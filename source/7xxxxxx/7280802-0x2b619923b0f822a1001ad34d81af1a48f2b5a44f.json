{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title MerkleProof\r\n * @dev Merkle proof verification based on\r\n * https://github.com/ameensol/merkle-tree-solidity/blob/master/src/MerkleProof.sol\r\n */\r\nlibrary MerkleProof {\r\n  /**\r\n   * @dev Verifies a Merkle proof proving the existence of a leaf in a Merkle tree. Assumes that each pair of leaves\r\n   * and each pair of pre-images are sorted.\r\n   * @param proof Merkle proof containing sibling hashes on the branch from the leaf to the root of the Merkle tree\r\n   * @param root Merkle root\r\n   * @param leaf Leaf of Merkle tree\r\n   */\r\n  function verify(\r\n    bytes32[] memory proof,\r\n    bytes32 root,\r\n    bytes32 leaf\r\n  )\r\n    internal\r\n    pure\r\n    returns (bool)\r\n  {\r\n    bytes32 computedHash = leaf;\r\n\r\n    for (uint256 i = 0; i < proof.length; i++) {\r\n      bytes32 proofElement = proof[i];\r\n\r\n      if (computedHash < proofElement) {\r\n        // Hash(current computed hash + current element of the proof)\r\n        computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n      } else {\r\n        // Hash(current element of the proof + current computed hash)\r\n        computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n      }\r\n    }\r\n\r\n    // Check if the computed hash (root) is equal to the provided root\r\n    return computedHash == root;\r\n  }\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n}\r\n\r\n/**\r\n * @title MerkleProof\r\n * @dev Merkle proof verification based on\r\n * https://github.com/ameensol/merkle-tree-solidity/blob/master/src/MerkleProof.sol\r\n */\r\ncontract MerkleProofAirdrop {\r\n  event Drop(string ipfs, address indexed rec, uint amount);\r\n\r\n  struct Airdrop {\r\n    address owner;\r\n    bytes32 root;\r\n    address tokenAddress;\r\n    uint total;\r\n    uint claimed;\r\n    mapping(address => bool) claimedRecipients;\r\n  }\r\n\r\n  mapping(bytes32 => Airdrop) public airdrops;\r\n  address payable public owner;\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function createNewAirdrop(\r\n      bytes32 _root,\r\n      address _tokenAddress,\r\n      uint _total,\r\n      string memory _ipfs\r\n    ) public payable {\r\n    require(msg.value >= 0.2 ether);\r\n    bytes32 ipfsHash = keccak256(abi.encodePacked(_ipfs));\r\n    IERC20 token = IERC20(_tokenAddress);\r\n    require(token.allowance(msg.sender, address(this)) >= _total, \"this contract must be allowed to spend tokens\");\r\n\r\n    airdrops[ipfsHash] = Airdrop({\r\n      owner: msg.sender,\r\n      root: _root,\r\n      tokenAddress: _tokenAddress,\r\n      total: _total,\r\n      claimed: 0\r\n    });\r\n    owner.transfer(address(this).balance);\r\n  }\r\n\r\n  function cancelAirdrop(string memory _ipfs) public {\r\n    bytes32 ipfsHash = keccak256(abi.encodePacked(_ipfs));\r\n    Airdrop storage airdrop = airdrops[ipfsHash];\r\n    require(msg.sender == airdrop.owner);\r\n    uint left = airdrop.total - airdrop.claimed;\r\n    require(left > 0);\r\n\r\n    IERC20 token = IERC20(airdrop.tokenAddress);\r\n    require(token.balanceOf(address(this)) >= left, \"not enough tokens\");\r\n    token.transfer(msg.sender, left);\r\n\r\n  }\r\n\r\n  function drop(bytes32[] memory proof, address _recipient, uint256 _amount, string memory _ipfs) public {\r\n    bytes32 hash = keccak256(abi.encode(_recipient, _amount));\r\n    bytes32 leaf = keccak256(abi.encode(hash));\r\n    bytes32 ipfsHash = keccak256(abi.encodePacked(_ipfs));\r\n    Airdrop storage airdrop = airdrops[ipfsHash];\r\n\r\n    require(verify(proof, airdrop.root, leaf));\r\n    require(airdrop.claimedRecipients[_recipient] == false, \"double spend\");\r\n    airdrop.claimedRecipients[_recipient] = true;\r\n    airdrop.claimed += _amount;\r\n\r\n    IERC20 token = IERC20(airdrop.tokenAddress);\r\n    require(token.allowance(airdrop.owner, address(this)) >= _amount, \"this contract must be allowed to spend tokens\");\r\n    token.transferFrom(airdrop.owner, _recipient, _amount);\r\n\r\n    // transfer tokens\r\n    emit Drop(_ipfs, _recipient, _amount);\r\n  }\r\n\r\n  function verify(\r\n    bytes32[] memory proof,\r\n    bytes32 root,\r\n    bytes32 leaf\r\n  )\r\n    public\r\n    pure\r\n    returns (bool)\r\n  {\r\n    return MerkleProof.verify(proof, root, leaf);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_root\",\"type\":\"bytes32\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_total\",\"type\":\"uint256\"},{\"name\":\"_ipfs\",\"type\":\"string\"}],\"name\":\"createNewAirdrop\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ipfs\",\"type\":\"string\"}],\"name\":\"cancelAirdrop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"name\":\"root\",\"type\":\"bytes32\"},{\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"verify\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_ipfs\",\"type\":\"string\"}],\"name\":\"drop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"airdrops\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"root\",\"type\":\"bytes32\"},{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"total\",\"type\":\"uint256\"},{\"name\":\"claimed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ipfs\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"rec\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Drop\",\"type\":\"event\"}]","ContractName":"MerkleProofAirdrop","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c608fea68138ebf3c8357e561c23c92a9aaa349008f657106ceda0957dd23d38"}]}