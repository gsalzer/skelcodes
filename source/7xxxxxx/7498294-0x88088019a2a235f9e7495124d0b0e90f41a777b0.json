{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.6;\r\n\r\n/**\r\n *\r\n * @author Alejandro Diaz <Alejandro.Diaz.666@protonmail.com>\r\n *\r\n * Overview:\r\n * This is an implimentation of a multi-dividend-paying token. the token supports income/dividends\r\n * of Eth and also Dai. A fixed number of tokens are minted in the constructor, and initially owned\r\n * by the contract owner. Dividends are awarded token holders thusly:\r\n *\r\n *   previous_due + [ p(x) * t(x)/N ] + [ p(x+1) * t(x+1)/N ] + ...\r\n *   where p(x) is the x'th income payment received by the contract\r\n *         t(x) is the number of tokens held by the token-holder at the time of p(x)\r\n *         N    is the total number of tokens, which never changes\r\n *\r\n * assume that t(x) takes on 3 values, t(a), t(b) and t(c), at times a, b, and c;\r\n * and that there are multiple payments at times between a and b: x, x+1, x+2...\r\n * and multiple payments at times between b and c: y, x+y, y+2...\r\n * and multiple payments at times greater than c: z, z+y, z+2...\r\n * then factoring:\r\n *\r\n *   current_due = { (t(a) * [p(x) + p(x+1)]) ... + (t(a) * [p(x) + p(y-1)]) ... +\r\n *                   (t(b) * [p(y) + p(y+1)]) ... + (t(b) * [p(y) + p(z-1)]) ... +\r\n *                   (t(c) * [p(z) + p(z+1)]) ... + (t(c) * [p(z) + p(now)]) } / N\r\n *\r\n * or\r\n *\r\n *   current_due = { (t(a) * period_a_income) +\r\n *                   (t(b) * period_b_income) +\r\n *                   (t(c) * period_c_income) } / N\r\n *\r\n * if we designate current_due * N as current-points, then\r\n *\r\n *   currentPoints = {  (t(a) * period_a_income) +\r\n *                      (t(b) * period_b_income) +\r\n *                      (t(c) * period_c_income) }\r\n *\r\n * or more succictly, if we recompute current points before a token-holder's number of\r\n * tokens, T, is about to change:\r\n *\r\n *   currentPoints = previous_points + (T * current-period-income)\r\n *\r\n * when we want to do a payout, we'll calculate:\r\n *  current_due = current-points / N\r\n *\r\n * we'll keep track of a token-holder's current-period-points, which is:\r\n *   T * current-period-income\r\n * by taking a snapshot of income collected exactly when the current period began; that is, the when the\r\n * number of tokens last changed. that is, we keep a running count of total income received\r\n *\r\n *   totalIncomeReceived = p(x) + p(x+1) + p(x+2)\r\n *\r\n * (which happily is the same for all token holders) then, before any token holder changes their number of\r\n * tokens we compute (for that token holder):\r\n *\r\n *  function calcCurPointsForAcct(acct) {\r\n *    currentPoints[acct] += (totalIncomeReceived - lastSnapshot[acct]) * T[acct]\r\n *    lastSnapshot[acct] = totalIncomeReceived\r\n *  }\r\n *\r\n * in the withdraw fcn, all we need is:\r\n *\r\n *  function withdraw(acct) {\r\n *    calcCurPointsForAcct(acct);\r\n *    current_amount_due = currentPoints[acct] / N\r\n *    currentPoints[acct] = 0;\r\n *    send(current_amount_due);\r\n *  }\r\n *\r\n */\r\n//import './SafeMath.sol';\r\n/*\r\n    Overflow protected math functions\r\n*/\r\ncontract SafeMath {\r\n    /**\r\n        constructor\r\n    */\r\n    constructor() public {\r\n    }\r\n\r\n    /**\r\n        @dev returns the sum of _x and _y, asserts if the calculation overflows\r\n\r\n        @param _x   value 1\r\n        @param _y   value 2\r\n\r\n        @return sum\r\n    */\r\n    function safeAdd(uint256 _x, uint256 _y) pure internal returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        assert(z >= _x);\r\n        return z;\r\n    }\r\n\r\n    /**\r\n        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\r\n\r\n        @param _x   minuend\r\n        @param _y   subtrahend\r\n\r\n        @return difference\r\n    */\r\n    function safeSub(uint256 _x, uint256 _y) pure internal returns (uint256) {\r\n        assert(_x >= _y);\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\r\n\r\n        @param _x   factor 1\r\n        @param _y   factor 2\r\n\r\n        @return product\r\n    */\r\n    function safeMul(uint256 _x, uint256 _y) pure internal returns (uint256) {\r\n        uint256 z = _x * _y;\r\n        assert(_x == 0 || z / _x == _y);\r\n        return z;\r\n    }\r\n}\r\n\r\n//import './iERC20Token.sol';\r\n// Token standard API\r\n// https://github.com/ethereum/EIPs/issues/20\r\ncontract iERC20Token {\r\n  function balanceOf( address who ) public view returns (uint value);\r\n  function allowance( address owner, address spender ) public view returns (uint remaining);\r\n  function transfer( address to, uint value) public returns (bool ok);\r\n  function transferFrom( address from, address to, uint value) public returns (bool ok);\r\n  function approve( address spender, uint value ) public returns (bool ok);\r\n  event Transfer( address indexed from, address indexed to, uint value);\r\n  event Approval( address indexed owner, address indexed spender, uint value);\r\n  //these are implimented via automatic getters\r\n  //function name() public view returns (string _name);\r\n  //function symbol() public view returns (string _symbol);\r\n  //function decimals() public view returns (uint8 _decimals);\r\n  //function totalSupply() public view returns (uint256 _totalSupply);\r\n}\r\n\r\n//import './iDividendToken.sol';\r\n// simple interface for withdrawing dividends\r\ncontract iDividendToken {\r\n  function checkDividends(address _addr) view public returns(uint _ethAmount, uint _daiAmount);\r\n  function withdrawEthDividends() public returns (uint _amount);\r\n  function withdrawDaiDividends() public returns (uint _amount);\r\n}\r\n\r\ncontract ETT is iERC20Token, iDividendToken, SafeMath {\r\n\r\n  event Transfer(address indexed from, address indexed to, uint amount);\r\n  event Approval(address indexed from, address indexed to, uint amount);\r\n\r\n  struct tokenHolder {\r\n    uint tokens;           // num tokens currently held in this acct, aka balance\r\n    uint currentEthPoints; // updated before token balance changes, or before a withdrawal. credit for owning tokens\r\n    uint lastEthSnapshot;  // snapshot of global TotalPoints (Eth), last time we updated this acct's currentEthPoints\r\n    uint currentDaiPoints; // updated before token balance changes, or before a withdrawal. credit for owning tokens\r\n    uint lastDaiSnapshot;  // snapshot of global TotalPoints (Dai), last time we updated this acct's currentDaiPoints\r\n  }\r\n\r\n  bool    public isLocked;\r\n  uint8   public decimals;\r\n  address public daiToken;\r\n  string  public symbol;\r\n  string  public name;\r\n  uint public    totalSupply;                                       // total token supply. never changes\r\n  uint public    holdoverEthBalance;                                // funds received, but not yet distributed\r\n  uint public    totalEthReceived;\r\n  uint public    holdoverDaiBalance;                                // funds received, but not yet distributed\r\n  uint public    totalDaiReceived;\r\n\r\n  mapping (address => mapping (address => uint)) private approvals; //transfer approvals, from -> to -> amount\r\n  mapping (address => tokenHolder) public tokenHolders;\r\n\r\n\r\n  //\r\n  //constructor\r\n  //\r\n  constructor(address _daiToken, uint256 _tokenSupply, uint8 _decimals, string memory _name, string memory _symbol) public {\r\n    daiToken = _daiToken;\r\n    totalSupply = _tokenSupply;\r\n    decimals = _decimals;\r\n    name = _name;\r\n    symbol = _symbol;\r\n    tokenHolders[msg.sender].tokens = totalSupply;\r\n    emit Transfer(address(0), msg.sender, totalSupply);\r\n  }\r\n\r\n\r\n  //\r\n  // ERC-20\r\n  //\r\n\r\n\r\n  //\r\n  // transfer tokens to a specified address\r\n  // @param to the address to transfer to.\r\n  // @param value the amount to be transferred.\r\n  // checks for overflow, sufficient tokens to xfer are in internal _transfer fcn\r\n  //\r\n  function transfer(address _to, uint _value) public returns (bool success) {\r\n    _transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n\r\n  //\r\n  // transfer tokens from one address to another.\r\n  // note that while this function emits an Approval event, this is not required as per the specification,\r\n  // and other compliant implementations may not emit the event.\r\n  // @param from address the address which you want to send tokens from\r\n  // @param to address the address which you want to transfer to\r\n  // @param value uint256 the amount of tokens to be transferred\r\n  // checks for overflow, sufficient tokens to xfer are in internal _transfer fcn\r\n  // check for sufficient approval in in the safeSub\r\n  //\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    _transfer(_from, _to, _value);\r\n    _approve(_from, msg.sender, safeSub(approvals[_from][msg.sender], _value));\r\n    return true;\r\n  }\r\n\r\n\r\n  //\r\n  // internal fcn to execute a transfer. no check/modification of approval here\r\n  // wrap of token balances is prevented in safe{Add,Sub}\r\n  //\r\n  function _transfer(address _from, address _to, uint _value) internal {\r\n    require(_to != address(0));\r\n    //first credit source acct with points accrued so far.. must do this before number of held tokens changes\r\n    calcCurPointsForAcct(_from);\r\n    tokenHolders[_from].tokens = safeSub(tokenHolders[_from].tokens, _value);\r\n    //if destination is a new tokenholder then we are setting his \"last\" snapshot to the current totalPoints\r\n    if (tokenHolders[_to].lastEthSnapshot == 0)\r\n      tokenHolders[_to].lastEthSnapshot = totalEthReceived;\r\n    if (tokenHolders[_to].lastDaiSnapshot == 0)\r\n      tokenHolders[_to].lastDaiSnapshot = totalDaiReceived;\r\n    //credit destination acct with points accrued so far.. must do this before number of held tokens changes\r\n    calcCurPointsForAcct(_to);\r\n    tokenHolders[_to].tokens = safeAdd(tokenHolders[_to].tokens, _value);\r\n    emit Transfer(_from, _to, _value);\r\n  }\r\n\r\n\r\n  function balanceOf(address _owner) public view returns (uint balance) {\r\n    balance = tokenHolders[_owner].tokens;\r\n  }\r\n\r\n\r\n  //\r\n  // approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n  // beware that changing an allowance with this method brings the risk that someone may use both the old\r\n  // and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n  // race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n  // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n  // @param _spender the address which will spend the funds.\r\n  // @param _value the amount of tokens to be spent.\r\n  //\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    _approve(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n\r\n  //\r\n  // increase the amount of tokens that an owner allows to a spender.\r\n  // approve should be called when allowed[msg.sender][spender] == 0. to increment\r\n  // allowed value it is better to use this function to avoid 2 calls (and wait until\r\n  // the first transaction is mined)\r\n  // Emits an Approval event.\r\n  // @param _spender the address which will spend the funds.\r\n  // @param _addedValue the amount of tokens to increase the allowance by.\r\n  //\r\n  function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool) {\r\n    _approve(msg.sender, _spender, safeAdd(approvals[msg.sender][_spender], _addedValue));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * decrease the amount of tokens that an owner allows to a spender.\r\n   * approve should be called when allowed[msg.sender][spender] == 0. to decrement\r\n   * allowed value it is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * from MonolithDAO Token.sol\r\n   * emits an Approval event.\r\n   * @param _spender the address which will spend the funds.\r\n   * @param _subtractedValue the amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseAllowance(address _spender, uint256 _subtractedValue) public returns (bool) {\r\n    _approve(msg.sender, _spender, safeSub(approvals[msg.sender][_spender], _subtractedValue));\r\n    return true;\r\n  }\r\n\r\n\r\n  /*\r\n   * @dev internal fcn to approve an address to spend another addresses' tokens.\r\n   * @param _owner the address that owns the tokens.\r\n   * @param _spender the address that will spend the tokens.\r\n   * @param _value the number of tokens that can be spent.\r\n   */\r\n  function _approve(address _owner, address _spender, uint _value) internal {\r\n    require(_owner != address(0));\r\n    require(_spender != address(0));\r\n    approvals[_owner][_spender] = _value;\r\n    emit Approval(_owner, _spender, _value);\r\n  }\r\n\r\n\r\n  function allowance(address _owner, address _spender) public view returns (uint remaining) {\r\n    return approvals[_owner][_spender];\r\n  }\r\n\r\n  //\r\n  // END ERC20\r\n  //\r\n\r\n  //\r\n  // calc current points for a token holder; that is, points that are due to this token holder for all dividends\r\n  // received by the contract during the current \"period\". the period began the last time this fcn was called, at which\r\n  // time we updated the account's snapshot of the running point count, totalEthReceived. during the period the account's\r\n  // number of tokens must not have changed. so always call this fcn before changing the number of tokens.\r\n  //\r\n  function calcCurPointsForAcct(address _acct) internal {\r\n    uint256 _newEthPoints = safeMul(safeSub(totalEthReceived, tokenHolders[_acct].lastEthSnapshot), tokenHolders[_acct].tokens);\r\n    tokenHolders[_acct].currentEthPoints = safeAdd(tokenHolders[_acct].currentEthPoints, _newEthPoints);\r\n    tokenHolders[_acct].lastEthSnapshot = totalEthReceived;\r\n    uint256 _newDaiPoints = safeMul(safeSub(totalDaiReceived, tokenHolders[_acct].lastDaiSnapshot), tokenHolders[_acct].tokens);\r\n    tokenHolders[_acct].currentDaiPoints = safeAdd(tokenHolders[_acct].currentDaiPoints, _newDaiPoints);\r\n    tokenHolders[_acct].lastDaiSnapshot = totalDaiReceived;\r\n  }\r\n\r\n\r\n  //\r\n  // default payable function. funds receieved here become dividends.\r\n  //\r\n  function () external payable {\r\n    holdoverEthBalance = safeAdd(holdoverEthBalance, msg.value);\r\n    totalEthReceived = safeAdd(totalEthReceived, msg.value);\r\n  }\r\n\r\n\r\n  //\r\n  // this payable function is for payment in Dai\r\n  // caller must have already approved the Dai transfer\r\n  //\r\n  function payDai(uint256 _daiAmount) external {\r\n    require(iERC20Token(daiToken).transferFrom(msg.sender, address(this), _daiAmount), \"failed to transfer dai\");\r\n    holdoverDaiBalance = safeAdd(holdoverDaiBalance, _daiAmount);\r\n    totalDaiReceived = safeAdd(totalDaiReceived, _daiAmount);\r\n  }\r\n\r\n\r\n  //\r\n  // updateDaiBalance\r\n  // update the dia holdover balance, in case someone transfers dai directly\r\n  // to the contract. anyone can call this.\r\n  //\r\n  function updateDaiBalance() public {\r\n    uint256 _actBalance = iERC20Token(daiToken).balanceOf(address(this));\r\n    uint256 _daiAmount = safeSub(_actBalance, holdoverDaiBalance);\r\n    holdoverDaiBalance = safeAdd(holdoverDaiBalance, _daiAmount);\r\n    totalDaiReceived = safeAdd(totalDaiReceived, _daiAmount);\r\n  }\r\n\r\n\r\n  //\r\n  // check my dividends\r\n  //\r\n  function checkDividends(address _addr) view public returns(uint _ethAmount, uint _daiAmount) {\r\n    //don't call calcCurPointsForAcct here, cuz this is a constant fcn\r\n    uint _currentEthPoints = tokenHolders[_addr].currentEthPoints +\r\n      ((totalEthReceived - tokenHolders[_addr].lastEthSnapshot) * tokenHolders[_addr].tokens);\r\n    _ethAmount = _currentEthPoints / totalSupply;\r\n    uint _currentDaiPoints = tokenHolders[_addr].currentDaiPoints +\r\n      ((totalDaiReceived - tokenHolders[_addr].lastDaiSnapshot) * tokenHolders[_addr].tokens);\r\n    _daiAmount = _currentDaiPoints / totalSupply;\r\n  }\r\n\r\n\r\n  //\r\n  // withdraw my dividends\r\n  //\r\n  function withdrawEthDividends() public returns (uint _amount) {\r\n    calcCurPointsForAcct(msg.sender);\r\n    _amount = tokenHolders[msg.sender].currentEthPoints / totalSupply;\r\n    uint _pointsUsed = safeMul(_amount, totalSupply);\r\n    tokenHolders[msg.sender].currentEthPoints = safeSub(tokenHolders[msg.sender].currentEthPoints, _pointsUsed);\r\n    holdoverEthBalance = safeSub(holdoverEthBalance, _amount);\r\n    msg.sender.transfer(_amount);\r\n  }\r\n\r\n  function withdrawDaiDividends() public returns (uint _amount) {\r\n    calcCurPointsForAcct(msg.sender);\r\n    _amount = tokenHolders[msg.sender].currentDaiPoints / totalSupply;\r\n    uint _pointsUsed = safeMul(_amount, totalSupply);\r\n    tokenHolders[msg.sender].currentDaiPoints = safeSub(tokenHolders[msg.sender].currentDaiPoints, _pointsUsed);\r\n    holdoverDaiBalance = safeSub(holdoverDaiBalance, _amount);\r\n    require(iERC20Token(daiToken).transfer(msg.sender, _amount), \"failed to transfer dai\");\r\n  }\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"holdoverEthBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEthDividends\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkDividends\",\"outputs\":[{\"name\":\"_ethAmount\",\"type\":\"uint256\"},{\"name\":\"_daiAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenHolders\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"currentEthPoints\",\"type\":\"uint256\"},{\"name\":\"lastEthSnapshot\",\"type\":\"uint256\"},{\"name\":\"currentDaiPoints\",\"type\":\"uint256\"},{\"name\":\"lastDaiSnapshot\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"holdoverDaiBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_daiAmount\",\"type\":\"uint256\"}],\"name\":\"payDai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDaiReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateDaiBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDaiDividends\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"daiToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_daiToken\",\"type\":\"address\"},{\"name\":\"_tokenSupply\",\"type\":\"uint256\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ETT","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000089d24a6b4ccb1b6faa2625fe562bdd9a23260359000000000000000000000000000000000000000000422ca8b0a00a4250000000000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000057475726d73000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000374726d0000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://2b15bf1a75eec94377d2e43dfa992171158e555117366ea305a0b312bddb0c47"}]}