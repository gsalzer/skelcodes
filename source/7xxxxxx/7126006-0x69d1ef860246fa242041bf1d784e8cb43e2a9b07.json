{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.22 <0.6.0;\r\ncontract FiveForty {\r\n    \r\n// \"FiveForty\" investment contract\r\n// 5% daily up to 200% of invest\r\n// 10% marketing fee\r\n// 5% reward to referrer and refferal (need to have invest)\r\n//\r\n// Send ETH to make an invest\r\n// Send 0 ETH to payout\r\n// Recomended GAS LIMIT - 150 000\r\n//\r\n// ***WARNING*** \r\n// It's a \"Ponzi scheme\", you can lose your etherium\r\n// You need to send payout request EVERY 24 HOURS\r\n// Contract supports >0 transactions to payout, you can send up to 999 WEI to send payout request\r\n\r\nusing ToAddress for *;\r\nmapping (address => uint256) invested; // records amounts invested\r\nmapping (address => uint256) lastPaymentBlock; // records blocks at which last payment were made\r\nmapping (address => uint256) dailyPayment; // records estimated daily payment\r\nmapping (address => uint256) totalPaid; // records total paid\r\naddress payable constant fundAddress = 0x27FE767C1da8a69731c64F15d6Ee98eE8af62E72; // marketing fund address\r\n\r\nfunction () external payable {\r\n    if (msg.value >= 1000) { // receiving function\r\n        \r\n        fundAddress.transfer(msg.value / 10); // sending marketing fee\r\n        if (invested[msg.sender] == 0) {lastPaymentBlock[msg.sender] = block.number;} // starting timer of payments (once for address)\r\n        invested[msg.sender] += msg.value; // calculating all invests from address\r\n        \r\n        address refAddress = msg.data.toAddr();\r\n        if (invested[refAddress] != 0 && refAddress != msg.sender) { invested[refAddress] += msg.value/20; } // Referral bonus adds only to investors\r\n        invested[msg.sender] += msg.value/20; // Referral reward\r\n        \r\n        dailyPayment[msg.sender] = (invested[msg.sender] * 2 - totalPaid[msg.sender]) / 40; // calculating amount of daily payment (5% of invest)\r\n        \r\n    } else { // Payment function\r\n        \r\n        if (invested[msg.sender] * 2 > totalPaid[msg.sender] && // max profit = invest*2\r\n            block.number - lastPaymentBlock[msg.sender] > 5900) { // 24 hours from last payout\r\n                totalPaid[msg.sender] += dailyPayment[msg.sender]; // calculating all payouts\r\n                address payable sender = msg.sender; sender.transfer(dailyPayment[msg.sender]); // sending daily profit\r\n            }\r\n    }\r\n}\r\n\r\nfunction investorInfo(address addr) public view returns(uint totalInvested, uint pendingProfit,\r\nuint dailyProfit, uint minutesBeforeNextPayment, uint totalPayouts) { // helps to track investment\r\n  totalInvested = invested[addr];\r\n  pendingProfit = invested[addr] * 2 - totalPaid[addr];\r\n  dailyProfit = dailyPayment[addr];\r\n  uint time = 1440 - (block.number - lastPaymentBlock[addr]) / 4;\r\n  if (time >= 0) { minutesBeforeNextPayment = time; } else { minutesBeforeNextPayment = 0; }\r\n  totalPayouts = totalPaid[addr];\r\n}\r\n\r\n}\r\n\r\nlibrary ToAddress {\r\n  function toAddr(bytes memory source) internal pure returns(address payable addr) {\r\n    assembly { addr := mload(add(source,0x14)) }\r\n    return addr;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"investorInfo\",\"outputs\":[{\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"name\":\"pendingProfit\",\"type\":\"uint256\"},{\"name\":\"dailyProfit\",\"type\":\"uint256\"},{\"name\":\"minutesBeforeNextPayment\",\"type\":\"uint256\"},{\"name\":\"totalPayouts\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"FiveForty","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://fabafcfa71b21a6237c923f50f7191461e545d6469f88b2e6a889cd7454d49e1"}]}