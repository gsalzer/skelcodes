{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n *\r\n * @author Alejandro Diaz <Alejandro.Diaz.666@protonmail.com>\r\n *\r\n * Overview:\r\n * This is an implimentation of a dividend-paying token, with a special transfer from a holding address.\r\n * A fixed number of tokens are minted in the constructor, with some amount initially owned by the contract\r\n * owner; and some amount owned by a reserve address. The reserve address cannot transfer tokens to any\r\n * other address, except as directed by a trusted partner-contract.\r\n *\r\n * Dividends are awarded token holders following the technique outlined by Nick Johnson in\r\n *  https://medium.com/ @ weka/dividend-bearing-tokens-on-ethereum-42d01c710657\r\n *\r\n * The technique is:\r\n *   previous_due + [ p(x) * t(x)/N ] + [ p(x+1) * t(x+1)/N ] + ...\r\n *   where p(x) is the x'th income payment received by the contract\r\n *         t(x) is the number of tokens held by the token-holder at the time of p(x)\r\n *         N    is the total number of tokens, which never changes\r\n *\r\n * assume that t(x) takes on 3 values, t(a), t(b) and t(c), at times a, b, and c;\r\n * and that there are multiple payments at times between a and b: x, x+1, x+2...\r\n * and multiple payments at times between b and c: y, x+y, y+2...\r\n * and multiple payments at times greater than c: z, z+y, z+2...\r\n * then factoring:\r\n *\r\n *   current_due = { (t(a) * [p(x) + p(x+1)]) ... + (t(a) * [p(x) + p(y-1)]) ... +\r\n *                   (t(b) * [p(y) + p(y+1)]) ... + (t(b) * [p(y) + p(z-1)]) ... +\r\n *                   (t(c) * [p(z) + p(z+1)]) ... + (t(c) * [p(z) + p(now)]) } / N\r\n *\r\n * or\r\n *\r\n *   current_due = { (t(a) * period_a_income) +\r\n *                   (t(b) * period_b_income) +\r\n *                   (t(c) * period_c_income) } / N\r\n *\r\n * if we designate current_due * N as current-points, then\r\n *\r\n *   currentPoints = {  (t(a) * period_a_income) +\r\n *                      (t(b) * period_b_income) +\r\n *                      (t(c) * period_c_income) }\r\n *\r\n * or more succictly, if we recompute current points before a token-holder's number of\r\n * tokens, T, is about to change:\r\n *\r\n *   currentPoints = previous_points + (T * current-period-income)\r\n *\r\n * when we want to do a payout, we'll calculate:\r\n *  current_due = current-points / N\r\n *\r\n * we'll keep track of a token-holder's current-period-points, which is:\r\n *   T * current-period-income\r\n * by taking a snapshot of income collected exactly when the current period began; that is, the when the\r\n * number of tokens last changed. that is, we keep a running count of total income received\r\n *\r\n *   totalIncomeReceived = p(x) + p(x+1) + p(x+2)\r\n *\r\n * (which happily is the same for all token holders) then, before any token holder changes their number of\r\n * tokens we compute (for that token holder):\r\n *\r\n *  function calcCurPointsForAcct(acct) {\r\n *    currentPoints[acct] += (totalIncomeReceived - lastSnapshot[acct]) * T[acct]\r\n *    lastSnapshot[acct] = totalIncomeReceived\r\n *  }\r\n *\r\n * in the withdraw fcn, all we need is:\r\n *\r\n *  function withdraw(acct) {\r\n *    calcCurPointsForAcct(acct);\r\n *    current_amount_due = currentPoints[acct] / N\r\n *    currentPoints[acct] = 0;\r\n *    send(current_amount_due);\r\n *  }\r\n *\r\n */\r\n//import './SafeMath.sol';\r\n/*\r\n    Overflow protected math functions\r\n*/\r\ncontract SafeMath {\r\n    /**\r\n        constructor\r\n    */\r\n    constructor() public {\r\n    }\r\n\r\n    /**\r\n        @dev returns the sum of _x and _y, asserts if the calculation overflows\r\n\r\n        @param _x   value 1\r\n        @param _y   value 2\r\n\r\n        @return sum\r\n    */\r\n    function safeAdd(uint256 _x, uint256 _y) pure internal returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        assert(z >= _x);\r\n        return z;\r\n    }\r\n\r\n    /**\r\n        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\r\n\r\n        @param _x   minuend\r\n        @param _y   subtrahend\r\n\r\n        @return difference\r\n    */\r\n    function safeSub(uint256 _x, uint256 _y) pure internal returns (uint256) {\r\n        assert(_x >= _y);\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\r\n\r\n        @param _x   factor 1\r\n        @param _y   factor 2\r\n\r\n        @return product\r\n    */\r\n    function safeMul(uint256 _x, uint256 _y) pure internal returns (uint256) {\r\n        uint256 z = _x * _y;\r\n        assert(_x == 0 || z / _x == _y);\r\n        return z;\r\n    }\r\n}\r\n\r\n//import './iERC20Token.sol';\r\n// Token standard API\r\n// https://github.com/ethereum/EIPs/issues/20\r\ncontract iERC20Token {\r\n  function balanceOf( address who ) public view returns (uint value);\r\n  function allowance( address owner, address spender ) public view returns (uint remaining);\r\n\r\n  function transfer( address to, uint value) public returns (bool ok);\r\n  function transferFrom( address from, address to, uint value) public returns (bool ok);\r\n  function approve( address spender, uint value ) public returns (bool ok);\r\n\r\n  event Transfer( address indexed from, address indexed to, uint value);\r\n  event Approval( address indexed owner, address indexed spender, uint value);\r\n\r\n  //these are implimented via automatic getters\r\n  //function name() public view returns (string _name);\r\n  //function symbol() public view returns (string _symbol);\r\n  //function decimals() public view returns (uint8 _decimals);\r\n  //function totalSupply() public view returns (uint256 _totalSupply);\r\n}\r\n\r\n//import './iDividendToken.sol';\r\n// simple interface for withdrawing dividends\r\ncontract iDividendToken {\r\n  function checkDividends(address _addr) view public returns(uint _ethAmount);\r\n  function withdrawDividends() public returns (uint _amount);\r\n}\r\n\r\n//import './iPlpPointsRedeemer.sol';\r\n// interface for redeeming PLP Points\r\ncontract iPlpPointsRedeemer {\r\n  function reserveTokens() public view returns (uint remaining);\r\n  function transferFromReserve(address _to, uint _value) public;\r\n}\r\n\r\ncontract PirateLotteryProfitToken is iERC20Token, iDividendToken, iPlpPointsRedeemer, SafeMath {\r\n\r\n  event PaymentEvent(address indexed from, uint amount);\r\n  event TransferEvent(address indexed from, address indexed to, uint amount);\r\n  event ApprovalEvent(address indexed from, address indexed to, uint amount);\r\n\r\n  struct tokenHolder {\r\n    uint tokens;           // num tokens currently held in this acct, aka balance\r\n    uint currentPoints;    // updated before token balance changes, or before a withdrawal. credit for owning tokens\r\n    uint lastSnapshot;     // snapshot of global TotalPoints, last time we updated this acct's currentPoints\r\n  }\r\n\r\n  bool    public isLocked;\r\n  uint8   public decimals;\r\n  string  public symbol;\r\n  string  public name;\r\n  address payable public owner;\r\n  address payable public reserve;            // reserve account\r\n  uint256 public  totalSupply;               // total token supply. never changes\r\n  uint256 public  holdoverBalance;           // funds received, but not yet distributed\r\n  uint256 public  totalReceived;\r\n\r\n  mapping (address => mapping (address => uint)) approvals;  //transfer approvals, from -> to\r\n  mapping (address => tokenHolder) public tokenHolders;\r\n  mapping (address => bool) public trusted;\r\n\r\n\r\n  //\r\n  // modifiers\r\n  //\r\n  modifier ownerOnly {\r\n    require(msg.sender == owner, \"owner only\");\r\n    _;\r\n  }\r\n  modifier unlockedOnly {\r\n    require(!isLocked, \"unlocked only\");\r\n    _;\r\n  }\r\n  modifier notReserve {\r\n    require(msg.sender != reserve, \"reserve is barred\");\r\n    _;\r\n  }\r\n  modifier trustedOnly {\r\n    require(trusted[msg.sender] == true, \"trusted only\");\r\n    _;\r\n  }\r\n  //this is to protect from short-address attack. use this to verify size of args, especially when an address arg preceeds\r\n  //a value arg. see: https://www.reddit.com/r/ethereum/comments/63s917/worrysome_bug_exploit_with_erc20_token/dfwmhc3/\r\n  modifier onlyPayloadSize(uint256 size) {\r\n    assert(msg.data.length >= size + 4);\r\n    _;\r\n  }\r\n\r\n  //\r\n  //constructor\r\n  //\r\n  constructor(uint256 _totalSupply, uint256 _reserveSupply, address payable _reserve, uint8 _decimals, string memory _name, string memory _symbol) public {\r\n    totalSupply = _totalSupply;\r\n    reserve = _reserve;\r\n    decimals = _decimals;\r\n    name = _name;\r\n    symbol = _symbol;\r\n    owner = msg.sender;\r\n    tokenHolders[reserve].tokens = _reserveSupply;\r\n    tokenHolders[owner].tokens = safeSub(totalSupply, _reserveSupply);\r\n  }\r\n\r\n  function setTrust(address _trustedAddr, bool _trust) public ownerOnly unlockedOnly {\r\n    trusted[_trustedAddr] = _trust;\r\n  }\r\n\r\n  function lock() public ownerOnly {\r\n    isLocked = true;\r\n  }\r\n\r\n\r\n  //\r\n  // ERC-20\r\n  //\r\n  function transfer(address _to, uint _value) public onlyPayloadSize(2*32) notReserve returns (bool success) {\r\n    if (tokenHolders[msg.sender].tokens >= _value) {\r\n      //first credit sender with points accrued so far.. must do this before number of held tokens changes\r\n      calcCurPointsForAcct(msg.sender);\r\n      tokenHolders[msg.sender].tokens = safeSub(tokenHolders[msg.sender].tokens, _value);\r\n      //if destination is a new tokenholder then we are setting his \"last\" snapshot to the current totalPoints\r\n      if (tokenHolders[_to].lastSnapshot == 0)\r\n        tokenHolders[_to].lastSnapshot = totalReceived;\r\n      //credit destination acct with points accrued so far.. must do this before number of held tokens changes\r\n      calcCurPointsForAcct(_to);\r\n      tokenHolders[_to].tokens = safeAdd(tokenHolders[_to].tokens, _value);\r\n      emit TransferEvent(msg.sender, _to, _value);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n\r\n  // transfer from reserve is prevented by preventing reserve from generating approval\r\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3*32) public returns (bool success) {\r\n    //prevent wrap:\r\n    if (tokenHolders[_from].tokens >= _value && approvals[_from][msg.sender] >= _value) {\r\n      //first credit source acct with points accrued so far.. must do this before number of held tokens changes\r\n      calcCurPointsForAcct(_from);\r\n      tokenHolders[_from].tokens = safeSub(tokenHolders[_from].tokens, _value);\r\n      //if destination is a new tokenreserve then we are setting his \"last\" snapshot to the current totalPoints\r\n      if (tokenHolders[_to].lastSnapshot == 0)\r\n        tokenHolders[_to].lastSnapshot = totalReceived;\r\n      //credit destination acct with points accrued so far.. must do this before number of held tokens changes\r\n      calcCurPointsForAcct(_to);\r\n      tokenHolders[_to].tokens = safeAdd(tokenHolders[_to].tokens, _value);\r\n      approvals[_from][msg.sender] = safeSub(approvals[_from][msg.sender], _value);\r\n      emit TransferEvent(_from, _to, _value);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n\r\n  function balanceOf(address _owner) public view returns (uint balance) {\r\n    balance = tokenHolders[_owner].tokens;\r\n  }\r\n\r\n\r\n  function approve(address _spender, uint _value) public onlyPayloadSize(2*32) notReserve returns (bool success) {\r\n    approvals[msg.sender][_spender] = _value;\r\n    emit ApprovalEvent(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n\r\n  function allowance(address _owner, address _spender) public view returns (uint remaining) {\r\n    return approvals[_owner][_spender];\r\n  }\r\n\r\n  //\r\n  // END ERC20\r\n  //\r\n\r\n\r\n  //\r\n  // iTransferPointsRedeemer\r\n  //\r\n  function reserveTokens() public view returns (uint remaining) {\r\n    return tokenHolders[reserve].tokens;\r\n  }\r\n\r\n\r\n  //\r\n  // transfer from reserve, initiated from a trusted partner-contract\r\n  //\r\n  function transferFromReserve(address _to, uint _value) onlyPayloadSize(2*32) public trustedOnly {\r\n    require(_value >= 10 || tokenHolders[reserve].tokens < 10, \"minimum redmption is 10 tokens\");\r\n    require(tokenHolders[reserve].tokens >= _value, \"reserve has insufficient tokens\");\r\n    //first credit source acct with points accrued so far.. must do this before number of held tokens changes\r\n    calcCurPointsForAcct(reserve);\r\n    tokenHolders[reserve].tokens = safeSub(tokenHolders[reserve].tokens, _value);\r\n    //if destination is a new tokenholder then we are setting his \"last\" snapshot to the current totalPoints\r\n    if (tokenHolders[_to].lastSnapshot == 0)\r\n      tokenHolders[_to].lastSnapshot = totalReceived;\r\n    //credit destination acct with points accrued so far.. must do this before number of held tokens changes\r\n    calcCurPointsForAcct(_to);\r\n    tokenHolders[_to].tokens = safeAdd(tokenHolders[_to].tokens, _value);\r\n    emit TransferEvent(reserve, _to, _value);\r\n  }\r\n\r\n\r\n  //\r\n  // calc current points for a token holder; that is, points that are due to this token holder for all dividends\r\n  // received by the contract during the current \"period\". the period began the last time this fcn was called, at which\r\n  // time we updated the account's snapshot of the running point count, totalReceived. during the period the account's\r\n  // number of tokens must not have changed. so always call this fcn before changing the number of tokens.\r\n  //\r\n  function calcCurPointsForAcct(address _acct) internal {\r\n    uint256 _newPoints = safeMul(safeSub(totalReceived, tokenHolders[_acct].lastSnapshot), tokenHolders[_acct].tokens);\r\n    tokenHolders[_acct].currentPoints = safeAdd(tokenHolders[_acct].currentPoints, _newPoints);\r\n    tokenHolders[_acct].lastSnapshot = totalReceived;\r\n  }\r\n\r\n\r\n  //\r\n  // default payable function. funds receieved here become dividends.\r\n  //\r\n  function () external payable {\r\n    holdoverBalance = safeAdd(holdoverBalance, msg.value);\r\n    totalReceived = safeAdd(totalReceived, msg.value);\r\n  }\r\n\r\n\r\n  //\r\n  // check my dividends\r\n  //\r\n  function checkDividends(address _addr) view public returns(uint _amount) {\r\n    //don't call calcCurPointsForAcct here, cuz this is a constant fcn\r\n    uint _currentPoints = tokenHolders[_addr].currentPoints +\r\n      ((totalReceived - tokenHolders[_addr].lastSnapshot) * tokenHolders[_addr].tokens);\r\n    _amount = _currentPoints / totalSupply;\r\n  }\r\n\r\n\r\n  //\r\n  // withdraw my dividends\r\n  //\r\n  function withdrawDividends() public returns (uint _amount) {\r\n    calcCurPointsForAcct(msg.sender);\r\n    _amount = tokenHolders[msg.sender].currentPoints / totalSupply;\r\n    uint _pointsUsed = safeMul(_amount, totalSupply);\r\n    tokenHolders[msg.sender].currentPoints = safeSub(tokenHolders[msg.sender].currentPoints, _pointsUsed);\r\n    holdoverBalance = safeSub(holdoverBalance, _amount);\r\n    msg.sender.transfer(_amount);\r\n  }\r\n\r\n\r\n  //only available before the contract is locked\r\n  function killContract() public ownerOnly unlockedOnly {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFromReserve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"killContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkDividends\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveTokens\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDividends\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenHolders\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"currentPoints\",\"type\":\"uint256\"},{\"name\":\"lastSnapshot\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"trusted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_trustedAddr\",\"type\":\"address\"},{\"name\":\"_trust\",\"type\":\"bool\"}],\"name\":\"setTrust\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserve\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"holdoverBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"name\":\"_reserveSupply\",\"type\":\"uint256\"},{\"name\":\"_reserve\",\"type\":\"address\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaymentEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ApprovalEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"PirateLotteryProfitToken","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000047868c00000000000000000000000000000000000000000000000000000000002faf0800000000000000000000000003b66698c45b8f169e5b549a3298e1b9bc6ddfecf000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000001b506972617465204c6f74746572792050726f66697420546f6b656e00000000000000000000000000000000000000000000000000000000000000000000000003504c500000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://22b62f6f7b42038f310ece2b942198b15a1812ac75b20dc31c36d6aea0e0e3c8"}]}