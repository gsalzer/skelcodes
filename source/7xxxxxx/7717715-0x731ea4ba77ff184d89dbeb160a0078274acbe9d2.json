{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.8;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://eips.ethereum.org/EIPS/eip-20\r\n * Originally based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n *\r\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\r\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\r\n * compliant implementations may not do it.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev Total number of tokens in existence\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param owner The address to query the balance of.\r\n     * @return A uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token to a specified address\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        _transfer(from, to, value);\r\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified addresses\r\n     * @param from The address to transfer from.\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0));\r\n\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that mints an amount of the token and assigns it to\r\n     * an account. This encapsulates the modification of balances such that the\r\n     * proper events are emitted.\r\n     * @param account The account that will receive the created tokens.\r\n     * @param value The amount that will be created.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.add(value);\r\n        _balances[account] = _balances[account].add(value);\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account.\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve an address to spend another addresses' tokens.\r\n     * @param owner The address that owns the tokens.\r\n     * @param spender The address that will spend the tokens.\r\n     * @param value The number of tokens that can be spent.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(spender != address(0));\r\n        require(owner != address(0));\r\n\r\n        _allowed[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account, deducting from the sender's allowance for said account. Uses the\r\n     * internal burn function.\r\n     * Emits an Approval event (reflecting the reduced allowance).\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burnFrom(address account, uint256 value) internal {\r\n        _burn(account, value);\r\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\r\n    }\r\n}\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract Claimable {\r\n    address private _pendingOwner;\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier throws if called by any account other than the pendingOwner.\r\n    */\r\n    modifier onlyPendingOwner() {\r\n      require(msg.sender == _pendingOwner);\r\n      _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to set the pendingOwner address.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n      _pendingOwner = newOwner;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the pendingOwner address to finalize the transfer.\r\n    */\r\n    function claimOwnership() onlyPendingOwner public {\r\n      emit OwnershipTransferred(_owner, _pendingOwner);\r\n      _owner = _pendingOwner;\r\n      _pendingOwner = address(0);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the average of two numbers. Since these are integers,\r\n     * averages of an even and odd number cannot be represented, and will be\r\n     * rounded down.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n/// @notice Implements safeTransfer, safeTransferFrom and\r\n/// safeApprove for CompatibleERC20.\r\n///\r\n/// See https://github.com/ethereum/solidity/issues/4116\r\n///\r\n/// This library allows interacting with ERC20 tokens that implement any of\r\n/// these interfaces:\r\n///\r\n/// (1) transfer returns true on success, false on failure\r\n/// (2) transfer returns true on success, reverts on failure\r\n/// (3) transfer returns nothing on success, reverts on failure\r\n///\r\n/// Additionally, safeTransferFromWithFees will return the final token\r\n/// value received after accounting for token fees.\r\n\r\nlibrary CompatibleERC20Functions {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /// @notice Calls transferFrom on the token, reverts if the call fails and\r\n    /// returns the value transferred after fees.\r\n    function safeTransferFromWithFees(IERC20 token, address from, address to, uint256 value) internal returns (uint256) {\r\n        uint256 balancesBefore = token.balanceOf(to);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n        require(previousReturnValue(), \"transferFrom failed\");\r\n        uint256 balancesAfter = token.balanceOf(to);\r\n        return Math.min(value, balancesAfter.sub(balancesBefore));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0));\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must equal true).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n\r\n        require(address(token).isContract());\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success);\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            require(abi.decode(returndata, (bool)));\r\n        }\r\n    }\r\n\r\n    /// @notice Checks the return value of the previous function. Returns true\r\n    /// if the previous function returned 32 non-zero bytes or returned zero\r\n    /// bytes.\r\n    function previousReturnValue() private pure returns (bool)\r\n    {\r\n        uint256 returnData = 0;\r\n\r\n        assembly { /* solium-disable-line security/no-inline-assembly */\r\n            // Switch on the number of bytes returned by the previous call\r\n            switch returndatasize\r\n\r\n            // 0 bytes: ERC20 of type (3), did not throw\r\n            case 0 {\r\n                returnData := 1\r\n            }\r\n\r\n            // 32 bytes: ERC20 of types (1) or (2)\r\n            case 32 {\r\n                // Copy the return data into scratch space\r\n                returndatacopy(0, 0, 32)\r\n\r\n                // Load  the return data into returnData\r\n                returnData := mload(0)\r\n            }\r\n\r\n            // Other return size: return false\r\n            default { }\r\n        }\r\n\r\n        return returnData != 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20Detailed token\r\n * @dev The decimals are only for visualization purposes.\r\n * All the operations are done using the smallest and indivisible token unit,\r\n * just as on Ethereum all the operations are done in wei.\r\n */\r\ncontract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    /**\r\n     * @return the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @return the symbol of the token.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @return the number of decimals of the token.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\ncontract PauserRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event PauserAdded(address indexed account);\r\n    event PauserRemoved(address indexed account);\r\n\r\n    Roles.Role private _pausers;\r\n\r\n    constructor () internal {\r\n        _addPauser(msg.sender);\r\n    }\r\n\r\n    modifier onlyPauser() {\r\n        require(isPauser(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isPauser(address account) public view returns (bool) {\r\n        return _pausers.has(account);\r\n    }\r\n\r\n    function addPauser(address account) public onlyPauser {\r\n        _addPauser(account);\r\n    }\r\n\r\n    function renouncePauser() public {\r\n        _removePauser(msg.sender);\r\n    }\r\n\r\n    function _addPauser(address account) internal {\r\n        _pausers.add(account);\r\n        emit PauserAdded(account);\r\n    }\r\n\r\n    function _removePauser(address account) internal {\r\n        _pausers.remove(account);\r\n        emit PauserRemoved(account);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is PauserRole {\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    constructor () internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @return true if the contract is paused, false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() public onlyPauser whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() public onlyPauser whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Pausable token\r\n * @dev ERC20 modified with pausable transfers.\r\n */\r\ncontract ERC20Pausable is ERC20, Pausable {\r\n    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {\r\n        return super.transfer(to, value);\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {\r\n        return super.transferFrom(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\r\n        return super.approve(spender, value);\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool success) {\r\n        return super.increaseAllowance(spender, addedValue);\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool success) {\r\n        return super.decreaseAllowance(spender, subtractedValue);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract ERC20Burnable is ERC20 {\r\n    /**\r\n     * @dev Burns a specific amount of tokens.\r\n     * @param value The amount of token to be burned.\r\n     */\r\n    function burn(uint256 value) public {\r\n        _burn(msg.sender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Burns a specific amount of tokens from the target address and decrements allowance\r\n     * @param from address The account whose tokens will be burned.\r\n     * @param value uint256 The amount of token to be burned.\r\n     */\r\n    function burnFrom(address from, uint256 value) public {\r\n        _burnFrom(from, value);\r\n    }\r\n}\r\n\r\ncontract RenToken is Ownable, ERC20Detailed, ERC20Pausable, ERC20Burnable {\r\n\r\n    string private constant _name = \"Republic Token\";\r\n    string private constant _symbol = \"REN\";\r\n    uint8 private constant _decimals = 18;\r\n\r\n    uint256 public constant INITIAL_SUPPLY = 1000000000 * 10**uint256(_decimals);\r\n\r\n    /// @notice The RenToken Constructor.\r\n    constructor() ERC20Burnable() ERC20Pausable() ERC20Detailed(_name, _symbol, _decimals) public {\r\n        _mint(msg.sender, INITIAL_SUPPLY);\r\n    }\r\n\r\n    function transferTokens(address beneficiary, uint256 amount) public onlyOwner returns (bool) {\r\n        /* solium-disable error-reason */\r\n        require(amount > 0);\r\n\r\n        _transfer(msg.sender, beneficiary, amount);\r\n        emit Transfer(msg.sender, beneficiary, amount);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n/// @notice DarknodeSlasher will become a voting system for darknodes to\r\n/// deregister other misbehaving darknodes.\r\n/// Right now, it is a placeholder.\r\ncontract DarknodeSlasher is Ownable {\r\n\r\n    DarknodeRegistry public darknodeRegistry;\r\n\r\n    constructor(DarknodeRegistry _darknodeRegistry) public {\r\n        darknodeRegistry = _darknodeRegistry;\r\n    }\r\n\r\n    function slash(address _prover, address _challenger1, address _challenger2)\r\n        external\r\n        onlyOwner\r\n    {\r\n        darknodeRegistry.slash(_prover, _challenger1, _challenger2);\r\n    }\r\n}\r\n\r\n/**\r\n * @notice LinkedList is a library for a circular double linked list.\r\n */\r\nlibrary LinkedList {\r\n\r\n    /*\r\n    * @notice A permanent NULL node (0x0) in the circular double linked list.\r\n    * NULL.next is the head, and NULL.previous is the tail.\r\n    */\r\n    address public constant NULL = address(0);\r\n\r\n    /**\r\n    * @notice A node points to the node before it, and the node after it. If\r\n    * node.previous = NULL, then the node is the head of the list. If\r\n    * node.next = NULL, then the node is the tail of the list.\r\n    */\r\n    struct Node {\r\n        bool inList;\r\n        address previous;\r\n        address next;\r\n    }\r\n\r\n    /**\r\n    * @notice LinkedList uses a mapping from address to nodes. Each address\r\n    * uniquely identifies a node, and in this way they are used like pointers.\r\n    */\r\n    struct List {\r\n        mapping (address => Node) list;\r\n    }\r\n\r\n    /**\r\n    * @notice Insert a new node before an existing node.\r\n    *\r\n    * @param self The list being used.\r\n    * @param target The existing node in the list.\r\n    * @param newNode The next node to insert before the target.\r\n    */\r\n    function insertBefore(List storage self, address target, address newNode) internal {\r\n        require(!isInList(self, newNode), \"already in list\");\r\n        require(isInList(self, target) || target == NULL, \"not in list\");\r\n\r\n        // It is expected that this value is sometimes NULL.\r\n        address prev = self.list[target].previous;\r\n\r\n        self.list[newNode].next = target;\r\n        self.list[newNode].previous = prev;\r\n        self.list[target].previous = newNode;\r\n        self.list[prev].next = newNode;\r\n\r\n        self.list[newNode].inList = true;\r\n    }\r\n\r\n    /**\r\n    * @notice Insert a new node after an existing node.\r\n    *\r\n    * @param self The list being used.\r\n    * @param target The existing node in the list.\r\n    * @param newNode The next node to insert after the target.\r\n    */\r\n    function insertAfter(List storage self, address target, address newNode) internal {\r\n        require(!isInList(self, newNode), \"already in list\");\r\n        require(isInList(self, target) || target == NULL, \"not in list\");\r\n\r\n        // It is expected that this value is sometimes NULL.\r\n        address n = self.list[target].next;\r\n\r\n        self.list[newNode].previous = target;\r\n        self.list[newNode].next = n;\r\n        self.list[target].next = newNode;\r\n        self.list[n].previous = newNode;\r\n\r\n        self.list[newNode].inList = true;\r\n    }\r\n\r\n    /**\r\n    * @notice Remove a node from the list, and fix the previous and next\r\n    * pointers that are pointing to the removed node. Removing anode that is not\r\n    * in the list will do nothing.\r\n    *\r\n    * @param self The list being using.\r\n    * @param node The node in the list to be removed.\r\n    */\r\n    function remove(List storage self, address node) internal {\r\n        require(isInList(self, node), \"not in list\");\r\n        if (node == NULL) {\r\n            return;\r\n        }\r\n        address p = self.list[node].previous;\r\n        address n = self.list[node].next;\r\n\r\n        self.list[p].next = n;\r\n        self.list[n].previous = p;\r\n\r\n        // Deleting the node should set this value to false, but we set it here for\r\n        // explicitness.\r\n        self.list[node].inList = false;\r\n        delete self.list[node];\r\n    }\r\n\r\n    /**\r\n    * @notice Insert a node at the beginning of the list.\r\n    *\r\n    * @param self The list being used.\r\n    * @param node The node to insert at the beginning of the list.\r\n    */\r\n    function prepend(List storage self, address node) internal {\r\n        // isInList(node) is checked in insertBefore\r\n\r\n        insertBefore(self, begin(self), node);\r\n    }\r\n\r\n    /**\r\n    * @notice Insert a node at the end of the list.\r\n    *\r\n    * @param self The list being used.\r\n    * @param node The node to insert at the end of the list.\r\n    */\r\n    function append(List storage self, address node) internal {\r\n        // isInList(node) is checked in insertBefore\r\n\r\n        insertAfter(self, end(self), node);\r\n    }\r\n\r\n    function swap(List storage self, address left, address right) internal {\r\n        // isInList(left) and isInList(right) are checked in remove\r\n\r\n        address previousRight = self.list[right].previous;\r\n        remove(self, right);\r\n        insertAfter(self, left, right);\r\n        remove(self, left);\r\n        insertAfter(self, previousRight, left);\r\n    }\r\n\r\n    function isInList(List storage self, address node) internal view returns (bool) {\r\n        return self.list[node].inList;\r\n    }\r\n\r\n    /**\r\n    * @notice Get the node at the beginning of a double linked list.\r\n    *\r\n    * @param self The list being used.\r\n    *\r\n    * @return A address identifying the node at the beginning of the double\r\n    * linked list.\r\n    */\r\n    function begin(List storage self) internal view returns (address) {\r\n        return self.list[NULL].next;\r\n    }\r\n\r\n    /**\r\n    * @notice Get the node at the end of a double linked list.\r\n    *\r\n    * @param self The list being used.\r\n    *\r\n    * @return A address identifying the node at the end of the double linked\r\n    * list.\r\n    */\r\n    function end(List storage self) internal view returns (address) {\r\n        return self.list[NULL].previous;\r\n    }\r\n\r\n    function next(List storage self, address node) internal view returns (address) {\r\n        require(isInList(self, node), \"not in list\");\r\n        return self.list[node].next;\r\n    }\r\n\r\n    function previous(List storage self, address node) internal view returns (address) {\r\n        require(isInList(self, node), \"not in list\");\r\n        return self.list[node].previous;\r\n    }\r\n\r\n}\r\n\r\n/// @notice This contract stores data and funds for the DarknodeRegistry\r\n/// contract. The data / fund logic and storage have been separated to improve\r\n/// upgradability.\r\ncontract DarknodeRegistryStore is Claimable {\r\n    using SafeMath for uint256;\r\n\r\n    string public VERSION; // Passed in as a constructor parameter.\r\n\r\n    /// @notice Darknodes are stored in the darknode struct. The owner is the\r\n    /// address that registered the darknode, the bond is the amount of REN that\r\n    /// was transferred during registration, and the public key is the\r\n    /// encryption key that should be used when sending sensitive information to\r\n    /// the darknode.\r\n    struct Darknode {\r\n        // The owner of a Darknode is the address that called the register\r\n        // function. The owner is the only address that is allowed to\r\n        // deregister the Darknode, unless the Darknode is slashed for\r\n        // malicious behavior.\r\n        address payable owner;\r\n\r\n        // The bond is the amount of REN submitted as a bond by the Darknode.\r\n        // This amount is reduced when the Darknode is slashed for malicious\r\n        // behavior.\r\n        uint256 bond;\r\n\r\n        // The block number at which the Darknode is considered registered.\r\n        uint256 registeredAt;\r\n\r\n        // The block number at which the Darknode is considered deregistered.\r\n        uint256 deregisteredAt;\r\n\r\n        // The public key used by this Darknode for encrypting sensitive data\r\n        // off chain. It is assumed that the Darknode has access to the\r\n        // respective private key, and that there is an agreement on the format\r\n        // of the public key.\r\n        bytes publicKey;\r\n    }\r\n\r\n    /// Registry data.\r\n    mapping(address => Darknode) private darknodeRegistry;\r\n    LinkedList.List private darknodes;\r\n\r\n    // RenToken.\r\n    RenToken public ren;\r\n\r\n    /// @notice The contract constructor.\r\n    ///\r\n    /// @param _VERSION A string defining the contract version.\r\n    /// @param _ren The address of the RenToken contract.\r\n    constructor(\r\n        string memory _VERSION,\r\n        RenToken _ren\r\n    ) public {\r\n        VERSION = _VERSION;\r\n        ren = _ren;\r\n    }\r\n\r\n    /// @notice Instantiates a darknode and appends it to the darknodes\r\n    /// linked-list.\r\n    ///\r\n    /// @param _darknodeID The darknode's ID.\r\n    /// @param _darknodeOwner The darknode's owner's address\r\n    /// @param _bond The darknode's bond value\r\n    /// @param _publicKey The darknode's public key\r\n    /// @param _registeredAt The time stamp when the darknode is registered.\r\n    /// @param _deregisteredAt The time stamp when the darknode is deregistered.\r\n    function appendDarknode(\r\n        address _darknodeID,\r\n        address payable _darknodeOwner,\r\n        uint256 _bond,\r\n        bytes calldata _publicKey,\r\n        uint256 _registeredAt,\r\n        uint256 _deregisteredAt\r\n    ) external onlyOwner {\r\n        Darknode memory darknode = Darknode({\r\n            owner: _darknodeOwner,\r\n            bond: _bond,\r\n            publicKey: _publicKey,\r\n            registeredAt: _registeredAt,\r\n            deregisteredAt: _deregisteredAt\r\n        });\r\n        darknodeRegistry[_darknodeID] = darknode;\r\n        LinkedList.append(darknodes, _darknodeID);\r\n    }\r\n\r\n    /// @notice Returns the address of the first darknode in the store\r\n    function begin() external view onlyOwner returns(address) {\r\n        return LinkedList.begin(darknodes);\r\n    }\r\n\r\n    /// @notice Returns the address of the next darknode in the store after the\r\n    /// given address.\r\n    function next(address darknodeID) external view onlyOwner returns(address) {\r\n        return LinkedList.next(darknodes, darknodeID);\r\n    }\r\n\r\n    /// @notice Removes a darknode from the store and transfers its bond to the\r\n    /// owner of this contract.\r\n    function removeDarknode(address darknodeID) external onlyOwner {\r\n        uint256 bond = darknodeRegistry[darknodeID].bond;\r\n        delete darknodeRegistry[darknodeID];\r\n        LinkedList.remove(darknodes, darknodeID);\r\n        require(ren.transfer(owner(), bond), \"bond transfer failed\");\r\n    }\r\n\r\n    /// @notice Updates the bond of a darknode. The new bond must be smaller\r\n    /// than the previous bond of the darknode.\r\n    function updateDarknodeBond(address darknodeID, uint256 decreasedBond) external onlyOwner {\r\n        uint256 previousBond = darknodeRegistry[darknodeID].bond;\r\n        require(decreasedBond < previousBond, \"bond not decreased\");\r\n        darknodeRegistry[darknodeID].bond = decreasedBond;\r\n        require(ren.transfer(owner(), previousBond.sub(decreasedBond)), \"bond transfer failed\");\r\n    }\r\n\r\n    /// @notice Updates the deregistration timestamp of a darknode.\r\n    function updateDarknodeDeregisteredAt(address darknodeID, uint256 deregisteredAt) external onlyOwner {\r\n        darknodeRegistry[darknodeID].deregisteredAt = deregisteredAt;\r\n    }\r\n\r\n    /// @notice Returns the owner of a given darknode.\r\n    function darknodeOwner(address darknodeID) external view onlyOwner returns (address payable) {\r\n        return darknodeRegistry[darknodeID].owner;\r\n    }\r\n\r\n    /// @notice Returns the bond of a given darknode.\r\n    function darknodeBond(address darknodeID) external view onlyOwner returns (uint256) {\r\n        return darknodeRegistry[darknodeID].bond;\r\n    }\r\n\r\n    /// @notice Returns the registration time of a given darknode.\r\n    function darknodeRegisteredAt(address darknodeID) external view onlyOwner returns (uint256) {\r\n        return darknodeRegistry[darknodeID].registeredAt;\r\n    }\r\n\r\n    /// @notice Returns the deregistration time of a given darknode.\r\n    function darknodeDeregisteredAt(address darknodeID) external view onlyOwner returns (uint256) {\r\n        return darknodeRegistry[darknodeID].deregisteredAt;\r\n    }\r\n\r\n    /// @notice Returns the encryption public key of a given darknode.\r\n    function darknodePublicKey(address darknodeID) external view onlyOwner returns (bytes memory) {\r\n        return darknodeRegistry[darknodeID].publicKey;\r\n    }\r\n}\r\n\r\n/// @notice DarknodeRegistry is responsible for the registration and\r\n/// deregistration of Darknodes.\r\ncontract DarknodeRegistry is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    string public VERSION; // Passed in as a constructor parameter.\r\n\r\n    /// @notice Darknode pods are shuffled after a fixed number of blocks.\r\n    /// An Epoch stores an epoch hash used as an (insecure) RNG seed, and the\r\n    /// blocknumber which restricts when the next epoch can be called.\r\n    struct Epoch {\r\n        uint256 epochhash;\r\n        uint256 blocknumber;\r\n    }\r\n\r\n    uint256 public numDarknodes;\r\n    uint256 public numDarknodesNextEpoch;\r\n    uint256 public numDarknodesPreviousEpoch;\r\n\r\n    /// Variables used to parameterize behavior.\r\n    uint256 public minimumBond;\r\n    uint256 public minimumPodSize;\r\n    uint256 public minimumEpochInterval;\r\n\r\n    /// When one of the above variables is modified, it is only updated when the\r\n    /// next epoch is called. These variables store the values for the next epoch.\r\n    uint256 public nextMinimumBond;\r\n    uint256 public nextMinimumPodSize;\r\n    uint256 public nextMinimumEpochInterval;\r\n\r\n    /// The current and previous epoch\r\n    Epoch public currentEpoch;\r\n    Epoch public previousEpoch;\r\n\r\n    /// Republic ERC20 token contract used to transfer bonds.\r\n    RenToken public ren;\r\n\r\n    /// Darknode Registry Store is the storage contract for darknodes.\r\n    DarknodeRegistryStore public store;\r\n\r\n    /// Darknode Slasher allows darknodes to vote on bond slashing.\r\n    DarknodeSlasher public slasher;\r\n    DarknodeSlasher public nextSlasher;\r\n\r\n    /// @notice Emitted when a darknode is registered.\r\n    /// @param _darknodeID The darknode ID that was registered.\r\n    /// @param _bond The amount of REN that was transferred as bond.\r\n    event LogDarknodeRegistered(address indexed _darknodeID, uint256 _bond);\r\n\r\n    /// @notice Emitted when a darknode is deregistered.\r\n    /// @param _darknodeID The darknode ID that was deregistered.\r\n    event LogDarknodeDeregistered(address indexed _darknodeID);\r\n\r\n    /// @notice Emitted when a refund has been made.\r\n    /// @param _owner The address that was refunded.\r\n    /// @param _amount The amount of REN that was refunded.\r\n    event LogDarknodeOwnerRefunded(address indexed _owner, uint256 _amount);\r\n\r\n    /// @notice Emitted when a new epoch has begun.\r\n    event LogNewEpoch(uint256 indexed epochhash);\r\n\r\n    /// @notice Emitted when a constructor parameter has been updated.\r\n    event LogMinimumBondUpdated(uint256 previousMinimumBond, uint256 nextMinimumBond);\r\n    event LogMinimumPodSizeUpdated(uint256 previousMinimumPodSize, uint256 nextMinimumPodSize);\r\n    event LogMinimumEpochIntervalUpdated(uint256 previousMinimumEpochInterval, uint256 nextMinimumEpochInterval);\r\n    event LogSlasherUpdated(address previousSlasher, address nextSlasher);\r\n\r\n    /// @notice Only allow the owner that registered the darknode to pass.\r\n    modifier onlyDarknodeOwner(address _darknodeID) {\r\n        require(store.darknodeOwner(_darknodeID) == msg.sender, \"must be darknode owner\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Only allow unregistered darknodes.\r\n    modifier onlyRefunded(address _darknodeID) {\r\n        require(isRefunded(_darknodeID), \"must be refunded or never registered\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Only allow refundable darknodes.\r\n    modifier onlyRefundable(address _darknodeID) {\r\n        require(isRefundable(_darknodeID), \"must be deregistered for at least one epoch\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Only allowed registered nodes without a pending deregistration to\r\n    /// deregister\r\n    modifier onlyDeregisterable(address _darknodeID) {\r\n        require(isDeregisterable(_darknodeID), \"must be deregisterable\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Only allow the Slasher contract.\r\n    modifier onlySlasher() {\r\n        require(address(slasher) == msg.sender, \"must be slasher\");\r\n        _;\r\n    }\r\n\r\n    /// @notice The contract constructor.\r\n    ///\r\n    /// @param _VERSION A string defining the contract version.\r\n    /// @param _renAddress The address of the RenToken contract.\r\n    /// @param _storeAddress The address of the DarknodeRegistryStore contract.\r\n    /// @param _minimumBond The minimum bond amount that can be submitted by a\r\n    ///        Darknode.\r\n    /// @param _minimumPodSize The minimum size of a Darknode pod.\r\n    /// @param _minimumEpochInterval The minimum number of blocks between\r\n    ///        epochs.\r\n    constructor(\r\n        string memory _VERSION,\r\n        RenToken _renAddress,\r\n        DarknodeRegistryStore _storeAddress,\r\n        uint256 _minimumBond,\r\n        uint256 _minimumPodSize,\r\n        uint256 _minimumEpochInterval\r\n    ) public {\r\n        VERSION = _VERSION;\r\n\r\n        store = _storeAddress;\r\n        ren = _renAddress;\r\n\r\n        minimumBond = _minimumBond;\r\n        nextMinimumBond = minimumBond;\r\n\r\n        minimumPodSize = _minimumPodSize;\r\n        nextMinimumPodSize = minimumPodSize;\r\n\r\n        minimumEpochInterval = _minimumEpochInterval;\r\n        nextMinimumEpochInterval = minimumEpochInterval;\r\n\r\n        currentEpoch = Epoch({\r\n            epochhash: uint256(blockhash(block.number - 1)),\r\n            blocknumber: block.number\r\n        });\r\n        numDarknodes = 0;\r\n        numDarknodesNextEpoch = 0;\r\n        numDarknodesPreviousEpoch = 0;\r\n    }\r\n\r\n    /// @notice Register a darknode and transfer the bond to this contract.\r\n    /// Before registering, the bond transfer must be approved in the REN\r\n    /// contract. The caller must provide a public encryption key for the\r\n    /// darknode. The darknode will remain pending registration until the next\r\n    /// epoch. Only after this period can the darknode be deregistered. The\r\n    /// caller of this method will be stored as the owner of the darknode.\r\n    ///\r\n    /// @param _darknodeID The darknode ID that will be registered.\r\n    /// @param _publicKey The public key of the darknode. It is stored to allow\r\n    ///        other darknodes and traders to encrypt messages to the trader.\r\n    function register(address _darknodeID, bytes calldata _publicKey) external onlyRefunded(_darknodeID) {\r\n        // Use the current minimum bond as the darknode's bond.\r\n        uint256 bond = minimumBond;\r\n\r\n        // Transfer bond to store\r\n        require(ren.transferFrom(msg.sender, address(store), bond), \"bond transfer failed\");\r\n\r\n        // Flag this darknode for registration\r\n        store.appendDarknode(\r\n            _darknodeID,\r\n            msg.sender,\r\n            bond,\r\n            _publicKey,\r\n            currentEpoch.blocknumber.add(minimumEpochInterval),\r\n            0\r\n        );\r\n\r\n        numDarknodesNextEpoch = numDarknodesNextEpoch.add(1);\r\n\r\n        // Emit an event.\r\n        emit LogDarknodeRegistered(_darknodeID, bond);\r\n    }\r\n\r\n    /// @notice Deregister a darknode. The darknode will not be deregistered\r\n    /// until the end of the epoch. After another epoch, the bond can be\r\n    /// refunded by calling the refund method.\r\n    /// @param _darknodeID The darknode ID that will be deregistered. The caller\r\n    ///        of this method store.darknodeRegisteredAt(_darknodeID) must be\r\n    //         the owner of this darknode.\r\n    function deregister(address _darknodeID) external onlyDeregisterable(_darknodeID) onlyDarknodeOwner(_darknodeID) {\r\n        deregisterDarknode(_darknodeID);\r\n    }\r\n\r\n    /// @notice Progress the epoch if it is possible to do so. This captures\r\n    /// the current timestamp and current blockhash and overrides the current\r\n    /// epoch.\r\n    function epoch() external {\r\n        if (previousEpoch.blocknumber == 0) {\r\n            // The first epoch must be called by the owner of the contract\r\n            require(msg.sender == owner(), \"not authorized (first epochs)\");\r\n        }\r\n\r\n        // Require that the epoch interval has passed\r\n        require(block.number >= currentEpoch.blocknumber.add(minimumEpochInterval), \"epoch interval has not passed\");\r\n        uint256 epochhash = uint256(blockhash(block.number - 1));\r\n\r\n        // Update the epoch hash and timestamp\r\n        previousEpoch = currentEpoch;\r\n        currentEpoch = Epoch({\r\n            epochhash: epochhash,\r\n            blocknumber: block.number\r\n        });\r\n\r\n        // Update the registry information\r\n        numDarknodesPreviousEpoch = numDarknodes;\r\n        numDarknodes = numDarknodesNextEpoch;\r\n\r\n        // If any update functions have been called, update the values now\r\n        if (nextMinimumBond != minimumBond) {\r\n            minimumBond = nextMinimumBond;\r\n            emit LogMinimumBondUpdated(minimumBond, nextMinimumBond);\r\n        }\r\n        if (nextMinimumPodSize != minimumPodSize) {\r\n            minimumPodSize = nextMinimumPodSize;\r\n            emit LogMinimumPodSizeUpdated(minimumPodSize, nextMinimumPodSize);\r\n        }\r\n        if (nextMinimumEpochInterval != minimumEpochInterval) {\r\n            minimumEpochInterval = nextMinimumEpochInterval;\r\n            emit LogMinimumEpochIntervalUpdated(minimumEpochInterval, nextMinimumEpochInterval);\r\n        }\r\n        if (nextSlasher != slasher) {\r\n            slasher = nextSlasher;\r\n            emit LogSlasherUpdated(address(slasher), address(nextSlasher));\r\n        }\r\n\r\n        // Emit an event\r\n        emit LogNewEpoch(epochhash);\r\n    }\r\n\r\n    /// @notice Allows the contract owner to initiate an ownership transfer of\r\n    /// the DarknodeRegistryStore. \r\n    /// @param _newOwner The address to transfer the ownership to.\r\n    function transferStoreOwnership(address _newOwner) external onlyOwner {\r\n        store.transferOwnership(_newOwner);\r\n    }\r\n\r\n    /// @notice Claims ownership of the store passed in to the constructor.\r\n    /// `transferStoreOwnership` must have previously been called when\r\n    /// transferring from another Darknode Registry.\r\n    function claimStoreOwnership() external onlyOwner {\r\n        store.claimOwnership();\r\n    }\r\n\r\n    /// @notice Allows the contract owner to update the minimum bond.\r\n    /// @param _nextMinimumBond The minimum bond amount that can be submitted by\r\n    ///        a darknode.\r\n    function updateMinimumBond(uint256 _nextMinimumBond) external onlyOwner {\r\n        // Will be updated next epoch\r\n        nextMinimumBond = _nextMinimumBond;\r\n    }\r\n\r\n    /// @notice Allows the contract owner to update the minimum pod size.\r\n    /// @param _nextMinimumPodSize The minimum size of a pod.\r\n    function updateMinimumPodSize(uint256 _nextMinimumPodSize) external onlyOwner {\r\n        // Will be updated next epoch\r\n        nextMinimumPodSize = _nextMinimumPodSize;\r\n    }\r\n\r\n    /// @notice Allows the contract owner to update the minimum epoch interval.\r\n    /// @param _nextMinimumEpochInterval The minimum number of blocks between epochs.\r\n    function updateMinimumEpochInterval(uint256 _nextMinimumEpochInterval) external onlyOwner {\r\n        // Will be updated next epoch\r\n        nextMinimumEpochInterval = _nextMinimumEpochInterval;\r\n    }\r\n\r\n    /// @notice Allow the contract owner to update the DarknodeSlasher contract\r\n    /// address.\r\n    /// @param _slasher The new slasher address.\r\n    function updateSlasher(DarknodeSlasher _slasher) external onlyOwner {\r\n        require(address(_slasher) != address(0), \"invalid slasher address\");\r\n        nextSlasher = _slasher;\r\n    }\r\n\r\n    /// @notice Allow the DarknodeSlasher contract to slash half of a darknode's\r\n    /// bond and deregister it. The bond is distributed as follows:\r\n    ///   1/2 is kept by the guilty prover\r\n    ///   1/8 is rewarded to the first challenger\r\n    ///   1/8 is rewarded to the second challenger\r\n    ///   1/4 becomes unassigned\r\n    /// @param _prover The guilty prover whose bond is being slashed\r\n    /// @param _challenger1 The first of the two darknodes who submitted the challenge\r\n    /// @param _challenger2 The second of the two darknodes who submitted the challenge\r\n    function slash(address _prover, address _challenger1, address _challenger2)\r\n        external\r\n        onlySlasher\r\n    {\r\n        uint256 penalty = store.darknodeBond(_prover) / 2;\r\n        uint256 reward = penalty / 4;\r\n\r\n        // Slash the bond of the failed prover in half\r\n        store.updateDarknodeBond(_prover, penalty);\r\n\r\n        // If the darknode has not been deregistered then deregister it\r\n        if (isDeregisterable(_prover)) {\r\n            deregisterDarknode(_prover);\r\n        }\r\n\r\n        // Reward the challengers with less than the penalty so that it is not\r\n        // worth challenging yourself\r\n        require(ren.transfer(store.darknodeOwner(_challenger1), reward), \"reward transfer failed\");\r\n        require(ren.transfer(store.darknodeOwner(_challenger2), reward), \"reward transfer failed\");\r\n    }\r\n\r\n    /// @notice Refund the bond of a deregistered darknode. This will make the\r\n    /// darknode available for registration again. Anyone can call this function\r\n    /// but the bond will always be refunded to the darknode owner.\r\n    ///\r\n    /// @param _darknodeID The darknode ID that will be refunded. The caller\r\n    ///        of this method must be the owner of this darknode.\r\n    function refund(address _darknodeID) external onlyRefundable(_darknodeID) {\r\n        address darknodeOwner = store.darknodeOwner(_darknodeID);\r\n\r\n        // Remember the bond amount\r\n        uint256 amount = store.darknodeBond(_darknodeID);\r\n\r\n        // Erase the darknode from the registry\r\n        store.removeDarknode(_darknodeID);\r\n\r\n        // Refund the owner by transferring REN\r\n        require(ren.transfer(darknodeOwner, amount), \"bond transfer failed\");\r\n\r\n        // Emit an event.\r\n        emit LogDarknodeOwnerRefunded(darknodeOwner, amount);\r\n    }\r\n\r\n    /// @notice Retrieves the address of the account that registered a darknode.\r\n    /// @param _darknodeID The ID of the darknode to retrieve the owner for.\r\n    function getDarknodeOwner(address _darknodeID) external view returns (address payable) {\r\n        return store.darknodeOwner(_darknodeID);\r\n    }\r\n\r\n    /// @notice Retrieves the bond amount of a darknode in 10^-18 REN.\r\n    /// @param _darknodeID The ID of the darknode to retrieve the bond for.\r\n    function getDarknodeBond(address _darknodeID) external view returns (uint256) {\r\n        return store.darknodeBond(_darknodeID);\r\n    }\r\n\r\n    /// @notice Retrieves the encryption public key of the darknode.\r\n    /// @param _darknodeID The ID of the darknode to retrieve the public key for.\r\n    function getDarknodePublicKey(address _darknodeID) external view returns (bytes memory) {\r\n        return store.darknodePublicKey(_darknodeID);\r\n    }\r\n\r\n    /// @notice Retrieves a list of darknodes which are registered for the\r\n    /// current epoch.\r\n    /// @param _start A darknode ID used as an offset for the list. If _start is\r\n    ///        0x0, the first dark node will be used. _start won't be\r\n    ///        included it is not registered for the epoch.\r\n    /// @param _count The number of darknodes to retrieve starting from _start.\r\n    ///        If _count is 0, all of the darknodes from _start are\r\n    ///        retrieved. If _count is more than the remaining number of\r\n    ///        registered darknodes, the rest of the list will contain\r\n    ///        0x0s.\r\n    function getDarknodes(address _start, uint256 _count) external view returns (address[] memory) {\r\n        uint256 count = _count;\r\n        if (count == 0) {\r\n            count = numDarknodes;\r\n        }\r\n        return getDarknodesFromEpochs(_start, count, false);\r\n    }\r\n\r\n    /// @notice Retrieves a list of darknodes which were registered for the\r\n    /// previous epoch. See `getDarknodes` for the parameter documentation.\r\n    function getPreviousDarknodes(address _start, uint256 _count) external view returns (address[] memory) {\r\n        uint256 count = _count;\r\n        if (count == 0) {\r\n            count = numDarknodesPreviousEpoch;\r\n        }\r\n        return getDarknodesFromEpochs(_start, count, true);\r\n    }\r\n\r\n    /// @notice Returns whether a darknode is scheduled to become registered\r\n    /// at next epoch.\r\n    /// @param _darknodeID The ID of the darknode to return\r\n    function isPendingRegistration(address _darknodeID) external view returns (bool) {\r\n        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);\r\n        return registeredAt != 0 && registeredAt > currentEpoch.blocknumber;\r\n    }\r\n\r\n    /// @notice Returns if a darknode is in the pending deregistered state. In\r\n    /// this state a darknode is still considered registered.\r\n    function isPendingDeregistration(address _darknodeID) external view returns (bool) {\r\n        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\r\n        return deregisteredAt != 0 && deregisteredAt > currentEpoch.blocknumber;\r\n    }\r\n\r\n    /// @notice Returns if a darknode is in the deregistered state.\r\n    function isDeregistered(address _darknodeID) public view returns (bool) {\r\n        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\r\n        return deregisteredAt != 0 && deregisteredAt <= currentEpoch.blocknumber;\r\n    }\r\n\r\n    /// @notice Returns if a darknode can be deregistered. This is true if the\r\n    /// darknodes is in the registered state and has not attempted to\r\n    /// deregister yet.\r\n    function isDeregisterable(address _darknodeID) public view returns (bool) {\r\n        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\r\n        // The Darknode is currently in the registered state and has not been\r\n        // transitioned to the pending deregistration, or deregistered, state\r\n        return isRegistered(_darknodeID) && deregisteredAt == 0;\r\n    }\r\n\r\n    /// @notice Returns if a darknode is in the refunded state. This is true\r\n    /// for darknodes that have never been registered, or darknodes that have\r\n    /// been deregistered and refunded.\r\n    function isRefunded(address _darknodeID) public view returns (bool) {\r\n        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);\r\n        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\r\n        return registeredAt == 0 && deregisteredAt == 0;\r\n    }\r\n\r\n    /// @notice Returns if a darknode is refundable. This is true for darknodes\r\n    /// that have been in the deregistered state for one full epoch.\r\n    function isRefundable(address _darknodeID) public view returns (bool) {\r\n        return isDeregistered(_darknodeID) && store.darknodeDeregisteredAt(_darknodeID) <= previousEpoch.blocknumber;\r\n    }\r\n\r\n    /// @notice Returns if a darknode is in the registered state.\r\n    function isRegistered(address _darknodeID) public view returns (bool) {\r\n        return isRegisteredInEpoch(_darknodeID, currentEpoch);\r\n    }\r\n\r\n    /// @notice Returns if a darknode was in the registered state last epoch.\r\n    function isRegisteredInPreviousEpoch(address _darknodeID) public view returns (bool) {\r\n        return isRegisteredInEpoch(_darknodeID, previousEpoch);\r\n    }\r\n\r\n    /// @notice Returns if a darknode was in the registered state for a given\r\n    /// epoch.\r\n    /// @param _darknodeID The ID of the darknode\r\n    /// @param _epoch One of currentEpoch, previousEpoch\r\n    function isRegisteredInEpoch(address _darknodeID, Epoch memory _epoch) private view returns (bool) {\r\n        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);\r\n        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\r\n        bool registered = registeredAt != 0 && registeredAt <= _epoch.blocknumber;\r\n        bool notDeregistered = deregisteredAt == 0 || deregisteredAt > _epoch.blocknumber;\r\n        // The Darknode has been registered and has not yet been deregistered,\r\n        // although it might be pending deregistration\r\n        return registered && notDeregistered;\r\n    }\r\n\r\n    /// @notice Returns a list of darknodes registered for either the current\r\n    /// or the previous epoch. See `getDarknodes` for documentation on the\r\n    /// parameters `_start` and `_count`.\r\n    /// @param _usePreviousEpoch If true, use the previous epoch, otherwise use\r\n    ///        the current epoch.\r\n    function getDarknodesFromEpochs(address _start, uint256 _count, bool _usePreviousEpoch) private view returns (address[] memory) {\r\n        uint256 count = _count;\r\n        if (count == 0) {\r\n            count = numDarknodes;\r\n        }\r\n\r\n        address[] memory nodes = new address[](count);\r\n\r\n        // Begin with the first node in the list\r\n        uint256 n = 0;\r\n        address next = _start;\r\n        if (next == address(0)) {\r\n            next = store.begin();\r\n        }\r\n\r\n        // Iterate until all registered Darknodes have been collected\r\n        while (n < count) {\r\n            if (next == address(0)) {\r\n                break;\r\n            }\r\n            // Only include Darknodes that are currently registered\r\n            bool includeNext;\r\n            if (_usePreviousEpoch) {\r\n                includeNext = isRegisteredInPreviousEpoch(next);\r\n            } else {\r\n                includeNext = isRegistered(next);\r\n            }\r\n            if (!includeNext) {\r\n                next = store.next(next);\r\n                continue;\r\n            }\r\n            nodes[n] = next;\r\n            next = store.next(next);\r\n            n += 1;\r\n        }\r\n        return nodes;\r\n    }\r\n\r\n    /// Private function called by `deregister` and `slash`\r\n    function deregisterDarknode(address _darknodeID) private {\r\n        // Flag the darknode for deregistration\r\n        store.updateDarknodeDeregisteredAt(_darknodeID, currentEpoch.blocknumber.add(minimumEpochInterval));\r\n        numDarknodesNextEpoch = numDarknodesNextEpoch.sub(1);\r\n\r\n        // Emit an event\r\n        emit LogDarknodeDeregistered(_darknodeID);\r\n    }\r\n}\r\n\r\n/// @notice DarknodePaymentStore is responsible for tracking black/whitelisted\r\n///         darknodes as well as the balances which have been allocated to the\r\n///         darknodes. It is also responsible for holding the tokens to be paid\r\n///         out to darknodes.\r\ncontract DarknodePaymentStore is Claimable {\r\n    using SafeMath for uint256;\r\n    using CompatibleERC20Functions for ERC20;\r\n\r\n    string public VERSION; // Passed in as a constructor parameter.\r\n\r\n    /// @notice The special address for Ether.\r\n    address constant public ETHEREUM = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    /// @notice The size of the whitelist\r\n    uint256 public darknodeWhitelistLength;\r\n\r\n    /// @notice Mapping of darknode -> token -> balance\r\n    mapping(address => mapping(address => uint256)) public darknodeBalances;\r\n\r\n    /// @notice Mapping of token -> lockedAmount\r\n    mapping(address => uint256) public lockedBalances;\r\n\r\n    /// @notice mapping of darknode -> blacklistTimestamp\r\n    mapping(address => uint256) public darknodeBlacklist;\r\n\r\n    /// @notice mapping of darknode -> whitelistTimestamp\r\n    mapping(address => uint256) public darknodeWhitelist;\r\n\r\n    /// @notice The contract constructor.\r\n    ///\r\n    /// @param _VERSION A string defining the contract version.\r\n    constructor(\r\n        string memory _VERSION\r\n    ) public {\r\n        VERSION = _VERSION;\r\n    }\r\n\r\n    /// @notice Allow direct payments to be made to the DarknodePaymentStore.\r\n    function () external payable {\r\n    }\r\n\r\n    /// @notice Checks to see if a darknode is blacklisted\r\n    ///\r\n    /// @param _darknode The address of the darknode\r\n    /// @return true if the darknode is blacklisted\r\n    function isBlacklisted(address _darknode) public view returns (bool) {\r\n        return darknodeBlacklist[_darknode] != 0;\r\n    }\r\n\r\n    /// @notice Checks to see if a darknode is whitelisted\r\n    ///\r\n    /// @param _darknode The address of the darknode\r\n    /// @return true if the darknode is whitelisted\r\n    function isWhitelisted(address _darknode) public view returns (bool) {\r\n        return darknodeWhitelist[_darknode] != 0;\r\n    }\r\n\r\n    /// @notice Get the total balance of the contract for a particular token\r\n    ///\r\n    /// @param _token The token to check balance of\r\n    /// @return The total balance of the contract\r\n    function totalBalance(address _token) public view returns (uint256) {\r\n        if (_token == ETHEREUM) {\r\n            return address(this).balance;\r\n        } else {\r\n            return ERC20(_token).balanceOf(address(this));\r\n        }\r\n    }\r\n\r\n    /// @notice Get the available balance of the contract for a particular token\r\n    ///         This is the free amount which has not yet been allocated to\r\n    ///         darknodes.\r\n    ///\r\n    /// @param _token The token to check balance of\r\n    /// @return The available balance of the contract\r\n    function availableBalance(address _token) public view returns (uint256) {\r\n        return totalBalance(_token).sub(lockedBalances[_token]);\r\n    }\r\n\r\n    /// @notice Blacklists a darknode from participating in reward allocation.\r\n    ///         If the darknode is whitelisted, it is removed from the whitelist\r\n    ///         and the number of whitelisted nodes is decreased.\r\n    ///\r\n    /// @param _darknode The address of the darknode to blacklist\r\n    function blacklist(address _darknode) external onlyOwner {\r\n        require(!isBlacklisted(_darknode), \"darknode already blacklisted\");\r\n        darknodeBlacklist[_darknode] = now;\r\n\r\n        // Unwhitelist if necessary\r\n        if (isWhitelisted(_darknode)) {\r\n            darknodeWhitelist[_darknode] = 0;\r\n            // Use SafeMath when subtracting to avoid underflows\r\n            darknodeWhitelistLength = darknodeWhitelistLength.sub(1);\r\n        }\r\n    }\r\n\r\n    /// @notice Whitelists a darknode allowing it to participate in reward\r\n    ///         allocation.\r\n    ///\r\n    /// @param _darknode The address of the darknode to whitelist\r\n    function whitelist(address _darknode) external onlyOwner {\r\n        require(!isBlacklisted(_darknode), \"darknode is blacklisted\");\r\n        require(!isWhitelisted(_darknode), \"darknode already whitelisted\");\r\n\r\n        darknodeWhitelist[_darknode] = now;\r\n        darknodeWhitelistLength++;\r\n    }\r\n\r\n    /// @notice Increments the amount of funds allocated to a particular\r\n    ///         darknode.\r\n    ///\r\n    /// @param _darknode The address of the darknode to increase balance of\r\n    /// @param _token The token which the balance should be incremented\r\n    /// @param _amount The amount that the balance should be incremented by\r\n    function incrementDarknodeBalance(address _darknode, address _token, uint256 _amount) external onlyOwner {\r\n        require(_amount > 0, \"invalid amount\");\r\n        require(availableBalance(_token) >= _amount, \"insufficient contract balance\");\r\n\r\n        darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token].add(_amount);\r\n        lockedBalances[_token] = lockedBalances[_token].add(_amount);\r\n    }\r\n\r\n    /// @notice Transfers an amount out of balance to a specified address\r\n    ///\r\n    /// @param _darknode The address of the darknode\r\n    /// @param _token Which token to transfer\r\n    /// @param _amount The amount to transfer\r\n    /// @param _recipient The address to withdraw it to\r\n    function transfer(address _darknode, address _token, uint256 _amount, address payable _recipient) external onlyOwner {\r\n        require(darknodeBalances[_darknode][_token] >= _amount, \"insufficient darknode balance\");\r\n        darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token].sub(_amount);\r\n        lockedBalances[_token] = lockedBalances[_token].sub(_amount);\r\n\r\n        if (_token == ETHEREUM) {\r\n            _recipient.transfer(_amount);\r\n        } else {\r\n            ERC20(_token).safeTransfer(_recipient, _amount);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"darknodeWhitelistLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_darknode\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"darknodeBlacklist\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"totalBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"darknodeBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"darknodeWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_darknode\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"availableBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_darknode\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"incrementDarknodeBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHEREUM\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_darknode\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_darknode\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_darknode\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_VERSION\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DarknodePaymentStore","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000d6d61696e6e65742d312e302e3000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://296cecab94308b7cf0cea6796dc0ace20d61bb4cb06fa0957fa9484f9016abf5"}]}