{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25 ;\r\n\r\ninterface IERC20Token {                                     \r\n    function balanceOf(address owner) external returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function decimals() external returns (uint256);\r\n}\r\n\r\ncontract ITNMining {\r\n    \r\n    using SafeMath for uint ; \r\n    using Limit for uint ; \r\n    \r\n    IERC20Token public tokenContract ;\r\n    address public owner;\r\n    \r\n    mapping(bytes32 => bytes32) public solutionForChallenge ; \r\n    \r\n    uint public blockNumber  = 0 ; \r\n    \r\n    uint public ITN_BLOCKS_PER_EPOCH_TARGET = 5 ;\r\n    uint public ITN_BLOCK_TIME = 600 ; \r\n    uint public ETHER_BLOCK_TIME = 15 ; \r\n    uint public halvingBlockAmount = 25000 ; \r\n    \r\n    uint public ETHER_BLOCKS_PER_EPOCH_TARGET = (ITN_BLOCK_TIME.div(ETHER_BLOCK_TIME)).mul(ITN_BLOCKS_PER_EPOCH_TARGET) ;\r\n    \r\n    uint public MIN_TARGET = 2 ** 16 ; \r\n    uint public MAX_TARGET = 2 ** 252 ; \r\n    \r\n    uint public target  = MAX_TARGET.div(10**4) ; \r\n    bytes32 public challenge ; \r\n    \r\n    address public lastRewardedMiner ; \r\n    uint public lastRewardAmount ; \r\n    uint public lastRewardETHBlock ; \r\n    \r\n    uint public ETHBlockDiffAdjusted  = block.number ; \r\n    \r\n    uint public minedTokensAmount  = 0 ; \r\n    \r\n    uint public blockReward = 200 ; \r\n    \r\n    bool public locked = false ; \r\n    \r\n    event newBlock(address miner, uint reward) ; \r\n    \r\n    constructor(IERC20Token _tokenContract) public {\r\n        tokenContract = _tokenContract ;\r\n        owner = msg.sender ; \r\n        \r\n        newBlockChallenge() ; \r\n    }\r\n    \r\n    function lockContract() public onlyOwner returns (bool success) {\r\n        locked = true ; \r\n        return true ; \r\n    }\r\n    \r\n    function mine(uint256 nonce, bytes32 challenge_digest) public returns (bool success) {\r\n        require(!locked) ; \r\n        require(tokenContract.balanceOf(address(this)) > blockReward) ;\r\n        \r\n        bytes32 digest =  keccak256(challenge, msg.sender, nonce); \r\n        \r\n        if (digest != challenge_digest) {\r\n            revert() ; \r\n        }\r\n        \r\n        if (uint256(challenge_digest) > target) {\r\n            revert() ; \r\n        }\r\n        \r\n\r\n        bytes32 solution = solutionForChallenge[challenge];\r\n        solutionForChallenge[challenge] = digest;\r\n        if(solution != 0x0) {\r\n            revert();\r\n        }\r\n        \r\n        minedTokensAmount = minedTokensAmount.add(blockReward) ; \r\n        \r\n        lastRewardedMiner = msg.sender ; \r\n        lastRewardAmount = blockReward ; \r\n        lastRewardETHBlock = block.number ; \r\n        \r\n        emit newBlock(msg.sender, blockReward) ; \r\n        \r\n        tokenContract.transfer(msg.sender, blockReward * 10 ** tokenContract.decimals()) ; \r\n        \r\n        newBlockChallenge() ; \r\n        \r\n        return true ; \r\n    }\r\n\r\n    function newBlockChallenge() internal {\r\n        blockNumber = blockNumber.add(1) ; \r\n        \r\n        if (blockNumber % ITN_BLOCKS_PER_EPOCH_TARGET == 0) {\r\n            adjustDifficulty() ; \r\n        }\r\n        \r\n        if (blockNumber % halvingBlockAmount == 0) {\r\n            blockReward = blockReward.div(2) ; \r\n        }\r\n        \r\n        challenge = blockhash(block.number - 1) ; \r\n    }\r\n    \r\n    function adjustDifficulty() internal {\r\n        uint blocksSinceLastBlock = block.number - ETHBlockDiffAdjusted ; \r\n          \r\n        if (blocksSinceLastBlock < ETHER_BLOCKS_PER_EPOCH_TARGET) { \r\n            \r\n            uint excs_percentage = (ETHER_BLOCKS_PER_EPOCH_TARGET.mul(100)).div(blocksSinceLastBlock) ;\r\n\r\n            uint excs_percentage_extra = excs_percentage.sub(100).limitLessThan(1000) ;  \r\n          \r\n            target = target.sub(target.div(2000).mul(excs_percentage_extra)) ;      \r\n        }\r\n        \r\n        else {      \r\n            \r\n            uint short_percentage = (blocksSinceLastBlock.mul(100)).div(ETHER_BLOCKS_PER_EPOCH_TARGET) ;\r\n\r\n            uint short_percentage_extra = short_percentage.sub(100).limitLessThan(1000) ;\r\n\r\n            target = target.add(target.div(2000).mul(short_percentage_extra)) ;\r\n        }\r\n        \r\n        \r\n        ETHBlockDiffAdjusted = block.number ; \r\n        \r\n        \r\n        if(target < MIN_TARGET) {target = MIN_TARGET ;}\r\n\r\n        if(target > MAX_TARGET) {target = MAX_TARGET ;}\r\n    }\r\n    \r\n    function getChallenge() public view returns (bytes32) {\r\n        return challenge;\r\n    }\r\n\r\n     function getMiningDifficulty() public view returns (uint) {\r\n        return MAX_TARGET.div(target);\r\n    }\r\n\r\n    function getMiningTarget() public view returns (uint) {\r\n       return target;\r\n   }\r\n   \r\n   function testHASH(uint256 nonce, bytes32 challenge_digest) public view returns (bool success) {\r\n        bytes32 digest =  keccak256(challenge, msg.sender, nonce); \r\n        \r\n        if (digest != challenge_digest) {\r\n            revert() ; \r\n        }\r\n        \r\n        if (uint256(challenge_digest) > target) {\r\n            revert() ; \r\n        }\r\n        \r\n        return true ; \r\n   }\r\n   \r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n    \r\n    function destroyOwnership() public onlyOwner {\r\n        owner = address(0) ; \r\n    }\r\n    \r\n    function stopMining() public onlyOwner {\r\n        tokenContract.transfer(msg.sender, tokenContract.balanceOf(address(this))) ;\r\n        msg.sender.transfer(address(this).balance) ;  \r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\nlibrary Limit {\r\n    function limitLessThan(uint a, uint b) internal pure returns (uint c) {\r\n\r\n        if(a > b) {\r\n            return b;\r\n        } else {\r\n            return a;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"blockReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMiningDifficulty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastRewardETHBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHER_BLOCKS_PER_EPOCH_TARGET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHBlockDiffAdjusted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMiningTarget\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halvingBlockAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minedTokensAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastRewardedMiner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lockContract\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getChallenge\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ITN_BLOCK_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"challenge_digest\",\"type\":\"bytes32\"}],\"name\":\"testHASH\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHER_BLOCK_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ITN_BLOCKS_PER_EPOCH_TARGET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"solutionForChallenge\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_TARGET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastRewardAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroyOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"challenge\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"target\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopMining\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"challenge_digest\",\"type\":\"bytes32\"}],\"name\":\"mine\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TARGET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"miner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"newBlock\",\"type\":\"event\"}]","ContractName":"ITNMining","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000008516b43a9b547e4692433340ca9f0a13b5d25d7f","Library":"","SwarmSource":"bzzr://b4d496f5b2a45ac35302fac5f7f483c38ce3d6e4a01bc5389ec23944286ad139"}]}