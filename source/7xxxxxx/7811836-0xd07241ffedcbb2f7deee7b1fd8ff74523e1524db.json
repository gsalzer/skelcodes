{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.8;\r\n\r\n\r\n/// @title ERC20 Token Interface\r\n/// @author Hoard Team\r\n/// @notice See https://github.com/ethereum/EIPs/issues/20\r\ncontract ERC20Token {\r\n\r\n    // PUBLIC INTERFACE\r\n\r\n    // /// @dev Returns total amount of tokens\r\n    // /// @notice params -> (uint256 totalSupply)\r\n    // It's implamented as a variable which doesn't override this method. Commented to prevent compilation error.\r\n    // function totalSupply    () constant public returns (uint256);\r\n\r\n    /// @dev Returns balance of specified account\r\n    /// @notice params -> (address _owner)\r\n    function balanceOf      (address) view public returns (uint256);\r\n\r\n    /// @dev  Transfers tokens from msg.sender to a specified address\r\n    /// @notice params -> (address _to, uint256 _value)\r\n    function transfer       (address, uint256) public returns (bool);\r\n\r\n    /// @dev  Allowance mechanism - delegated transfer\r\n    /// @notice params -> (address _from, address _to, uint256 _value)\r\n    function transferFrom   (address, address, uint256) public returns (bool);\r\n\r\n    /// @dev  Allowance mechanism - approve delegated transfer\r\n    /// @notice params -> (address _spender, uint256 _value)\r\n    function approve        (address, uint256) public returns (bool);\r\n\r\n    /// @dev  Allowance mechanism - set allowance for specified address\r\n    /// @notice params -> (address _owner, address _spender)\r\n    function allowance      (address, address) public view returns (uint256);\r\n\r\n\r\n    // EVENTS\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\n\r\n/// @title Safe Math\r\n/// @author Open Zeppelin\r\n/// @notice implementation from - https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\nlibrary SafeMath {\r\n  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n  \r\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/// @title Standard ERC20 compliant token\r\n/// @author Hoard Team\r\n/// @notice Original taken from https://github.com/ethereum/EIPs/issues/20\r\n/// @notice SafeMath used as specified by OpenZeppelin\r\n/// @notice Comments and additional approval code from https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token\r\ncontract StandardToken is ERC20Token {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) balances;\r\n\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    uint256 public totalSupply;\r\n\r\n   /// @dev transfer token for a specified address\r\n   /// @param _to The address to transfer to.\r\n   /// @param _value The amount to be transferred.\r\n   function transfer(address _to, uint256 _value) public returns (bool) {\r\n        balances[msg.sender] = balances[msg.sender].safeSub(_value);\r\n        balances[_to] = balances[_to].safeAdd(_value);\r\n\r\n        emit Transfer(msg.sender, _to, _value);            \r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfer tokens from one address to another\r\n    /// @param _from address The address which you want to send tokens from\r\n    /// @param _to address The address which you want to transfer to\r\n    /// @param _value uint256 the amount of tokens to be transferred\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n        // require (_value <= _allowance);        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n\r\n        balances[_to] = balances[_to].safeAdd(_value);\r\n        balances[_from] = balances[_from].safeSub(_value);\r\n        allowed[_from][msg.sender] = _allowance.safeSub(_value);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n            \r\n        return true;\r\n    }\r\n\r\n    /// @dev Gets the balance of the specified address.\r\n    /// @param _owner The address to query the the balance of. \r\n    /// @return An uint256 representing the amount owned by the passed address.\r\n    function balanceOf(address _owner) view public returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n   /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   /// @param _spender The address which will spend the funds.\r\n   /// @param _value The amount of tokens to be spent.\r\n   function approve(address _spender, uint256 _value) public returns (bool) {\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n        \r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n   /// @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   /// @param _owner address The address which owns the funds.\r\n   /// @param _spender address The address which will spend the funds.\r\n   /// @return A uint256 specifying the amount of tokens still available for the spender.\r\n   function allowance(address _owner, address _spender) view public returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /// @notice approve should be called when allowed[_spender] == 0. To increment\r\n    /// allowed value it is better to use this function to avoid 2 calls (and wait until \r\n    /// the first transaction is mined)\r\n    function increaseApproval (address _spender, uint256 _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].safeAdd(_addedValue);\r\n\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice approve should be called when allowed[_spender] == 0. To decrement\r\n    /// allowed value it is better to use this function to avoid 2 calls (and wait until \r\n    /// the first transaction is mined)\r\n    function decreaseApproval (address _spender, uint256 _subtractedValue) public returns (bool) {\r\n        uint256 oldValue = allowed[msg.sender][_spender];\r\n        \r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue - _subtractedValue;\r\n        }\r\n\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n\r\n/// @title Migration Agent interface\r\n/// @author Hoard Team\r\n/// @notice Based on GNT implementation - https://github.com/golemfactory/golem-crowdfunding/blob/master/contracts/Token.sol\r\ncontract MigrationAgent {\r\n\r\n    /// @dev migrates tokens or other \"assets\" from one contract to another (not yet specified)\r\n    /// @notice parameters -> (address _from, uint _value)\r\n    function migrateFrom(address, uint256) public;\r\n}\r\n\r\n\r\n/// @title Mintable token interface\r\n/// @author Hoard Team\r\ncontract Mintable {\r\n\r\n    /// @dev Mint new tokens  \r\n    /// @notice params -> (address _recipient, uint256 _amount)\r\n    function mintTokens         (address, uint256) public;\r\n}\r\n\r\n\r\n/// @title Migratable entity interface\r\n/// @author Hoard Team\r\ncontract Migratable {\r\n\r\n    /// @dev Migrates tokens for msg.sender  \r\n    /// @notice params -> (uint256 _value)\r\n    function migrate            (uint256) public;\r\n\r\n\r\n    // EVENTS\r\n\r\n    event Migrate               (address indexed _from, address indexed _to, uint256 _value);\r\n}\r\n\r\n\r\n/// @title Standard ERC20 compliant token\r\n/// @author Hoard Team\r\ncontract ExtendedStandardToken is StandardToken, Migratable, Mintable {\r\n\r\n    address public migrationAgent;\r\n    uint256 public totalMigrated;\r\n\r\n\r\n    // MODIFIERS\r\n\r\n    modifier migrationAgentSet {\r\n        require(migrationAgent != address(0));\r\n        _;\r\n    }\r\n\r\n    modifier migrationAgentNotSet {\r\n        require(migrationAgent == address(0));\r\n        _;\r\n    }\r\n\r\n    /// @dev Internal constructor to prevent bare instances of this contract\r\n    constructor () internal {\r\n    }\r\n\r\n    // MIGRATION LOGIC\r\n\r\n    /// @dev Migrates tokens for msg.sender and burns them\r\n    /// @param _value amount of tokens to migrate\r\n    function migrate            (uint256 _value) public {\r\n\r\n        // Validate input value\r\n        require(_value > 0);\r\n    \r\n        //require(_value <= balances[msg.sender]);\r\n        //not necessary as safeSub throws in case the above condition does not hold\r\n    \r\n        balances[msg.sender] = balances[msg.sender].safeSub(_value);\r\n        totalSupply = totalSupply.safeSub(_value);\r\n        totalMigrated = totalMigrated.safeAdd(_value);\r\n\r\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\r\n\r\n        emit Migrate(msg.sender, migrationAgent, _value);\r\n    }\r\n\r\n\r\n    // MINTING LOGIC\r\n\r\n    /// @dev Mints additional tokens\r\n    /// @param _recipient owner of new tokens \r\n    /// @param _amount amount of tokens to mint\r\n    function mintTokens         (address _recipient, uint256 _amount) public {\r\n        require(_amount > 0);\r\n\r\n        balances[_recipient] = balances[_recipient].safeAdd(_amount);\r\n        totalSupply = totalSupply.safeAdd(_amount);\r\n\r\n        // Log token creation event\r\n        emit Transfer(address(0), msg.sender, _amount);\r\n    }\r\n\r\n\r\n    // CONTROL LOGIC\r\n\r\n    /// @dev Sets address of a new migration agent\r\n    /// @param _address address of new migration agent \r\n    function setMigrationAgent  (address _address) public {\r\n        migrationAgent = _address; \r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n/// @title Hoard Token (HRD) - crowdfunding code for Hoard token\r\n/// @author Hoard Team\r\n/// @notice Based on MLN implementation - https://github.com/melonproject/melon/blob/master/contracts/tokens/MelonToken.sol\r\n/// @notice Based on GNT implementation - https://github.com/golemfactory/golem-crowdfunding/blob/master/contracts/Token.sol\r\ncontract HoardToken is ExtendedStandardToken {\r\n\r\n    // Token description fields\r\n    string public constant name = \"Hoard Token\";\r\n    string public constant symbol = \"HRD\";\r\n    uint256 public constant decimals = 18;  // 18 decimal places, the same as ETH\r\n\r\n    // contract supervision variables\r\n    address public creator;\r\n    address public hoard;\r\n    address public migrationMaster;\r\n\r\n\r\n    // MODIFIERS\r\n\r\n    modifier onlyCreator {\r\n        require(msg.sender == creator);\r\n        _;\r\n    }\r\n\r\n    modifier onlyHoard {\r\n        require(msg.sender == hoard);\r\n        _;\r\n    }\r\n\r\n    modifier onlyMigrationMaster {\r\n        require(msg.sender == migrationMaster);\r\n        _;\r\n    }\r\n\r\n    // CONSTRUCTION\r\n\r\n    /// @param _hoard Hoard multisig contract\r\n    /// @param _migrationMaster migration master\r\n    constructor (address _hoard, address _migrationMaster) public {\r\n        require(_hoard != address(0));\r\n        require(_migrationMaster != address(0));\r\n\r\n        creator = msg.sender;\r\n        hoard = _hoard;\r\n        migrationMaster = _migrationMaster;\r\n    }\r\n\r\n\r\n    // BASE CLASS IMPLEMENTATION\r\n\r\n    /// @notice ExtendedStandardToken is StandardToken\r\n    function transfer               (address _to, uint256 _value) public\r\n        returns (bool) \r\n    {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n\r\n    /// @notice ExtendedStandardToken is StandardToken\r\n    function transferFrom           (address _from, address _to, uint256 _value) public \r\n        returns (bool)\r\n    {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n\r\n    /// @notice ExtendedStandardToken is Migratable\r\n    function migrate                (uint256 _value) public migrationAgentSet {\r\n        super.migrate(_value);    \r\n    }\r\n\r\n    /// @notice ExtendedStandardToken\r\n    function setMigrationAgent      (address _address) public onlyMigrationMaster migrationAgentNotSet {\r\n        require(_address != address(0));\r\n\r\n        super.setMigrationAgent(_address);\r\n    }\r\n\r\n    /// @notice ExtendedStandardToken is Mintable\r\n    function mintTokens             (address _recipient, uint256 _amount) public onlyCreator {\r\n        super.mintTokens(_recipient, _amount);\r\n    }\r\n\r\n    // CONTROL LOGIC\r\n\r\n    /// @dev changes Hoard multisig address to another one\r\n    function changeHoardAddress     (address _address) onlyHoard external { hoard = _address; }\r\n\r\n    /// @dev changes migration master address to another one\r\n    function changeMigrationMaster  (address _address) onlyHoard external { migrationMaster = _address; }\r\n\r\n}\r\n\r\n\r\n\r\n/// @title HRD Allocation - time-locked vault of tokens allocated to developers and Hoard\r\n/// @notice Based on GNT implementation - https://github.com/golemfactory/golem-crowdfunding/blob/master/contracts/GNTAllocation.sol\r\ncontract HRDAllocation {\r\n\r\n    // Addresses of developer and the Hoard to allocations mapping.\r\n    mapping (address => uint256) allocations;\r\n\r\n    // Address of the token contract\r\n    HoardToken hoardToken;\r\n\r\n    // endowment accounts\r\n    address public constant ADDR_01 = 0x7D4f9442659A85c64dBc0fcD73C163bbD7CcEf84;\r\n    address public constant ADDR_02 = 0xa24697ff026a072acfBc2ad4baef3386deF89Fd9;\r\n    address public constant ADDR_03 = 0x5472e965d2Fe689C5cF20d8E72C3f8d116E95d30;\r\n    address public constant ADDR_04 = 0x90A62aa1f37f9B5A43E6768991dA1cd83526b89f;\r\n    address public constant ADDR_05 = 0xd0a93607f75B8Cf378c6C06A15bd664541849768;\r\n    address public constant ADDR_06 = 0xd0E1555b918f9b2E57b0fC8913C7181382ad9CB5;\r\n    address public constant ADDR_07 = 0x20845469fF9DDc56F98A66419B88A5435739707a;\r\n    address public constant ADDR_08 = 0x1AB9fc0928C80164B1bfE166527F82c759Ade114;\r\n    address public constant ADDR_09 = 0x11c1c4f3c6c725455e48f862e59407e5db7bd7A8;\r\n    address public constant ADDR_10 = 0x7165b273907F4Cc437224b5c50C50C70F8a355E0;\r\n    address public constant ADDR_11 = 0x625186d75dea6f90B37C1f3fb70acBaDD251371D;\r\n    address public constant ADDR_12 = 0xf2f6C59359958DB1C4dDD140c87C6a6e314f0267;\r\n    address public constant ADDR_13 = 0x274A87EEe6321a0c62230B1087048EB40b2C628e;\r\n    address public constant ADDR_14 = 0xB576274F6Be62Bb290F15a3B4D503a6c06f7cBbb;\r\n    address public constant ADDR_15 = 0x3C4D5be2fd91BD2B2cF8E1D4D2C1B54E8d29C83D;\r\n    address public constant ADDR_16 = 0x6803BcB68C0427d25B46a3ef7520F1460518C0Fb;\r\n    address public constant ADDR_17 = 0x52F540BE7d494075dA30b1ED67BAf46FdE30B7d9;\r\n    address public constant ADDR_18 = 0x0872dfA15E300496BadBB4c04c939F5E515DeedD;\r\n    address public constant ADDR_19 = 0xC8EcfFEAc244099809BB1480689A7A36d21a6091;\r\n    address public constant ADDR_20 = 0xE80b3ad9A170A608Eb07C460F231dA6c872dd5C4;\r\n    address public constant ADDR_21 = 0x077656617C26074BD54Fa636142CAD91d633C8Ac;\r\n    address public constant ADDR_22 = 0x572d0f9C8a2C783aDDfCaeAb68f2F60781edd5Df;\r\n    address public constant ADDR_23 = 0xaD1FA44CfBA1a3ca7b4dE016F857aBB30131A513;\r\n    address public constant ADDR_24 = 0x2A4331B02Ca0630b5f0C68ecB3E1732866864cc7;\r\n\r\n    // endowment amounts\r\n    uint256 public constant ALLOC_01  = 50000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_02  = 10000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_03  = 5000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_04  = 20000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_05  = 20000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_06  = 6000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_07  = 2000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_08  = 3000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_09  = 3000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_10  = 3000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_11  = 3000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_12  = 3000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_13  = 4000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_14  = 3000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_15  = 3000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_16  = 3000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_17  = 3000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_18  = 4000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_19  = 6000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_20  = 3000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_21  = 3000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_22  = 2000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_23  = 2000000 * 10 ** 18;\r\n    uint256 public constant ALLOC_24  = 2000000 * 10 ** 18;\r\n\r\n    // Vault configuration\r\n    uint256 unlockedAt;\r\n    uint256 tokensCreated = 0;\r\n\r\n\r\n    // MODIFIERS\r\n\r\n    modifier onlyIfUnlocked {\r\n        require(now >= unlockedAt);\r\n        _;\r\n    }\r\n\r\n\r\n    // CONSTRUCTION\r\n\r\n    /// @param _hoard Hoard multisig address\r\n    /// @param _hoardToken token address\r\n    /// @param _lockIntervalDuration how long endowment tokens are going to be locked\r\n    /// @notice Allow developer to unlock allocated tokens by transferring them\r\n    /// from HRDAllocation to developer's address.\r\n    constructor (address _hoard, address _hoardToken, uint256 _lockIntervalDuration, uint256 _totalHRD) public {\r\n        // Make sure that basic input invariants are satisfied \r\n        require(_hoard != address(0));\r\n        require(_hoardToken != address(0));\r\n        require(_lockIntervalDuration > 0);\r\n\r\n        // Sanity checks at the cost of slightly larger contract\r\n        uint256 ALLOC_01_05 = ALLOC_01 + ALLOC_02 + ALLOC_03 + ALLOC_04 + ALLOC_05;\r\n        uint256 ALLOC_06_10 = ALLOC_06 + ALLOC_07 + ALLOC_08 + ALLOC_09 + ALLOC_10;\r\n        uint256 ALLOC_11_15 = ALLOC_11 + ALLOC_12 + ALLOC_13 + ALLOC_14 + ALLOC_15;\r\n        uint256 ALLOC_16_20 = ALLOC_16 + ALLOC_17 + ALLOC_18 + ALLOC_19 + ALLOC_20;\r\n        uint256 ALLOC_21_24 = ALLOC_21 + ALLOC_22 + ALLOC_23 + ALLOC_24;\r\n\r\n        uint256 ALLOC_ALL = ALLOC_01_05 + ALLOC_06_10 + ALLOC_11_15 + ALLOC_16_20 + ALLOC_21_24;\r\n\r\n        // Called here so that the contract is not constructed if invalid number of tokens is specified\r\n        require(_totalHRD == ALLOC_ALL);\r\n\r\n        hoardToken = HoardToken(_hoardToken);\r\n        unlockedAt = 1556712000 + _lockIntervalDuration; // 05/01/2019 @ 12:00pm (UTC) + _lockIntervalDuration\r\n\r\n        // For developers and advisors\r\n        allocations[ADDR_01] = ALLOC_01;\r\n        allocations[ADDR_02] = ALLOC_02;\r\n        allocations[ADDR_03] = ALLOC_03;\r\n        allocations[ADDR_04] = ALLOC_04;\r\n        allocations[ADDR_05] = ALLOC_05;\r\n        allocations[ADDR_06] = ALLOC_06;\r\n        allocations[ADDR_07] = ALLOC_07;\r\n        allocations[ADDR_08] = ALLOC_08;\r\n        allocations[ADDR_09] = ALLOC_09;\r\n        allocations[ADDR_10] = ALLOC_10;\r\n        allocations[ADDR_11] = ALLOC_11;\r\n        allocations[ADDR_12] = ALLOC_12;\r\n        allocations[ADDR_13] = ALLOC_13;\r\n        allocations[ADDR_14] = ALLOC_14;\r\n        allocations[ADDR_15] = ALLOC_15;\r\n        allocations[ADDR_16] = ALLOC_16;\r\n        allocations[ADDR_17] = ALLOC_17;\r\n        allocations[ADDR_18] = ALLOC_18;\r\n        allocations[ADDR_19] = ALLOC_19;\r\n        allocations[ADDR_20] = ALLOC_20;\r\n        allocations[ADDR_21] = ALLOC_21;\r\n        allocations[ADDR_22] = ALLOC_22;\r\n        allocations[ADDR_23] = ALLOC_23;\r\n        allocations[ADDR_24] = ALLOC_24;\r\n    }\r\n\r\n    /// @notice Allow developer to unlock allocated tokens by transferring them\r\n    /// from HRDAllocation to developer's address.\r\n    function unlock() external onlyIfUnlocked {\r\n\r\n        // During first unlock attempt fetch total number of locked tokens.\r\n        if (tokensCreated == 0) {\r\n            tokensCreated = hoardToken.balanceOf(address(this));\r\n        }\r\n\r\n        uint256 hrdAllocation = allocations[msg.sender];\r\n        \r\n        require(hrdAllocation > 0);\r\n\r\n        allocations[msg.sender] = 0;\r\n        \r\n        hoardToken.transfer(msg.sender, hrdAllocation);\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title Hoard  Crowdfunding Logic \r\n/// @author Hoard Team\r\n/// @notice Based roughly on MLN implementation - https://github.com/melonproject/melon/blob/master/contracts/tokens/MelonToken.sol\r\ncontract HoardDeployer {\r\n\r\n    // configuration of time dependant logic\r\n    uint256 public constant endowmentLockDuration = 12 * 30 days; // duration of HRD endowment lock period (1 year)\r\n\r\n    // configuration of HRD generation logic\r\n    uint256 public constant totalHRD           = 1000000000 * 10 ** 18;                    // Fixed amount of tokens to be generated (decimals == decimals in HoardToken)\r\n\r\n    uint256 public constant totalDevHRD        = 166000000 * 10 ** 18;                     // Amount of tokens for the hoard company and the dev team\r\n    uint256 public constant totalPublicHRD     = totalHRD - totalDevHRD;                   // Amount of tokens for the Hoard at the beginning\r\n\r\n    // Hoard Token\r\n    HoardToken      public hoardToken;\r\n    HRDAllocation   public lockedAllocation;\r\n\r\n    // CONSTRUCTION\r\n\r\n    /// @param _hoard Hoard multisig contract\r\n    /// @param _migrationMaster migration master\r\n    /// @notice this is a two-phase process and after the contract is created, allocations have to be initialized\r\n    /// via an additional call\r\n    constructor (address _hoard, address _migrationMaster) public {\r\n        require(_hoard != address(0));\r\n        require(_migrationMaster != address(0));\r\n\r\n        hoardToken = new HoardToken(_hoard, _migrationMaster);\r\n        lockedAllocation = new HRDAllocation(_hoard, address(hoardToken), endowmentLockDuration, totalDevHRD);\r\n\r\n        // Generate endowment HRD and store it in a time-locked contract\r\n        hoardToken.mintTokens(address(lockedAllocation), totalDevHRD);\r\n\r\n        // At the beginning all tokens except endowmnet go to hoard\r\n        hoardToken.mintTokens(_hoard, totalPublicHRD);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"hoardToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalHRD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endowmentLockDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDevHRD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedAllocation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPublicHRD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_hoard\",\"type\":\"address\"},{\"name\":\"_migrationMaster\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"HoardDeployer","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c14f6e197f8116e5ee3dd5d6049635ba6d7060df000000000000000000000000c14f6e197f8116e5ee3dd5d6049635ba6d7060df","Library":"","SwarmSource":"bzzr://0513916afb617cbbdedccd6044a5b4d060c8ee7b9b32d60c4e25bfd2ae86331c"}]}