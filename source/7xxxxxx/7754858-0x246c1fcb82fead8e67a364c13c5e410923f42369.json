{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.7;\r\n\r\ncontract Regatta {\r\n\r\n    event Declare(uint race_number);\r\n    event Enter(uint race_number, address entrant, uint8 class, uint8 variant, bool repellent);\r\n\r\n    event Void(uint race_number, address judge);\r\n    event Finish(uint race_number, uint block_finish, address judge);\r\n    event Rename(address boat, bytes32 name);\r\n    event CashOut(address winner);\r\n\r\n    struct Race {\r\n        uint pool;\r\n\r\n        uint block_start;\r\n        uint block_finish;\r\n\r\n        Boat[10] boats;\r\n\r\n        uint boat_count;\r\n    }\r\n\r\n    struct Boat {\r\n        address owner;\r\n        uint8 class;\r\n        uint8 variant;\r\n        bool repellent;\r\n    }\r\n\r\n\r\n    mapping(address => uint) bank;\r\n    mapping(address => bytes32) boat_names;\r\n    mapping(uint => Race) races;\r\n\r\n    address blackbeard;\r\n    function mutiny(address new_beard) external{\r\n        require(msg.sender == blackbeard,\"impostor\");\r\n        blackbeard = new_beard;\r\n    }\r\n\r\n\r\n\r\n    uint race_number;\r\n    uint constant COURSE_LENGTH = 50;\r\n\r\n    uint constant PRICE_REPELLENT = 10; //%\r\n\r\n    uint[3] PRICE_CLASS = [\r\n    5 finney,\r\n    15 finney,\r\n    30 finney\r\n    ];\r\n\r\n    uint[3] MULTIPLIER_CLASS = [\r\n    100, //%\r\n    115, //%\r\n    130 //%\r\n    ];\r\n\r\n    uint constant MULTIPLIER_VARIANT = 2;\r\n    uint constant TIME_WAIT = 3;\r\n    uint constant MODULO_SQUID = 3;\r\n\r\n    constructor() public{\r\n        blackbeard = msg.sender;\r\n    }\r\n\r\n    //Added set price function in case ETH price changes make it too expensive\r\n    function set_PRICE_CLASS(uint class, uint PRICE) external{\r\n        require(msg.sender == blackbeard,\"permission\");\r\n        require(class < 3,\"class\");\r\n        PRICE_CLASS[class] = PRICE;\r\n    }\r\n\r\n    function calculate_fee(uint8 class, bool repellent) internal view returns(uint){\r\n        if(repellent){\r\n            return PRICE_CLASS[class] * (100 + PRICE_REPELLENT) / 100;\r\n        }else{\r\n            return PRICE_CLASS[class];\r\n        }\r\n    }\r\n    function increment_boat(uint hash, uint weather, uint boatNum, uint8 class, uint variant) internal view returns(uint){\r\n        uint increment = uint(keccak256(abi.encodePacked(boatNum,hash)))%10 * MULTIPLIER_CLASS[class]/100;\r\n        if(weather == variant){\r\n            increment *= MULTIPLIER_VARIANT;\r\n        }\r\n        return increment;\r\n    }\r\n    function check_race_finished() view internal returns(bool){\r\n        if(race_number == 0){\r\n            return true;\r\n        }else{\r\n            return races[race_number].block_finish != 0;\r\n        }\r\n    }\r\n    function check_race_started() view internal returns(bool){\r\n        return races[ race_number ].block_start != 0 &&\r\n        races[ race_number ].block_start < block.number;\r\n    }\r\n\r\n    //Void\r\n    function declare_void() public {\r\n        require(races[race_number].block_start != 0,\"unstarted\");\r\n        require(block.number > races[race_number].block_start + 255,\"not_void\");\r\n        require(races[race_number].block_finish == 0,\"finished\");\r\n\r\n        do_declare_void();\r\n\r\n        uint balance = bank[msg.sender];\r\n        bank[msg.sender] = 0;\r\n        msg.sender.transfer( balance );\r\n    }\r\n    //  -> set and pay\r\n    function do_declare_void() internal {\r\n        races[race_number].block_finish = races[race_number].block_start;\r\n\r\n        bank[ blackbeard ] += races[race_number].pool * 99/100;\r\n        bank[ msg.sender ] += races[race_number].pool /100;\r\n\r\n        emit Void(race_number, msg.sender);\r\n    }\r\n\r\n    //Finish\r\n    function declare_finish(uint block_finish) external {\r\n        require(races[race_number].block_start != 0,\"unstarted\");\r\n        require(block_finish < block.number, \"undetermined\");\r\n        require(block.number <= races[race_number].block_start + 255,\"void\");\r\n\r\n        if( races[race_number].block_finish != 0 ){\r\n            //Fallback and just withdraw that shit\r\n            uint balance = bank[msg.sender];\r\n            require(balance > 0, \"finished\");\r\n            bank[msg.sender] = 0;\r\n            msg.sender.transfer( balance );\r\n            emit CashOut( msg.sender );\r\n            return;\r\n        }\r\n\r\n        do_declare_finish(block_finish);\r\n\r\n        uint balance = bank[msg.sender];\r\n        bank[msg.sender] = 0;\r\n        msg.sender.transfer( balance );\r\n    }\r\n    //  -> set and pay\r\n    function do_declare_finish(uint block_finish) internal {\r\n        uint squid = 11;\r\n        uint leader;\r\n        uint[10] memory progress;\r\n        uint winners;\r\n\r\n        bool finished;\r\n\r\n\r\n        for(uint b = races[race_number].block_start; b <= block_finish; b++){\r\n            uint hash = uint(blockhash(b));\r\n            uint weather = hash%3;\r\n            for(uint boat = 0; boat < races[race_number].boat_count; boat++){\r\n                if(squid != boat){\r\n                    progress[boat] += increment_boat(\r\n                        hash,\r\n                        weather,\r\n                        boat,\r\n                        races[race_number].boats[boat].class,\r\n                        races[race_number].boats[boat].variant\r\n                    );\r\n                }\r\n                if(progress[boat] >= progress[leader]){\r\n                    leader = boat;\r\n                }\r\n\r\n                if(b == block_finish - 1){\r\n                    require(progress[boat] < COURSE_LENGTH,\"passed\");\r\n                }else if(b == block_finish){\r\n                    finished = finished || progress[boat] >= COURSE_LENGTH;\r\n                    if(progress[boat] >= COURSE_LENGTH){\r\n                        winners++;\r\n                    }\r\n                }\r\n            }\r\n            if(progress[leader] < COURSE_LENGTH && progress[leader] > COURSE_LENGTH/2 && !races[race_number].boats[leader].repellent && squid == 11 &&  uint(hash)%MODULO_SQUID == 0){\r\n                squid =  leader;\r\n            }\r\n        }\r\n\r\n        require(finished,\"unfinished\");\r\n        races[race_number].block_finish = block_finish;\r\n\r\n        uint paid = 0;\r\n        uint reward = races[race_number].pool * 95 / winners /100;\r\n        for( uint boat = 0; boat < races[race_number].boat_count; boat++){\r\n            if(progress[boat] >= COURSE_LENGTH){\r\n                bank[\r\n                races[race_number].boats[boat].owner\r\n                ] += reward;\r\n\r\n                paid += reward;\r\n            }\r\n        }\r\n        bank[ msg.sender ] += races[race_number].pool /100;\r\n        paid += races[race_number].pool /100;\r\n\r\n        bank[ blackbeard ] += races[race_number].pool - paid;\r\n\r\n\r\n        emit Finish(race_number, block_finish, msg.sender);\r\n    }\r\n\r\n    //Declare Race\r\n    function declare_race(uint8 class, uint8 variant, bool repellent) public payable{\r\n\r\n        require(races[race_number].block_finish != 0 || race_number == 0,\"unfinished\");\r\n\r\n        require(class < 3,\"class\");\r\n        uint fee = calculate_fee(class,repellent);\r\n        uint contribution = calculate_fee(class,false);\r\n        require( msg.value == fee, \"payment\");\r\n        require(variant < 3,\"variant\");\r\n\r\n        race_number++;\r\n\r\n        races[race_number].boat_count = 2;\r\n        races[race_number].boats[0] = Boat(msg.sender,class,variant,repellent);\r\n        races[race_number].pool += contribution;\r\n\r\n        if(fee > contribution){\r\n            bank[blackbeard] += fee - contribution;\r\n        }\r\n\r\n\r\n        emit Declare(race_number);\r\n        emit Enter(race_number, msg.sender, class, variant, repellent);\r\n    }\r\n\r\n    //Enter Race\r\n    function enter_race(uint8 class, uint8 variant, bool repellent) public payable{\r\n\r\n        require(class < 3,\"class\");\r\n        uint fee = calculate_fee(class,repellent);\r\n        uint contribution = calculate_fee(class,false);\r\n        require( msg.value == fee, \"payment\");\r\n        require(variant < 3,\"variant\");\r\n\r\n        require(!check_race_started(),\"started\");\r\n        require(!check_race_finished(),\"finished\");\r\n\r\n        require(races[race_number].boat_count < 10,\"full\");\r\n        require(race_number > 0,\"undeclared\");\r\n\r\n        if(races[race_number].block_start == 0){\r\n            races[race_number].block_start = block.number + TIME_WAIT;\r\n            races[race_number].boats[1] = Boat(msg.sender,class,variant,repellent);\r\n        }else{\r\n            races[race_number].boats[\r\n            races[race_number].boat_count\r\n            ] = Boat(msg.sender,class,variant,repellent);\r\n            races[race_number].boat_count++;\r\n        }\r\n        races[race_number].pool += contribution;\r\n\r\n        if(fee > contribution){\r\n            bank[blackbeard] += fee - contribution;\r\n        }\r\n\r\n        emit Enter(race_number, msg.sender, class, variant, repellent);\r\n\r\n    }\r\n\r\n    //Important guys\r\n    function cleanup(uint block_finish_last) internal {\r\n        if(race_number == 0){\r\n            //Initial condition, skip\r\n        }else if(races[race_number].block_start != 0\r\n        && races[race_number].block_start == races[race_number].block_finish\r\n        ){\r\n            //If races[race_number].block_start == races[race_number].block_finish,\r\n            //it's been voided, skip\r\n        }else\r\n\r\n        //If block_finish_last isn't 0\r\n        //&& there is an unfinished race,\r\n        //finish it, (pay winners)\r\n            if(block_finish_last != 0\r\n            && races[race_number].block_finish == 0\r\n            && races[race_number].block_start != 0\r\n            && races[race_number].block_start < block.number\r\n            && block_finish_last <  block.number\r\n            ){\r\n                //Finish it\r\n                do_declare_finish(block_finish_last);\r\n            }else\r\n\r\n            //else if block_finish_last is 0\r\n            //&& there is a void race\r\n            //void it\r\n                if(block_finish_last == 0\r\n                && races[race_number].block_finish == 0\r\n                && races[race_number].block_start != 0\r\n                && races[race_number].block_start + 255 < block.number\r\n                ){\r\n                    //Void it\r\n                    do_declare_void();\r\n                }\r\n    }\r\n    function enter_next_race(uint block_finish_last, uint8 class, uint8 variant, bool repellent) external payable{\r\n        cleanup(block_finish_last);\r\n\r\n        //if the current race is finished\r\n        if(races[race_number].block_finish != 0 || race_number == 0){\r\n            //Start new race\r\n            declare_race(class,variant,repellent);\r\n        }else{\r\n            //Enter next race\r\n            enter_race(class,variant,repellent);\r\n        }\r\n\r\n\r\n    }\r\n    function collect_winnings(uint block_finish_last) external {\r\n        cleanup(block_finish_last);\r\n\r\n        grab_gold();\r\n    }\r\n\r\n\r\n    //Admin\r\n    function rename_boat(bytes32 name) external {\r\n        boat_names[msg.sender] = name;\r\n        emit Rename(msg.sender,name);\r\n    }\r\n    function grab_gold() public {\r\n        uint balance = bank[msg.sender];\r\n        require(balance > 0,\"broke\");\r\n        bank[msg.sender] = 0;\r\n\r\n\r\n        msg.sender.transfer( balance );\r\n        emit CashOut(msg.sender);\r\n    }\r\n\r\n\r\n    //Read\r\n    function get_pool() external view returns(uint){\r\n        return races[race_number].pool;\r\n    }\r\n    function get_race_number() public view returns (uint){\r\n        return race_number;\r\n    }\r\n    function get_weather() public view returns (uint){\r\n        uint hash = uint(blockhash(block.number - 1));\r\n        return  hash%3;\r\n    }\r\n    function get_progress() public view  returns (uint[10] memory progress, uint block_finish, uint weather, uint squid, uint block_now, bytes32[10] memory history, uint block_squid){\r\n        //History\r\n        for(uint b = 0; b < 10; b++){\r\n            history[b] = blockhash(b + block.number - 10 );\r\n        }\r\n\r\n        if(races[race_number].block_start == 0){\r\n            return (progress, block_finish, 0, 11, block.number, history, 0);\r\n        }\r\n\r\n        squid = 11;\r\n        uint leader;\r\n        for(uint b = races[race_number].block_start; b < block.number; b++){\r\n            uint hash = uint(blockhash(b));\r\n            weather = hash%3;\r\n            for(uint boat = 0; boat < races[race_number].boat_count; boat++){\r\n                if(squid != boat){\r\n                    progress[boat] += increment_boat(\r\n                        hash,\r\n                        weather,\r\n                        boat,\r\n                        races[race_number].boats[boat].class,\r\n                        races[race_number].boats[boat].variant\r\n                    );\r\n                }\r\n                if(progress[boat] >= progress[leader]){\r\n                    leader = boat;\r\n                }\r\n                if(progress[boat] >= COURSE_LENGTH ){\r\n                    block_finish = b;\r\n                }\r\n            }\r\n\r\n            if(block_finish != 0){\r\n                break;\r\n            }\r\n            if(\r\n                progress[leader] < COURSE_LENGTH\r\n                && progress[leader] > COURSE_LENGTH/2\r\n                && !races[race_number].boats[leader].repellent\r\n            && squid == 11\r\n            && hash%MODULO_SQUID == 0\r\n            ){\r\n                squid =  leader;\r\n                block_squid = b;\r\n            }\r\n        }\r\n\r\n        return (progress, block_finish, weather, squid, block.number, history, block_squid);\r\n    }\r\n\r\n    function get_times() public view returns (uint block_start, uint block_finish, uint block_current){\r\n        return (\r\n        races[race_number].block_start,\r\n        races[race_number].block_finish,\r\n        block.number\r\n        );\r\n    }\r\n    function get_boats() public view returns (\r\n        address[10] memory owner,\r\n        uint8[10] memory class,\r\n        uint8[10] memory variant,\r\n        bool[10] memory repellent\r\n    ){\r\n        for(uint boat = 0; boat < 10; boat++){\r\n            owner[boat] = races[race_number].boats[boat].owner;\r\n            class[boat] = races[race_number].boats[boat].class;\r\n            variant[boat] = races[race_number].boats[boat].variant;\r\n            repellent[boat] = races[race_number].boats[boat].repellent;\r\n        }\r\n        return (owner,class,variant,repellent);\r\n    }\r\n\r\n    function get_name(address boat) public view returns(bytes32 name){\r\n        return boat_names[boat];\r\n    }\r\n    function get_balance() public view returns(uint balance){\r\n        return bank[msg.sender];\r\n    }\r\n    function get_boat_count() public view returns(uint boat_count){\r\n        return races[race_number].boat_count;\r\n    }\r\n    function get_pool_past(uint past_race_number) external view returns(uint pool){\r\n        return races[past_race_number].pool;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"get_weather\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"block_finish\",\"type\":\"uint256\"}],\"name\":\"declare_finish\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"past_race_number\",\"type\":\"uint256\"}],\"name\":\"get_pool_past\",\"outputs\":[{\"name\":\"pool\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"grab_gold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"block_finish_last\",\"type\":\"uint256\"}],\"name\":\"collect_winnings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"declare_void\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"class\",\"type\":\"uint256\"},{\"name\":\"PRICE\",\"type\":\"uint256\"}],\"name\":\"set_PRICE_CLASS\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_times\",\"outputs\":[{\"name\":\"block_start\",\"type\":\"uint256\"},{\"name\":\"block_finish\",\"type\":\"uint256\"},{\"name\":\"block_current\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"class\",\"type\":\"uint8\"},{\"name\":\"variant\",\"type\":\"uint8\"},{\"name\":\"repellent\",\"type\":\"bool\"}],\"name\":\"declare_race\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"block_finish_last\",\"type\":\"uint256\"},{\"name\":\"class\",\"type\":\"uint8\"},{\"name\":\"variant\",\"type\":\"uint8\"},{\"name\":\"repellent\",\"type\":\"bool\"}],\"name\":\"enter_next_race\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"rename_boat\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"class\",\"type\":\"uint8\"},{\"name\":\"variant\",\"type\":\"uint8\"},{\"name\":\"repellent\",\"type\":\"bool\"}],\"name\":\"enter_race\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_race_number\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_boat_count\",\"outputs\":[{\"name\":\"boat_count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_balance\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_pool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_progress\",\"outputs\":[{\"name\":\"progress\",\"type\":\"uint256[10]\"},{\"name\":\"block_finish\",\"type\":\"uint256\"},{\"name\":\"weather\",\"type\":\"uint256\"},{\"name\":\"squid\",\"type\":\"uint256\"},{\"name\":\"block_now\",\"type\":\"uint256\"},{\"name\":\"history\",\"type\":\"bytes32[10]\"},{\"name\":\"block_squid\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_boats\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address[10]\"},{\"name\":\"class\",\"type\":\"uint8[10]\"},{\"name\":\"variant\",\"type\":\"uint8[10]\"},{\"name\":\"repellent\",\"type\":\"bool[10]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"boat\",\"type\":\"address\"}],\"name\":\"get_name\",\"outputs\":[{\"name\":\"name\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_beard\",\"type\":\"address\"}],\"name\":\"mutiny\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"race_number\",\"type\":\"uint256\"}],\"name\":\"Declare\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"race_number\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"entrant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"class\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"variant\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"repellent\",\"type\":\"bool\"}],\"name\":\"Enter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"race_number\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"judge\",\"type\":\"address\"}],\"name\":\"Void\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"race_number\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"block_finish\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"judge\",\"type\":\"address\"}],\"name\":\"Finish\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"boat\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"Rename\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"CashOut\",\"type\":\"event\"}]","ContractName":"Regatta","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1e38f8a2d0104c1c7d1eef2de47d7d6461c6f94cd2a9400e71db539b115bc274"}]}