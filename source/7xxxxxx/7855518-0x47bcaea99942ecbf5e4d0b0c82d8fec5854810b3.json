{"status":"1","message":"OK","result":[{"SourceCode":"{\"AdminManaged.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\nimport { Roles } from \\\"./Roles.sol\\\";\\r\\n\\r\\ncontract AdminManaged{\\r\\n    using Roles for Roles.Role;\\r\\n\\r\\n    Roles.Role internal admins_;\\r\\n\\r\\n    constructor(address _firstAdmin) public {\\r\\n        admins_.add(_firstAdmin);\\r\\n    }\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        require(admins_.has(msg.sender), \\\"User not authorised\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev    Used to add an admin \\r\\n    /// @param _newAdmin        :address The address of the new admin\\r\\n    function addAdmin(address _newAdmin) external onlyAdmin {\\r\\n        admins_.add(_newAdmin);\\r\\n        require(admins_.has(_newAdmin), \\\"User not added as admin\\\");\\r\\n    }\\r\\n\\r\\n    /// @dev    Used to remove admins\\r\\n    /// @param _oldAdmin        :address The address of the previous admin\\r\\n    function removeAdmin(address _oldAdmin) external onlyAdmin {\\r\\n        admins_.remove(_oldAdmin);\\r\\n        require(!admins_.has(_oldAdmin), \\\"User not removed as admin\\\");\\r\\n    }\\r\\n\\r\\n    /// @dev    Checking admin rights\\r\\n    /// @param _account         :address in question \\r\\n    /// @return bool            \\r\\n    function isAdmin(address _account) external view returns(bool) {\\r\\n        return admins_.has(_account);\\r\\n    }\\r\\n\\r\\n}\"},\"BaseFactory.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\ncontract BaseFactory {\\r\\n    address internal admin_;\\r\\n    mapping(address =\\u003e bool) internal rootFactories_;\\r\\n\\r\\n    constructor(address _rootFactory) public {\\r\\n        rootFactories_[_rootFactory] = true;\\r\\n        admin_ = msg.sender;\\r\\n    }\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == admin_, \\\"Not authorised\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyRootFactory() {\\r\\n        require(rootFactories_[msg.sender], \\\"Not authorised\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function addRootFactory(address _newRoot) external onlyAdmin() {\\r\\n        rootFactories_[_newRoot] = true;\\r\\n    }\\r\\n\\r\\n    function removeRootFactory(address _newRoot) external onlyAdmin() {\\r\\n        rootFactories_[_newRoot] = false;\\r\\n    }\\r\\n}\"},\"BaseUtility.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\nimport { Roles } from \\\"./Roles.sol\\\";\\r\\nimport { SafeMath } from \\\"./SafeMath.sol\\\";\\r\\nimport { AdminManaged } from \\\"./AdminManaged.sol\\\";\\r\\n\\r\\n\\r\\n/// @author Ryan @ Protea \\r\\n/// @title Generic Utility base\\r\\ncontract BaseUtility is AdminManaged{\\r\\n    using SafeMath for uint256;\\r\\n    using Roles for Roles.Role;\\r\\n\\r\\n    Roles.Role internal admins_;\\r\\n\\r\\n    address internal tokenManager_;\\r\\n    address internal membershipManager_;\\r\\n\\r\\n    uint256 internal index_ = 0;\\r\\n\\r\\n    /// @dev Sets the address of the admin to the msg.sender.\\r\\n    /// @param _tokenManager        :address\\r\\n    /// @param _membershipManager   :address\\r\\n    /// @param _communityCreator    :address\\r\\n    constructor (\\r\\n        address _tokenManager, \\r\\n        address _membershipManager,\\r\\n        address _communityCreator\\r\\n    ) \\r\\n        public \\r\\n        AdminManaged(_communityCreator)\\r\\n    {\\r\\n        tokenManager_ = _tokenManager;\\r\\n        membershipManager_ = _membershipManager;\\r\\n    }\\r\\n\\r\\n    modifier onlyMembershipManager() {\\r\\n        require(msg.sender == membershipManager_, \\\"Not authorised\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyToken() {\\r\\n        require(msg.sender == address(tokenManager_), \\\"Not registered token address\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev    Returns the registered token manager\\r\\n    /// @return address\\r\\n    function tokenManager() external view returns(address) {\\r\\n        return tokenManager_;\\r\\n    }\\r\\n\\r\\n    /// @dev    Returns the registered membership manager\\r\\n    /// @return address\\r\\n    function membershipManager() external view returns(address) {\\r\\n        return membershipManager_;\\r\\n    }\\r\\n\\r\\n    /// @dev    Returns the current index\\r\\n    /// @return address\\r\\n    function index() external view returns(uint256) {\\r\\n        return index_;\\r\\n    }\\r\\n}\"},\"EventManagerV1.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\nimport { SafeMath } from \\\"./SafeMath.sol\\\";\\r\\nimport { IMembershipManager } from \\\"./IMembershipManager.sol\\\";\\r\\nimport { BaseUtility } from \\\"./BaseUtility.sol\\\";\\r\\n\\r\\n/// @author Ryan @ Protea\\r\\n/// @title Basic staked event manager\\r\\ncontract EventManagerV1 is BaseUtility {\\r\\n    mapping(uint256 =\\u003e EventData) internal events_;\\r\\n    /// For a reward to be issued, user state must be set to 99, meaning \\\"Rewardable\\\" this is to be considered the final state of users in issuer contracts\\r\\n    mapping(uint256 =\\u003e mapping(address =\\u003e uint8)) internal memberState_;\\r\\n    // States:\\r\\n    // 0: Not registered\\r\\n    // 1: RSVP\\u0027d\\r\\n    // 98: Paid\\r\\n    // 99: Attended (Rewardable)\\r\\n\\r\\n    struct EventData{\\r\\n        address organiser;\\r\\n        uint256 requiredDai;\\r\\n        uint256 gift;\\r\\n        uint24 state; // 0: not created, 1: pending start, 2: started, 3: ended, 4: cancelled\\r\\n        uint24 maxAttendees;\\r\\n        address[] currentAttendees;\\r\\n        uint24 totalAttended;\\r\\n        string name;\\r\\n    }\\r\\n\\r\\n    event EventCreated(uint256 indexed index, address publisher);\\r\\n    event EventStarted(uint256 indexed index, address publisher);\\r\\n    event EventConcluded(uint256 indexed index, address publisher, uint256 state);\\r\\n    event MemberRegistered(uint256 indexed index, address member, uint256 memberIndex);\\r\\n    event MemberCancelled(uint256 indexed index, address member);\\r\\n    event MemberAttended(uint256 indexed index, address member);\\r\\n\\r\\n    /// @dev Sets the address of the admin to the msg.sender.\\r\\n    /// @param _tokenManager        :address\\r\\n    /// @param _membershipManager   :address\\r\\n    /// @param _communityCreator    :address\\r\\n    constructor (\\r\\n        address _tokenManager,\\r\\n        address _membershipManager,\\r\\n        address _communityCreator\\r\\n    )\\r\\n        public\\r\\n        BaseUtility(_tokenManager, _membershipManager, _communityCreator)\\r\\n    {}\\r\\n\\r\\n    modifier onlyRsvpAvailable(uint256 _index) {\\r\\n        uint24 currentAttending = uint24(events_[_index].currentAttendees.length);\\r\\n        require((events_[_index].maxAttendees == 0 || currentAttending \\u003c events_[_index].maxAttendees), \\\"RSVP not available\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyActiveMember(address _account){\\r\\n        (,,uint256 availableStake) = IMembershipManager(membershipManager_).getMembershipStatus(_account);\\r\\n        require(availableStake \\u003e 0, \\\"Membership invalid\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyMember(address _member, uint256 _index){\\r\\n        require(memberState_[_index][_member] \\u003e= 1, \\\"User not registered\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOrganiser(uint256 _index) {\\r\\n        require(events_[_index].organiser == msg.sender, \\\"Account not organiser\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyPending(uint256 _index) {\\r\\n        require(events_[_index].state == 1, \\\"Event not pending\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyStarted(uint256 _index) {\\r\\n        require(events_[_index].state == 2, \\\"Event not started\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyRegistered(uint256 _index) {\\r\\n        require(memberState_[_index][msg.sender] == 1, \\\"User not registered\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev Creates an event.\\r\\n    /// @param _name                :string The name of the event.\\r\\n    /// @param _maxAttendees        :uint24 The max number of attendees for this event.\\r\\n    /// @param _organiser           :address The orgoniser of the event\\r\\n    /// @param _requiredDai       :uint256  The price of a \\u0027deposit\\u0027 for the event.\\r\\n    function createEvent(\\r\\n        string calldata _name,\\r\\n        uint24 _maxAttendees,\\r\\n        address _organiser,\\r\\n        uint256 _requiredDai\\r\\n    )\\r\\n        external\\r\\n        onlyActiveMember(msg.sender)\\r\\n        returns(bool)\\r\\n    {\\r\\n        uint256 index = index_;\\r\\n\\r\\n        events_[index].name = _name;\\r\\n        events_[index].maxAttendees = _maxAttendees;\\r\\n        events_[index].organiser = _organiser;\\r\\n        events_[index].requiredDai = _requiredDai;\\r\\n        events_[index].state = 1;\\r\\n        memberState_[index][_organiser] = 99;\\r\\n        events_[index].currentAttendees.push(_organiser);\\r\\n\\r\\n        index_++;\\r\\n        emit EventCreated(index, _organiser);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @dev Changes the limit on the number of participants. Only the event organiser can call this function.\\r\\n    /// @param _index           :uint256 The index of the event.\\r\\n    /// @param _limit           :uint24  The new participation limit for the event.\\r\\n    function changeParticipantLimit(uint256 _index, uint24 _limit)\\r\\n        external\\r\\n        onlyOrganiser(_index)\\r\\n    {\\r\\n        if(_limit == 0) {\\r\\n            events_[_index].maxAttendees = 0;\\r\\n        }else{\\r\\n            require((events_[_index].currentAttendees.length \\u003c _limit), \\\"Limit can only be increased\\\");\\r\\n            events_[_index].maxAttendees = _limit;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Allows an event organiser to end an event. This function is only callable by the organiser of the event.\\r\\n    /// @param _index : The index of the event in the array of events.\\r\\n    function startEvent(uint256 _index)\\r\\n        external\\r\\n        onlyOrganiser(_index)\\r\\n        onlyPending(_index)\\r\\n    {\\r\\n        require(events_[_index].state == 1, \\\"Unable to start event, either already started or ended\\\");\\r\\n        events_[_index].state = 2;\\r\\n        emit EventStarted(_index, msg.sender);\\r\\n    }\\r\\n\\r\\n    /// @dev Allows an event organiser to end an event. This function is only callable by the manager of the event.\\r\\n    /// @param _index : The index of the event in the array of events.\\r\\n    function endEvent(uint256 _index)\\r\\n        external\\r\\n        onlyOrganiser(_index)\\r\\n        onlyStarted(_index)\\r\\n    {\\r\\n        events_[_index].state = 3;\\r\\n        calcGift(_index);\\r\\n        emit EventConcluded(_index, msg.sender, events_[_index].state);\\r\\n    }\\r\\n\\r\\n    /// @dev Allows an event organiser to cancel an event.\\r\\n    ///     This function is only callable by the event organiser.\\r\\n    /// @param _index : The index of the event in the array of events.\\r\\n    function cancelEvent(uint256 _index)\\r\\n        external\\r\\n        onlyOrganiser(_index)\\r\\n        onlyPending(_index)\\r\\n    {\\r\\n        events_[_index].state = 4;\\r\\n        emit EventConcluded(_index, msg.sender, events_[_index].state);\\r\\n    }\\r\\n\\r\\n    /// @dev Allows a member to RSVP for an event.\\r\\n    /// @param _index           :uint256 The index of the event.\\r\\n    function rsvp(uint256 _index)\\r\\n        external\\r\\n        onlyPending(_index)\\r\\n        onlyRsvpAvailable(_index)\\r\\n        returns (bool)\\r\\n    {\\r\\n        require(memberState_[_index][msg.sender] == 0, \\\"RSVP not available\\\");\\r\\n        require(IMembershipManager(membershipManager_).lockCommitment(msg.sender, _index, events_[_index].requiredDai), \\\"Insufficent tokens\\\");\\r\\n\\r\\n        memberState_[_index][msg.sender] = 1;\\r\\n        events_[_index].currentAttendees.push(msg.sender);\\r\\n        emit MemberRegistered(_index, msg.sender, events_[_index].currentAttendees.length - 1);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @dev Allows a member to cancel an RSVP for an event.\\r\\n    /// @param _index           :uint256 The index of the event.\\r\\n    function cancelRsvp(uint256 _index)\\r\\n        external\\r\\n        onlyPending(_index)\\r\\n        returns (bool)\\r\\n    {\\r\\n        require(memberState_[_index][msg.sender] == 1, \\\"User not RSVP\\u0027d\\\");\\r\\n        require(IMembershipManager(membershipManager_).unlockCommitment(msg.sender, _index, 0), \\\"Unlock of tokens failed\\\");\\r\\n\\r\\n        memberState_[_index][msg.sender] = 0;\\r\\n\\r\\n        events_[_index].currentAttendees = removeFromList(msg.sender, events_[_index].currentAttendees);\\r\\n\\r\\n        emit MemberCancelled(_index, msg.sender);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @dev Allows a member to confirm attendance. Uses the msg.sender as the address of the member.\\r\\n    /// @param _index : The index of the event in the array.\\r\\n    function confirmAttendance(uint256 _index)\\r\\n        external\\r\\n        onlyStarted(_index)\\r\\n        onlyRegistered(_index)\\r\\n    {\\r\\n        memberState_[_index][msg.sender] = 99;\\r\\n        events_[_index].totalAttended = events_[_index].totalAttended + 1;\\r\\n\\r\\n        require(IMembershipManager(membershipManager_).unlockCommitment(msg.sender, _index, 0), \\\"Unlocking has failed\\\");\\r\\n        // Manual exposed attend until Proof of Attendance\\r\\n        //partial release mechanisim is finished\\r\\n        emit MemberAttended(_index, msg.sender);\\r\\n    }\\r\\n\\r\\n    /// @dev Allows the admin to confirm attendance for attendees\\r\\n    /// @param _index       :uint256 The index of the event in the array.\\r\\n    /// @param _attendees   :address[] List of attendee accounts.\\r\\n    function organiserConfirmAttendance(uint256 _index, address[] calldata _attendees)\\r\\n        external\\r\\n        onlyStarted(_index)\\r\\n        onlyOrganiser(_index)\\r\\n    {\\r\\n        uint256 arrayLength = _attendees.length;\\r\\n        for(uint256 i = 0; i \\u003c arrayLength; i++){\\r\\n            if(memberState_[_index][_attendees[i]] == 1){\\r\\n                memberState_[_index][_attendees[i]] = 99;\\r\\n                events_[_index].totalAttended = events_[_index].totalAttended + 1;\\r\\n\\r\\n                require(IMembershipManager(membershipManager_).unlockCommitment(_attendees[i], _index, 0), \\\"Unlocking has failed\\\");\\r\\n                emit MemberAttended(_index, _attendees[i]);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Pays out an atendee of an event. This function is only callable by the attendee.\\r\\n    /// @param _member : The member to be paid out\\r\\n    /// @param _index : The index of the event of the array.\\r\\n    function claimGift(address _member, uint256 _index)\\r\\n        external\\r\\n        onlyMember(_member, _index)\\r\\n        returns(bool)\\r\\n    {\\r\\n        require(events_[_index].state == 3 || events_[_index].state == 4, \\\"Event not concluded\\\");\\r\\n        if(events_[_index].state == 3){\\r\\n            require(memberState_[_index][_member] == 99, \\\"Deposits returned\\\");\\r\\n            require(IMembershipManager(membershipManager_).manualTransfer(events_[_index].gift, _index, _member), \\\"Return amount invalid\\\");\\r\\n            memberState_[_index][msg.sender] = 98;\\r\\n        }else{\\r\\n            require(memberState_[_index][msg.sender] == 1, \\\"Request invalid\\\");\\r\\n            require(IMembershipManager(membershipManager_).unlockCommitment(msg.sender, _index, 50), \\\"Unlocking has failed\\\");\\r\\n            memberState_[_index][msg.sender] = 98;\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @dev Allows an organiser to send any remaining tokens that could be left from math inaccuracies\\r\\n    /// @param _index       :uint265 The index of the event of the array.\\r\\n    /// @param _target      :address Account to receive the remaining tokens\\r\\n    /// @notice  Due to division having some aspects of rounding, theres a potential to have tiny amounts of tokens locked, since these grow in value they should be managed\\r\\n    function emptyActivitySlot(uint256 _index, address _target)\\r\\n        external\\r\\n        onlyOrganiser(_index)\\r\\n    {\\r\\n        require(events_[_index].state == 3, \\\"Event not concluded\\\");\\r\\n        uint256 totalRemaining = IMembershipManager(membershipManager_).getUtilityStake(address(this), _index);\\r\\n        require(totalRemaining \\u003c= 100, \\\"Pool not low enough to allow\\\");\\r\\n        require(IMembershipManager(membershipManager_).manualTransfer(totalRemaining, _index, _target), \\\"Return amount invalid\\\");\\r\\n    }\\r\\n\\r\\n    /// @dev Calculates the gift for atendees.\\r\\n    /// @param _index : The index of the event in the event manager.\\r\\n    function calcGift(uint256 _index)\\r\\n        internal\\r\\n    {\\r\\n        uint256 totalRemaining = IMembershipManager(membershipManager_).getUtilityStake(address(this), _index);\\r\\n        if(totalRemaining \\u003e 0){\\r\\n            events_[_index].gift = totalRemaining.div(events_[_index].totalAttended + 1);// accounts for the organizer to get a share\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Used to get the members current state per activity\\r\\n    /// @param _member : The member to be paid out\\r\\n    /// @param _index : The index of the event in the event manager.\\r\\n    function getUserState(address _member, uint256 _index) external view returns(uint8) {\\r\\n        return memberState_[_index][_member];\\r\\n    }\\r\\n\\r\\n    /// @dev Gets the details of an event.\\r\\n    /// @param _index           : The index of the event in the array of events.\\r\\n    /// @return                 :EventData Event details.\\r\\n    function getEvent(uint256 _index)\\r\\n        external\\r\\n        view\\r\\n        returns(\\r\\n            string memory,\\r\\n            uint24,\\r\\n            uint256,\\r\\n            uint24,\\r\\n            uint256\\r\\n        )\\r\\n    {\\r\\n        return (\\r\\n            events_[_index].name,\\r\\n            events_[_index].maxAttendees,\\r\\n            events_[_index].requiredDai,\\r\\n            events_[_index].state,\\r\\n            events_[_index].gift\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev Get a list of RSVP\\u0027d members\\r\\n    /// @param _index : The index of the event in the event manager.\\r\\n    function getRSVPdAttendees(uint256 _index)\\r\\n        external\\r\\n        view\\r\\n        returns(address[] memory)\\r\\n    {\\r\\n        return events_[_index].currentAttendees;\\r\\n    }\\r\\n\\r\\n    /// @dev Used to get the organiser for a specific event\\r\\n    /// @param _index : The index of the event in the event manager.\\r\\n    function getOrganiser(uint256 _index)\\r\\n        external\\r\\n        view\\r\\n        returns(address)\\r\\n    {\\r\\n        return events_[_index].organiser;\\r\\n    }\\r\\n\\r\\n    /// @dev Used for removing members from RSVP lists\\r\\n    /// @param _target      :address account to remove\\r\\n    /// @param _addressList :address[] The current list of attendees\\r\\n    function removeFromList(address _target, address[] memory _addressList) internal pure returns(address[] memory) {\\r\\n        uint256 offset = 0;\\r\\n        address[] memory newList = new address[](_addressList.length-1);\\r\\n        uint256 arrayLength = _addressList.length;\\r\\n        for (uint256 i = 0; i \\u003c arrayLength; i++){\\r\\n            if(_addressList[i] != _target){\\r\\n                newList[i - offset] = _addressList[i];\\r\\n            }else{\\r\\n                offset = 1;\\r\\n            }\\r\\n        }\\r\\n        return newList;\\r\\n    }\\r\\n}\"},\"EventManagerV1Factory.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\nimport { EventManagerV1 } from \\\"./EventManagerV1.sol\\\";\\r\\nimport { BaseFactory } from \\\"./BaseFactory.sol\\\";\\r\\nimport { IEventManagerFactory } from \\\"./IEventManagerFactory.sol\\\";\\r\\n\\r\\ncontract EventManagerV1Factory is BaseFactory, IEventManagerFactory {\\r\\n    constructor(address _rootFactory) public BaseFactory(_rootFactory) {\\r\\n\\r\\n    }\\r\\n    \\r\\n    function deployEventManager(address _tokenManager, address _membershipManager, address _communityCreator) \\r\\n        external \\r\\n        onlyRootFactory() \\r\\n        returns (address) \\r\\n    {\\r\\n        return address( \\r\\n            new EventManagerV1(\\r\\n                _tokenManager,\\r\\n                _membershipManager,\\r\\n                _communityCreator\\r\\n        ));\\r\\n    }\\r\\n}\"},\"IEventManagerFactory.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\ninterface IEventManagerFactory{\\r\\n    function deployEventManager(address _tokenManager, address _membershipManager, address _communityCreator) external returns (address);\\r\\n}\"},\"IMembershipManager.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\n/// @author Ryan @ Protea \\r\\n/// @title IMembershipManager\\r\\ninterface IMembershipManager {\\r\\n    struct RegisteredUtility{\\r\\n        bool active;\\r\\n        mapping(uint256 =\\u003e uint256) lockedStakePool; // Total Stake withheld by the utility\\r\\n        mapping(uint256 =\\u003e mapping(address =\\u003e uint256)) contributions; // Traking individual token values sent in\\r\\n    }\\r\\n\\r\\n    struct Membership{\\r\\n        uint256 currentDate;\\r\\n        uint256 availableStake;\\r\\n        uint256 reputation;\\r\\n    }\\r\\n\\r\\n    event UtilityAdded(address issuer);\\r\\n    event UtilityRemoved(address issuer);\\r\\n    event ReputationRewardSet(address indexed issuer, uint8 id, uint256 amount);\\r\\n\\r\\n    event StakeLocked(address indexed member, address indexed utility, uint256 tokenAmount);\\r\\n    event StakeUnlocked(address indexed member, address indexed utility, uint256 tokenAmount);\\r\\n\\r\\n    event MembershipStaked(address indexed member, uint256 tokensStaked);\\r\\n   \\r\\n    function initialize(address _tokenManager) external returns(bool);\\r\\n\\r\\n    function addUtility(address _utility) external;\\r\\n\\r\\n    function removeUtility(address _utility) external;\\r\\n\\r\\n    function addAdmin(address _newAdmin) external;\\r\\n\\r\\n    function addSystemAdmin(address _newAdmin) external;\\r\\n\\r\\n    function removeAdmin(address _newAdmin) external;\\r\\n\\r\\n    function removeSystemAdmin(address _newAdmin) external;\\r\\n\\r\\n    function setReputationRewardEvent(address _utility, uint8 _id, uint256 _rewardAmount) external;\\r\\n\\r\\n    function issueReputationReward(address _member, uint8 _rewardId) external returns (bool);\\r\\n  \\r\\n    function stakeMembership(uint256 _daiValue, address _member) external returns(bool);\\r\\n\\r\\n    function manualTransfer(uint256 _tokenAmount, uint256 _index, address _member) external returns (bool);\\r\\n\\r\\n    function withdrawMembership(uint256 _daiValue, address _member) external returns(bool);\\r\\n\\r\\n    function lockCommitment(address _member, uint256 _index, uint256 _daiValue) external returns (bool);\\r\\n\\r\\n    function unlockCommitment(address _member, uint256 _index, uint8 _reputationEvent) external returns (bool);\\r\\n\\r\\n    function reputationOf(address _account) external view returns(uint256);\\r\\n\\r\\n    function getMembershipStatus(address _member) external view returns(uint256, uint256, uint256);\\r\\n\\r\\n    function getUtilityStake(address _utility, uint256 _index) external view returns(uint256);\\r\\n    \\r\\n    function getMemberUtilityStake(address _utility, address _member, uint256 _index) external view returns(uint256);\\r\\n\\r\\n    function getReputationRewardEvent(address _utility, uint8 _id) external view returns(uint256);\\r\\n\\r\\n    function tokenManager() external view returns(address);\\r\\n}\"},\"Roles.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\n/**\\r\\n * @title Roles\\r\\n * @dev Library for managing addresses assigned to a Role.\\r\\n */\\r\\nlibrary Roles {\\r\\n    struct Role {\\r\\n        mapping (address =\\u003e bool) bearer;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev give an account access to this role\\r\\n     */\\r\\n    function add(Role storage role, address account) internal {\\r\\n        require(account != address(0));\\r\\n        require(!has(role, account));\\r\\n\\r\\n        role.bearer[account] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev remove an account\\u0027s access to this role\\r\\n     */\\r\\n    function remove(Role storage role, address account) internal {\\r\\n        require(account != address(0));\\r\\n        require(has(role, account));\\r\\n\\r\\n        role.bearer[account] = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev check if an account has this role\\r\\n     * @return bool\\r\\n     */\\r\\n    function has(Role storage role, address account)\\r\\n      internal\\r\\n      view\\r\\n      returns (bool)\\r\\n    {\\r\\n        require(account != address(0));\\r\\n        return role.bearer[account];\\r\\n    }\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Math operations with safety checks that revert on error\\r\\n */\\r\\nlibrary SafeMath {\\r\\n\\r\\n  /**\\r\\n  * @dev Multiplies two numbers, reverts on overflow.\\r\\n  */\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    uint256 c = a * b;\\r\\n    require(c / a == b);\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\r\\n  */\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b \\u003e 0); // Solidity only automatically asserts when dividing by 0\\r\\n    uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\r\\n  */\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b \\u003c= a);\\r\\n    uint256 c = a - b;\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Adds two numbers, reverts on overflow.\\r\\n  */\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    require(c \\u003e= a);\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\r\\n  * reverts when dividing by zero.\\r\\n  */\\r\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b != 0);\\r\\n    return a % b;\\r\\n  }\\r\\n}\\r\\n\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tokenManager\",\"type\":\"address\"},{\"name\":\"_membershipManager\",\"type\":\"address\"},{\"name\":\"_communityCreator\",\"type\":\"address\"}],\"name\":\"deployEventManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRoot\",\"type\":\"address\"}],\"name\":\"removeRootFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRoot\",\"type\":\"address\"}],\"name\":\"addRootFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_rootFactory\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"EventManagerV1Factory","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"000000000000000000000000c5af5f868eff2f7cc49d7be5362c505bd5bec06a","Library":"","SwarmSource":"bzzr://33f9cac264d4a6562c26e9306cead8cdbb5598fa7f3b0b9bfbedccbdfb69e8b0"}]}