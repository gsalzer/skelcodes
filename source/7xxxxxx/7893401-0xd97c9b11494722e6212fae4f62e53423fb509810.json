{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.25 <0.6.0;\r\n\r\n/**\r\n * Minimum recommendation: 10(GWEI) & 121000 Gas \r\n   Minimum send to this contract = 0.2 eth\r\n   Approximately 2.5 mill tokens = 10.000 ETH \"hard goal\"\r\n   Deadline 4/aug/2019  \r\n    check in site iskra-coin.io\r\n */\r\n\r\ninterface token {\r\n    function transfer(address receiver, uint amount) external;\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter);\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract LightCrowdsale1 is ReentrancyGuard {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint;\r\n\r\n    address payable public beneficiary; // wallet to send eth to\r\n    uint public fundingGoal; // maximum amount to raise\r\n    uint public amountRaised; // current amount raised\r\n    uint public minAmountWei; // min amount for crowdsale\r\n    uint public deadline; // time when crowdsale to close\r\n    uint public price; // price for token\r\n    token public tokenReward; // token\r\n    mapping(address => uint256) public balanceOf;\r\n    bool fundingGoalReached = false;\r\n    bool crowdsaleClosed = false;\r\n\r\n    event GoalReached(address recipient, uint totalAmountRaised);\r\n    event FundTransfer(address backer, uint amount, bool isContribution);\r\n\r\n    /**\r\n     * Constructor\r\n     *\r\n     * Setup the owner\r\n     */\r\n    constructor(\r\n        address payable ifSuccessfulSendTo,\r\n        uint fundingGoalInEthers,\r\n        uint durationInMinutes,\r\n        uint finneyCostOfEachToken,\r\n        address addressOfTokenUsedAsReward,\r\n        uint minAmountFinney\r\n    ) public {\r\n        beneficiary = ifSuccessfulSendTo;\r\n        fundingGoal = fundingGoalInEthers * 1 ether;\r\n        deadline = now + durationInMinutes * 1 minutes;\r\n        price = finneyCostOfEachToken * 1 finney;\r\n        minAmountWei = minAmountFinney * 1 finney;\r\n        tokenReward = token(addressOfTokenUsedAsReward);\r\n    }\r\n\r\n    /**\r\n     * Fallback function\r\n     *\r\n     * The function without name is the default function that is called whenever anyone sends funds to a contract\r\n     */\r\n    function() payable external {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    function buyTokens(address sender) public nonReentrant payable {\r\n        checkGoalReached();\r\n        require(!crowdsaleClosed);\r\n        require(sender != address(0));\r\n        uint amount = msg.value;\r\n        require(balanceOf[sender] >= amount);\r\n        require(amount != 0);\r\n        require(amount >= minAmountWei);\r\n\r\n        uint senderBalance = balanceOf[sender];\r\n        balanceOf[sender] = senderBalance.add(amount);\r\n        amountRaised = amountRaised.add(amount);\r\n        uint tokenToSend = amount.div(price) * 1 ether;\r\n        tokenReward.transfer(sender, tokenToSend);\r\n        emit FundTransfer(sender, amount, true);\r\n\r\n        if (beneficiary.send(amount)) {\r\n            emit FundTransfer(beneficiary, amount, false);\r\n        }\r\n\r\n        checkGoalReached();\r\n    }\r\n\r\n    modifier afterDeadline() {if (now >= deadline) _;}\r\n\r\n    /**\r\n     * Check if goal was reached\r\n     *\r\n     * Checks if the goal or time limit has been reached and ends the campaign\r\n     */\r\n    function checkGoalReached() public afterDeadline {\r\n        if (amountRaised >= fundingGoal) {\r\n            fundingGoalReached = true;\r\n            crowdsaleClosed = true;\r\n            emit GoalReached(beneficiary, amountRaised);\r\n        }\r\n        if (now > deadline) {\r\n            crowdsaleClosed = true;\r\n            emit GoalReached(beneficiary, amountRaised);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"checkGoalReached\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minAmountWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenReward\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"ifSuccessfulSendTo\",\"type\":\"address\"},{\"name\":\"fundingGoalInEthers\",\"type\":\"uint256\"},{\"name\":\"durationInMinutes\",\"type\":\"uint256\"},{\"name\":\"finneyCostOfEachToken\",\"type\":\"uint256\"},{\"name\":\"addressOfTokenUsedAsReward\",\"type\":\"address\"},{\"name\":\"minAmountFinney\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalAmountRaised\",\"type\":\"uint256\"}],\"name\":\"GoalReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isContribution\",\"type\":\"bool\"}],\"name\":\"FundTransfer\",\"type\":\"event\"}]","ContractName":"LightCrowdsale1","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000013512480dd2c3718e4314046d3156fc334dda3690000000000000000000000000000000000000000000000000000000000002710000000000000000000000000000000000000000000000000000000000001531a0000000000000000000000000000000000000000000000000000000000000004000000000000000000000000aab80423daa0334aba8f16726677c23619e3877300000000000000000000000000000000000000000000000000000000000000c8","Library":"","SwarmSource":"bzzr://1a602677ce715b6cb02b4a724fa82340b864545e40e0c769dfc78952f0ac3abd"}]}