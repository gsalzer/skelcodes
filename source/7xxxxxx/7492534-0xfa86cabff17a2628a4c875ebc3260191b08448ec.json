{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2 <0.6.0;\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\nlibrary RLP {\r\n\r\n    uint constant DATA_SHORT_START = 0x80;\r\n    uint constant DATA_LONG_START = 0xB8;\r\n    uint constant LIST_SHORT_START = 0xC0;\r\n    uint constant LIST_LONG_START = 0xF8;\r\n\r\n    uint constant DATA_LONG_OFFSET = 0xB7;\r\n    uint constant LIST_LONG_OFFSET = 0xF7;\r\n\r\n\r\n    struct RLPItem {\r\n        uint _unsafe_memPtr;    // Pointer to the RLP-encoded bytes.\r\n        uint _unsafe_length;    // Number of bytes. This is the full length of the string.\r\n    }\r\n\r\n    struct Iterator {\r\n        RLPItem _unsafe_item;   // Item that's being iterated over.\r\n        uint _unsafe_nextPtr;   // Position of the next item in the list.\r\n    }\r\n\r\n    /* Iterator */\r\n\r\n    function next(Iterator memory self) internal pure returns (RLPItem memory subItem) {\r\n        if(hasNext(self)) {\r\n            uint256 ptr = self._unsafe_nextPtr;\r\n            uint256 itemLength = _itemLength(ptr);\r\n            subItem._unsafe_memPtr = ptr;\r\n            subItem._unsafe_length = itemLength;\r\n            self._unsafe_nextPtr = ptr + itemLength;\r\n        }\r\n        else\r\n            revert();\r\n    }\r\n\r\n    function next(Iterator memory self, bool strict) internal pure returns (RLPItem memory subItem) {\r\n        subItem = next(self);\r\n        if(strict && !_validate(subItem))\r\n            revert();\r\n        return subItem;\r\n    }\r\n\r\n    function hasNext(\r\n        Iterator memory self\r\n    ) internal pure returns (bool) {\r\n        RLP.RLPItem memory item = self._unsafe_item;\r\n        return self._unsafe_nextPtr < item._unsafe_memPtr + item._unsafe_length;\r\n    }\r\n\r\n    /* RLPItem */\r\n\r\n    /// @dev Creates an RLPItem from an array of RLP encoded bytes.\r\n    /// @param self The RLP encoded bytes.\r\n    /// @return An RLPItem\r\n    function toRLPItem(bytes memory self) internal pure returns (RLPItem memory) {\r\n        uint len = self.length;\r\n        if (len == 0) {\r\n            return RLPItem(0, 0);\r\n        }\r\n        uint memPtr;\r\n        assembly {\r\n            memPtr := add(self, 0x20)\r\n        }\r\n        return RLPItem(memPtr, len);\r\n    }\r\n\r\n    /// @dev Creates an RLPItem from an array of RLP encoded bytes.\r\n    /// @param self The RLP encoded bytes.\r\n    /// @param strict Will throw if the data is not RLP encoded.\r\n    /// @return An RLPItem\r\n    function toRLPItem(bytes memory self, bool strict) internal pure returns (RLPItem memory) {\r\n        RLP.RLPItem memory item = toRLPItem(self);\r\n        if(strict) {\r\n            uint len = self.length;\r\n            if(_payloadOffset(item) > len)\r\n                revert();\r\n            if(_itemLength(item._unsafe_memPtr) != len)\r\n                revert();\r\n            if(!_validate(item))\r\n                revert();\r\n        }\r\n        return item;\r\n    }\r\n\r\n    /// @dev Check if the RLP item is null.\r\n    /// @param self The RLP item.\r\n    /// @return 'true' if the item is null.\r\n    function isNull(RLPItem memory self) internal pure returns (bool ret) {\r\n        return self._unsafe_length == 0;\r\n    }\r\n\r\n    /// @dev Check if the RLP item is a list.\r\n    /// @param self The RLP item.\r\n    /// @return 'true' if the item is a list.\r\n    function isList(RLPItem memory self) internal pure returns (bool ret) {\r\n        if (self._unsafe_length == 0)\r\n            return false;\r\n        uint memPtr = self._unsafe_memPtr;\r\n        assembly {\r\n            ret := iszero(lt(byte(0, mload(memPtr)), 0xC0))\r\n        }\r\n    }\r\n\r\n    /// @dev Check if the RLP item is data.\r\n    /// @param self The RLP item.\r\n    /// @return 'true' if the item is data.\r\n    function isData(RLPItem memory self) internal pure returns (bool ret) {\r\n        if (self._unsafe_length == 0)\r\n            return false;\r\n        uint memPtr = self._unsafe_memPtr;\r\n        assembly {\r\n            ret := lt(byte(0, mload(memPtr)), 0xC0)\r\n        }\r\n    }\r\n\r\n    /// @dev Check if the RLP item is empty (string or list).\r\n    /// @param self The RLP item.\r\n    /// @return 'true' if the item is null.\r\n    function isEmpty(RLPItem memory self) internal pure returns (bool ret) {\r\n        if(isNull(self))\r\n            return false;\r\n        uint b0;\r\n        uint memPtr = self._unsafe_memPtr;\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n        }\r\n        return (b0 == DATA_SHORT_START || b0 == LIST_SHORT_START);\r\n    }\r\n\r\n    /// @dev Get the number of items in an RLP encoded list.\r\n    /// @param self The RLP item.\r\n    /// @return The number of items.\r\n    function items(RLPItem memory self) internal pure returns (uint) {\r\n        if (!isList(self))\r\n            return 0;\r\n        uint b0;\r\n        uint memPtr = self._unsafe_memPtr;\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n        }\r\n        uint pos = memPtr + _payloadOffset(self);\r\n        uint last = memPtr + self._unsafe_length - 1;\r\n        uint itms;\r\n        while(pos <= last) {\r\n            pos += _itemLength(pos);\r\n            itms++;\r\n        }\r\n        return itms;\r\n    }\r\n\r\n    /// @dev Create an iterator.\r\n    /// @param self The RLP item.\r\n    /// @return An 'Iterator' over the item.\r\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory it) {\r\n        require(isList(self));\r\n        uint ptr = self._unsafe_memPtr + _payloadOffset(self);\r\n        it._unsafe_item = self;\r\n        it._unsafe_nextPtr = ptr;\r\n    }\r\n\r\n    /// @dev Return the RLP encoded bytes.\r\n    /// @param self The RLPItem.\r\n    /// @return The bytes.\r\n    function toBytes(RLPItem memory self) internal pure returns (bytes memory bts) {\r\n        uint256 len = self._unsafe_length;\r\n        if (len == 0)\r\n            return bts;\r\n        bts = new bytes(len);\r\n        _copyToBytes(self._unsafe_memPtr, bts, len);\r\n//\r\n//        uint256 len = self._unsafe_length;\r\n//\r\n//        if (len == 0) {\r\n//            return bts;\r\n//        } else if (len == 1) {\r\n//            bts = new bytes(len);\r\n//            _copyToBytes(self._unsafe_memPtr, bts, len);\r\n//            return bts;\r\n//        }\r\n//\r\n//        bts = new bytes(len-_payloadOffset(self));\r\n//        uint start = self._unsafe_memPtr + _payloadOffset(self);\r\n//        _copyToBytes(start, bts, len-_payloadOffset(self));\r\n    }\r\n\r\n    /// @dev Decode an RLPItem into bytes. This will not work if the\r\n    /// RLPItem is a list.\r\n    /// @param self The RLPItem.\r\n    /// @return The decoded string.\r\n    function toData(RLPItem memory self) internal pure returns (bytes memory bts) {\r\n        require(isData(self));\r\n        (uint256 rStartPos, uint256 len) = _decode(self);\r\n        bts = new bytes(len);\r\n        _copyToBytes(rStartPos, bts, len);\r\n    }\r\n\r\n    /// @dev Get the list of sub-items from an RLP encoded list.\r\n    /// Warning: This is inefficient, as it requires that the list is read twice.\r\n    /// @param self The RLP item.\r\n    /// @return Array of RLPItems.\r\n    function toList(RLPItem memory self) internal pure returns (RLPItem[] memory list) {\r\n        require(isList(self));\r\n        uint256 numItems = items(self);\r\n        list = new RLPItem[](numItems);\r\n        RLP.Iterator memory it = iterator(self);\r\n        uint idx;\r\n        while(hasNext(it)) {\r\n            list[idx] = next(it);\r\n            idx++;\r\n        }\r\n    }\r\n\r\n    /// @dev Decode an RLPItem into an ascii string. This will not work if the\r\n    /// RLPItem is a list.\r\n    /// @param self The RLPItem.\r\n    /// @return The decoded string.\r\n    function toAscii(RLPItem memory self) internal pure returns (string memory str) {\r\n        require(isData(self));\r\n        (uint256 rStartPos, uint256 len) = _decode(self);\r\n        bytes memory bts = new bytes(len);\r\n        _copyToBytes(rStartPos, bts, len);\r\n        str = string(bts);\r\n    }\r\n\r\n    /// @dev Decode an RLPItem into a uint. This will not work if the\r\n    /// RLPItem is a list.\r\n    /// @param self The RLPItem.\r\n    /// @return The decoded string.\r\n    function toUint(RLPItem memory self) internal pure returns (uint data) {\r\n        require(isData(self));\r\n        (uint256 rStartPos, uint256 len) = _decode(self);\r\n        require(len <= 32);\r\n        assembly {\r\n            data := div(mload(rStartPos), exp(256, sub(32, len)))\r\n        }\r\n    }\r\n\r\n    /// @dev Decode an RLPItem into a boolean. This will not work if the\r\n    /// RLPItem is a list.\r\n    /// @param self The RLPItem.\r\n    /// @return The decoded string.\r\n    function toBool(RLPItem memory self) internal pure returns (bool data) {\r\n        require(isData(self));\r\n        (uint256 rStartPos, uint256 len) = _decode(self);\r\n        require(len == 1);\r\n        uint temp;\r\n        assembly {\r\n            temp := byte(0, mload(rStartPos))\r\n        }\r\n        require(temp == 1 || temp == 0);\r\n        return temp == 1 ? true : false;\r\n    }\r\n\r\n    /// @dev Decode an RLPItem into a byte. This will not work if the\r\n    /// RLPItem is a list.\r\n    /// @param self The RLPItem.\r\n    /// @return The decoded string.\r\n    function toByte(RLPItem memory self)\r\n    internal\r\n    pure\r\n    returns (byte data)\r\n    {\r\n        require(isData(self));\r\n\r\n        (uint256 rStartPos, uint256 len) = _decode(self);\r\n\r\n        require(len == 1);\r\n\r\n        byte temp;\r\n        assembly {\r\n            temp := byte(0, mload(rStartPos))\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    /// @dev Decode an RLPItem into an int. This will not work if the\r\n    /// RLPItem is a list.\r\n    /// @param self The RLPItem.\r\n    /// @return The decoded string.\r\n    function toInt(RLPItem memory self)\r\n    internal\r\n    pure\r\n    returns (int data)\r\n    {\r\n        return int(toUint(self));\r\n    }\r\n\r\n    /// @dev Decode an RLPItem into a bytes32. This will not work if the\r\n    /// RLPItem is a list.\r\n    /// @param self The RLPItem.\r\n    /// @return The decoded string.\r\n    function toBytes32(RLPItem memory self)\r\n    internal\r\n    pure\r\n    returns (bytes32 data)\r\n    {\r\n        return bytes32(toUint(self));\r\n    }\r\n\r\n    /// @dev Decode an RLPItem into an address. This will not work if the\r\n    /// RLPItem is a list.\r\n    /// @param self The RLPItem.\r\n    /// @return The decoded string.\r\n    function toAddress(RLPItem memory self)\r\n    internal\r\n    pure\r\n    returns (address data)\r\n    {\r\n        (, uint256 len) = _decode(self);\r\n        require(len <= 20);\r\n        return address(toUint(self));\r\n    }\r\n\r\n    // Get the payload offset.\r\n    function _payloadOffset(RLPItem memory self)\r\n    private\r\n    pure\r\n    returns (uint)\r\n    {\r\n        if(self._unsafe_length == 0)\r\n            return 0;\r\n        uint b0;\r\n        uint memPtr = self._unsafe_memPtr;\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n        }\r\n        if(b0 < DATA_SHORT_START)\r\n            return 0;\r\n        if(b0 < DATA_LONG_START || (b0 >= LIST_SHORT_START && b0 < LIST_LONG_START))\r\n            return 1;\r\n        if(b0 < LIST_SHORT_START)\r\n            return b0 - DATA_LONG_OFFSET + 1;\r\n        return b0 - LIST_LONG_OFFSET + 1;\r\n    }\r\n\r\n    // Get the full length of an RLP item.\r\n    function _itemLength(uint memPtr)\r\n    private\r\n    pure\r\n    returns (uint len)\r\n    {\r\n        uint b0;\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n        }\r\n        if (b0 < DATA_SHORT_START)\r\n            len = 1;\r\n        else if (b0 < DATA_LONG_START)\r\n            len = b0 - DATA_SHORT_START + 1;\r\n        else if (b0 < LIST_SHORT_START) {\r\n            assembly {\r\n                let bLen := sub(b0, 0xB7) // bytes length (DATA_LONG_OFFSET)\r\n                let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\r\n                len := add(1, add(bLen, dLen)) // total length\r\n            }\r\n        } else if (b0 < LIST_LONG_START) {\r\n            len = b0 - LIST_SHORT_START + 1;\r\n        } else {\r\n            assembly {\r\n                let bLen := sub(b0, 0xF7) // bytes length (LIST_LONG_OFFSET)\r\n                let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\r\n                len := add(1, add(bLen, dLen)) // total length\r\n            }\r\n        }\r\n    }\r\n\r\n    // Get start position and length of the data.\r\n    function _decode(RLPItem memory self)\r\n    private\r\n    pure\r\n    returns (uint memPtr, uint len)\r\n    {\r\n        require(isData(self));\r\n        uint b0;\r\n        uint start = self._unsafe_memPtr;\r\n        assembly {\r\n            b0 := byte(0, mload(start))\r\n        }\r\n        if (b0 < DATA_SHORT_START) {\r\n            memPtr = start;\r\n            len = 1;\r\n            return (memPtr, len);\r\n        }\r\n        if (b0 < DATA_LONG_START) {\r\n            len = self._unsafe_length - 1;\r\n            memPtr = start + 1;\r\n        } else {\r\n            uint bLen;\r\n            assembly {\r\n                bLen := sub(b0, 0xB7) // DATA_LONG_OFFSET\r\n            }\r\n            len = self._unsafe_length - 1 - bLen;\r\n            memPtr = start + bLen + 1;\r\n        }\r\n        return (memPtr, len);\r\n    }\r\n\r\n    // Assumes that enough memory has been allocated to store in target.\r\n    function _copyToBytes(\r\n        uint btsPtr,\r\n        bytes memory tgt,\r\n        uint btsLen) private pure\r\n    {\r\n        // Exploiting the fact that 'tgt' was the last thing to be allocated,\r\n        // we can write entire words, and just overwrite any excess.\r\n        assembly {\r\n            {\r\n                let words := div(add(btsLen, 31), 32)\r\n                let rOffset := btsPtr\r\n                let wOffset := add(tgt, 0x20)\r\n\r\n                for { let i := 0 } lt(i, words) { i := add(i, 1) } {\r\n                    let offset := mul(i, 0x20)\r\n                    mstore(add(wOffset, offset), mload(add(rOffset, offset)))\r\n                }\r\n\r\n                mstore(add(tgt, add(0x20, mload(tgt))), 0)\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    // Check that an RLP item is valid.\r\n    function _validate(RLPItem memory self)\r\n    private\r\n    pure\r\n    returns (bool ret)\r\n    {\r\n        // Check that RLP is well-formed.\r\n        uint b0;\r\n        uint b1;\r\n        uint memPtr = self._unsafe_memPtr;\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n            b1 := byte(1, mload(memPtr))\r\n        }\r\n        if(b0 == DATA_SHORT_START + 1 && b1 < DATA_SHORT_START)\r\n            return false;\r\n        return true;\r\n    }\r\n}\r\nlibrary Object {\r\n    using RLP for bytes;\r\n    using RLP for bytes[];\r\n    using RLP for RLP.RLPItem;\r\n    using RLP for RLP.Iterator;\r\n\r\n    struct Data {\r\n        uint sura;\r\n        uint ayat;\r\n        bytes text;\r\n    }\r\n\r\n    function createData(bytes memory dataBytes)\r\n        internal\r\n        pure\r\n        returns (Data memory)\r\n    {\r\n        RLP.RLPItem[] memory dataList = dataBytes.toRLPItem().toList();\r\n        return Data({\r\n            sura: dataList[0].toUint(),\r\n            ayat: dataList[1].toUint(),\r\n            text: dataList[2].toBytes()\r\n        });\r\n    }\r\n}\r\n\r\ncontract Storage is Ownable {\r\n    using Object for bytes;\r\n    using RLP for bytes;\r\n    using RLP for bytes[];\r\n    using RLP for RLP.RLPItem;\r\n    using RLP for RLP.Iterator;\r\n\r\n    struct coord {\r\n        uint sura;\r\n        uint ayat;\r\n    }\r\n\r\n    // @dev Mapping ayat's hash with its text.\r\n    mapping(bytes32 => bytes) public content;\r\n    mapping(uint => mapping(uint => bytes32)) public coordinates;\r\n    mapping(bytes32 => coord[]) public all_coordinates;\r\n\r\n    /** @dev Adds content.\r\n      * @param text Ayat text.\r\n      * @param sura Sura number.\r\n      * @param ayat Ayat number.\r\n      */\r\n    function add_content(\r\n        bytes memory text,\r\n        uint sura,\r\n        uint ayat\r\n    ) public onlyOwner {\r\n        bytes32 hash = keccak256(text);\r\n        if (coordinates[sura][ayat] != 0x0000000000000000000000000000000000000000000000000000000000000000) {\r\n            return;\r\n        }\r\n\r\n        coordinates[sura][ayat] = hash;\r\n        all_coordinates[hash].push(coord({sura:sura, ayat: ayat}));\r\n        content[hash] = text;\r\n    }\r\n\r\n    /** @dev Adds packed data.\r\n      * @param data RLP packed objects.\r\n      */\r\n    function add_data(bytes memory data) public onlyOwner {\r\n        RLP.RLPItem[] memory list = data.toRLPItem().toList();\r\n\r\n        for (uint index = 0; index < list.length; index++) {\r\n            RLP.RLPItem[] memory item = list[index].toList();\r\n\r\n            uint sura = item[0].toUint();\r\n            uint ayat = item[1].toUint();\r\n            bytes memory text = item[2].toData();\r\n\r\n            add_content(text, sura, ayat);\r\n        }\r\n    }\r\n\r\n    /** @dev Gets ayat text by hash.\r\n      * @param ayat_hash Ayat keccak256 hash of compressed text (gzip).\r\n      * @return Ayat compressed text.\r\n      */\r\n    function get_ayat_text_by_hash(\r\n        bytes32 ayat_hash\r\n    ) public view returns (bytes  memory text) {\r\n        text = content[ayat_hash];\r\n    }\r\n\r\n    /** @dev Gets ayat text by coordinates.\r\n      * @param sura Sura number.\r\n      * @param ayat Ayat number.\r\n      * @return Ayat compressed text.\r\n      */\r\n    function get_ayat_text_by_coordinates(\r\n        uint sura,\r\n        uint ayat\r\n    ) public view returns (bytes memory text) {\r\n        bytes32 hash = coordinates[sura][ayat];\r\n        text = content[hash];\r\n    }\r\n\r\n    /** @dev Gets number of ayats by hash.\r\n      * @param hash Ayat keccak256 hash of compressed text (gzip).\r\n      * @return Ayats number.\r\n      */\r\n    function get_ayats_length(\r\n        bytes32 hash\r\n    ) public view returns (uint) {\r\n        return all_coordinates[hash].length;\r\n    }\r\n\r\n    /** @dev Gets an ayat's number and a sura number by a hash and a index in an array.\r\n      * @param hash Ayat keccak256 hash of compressed text (gzip).\r\n      * @param index Ayat index. Ayat text is not unique in the Quran, so this may be several options.\r\n      */\r\n    function get_ayat_coordinates_by_index(\r\n        bytes32 hash,\r\n        uint index\r\n    ) public view returns (uint sura, uint ayat) {\r\n        coord memory data = all_coordinates[hash][index];\r\n        sura = data.sura;\r\n        ayat = data.ayat;\r\n    }\r\n\r\n    /** @dev Verifying the text of an ayat.\r\n      * @param text Ayat compressed text (gzip).\r\n      * @return bool\r\n      */\r\n    function check_ayat_text(\r\n        bytes memory text\r\n    ) public view returns(bool) {\r\n        bytes32 hash = keccak256(text);\r\n        bytes memory ayat_data = content[hash];\r\n        return ayat_data.length != 0;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"add_data\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"content\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ayat_hash\",\"type\":\"bytes32\"}],\"name\":\"get_ayat_text_by_hash\",\"outputs\":[{\"name\":\"text\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"text\",\"type\":\"bytes\"},{\"name\":\"sura\",\"type\":\"uint256\"},{\"name\":\"ayat\",\"type\":\"uint256\"}],\"name\":\"add_content\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"get_ayats_length\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"coordinates\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sura\",\"type\":\"uint256\"},{\"name\":\"ayat\",\"type\":\"uint256\"}],\"name\":\"get_ayat_text_by_coordinates\",\"outputs\":[{\"name\":\"text\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"text\",\"type\":\"bytes\"}],\"name\":\"check_ayat_text\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"get_ayat_coordinates_by_index\",\"outputs\":[{\"name\":\"sura\",\"type\":\"uint256\"},{\"name\":\"ayat\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"all_coordinates\",\"outputs\":[{\"name\":\"sura\",\"type\":\"uint256\"},{\"name\":\"ayat\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Storage","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2df067a9e517cc0e4144ae9d23ec5068724cfe7bb910a0e085195499fd1513b2"}]}