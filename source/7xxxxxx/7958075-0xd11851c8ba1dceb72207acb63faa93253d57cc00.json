{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n//import \"./SafeMath.sol\";\r\n/* solhint-disable var-name-mixedcase */\r\n/* solhint-disable const-name-snakecase */\r\n/* solhint-disable code-complexity */\r\n/* solhint-disable max-line-length */\r\n/* solhint-disable func-name-mixedcase */\r\n/* solhint-disable use-forbidden-name */\r\n\r\n\r\n/*\r\n\r\n.----------------.  .----------------.  .----------------.  .----------------.  .----------------.\r\n| .--------------. || .--------------. || .--------------. || .--------------. || .--------------. |\r\n| |    ______    | || |  ________    | || | _____  _____ | || |  _________   | || |   _____      | |\r\n| |   / ____ `.  | || | |_   ___ `.  | || ||_   _||_   _|| || | |_   ___  |  | || |  |_   _|     | |\r\n| |   `'  __) |  | || |   | |   `. \\ | || |  | |    | |  | || |   | |_  \\_|  | || |    | |       | |\r\n| |   _  |__ '.  | || |   | |    | | | || |  | '    ' |  | || |   |  _|  _   | || |    | |   _   | |\r\n| |  | \\____) |  | || |  _| |___.' / | || |   \\ `--' /   | || |  _| |___/ |  | || |   _| |__/ |  | |\r\n| |   \\______.'  | || | |________.'  | || |    `.__.'    | || | |_________|  | || |  |________|  | |\r\n| |              | || |              | || |              | || |              | || |              | |\r\n| '--------------' || '--------------' || '--------------' || '--------------' || '--------------' |\r\n'----------------'  '----------------'  '----------------'  '----------------'  '----------------'\r\n\r\n [x] Probably Fair\r\n [x] Open Source\r\n [x] Better than dice & ICO scams\r\n [x] made with <3.add(hate)\r\n\r\n Play it!\r\n\r\n Or don't?\r\n\r\n Nobody cares.\r\n\r\n*/\r\n\r\n\r\n/* solhint-disable all */\r\n\r\ncontract Truel {\r\n    using SafeMath for uint;\r\n\r\n    address private PLEDGE_ADDRESS;\r\n    address private P3X_ADDRESS;\r\n    IP3X private p3xContract;\r\n    IPledge private pledgeContract;\r\n    MegaballInterface public megaballContract;\r\n\r\n    event Jackpot(uint indexed roundNumber, address indexed player, uint indexed amount);\r\n    event OnWithdraw(address indexed customerAddress, uint256 ethereumWithdrawn, uint256 p3xWithdrawn);\r\n    event WaitlistEntered(address player);\r\n    event RoundEntered(uint indexed roundNumber, address indexed player);\r\n    event PlayerShot(uint indexed roundNumber, address indexed shooter, address indexed dead);\r\n\r\n    mapping(uint256 => Round) rounds;\r\n\r\n    mapping(uint256 => Entrant) waitingList;\r\n    uint256 public waitingListCount = 0;\r\n    uint256 public waitingListMoveCount = 0;\r\n\r\n    mapping(uint256 => uint256) public queue;\r\n    uint256 public nextValid = 0;\r\n    uint256 public nextToValidate = 0;\r\n\r\n    uint256 public validatorBagMin = 0;\r\n\r\n    address public owner;\r\n\r\n    struct Entrant {\r\n        address player;\r\n        uint8 choice;\r\n        bool dead;\r\n        uint256 mintRemainder;\r\n    }\r\n\r\n    struct Round {\r\n        bool isExist;\r\n        uint8 entrantCount;\r\n        Entrant entrantOne;\r\n        Entrant entrantTwo;\r\n        Entrant entrantThree;\r\n        bool complete;\r\n        uint8 result;\r\n        uint8 n2;\r\n        uint8 n3;\r\n        uint8 n4;\r\n        Entrant roundCreator;\r\n    }\r\n\r\n    mapping (address => uint256) private p3xVault;\r\n    mapping (address => uint256) private ethVault;\r\n\r\n    uint256 public UNALLOCATEDP3X = 0;\r\n\r\n    uint256 public DIVIDENDS_JACKPOT = 0;\r\n    uint256 public BACKFIRE_JACKPOT = 0;\r\n    uint256 public MINI_JACKPOT = 0;\r\n\r\n    uint256 public DENOMINATION = 100000000000000000;\r\n    uint256 public nextWithdrawTime = 0;\r\n    uint256 constant private denominationFloor = 100000000000000;\r\n    uint256 constant private denominationCeiling = 10000000000000000000;\r\n    uint256 public denominationActiveTimestamp;\r\n    uint256 private denominationUpdateTimeOffset = 2629743; //1 month, //6 months 15778463\r\n\r\n    //CHOICE COUNTS\r\n    uint256 public LEFT = 0;\r\n    uint256 public MISS = 0;\r\n    uint256 public RIGHT = 0;\r\n    uint256 public BACKFIRE = 0;\r\n\r\n    constructor(address pa, address hx, address mb) public\r\n    {\r\n        nextWithdrawTime = now;\r\n        owner = msg.sender;\r\n        validatorBagMin = 10e18;\r\n        denominationActiveTimestamp = SafeMath.add(now, denominationUpdateTimeOffset);\r\n\r\n        PLEDGE_ADDRESS = address(pa);\r\n        P3X_ADDRESS = address(hx);\r\n        p3xContract = IP3X(P3X_ADDRESS);\r\n        pledgeContract = IPledge(PLEDGE_ADDRESS);\r\n        megaballContract = MegaballInterface(address(mb));\r\n\r\n    }\r\n\r\n    /*\r\n    *  balance functions\r\n    *  players main game balance\r\n    */\r\n    function getBalance() public view returns (uint) {\r\n        return p3xVault[msg.sender];\r\n    }\r\n\r\n\r\n  /* modifiers */\r\n    modifier hasBalance() {\r\n        require(p3xVault[msg.sender] > 0);\r\n       _;\r\n    }\r\n\r\n    modifier hasBagBalance() {\r\n        require(p3xVault[msg.sender] > validatorBagMin);\r\n       _;\r\n    }\r\n\r\n    function updateDenomination()\r\n      external\r\n    {\r\n        require(denominationActiveTimestamp < now);\r\n\r\n        denominationActiveTimestamp = SafeMath.add(now, denominationUpdateTimeOffset);\r\n        uint256 USD_DENOM = megaballContract.DENOMINATION();\r\n\r\n        if (USD_DENOM > denominationFloor && USD_DENOM < denominationCeiling) {\r\n            DENOMINATION = USD_DENOM;\r\n        }\r\n    }\r\n\r\n    function setValidatorBagMin() public {\r\n        require(msg.sender == owner);\r\n        if (waitingListCount > 1000) {\r\n            validatorBagMin = 20e18;\r\n        }\r\n\r\n        if (waitingListCount > 10000) {\r\n            validatorBagMin = 100e18;\r\n        }\r\n\r\n        if (waitingListCount > 20000) {\r\n            validatorBagMin = 200e18;\r\n        }\r\n    }\r\n\r\n    function isValidator() public view returns (bool) {\r\n        if (p3xVault[msg.sender] > validatorBagMin) { return true;}\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    function getEthBalance() public view returns (uint) {\r\n        return ethVault[msg.sender];\r\n    }\r\n\r\n  /* modifiers */\r\n    modifier hasEthBalance() {\r\n        require(ethVault[msg.sender] > 0);\r\n       _;\r\n    }\r\n\r\n    function myP3XBalance()\r\n        external\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return p3xContract.balanceOf(msg.sender);\r\n    }\r\n\r\n    function contractEthBalance()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return (address(this).balance);\r\n    }\r\n\r\n    function contractP3XBalance()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return p3xContract.balanceOf(address(this));\r\n    }\r\n\r\n    function contractP3XDividends()\r\n        external\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return p3xContract.dividendsOf(address(this), true);\r\n    }\r\n\r\n    function pledgeDividends()\r\n        external\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return p3xContract.dividendsOf(address(PLEDGE_ADDRESS), true);\r\n    }\r\n\r\n    function withdraw()\r\n        external\r\n    {\r\n        uint256 amountP3x = p3xVault[msg.sender];\r\n        if (amountP3x > 0) {\r\n            p3xVault[msg.sender] = 0;\r\n            p3xContract.transfer(msg.sender, amountP3x);\r\n        }\r\n\r\n        uint256 amountEth = ethVault[msg.sender];\r\n        if (amountEth > 0) {\r\n            ethVault[msg.sender] = 0;\r\n            msg.sender.transfer(amountEth);\r\n        }\r\n        emit OnWithdraw(msg.sender, amountEth, amountP3x);\r\n\r\n    }\r\n\r\n\r\n    function withdrawEarnings()\r\n        external\r\n    {\r\n        uint256 amount = p3xVault[msg.sender];\r\n\r\n        require(amount > 0);\r\n\r\n        p3xVault[msg.sender] = 0;\r\n\r\n        p3xContract.transfer(msg.sender, amount);\r\n    }\r\n\r\n    function withdrawEth()\r\n        external\r\n    {\r\n        uint256 amount = ethVault[msg.sender];\r\n\r\n        require(amount > 0);\r\n\r\n        ethVault[msg.sender] = 0;\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    //TODO FALLBACK\r\n\r\n    function() external payable {}\r\n\r\n    function tokenFallback(address player, uint256 amount, bytes calldata data)\r\n    external\r\n    {\r\n        require(msg.sender == P3X_ADDRESS);\r\n\r\n    }\r\n\r\n    function fetchDividendsFromP3X()\r\n    public\r\n    {\r\n        if (nextWithdrawTime < now) {\r\n            nextWithdrawTime = now.add(600);\r\n            uint256 dividends = p3xContract.dividendsOf(address(this), true);\r\n            if (dividends > 0) {\r\n                p3xContract.withdraw();\r\n                MINI_JACKPOT = MINI_JACKPOT.add(dividends);\r\n                DIVIDENDS_JACKPOT = DIVIDENDS_JACKPOT.add(pledgeContract.withdraw());\r\n            }\r\n        }\r\n    }\r\n\r\n    function choiceTally(uint8 _choice) internal {\r\n        if (_choice == 0) {\r\n            LEFT = LEFT.add(1);\r\n        }\r\n        if (_choice == 1) {\r\n            MISS = MISS.add(1);\r\n        }\r\n        if (_choice == 2) {\r\n            RIGHT = RIGHT.add(1);\r\n        }\r\n    }\r\n\r\n    function enterTruel(uint8 _choice)\r\n    external\r\n    payable\r\n    {\r\n        require(msg.value == DENOMINATION);\r\n        choiceTally(_choice);\r\n\r\n        /* buy keys, pledge contract as referral */\r\n        uint256 total = p3xContract.buy.value(msg.value)(PLEDGE_ADDRESS);\r\n\r\n        uint256 value = total.div(2);\r\n\r\n        UNALLOCATEDP3X = UNALLOCATEDP3X.add(value);\r\n        p3xVault[msg.sender] = p3xVault[msg.sender].add(value);\r\n\r\n\r\n        Entrant memory entrants = Entrant(msg.sender, _choice, false, value);\r\n        waitingList[waitingListCount] = entrants;\r\n        waitingListCount = waitingListCount.add(1);\r\n        emit WaitlistEntered(msg.sender);\r\n    }\r\n\r\n    function findFirstAvailableBlock()\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        /*\r\n          we go 4 blocks into the future,\r\n          1 for potential random seed\r\n          1 for each player (backfirecheck & aggregate for jackpot)\r\n        */\r\n        for (uint8 i=4; i < 100; i++)\r\n        {\r\n            if (!rounds[block.number + i].isExist) {\r\n                return block.number + i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n      moves players from waitlist to a truel round\r\n    */\r\n\r\n    function enterFromWaitlist()\r\n    public\r\n    hasBagBalance\r\n    {\r\n        require((waitingListCount - waitingListMoveCount) > 5);\r\n        uint256 blockz = findFirstAvailableBlock();\r\n        require(!rounds[blockz].isExist);\r\n        require(p3xVault[msg.sender] > waitingList[waitingListMoveCount].mintRemainder.mul(2));\r\n\r\n        if (!rounds[blockz].isExist) {\r\n            fetchDividendsFromP3X();\r\n            uint256 zz = waitingListMoveCount.add(1);\r\n            uint256 yy = waitingListMoveCount.add(2);\r\n\r\n            uint256 withheldValue = waitingList[waitingListMoveCount].mintRemainder.mul(2);\r\n            p3xVault[msg.sender] = p3xVault[msg.sender].sub(withheldValue);\r\n            Entrant memory roundCreator = Entrant(msg.sender, 0, false, withheldValue);\r\n\r\n            rounds[blockz] = Round(true, 3, waitingList[waitingListMoveCount], waitingList[zz], waitingList[yy], false, 0, 0, 0, 0, roundCreator);\r\n\r\n            emit RoundEntered(blockz, waitingList[waitingListMoveCount].player);\r\n            emit RoundEntered(blockz, waitingList[zz].player);\r\n            emit RoundEntered(blockz, waitingList[yy].player);\r\n            waitingListMoveCount = waitingListMoveCount.add(3);\r\n            //ease of use\r\n            queue[nextValid] = blockz;\r\n            nextValid = nextValid.add(1);\r\n        }\r\n    }\r\n\r\n    function getQueueItem(uint256 item)\r\n    external\r\n    view\r\n    returns (uint)\r\n    {\r\n        uint256 lblock = queue[item];\r\n        return lblock;\r\n    }\r\n\r\n    function getBlockFromQueue(uint256 _offset)\r\n    public\r\n    view\r\n    returns (address, bool, address, bool, address, bool, bool, uint)\r\n    {\r\n        uint256 queuePosition = nextToValidate.sub(_offset);\r\n        uint256 _block = queue[queuePosition];\r\n        return (\r\n            rounds[_block].entrantOne.player,\r\n            rounds[_block].entrantOne.dead,\r\n            rounds[_block].entrantTwo.player,\r\n            rounds[_block].entrantTwo.dead,\r\n            rounds[_block].entrantThree.player,\r\n            rounds[_block].entrantThree.dead,\r\n            rounds[_block].complete,\r\n            _block);\r\n    }\r\n\r\n\r\n    function whichBlock()\r\n    external\r\n    view\r\n    returns (uint)\r\n    {\r\n        uint256 lblock = queue[nextToValidate];\r\n        return lblock;\r\n    }\r\n\r\n    function validator()\r\n    external\r\n    hasBagBalance\r\n    {\r\n        uint256 lblock = queue[nextToValidate];\r\n        validate(lblock);\r\n        nextToValidate = nextToValidate.add(1);\r\n    }\r\n\r\n    function canCreateRound()\r\n    external\r\n    view\r\n    returns (bool)\r\n    {\r\n        bool status = true;\r\n\r\n        if ((waitingListCount - waitingListMoveCount) < 6) {status = false;}\r\n        if (p3xVault[msg.sender] < waitingList[waitingListMoveCount].mintRemainder.mul(2)) {status = false;}\r\n\r\n        return status;\r\n    }\r\n\r\n\r\n    function isValidatorAvailable()\r\n    external\r\n    view\r\n    returns (bool)\r\n    {\r\n\r\n        uint256 qblock = queue[nextToValidate];\r\n        uint256 bx = block.number;\r\n        uint256 bxp = bx.add(10);\r\n\r\n        if (nextToValidate == nextValid) {\r\n            return false;\r\n        }\r\n\r\n        if (rounds[qblock].roundCreator.player == msg.sender) {\r\n            if (bx > qblock) { return true;}\r\n        }\r\n\r\n        if (rounds[qblock].roundCreator.player != msg.sender) {\r\n            if (bxp > qblock) { return true;}\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function firstShotToRoundCreator(uint256 _block, address _blockOwner)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        uint256 bx = block.number - _block;\r\n\r\n        if (rounds[_block].roundCreator.player == _blockOwner) {\r\n            if (bx > 0) { return true;}\r\n        }\r\n\r\n        if (rounds[_block].roundCreator.player != _blockOwner) {\r\n            if (bx > 10) { return true;}\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    function validate(uint256 _block)\r\n    internal\r\n    {\r\n        require(rounds[_block].complete == false);\r\n        require(_block < block.number);\r\n        require(rounds[_block].isExist);\r\n        require(firstShotToRoundCreator(_block, msg.sender));\r\n\r\n        rounds[_block].complete = true;\r\n        uint8 n1 = 0;\r\n        uint8 n2 = 0;\r\n        uint8 n3 = 0;\r\n        uint8 n4 = 0;\r\n\r\n        uint8 s1 = 0;\r\n        //uint256 bz = block.number;\r\n        uint256 bx = block.number.sub(_block);\r\n        if (bx >= 232) {\r\n            rounds[_block].result = 0;\r\n        }\r\n\r\n        if (bx < 232) {\r\n            //!urfux\r\n            n1 = SafeMath.add3(1, (uint256(keccak256(abi.encodePacked(_block.sub(3)))) % 3));\r\n            n2 = SafeMath.add3(1, (uint256(keccak256(abi.encodePacked(_block.sub(2)))) % 100));\r\n            n3 = SafeMath.add3(1, (uint256(keccak256(abi.encodePacked(_block.sub(1)))) % 100));\r\n            n4 = SafeMath.add3(1, (uint256(keccak256(abi.encodePacked(_block))) % 100));\r\n\r\n            s1 = n2 + n3 + n4;\r\n            rounds[_block].result = n1;\r\n            rounds[_block].n2 = n2;\r\n            rounds[_block].n3 = n3;\r\n            rounds[_block].n4 = n4;\r\n        }\r\n\r\n\r\n\r\n        /*\r\n          urfux\r\n          NOT RESOLVED INTIME PUNISHMENT\r\n          PLAYERS DONT GET P3X BACK FOR THIS\r\n          LOCKED INTO CONTRACT\r\n        */\r\n        if (rounds[_block].result == 0) {\r\n            rounds[_block].entrantOne.dead = true;\r\n            rounds[_block].entrantTwo.dead = true;\r\n            rounds[_block].entrantThree.dead = true;\r\n        }\r\n\r\n        /* CHOICE 0 = left CHOICE 1 = miss CHOICE 2 = right */\r\n        if (rounds[_block].result > 0) {\r\n\r\n          //credit rnd creator\r\n            address p4 = rounds[_block].roundCreator.player;\r\n            p3xVault[p4] = p3xVault[p4].add(rounds[_block].roundCreator.mintRemainder);\r\n\r\n            /* did p1 backfire ? */\r\n            if (rounds[_block].entrantOne.choice != 1 && n2 < 10) {\r\n                rounds[_block].entrantOne.dead = true;\r\n                BACKFIRE_JACKPOT = BACKFIRE_JACKPOT.add(rounds[_block].entrantOne.mintRemainder);\r\n                rounds[_block].entrantOne.mintRemainder = 0;\r\n                BACKFIRE = BACKFIRE.add(1);\r\n                emit PlayerShot(_block, rounds[_block].entrantOne.player, rounds[_block].entrantOne.player);\r\n            }\r\n            /* did p2 backfire ? */\r\n            if (rounds[_block].entrantTwo.choice != 1 && n3 < 10) {\r\n                rounds[_block].entrantTwo.dead = true;\r\n                BACKFIRE_JACKPOT = BACKFIRE_JACKPOT.add(rounds[_block].entrantTwo.mintRemainder);\r\n                rounds[_block].entrantTwo.mintRemainder = 0;\r\n                BACKFIRE = BACKFIRE.add(1);\r\n                emit PlayerShot(_block, rounds[_block].entrantTwo.player, rounds[_block].entrantTwo.player);\r\n            }\r\n            /* did p3 backfire ? */\r\n            if (rounds[_block].entrantThree.choice != 1 && n4 < 10) {\r\n                rounds[_block].entrantThree.dead = true;\r\n                BACKFIRE_JACKPOT = BACKFIRE_JACKPOT.add(rounds[_block].entrantThree.mintRemainder);\r\n                rounds[_block].entrantThree.mintRemainder = 0;\r\n                BACKFIRE = BACKFIRE.add(1);\r\n                emit PlayerShot(_block, rounds[_block].entrantThree.player, rounds[_block].entrantThree.player);\r\n            }\r\n\r\n          //DEFAULT ORDER 1 2 3\r\n            if (rounds[_block].result == 1) {\r\n                if (rounds[_block].entrantOne.choice == 0 && rounds[_block].entrantOne.dead == false) {\r\n                    rounds[_block].entrantThree.dead = true;\r\n                    rounds[_block].entrantOne.mintRemainder = rounds[_block].entrantOne.mintRemainder.add(rounds[_block].entrantThree.mintRemainder);\r\n                    rounds[_block].entrantThree.mintRemainder = 0;\r\n                    emit PlayerShot(_block, rounds[_block].entrantOne.player, rounds[_block].entrantThree.player);\r\n                }\r\n                if (rounds[_block].entrantOne.choice == 2 && rounds[_block].entrantOne.dead == false) {\r\n                    rounds[_block].entrantTwo.dead = true;\r\n                    rounds[_block].entrantOne.mintRemainder = rounds[_block].entrantOne.mintRemainder.add(rounds[_block].entrantTwo.mintRemainder);\r\n                    rounds[_block].entrantTwo.mintRemainder = 0;\r\n                    emit PlayerShot(_block, rounds[_block].entrantOne.player, rounds[_block].entrantTwo.player);\r\n                }\r\n\r\n                if (rounds[_block].entrantTwo.choice == 0 && rounds[_block].entrantTwo.dead == false) {\r\n                    rounds[_block].entrantOne.dead = true;\r\n                    rounds[_block].entrantTwo.mintRemainder = rounds[_block].entrantTwo.mintRemainder.add(rounds[_block].entrantOne.mintRemainder);\r\n                    rounds[_block].entrantOne.mintRemainder = 0;\r\n                    emit PlayerShot(_block, rounds[_block].entrantTwo.player, rounds[_block].entrantOne.player);\r\n                }\r\n                if (rounds[_block].entrantTwo.choice == 2 && rounds[_block].entrantTwo.dead == false) {\r\n                    rounds[_block].entrantThree.dead = true;\r\n                    rounds[_block].entrantTwo.mintRemainder = rounds[_block].entrantTwo.mintRemainder.add(rounds[_block].entrantThree.mintRemainder);\r\n                    rounds[_block].entrantThree.mintRemainder = 0;\r\n                    emit PlayerShot(_block, rounds[_block].entrantTwo.player, rounds[_block].entrantThree.player);\r\n                }\r\n\r\n                if (rounds[_block].entrantThree.choice == 0 && rounds[_block].entrantThree.dead == false) {\r\n                    rounds[_block].entrantTwo.dead = true;\r\n                    rounds[_block].entrantThree.mintRemainder = rounds[_block].entrantThree.mintRemainder.add(rounds[_block].entrantTwo.mintRemainder);\r\n                    rounds[_block].entrantTwo.mintRemainder = 0;\r\n                    emit PlayerShot(_block, rounds[_block].entrantThree.player, rounds[_block].entrantTwo.player);\r\n                }\r\n                if (rounds[_block].entrantThree.choice == 2 && rounds[_block].entrantThree.dead == false) {\r\n                    rounds[_block].entrantOne.dead = true;\r\n                    rounds[_block].entrantThree.mintRemainder = rounds[_block].entrantThree.mintRemainder.add(rounds[_block].entrantOne.mintRemainder);\r\n                    rounds[_block].entrantOne.mintRemainder = 0;\r\n                    emit PlayerShot(_block, rounds[_block].entrantThree.player, rounds[_block].entrantOne.player);\r\n                }\r\n            }\r\n            //SECOND ORDER 3 1 2\r\n            if (rounds[_block].result == 2) {\r\n                if (rounds[_block].entrantThree.choice == 0 && rounds[_block].entrantThree.dead == false) {\r\n                    rounds[_block].entrantTwo.dead = true;\r\n                    rounds[_block].entrantThree.mintRemainder = rounds[_block].entrantThree.mintRemainder.add(rounds[_block].entrantTwo.mintRemainder);\r\n                    rounds[_block].entrantTwo.mintRemainder = 0;\r\n                    emit PlayerShot(_block, rounds[_block].entrantThree.player, rounds[_block].entrantTwo.player);\r\n                }\r\n                if (rounds[_block].entrantThree.choice == 2 && rounds[_block].entrantThree.dead == false) {\r\n                    rounds[_block].entrantOne.dead = true;\r\n                    rounds[_block].entrantThree.mintRemainder = rounds[_block].entrantThree.mintRemainder.add(rounds[_block].entrantOne.mintRemainder);\r\n                    rounds[_block].entrantOne.mintRemainder = 0;\r\n                    emit PlayerShot(_block, rounds[_block].entrantThree.player, rounds[_block].entrantOne.player);\r\n                }\r\n\r\n                if (rounds[_block].entrantOne.choice == 0 && rounds[_block].entrantOne.dead == false) {\r\n                    rounds[_block].entrantThree.dead = true;\r\n                    rounds[_block].entrantOne.mintRemainder = rounds[_block].entrantOne.mintRemainder.add(rounds[_block].entrantThree.mintRemainder);\r\n                    rounds[_block].entrantThree.mintRemainder = 0;\r\n                    emit PlayerShot(_block, rounds[_block].entrantOne.player, rounds[_block].entrantThree.player);\r\n                }\r\n                if (rounds[_block].entrantOne.choice == 2 && rounds[_block].entrantOne.dead == false) {\r\n                    rounds[_block].entrantTwo.dead = true;\r\n                    rounds[_block].entrantOne.mintRemainder = rounds[_block].entrantOne.mintRemainder.add(rounds[_block].entrantTwo.mintRemainder);\r\n                    rounds[_block].entrantTwo.mintRemainder = 0;\r\n                    emit PlayerShot(_block, rounds[_block].entrantOne.player, rounds[_block].entrantTwo.player);\r\n                }\r\n\r\n                if (rounds[_block].entrantTwo.choice == 0 && rounds[_block].entrantTwo.dead == false) {\r\n                    rounds[_block].entrantOne.dead = true;\r\n                    rounds[_block].entrantTwo.mintRemainder = rounds[_block].entrantTwo.mintRemainder.add(rounds[_block].entrantOne.mintRemainder);\r\n                    rounds[_block].entrantOne.mintRemainder = 0;\r\n                    emit PlayerShot(_block, rounds[_block].entrantTwo.player, rounds[_block].entrantOne.player);\r\n                }\r\n                if (rounds[_block].entrantTwo.choice == 2 && rounds[_block].entrantTwo.dead == false) {\r\n                    rounds[_block].entrantThree.dead = true;\r\n                    rounds[_block].entrantTwo.mintRemainder = rounds[_block].entrantTwo.mintRemainder.add(rounds[_block].entrantThree.mintRemainder);\r\n                    rounds[_block].entrantThree.mintRemainder = 0;\r\n                    emit PlayerShot(_block, rounds[_block].entrantTwo.player, rounds[_block].entrantThree.player);\r\n                }\r\n            }\r\n\r\n            //THIRD ORDER 2 3 1\r\n            if (rounds[_block].result == 3) {\r\n                if (rounds[_block].entrantTwo.choice == 0 && rounds[_block].entrantTwo.dead == false) {\r\n                    rounds[_block].entrantOne.dead = true;\r\n                    rounds[_block].entrantTwo.mintRemainder = rounds[_block].entrantTwo.mintRemainder.add(rounds[_block].entrantOne.mintRemainder);\r\n                    rounds[_block].entrantOne.mintRemainder = 0;\r\n                    emit PlayerShot(_block, rounds[_block].entrantTwo.player, rounds[_block].entrantOne.player);\r\n                }\r\n                if (rounds[_block].entrantTwo.choice == 2 && rounds[_block].entrantTwo.dead == false) {\r\n                    rounds[_block].entrantThree.dead = true;\r\n                    rounds[_block].entrantTwo.mintRemainder = rounds[_block].entrantTwo.mintRemainder.add(rounds[_block].entrantThree.mintRemainder);\r\n                    rounds[_block].entrantThree.mintRemainder = 0;\r\n                    emit PlayerShot(_block, rounds[_block].entrantTwo.player, rounds[_block].entrantThree.player);\r\n                }\r\n\r\n                if (rounds[_block].entrantThree.choice == 0 && rounds[_block].entrantThree.dead == false) {\r\n                    rounds[_block].entrantTwo.dead = true;\r\n                    rounds[_block].entrantThree.mintRemainder = rounds[_block].entrantThree.mintRemainder.add(rounds[_block].entrantTwo.mintRemainder);\r\n                    rounds[_block].entrantTwo.mintRemainder = 0;\r\n                    emit PlayerShot(_block, rounds[_block].entrantThree.player, rounds[_block].entrantTwo.player);\r\n                }\r\n                if (rounds[_block].entrantThree.choice == 2 && rounds[_block].entrantThree.dead == false) {\r\n                    rounds[_block].entrantOne.dead = true;\r\n                    rounds[_block].entrantThree.mintRemainder = rounds[_block].entrantThree.mintRemainder.add(rounds[_block].entrantOne.mintRemainder);\r\n                    rounds[_block].entrantOne.mintRemainder = 0;\r\n                    emit PlayerShot(_block, rounds[_block].entrantThree.player, rounds[_block].entrantOne.player);\r\n                }\r\n\r\n                if (rounds[_block].entrantOne.choice == 0 && rounds[_block].entrantOne.dead == false) {\r\n                    rounds[_block].entrantThree.dead = true;\r\n                    rounds[_block].entrantOne.mintRemainder = rounds[_block].entrantOne.mintRemainder.add(rounds[_block].entrantThree.mintRemainder);\r\n                    rounds[_block].entrantThree.mintRemainder = 0;\r\n                    emit PlayerShot(_block, rounds[_block].entrantOne.player, rounds[_block].entrantThree.player);\r\n                }\r\n                if (rounds[_block].entrantOne.choice == 2 && rounds[_block].entrantOne.dead == false) {\r\n                    rounds[_block].entrantTwo.dead = true;\r\n                    rounds[_block].entrantOne.mintRemainder = rounds[_block].entrantOne.mintRemainder.add(rounds[_block].entrantTwo.mintRemainder);\r\n                    rounds[_block].entrantTwo.mintRemainder = 0;\r\n                    emit PlayerShot(_block, rounds[_block].entrantOne.player, rounds[_block].entrantTwo.player);\r\n                }\r\n            }\r\n\r\n            if (rounds[_block].entrantOne.mintRemainder > 0) {\r\n                payWinner(rounds[_block].entrantOne.player, rounds[_block].entrantOne.mintRemainder);\r\n            }\r\n\r\n            if (rounds[_block].entrantTwo.mintRemainder > 0) {\r\n                payWinner(rounds[_block].entrantTwo.player, rounds[_block].entrantTwo.mintRemainder);\r\n            }\r\n\r\n            if (rounds[_block].entrantThree.mintRemainder > 0) {\r\n                payWinner(rounds[_block].entrantThree.player, rounds[_block].entrantThree.mintRemainder);\r\n            }\r\n\r\n            /* this how you win big */\r\n            doMicroJP(s1);\r\n            doJackpot(s1, _block);\r\n            doMiniJackpot(s1, msg.sender);\r\n        }\r\n\r\n    }\r\n\r\n    function doMicroJP(uint8 s1) internal {\r\n        if (s1 > 265) {\r\n            uint256 share = MINI_JACKPOT;\r\n            if (share > 0) {\r\n                MINI_JACKPOT = 0;\r\n                address p4 = waitingList[waitingListMoveCount - 1].player;\r\n                ethVault[p4] = ethVault[p4].add(share);\r\n                emit Jackpot(block.number, p4, share);\r\n            }\r\n        }\r\n    }\r\n\r\n    function doMiniJackpot(uint8 s1, address validatorAddress) internal {\r\n        if (s1 > 265) {\r\n            uint256 bshare = BACKFIRE_JACKPOT;\r\n            if (bshare > 0) {\r\n                BACKFIRE_JACKPOT = 0;\r\n                p3xVault[validatorAddress] = p3xVault[validatorAddress].add(bshare);\r\n                emit Jackpot(block.number, validatorAddress, bshare);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function doJackpot(uint8 s1, uint256 _block) internal {\r\n        if (s1 == 297) {\r\n\r\n            if (!rounds[_block].entrantOne.dead\r\n                && !rounds[_block].entrantTwo.dead\r\n                && !rounds[_block].entrantThree.dead) {\r\n\r\n                uint256 share = DIVIDENDS_JACKPOT.div(4);\r\n                DIVIDENDS_JACKPOT = 0;\r\n\r\n                address p1 = rounds[_block].entrantOne.player;\r\n                address p2 = rounds[_block].entrantTwo.player;\r\n                address p3 = rounds[_block].entrantThree.player;\r\n                address p4 = waitingList[waitingListMoveCount - 1].player;\r\n\r\n                ethVault[p1] = ethVault[p1].add(share);\r\n                ethVault[p2] = ethVault[p2].add(share);\r\n                ethVault[p3] = ethVault[p3].add(share);\r\n\r\n                ethVault[p4] = ethVault[p4].add(share);\r\n\r\n                emit Jackpot(_block, p4, share);\r\n                emit Jackpot(_block, p1, share);\r\n                emit Jackpot(_block, p2, share);\r\n                emit Jackpot(_block, p3, share);\r\n            }\r\n        }\r\n    }\r\n\r\n    function payWinner(address player, uint256 amount) internal {\r\n        UNALLOCATEDP3X = UNALLOCATEDP3X.sub(amount);\r\n        if (UNALLOCATEDP3X > amount) {\r\n            p3xVault[player] = p3xVault[player].add(amount);\r\n        }\r\n    }\r\n\r\n    function roundDeathInfo(uint256 _block)\r\n    public\r\n    view\r\n    returns (address, bool, address, bool, address, bool, bool)\r\n    {\r\n        return (\r\n        rounds[_block].entrantOne.player,\r\n        rounds[_block].entrantOne.dead,\r\n        rounds[_block].entrantTwo.player,\r\n        rounds[_block].entrantTwo.dead,\r\n        rounds[_block].entrantThree.player,\r\n        rounds[_block].entrantThree.dead,\r\n        rounds[_block].complete);\r\n    }\r\n\r\n    function deaths(uint256 _block)\r\n    public\r\n    view\r\n    returns (bool, bool, bool)\r\n    {\r\n        return (\r\n        rounds[_block].entrantOne.dead,\r\n        rounds[_block].entrantTwo.dead,\r\n        rounds[_block].entrantThree.dead);\r\n    }\r\n\r\n    function mintRemainder(uint256 _block)\r\n    public\r\n    view\r\n    returns (uint, uint, uint)\r\n    {\r\n        return (\r\n        rounds[_block].entrantOne.mintRemainder,\r\n        rounds[_block].entrantTwo.mintRemainder,\r\n        rounds[_block].entrantThree.mintRemainder);\r\n    }\r\n\r\n\r\n    function choices()\r\n    public\r\n    view\r\n    returns (uint, uint, uint)\r\n    {\r\n        return (\r\n        LEFT,\r\n        RIGHT,\r\n        MISS);\r\n    }\r\n\r\n    function results(uint256 _block)\r\n    public\r\n    view\r\n    returns (uint, uint, uint, uint)\r\n    {\r\n        return (\r\n        rounds[_block].result,\r\n        rounds[_block].n2,\r\n        rounds[_block].n3,\r\n        rounds[_block].n4);\r\n    }\r\n\r\n    function getWaitlistItem(uint256 _item)\r\n    public\r\n    view\r\n    returns (address, uint8, bool, uint256, uint256)\r\n    {\r\n        return (\r\n        waitingList[_item].player,\r\n        waitingList[_item].choice,\r\n        waitingList[_item].dead,\r\n        waitingList[_item].mintRemainder,\r\n        _item);\r\n    }\r\n}\r\n\r\n\r\ninterface IP3X {\r\n    function transfer(address to, uint256 value) external returns(bool);\r\n    function transfer(address to, uint value, bytes calldata data) external returns(bool ok);\r\n    function buy(address referrerAddress) payable external returns(uint256);\r\n    function balanceOf(address tokenOwner) external view returns(uint);\r\n    function dividendsOf(address customerAddress, bool includeReferralBonus) external view returns(uint256);\r\n    function withdraw() external;\r\n}\r\n\r\n\r\ninterface IPledge {\r\n    function withdraw() external returns(uint256);\r\n}\r\n\r\ninterface MegaballInterface {\r\n    function DENOMINATION() external view returns(uint);\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr\r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n\r\n/**\r\n* @dev Multiplies two numbers, throws on overflow.\r\n*/\r\n    function mul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add2(uint8 a, uint8 b)\r\n        internal\r\n        pure\r\n        returns (uint8 c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a);\r\n        return uint8(c);\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add3(uint8 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint8 c)\r\n    {\r\n        c = a + uint8(b);\r\n        require(c >= a);\r\n        return uint8(c);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n      // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n      // uint256 c = a / b;\r\n      // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y)\r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y)\r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n\r\n    /**\r\n     * @dev x to the power of y\r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else\r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_choice\",\"type\":\"uint8\"}],\"name\":\"enterTruel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"waitingListMoveCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"waitingListCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RIGHT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"results\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"megaballContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"roundDeathInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"},{\"name\":\"_blockOwner\",\"type\":\"address\"}],\"name\":\"firstShotToRoundCreator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextValid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isValidator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"validator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_offset\",\"type\":\"uint256\"}],\"name\":\"getBlockFromQueue\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"deaths\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canCreateRound\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractP3XDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"denominationActiveTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractP3XBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractEthBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextToValidate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"item\",\"type\":\"uint256\"}],\"name\":\"getQueueItem\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LEFT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setValidatorBagMin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DIVIDENDS_JACKPOT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"mintRemainder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEthBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BACKFIRE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DENOMINATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_item\",\"type\":\"uint256\"}],\"name\":\"getWaitlistItem\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myP3XBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEarnings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"validatorBagMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whichBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pledgeDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"choices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fetchDividendsFromP3X\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateDenomination\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextWithdrawTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"queue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isValidatorAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINI_JACKPOT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enterFromWaitlist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UNALLOCATEDP3X\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MISS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BACKFIRE_JACKPOT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"pa\",\"type\":\"address\"},{\"name\":\"hx\",\"type\":\"address\"},{\"name\":\"mb\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"roundNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Jackpot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"p3xWithdrawn\",\"type\":\"uint256\"}],\"name\":\"OnWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"}],\"name\":\"WaitlistEntered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"roundNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"}],\"name\":\"RoundEntered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"roundNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"shooter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"dead\",\"type\":\"address\"}],\"name\":\"PlayerShot\",\"type\":\"event\"}]","ContractName":"Truel","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000073b2f2ee70391f8b4bd1b4a7a6d0451670f0613e000000000000000000000000058a144951e062fc14f310057d2fd9ef0cf5095b0000000000000000000000003fe2b3e8feb33ed523ce8f786c22cb6556f8a33f","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://eac030328346f575152580d97130252201f21d1d7f64fee5f2f48a85de8630d1"}]}