{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\r\n\r\n Licensed under the Apache License, Version 2.0 (the \"License\");\r\n you may not use this file except in compliance with the License.\r\n You may obtain a copy of the License at\r\n\r\n     http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n Unless required by applicable law or agreed to in writing, software\r\n distributed under the License is distributed on an \"AS IS\" BASIS,\r\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n See the License for the specific language governing permissions and\r\n limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.4.25;\r\npragma experimental \"v0.5.0\";\r\n\r\ninterface Authority {\r\n\r\n    /*\r\n     * EVENTS\r\n     */\r\n    event AuthoritySet(address indexed authority);\r\n    event WhitelisterSet(address indexed whitelister);\r\n    event WhitelistedUser(address indexed target, bool approved);\r\n    event WhitelistedRegistry(address indexed registry, bool approved);\r\n    event WhitelistedFactory(address indexed factory, bool approved);\r\n    event WhitelistedVault(address indexed vault, bool approved);\r\n    event WhitelistedDrago(address indexed drago, bool isWhitelisted);\r\n    event NewDragoEventful(address indexed dragoEventful);\r\n    event NewVaultEventful(address indexed vaultEventful);\r\n    event NewNavVerifier(address indexed navVerifier);\r\n    event NewExchangesAuthority(address indexed exchangesAuthority);\r\n\r\n    /*\r\n     * CORE FUNCTIONS\r\n     */\r\n    function setAuthority(address _authority, bool _isWhitelisted) external;\r\n    function setWhitelister(address _whitelister, bool _isWhitelisted) external;\r\n    function whitelistUser(address _target, bool _isWhitelisted) external;\r\n    function whitelistDrago(address _drago, bool _isWhitelisted) external;\r\n    function whitelistVault(address _vault, bool _isWhitelisted) external;\r\n    function whitelistRegistry(address _registry, bool _isWhitelisted) external;\r\n    function whitelistFactory(address _factory, bool _isWhitelisted) external;\r\n    function setDragoEventful(address _dragoEventful) external;\r\n    function setVaultEventful(address _vaultEventful) external;\r\n    function setNavVerifier(address _navVerifier) external;\r\n    function setExchangesAuthority(address _exchangesAuthority) external;\r\n\r\n    /*\r\n     * CONSTANT PUBLIC FUNCTIONS\r\n     */\r\n    function isWhitelistedUser(address _target) external view returns (bool);\r\n    function isAuthority(address _authority) external view returns (bool);\r\n    function isWhitelistedRegistry(address _registry) external view returns (bool);\r\n    function isWhitelistedDrago(address _drago) external view returns (bool);\r\n    function isWhitelistedVault(address _vault) external view returns (bool);\r\n    function isWhitelistedFactory(address _factory) external view returns (bool);\r\n    function getDragoEventful() external view returns (address);\r\n    function getVaultEventful() external view returns (address);\r\n    function getNavVerifier() external view returns (address);\r\n    function getExchangesAuthority() external view returns (address);\r\n}\r\n\r\ninterface VaultEventful {\r\n\r\n    /*\r\n     * EVENTS\r\n     */\r\n    event BuyVault(address indexed vault, address indexed from, address indexed to, uint256 amount, uint256 revenue, bytes name, bytes symbol);\r\n    event SellVault(address indexed vault, address indexed from, address indexed to, uint256 amount, uint256 revenue, bytes name, bytes symbol);\r\n    event NewRatio(address indexed vault, address indexed from, uint256 newRatio);\r\n    event NewFee(address indexed vault, address indexed from, address indexed to, uint256 fee);\r\n    event NewCollector(address indexed vault, address indexed from, address indexed to, address collector);\r\n    event VaultDao(address indexed vault, address indexed from, address indexed to, address vaultDao);\r\n    event VaultCreated(address indexed vault, address indexed group, address indexed owner, uint256 vaultId, string name, string symbol);\r\n\r\n    /*\r\n     * CORE FUNCTIONS\r\n     */\r\n    function buyVault(address _who, address _targetVault, uint256 _value, uint256 _amount, bytes _name, bytes _symbol) external returns (bool success);\r\n    function sellVault(address _who, address _targetVault, uint256 _amount, uint256 _revenue, bytes _name, bytes _symbol) external returns(bool success);\r\n    function changeRatio(address _who, address _targetVault, uint256 _ratio) external returns(bool success);\r\n    function setTransactionFee(address _who, address _targetVault, uint256 _transactionFee) external returns(bool success);\r\n    function changeFeeCollector(address _who, address _targetVault, address _feeCollector) external returns(bool success);\r\n    function changeVaultDao(address _who, address _targetVault, address _vaultDao) external returns(bool success);\r\n    function createVault(address _who, address _newVault, string _name, string _symbol, uint256 _vaultId) external returns(bool success);\r\n}\r\n\r\ninterface Token {\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    function balanceOf(address _who) external view returns (uint256);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n\r\n    // Locked state of mutex\r\n    bool private locked = false;\r\n\r\n    /// @dev Functions with this modifer cannot be reentered. The mutex will be locked\r\n    ///      before function execution and unlocked after.\r\n    modifier nonReentrant() {\r\n        // Ensure mutex is unlocked\r\n        require(\r\n            !locked,\r\n            \"REENTRANCY_ILLEGAL\"\r\n        );\r\n\r\n        // Lock mutex before function call\r\n        locked = true;\r\n\r\n        // Perform function call\r\n        _;\r\n\r\n        // Unlock mutex after function call\r\n        locked = false;\r\n    }\r\n}\r\n\r\ncontract Owned {\r\n\r\n    address public owner;\r\n\r\n    event NewOwner(address indexed old, address indexed current);\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function setOwner(address _new) public onlyOwner {\r\n        require(_new != address(0));\r\n        owner = _new;\r\n        emit  NewOwner(owner, _new);\r\n    }\r\n}\r\n\r\ncontract SafeMath {\r\n\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b > 0);\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface VaultFace {\r\n\r\n    /*\r\n     * CORE FUNCTIONS\r\n     */\r\n    function buyVault() external payable returns (bool success);\r\n    function buyVaultOnBehalf(address _hodler) external payable returns (bool success);\r\n    function sellVault(uint256 amount) external returns (bool success);\r\n    function changeRatio(uint256 _ratio) external;\r\n    function setTransactionFee(uint256 _transactionFee) external;\r\n    function changeFeeCollector(address _feeCollector) external;\r\n    function changeVaultDao(address _vaultDao) external;\r\n    function updatePrice() external;\r\n    function changeMinPeriod(uint32 _minPeriod) external;\r\n    function depositToken(address _token, uint256 _value, uint8 _forTime) external returns (bool success);\r\n    function depositTokenOnBehalf(address _token, address _hodler, uint256 _value, uint8 _forTime) external returns (bool success);\r\n    function withdrawToken(address _token, uint256 _value) external returns (bool success);\r\n\r\n    /*\r\n     * CONSTANT PUBLIC FUNCTIONS\r\n     */\r\n    function balanceOf(address _who) external view returns (uint256);\r\n    function tokenBalanceOf(address _token, address _owner) external view returns (uint256);\r\n    function timeToUnlock(address _token, address _user) external view returns (uint256);\r\n    function tokensInVault(address _token) external view returns (uint256);\r\n    function getEventful() external view returns (address);\r\n    function getData() external view returns (string name, string symbol, uint256 sellPrice, uint256 buyPrice);\r\n    function calcSharePrice() external view returns (uint256);\r\n    function getAdminData() external view returns (address, address feeCollector, address vaultDao, uint256 ratio, uint256 transactionFee, uint32 minPeriod);\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\n/// @title Vault - contract for creating a vault type of pool.\r\n/// @author Gabriele Rigo - <gab@rigoblock.com>\r\n// solhint-disable-next-line\r\ncontract Vault is Owned, SafeMath, ReentrancyGuard, VaultFace {\r\n\r\n    string constant VERSION = 'VC 0.5.2';\r\n    uint256 constant BASE = 1000000; //tokens are divisible by 1 million\r\n\r\n    VaultData data;\r\n    Admin admin;\r\n\r\n    mapping (address => Account) accounts;\r\n\r\n    mapping (address => uint256) totalTokens;\r\n    mapping (address => mapping (address => uint256)) public depositLock;\r\n    mapping (address => mapping (address => uint256)) public tokenBalances;\r\n\r\n    struct Receipt {\r\n        uint32 activation;\r\n    }\r\n\r\n    struct Account {\r\n        uint256 balance;\r\n        Receipt receipt;\r\n    }\r\n\r\n    struct VaultData {\r\n        string name;\r\n        string symbol;\r\n        uint256 vaultId;\r\n        uint256 totalSupply;\r\n        uint256 price;\r\n        uint256 transactionFee; // fee is in basis points (1 bps = 0.01%)\r\n        uint32 minPeriod;\r\n        uint128 validatorIndex;\r\n    }\r\n\r\n    struct Admin {\r\n        address authority;\r\n        address vaultDao;\r\n        address feeCollector;\r\n        uint256 minOrder; // minimum stake to avoid dust clogging things up\r\n        uint256 ratio; // ratio is 80%\r\n    }\r\n\r\n    modifier onlyVaultDao {\r\n        require(msg.sender == admin.vaultDao);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier minimumStake(uint256 _amount) {\r\n        require(_amount >= admin.minOrder);\r\n        _;\r\n    }\r\n\r\n    modifier hasEnough(uint256 _amount) {\r\n        require(accounts[msg.sender].balance >= _amount);\r\n        _;\r\n    }\r\n\r\n    modifier positiveAmount(uint256 _amount) {\r\n        require(accounts[msg.sender].balance + _amount > accounts[msg.sender].balance);\r\n        _;\r\n    }\r\n\r\n    modifier minimumPeriodPast {\r\n        require(now >= accounts[msg.sender].receipt.activation);\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        string _vaultName,\r\n        string _vaultSymbol,\r\n        uint256 _vaultId,\r\n        address _owner,\r\n        address _authority)\r\n        public\r\n    {\r\n        data.name = _vaultName;\r\n        data.symbol = _vaultSymbol;\r\n        data.vaultId = _vaultId;\r\n        data.price = 1 ether; //initial price is 1 Ether\r\n        owner = _owner;\r\n        admin.authority = _authority;\r\n        admin.vaultDao = msg.sender;\r\n        admin.minOrder = 1 finney;\r\n        admin.feeCollector = _owner;\r\n        admin.ratio = 80;\r\n    }\r\n\r\n    /*\r\n     * CORE FUNCTIONS\r\n     */\r\n    /// @dev Allows a user to buy into a vault\r\n    /// @return Bool the function executed correctly\r\n    function buyVault()\r\n        external\r\n        payable\r\n        minimumStake(msg.value)\r\n        returns (bool success)\r\n    {\r\n        require(buyVaultInternal(msg.sender, msg.value));\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allows a user to buy into a vault on behalf of an address\r\n    /// @param _hodler Address of the target user\r\n    /// @return Bool the function executed correctly\r\n    function buyVaultOnBehalf(address _hodler)\r\n        external\r\n        payable\r\n        minimumStake(msg.value)\r\n        returns (bool success)\r\n    {\r\n        require(buyVaultInternal(_hodler, msg.value));\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allows a user to sell from a vault\r\n    /// @param _amount Number of shares to sell\r\n    /// @return Bool the function executed correctly\r\n    function sellVault(uint256 _amount)\r\n        external\r\n        nonReentrant\r\n        hasEnough(_amount)\r\n        positiveAmount(_amount)\r\n        minimumPeriodPast\r\n        returns (bool success)\r\n    {\r\n        updatePriceInternal();\r\n        uint256 feeVault;\r\n        uint256 feeVaultDao;\r\n        uint256 netAmount;\r\n        uint256 netRevenue;\r\n        (feeVault, feeVaultDao, netAmount, netRevenue) = getSaleAmounts(_amount);\r\n        addSaleLog(_amount, netRevenue);\r\n        allocateSaleTokens(msg.sender, _amount, feeVault, feeVaultDao);\r\n        data.totalSupply = safeSub(data.totalSupply, netAmount);\r\n        msg.sender.transfer(netRevenue);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allows vault dao/factory to change fee split ratio\r\n    /// @param _ratio Number of ratio for wizard, from 0 to 100\r\n    function changeRatio(uint256 _ratio)\r\n        external\r\n        onlyVaultDao\r\n    {\r\n        Authority auth = Authority(admin.authority);\r\n        VaultEventful events = VaultEventful(auth.getVaultEventful());\r\n        require(events.changeRatio(msg.sender, this, _ratio));\r\n        admin.ratio = _ratio;\r\n    }\r\n\r\n    /// @dev Allows vault owner to set the transaction fee\r\n    /// @param _transactionFee Value of the transaction fee in basis points\r\n    function setTransactionFee(uint256 _transactionFee)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(_transactionFee <= 100); //fee cannot be higher than 1%\r\n        Authority auth = Authority(admin.authority);\r\n        VaultEventful events = VaultEventful(auth.getVaultEventful());\r\n        require(events.setTransactionFee(msg.sender, this, _transactionFee));\r\n        data.transactionFee = _transactionFee;\r\n    }\r\n\r\n    /// @dev Allows owner to decide where to receive the fee\r\n    /// @param _feeCollector Address of the fee receiver\r\n    function changeFeeCollector(address _feeCollector)\r\n        external\r\n        onlyOwner\r\n    {\r\n        Authority auth = Authority(admin.authority);\r\n        VaultEventful events = VaultEventful(auth.getVaultEventful());\r\n        require(events.changeFeeCollector(msg.sender, this, _feeCollector));\r\n        admin.feeCollector = _feeCollector;\r\n    }\r\n\r\n    /// @dev Allows vault dao/factory to upgrade its address\r\n    /// @param _vaultDao Address of the new vault dao\r\n    function changeVaultDao(address _vaultDao)\r\n        external\r\n        onlyVaultDao\r\n    {\r\n        Authority auth = Authority(admin.authority);\r\n        VaultEventful events = VaultEventful(auth.getVaultEventful());\r\n        require(events.changeVaultDao(msg.sender, this, _vaultDao));\r\n        admin.vaultDao = _vaultDao;\r\n    }\r\n\r\n    /// @dev Allows anyone to pay and update the price\r\n    /// @dev This function allows to write the new nav\r\n    /// @dev NAV is provided by view functions\r\n    function updatePrice()\r\n        external\r\n        nonReentrant\r\n    {\r\n        updatePriceInternal();\r\n    }\r\n\r\n    /// @dev Allows vault dao/factory to change the minimum holding period\r\n    /// @param _minPeriod Lockup time in seconds\r\n    function changeMinPeriod(uint32 _minPeriod)\r\n        external\r\n        onlyVaultDao\r\n    {\r\n        data.minPeriod = _minPeriod;\r\n    }\r\n\r\n    /// @dev Allows anyone to deposit tokens to a vault\r\n    /// @param _token Address of the token\r\n    /// @param _value Amount to deposit\r\n    /// @param _forTime Lockup time in seconds\r\n    /// @notice lockup time can be zero\r\n    function depositToken(\r\n        address _token,\r\n        uint256 _value,\r\n        uint8 _forTime)\r\n        external\r\n        nonReentrant\r\n        returns (bool success)\r\n    {\r\n        require(depositTokenInternal(_token, msg.sender, _value, _forTime));\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allows anyone to deposit tokens to a vault on behalf of someone\r\n    /// @param _token Address of the token\r\n    /// @param _value Amount to deposit\r\n    /// @param _forTime Lockup time in seconds\r\n    /// @notice lockup time can be zero\r\n    function depositTokenOnBehalf(\r\n        address _token,\r\n        address _hodler,\r\n        uint256 _value,\r\n        uint8 _forTime)\r\n        external\r\n        returns (bool success)\r\n    {\r\n        require(depositTokenInternal(_token, _hodler, _value, _forTime));\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allows anyone to withdraw tokens from a vault\r\n    /// @param _token Address of the token\r\n    /// @param _value Amount to withdraw\r\n    /// @return Bool the transaction was successful\r\n    function withdrawToken(\r\n        address _token,\r\n        uint256 _value)\r\n        external\r\n        nonReentrant\r\n        returns\r\n        (bool success)\r\n    {\r\n        require(tokenBalances[_token][msg.sender] >= _value);\r\n        require(uint32(now) > depositLock[_token][msg.sender]);\r\n        tokenBalances[_token][msg.sender] = safeSub(tokenBalances[_token][msg.sender], _value);\r\n        totalTokens[_token] = safeSub(totalTokens[_token], _value);\r\n        require(Token(_token).transfer(msg.sender, _value));\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * CONSTANT PUBLIC FUNCTIONS\r\n     */\r\n    /// @dev Calculates how many shares a user holds\r\n    /// @param _from Address of the target account\r\n    /// @return Number of shares\r\n    function balanceOf(address _from)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return accounts[_from].balance;\r\n    }\r\n\r\n    /// @dev Returns a user balance of a certain deposited token\r\n    /// @param _token Address of the token\r\n    /// @param _owner Address of the user\r\n    /// @return Number of tokens\r\n    function tokenBalanceOf(\r\n        address _token,\r\n        address _owner)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return tokenBalances[_token][_owner];\r\n    }\r\n\r\n    /// @dev Returns the time needed to withdraw\r\n    /// @param _token Address of the token\r\n    /// @param _user Address of the user\r\n    /// @return Time in seconds\r\n    function timeToUnlock(\r\n        address _token,\r\n        address _user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return depositLock[_token][_user];\r\n    }\r\n\r\n    /// @dev Returns the amount of tokens of a certain token in vault\r\n    /// @param _token Address of the token\r\n    /// @return _value in custody\r\n    function tokensInVault(address _token)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalTokens[_token];\r\n    }\r\n\r\n    /// @dev Gets the address of the logger contract\r\n    /// @return Address of the logger contrac\r\n    function getEventful()\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        Authority auth = Authority(admin.authority);\r\n        return auth.getVaultEventful();\r\n    }\r\n\r\n    /// @dev Finds details of a vault pool\r\n    /// @return String name of a vault\r\n    /// @return String symbol of a vault\r\n    /// @return Value of the share price in wei\r\n    /// @return Value of the share price in wei\r\n    function getData()\r\n        external\r\n        view\r\n        returns (\r\n            string name,\r\n            string symbol,\r\n            uint256 sellPrice,\r\n            uint256 buyPrice\r\n        )\r\n    {\r\n        return(\r\n            name = data.name,\r\n            symbol = data.symbol,\r\n            sellPrice = getNav(),\r\n            buyPrice = getNav()\r\n        );\r\n    }\r\n\r\n    /// @dev Returns the price of a pool\r\n    /// @return Value of the share price in wei\r\n    function calcSharePrice()\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return getNav();\r\n    }\r\n\r\n    /// @dev Finds the administrative data of the pool\r\n    /// @return Address of the account where a user collects fees\r\n    /// @return Address of the vault dao/factory\r\n    /// @return Number of the fee split ratio\r\n    /// @return Value of the transaction fee in basis points\r\n    /// @return Number of the minimum holding period for shares\r\n    function getAdminData()\r\n        external\r\n        view\r\n        returns (\r\n            address,\r\n            address feeCollector,\r\n            address vaultDao,\r\n            uint256 ratio,\r\n            uint256 transactionFee,\r\n            uint32 minPeriod\r\n        )\r\n    {\r\n        return (\r\n            owner,\r\n            admin.feeCollector,\r\n            admin.vaultDao,\r\n            admin.ratio,\r\n            data.transactionFee,\r\n            data.minPeriod\r\n        );\r\n    }\r\n\r\n    /// @dev Returns the total amount of issued tokens for this vault\r\n    /// @return Number of shares\r\n    function totalSupply()\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return data.totalSupply;\r\n    }\r\n\r\n    /*\r\n     * INTERNAL FUNCTIONS\r\n     */\r\n    /// @dev Executes purchase function\r\n    /// @param _hodler Address of the target user\r\n    /// @return Bool the function executed correctly\r\n    function buyVaultInternal(\r\n        address _hodler,\r\n        uint256 _totalEth)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        updatePriceInternal();\r\n        uint256 grossAmount;\r\n        uint256 feeVault;\r\n        uint256 feeVaultDao;\r\n        uint256 amount;\r\n        (grossAmount, feeVault, feeVaultDao, amount) = getPurchaseAmounts(_totalEth);\r\n        addPurchaseLog(amount);\r\n        allocatePurchaseTokens(_hodler, amount, feeVault, feeVaultDao);\r\n        data.totalSupply = safeAdd(data.totalSupply, grossAmount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Updates the price\r\n    function updatePriceInternal()\r\n        internal\r\n    {\r\n        if (address(this).balance > 0) {\r\n            data.price = getNav();\r\n        }\r\n    }\r\n\r\n    /// @dev Allocates tokens to buyer, splits fee in tokens to wizard and dao\r\n    /// @param _hodler Address of the buyer\r\n    /// @param _amount Value of issued tokens\r\n    /// @param _feeVault Number of shares as fee\r\n    /// @param _feeVaultDao Number of shares as fee to dao\r\n    function allocatePurchaseTokens(\r\n        address _hodler,\r\n        uint256 _amount,\r\n        uint256 _feeVault,\r\n        uint256 _feeVaultDao)\r\n        internal\r\n    {\r\n        accounts[_hodler].balance = safeAdd(accounts[_hodler].balance, _amount);\r\n        accounts[admin.feeCollector].balance = safeAdd(accounts[admin.feeCollector].balance, _feeVault);\r\n        accounts[admin.vaultDao].balance = safeAdd(accounts[admin.vaultDao].balance, _feeVaultDao);\r\n        accounts[_hodler].receipt.activation = uint32(now) + data.minPeriod;\r\n    }\r\n\r\n    /// @dev Destroys tokens from buyer, splits fee in tokens to wizard and dao\r\n    /// @param _hodler Address of the seller\r\n    /// @param _amount Value of burnt tokens\r\n    /// @param _feeVault Number of shares as fee\r\n    /// @param _feeVaultDao Number of shares as fee to dao\r\n    function allocateSaleTokens(\r\n        address _hodler,\r\n        uint256 _amount,\r\n        uint256 _feeVault,\r\n        uint256 _feeVaultDao)\r\n        internal\r\n    {\r\n        accounts[_hodler].balance = safeSub(accounts[_hodler].balance, _amount);\r\n        accounts[admin.feeCollector].balance = safeAdd(accounts[admin.feeCollector].balance, _feeVault);\r\n        accounts[admin.vaultDao].balance = safeAdd(accounts[admin.vaultDao].balance, _feeVaultDao);\r\n    }\r\n\r\n    /// @dev Sends a buy log to the eventful contract\r\n    /// @param _amount Number of purchased shares\r\n    function addPurchaseLog(uint256 _amount)\r\n        internal\r\n    {\r\n        bytes memory name = bytes(data.name);\r\n        bytes memory symbol = bytes(data.symbol);\r\n        Authority auth = Authority(admin.authority);\r\n        VaultEventful events = VaultEventful(auth.getVaultEventful());\r\n        require(events.buyVault(msg.sender, this, msg.value, _amount, name, symbol));\r\n    }\r\n\r\n    /// @dev Sends a sell log to the eventful contract\r\n    /// @param _amount Number of sold shares\r\n    /// @param _netRevenue Value of sale for hodler\r\n    function addSaleLog(\r\n        uint256 _amount,\r\n        uint256 _netRevenue)\r\n        internal\r\n    {\r\n        bytes memory name = bytes(data.name);\r\n        bytes memory symbol = bytes(data.symbol);\r\n        Authority auth = Authority(admin.authority);\r\n        VaultEventful events = VaultEventful(auth.getVaultEventful());\r\n        require(events.sellVault(msg.sender, this, _amount, _netRevenue, name, symbol));\r\n    }\r\n    \r\n    /// @dev Executes a deposit\r\n    /// @param _token Address of the token to be deposited\r\n    /// @param _hodler Address of the hodler\r\n    /// @param _value Amount of tokens\r\n    /// @param _forTime Time in seconds of lockup\r\n    /// @return Bool the transaction was successful\r\n    function depositTokenInternal(\r\n        address _token,\r\n        address _hodler,\r\n        uint256 _value,\r\n        uint8 _forTime)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        require(now + _forTime >= depositLock[_token][_hodler]);\r\n        require(Token(_token).approve(address(this), _value));\r\n        require(Token(_token).transferFrom(msg.sender, address(this), _value));\r\n        tokenBalances[_token][_hodler] = safeAdd(tokenBalances[_token][_hodler], _value);\r\n        totalTokens[_token] = safeAdd(totalTokens[_token], _value);\r\n        depositLock[_token][_hodler] = safeAdd(uint(now), _forTime);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Calculates the correct purchase amounts\r\n    /// @return Number of new shares\r\n    /// @return Value of fee in shares\r\n    /// @return Value of fee in shares to dao\r\n    /// @return Value of net purchased shares\r\n    function getPurchaseAmounts(uint256 _totalEth)\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 grossAmount,\r\n            uint256 feeVault,\r\n            uint256 feeVaultDao,\r\n            uint256 amount\r\n        )\r\n    {\r\n        grossAmount = safeDiv(_totalEth * BASE, data.price);\r\n        uint256 fee = safeMul(grossAmount, data.transactionFee) / 10000; //fee is in basis points\r\n        return (\r\n            grossAmount,\r\n            feeVault = safeMul(fee , admin.ratio) / 100,\r\n            feeVaultDao = safeSub(fee, feeVault),\r\n            amount = safeSub(grossAmount, fee)\r\n        );\r\n    }\r\n\r\n    /// @dev Calculates the correct sale amounts\r\n    /// @return Value of fee in shares\r\n    /// @return Value of fee in shares to dao\r\n    /// @return Value of net sold shares\r\n    /// @return Value of sale amount for hodler\r\n    function getSaleAmounts(uint256 _amount)\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 feeVault,\r\n            uint256 feeVaultDao,\r\n            uint256 netAmount,\r\n            uint256 netRevenue\r\n        )\r\n    {\r\n        uint256 fee = safeMul(_amount, data.transactionFee) / 10000; //fee is in basis points\r\n        return (\r\n            feeVault = safeMul(fee, admin.ratio) / 100,\r\n            feeVaultDao = safeSub(fee, feeVaultDao),\r\n            netAmount = safeSub(_amount, fee),\r\n            netRevenue = (safeMul(netAmount, data.price) / BASE)\r\n        );\r\n    }\r\n\r\n    /// @dev Calculates the value of the shares\r\n    /// @return Value of the shares in wei\r\n    function getNav()\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 aum = address(this).balance - msg.value;\r\n        return (data.totalSupply == 0 ? data.price : safeDiv(aum * BASE, data.totalSupply));\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_transactionFee\",\"type\":\"uint256\"}],\"name\":\"setTransactionFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_forTime\",\"type\":\"uint8\"}],\"name\":\"depositToken\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"tokensInVault\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokenBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellVault\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getData\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"sellPrice\",\"type\":\"uint256\"},{\"name\":\"buyPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vaultDao\",\"type\":\"address\"}],\"name\":\"changeVaultDao\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minPeriod\",\"type\":\"uint32\"}],\"name\":\"changeMinPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updatePrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEventful\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"timeToUnlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdminData\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"feeCollector\",\"type\":\"address\"},{\"name\":\"vaultDao\",\"type\":\"address\"},{\"name\":\"ratio\",\"type\":\"uint256\"},{\"name\":\"transactionFee\",\"type\":\"uint256\"},{\"name\":\"minPeriod\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeCollector\",\"type\":\"address\"}],\"name\":\"changeFeeCollector\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calcSharePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hodler\",\"type\":\"address\"}],\"name\":\"buyVaultOnBehalf\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_hodler\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_forTime\",\"type\":\"uint8\"}],\"name\":\"depositTokenOnBehalf\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyVault\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositLock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ratio\",\"type\":\"uint256\"}],\"name\":\"changeRatio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_vaultName\",\"type\":\"string\"},{\"name\":\"_vaultSymbol\",\"type\":\"string\"},{\"name\":\"_vaultId\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_authority\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"old\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"current\",\"type\":\"address\"}],\"name\":\"NewOwner\",\"type\":\"event\"}]","ContractName":"Vault","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000009899beaad8ded0402c39148afdd03850dfe29fda000000000000000000000000307b265c6ab333b63e739936722cc8e62d78cc1900000000000000000000000000000000000000000000000000000000000000084265737420706f700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003424f500000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://f2cabb81a60ffa035834e4ef0dc5069099e9f5a66a3929bd9459166aba58ae36"}]}