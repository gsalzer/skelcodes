{"status":"1","message":"OK","result":[{"SourceCode":"//\r\n// Our shop contract acts as a payment provider for our in-game shop system. \r\n// Coin packages that are purchased here are being picked up by our offchain \r\n// sync network and are then translated into in-game assets. This happens with\r\n// minimal delay and enables a fluid gameplay experience. An in-game notification\r\n// informs players about the successful purchase of coins.\r\n// \r\n// Prices are scaled against the current USD value of ETH courtesy of\r\n// MAKERDAO (https://developer.makerdao.com/feeds/) \r\n// This enables us to match our native In-App-Purchase prices from e.g. Apple's AppStore\r\n// We can also reduce the price of packages temporarily for e.g. events and promotions.\r\n//\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) constant returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    function DSAuth() {\r\n        owner = msg.sender;\r\n        LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        assert(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    modifier authorized(bytes4 sig) {\r\n        assert(isAuthorized(msg.sender, sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n\r\n    function assert(bool x) internal {\r\n        if (!x) throw;\r\n    }\r\n}\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n\tuint\t \t  wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n        }\r\n\r\n        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\ncontract DSMath {\r\n    \r\n    /*\r\n    standard uint256 functions\r\n     */\r\n\r\n    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x + y) >= x);\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x - y) <= x);\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x * y) >= x);\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        z = x / y;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    /*\r\n    uint128 functions (h is for half)\r\n     */\r\n\r\n\r\n    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        assert((z = x + y) >= x);\r\n    }\r\n\r\n    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        assert((z = x - y) <= x);\r\n    }\r\n\r\n    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        assert((z = x * y) >= x);\r\n    }\r\n\r\n    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = x / y;\r\n    }\r\n\r\n    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n\r\n    /*\r\n    int256 functions\r\n     */\r\n\r\n    function imin(int256 x, int256 y) constant internal returns (int256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int256 x, int256 y) constant internal returns (int256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    /*\r\n    WAD math\r\n     */\r\n\r\n    uint128 constant WAD = 10 ** 18;\r\n\r\n    function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hadd(x, y);\r\n    }\r\n\r\n    function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hsub(x, y);\r\n    }\r\n\r\n    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = cast((uint256(x) * y + WAD / 2) / WAD);\r\n    }\r\n\r\n    function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = cast((uint256(x) * WAD + y / 2) / y);\r\n    }\r\n\r\n    function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hmin(x, y);\r\n    }\r\n    function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hmax(x, y);\r\n    }\r\n\r\n    /*\r\n    RAY math\r\n     */\r\n\r\n    uint128 constant RAY = 10 ** 27;\r\n\r\n    function radd(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hadd(x, y);\r\n    }\r\n\r\n    function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hsub(x, y);\r\n    }\r\n\r\n    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = cast((uint256(x) * y + RAY / 2) / RAY);\r\n    }\r\n\r\n    function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = cast((uint256(x) * RAY + y / 2) / y);\r\n    }\r\n\r\n    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\r\n        // This famous algorithm is called \"exponentiation by squaring\"\r\n        // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n        //\r\n        // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n        //\r\n        // These facts are why it works:\r\n        //\r\n        //  If n is even, then x^n = (x^2)^(n/2).\r\n        //  If n is odd,  then x^n = x * x^(n-1),\r\n        //   and applying the equation for even x gives\r\n        //    x^n = x * (x^2)^((n-1) / 2).\r\n        //\r\n        //  Also, EVM division is flooring and\r\n        //    floor[(n-1) / 2] = floor[n / 2].\r\n\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n\r\n    function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hmin(x, y);\r\n    }\r\n    function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hmax(x, y);\r\n    }\r\n\r\n    function cast(uint256 x) constant internal returns (uint128 z) {\r\n        assert((z = uint128(x)) == x);\r\n    }\r\n\r\n}\r\n\r\ncontract DSThing is DSAuth, DSNote, DSMath {\r\n}\r\n\r\ncontract DSValue is DSThing {\r\n    bool    has;\r\n    bytes32 val;\r\n    function peek() constant returns (bytes32, bool) {\r\n        return (val,has);\r\n    }\r\n    function read() constant returns (bytes32) {\r\n        var (wut, has) = peek();\r\n        assert(has);\r\n        return wut;\r\n    }\r\n    function poke(bytes32 wut) note auth {\r\n        val = wut;\r\n        has = true;\r\n    }\r\n    function void() note auth { // unset the value\r\n        has = false;\r\n    }\r\n}\r\n\r\ncontract Medianizer is DSValue {\r\n    mapping (bytes12 => address) public values;\r\n    mapping (address => bytes12) public indexes;\r\n    bytes12 public next = 0x1;\r\n\r\n    uint96 public min = 0x1;\r\n\r\n    function set(address wat) auth {\r\n        bytes12 nextId = bytes12(uint96(next) + 1);\r\n        assert(nextId != 0x0);\r\n        set(next, wat);\r\n        next = nextId;\r\n    }\r\n\r\n    function set(bytes12 pos, address wat) note auth {\r\n        if (pos == 0x0) throw;\r\n\r\n        if (wat != 0 && indexes[wat] != 0) throw;\r\n\r\n        indexes[values[pos]] = 0; // Making sure to remove a possible existing address in that position\r\n\r\n        if (wat != 0) {\r\n            indexes[wat] = pos;\r\n        }\r\n\r\n        values[pos] = wat;\r\n    }\r\n\r\n    function setMin(uint96 min_) note auth {\r\n        if (min_ == 0x0) throw;\r\n        min = min_;\r\n    }\r\n\r\n    function setNext(bytes12 next_) note auth {\r\n        if (next_ == 0x0) throw;\r\n        next = next_;\r\n    }\r\n\r\n    function unset(bytes12 pos) {\r\n        set(pos, 0);\r\n    }\r\n\r\n    function unset(address wat) {\r\n        set(indexes[wat], 0);\r\n    }\r\n\r\n    function poke() {\r\n        poke(0);\r\n    }\r\n\r\n    function poke(bytes32) note {\r\n        (val, has) = compute();\r\n    }\r\n\r\n    function compute() constant returns (bytes32, bool) {\r\n        bytes32[] memory wuts = new bytes32[](uint96(next) - 1);\r\n        uint96 ctr = 0;\r\n        for (uint96 i = 1; i < uint96(next); i++) {\r\n            if (values[bytes12(i)] != 0) {\r\n                var (wut, wuz) = DSValue(values[bytes12(i)]).peek();\r\n                if (wuz) {\r\n                    if (ctr == 0 || wut >= wuts[ctr - 1]) {\r\n                        wuts[ctr] = wut;\r\n                    } else {\r\n                        uint96 j = 0;\r\n                        while (wut >= wuts[j]) {\r\n                            j++;\r\n                        }\r\n                        for (uint96 k = ctr; k > j; k--) {\r\n                            wuts[k] = wuts[k - 1];\r\n                        }\r\n                        wuts[j] = wut;\r\n                    }\r\n                    ctr++;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (ctr < min) return (val, false);\r\n\r\n        bytes32 value;\r\n        if (ctr % 2 == 0) {\r\n            uint128 val1 = uint128(wuts[(ctr / 2) - 1]);\r\n            uint128 val2 = uint128(wuts[ctr / 2]);\r\n            value = bytes32(wdiv(hadd(val1, val2), 2 ether));\r\n        } else {\r\n            value = wuts[(ctr - 1) / 2];\r\n        }\r\n\r\n        return (value, true);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n * via OpenZeppelin\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    require(_newOwner != address(0));\r\n    OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract ChainmonstersMedianizer is Ownable {\r\n\r\n    address medianizerBase;\r\n    Medianizer makerMed;\r\n\r\n    constructor(address _medianizerContract) public {\r\n        owner = msg.sender;\r\n\r\n        medianizerBase = _medianizerContract;\r\n\r\n        makerMed = Medianizer(medianizerBase);\r\n    }\r\n\r\n    function updateMedianizerBase(address _medianizerContract) public onlyOwner {\r\n        medianizerBase = _medianizerContract;\r\n        makerMed = Medianizer(medianizerBase);\r\n    }\r\n\r\n    function getUSDPrice() public view returns (uint256) {\r\n        return bytesToUint(toBytes(makerMed.read()));\r\n    }\r\n    \r\n    function isMedianizer() public view returns (bool) {\r\n        return true;\r\n    }\r\n    \r\n    \r\n\r\n    function toBytes(bytes32 _data) public pure returns (bytes) {\r\n        return abi.encodePacked(_data);\r\n    }\r\n\r\n    function bytesToUint(bytes b) public pure returns (uint256){\r\n        uint256 number;\r\n        for(uint i=0;i<b.length;i++){\r\n            number = number + uint(b[i])*(2**(8*(b.length-(i+1))));\r\n        }\r\n        return number;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n*/\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, returns 0 if it would go into minus range.\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (b >= a) {\r\n            return 0;\r\n        }\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ChainmonstersShop {\r\n    using SafeMath for uint256; \r\n    \r\n    // static\r\n    address public owner;\r\n    \r\n    // start auction manually at given time\r\n    bool started;\r\n\r\n    uint256 public totalCoinsSold;\r\n\r\n    address medianizer;\r\n    uint256 shiftValue = 100; // double digit shifting to support prices like $29.99\r\n    uint256 multiplier = 10000; // internal multiplier\r\n\r\n    struct Package {\r\n        // price in USD\r\n        uint256 price;\r\n        // reference to in-game equivalent e.g. \"100 Coins\"\r\n        string packageReference;\r\n        // available for purchase?\r\n        bool isActive;\r\n        // amount of coins\r\n        uint256 coinsAmount;\r\n    }\r\n\r\n    \r\n    event LogPurchase(address _from, uint256 _price, string _packageReference);\r\n\r\n    mapping(address => uint256) public addressToCoinsPurchased;\r\n    Package[] packages;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n\r\n        started = false;\r\n    }\r\n\r\n    function startShop() public onlyOwner {\r\n        require(started == false);\r\n\r\n    }\r\n\r\n    // in case of contract switch or adding new packages\r\n    function pauseShop() public onlyOwner {\r\n        require(started == true);\r\n    }\r\n\r\n    function isStarted() public view returns (bool success) {\r\n        return started;\r\n    }\r\n\r\n    function purchasePackage(uint256 _id) public\r\n        payable\r\n        returns (bool success)\r\n        {\r\n            require(started == true);\r\n            require(packages[_id].isActive == true);\r\n            require(msg.sender != owner);\r\n            require(msg.value == priceOf(packages[_id].price)); // only accept 100% accurate prices\r\n\r\n            addressToCoinsPurchased[msg.sender] += packages[_id].coinsAmount;\r\n            totalCoinsSold += packages[_id].coinsAmount;\r\n            emit LogPurchase(msg.sender, msg.value, packages[_id].packageReference);\r\n        }\r\n\r\n    function addPackage(uint256 _price, string _packageReference, bool _isActive, uint256 _coinsAmount)\r\n        external\r\n        onlyOwner\r\n        {\r\n            require(_price > 0);\r\n            Package memory _package = Package({\r\n            price: uint256(_price),\r\n            packageReference: string(_packageReference),\r\n            isActive: bool(_isActive),\r\n            coinsAmount: uint256(_coinsAmount)\r\n        });\r\n\r\n        uint256 newPackageId = packages.push(_package);\r\n\r\n        }\r\n\r\n    function setPrice(uint256 _packageId, uint256 _newPrice)\r\n        external\r\n        onlyOwner\r\n        {\r\n            require(packages[_packageId].price > 0);\r\n            packages[_packageId].price = _newPrice;\r\n        }\r\n\r\n    function getPackage(uint256 _id)\r\n        external \r\n        view\r\n        returns (uint256 priceInETH, uint256 priceInUSD, string packageReference, uint256 coinsAmount )\r\n        {\r\n            Package storage package = packages[_id];\r\n            priceInETH = priceOf(_id);\r\n            priceInUSD = package.price;\r\n            packageReference = package.packageReference;\r\n            coinsAmount = package.coinsAmount;\r\n        \r\n        }\r\n\r\n \r\n  function priceOf(uint256 _packageId)\r\n    public\r\n    view\r\n    returns (uint256) \r\n    {\r\n\r\n        // if no medianizer is set then return fixed price(!)\r\n        if (medianizer == address(0x0)) {\r\n          return packages[_packageId].price;\r\n        }\r\n        else {\r\n          // the price of usd/eth gets returned from medianizer\r\n          uint256 USDinWei = ChainmonstersMedianizer(medianizer).getUSDPrice();\r\n    \r\n          uint256 multValue = (packages[_packageId].price.mul(multiplier)).div(USDinWei.div(1 ether));\r\n          uint256 inWei = multValue.mul(1 ether);\r\n          uint256 result = inWei.div(shiftValue.mul(multiplier));\r\n          return result;\r\n        }\r\n    \r\n  }\r\n  \r\n  function getPackagesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return packages.length;\r\n    }\r\n\r\n  function setMedianizer(ChainmonstersMedianizer _medianizer)\r\n     public\r\n    onlyOwner \r\n    {\r\n    require(_medianizer.isMedianizer(), \"given address is not a medianizer contract!\");\r\n    medianizer = _medianizer;\r\n  }\r\n\r\n    \r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\nfunction withdrawBalance() external onlyOwner {\r\n        uint256 balance = this.balance;\r\n        owner.transfer(balance);\r\n    }\r\n    \r\n   \r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_packageReference\",\"type\":\"string\"},{\"name\":\"_isActive\",\"type\":\"bool\"},{\"name\":\"_coinsAmount\",\"type\":\"uint256\"}],\"name\":\"addPackage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCoinsSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseShop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToCoinsPurchased\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStarted\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startShop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"purchasePackage\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_packageId\",\"type\":\"uint256\"}],\"name\":\"priceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getPackage\",\"outputs\":[{\"name\":\"priceInETH\",\"type\":\"uint256\"},{\"name\":\"priceInUSD\",\"type\":\"uint256\"},{\"name\":\"packageReference\",\"type\":\"string\"},{\"name\":\"coinsAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPackagesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_medianizer\",\"type\":\"address\"}],\"name\":\"setMedianizer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_packageId\",\"type\":\"uint256\"},{\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_packageReference\",\"type\":\"string\"}],\"name\":\"LogPurchase\",\"type\":\"event\"}]","ContractName":"ChainmonstersShop","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c96613b0dc1aab575313d2fd593b8fad911ffb2ca59061529e149107af8e3334"}]}