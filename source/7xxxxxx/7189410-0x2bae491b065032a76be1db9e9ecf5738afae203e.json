{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\n// File: @gnosis.pm/util-contracts/contracts/Proxy.sol\r\n\r\n/// @title Proxied - indicates that a contract will be proxied. Also defines storage requirements for Proxy.\r\n/// @author Alan Lu - <alan@gnosis.pm>\r\ncontract Proxied {\r\n    address public masterCopy;\r\n}\r\n\r\n/// @title Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\ncontract Proxy is Proxied {\r\n    /// @dev Constructor function sets address of master copy contract.\r\n    /// @param _masterCopy Master copy address.\r\n    constructor(address _masterCopy) public {\r\n        require(_masterCopy != address(0), \"The master copy is required\");\r\n        masterCopy = _masterCopy;\r\n    }\r\n\r\n    /// @dev Fallback function forwards all transactions and returns all received return data.\r\n    function() external payable {\r\n        address _masterCopy = masterCopy;\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize)\r\n            let success := delegatecall(not(0), _masterCopy, 0, calldatasize, 0, 0)\r\n            returndatacopy(0, 0, returndatasize)\r\n            switch success\r\n                case 0 {\r\n                    revert(0, returndatasize)\r\n                }\r\n                default {\r\n                    return(0, returndatasize)\r\n                }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @gnosis.pm/util-contracts/contracts/Token.sol\r\n\r\n/// Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\npragma solidity ^0.5.2;\r\n\r\n/// @title Abstract token contract - Functions to be implemented by token contracts\r\ncontract Token {\r\n    /*\r\n     *  Events\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    function transfer(address to, uint value) public returns (bool);\r\n    function transferFrom(address from, address to, uint value) public returns (bool);\r\n    function approve(address spender, uint value) public returns (bool);\r\n    function balanceOf(address owner) public view returns (uint);\r\n    function allowance(address owner, address spender) public view returns (uint);\r\n    function totalSupply() public view returns (uint);\r\n}\r\n\r\n// File: @gnosis.pm/util-contracts/contracts/Math.sol\r\n\r\n/// @title Math library - Allows calculation of logarithmic and exponential functions\r\n/// @author Alan Lu - <alan.lu@gnosis.pm>\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\nlibrary GnosisMath {\r\n    /*\r\n     *  Constants\r\n     */\r\n    // This is equal to 1 in our calculations\r\n    uint public constant ONE = 0x10000000000000000;\r\n    uint public constant LN2 = 0xb17217f7d1cf79ac;\r\n    uint public constant LOG2_E = 0x171547652b82fe177;\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Returns natural exponential function value of given x\r\n    /// @param x x\r\n    /// @return e**x\r\n    function exp(int x) public pure returns (uint) {\r\n        // revert if x is > MAX_POWER, where\r\n        // MAX_POWER = int(mp.floor(mp.log(mpf(2**256 - 1) / ONE) * ONE))\r\n        require(x <= 2454971259878909886679);\r\n        // return 0 if exp(x) is tiny, using\r\n        // MIN_POWER = int(mp.floor(mp.log(mpf(1) / ONE) * ONE))\r\n        if (x < -818323753292969962227) return 0;\r\n        // Transform so that e^x -> 2^x\r\n        x = x * int(ONE) / int(LN2);\r\n        // 2^x = 2^whole(x) * 2^frac(x)\r\n        //       ^^^^^^^^^^ is a bit shift\r\n        // so Taylor expand on z = frac(x)\r\n        int shift;\r\n        uint z;\r\n        if (x >= 0) {\r\n            shift = x / int(ONE);\r\n            z = uint(x % int(ONE));\r\n        } else {\r\n            shift = x / int(ONE) - 1;\r\n            z = ONE - uint(-x % int(ONE));\r\n        }\r\n        // 2^x = 1 + (ln 2) x + (ln 2)^2/2! x^2 + ...\r\n        //\r\n        // Can generate the z coefficients using mpmath and the following lines\r\n        // >>> from mpmath import mp\r\n        // >>> mp.dps = 100\r\n        // >>> ONE =  0x10000000000000000\r\n        // >>> print('\\n'.join(hex(int(mp.log(2)**i / mp.factorial(i) * ONE)) for i in range(1, 7)))\r\n        // 0xb17217f7d1cf79ab\r\n        // 0x3d7f7bff058b1d50\r\n        // 0xe35846b82505fc5\r\n        // 0x276556df749cee5\r\n        // 0x5761ff9e299cc4\r\n        // 0xa184897c363c3\r\n        uint zpow = z;\r\n        uint result = ONE;\r\n        result += 0xb17217f7d1cf79ab * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x3d7f7bff058b1d50 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0xe35846b82505fc5 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x276556df749cee5 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x5761ff9e299cc4 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0xa184897c363c3 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0xffe5fe2c4586 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x162c0223a5c8 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x1b5253d395e * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x1e4cf5158b * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x1e8cac735 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x1c3bd650 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x1816193 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x131496 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0xe1b7 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x9c7 * zpow / ONE;\r\n        if (shift >= 0) {\r\n            if (result >> (256 - shift) > 0) return (2 ** 256 - 1);\r\n            return result << shift;\r\n        } else return result >> (-shift);\r\n    }\r\n\r\n    /// @dev Returns natural logarithm value of given x\r\n    /// @param x x\r\n    /// @return ln(x)\r\n    function ln(uint x) public pure returns (int) {\r\n        require(x > 0);\r\n        // binary search for floor(log2(x))\r\n        int ilog2 = floorLog2(x);\r\n        int z;\r\n        if (ilog2 < 0) z = int(x << uint(-ilog2));\r\n        else z = int(x >> uint(ilog2));\r\n        // z = x * 2^-⌊log₂x⌋\r\n        // so 1 <= z < 2\r\n        // and ln z = ln x - ⌊log₂x⌋/log₂e\r\n        // so just compute ln z using artanh series\r\n        // and calculate ln x from that\r\n        int term = (z - int(ONE)) * int(ONE) / (z + int(ONE));\r\n        int halflnz = term;\r\n        int termpow = term * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 3;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 5;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 7;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 9;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 11;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 13;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 15;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 17;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 19;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 21;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 23;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 25;\r\n        return (ilog2 * int(ONE)) * int(ONE) / int(LOG2_E) + 2 * halflnz;\r\n    }\r\n\r\n    /// @dev Returns base 2 logarithm value of given x\r\n    /// @param x x\r\n    /// @return logarithmic value\r\n    function floorLog2(uint x) public pure returns (int lo) {\r\n        lo = -64;\r\n        int hi = 193;\r\n        // I use a shift here instead of / 2 because it floors instead of rounding towards 0\r\n        int mid = (hi + lo) >> 1;\r\n        while ((lo + 1) < hi) {\r\n            if (mid < 0 && x << uint(-mid) < ONE || mid >= 0 && x >> uint(mid) < ONE) hi = mid;\r\n            else lo = mid;\r\n            mid = (hi + lo) >> 1;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns maximum of an array\r\n    /// @param nums Numbers to look through\r\n    /// @return Maximum number\r\n    function max(int[] memory nums) public pure returns (int maxNum) {\r\n        require(nums.length > 0);\r\n        maxNum = -2 ** 255;\r\n        for (uint i = 0; i < nums.length; i++) if (nums[i] > maxNum) maxNum = nums[i];\r\n    }\r\n\r\n    /// @dev Returns whether an add operation causes an overflow\r\n    /// @param a First addend\r\n    /// @param b Second addend\r\n    /// @return Did no overflow occur?\r\n    function safeToAdd(uint a, uint b) internal pure returns (bool) {\r\n        return a + b >= a;\r\n    }\r\n\r\n    /// @dev Returns whether a subtraction operation causes an underflow\r\n    /// @param a Minuend\r\n    /// @param b Subtrahend\r\n    /// @return Did no underflow occur?\r\n    function safeToSub(uint a, uint b) internal pure returns (bool) {\r\n        return a >= b;\r\n    }\r\n\r\n    /// @dev Returns whether a multiply operation causes an overflow\r\n    /// @param a First factor\r\n    /// @param b Second factor\r\n    /// @return Did no overflow occur?\r\n    function safeToMul(uint a, uint b) internal pure returns (bool) {\r\n        return b == 0 || a * b / b == a;\r\n    }\r\n\r\n    /// @dev Returns sum if no overflow occurred\r\n    /// @param a First addend\r\n    /// @param b Second addend\r\n    /// @return Sum\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        require(safeToAdd(a, b));\r\n        return a + b;\r\n    }\r\n\r\n    /// @dev Returns difference if no overflow occurred\r\n    /// @param a Minuend\r\n    /// @param b Subtrahend\r\n    /// @return Difference\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        require(safeToSub(a, b));\r\n        return a - b;\r\n    }\r\n\r\n    /// @dev Returns product if no overflow occurred\r\n    /// @param a First factor\r\n    /// @param b Second factor\r\n    /// @return Product\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        require(safeToMul(a, b));\r\n        return a * b;\r\n    }\r\n\r\n    /// @dev Returns whether an add operation causes an overflow\r\n    /// @param a First addend\r\n    /// @param b Second addend\r\n    /// @return Did no overflow occur?\r\n    function safeToAdd(int a, int b) internal pure returns (bool) {\r\n        return (b >= 0 && a + b >= a) || (b < 0 && a + b < a);\r\n    }\r\n\r\n    /// @dev Returns whether a subtraction operation causes an underflow\r\n    /// @param a Minuend\r\n    /// @param b Subtrahend\r\n    /// @return Did no underflow occur?\r\n    function safeToSub(int a, int b) internal pure returns (bool) {\r\n        return (b >= 0 && a - b <= a) || (b < 0 && a - b > a);\r\n    }\r\n\r\n    /// @dev Returns whether a multiply operation causes an overflow\r\n    /// @param a First factor\r\n    /// @param b Second factor\r\n    /// @return Did no overflow occur?\r\n    function safeToMul(int a, int b) internal pure returns (bool) {\r\n        return (b == 0) || (a * b / b == a);\r\n    }\r\n\r\n    /// @dev Returns sum if no overflow occurred\r\n    /// @param a First addend\r\n    /// @param b Second addend\r\n    /// @return Sum\r\n    function add(int a, int b) internal pure returns (int) {\r\n        require(safeToAdd(a, b));\r\n        return a + b;\r\n    }\r\n\r\n    /// @dev Returns difference if no overflow occurred\r\n    /// @param a Minuend\r\n    /// @param b Subtrahend\r\n    /// @return Difference\r\n    function sub(int a, int b) internal pure returns (int) {\r\n        require(safeToSub(a, b));\r\n        return a - b;\r\n    }\r\n\r\n    /// @dev Returns product if no overflow occurred\r\n    /// @param a First factor\r\n    /// @param b Second factor\r\n    /// @return Product\r\n    function mul(int a, int b) internal pure returns (int) {\r\n        require(safeToMul(a, b));\r\n        return a * b;\r\n    }\r\n}\r\n\r\n// File: @gnosis.pm/util-contracts/contracts/GnosisStandardToken.sol\r\n\r\n/**\r\n * Deprecated: Use Open Zeppeling one instead\r\n */\r\ncontract StandardTokenData {\r\n    /*\r\n     *  Storage\r\n     */\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowances;\r\n    uint totalTokens;\r\n}\r\n\r\n/**\r\n * Deprecated: Use Open Zeppeling one instead\r\n */\r\n/// @title Standard token contract with overflow protection\r\ncontract GnosisStandardToken is Token, StandardTokenData {\r\n    using GnosisMath for *;\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Transfers sender's tokens to a given address. Returns success\r\n    /// @param to Address of token receiver\r\n    /// @param value Number of tokens to transfer\r\n    /// @return Was transfer successful?\r\n    function transfer(address to, uint value) public returns (bool) {\r\n        if (!balances[msg.sender].safeToSub(value) || !balances[to].safeToAdd(value)) {\r\n            return false;\r\n        }\r\n\r\n        balances[msg.sender] -= value;\r\n        balances[to] += value;\r\n        emit Transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success\r\n    /// @param from Address from where tokens are withdrawn\r\n    /// @param to Address to where tokens are sent\r\n    /// @param value Number of tokens to transfer\r\n    /// @return Was transfer successful?\r\n    function transferFrom(address from, address to, uint value) public returns (bool) {\r\n        if (!balances[from].safeToSub(value) || !allowances[from][msg.sender].safeToSub(\r\n            value\r\n        ) || !balances[to].safeToAdd(value)) {\r\n            return false;\r\n        }\r\n        balances[from] -= value;\r\n        allowances[from][msg.sender] -= value;\r\n        balances[to] += value;\r\n        emit Transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Sets approved amount of tokens for spender. Returns success\r\n    /// @param spender Address of allowed account\r\n    /// @param value Number of approved tokens\r\n    /// @return Was approval successful?\r\n    function approve(address spender, uint value) public returns (bool) {\r\n        allowances[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Returns number of allowed tokens for given address\r\n    /// @param owner Address of token owner\r\n    /// @param spender Address of token spender\r\n    /// @return Remaining allowance for spender\r\n    function allowance(address owner, address spender) public view returns (uint) {\r\n        return allowances[owner][spender];\r\n    }\r\n\r\n    /// @dev Returns number of tokens owned by given address\r\n    /// @param owner Address of token owner\r\n    /// @return Balance of owner\r\n    function balanceOf(address owner) public view returns (uint) {\r\n        return balances[owner];\r\n    }\r\n\r\n    /// @dev Returns total supply of tokens\r\n    /// @return Total supply\r\n    function totalSupply() public view returns (uint) {\r\n        return totalTokens;\r\n    }\r\n}\r\n\r\n// File: contracts/TokenFRT.sol\r\n\r\n/// @title Standard token contract with overflow protection\r\ncontract TokenFRT is Proxied, GnosisStandardToken {\r\n    address public owner;\r\n\r\n    string public constant symbol = \"MGN\";\r\n    string public constant name = \"Magnolia Token\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    struct UnlockedToken {\r\n        uint amountUnlocked;\r\n        uint withdrawalTime;\r\n    }\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    address public minter;\r\n\r\n    // user => UnlockedToken\r\n    mapping(address => UnlockedToken) public unlockedTokens;\r\n\r\n    // user => amount\r\n    mapping(address => uint) public lockedTokenBalances;\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n\r\n    // @dev allows to set the minter of Magnolia tokens once.\r\n    // @param   _minter the minter of the Magnolia tokens, should be the DX-proxy\r\n    function updateMinter(address _minter) public {\r\n        require(msg.sender == owner, \"Only the minter can set a new one\");\r\n        require(_minter != address(0), \"The new minter must be a valid address\");\r\n\r\n        minter = _minter;\r\n    }\r\n\r\n    // @dev the intention is to set the owner as the DX-proxy, once it is deployed\r\n    // Then only an update of the DX-proxy contract after a 30 days delay could change the minter again.\r\n    function updateOwner(address _owner) public {\r\n        require(msg.sender == owner, \"Only the owner can update the owner\");\r\n        require(_owner != address(0), \"The new owner must be a valid address\");\r\n        owner = _owner;\r\n    }\r\n\r\n    function mintTokens(address user, uint amount) public {\r\n        require(msg.sender == minter, \"Only the minter can mint tokens\");\r\n\r\n        lockedTokenBalances[user] = add(lockedTokenBalances[user], amount);\r\n        totalTokens = add(totalTokens, amount);\r\n    }\r\n\r\n    /// @dev Lock Token\r\n    function lockTokens(uint amount) public returns (uint totalAmountLocked) {\r\n        // Adjust amount by balance\r\n        uint actualAmount = min(amount, balances[msg.sender]);\r\n\r\n        // Update state variables\r\n        balances[msg.sender] = sub(balances[msg.sender], actualAmount);\r\n        lockedTokenBalances[msg.sender] = add(lockedTokenBalances[msg.sender], actualAmount);\r\n\r\n        // Get return variable\r\n        totalAmountLocked = lockedTokenBalances[msg.sender];\r\n    }\r\n\r\n    function unlockTokens() public returns (uint totalAmountUnlocked, uint withdrawalTime) {\r\n        // Adjust amount by locked balances\r\n        uint amount = lockedTokenBalances[msg.sender];\r\n\r\n        if (amount > 0) {\r\n            // Update state variables\r\n            lockedTokenBalances[msg.sender] = sub(lockedTokenBalances[msg.sender], amount);\r\n            unlockedTokens[msg.sender].amountUnlocked = add(unlockedTokens[msg.sender].amountUnlocked, amount);\r\n            unlockedTokens[msg.sender].withdrawalTime = now + 24 hours;\r\n        }\r\n\r\n        // Get return variables\r\n        totalAmountUnlocked = unlockedTokens[msg.sender].amountUnlocked;\r\n        withdrawalTime = unlockedTokens[msg.sender].withdrawalTime;\r\n    }\r\n\r\n    function withdrawUnlockedTokens() public {\r\n        require(unlockedTokens[msg.sender].withdrawalTime < now, \"The tokens cannot be withdrawn yet\");\r\n        balances[msg.sender] = add(balances[msg.sender], unlockedTokens[msg.sender].amountUnlocked);\r\n        unlockedTokens[msg.sender].amountUnlocked = 0;\r\n    }\r\n\r\n    function min(uint a, uint b) public pure returns (uint) {\r\n        if (a < b) {\r\n            return a;\r\n        } else {\r\n            return b;\r\n        }\r\n    }\r\n    \r\n    /// @dev Returns whether an add operation causes an overflow\r\n    /// @param a First addend\r\n    /// @param b Second addend\r\n    /// @return Did no overflow occur?\r\n    function safeToAdd(uint a, uint b) public pure returns (bool) {\r\n        return a + b >= a;\r\n    }\r\n\r\n    /// @dev Returns whether a subtraction operation causes an underflow\r\n    /// @param a Minuend\r\n    /// @param b Subtrahend\r\n    /// @return Did no underflow occur?\r\n    function safeToSub(uint a, uint b) public pure returns (bool) {\r\n        return a >= b;\r\n    }\r\n\r\n    /// @dev Returns sum if no overflow occurred\r\n    /// @param a First addend\r\n    /// @param b Second addend\r\n    /// @return Sum\r\n    function add(uint a, uint b) public pure returns (uint) {\r\n        require(safeToAdd(a, b), \"It must be a safe adition\");\r\n        return a + b;\r\n    }\r\n\r\n    /// @dev Returns difference if no overflow occurred\r\n    /// @param a Minuend\r\n    /// @param b Subtrahend\r\n    /// @return Difference\r\n    function sub(uint a, uint b) public pure returns (uint) {\r\n        require(safeToSub(a, b), \"It must be a safe substraction\");\r\n        return a - b;\r\n    }\r\n}\r\n\r\n// File: @gnosis.pm/owl-token/contracts/TokenOWL.sol\r\n\r\ncontract TokenOWL is Proxied, GnosisStandardToken {\r\n    using GnosisMath for *;\r\n\r\n    string public constant name = \"OWL Token\";\r\n    string public constant symbol = \"OWL\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    struct masterCopyCountdownType {\r\n        address masterCopy;\r\n        uint timeWhenAvailable;\r\n    }\r\n\r\n    masterCopyCountdownType masterCopyCountdown;\r\n\r\n    address public creator;\r\n    address public minter;\r\n\r\n    event Minted(address indexed to, uint256 amount);\r\n    event Burnt(address indexed from, address indexed user, uint256 amount);\r\n\r\n    modifier onlyCreator() {\r\n        // R1\r\n        require(msg.sender == creator, \"Only the creator can perform the transaction\");\r\n        _;\r\n    }\r\n    /// @dev trickers the update process via the proxyMaster for a new address _masterCopy\r\n    /// updating is only possible after 30 days\r\n    function startMasterCopyCountdown(address _masterCopy) public onlyCreator {\r\n        require(address(_masterCopy) != address(0), \"The master copy must be a valid address\");\r\n\r\n        // Update masterCopyCountdown\r\n        masterCopyCountdown.masterCopy = _masterCopy;\r\n        masterCopyCountdown.timeWhenAvailable = now + 30 days;\r\n    }\r\n\r\n    /// @dev executes the update process via the proxyMaster for a new address _masterCopy\r\n    function updateMasterCopy() public onlyCreator {\r\n        require(address(masterCopyCountdown.masterCopy) != address(0), \"The master copy must be a valid address\");\r\n        require(\r\n            block.timestamp >= masterCopyCountdown.timeWhenAvailable,\r\n            \"It's not possible to update the master copy during the waiting period\"\r\n        );\r\n\r\n        // Update masterCopy\r\n        masterCopy = masterCopyCountdown.masterCopy;\r\n    }\r\n\r\n    function getMasterCopy() public view returns (address) {\r\n        return masterCopy;\r\n    }\r\n\r\n    /// @dev Set minter. Only the creator of this contract can call this.\r\n    /// @param newMinter The new address authorized to mint this token\r\n    function setMinter(address newMinter) public onlyCreator {\r\n        minter = newMinter;\r\n    }\r\n\r\n    /// @dev change owner/creator of the contract. Only the creator/owner of this contract can call this.\r\n    /// @param newOwner The new address, which should become the owner\r\n    function setNewOwner(address newOwner) public onlyCreator {\r\n        creator = newOwner;\r\n    }\r\n\r\n    /// @dev Mints OWL.\r\n    /// @param to Address to which the minted token will be given\r\n    /// @param amount Amount of OWL to be minted\r\n    function mintOWL(address to, uint amount) public {\r\n        require(minter != address(0), \"The minter must be initialized\");\r\n        require(msg.sender == minter, \"Only the minter can mint OWL\");\r\n        balances[to] = balances[to].add(amount);\r\n        totalTokens = totalTokens.add(amount);\r\n        emit Minted(to, amount);\r\n    }\r\n\r\n    /// @dev Burns OWL.\r\n    /// @param user Address of OWL owner\r\n    /// @param amount Amount of OWL to be burnt\r\n    function burnOWL(address user, uint amount) public {\r\n        allowances[user][msg.sender] = allowances[user][msg.sender].sub(amount);\r\n        balances[user] = balances[user].sub(amount);\r\n        totalTokens = totalTokens.sub(amount);\r\n        emit Burnt(msg.sender, user, amount);\r\n    }\r\n}\r\n\r\n// File: contracts/base/SafeTransfer.sol\r\n\r\ninterface BadToken {\r\n    function transfer(address to, uint value) external;\r\n    function transferFrom(address from, address to, uint value) external;\r\n}\r\n\r\ncontract SafeTransfer {\r\n    function safeTransfer(address token, address to, uint value, bool from) internal returns (bool result) {\r\n        if (from) {\r\n            BadToken(token).transferFrom(msg.sender, address(this), value);\r\n        } else {\r\n            BadToken(token).transfer(to, value);\r\n        }\r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            switch returndatasize\r\n                case 0 {\r\n                    // This is our BadToken\r\n                    result := not(0) // result is true\r\n                }\r\n                case 32 {\r\n                    // This is our GoodToken\r\n                    returndatacopy(0, 0, 32)\r\n                    result := mload(0) // result == returndata of external call\r\n                }\r\n                default {\r\n                    // This is not an ERC20 token\r\n                    result := 0\r\n                }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n// File: contracts/base/AuctioneerManaged.sol\r\n\r\ncontract AuctioneerManaged {\r\n    // auctioneer has the power to manage some variables\r\n    address public auctioneer;\r\n\r\n    function updateAuctioneer(address _auctioneer) public onlyAuctioneer {\r\n        require(_auctioneer != address(0), \"The auctioneer must be a valid address\");\r\n        auctioneer = _auctioneer;\r\n    }\r\n\r\n    // > Modifiers\r\n    modifier onlyAuctioneer() {\r\n        // Only allows auctioneer to proceed\r\n        // R1\r\n        // require(msg.sender == auctioneer, \"Only auctioneer can perform this operation\");\r\n        require(msg.sender == auctioneer, \"Only the auctioneer can nominate a new one\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/base/TokenWhitelist.sol\r\n\r\ncontract TokenWhitelist is AuctioneerManaged {\r\n    // Mapping that stores the tokens, which are approved\r\n    // Only tokens approved by auctioneer generate frtToken tokens\r\n    // addressToken => boolApproved\r\n    mapping(address => bool) public approvedTokens;\r\n\r\n    event Approval(address indexed token, bool approved);\r\n\r\n    /// @dev for quick overview of approved Tokens\r\n    /// @param addressesToCheck are the ERC-20 token addresses to be checked whether they are approved\r\n    function getApprovedAddressesOfList(address[] calldata addressesToCheck) external view returns (bool[] memory) {\r\n        uint length = addressesToCheck.length;\r\n\r\n        bool[] memory isApproved = new bool[](length);\r\n\r\n        for (uint i = 0; i < length; i++) {\r\n            isApproved[i] = approvedTokens[addressesToCheck[i]];\r\n        }\r\n\r\n        return isApproved;\r\n    }\r\n    \r\n    function updateApprovalOfToken(address[] memory token, bool approved) public onlyAuctioneer {\r\n        for (uint i = 0; i < token.length; i++) {\r\n            approvedTokens[token[i]] = approved;\r\n            emit Approval(token[i], approved);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/base/DxMath.sol\r\n\r\ncontract DxMath {\r\n    // > Math fns\r\n    function min(uint a, uint b) public pure returns (uint) {\r\n        if (a < b) {\r\n            return a;\r\n        } else {\r\n            return b;\r\n        }\r\n    }\r\n\r\n    function atleastZero(int a) public pure returns (uint) {\r\n        if (a < 0) {\r\n            return 0;\r\n        } else {\r\n            return uint(a);\r\n        }\r\n    }\r\n    \r\n    /// @dev Returns whether an add operation causes an overflow\r\n    /// @param a First addend\r\n    /// @param b Second addend\r\n    /// @return Did no overflow occur?\r\n    function safeToAdd(uint a, uint b) public pure returns (bool) {\r\n        return a + b >= a;\r\n    }\r\n\r\n    /// @dev Returns whether a subtraction operation causes an underflow\r\n    /// @param a Minuend\r\n    /// @param b Subtrahend\r\n    /// @return Did no underflow occur?\r\n    function safeToSub(uint a, uint b) public pure returns (bool) {\r\n        return a >= b;\r\n    }\r\n\r\n    /// @dev Returns whether a multiply operation causes an overflow\r\n    /// @param a First factor\r\n    /// @param b Second factor\r\n    /// @return Did no overflow occur?\r\n    function safeToMul(uint a, uint b) public pure returns (bool) {\r\n        return b == 0 || a * b / b == a;\r\n    }\r\n\r\n    /// @dev Returns sum if no overflow occurred\r\n    /// @param a First addend\r\n    /// @param b Second addend\r\n    /// @return Sum\r\n    function add(uint a, uint b) public pure returns (uint) {\r\n        require(safeToAdd(a, b));\r\n        return a + b;\r\n    }\r\n\r\n    /// @dev Returns difference if no overflow occurred\r\n    /// @param a Minuend\r\n    /// @param b Subtrahend\r\n    /// @return Difference\r\n    function sub(uint a, uint b) public pure returns (uint) {\r\n        require(safeToSub(a, b));\r\n        return a - b;\r\n    }\r\n\r\n    /// @dev Returns product if no overflow occurred\r\n    /// @param a First factor\r\n    /// @param b Second factor\r\n    /// @return Product\r\n    function mul(uint a, uint b) public pure returns (uint) {\r\n        require(safeToMul(a, b));\r\n        return a * b;\r\n    }\r\n}\r\n\r\n// File: contracts/Oracle/DSMath.sol\r\n\r\ncontract DSMath {\r\n    /*\r\n    standard uint256 functions\r\n     */\r\n\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        assert((z = x + y) >= x);\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        assert((z = x - y) <= x);\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        assert((z = x * y) >= x);\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x / y;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    /*\r\n    uint128 functions (h is for half)\r\n     */\r\n\r\n    function hadd(uint128 x, uint128 y) internal pure returns (uint128 z) {\r\n        assert((z = x + y) >= x);\r\n    }\r\n\r\n    function hsub(uint128 x, uint128 y) internal pure returns (uint128 z) {\r\n        assert((z = x - y) <= x);\r\n    }\r\n\r\n    function hmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\r\n        assert((z = x * y) >= x);\r\n    }\r\n\r\n    function hdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\r\n        z = x / y;\r\n    }\r\n\r\n    function hmin(uint128 x, uint128 y) internal pure returns (uint128 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function hmax(uint128 x, uint128 y) internal pure returns (uint128 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    /*\r\n    int256 functions\r\n     */\r\n\r\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    /*\r\n    WAD math\r\n     */\r\n\r\n    uint128 constant WAD = 10 ** 18;\r\n\r\n    function wadd(uint128 x, uint128 y) internal pure returns (uint128) {\r\n        return hadd(x, y);\r\n    }\r\n\r\n    function wsub(uint128 x, uint128 y) internal pure returns (uint128) {\r\n        return hsub(x, y);\r\n    }\r\n\r\n    function wmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\r\n        z = cast((uint256(x) * y + WAD / 2) / WAD);\r\n    }\r\n\r\n    function wdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\r\n        z = cast((uint256(x) * WAD + y / 2) / y);\r\n    }\r\n\r\n    function wmin(uint128 x, uint128 y) internal pure returns (uint128) {\r\n        return hmin(x, y);\r\n    }\r\n\r\n    function wmax(uint128 x, uint128 y) internal pure returns (uint128) {\r\n        return hmax(x, y);\r\n    }\r\n\r\n    /*\r\n    RAY math\r\n     */\r\n\r\n    uint128 constant RAY = 10 ** 27;\r\n\r\n    function radd(uint128 x, uint128 y) internal pure returns (uint128) {\r\n        return hadd(x, y);\r\n    }\r\n\r\n    function rsub(uint128 x, uint128 y) internal pure returns (uint128) {\r\n        return hsub(x, y);\r\n    }\r\n\r\n    function rmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\r\n        z = cast((uint256(x) * y + RAY / 2) / RAY);\r\n    }\r\n\r\n    function rdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\r\n        z = cast((uint256(x) * RAY + y / 2) / y);\r\n    }\r\n\r\n    function rpow(uint128 x, uint64 n) internal pure returns (uint128 z) {\r\n        // This famous algorithm is called \"exponentiation by squaring\"\r\n        // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n        //\r\n        // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n        //\r\n        // These facts are why it works:\r\n        //\r\n        //  If n is even, then x^n = (x^2)^(n/2).\r\n        //  If n is odd,  then x^n = x * x^(n-1),\r\n        //   and applying the equation for even x gives\r\n        //    x^n = x * (x^2)^((n-1) / 2).\r\n        //\r\n        //  Also, EVM division is flooring and\r\n        //    floor[(n-1) / 2] = floor[n / 2].\r\n\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n\r\n    function rmin(uint128 x, uint128 y) internal pure returns (uint128) {\r\n        return hmin(x, y);\r\n    }\r\n\r\n    function rmax(uint128 x, uint128 y) internal pure returns (uint128) {\r\n        return hmax(x, y);\r\n    }\r\n\r\n    function cast(uint256 x) internal pure returns (uint128 z) {\r\n        assert((z = uint128(x)) == x);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/Oracle/DSAuth.sol\r\n\r\ncontract DSAuthority {\r\n    function canCall(address src, address dst, bytes4 sig) public view returns (bool);\r\n}\r\n\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority(address indexed authority);\r\n    event LogSetOwner(address indexed owner);\r\n}\r\n\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority public authority;\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_) public auth {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_) public auth {\r\n        authority = authority_;\r\n        emit LogSetAuthority(address(authority));\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig), \"It must be an authorized call\");\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, address(this), sig);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Oracle/DSNote.sol\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4 indexed sig,\r\n        address indexed guy,\r\n        bytes32 indexed foo,\r\n        bytes32 bar,\r\n        uint wad,\r\n        bytes fax\r\n    );\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n        }\r\n\r\n        emit LogNote(\r\n            msg.sig,\r\n            msg.sender,\r\n            foo,\r\n            bar,\r\n            msg.value,\r\n            msg.data\r\n        );\r\n\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/Oracle/DSThing.sol\r\n\r\ncontract DSThing is DSAuth, DSNote, DSMath {}\r\n\r\n// File: contracts/Oracle/PriceFeed.sol\r\n\r\n/// price-feed.sol\r\n\r\n// Copyright (C) 2017  DappHub, LLC\r\n\r\n// Licensed under the Apache License, Version 2.0 (the \"License\").\r\n// You may not use this file except in compliance with the License.\r\n\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\r\n\r\n\r\n\r\ncontract PriceFeed is DSThing {\r\n    uint128 val;\r\n    uint32 public zzz;\r\n\r\n    function peek() public view returns (bytes32, bool) {\r\n        return (bytes32(uint256(val)), block.timestamp < zzz);\r\n    }\r\n\r\n    function read() public view returns (bytes32) {\r\n        assert(block.timestamp < zzz);\r\n        return bytes32(uint256(val));\r\n    }\r\n\r\n    function post(uint128 val_, uint32 zzz_, address med_) public payable note auth {\r\n        val = val_;\r\n        zzz = zzz_;\r\n        (bool success, ) = med_.call(abi.encodeWithSignature(\"poke()\"));\r\n        require(success, \"The poke must succeed\");\r\n    }\r\n\r\n    function void() public payable note auth {\r\n        zzz = 0;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/Oracle/DSValue.sol\r\n\r\ncontract DSValue is DSThing {\r\n    bool has;\r\n    bytes32 val;\r\n    function peek() public view returns (bytes32, bool) {\r\n        return (val, has);\r\n    }\r\n\r\n    function read() public view returns (bytes32) {\r\n        (bytes32 wut, bool _has) = peek();\r\n        assert(_has);\r\n        return wut;\r\n    }\r\n\r\n    function poke(bytes32 wut) public payable note auth {\r\n        val = wut;\r\n        has = true;\r\n    }\r\n\r\n    function void() public payable note auth {\r\n        // unset the value\r\n        has = false;\r\n    }\r\n}\r\n\r\n// File: contracts/Oracle/Medianizer.sol\r\n\r\ncontract Medianizer is DSValue {\r\n    mapping(bytes12 => address) public values;\r\n    mapping(address => bytes12) public indexes;\r\n    bytes12 public next = bytes12(uint96(1));\r\n    uint96 public minimun = 0x1;\r\n\r\n    function set(address wat) public auth {\r\n        bytes12 nextId = bytes12(uint96(next) + 1);\r\n        assert(nextId != 0x0);\r\n        set(next, wat);\r\n        next = nextId;\r\n    }\r\n\r\n    function set(bytes12 pos, address wat) public payable note auth {\r\n        require(pos != 0x0, \"pos cannot be 0x0\");\r\n        require(wat == address(0) || indexes[wat] == 0, \"wat is not defined or it has an index\");\r\n\r\n        indexes[values[pos]] = bytes12(0); // Making sure to remove a possible existing address in that position\r\n\r\n        if (wat != address(0)) {\r\n            indexes[wat] = pos;\r\n        }\r\n\r\n        values[pos] = wat;\r\n    }\r\n\r\n    function setMin(uint96 min_) public payable note auth {\r\n        require(min_ != 0x0, \"min cannot be 0x0\");\r\n        minimun = min_;\r\n    }\r\n\r\n    function setNext(bytes12 next_) public payable note auth {\r\n        require(next_ != 0x0, \"next cannot be 0x0\");\r\n        next = next_;\r\n    }\r\n\r\n    function unset(bytes12 pos) public {\r\n        set(pos, address(0));\r\n    }\r\n\r\n    function unset(address wat) public {\r\n        set(indexes[wat], address(0));\r\n    }\r\n\r\n    function poke() public {\r\n        poke(0);\r\n    }\r\n\r\n    function poke(bytes32) public payable note {\r\n        (val, has) = compute();\r\n    }\r\n\r\n    function compute() public view returns (bytes32, bool) {\r\n        bytes32[] memory wuts = new bytes32[](uint96(next) - 1);\r\n        uint96 ctr = 0;\r\n        for (uint96 i = 1; i < uint96(next); i++) {\r\n            if (values[bytes12(i)] != address(0)) {\r\n                (bytes32 wut, bool wuz) = DSValue(values[bytes12(i)]).peek();\r\n                if (wuz) {\r\n                    if (ctr == 0 || wut >= wuts[ctr - 1]) {\r\n                        wuts[ctr] = wut;\r\n                    } else {\r\n                        uint96 j = 0;\r\n                        while (wut >= wuts[j]) {\r\n                            j++;\r\n                        }\r\n                        for (uint96 k = ctr; k > j; k--) {\r\n                            wuts[k] = wuts[k - 1];\r\n                        }\r\n                        wuts[j] = wut;\r\n                    }\r\n                    ctr++;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (ctr < minimun)\r\n            return (val, false);\r\n\r\n        bytes32 value;\r\n        if (ctr % 2 == 0) {\r\n            uint128 val1 = uint128(uint(wuts[(ctr / 2) - 1]));\r\n            uint128 val2 = uint128(uint(wuts[ctr / 2]));\r\n            value = bytes32(uint256(wdiv(hadd(val1, val2), 2 ether)));\r\n        } else {\r\n            value = wuts[(ctr - 1) / 2];\r\n        }\r\n\r\n        return (value, true);\r\n    }\r\n}\r\n\r\n// File: contracts/Oracle/PriceOracleInterface.sol\r\n\r\n/*\r\nThis contract is the interface between the MakerDAO priceFeed and our DX platform.\r\n*/\r\n\r\n\r\n\r\n\r\ncontract PriceOracleInterface {\r\n    address public priceFeedSource;\r\n    address public owner;\r\n    bool public emergencyMode;\r\n\r\n    // Modifiers\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only the owner can do the operation\");\r\n        _;\r\n    }\r\n\r\n    /// @dev constructor of the contract\r\n    /// @param _priceFeedSource address of price Feed Source -> should be maker feeds Medianizer contract\r\n    constructor(address _owner, address _priceFeedSource) public {\r\n        owner = _owner;\r\n        priceFeedSource = _priceFeedSource;\r\n    }\r\n    \r\n    /// @dev gives the owner the possibility to put the Interface into an emergencyMode, which will\r\n    /// output always a price of 600 USD. This gives everyone time to set up a new pricefeed.\r\n    function raiseEmergency(bool _emergencyMode) public onlyOwner {\r\n        emergencyMode = _emergencyMode;\r\n    }\r\n\r\n    /// @dev updates the priceFeedSource\r\n    /// @param _owner address of owner\r\n    function updateCurator(address _owner) public onlyOwner {\r\n        owner = _owner;\r\n    }\r\n\r\n    /// @dev returns the USDETH price\r\n    function getUsdEthPricePeek() public view returns (bytes32 price, bool valid) {\r\n        return Medianizer(priceFeedSource).peek();\r\n    }\r\n\r\n    /// @dev returns the USDETH price, ie gets the USD price from Maker feed with 18 digits, but last 18 digits are cut off\r\n    function getUSDETHPrice() public view returns (uint256) {\r\n        // if the contract is in the emergencyMode, because there is an issue with the oracle, we will simply return a price of 600 USD\r\n        if (emergencyMode) {\r\n            return 600;\r\n        }\r\n        (bytes32 price, ) = Medianizer(priceFeedSource).peek();\r\n\r\n        // ensuring that there is no underflow or overflow possible,\r\n        // even if the price is compromised\r\n        uint priceUint = uint256(price)/(1 ether);\r\n        if (priceUint == 0) {\r\n            return 1;\r\n        }\r\n        if (priceUint > 1000000) {\r\n            return 1000000; \r\n        }\r\n        return priceUint;\r\n    }\r\n}\r\n\r\n// File: contracts/base/EthOracle.sol\r\n\r\ncontract EthOracle is AuctioneerManaged, DxMath {\r\n    uint constant WAITING_PERIOD_CHANGE_ORACLE = 30 days;\r\n\r\n    // Price Oracle interface\r\n    PriceOracleInterface public ethUSDOracle;\r\n    // Price Oracle interface proposals during update process\r\n    PriceOracleInterface public newProposalEthUSDOracle;\r\n\r\n    uint public oracleInterfaceCountdown;\r\n\r\n    event NewOracleProposal(PriceOracleInterface priceOracleInterface);\r\n\r\n    function initiateEthUsdOracleUpdate(PriceOracleInterface _ethUSDOracle) public onlyAuctioneer {\r\n        require(address(_ethUSDOracle) != address(0), \"The oracle address must be valid\");\r\n        newProposalEthUSDOracle = _ethUSDOracle;\r\n        oracleInterfaceCountdown = add(block.timestamp, WAITING_PERIOD_CHANGE_ORACLE);\r\n        emit NewOracleProposal(_ethUSDOracle);\r\n    }\r\n\r\n    function updateEthUSDOracle() public {\r\n        require(address(newProposalEthUSDOracle) != address(0), \"The new proposal must be a valid addres\");\r\n        require(\r\n            oracleInterfaceCountdown < block.timestamp,\r\n            \"It's not possible to update the oracle during the waiting period\"\r\n        );\r\n        ethUSDOracle = newProposalEthUSDOracle;\r\n        newProposalEthUSDOracle = PriceOracleInterface(0);\r\n    }\r\n}\r\n\r\n// File: contracts/base/DxUpgrade.sol\r\n\r\ncontract DxUpgrade is Proxied, AuctioneerManaged, DxMath {\r\n    uint constant WAITING_PERIOD_CHANGE_MASTERCOPY = 30 days;\r\n\r\n    address public newMasterCopy;\r\n    // Time when new masterCopy is updatabale\r\n    uint public masterCopyCountdown;\r\n\r\n    event NewMasterCopyProposal(address newMasterCopy);\r\n\r\n    function startMasterCopyCountdown(address _masterCopy) public onlyAuctioneer {\r\n        require(_masterCopy != address(0), \"The new master copy must be a valid address\");\r\n\r\n        // Update masterCopyCountdown\r\n        newMasterCopy = _masterCopy;\r\n        masterCopyCountdown = add(block.timestamp, WAITING_PERIOD_CHANGE_MASTERCOPY);\r\n        emit NewMasterCopyProposal(_masterCopy);\r\n    }\r\n\r\n    function updateMasterCopy() public {\r\n        require(newMasterCopy != address(0), \"The new master copy must be a valid address\");\r\n        require(block.timestamp >= masterCopyCountdown, \"The master contract cannot be updated in a waiting period\");\r\n\r\n        // Update masterCopy\r\n        masterCopy = newMasterCopy;\r\n        newMasterCopy = address(0);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/DutchExchange.sol\r\n\r\n/// @title Dutch Exchange - exchange token pairs with the clever mechanism of the dutch auction\r\n/// @author Alex Herrmann - <alex@gnosis.pm>\r\n/// @author Dominik Teiml - <dominik@gnosis.pm>\r\n\r\ncontract DutchExchange is DxUpgrade, TokenWhitelist, EthOracle, SafeTransfer {\r\n\r\n    // The price is a rational number, so we need a concept of a fraction\r\n    struct Fraction {\r\n        uint num;\r\n        uint den;\r\n    }\r\n\r\n    uint constant WAITING_PERIOD_NEW_TOKEN_PAIR = 6 hours;\r\n    uint constant WAITING_PERIOD_NEW_AUCTION = 10 minutes;\r\n    uint constant AUCTION_START_WAITING_FOR_FUNDING = 1;\r\n\r\n    // > Storage\r\n    // Ether ERC-20 token\r\n    address public ethToken;\r\n\r\n    // Minimum required sell funding for adding a new token pair, in USD\r\n    uint public thresholdNewTokenPair;\r\n    // Minimum required sell funding for starting antoher auction, in USD\r\n    uint public thresholdNewAuction;\r\n    // Fee reduction token (magnolia, ERC-20 token)\r\n    TokenFRT public frtToken;\r\n    // Token for paying fees\r\n    TokenOWL public owlToken;\r\n\r\n    // For the following three mappings, there is one mapping for each token pair\r\n    // The order which the tokens should be called is smaller, larger\r\n    // These variables should never be called directly! They have getters below\r\n    // Token => Token => index\r\n    mapping(address => mapping(address => uint)) public latestAuctionIndices;\r\n    // Token => Token => time\r\n    mapping (address => mapping (address => uint)) public auctionStarts;\r\n    // Token => Token => auctionIndex => time\r\n    mapping (address => mapping (address => mapping (uint => uint))) public clearingTimes;\r\n\r\n    // Token => Token => auctionIndex => price\r\n    mapping(address => mapping(address => mapping(uint => Fraction))) public closingPrices;\r\n\r\n    // Token => Token => amount\r\n    mapping(address => mapping(address => uint)) public sellVolumesCurrent;\r\n    // Token => Token => amount\r\n    mapping(address => mapping(address => uint)) public sellVolumesNext;\r\n    // Token => Token => amount\r\n    mapping(address => mapping(address => uint)) public buyVolumes;\r\n\r\n    // Token => user => amount\r\n    // balances stores a user's balance in the DutchX\r\n    mapping(address => mapping(address => uint)) public balances;\r\n\r\n    // Token => Token => auctionIndex => amount\r\n    mapping(address => mapping(address => mapping(uint => uint))) public extraTokens;\r\n\r\n    // Token => Token =>  auctionIndex => user => amount\r\n    mapping(address => mapping(address => mapping(uint => mapping(address => uint)))) public sellerBalances;\r\n    mapping(address => mapping(address => mapping(uint => mapping(address => uint)))) public buyerBalances;\r\n    mapping(address => mapping(address => mapping(uint => mapping(address => uint)))) public claimedAmounts;\r\n\r\n    function depositAndSell(address sellToken, address buyToken, uint amount)\r\n        external\r\n        returns (uint newBal, uint auctionIndex, uint newSellerBal)\r\n    {\r\n        newBal = deposit(sellToken, amount);\r\n        (auctionIndex, newSellerBal) = postSellOrder(sellToken, buyToken, 0, amount);\r\n    }\r\n\r\n    function claimAndWithdraw(address sellToken, address buyToken, address user, uint auctionIndex, uint amount)\r\n        external\r\n        returns (uint returned, uint frtsIssued, uint newBal)\r\n    {\r\n        (returned, frtsIssued) = claimSellerFunds(sellToken, buyToken, user, auctionIndex);\r\n        newBal = withdraw(buyToken, amount);\r\n    }\r\n\r\n    /// @dev for multiple claims\r\n    /// @param auctionSellTokens are the sellTokens defining an auctionPair\r\n    /// @param auctionBuyTokens are the buyTokens defining an auctionPair\r\n    /// @param auctionIndices are the auction indices on which an token should be claimedAmounts\r\n    /// @param user is the user who wants to his tokens\r\n    function claimTokensFromSeveralAuctionsAsSeller(\r\n        address[] calldata auctionSellTokens,\r\n        address[] calldata auctionBuyTokens,\r\n        uint[] calldata auctionIndices,\r\n        address user\r\n    ) external returns (uint[] memory, uint[] memory)\r\n    {\r\n        uint length = checkLengthsForSeveralAuctionClaiming(auctionSellTokens, auctionBuyTokens, auctionIndices);\r\n\r\n        uint[] memory claimAmounts = new uint[](length);\r\n        uint[] memory frtsIssuedList = new uint[](length);\r\n\r\n        for (uint i = 0; i < length; i++) {\r\n            (claimAmounts[i], frtsIssuedList[i]) = claimSellerFunds(\r\n                auctionSellTokens[i],\r\n                auctionBuyTokens[i],\r\n                user,\r\n                auctionIndices[i]\r\n            );\r\n        }\r\n\r\n        return (claimAmounts, frtsIssuedList);\r\n    }\r\n\r\n    /// @dev for multiple claims\r\n    /// @param auctionSellTokens are the sellTokens defining an auctionPair\r\n    /// @param auctionBuyTokens are the buyTokens defining an auctionPair\r\n    /// @param auctionIndices are the auction indices on which an token should be claimedAmounts\r\n    /// @param user is the user who wants to his tokens\r\n    function claimTokensFromSeveralAuctionsAsBuyer(\r\n        address[] calldata auctionSellTokens,\r\n        address[] calldata auctionBuyTokens,\r\n        uint[] calldata auctionIndices,\r\n        address user\r\n    ) external returns (uint[] memory, uint[] memory)\r\n    {\r\n        uint length = checkLengthsForSeveralAuctionClaiming(auctionSellTokens, auctionBuyTokens, auctionIndices);\r\n\r\n        uint[] memory claimAmounts = new uint[](length);\r\n        uint[] memory frtsIssuedList = new uint[](length);\r\n\r\n        for (uint i = 0; i < length; i++) {\r\n            (claimAmounts[i], frtsIssuedList[i]) = claimBuyerFunds(\r\n                auctionSellTokens[i],\r\n                auctionBuyTokens[i],\r\n                user,\r\n                auctionIndices[i]\r\n            );\r\n        }\r\n\r\n        return (claimAmounts, frtsIssuedList);\r\n    }\r\n\r\n    /// @dev for multiple withdraws\r\n    /// @param auctionSellTokens are the sellTokens defining an auctionPair\r\n    /// @param auctionBuyTokens are the buyTokens defining an auctionPair\r\n    /// @param auctionIndices are the auction indices on which an token should be claimedAmounts\r\n    function claimAndWithdrawTokensFromSeveralAuctionsAsSeller(\r\n        address[] calldata auctionSellTokens,\r\n        address[] calldata auctionBuyTokens,\r\n        uint[] calldata auctionIndices\r\n    ) external returns (uint[] memory, uint frtsIssued)\r\n    {\r\n        uint length = checkLengthsForSeveralAuctionClaiming(auctionSellTokens, auctionBuyTokens, auctionIndices);\r\n\r\n        uint[] memory claimAmounts = new uint[](length);\r\n        uint claimFrts = 0;\r\n\r\n        for (uint i = 0; i < length; i++) {\r\n            (claimAmounts[i], claimFrts) = claimSellerFunds(\r\n                auctionSellTokens[i],\r\n                auctionBuyTokens[i],\r\n                msg.sender,\r\n                auctionIndices[i]\r\n            );\r\n\r\n            frtsIssued += claimFrts;\r\n\r\n            withdraw(auctionBuyTokens[i], claimAmounts[i]);\r\n        }\r\n\r\n        return (claimAmounts, frtsIssued);\r\n    }\r\n\r\n    /// @dev for multiple withdraws\r\n    /// @param auctionSellTokens are the sellTokens defining an auctionPair\r\n    /// @param auctionBuyTokens are the buyTokens defining an auctionPair\r\n    /// @param auctionIndices are the auction indices on which an token should be claimedAmounts\r\n    function claimAndWithdrawTokensFromSeveralAuctionsAsBuyer(\r\n        address[] calldata auctionSellTokens,\r\n        address[] calldata auctionBuyTokens,\r\n        uint[] calldata auctionIndices\r\n    ) external returns (uint[] memory, uint frtsIssued)\r\n    {\r\n        uint length = checkLengthsForSeveralAuctionClaiming(auctionSellTokens, auctionBuyTokens, auctionIndices);\r\n\r\n        uint[] memory claimAmounts = new uint[](length);\r\n        uint claimFrts = 0;\r\n\r\n        for (uint i = 0; i < length; i++) {\r\n            (claimAmounts[i], claimFrts) = claimBuyerFunds(\r\n                auctionSellTokens[i],\r\n                auctionBuyTokens[i],\r\n                msg.sender,\r\n                auctionIndices[i]\r\n            );\r\n\r\n            frtsIssued += claimFrts;\r\n\r\n            withdraw(auctionSellTokens[i], claimAmounts[i]);\r\n        }\r\n\r\n        return (claimAmounts, frtsIssued);\r\n    }\r\n\r\n    function getMasterCopy() external view returns (address) {\r\n        return masterCopy;\r\n    }\r\n\r\n    /// @dev Constructor-Function creates exchange\r\n    /// @param _frtToken - address of frtToken ERC-20 token\r\n    /// @param _owlToken - address of owlToken ERC-20 token\r\n    /// @param _auctioneer - auctioneer for managing interfaces\r\n    /// @param _ethToken - address of ETH ERC-20 token\r\n    /// @param _ethUSDOracle - address of the oracle contract for fetching feeds\r\n    /// @param _thresholdNewTokenPair - Minimum required sell funding for adding a new token pair, in USD\r\n    function setupDutchExchange(\r\n        TokenFRT _frtToken,\r\n        TokenOWL _owlToken,\r\n        address _auctioneer,\r\n        address _ethToken,\r\n        PriceOracleInterface _ethUSDOracle,\r\n        uint _thresholdNewTokenPair,\r\n        uint _thresholdNewAuction\r\n    ) public\r\n    {\r\n        // Make sure contract hasn't been initialised\r\n        require(ethToken == address(0), \"The contract must be uninitialized\");\r\n\r\n        // Validates inputs\r\n        require(address(_owlToken) != address(0), \"The OWL address must be valid\");\r\n        require(address(_frtToken) != address(0), \"The FRT address must be valid\");\r\n        require(_auctioneer != address(0), \"The auctioneer address must be valid\");\r\n        require(_ethToken != address(0), \"The WETH address must be valid\");\r\n        require(address(_ethUSDOracle) != address(0), \"The oracle address must be valid\");\r\n\r\n        frtToken = _frtToken;\r\n        owlToken = _owlToken;\r\n        auctioneer = _auctioneer;\r\n        ethToken = _ethToken;\r\n        ethUSDOracle = _ethUSDOracle;\r\n        thresholdNewTokenPair = _thresholdNewTokenPair;\r\n        thresholdNewAuction = _thresholdNewAuction;\r\n    }\r\n\r\n    function updateThresholdNewTokenPair(uint _thresholdNewTokenPair) public onlyAuctioneer {\r\n        thresholdNewTokenPair = _thresholdNewTokenPair;\r\n    }\r\n\r\n    function updateThresholdNewAuction(uint _thresholdNewAuction) public onlyAuctioneer {\r\n        thresholdNewAuction = _thresholdNewAuction;\r\n    }\r\n\r\n    /// @param initialClosingPriceNum initial price will be 2 * initialClosingPrice. This is its numerator\r\n    /// @param initialClosingPriceDen initial price will be 2 * initialClosingPrice. This is its denominator\r\n    function addTokenPair(\r\n        address token1,\r\n        address token2,\r\n        uint token1Funding,\r\n        uint token2Funding,\r\n        uint initialClosingPriceNum,\r\n        uint initialClosingPriceDen\r\n    ) public\r\n    {\r\n        // R1\r\n        require(token1 != token2, \"You cannot add a token pair using the same token\");\r\n\r\n        // R2\r\n        require(initialClosingPriceNum != 0, \"You must set the numerator for the initial price\");\r\n\r\n        // R3\r\n        require(initialClosingPriceDen != 0, \"You must set the denominator for the initial price\");\r\n\r\n        // R4\r\n        require(getAuctionIndex(token1, token2) == 0, \"The token pair was already added\");\r\n\r\n        // R5: to prevent overflow\r\n        require(initialClosingPriceNum < 10 ** 18, \"You must set a smaller numerator for the initial price\");\r\n\r\n        // R6\r\n        require(initialClosingPriceDen < 10 ** 18, \"You must set a smaller denominator for the initial price\");\r\n\r\n        setAuctionIndex(token1, token2);\r\n\r\n        token1Funding = min(token1Funding, balances[token1][msg.sender]);\r\n        token2Funding = min(token2Funding, balances[token2][msg.sender]);\r\n\r\n        // R7\r\n        require(token1Funding < 10 ** 30, \"You should use a smaller funding for token 1\");\r\n\r\n        // R8\r\n        require(token2Funding < 10 ** 30, \"You should use a smaller funding for token 2\");\r\n\r\n        uint fundedValueUSD;\r\n        uint ethUSDPrice = ethUSDOracle.getUSDETHPrice();\r\n\r\n        // Compute fundedValueUSD\r\n        address ethTokenMem = ethToken;\r\n        if (token1 == ethTokenMem) {\r\n            // C1\r\n            // MUL: 10^30 * 10^6 = 10^36\r\n            fundedValueUSD = mul(token1Funding, ethUSDPrice);\r\n        } else if (token2 == ethTokenMem) {\r\n            // C2\r\n            // MUL: 10^30 * 10^6 = 10^36\r\n            fundedValueUSD = mul(token2Funding, ethUSDPrice);\r\n        } else {\r\n            // C3: Neither token is ethToken\r\n            fundedValueUSD = calculateFundedValueTokenToken(\r\n                token1,\r\n                token2,\r\n                token1Funding,\r\n                token2Funding,\r\n                ethTokenMem,\r\n                ethUSDPrice\r\n            );\r\n        }\r\n\r\n        // R5\r\n        require(fundedValueUSD >= thresholdNewTokenPair, \"You should surplus the threshold for adding token pairs\");\r\n\r\n        // Save prices of opposite auctions\r\n        closingPrices[token1][token2][0] = Fraction(initialClosingPriceNum, initialClosingPriceDen);\r\n        closingPrices[token2][token1][0] = Fraction(initialClosingPriceDen, initialClosingPriceNum);\r\n\r\n        // Split into two fns because of 16 local-var cap\r\n        addTokenPairSecondPart(token1, token2, token1Funding, token2Funding);\r\n    }\r\n\r\n    function deposit(address tokenAddress, uint amount) public returns (uint) {\r\n        // R1\r\n        require(safeTransfer(tokenAddress, msg.sender, amount, true), \"The deposit transaction must succeed\");\r\n\r\n        uint newBal = add(balances[tokenAddress][msg.sender], amount);\r\n\r\n        balances[tokenAddress][msg.sender] = newBal;\r\n\r\n        emit NewDeposit(tokenAddress, amount);\r\n\r\n        return newBal;\r\n    }\r\n\r\n    function withdraw(address tokenAddress, uint amount) public returns (uint) {\r\n        uint usersBalance = balances[tokenAddress][msg.sender];\r\n        amount = min(amount, usersBalance);\r\n\r\n        // R1\r\n        require(amount > 0, \"The amount must be greater than 0\");\r\n\r\n        uint newBal = sub(usersBalance, amount);\r\n        balances[tokenAddress][msg.sender] = newBal;\r\n\r\n        // R2\r\n        require(safeTransfer(tokenAddress, msg.sender, amount, false), \"The withdraw transfer must succeed\");\r\n        emit NewWithdrawal(tokenAddress, amount);\r\n\r\n        return newBal;\r\n    }\r\n\r\n    function postSellOrder(address sellToken, address buyToken, uint auctionIndex, uint amount)\r\n        public\r\n        returns (uint, uint)\r\n    {\r\n        // Note: if a user specifies auctionIndex of 0, it\r\n        // means he is agnostic which auction his sell order goes into\r\n\r\n        amount = min(amount, balances[sellToken][msg.sender]);\r\n\r\n        // R1\r\n        // require(amount >= 0, \"Sell amount should be greater than 0\");\r\n\r\n        // R2\r\n        uint latestAuctionIndex = getAuctionIndex(sellToken, buyToken);\r\n        require(latestAuctionIndex > 0);\r\n\r\n        // R3\r\n        uint auctionStart = getAuctionStart(sellToken, buyToken);\r\n        if (auctionStart == AUCTION_START_WAITING_FOR_FUNDING || auctionStart > now) {\r\n            // C1: We are in the 10 minute buffer period\r\n            // OR waiting for an auction to receive sufficient sellVolume\r\n            // Auction has already cleared, and index has been incremented\r\n            // sell order must use that auction index\r\n            // R1.1\r\n            if (auctionIndex == 0) {\r\n                auctionIndex = latestAuctionIndex;\r\n            } else {\r\n                require(auctionIndex == latestAuctionIndex, \"Auction index should be equal to latest auction index\");\r\n            }\r\n\r\n            // R1.2\r\n            require(add(sellVolumesCurrent[sellToken][buyToken], amount) < 10 ** 30);\r\n        } else {\r\n            // C2\r\n            // R2.1: Sell orders must go to next auction\r\n            if (auctionIndex == 0) {\r\n                auctionIndex = latestAuctionIndex + 1;\r\n            } else {\r\n                require(auctionIndex == latestAuctionIndex + 1);\r\n            }\r\n\r\n            // R2.2\r\n            require(add(sellVolumesNext[sellToken][buyToken], amount) < 10 ** 30);\r\n        }\r\n\r\n        // Fee mechanism, fees are added to extraTokens\r\n        uint amountAfterFee = settleFee(sellToken, buyToken, auctionIndex, amount);\r\n\r\n        // Update variables\r\n        balances[sellToken][msg.sender] = sub(balances[sellToken][msg.sender], amount);\r\n        uint newSellerBal = add(sellerBalances[sellToken][buyToken][auctionIndex][msg.sender], amountAfterFee);\r\n        sellerBalances[sellToken][buyToken][auctionIndex][msg.sender] = newSellerBal;\r\n\r\n        if (auctionStart == AUCTION_START_WAITING_FOR_FUNDING || auctionStart > now) {\r\n            // C1\r\n            uint sellVolumeCurrent = sellVolumesCurrent[sellToken][buyToken];\r\n            sellVolumesCurrent[sellToken][buyToken] = add(sellVolumeCurrent, amountAfterFee);\r\n        } else {\r\n            // C2\r\n            uint sellVolumeNext = sellVolumesNext[sellToken][buyToken];\r\n            sellVolumesNext[sellToken][buyToken] = add(sellVolumeNext, amountAfterFee);\r\n\r\n            // close previous auction if theoretically closed\r\n            closeTheoreticalClosedAuction(sellToken, buyToken, latestAuctionIndex);\r\n        }\r\n\r\n        if (auctionStart == AUCTION_START_WAITING_FOR_FUNDING) {\r\n            scheduleNextAuction(sellToken, buyToken);\r\n        }\r\n\r\n        emit NewSellOrder(sellToken, buyToken, msg.sender, auctionIndex, amountAfterFee);\r\n\r\n        return (auctionIndex, newSellerBal);\r\n    }\r\n\r\n    function postBuyOrder(address sellToken, address buyToken, uint auctionIndex, uint amount)\r\n        public\r\n        returns (uint newBuyerBal)\r\n    {\r\n        // R1: auction must not have cleared\r\n        require(closingPrices[sellToken][buyToken][auctionIndex].den == 0);\r\n\r\n        uint auctionStart = getAuctionStart(sellToken, buyToken);\r\n\r\n        // R2\r\n        require(auctionStart <= now);\r\n\r\n        // R4\r\n        require(auctionIndex == getAuctionIndex(sellToken, buyToken));\r\n\r\n        // R5: auction must not be in waiting period\r\n        require(auctionStart > AUCTION_START_WAITING_FOR_FUNDING);\r\n\r\n        // R6: auction must be funded\r\n        require(sellVolumesCurrent[sellToken][buyToken] > 0);\r\n\r\n        uint buyVolume = buyVolumes[sellToken][buyToken];\r\n        amount = min(amount, balances[buyToken][msg.sender]);\r\n\r\n        // R7\r\n        require(add(buyVolume, amount) < 10 ** 30);\r\n\r\n        // Overbuy is when a part of a buy order clears an auction\r\n        // In that case we only process the part before the overbuy\r\n        // To calculate overbuy, we first get current price\r\n        uint sellVolume = sellVolumesCurrent[sellToken][buyToken];\r\n\r\n        uint num;\r\n        uint den;\r\n        (num, den) = getCurrentAuctionPrice(sellToken, buyToken, auctionIndex);\r\n        // 10^30 * 10^37 = 10^67\r\n        uint outstandingVolume = atleastZero(int(mul(sellVolume, num) / den - buyVolume));\r\n\r\n        uint amountAfterFee;\r\n        if (amount < outstandingVolume) {\r\n            if (amount > 0) {\r\n                amountAfterFee = settleFee(buyToken, sellToken, auctionIndex, amount);\r\n            }\r\n        } else {\r\n            amount = outstandingVolume;\r\n            amountAfterFee = outstandingVolume;\r\n        }\r\n\r\n        // Here we could also use outstandingVolume or amountAfterFee, it doesn't matter\r\n        if (amount > 0) {\r\n            // Update variables\r\n            balances[buyToken][msg.sender] = sub(balances[buyToken][msg.sender], amount);\r\n            newBuyerBal = add(buyerBalances[sellToken][buyToken][auctionIndex][msg.sender], amountAfterFee);\r\n            buyerBalances[sellToken][buyToken][auctionIndex][msg.sender] = newBuyerBal;\r\n            buyVolumes[sellToken][buyToken] = add(buyVolumes[sellToken][buyToken], amountAfterFee);\r\n            emit NewBuyOrder(sellToken, buyToken, msg.sender, auctionIndex, amountAfterFee);\r\n        }\r\n\r\n        // Checking for equality would suffice here. nevertheless:\r\n        if (amount >= outstandingVolume) {\r\n            // Clear auction\r\n            clearAuction(sellToken, buyToken, auctionIndex, sellVolume);\r\n        }\r\n\r\n        return (newBuyerBal);\r\n    }\r\n\r\n    function claimSellerFunds(address sellToken, address buyToken, address user, uint auctionIndex)\r\n        public\r\n        returns (\r\n        // < (10^60, 10^61)\r\n        uint returned,\r\n        uint frtsIssued\r\n    )\r\n    {\r\n        closeTheoreticalClosedAuction(sellToken, buyToken, auctionIndex);\r\n        uint sellerBalance = sellerBalances[sellToken][buyToken][auctionIndex][user];\r\n\r\n        // R1\r\n        require(sellerBalance > 0);\r\n\r\n        // Get closing price for said auction\r\n        Fraction memory closingPrice = closingPrices[sellToken][buyToken][auctionIndex];\r\n        uint num = closingPrice.num;\r\n        uint den = closingPrice.den;\r\n\r\n        // R2: require auction to have cleared\r\n        require(den > 0);\r\n\r\n        // Calculate return\r\n        // < 10^30 * 10^30 = 10^60\r\n        returned = mul(sellerBalance, num) / den;\r\n\r\n        frtsIssued = issueFrts(\r\n            sellToken,\r\n            buyToken,\r\n            returned,\r\n            auctionIndex,\r\n            sellerBalance,\r\n            user\r\n        );\r\n\r\n        // Claim tokens\r\n        sellerBalances[sellToken][buyToken][auctionIndex][user] = 0;\r\n        if (returned > 0) {\r\n            balances[buyToken][user] = add(balances[buyToken][user], returned);\r\n        }\r\n        emit NewSellerFundsClaim(\r\n            sellToken,\r\n            buyToken,\r\n            user,\r\n            auctionIndex,\r\n            returned,\r\n            frtsIssued\r\n        );\r\n    }\r\n\r\n    function claimBuyerFunds(address sellToken, address buyToken, address user, uint auctionIndex)\r\n        public\r\n        returns (uint returned, uint frtsIssued)\r\n    {\r\n        closeTheoreticalClosedAuction(sellToken, buyToken, auctionIndex);\r\n\r\n        uint num;\r\n        uint den;\r\n        (returned, num, den) = getUnclaimedBuyerFunds(sellToken, buyToken, user, auctionIndex);\r\n\r\n        if (closingPrices[sellToken][buyToken][auctionIndex].den == 0) {\r\n            // Auction is running\r\n            claimedAmounts[sellToken][buyToken][auctionIndex][user] = add(\r\n                claimedAmounts[sellToken][buyToken][auctionIndex][user],\r\n                returned\r\n            );\r\n        } else {\r\n            // Auction has closed\r\n            // We DON'T want to check for returned > 0, because that would fail if a user claims\r\n            // intermediate funds & auction clears in same block (he/she would not be able to claim extraTokens)\r\n\r\n            // Assign extra sell tokens (this is possible only after auction has cleared,\r\n            // because buyVolume could still increase before that)\r\n            uint extraTokensTotal = extraTokens[sellToken][buyToken][auctionIndex];\r\n            uint buyerBalance = buyerBalances[sellToken][buyToken][auctionIndex][user];\r\n\r\n            // closingPrices.num represents buyVolume\r\n            // < 10^30 * 10^30 = 10^60\r\n            uint tokensExtra = mul(\r\n                buyerBalance,\r\n                extraTokensTotal\r\n            ) / closingPrices[sellToken][buyToken][auctionIndex].num;\r\n            returned = add(returned, tokensExtra);\r\n\r\n            frtsIssued = issueFrts(\r\n                buyToken,\r\n                sellToken,\r\n                mul(buyerBalance, den) / num,\r\n                auctionIndex,\r\n                buyerBalance,\r\n                user\r\n            );\r\n\r\n            // Auction has closed\r\n            // Reset buyerBalances and claimedAmounts\r\n            buyerBalances[sellToken][buyToken][auctionIndex][user] = 0;\r\n            claimedAmounts[sellToken][buyToken][auctionIndex][user] = 0;\r\n        }\r\n\r\n        // Claim tokens\r\n        if (returned > 0) {\r\n            balances[sellToken][user] = add(balances[sellToken][user], returned);\r\n        }\r\n\r\n        emit NewBuyerFundsClaim(\r\n            sellToken,\r\n            buyToken,\r\n            user,\r\n            auctionIndex,\r\n            returned,\r\n            frtsIssued\r\n        );\r\n    }\r\n\r\n    /// @dev allows to close possible theoretical closed markets\r\n    /// @param sellToken sellToken of an auction\r\n    /// @param buyToken buyToken of an auction\r\n    /// @param auctionIndex is the auctionIndex of the auction\r\n    function closeTheoreticalClosedAuction(address sellToken, address buyToken, uint auctionIndex) public {\r\n        if (auctionIndex == getAuctionIndex(\r\n            buyToken,\r\n            sellToken\r\n        ) && closingPrices[sellToken][buyToken][auctionIndex].num == 0) {\r\n            uint buyVolume = buyVolumes[sellToken][buyToken];\r\n            uint sellVolume = sellVolumesCurrent[sellToken][buyToken];\r\n            uint num;\r\n            uint den;\r\n            (num, den) = getCurrentAuctionPrice(sellToken, buyToken, auctionIndex);\r\n            // 10^30 * 10^37 = 10^67\r\n            if (sellVolume > 0) {\r\n                uint outstandingVolume = atleastZero(int(mul(sellVolume, num) / den - buyVolume));\r\n\r\n                if (outstandingVolume == 0) {\r\n                    postBuyOrder(sellToken, buyToken, auctionIndex, 0);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Claim buyer funds for one auction\r\n    function getUnclaimedBuyerFunds(address sellToken, address buyToken, address user, uint auctionIndex)\r\n        public\r\n        view\r\n        returns (\r\n        // < (10^67, 10^37)\r\n        uint unclaimedBuyerFunds,\r\n        uint num,\r\n        uint den\r\n    )\r\n    {\r\n        // R1: checks if particular auction has ever run\r\n        require(auctionIndex <= getAuctionIndex(sellToken, buyToken));\r\n\r\n        (num, den) = getCurrentAuctionPrice(sellToken, buyToken, auctionIndex);\r\n\r\n        if (num == 0) {\r\n            // This should rarely happen - as long as there is >= 1 buy order,\r\n            // auction will clear before price = 0. So this is just fail-safe\r\n            unclaimedBuyerFunds = 0;\r\n        } else {\r\n            uint buyerBalance = buyerBalances[sellToken][buyToken][auctionIndex][user];\r\n            // < 10^30 * 10^37 = 10^67\r\n            unclaimedBuyerFunds = atleastZero(\r\n                int(mul(buyerBalance, den) / num - claimedAmounts[sellToken][buyToken][auctionIndex][user])\r\n            );\r\n        }\r\n    }\r\n\r\n    function getFeeRatio(address user)\r\n        public\r\n        view\r\n        returns (\r\n        // feeRatio < 10^4\r\n        uint num,\r\n        uint den\r\n    )\r\n    {\r\n        uint totalSupply = frtToken.totalSupply();\r\n        uint lockedFrt = frtToken.lockedTokenBalances(user);\r\n\r\n        /*\r\n          Fee Model:\r\n            locked FRT range     Fee\r\n            -----------------   ------\r\n            [0, 0.01%)           0.5%\r\n            [0.01%, 0.1%)        0.4%\r\n            [0.1%, 1%)           0.3%\r\n            [1%, 10%)            0.2%\r\n            [10%, 100%)          0.1%\r\n        */\r\n\r\n        if (lockedFrt * 10000 < totalSupply || totalSupply == 0) {\r\n            // Maximum fee, if user has locked less than 0.01% of the total FRT\r\n            // Fee: 0.5%\r\n            num = 1;\r\n            den = 200;\r\n        } else if (lockedFrt * 1000 < totalSupply) {\r\n            // If user has locked more than 0.01% and less than 0.1% of the total FRT\r\n            // Fee: 0.4%\r\n            num = 1;\r\n            den = 250;\r\n        } else if (lockedFrt * 100 < totalSupply) {\r\n            // If user has locked more than 0.1% and less than 1% of the total FRT\r\n            // Fee: 0.3%\r\n            num = 3;\r\n            den = 1000;\r\n        } else if (lockedFrt * 10 < totalSupply) {\r\n            // If user has locked more than 1% and less than 10% of the total FRT\r\n            // Fee: 0.2%\r\n            num = 1;\r\n            den = 500;\r\n        } else {\r\n            // If user has locked more than 10% of the total FRT\r\n            // Fee: 0.1%\r\n            num = 1;\r\n            den = 1000;\r\n        }\r\n    }\r\n\r\n    //@ dev returns price in units [token2]/[token1]\r\n    //@ param token1 first token for price calculation\r\n    //@ param token2 second token for price calculation\r\n    //@ param auctionIndex index for the auction to get the averaged price from\r\n    function getPriceInPastAuction(\r\n        address token1,\r\n        address token2,\r\n        uint auctionIndex\r\n    )\r\n        public\r\n        view\r\n        // price < 10^31\r\n        returns (uint num, uint den)\r\n    {\r\n        if (token1 == token2) {\r\n            // C1\r\n            num = 1;\r\n            den = 1;\r\n        } else {\r\n            // C2\r\n            // R2.1\r\n            // require(auctionIndex >= 0);\r\n\r\n            // C3\r\n            // R3.1\r\n            require(auctionIndex <= getAuctionIndex(token1, token2));\r\n            // auction still running\r\n\r\n            uint i = 0;\r\n            bool correctPair = false;\r\n            Fraction memory closingPriceToken1;\r\n            Fraction memory closingPriceToken2;\r\n\r\n            while (!correctPair) {\r\n                closingPriceToken2 = closingPrices[token2][token1][auctionIndex - i];\r\n                closingPriceToken1 = closingPrices[token1][token2][auctionIndex - i];\r\n\r\n                if (closingPriceToken1.num > 0 && closingPriceToken1.den > 0 ||\r\n                    closingPriceToken2.num > 0 && closingPriceToken2.den > 0)\r\n                {\r\n                    correctPair = true;\r\n                }\r\n                i++;\r\n            }\r\n\r\n            // At this point at least one closing price is strictly positive\r\n            // If only one is positive, we want to output that\r\n            if (closingPriceToken1.num == 0 || closingPriceToken1.den == 0) {\r\n                num = closingPriceToken2.den;\r\n                den = closingPriceToken2.num;\r\n            } else if (closingPriceToken2.num == 0 || closingPriceToken2.den == 0) {\r\n                num = closingPriceToken1.num;\r\n                den = closingPriceToken1.den;\r\n            } else {\r\n                // If both prices are positive, output weighted average\r\n                num = closingPriceToken2.den + closingPriceToken1.num;\r\n                den = closingPriceToken2.num + closingPriceToken1.den;\r\n            }\r\n        }\r\n    }\r\n\r\n    function scheduleNextAuction(\r\n        address sellToken,\r\n        address buyToken\r\n    )\r\n        internal\r\n    {\r\n        (uint sellVolume, uint sellVolumeOpp) = getSellVolumesInUSD(sellToken, buyToken);\r\n\r\n        bool enoughSellVolume = sellVolume >= thresholdNewAuction;\r\n        bool enoughSellVolumeOpp = sellVolumeOpp >= thresholdNewAuction;\r\n        bool schedule;\r\n        // Make sure both sides have liquidity in order to start the auction\r\n        if (enoughSellVolume && enoughSellVolumeOpp) {\r\n            schedule = true;\r\n        } else if (enoughSellVolume || enoughSellVolumeOpp) {\r\n            // But if the auction didn't start in 24h, then is enough to have\r\n            // liquidity in one of the two sides\r\n            uint latestAuctionIndex = getAuctionIndex(sellToken, buyToken);\r\n            uint clearingTime = getClearingTime(sellToken, buyToken, latestAuctionIndex - 1);\r\n            schedule = clearingTime <= now - 24 hours;\r\n        }\r\n\r\n        if (schedule) {\r\n            // Schedule next auction\r\n            setAuctionStart(sellToken, buyToken, WAITING_PERIOD_NEW_AUCTION);\r\n        } else {\r\n            resetAuctionStart(sellToken, buyToken);\r\n        }\r\n    }\r\n\r\n    function getSellVolumesInUSD(\r\n        address sellToken,\r\n        address buyToken\r\n    )\r\n        internal\r\n        view\r\n        returns (uint sellVolume, uint sellVolumeOpp)\r\n    {\r\n        // Check if auctions received enough sell orders\r\n        uint ethUSDPrice = ethUSDOracle.getUSDETHPrice();\r\n\r\n        uint sellNum;\r\n        uint sellDen;\r\n        (sellNum, sellDen) = getPriceOfTokenInLastAuction(sellToken);\r\n\r\n        uint buyNum;\r\n        uint buyDen;\r\n        (buyNum, buyDen) = getPriceOfTokenInLastAuction(buyToken);\r\n\r\n        // We use current sell volume, because in clearAuction() we set\r\n        // sellVolumesCurrent = sellVolumesNext before calling this function\r\n        // (this is so that we don't need case work,\r\n        // since it might also be called from postSellOrder())\r\n\r\n        // < 10^30 * 10^31 * 10^6 = 10^67\r\n        sellVolume = mul(mul(sellVolumesCurrent[sellToken][buyToken], sellNum), ethUSDPrice) / sellDen;\r\n        sellVolumeOpp = mul(mul(sellVolumesCurrent[buyToken][sellToken], buyNum), ethUSDPrice) / buyDen;\r\n    }\r\n\r\n    /// @dev Gives best estimate for market price of a token in ETH of any price oracle on the Ethereum network\r\n    /// @param token address of ERC-20 token\r\n    /// @return Weighted average of closing prices of opposite Token-ethToken auctions, based on their sellVolume\r\n    function getPriceOfTokenInLastAuction(address token)\r\n        public\r\n        view\r\n        returns (\r\n        // price < 10^31\r\n        uint num,\r\n        uint den\r\n    )\r\n    {\r\n        uint latestAuctionIndex = getAuctionIndex(token, ethToken);\r\n        // getPriceInPastAuction < 10^30\r\n        (num, den) = getPriceInPastAuction(token, ethToken, latestAuctionIndex - 1);\r\n    }\r\n\r\n    function getCurrentAuctionPrice(address sellToken, address buyToken, uint auctionIndex)\r\n        public\r\n        view\r\n        returns (\r\n        // price < 10^37\r\n        uint num,\r\n        uint den\r\n    )\r\n    {\r\n        Fraction memory closingPrice = closingPrices[sellToken][buyToken][auctionIndex];\r\n\r\n        if (closingPrice.den != 0) {\r\n            // Auction has closed\r\n            (num, den) = (closingPrice.num, closingPrice.den);\r\n        } else if (auctionIndex > getAuctionIndex(sellToken, buyToken)) {\r\n            (num, den) = (0, 0);\r\n        } else {\r\n            // Auction is running\r\n            uint pastNum;\r\n            uint pastDen;\r\n            (pastNum, pastDen) = getPriceInPastAuction(sellToken, buyToken, auctionIndex - 1);\r\n\r\n            // If we're calling the function into an unstarted auction,\r\n            // it will return the starting price of that auction\r\n            uint timeElapsed = atleastZero(int(now - getAuctionStart(sellToken, buyToken)));\r\n\r\n            // The numbers below are chosen such that\r\n            // P(0 hrs) = 2 * lastClosingPrice, P(6 hrs) = lastClosingPrice, P(>=24 hrs) = 0\r\n\r\n            // 10^5 * 10^31 = 10^36\r\n            num = atleastZero(int((24 hours - timeElapsed) * pastNum));\r\n            // 10^6 * 10^31 = 10^37\r\n            den = mul((timeElapsed + 12 hours), pastDen);\r\n\r\n            if (mul(num, sellVolumesCurrent[sellToken][buyToken]) <= mul(den, buyVolumes[sellToken][buyToken])) {\r\n                num = buyVolumes[sellToken][buyToken];\r\n                den = sellVolumesCurrent[sellToken][buyToken];\r\n            }\r\n        }\r\n    }\r\n\r\n    // > Helper fns\r\n    function getTokenOrder(address token1, address token2) public pure returns (address, address) {\r\n        if (token2 < token1) {\r\n            (token1, token2) = (token2, token1);\r\n        }\r\n\r\n        return (token1, token2);\r\n    }\r\n\r\n    function getAuctionStart(address token1, address token2) public view returns (uint auctionStart) {\r\n        (token1, token2) = getTokenOrder(token1, token2);\r\n        auctionStart = auctionStarts[token1][token2];\r\n    }\r\n\r\n    function getAuctionIndex(address token1, address token2) public view returns (uint auctionIndex) {\r\n        (token1, token2) = getTokenOrder(token1, token2);\r\n        auctionIndex = latestAuctionIndices[token1][token2];\r\n    }\r\n\r\n    function calculateFundedValueTokenToken(\r\n        address token1,\r\n        address token2,\r\n        uint token1Funding,\r\n        uint token2Funding,\r\n        address ethTokenMem,\r\n        uint ethUSDPrice\r\n    )\r\n        internal\r\n        view\r\n        returns (uint fundedValueUSD)\r\n    {\r\n        // We require there to exist ethToken-Token auctions\r\n        // R3.1\r\n        require(getAuctionIndex(token1, ethTokenMem) > 0);\r\n\r\n        // R3.2\r\n        require(getAuctionIndex(token2, ethTokenMem) > 0);\r\n\r\n        // Price of Token 1\r\n        uint priceToken1Num;\r\n        uint priceToken1Den;\r\n        (priceToken1Num, priceToken1Den) = getPriceOfTokenInLastAuction(token1);\r\n\r\n        // Price of Token 2\r\n        uint priceToken2Num;\r\n        uint priceToken2Den;\r\n        (priceToken2Num, priceToken2Den) = getPriceOfTokenInLastAuction(token2);\r\n\r\n        // Compute funded value in ethToken and USD\r\n        // 10^30 * 10^30 = 10^60\r\n        uint fundedValueETH = add(\r\n            mul(token1Funding, priceToken1Num) / priceToken1Den,\r\n            token2Funding * priceToken2Num / priceToken2Den\r\n        );\r\n\r\n        fundedValueUSD = mul(fundedValueETH, ethUSDPrice);\r\n    }\r\n\r\n    function addTokenPairSecondPart(\r\n        address token1,\r\n        address token2,\r\n        uint token1Funding,\r\n        uint token2Funding\r\n    )\r\n        internal\r\n    {\r\n        balances[token1][msg.sender] = sub(balances[token1][msg.sender], token1Funding);\r\n        balances[token2][msg.sender] = sub(balances[token2][msg.sender], token2Funding);\r\n\r\n        // Fee mechanism, fees are added to extraTokens\r\n        uint token1FundingAfterFee = settleFee(token1, token2, 1, token1Funding);\r\n        uint token2FundingAfterFee = settleFee(token2, token1, 1, token2Funding);\r\n\r\n        // Update other variables\r\n        sellVolumesCurrent[token1][token2] = token1FundingAfterFee;\r\n        sellVolumesCurrent[token2][token1] = token2FundingAfterFee;\r\n        sellerBalances[token1][token2][1][msg.sender] = token1FundingAfterFee;\r\n        sellerBalances[token2][token1][1][msg.sender] = token2FundingAfterFee;\r\n\r\n        // Save clearingTime as adding time\r\n        (address tokenA, address tokenB) = getTokenOrder(token1, token2);\r\n        clearingTimes[tokenA][tokenB][0] = now;\r\n\r\n        setAuctionStart(token1, token2, WAITING_PERIOD_NEW_TOKEN_PAIR);\r\n        emit NewTokenPair(token1, token2);\r\n    }\r\n\r\n    function setClearingTime(\r\n        address token1,\r\n        address token2,\r\n        uint auctionIndex,\r\n        uint auctionStart,\r\n        uint sellVolume,\r\n        uint buyVolume\r\n    )\r\n        internal\r\n    {\r\n        (uint pastNum, uint pastDen) = getPriceInPastAuction(token1, token2, auctionIndex - 1);\r\n        // timeElapsed = (12 hours)*(2 * pastNum * sellVolume - buyVolume * pastDen)/\r\n            // (sellVolume * pastNum + buyVolume * pastDen)\r\n        uint numerator = sub(mul(mul(pastNum, sellVolume), 24 hours), mul(mul(buyVolume, pastDen), 12 hours));\r\n        uint timeElapsed = numerator / (add(mul(sellVolume, pastNum), mul(buyVolume, pastDen)));\r\n        uint clearingTime = auctionStart + timeElapsed;\r\n        (token1, token2) = getTokenOrder(token1, token2);\r\n        clearingTimes[token1][token2][auctionIndex] = clearingTime;\r\n    }\r\n\r\n    function getClearingTime(\r\n        address token1,\r\n        address token2,\r\n        uint auctionIndex\r\n    )\r\n        public\r\n        view\r\n        returns (uint time)\r\n    {\r\n        (token1, token2) = getTokenOrder(token1, token2);\r\n        time = clearingTimes[token1][token2][auctionIndex];\r\n    }\r\n\r\n    function issueFrts(\r\n        address primaryToken,\r\n        address secondaryToken,\r\n        uint x,\r\n        uint auctionIndex,\r\n        uint bal,\r\n        address user\r\n    )\r\n        internal\r\n        returns (uint frtsIssued)\r\n    {\r\n        if (approvedTokens[primaryToken] && approvedTokens[secondaryToken]) {\r\n            address ethTokenMem = ethToken;\r\n            // Get frts issued based on ETH price of returned tokens\r\n            if (primaryToken == ethTokenMem) {\r\n                frtsIssued = bal;\r\n            } else if (secondaryToken == ethTokenMem) {\r\n                // 10^30 * 10^39 = 10^66\r\n                frtsIssued = x;\r\n            } else {\r\n                // Neither token is ethToken, so we use getHhistoricalPriceOracle()\r\n                uint pastNum;\r\n                uint pastDen;\r\n                (pastNum, pastDen) = getPriceInPastAuction(primaryToken, ethTokenMem, auctionIndex - 1);\r\n                // 10^30 * 10^35 = 10^65\r\n                frtsIssued = mul(bal, pastNum) / pastDen;\r\n            }\r\n\r\n            if (frtsIssued > 0) {\r\n                // Issue frtToken\r\n                frtToken.mintTokens(user, frtsIssued);\r\n            }\r\n        }\r\n    }\r\n\r\n    function settleFee(address primaryToken, address secondaryToken, uint auctionIndex, uint amount)\r\n        internal\r\n        returns (\r\n        // < 10^30\r\n        uint amountAfterFee\r\n    )\r\n    {\r\n        uint feeNum;\r\n        uint feeDen;\r\n        (feeNum, feeDen) = getFeeRatio(msg.sender);\r\n        // 10^30 * 10^3 / 10^4 = 10^29\r\n        uint fee = mul(amount, feeNum) / feeDen;\r\n\r\n        if (fee > 0) {\r\n            fee = settleFeeSecondPart(primaryToken, fee);\r\n\r\n            uint usersExtraTokens = extraTokens[primaryToken][secondaryToken][auctionIndex + 1];\r\n            extraTokens[primaryToken][secondaryToken][auctionIndex + 1] = add(usersExtraTokens, fee);\r\n\r\n            emit Fee(primaryToken, secondaryToken, msg.sender, auctionIndex, fee);\r\n        }\r\n\r\n        amountAfterFee = sub(amount, fee);\r\n    }\r\n\r\n    function settleFeeSecondPart(address primaryToken, uint fee) internal returns (uint newFee) {\r\n        // Allow user to reduce up to half of the fee with owlToken\r\n        uint num;\r\n        uint den;\r\n        (num, den) = getPriceOfTokenInLastAuction(primaryToken);\r\n\r\n        // Convert fee to ETH, then USD\r\n        // 10^29 * 10^30 / 10^30 = 10^29\r\n        uint feeInETH = mul(fee, num) / den;\r\n\r\n        uint ethUSDPrice = ethUSDOracle.getUSDETHPrice();\r\n        // 10^29 * 10^6 = 10^35\r\n        // Uses 18 decimal places <> exactly as owlToken tokens: 10**18 owlToken == 1 USD\r\n        uint feeInUSD = mul(feeInETH, ethUSDPrice);\r\n        uint amountOfowlTokenBurned = min(owlToken.allowance(msg.sender, address(this)), feeInUSD / 2);\r\n        amountOfowlTokenBurned = min(owlToken.balanceOf(msg.sender), amountOfowlTokenBurned);\r\n\r\n        if (amountOfowlTokenBurned > 0) {\r\n            owlToken.burnOWL(msg.sender, amountOfowlTokenBurned);\r\n            // Adjust fee\r\n            // 10^35 * 10^29 = 10^64\r\n            uint adjustment = mul(amountOfowlTokenBurned, fee) / feeInUSD;\r\n            newFee = sub(fee, adjustment);\r\n        } else {\r\n            newFee = fee;\r\n        }\r\n    }\r\n\r\n    // addClearTimes\r\n    /// @dev clears an Auction\r\n    /// @param sellToken sellToken of the auction\r\n    /// @param buyToken  buyToken of the auction\r\n    /// @param auctionIndex of the auction to be cleared.\r\n    function clearAuction(\r\n        address sellToken,\r\n        address buyToken,\r\n        uint auctionIndex,\r\n        uint sellVolume\r\n    )\r\n        internal\r\n    {\r\n        // Get variables\r\n        uint buyVolume = buyVolumes[sellToken][buyToken];\r\n        uint sellVolumeOpp = sellVolumesCurrent[buyToken][sellToken];\r\n        uint closingPriceOppDen = closingPrices[buyToken][sellToken][auctionIndex].den;\r\n        uint auctionStart = getAuctionStart(sellToken, buyToken);\r\n\r\n        // Update closing price\r\n        if (sellVolume > 0) {\r\n            closingPrices[sellToken][buyToken][auctionIndex] = Fraction(buyVolume, sellVolume);\r\n        }\r\n\r\n        // if (opposite is 0 auction OR price = 0 OR opposite auction cleared)\r\n        // price = 0 happens if auction pair has been running for >= 24 hrs\r\n        if (sellVolumeOpp == 0 || now >= auctionStart + 24 hours || closingPriceOppDen > 0) {\r\n            // Close auction pair\r\n            uint buyVolumeOpp = buyVolumes[buyToken][sellToken];\r\n            if (closingPriceOppDen == 0 && sellVolumeOpp > 0) {\r\n                // Save opposite price\r\n                closingPrices[buyToken][sellToken][auctionIndex] = Fraction(buyVolumeOpp, sellVolumeOpp);\r\n            }\r\n\r\n            uint sellVolumeNext = sellVolumesNext[sellToken][buyToken];\r\n            uint sellVolumeNextOpp = sellVolumesNext[buyToken][sellToken];\r\n\r\n            // Update state variables for both auctions\r\n            sellVolumesCurrent[sellToken][buyToken] = sellVolumeNext;\r\n            if (sellVolumeNext > 0) {\r\n                sellVolumesNext[sellToken][buyToken] = 0;\r\n            }\r\n            if (buyVolume > 0) {\r\n                buyVolumes[sellToken][buyToken] = 0;\r\n            }\r\n\r\n            sellVolumesCurrent[buyToken][sellToken] = sellVolumeNextOpp;\r\n            if (sellVolumeNextOpp > 0) {\r\n                sellVolumesNext[buyToken][sellToken] = 0;\r\n            }\r\n            if (buyVolumeOpp > 0) {\r\n                buyVolumes[buyToken][sellToken] = 0;\r\n            }\r\n\r\n            // Save clearing time\r\n            setClearingTime(sellToken, buyToken, auctionIndex, auctionStart, sellVolume, buyVolume);\r\n            // Increment auction index\r\n            setAuctionIndex(sellToken, buyToken);\r\n            // Check if next auction can be scheduled\r\n            scheduleNextAuction(sellToken, buyToken);\r\n        }\r\n\r\n        emit AuctionCleared(sellToken, buyToken, sellVolume, buyVolume, auctionIndex);\r\n    }\r\n\r\n    function setAuctionStart(address token1, address token2, uint value) internal {\r\n        (token1, token2) = getTokenOrder(token1, token2);\r\n        uint auctionStart = now + value;\r\n        uint auctionIndex = latestAuctionIndices[token1][token2];\r\n        auctionStarts[token1][token2] = auctionStart;\r\n        emit AuctionStartScheduled(token1, token2, auctionIndex, auctionStart);\r\n    }\r\n\r\n    function resetAuctionStart(address token1, address token2) internal {\r\n        (token1, token2) = getTokenOrder(token1, token2);\r\n        if (auctionStarts[token1][token2] != AUCTION_START_WAITING_FOR_FUNDING) {\r\n            auctionStarts[token1][token2] = AUCTION_START_WAITING_FOR_FUNDING;\r\n        }\r\n    }\r\n\r\n    function setAuctionIndex(address token1, address token2) internal {\r\n        (token1, token2) = getTokenOrder(token1, token2);\r\n        latestAuctionIndices[token1][token2] += 1;\r\n    }\r\n\r\n    function checkLengthsForSeveralAuctionClaiming(\r\n        address[] memory auctionSellTokens,\r\n        address[] memory auctionBuyTokens,\r\n        uint[] memory auctionIndices\r\n    ) internal pure returns (uint length)\r\n    {\r\n        length = auctionSellTokens.length;\r\n        uint length2 = auctionBuyTokens.length;\r\n        require(length == length2);\r\n\r\n        uint length3 = auctionIndices.length;\r\n        require(length2 == length3);\r\n    }\r\n\r\n    // > Events\r\n    event NewDeposit(address indexed token, uint amount);\r\n\r\n    event NewWithdrawal(address indexed token, uint amount);\r\n\r\n    event NewSellOrder(\r\n        address indexed sellToken,\r\n        address indexed buyToken,\r\n        address indexed user,\r\n        uint auctionIndex,\r\n        uint amount\r\n    );\r\n\r\n    event NewBuyOrder(\r\n        address indexed sellToken,\r\n        address indexed buyToken,\r\n        address indexed user,\r\n        uint auctionIndex,\r\n        uint amount\r\n    );\r\n\r\n    event NewSellerFundsClaim(\r\n        address indexed sellToken,\r\n        address indexed buyToken,\r\n        address indexed user,\r\n        uint auctionIndex,\r\n        uint amount,\r\n        uint frtsIssued\r\n    );\r\n\r\n    event NewBuyerFundsClaim(\r\n        address indexed sellToken,\r\n        address indexed buyToken,\r\n        address indexed user,\r\n        uint auctionIndex,\r\n        uint amount,\r\n        uint frtsIssued\r\n    );\r\n\r\n    event NewTokenPair(address indexed sellToken, address indexed buyToken);\r\n\r\n    event AuctionCleared(\r\n        address indexed sellToken,\r\n        address indexed buyToken,\r\n        uint sellVolume,\r\n        uint buyVolume,\r\n        uint indexed auctionIndex\r\n    );\r\n\r\n    event AuctionStartScheduled(\r\n        address indexed sellToken,\r\n        address indexed buyToken,\r\n        uint indexed auctionIndex,\r\n        uint auctionStart\r\n    );\r\n\r\n    event Fee(\r\n        address indexed primaryToken,\r\n        address indexed secondarToken,\r\n        address indexed user,\r\n        uint auctionIndex,\r\n        uint fee\r\n    );\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"token1\",\"type\":\"address\"},{\"name\":\"token2\",\"type\":\"address\"}],\"name\":\"getTokenOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addressesToCheck\",\"type\":\"address[]\"}],\"name\":\"getApprovedAddressesOfList\",\"outputs\":[{\"name\":\"\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMasterCopy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimAndWithdraw\",\"outputs\":[{\"name\":\"returned\",\"type\":\"uint256\"},{\"name\":\"frtsIssued\",\"type\":\"uint256\"},{\"name\":\"newBal\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"auctionSellTokens\",\"type\":\"address[]\"},{\"name\":\"auctionBuyTokens\",\"type\":\"address[]\"},{\"name\":\"auctionIndices\",\"type\":\"uint256[]\"}],\"name\":\"claimAndWithdrawTokensFromSeveralAuctionsAsBuyer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"frtsIssued\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"masterCopyCountdown\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"auctionStarts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token1\",\"type\":\"address\"},{\"name\":\"token2\",\"type\":\"address\"}],\"name\":\"getAuctionIndex\",\"outputs\":[{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateMasterCopy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"int256\"}],\"name\":\"atleastZero\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"buyerBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ethUSDOracle\",\"type\":\"address\"}],\"name\":\"initiateEthUsdOracleUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token1\",\"type\":\"address\"},{\"name\":\"token2\",\"type\":\"address\"},{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"getPriceInPastAuction\",\"outputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"den\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeToAdd\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"postSellOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"postBuyOrder\",\"outputs\":[{\"name\":\"newBuyerBal\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctioneer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"claimSellerFunds\",\"outputs\":[{\"name\":\"returned\",\"type\":\"uint256\"},{\"name\":\"frtsIssued\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositAndSell\",\"outputs\":[{\"name\":\"newBal\",\"type\":\"uint256\"},{\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"name\":\"newSellerBal\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address[]\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"updateApprovalOfToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thresholdNewTokenPair\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newMasterCopy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethUSDOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token1\",\"type\":\"address\"},{\"name\":\"token2\",\"type\":\"address\"},{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"getClearingTime\",\"outputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"add\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"auctionSellTokens\",\"type\":\"address[]\"},{\"name\":\"auctionBuyTokens\",\"type\":\"address[]\"},{\"name\":\"auctionIndices\",\"type\":\"uint256[]\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"claimTokensFromSeveralAuctionsAsSeller\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_auctioneer\",\"type\":\"address\"}],\"name\":\"updateAuctioneer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"min\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"closeTheoreticalClosedAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"frtToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"auctionSellTokens\",\"type\":\"address[]\"},{\"name\":\"auctionBuyTokens\",\"type\":\"address[]\"},{\"name\":\"auctionIndices\",\"type\":\"uint256[]\"}],\"name\":\"claimAndWithdrawTokensFromSeveralAuctionsAsSeller\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"frtsIssued\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimedAmounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracleInterfaceCountdown\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"masterCopy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_frtToken\",\"type\":\"address\"},{\"name\":\"_owlToken\",\"type\":\"address\"},{\"name\":\"_auctioneer\",\"type\":\"address\"},{\"name\":\"_ethToken\",\"type\":\"address\"},{\"name\":\"_ethUSDOracle\",\"type\":\"address\"},{\"name\":\"_thresholdNewTokenPair\",\"type\":\"uint256\"},{\"name\":\"_thresholdNewAuction\",\"type\":\"uint256\"}],\"name\":\"setupDutchExchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"claimBuyerFunds\",\"outputs\":[{\"name\":\"returned\",\"type\":\"uint256\"},{\"name\":\"frtsIssued\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"clearingTimes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"sellVolumesNext\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"sellVolumesCurrent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"sub\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"buyVolumes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"sellerBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_thresholdNewAuction\",\"type\":\"uint256\"}],\"name\":\"updateThresholdNewAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"mul\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeToMul\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newProposalEthUSDOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owlToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"auctionSellTokens\",\"type\":\"address[]\"},{\"name\":\"auctionBuyTokens\",\"type\":\"address[]\"},{\"name\":\"auctionIndices\",\"type\":\"uint256[]\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"claimTokensFromSeveralAuctionsAsBuyer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token1\",\"type\":\"address\"},{\"name\":\"token2\",\"type\":\"address\"}],\"name\":\"getAuctionStart\",\"outputs\":[{\"name\":\"auctionStart\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"getUnclaimedBuyerFunds\",\"outputs\":[{\"name\":\"unclaimedBuyerFunds\",\"type\":\"uint256\"},{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"den\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_thresholdNewTokenPair\",\"type\":\"uint256\"}],\"name\":\"updateThresholdNewTokenPair\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeToSub\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token1\",\"type\":\"address\"},{\"name\":\"token2\",\"type\":\"address\"},{\"name\":\"token1Funding\",\"type\":\"uint256\"},{\"name\":\"token2Funding\",\"type\":\"uint256\"},{\"name\":\"initialClosingPriceNum\",\"type\":\"uint256\"},{\"name\":\"initialClosingPriceDen\",\"type\":\"uint256\"}],\"name\":\"addTokenPair\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"closingPrices\",\"outputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"den\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getFeeRatio\",\"outputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"den\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thresholdNewAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getPriceOfTokenInLastAuction\",\"outputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"den\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateEthUSDOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_masterCopy\",\"type\":\"address\"}],\"name\":\"startMasterCopyCountdown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"extraTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"latestAuctionIndices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"getCurrentAuctionPrice\",\"outputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"den\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewSellOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewBuyOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"frtsIssued\",\"type\":\"uint256\"}],\"name\":\"NewSellerFundsClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"frtsIssued\",\"type\":\"uint256\"}],\"name\":\"NewBuyerFundsClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyToken\",\"type\":\"address\"}],\"name\":\"NewTokenPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sellVolume\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyVolume\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"AuctionCleared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auctionStart\",\"type\":\"uint256\"}],\"name\":\"AuctionStartScheduled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"primaryToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"secondarToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Fee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"priceOracleInterface\",\"type\":\"address\"}],\"name\":\"NewOracleProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newMasterCopy\",\"type\":\"address\"}],\"name\":\"NewMasterCopyProposal\",\"type\":\"event\"}]","ContractName":"DutchExchange","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7c2888b04e675c63e2fcd95ada8c4645e1b6e490b95f8c3ecdcf29cc9c08faca"}]}