{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Source Code first verified at https://etherscan.io on Monday, November 26, 2018\r\n (UTC) */\r\n\r\npragma solidity ^0.5.1;\r\n\r\nlibrary SafeMath {\r\n        function mul (uint256 a, uint256 b) internal pure returns (uint256) {\r\n                if (a == 0) {\r\n                        return 0;\r\n                }\r\n                uint256 c = a * b;\r\n                assert(c / a == b);\r\n                return c;\r\n        }\r\n\r\n        function div (uint256 a, uint256 b) internal pure returns (uint256) {\r\n                return a / b;\r\n        }\r\n\r\n        function sub (uint256 a, uint256 b) internal pure returns (uint256) {\r\n                assert(b <= a);\r\n                return a - b;\r\n        }\r\n\r\n        function add (uint256 a, uint256 b) internal pure returns (uint256) {\r\n                uint256 c = a + b;\r\n                assert(c >= a);\r\n                return c;\r\n        }\r\n}\r\n\r\ncontract ERCBasic {\r\n        event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n        function totalSupply () public view returns (uint256);\r\n        function balanceOf (address who) public view returns (uint256);\r\n        function transfer (address to, uint256 value) public returns (bool);\r\n}\r\n\r\ncontract ERC is ERCBasic {\r\n        event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n        function transferFrom (address from, address to, uint256 value) public returns (bool);\r\n        function allowance (address owner, address spender) public view returns (uint256);\r\n        function approve (address spender, uint256 value) public returns (bool);\r\n}\r\n\r\ncontract Ownable {\r\n        \r\n        address payable internal owner;\r\n        address internal foundationOwner;\r\n\r\n        constructor () public {\r\n                owner = msg.sender;\r\n                foundationOwner = owner;\r\n        }\r\n\r\n        modifier onlyOwner () {\r\n                require(msg.sender == owner);\r\n                _;\r\n        }\r\n\r\n        modifier hasMintability () {\r\n                require(msg.sender == owner || msg.sender == foundationOwner);\r\n                _;\r\n        }\r\n\r\n      \r\n}\r\n\r\ncontract Pausable is Ownable {\r\n        event ContractPause();\r\n        event ContractResume();\r\n        event ContractPauseSchedule(uint256 from, uint256 to);\r\n\r\n        uint256 internal pauseFrom;\r\n        uint256 internal pauseTo;\r\n\r\n        modifier whenRunning () {\r\n                require(now < pauseFrom || now > pauseTo);\r\n                _;\r\n        }\r\n\r\n        modifier whenPaused () {\r\n                require(now >= pauseFrom && now <= pauseTo);\r\n                _;\r\n        }\r\n\r\n        function pause () public onlyOwner {\r\n                pauseFrom = now - 1;\r\n                pauseTo = now + 30000 days;\r\n                emit ContractPause();\r\n        }\r\n\r\n        function pause (uint256 from, uint256 to) public onlyOwner {\r\n                require(to > from);\r\n                pauseFrom = from;\r\n                pauseTo = to;\r\n                emit ContractPauseSchedule(from, to);\r\n        }\r\n\r\n        function resume () public onlyOwner {\r\n                pauseFrom = now - 2;\r\n                pauseTo = now - 1;\r\n                emit ContractResume();\r\n        }\r\n}\r\n\r\ncontract TokenForge is Ownable {\r\n        event ForgeStart();\r\n        event ForgeStop();\r\n\r\n        bool public forge_running = true;\r\n\r\n        modifier canForge () {\r\n                require(forge_running);\r\n                _;\r\n        }\r\n\r\n        modifier cannotForge () {\r\n                require(!forge_running);\r\n                _;\r\n        }\r\n\r\n        function startForge () public onlyOwner cannotForge returns (bool) {\r\n                forge_running = true;\r\n                emit ForgeStart();\r\n                return true;\r\n        }\r\n\r\n        function stopForge () public onlyOwner canForge returns (bool) {\r\n                forge_running = false;\r\n                emit ForgeStop();\r\n                return true;\r\n        }\r\n}\r\n\r\ncontract CappedToken is Ownable {\r\n        using SafeMath for uint256;\r\n\r\n        uint256 public token_cap;\r\n        uint256 public token_created;\r\n        uint256 public token_foundation_cap;\r\n        uint256 public token_foundation_created;\r\n\r\n\r\n        constructor (uint256 _cap, uint256 _foundationCap) public {\r\n                token_cap = _cap;\r\n                token_foundation_cap = _foundationCap;\r\n        }\r\n\r\n        function changeCap (uint256 _cap) public onlyOwner returns (bool) {\r\n                if (_cap < token_created && _cap > 0) return false;\r\n                token_cap = _cap;\r\n                return true;\r\n        }\r\n\r\n        function canMint (uint256 amount) public view returns (bool) {\r\n                return (token_cap == 0) || (token_created.add(amount) <= token_cap);\r\n        }\r\n        \r\n        function canMintFoundation(uint256 amount) internal view returns(bool) {\r\n                return(token_foundation_created.add(amount) <= token_foundation_cap);\r\n        }\r\n}\r\n\r\ncontract BasicToken is ERCBasic, Pausable {\r\n        using SafeMath for uint256;\r\n\r\n        mapping(address => uint256) public wallets;\r\n\r\n        modifier canTransfer (address _from, address _to, uint256 amount) {\r\n                require((_from != address(0)) && (_to != address(0)));\r\n                require(_from != _to);\r\n                require(amount > 0);\r\n                _;\r\n        }\r\n\r\n        function balanceOf (address user) public view returns (uint256) {\r\n                return wallets[user];\r\n        }\r\n}\r\n\r\ncontract DelegatableToken is ERC, BasicToken {\r\n        using SafeMath for uint256;\r\n\r\n        mapping(address => mapping(address => uint256)) public warrants;\r\n\r\n        function allowance (address owner, address delegator) public view returns (uint256) {\r\n                return warrants[owner][delegator];\r\n        }\r\n\r\n        function approve (address delegator, uint256 value) public whenRunning returns (bool) {\r\n                if (delegator == msg.sender) return true;\r\n                warrants[msg.sender][delegator] = value;\r\n                emit Approval(msg.sender, delegator, value);\r\n                return true;\r\n        }\r\n\r\n        function increaseApproval (address delegator, uint256 delta) public whenRunning returns (bool) {\r\n                if (delegator == msg.sender) return true;\r\n                uint256 value = warrants[msg.sender][delegator].add(delta);\r\n                warrants[msg.sender][delegator] = value;\r\n                emit Approval(msg.sender, delegator, value);\r\n                return true;\r\n        }\r\n\r\n        function decreaseApproval (address delegator, uint256 delta) public whenRunning returns (bool) {\r\n                if (delegator == msg.sender) return true;\r\n                uint256 value = warrants[msg.sender][delegator];\r\n                if (value < delta) {\r\n                        value = 0;\r\n                }\r\n                else {\r\n                        value = value.sub(delta);\r\n                }\r\n                warrants[msg.sender][delegator] = value;\r\n                emit Approval(msg.sender, delegator, value);\r\n                return true;\r\n        }\r\n}\r\n\r\ncontract LockableProtocol is BasicToken {\r\n        function invest (address investor, uint256 amount) public returns (bool);\r\n        function getInvestedToken (address investor) public view returns (uint256);\r\n        function getLockedToken (address investor) public view returns (uint256);\r\n        function availableWallet (address user) public view returns (uint256) {\r\n                return wallets[user].sub(getLockedToken(user));\r\n        }\r\n}\r\n\r\ncontract MintAndBurnToken is TokenForge, CappedToken, LockableProtocol {\r\n        using SafeMath for uint256;\r\n        \r\n        event Mint(address indexed user, uint256 amount);\r\n        event Burn(address indexed user, uint256 amount);\r\n\r\n        constructor (uint256 _initial, uint256 _cap, uint256 _qnetCap) public CappedToken(_cap, _qnetCap) {\r\n                token_created = _initial;\r\n                wallets[msg.sender] = _initial;\r\n\r\n        emit Mint(msg.sender, _initial);\r\n        emit Transfer(address(0), msg.sender, _initial);\r\n        }\r\n\r\n        function totalSupply () public view returns (uint256) {\r\n                return token_created;\r\n        }\r\n\r\n        function totalQnetSupply() public view returns(uint256) {\r\n                return token_foundation_created;\r\n        }\r\n\r\n        function mint (address target, uint256 amount) public hasMintability whenRunning canForge returns (bool) {\r\n                require(target != owner && target != foundationOwner); // Owner和FoundationOwner不能成为mint的对象\r\n                require(canMint(amount));\r\n\r\n        if (msg.sender == foundationOwner) {\r\n                require(canMintFoundation(amount));\r\n                token_foundation_created = token_foundation_created.add(amount);\r\n        }\r\n        \r\n        token_created = token_created.add(amount);\r\n        wallets[target] = wallets[target].add(amount);\r\n\r\n        emit Mint(target, amount);\r\n        emit Transfer(address(0), target, amount);\r\n        return true;\r\n        }\r\n\r\n        function burn (uint256 amount) public whenRunning canForge returns (bool) {\r\n                uint256 balance = availableWallet(msg.sender);\r\n                require(amount <= balance);\r\n\r\n        token_created = token_created.sub(amount);\r\n        wallets[msg.sender] -= amount;\r\n\r\n        emit Burn(msg.sender, amount);\r\n        emit Transfer(msg.sender, address(0), amount);\r\n\r\n        return true;\r\n        }\r\n}\r\n\r\ncontract LockableToken is MintAndBurnToken, DelegatableToken {\r\n        using SafeMath for uint256;\r\n\r\n        struct LockBin {\r\n                uint256 start;\r\n                uint256 finish;\r\n                uint256 duration;\r\n                uint256 amount;\r\n        }\r\n\r\n        event InvestStart();\r\n        event InvestStop();\r\n        event NewInvest(uint256 release_start, uint256 release_duration);\r\n\r\n        uint256 public releaseStart;\r\n        uint256 public releaseDuration;\r\n        bool public forceStopInvest;\r\n        mapping(address => mapping(uint => LockBin)) public lockbins;\r\n\r\n        modifier canInvest () {\r\n                require(!forceStopInvest);\r\n                _;\r\n        }\r\n\r\n        constructor (uint256 _initial, uint256 _cap, uint256 _qnetCap) public MintAndBurnToken(_initial, _cap, _qnetCap) {\r\n                forceStopInvest = true;\r\n        }\r\n\r\n        function pauseInvest () public onlyOwner whenRunning returns (bool) {\r\n                require(!forceStopInvest);\r\n                forceStopInvest = true;\r\n                emit InvestStop();\r\n                return true;\r\n        }\r\n\r\n        function resumeInvest () public onlyOwner whenRunning returns (bool) {\r\n                require(forceStopInvest);\r\n                forceStopInvest = false;\r\n                emit InvestStart();\r\n                return true;\r\n        }\r\n\r\n        function setInvest (uint256 release_start, uint256 release_duration) public onlyOwner whenRunning returns (bool) {\r\n                releaseStart = release_start;\r\n                releaseDuration = release_duration;\r\n                forceStopInvest = false;\r\n\r\n        emit NewInvest(release_start, release_duration);\r\n        return true;\r\n        }\r\n\r\n        function invest (address investor, uint256 amount) public onlyOwner whenRunning canInvest returns (bool) {\r\n                require(investor != address(0));\r\n                require(investor != owner);\r\n                require(investor != foundationOwner);\r\n                require(amount > 0);\r\n                require(canMint(amount));\r\n\r\n        mapping(uint => LockBin) storage locks = lockbins[investor];\r\n        LockBin storage info = locks[0];\r\n        uint index = info.amount + 1;\r\n        locks[index] = LockBin({\r\n                start: releaseStart,\r\n                finish: releaseStart + releaseDuration,\r\n                duration: releaseDuration / (1 days),\r\n                amount: amount\r\n        });\r\n        info.amount = index;\r\n\r\n        token_created = token_created.add(amount);\r\n        wallets[investor] = wallets[investor].add(amount);\r\n        emit Mint(investor, amount);\r\n        emit Transfer(address(0), investor, amount);\r\n\r\n        return true;\r\n        }\r\n\r\n        function batchInvest (address[] memory investors, uint256 amount) public onlyOwner whenRunning canInvest returns (bool) {\r\n                require(amount > 0);\r\n\r\n        uint investorsLength = investors.length;\r\n        uint investorsCount = 0;\r\n        uint i;\r\n        address r;\r\n        for (i = 0; i < investorsLength; i ++) {\r\n                r = investors[i];\r\n                if (r == address(0) || r == owner || r == foundationOwner) continue;\r\n                investorsCount ++;\r\n        }\r\n        require(investorsCount > 0);\r\n\r\n        uint256 totalAmount = amount.mul(uint256(investorsCount));\r\n        require(canMint(totalAmount));\r\n\r\n        token_created = token_created.add(totalAmount);\r\n\r\n        for (i = 0; i < investorsLength; i ++) {\r\n                r = investors[i];\r\n                if (r == address(0) || r == owner || r == foundationOwner) continue;\r\n\r\n        mapping(uint => LockBin) storage locks = lockbins[r];\r\n        LockBin storage info = locks[0];\r\n        uint index = info.amount + 1;\r\n        locks[index] = LockBin({\r\n                start: releaseStart,\r\n                finish: releaseStart + releaseDuration,\r\n                duration: releaseDuration / (1 days),\r\n                amount: amount\r\n        });\r\n        info.amount = index;\r\n\r\n        wallets[r] = wallets[r].add(amount);\r\n        emit Mint(r, amount);\r\n        emit Transfer(address(0), r, amount);\r\n        }\r\n\r\n        return true;\r\n        }\r\n\r\n        function batchInvests (address[] memory investors, uint256[] memory amounts) public onlyOwner whenRunning canInvest returns (bool) {\r\n                uint investorsLength = investors.length;\r\n                require(investorsLength == amounts.length);\r\n\r\n        uint investorsCount = 0;\r\n        uint256 totalAmount = 0;\r\n        uint i;\r\n        address r;\r\n        for (i = 0; i < investorsLength; i ++) {\r\n                r = investors[i];\r\n                if (r == address(0) || r == owner) continue;\r\n                investorsCount ++;\r\n                totalAmount += amounts[i];\r\n        }\r\n        require(totalAmount > 0);\r\n        require(canMint(totalAmount));\r\n\r\n        uint256 amount;\r\n        token_created = token_created.add(totalAmount);\r\n        for (i = 0; i < investorsLength; i ++) {\r\n                r = investors[i];\r\n                if (r == address(0) || r == owner) continue;\r\n                amount = amounts[i];\r\n                wallets[r] = wallets[r].add(amount);\r\n                emit Mint(r, amount);\r\n                emit Transfer(address(0), r, amount);\r\n\r\n        mapping(uint => LockBin) storage locks = lockbins[r];\r\n        LockBin storage info = locks[0];\r\n        uint index = info.amount + 1;\r\n        locks[index] = LockBin({\r\n                start: releaseStart,\r\n                finish: releaseStart + releaseDuration,\r\n                duration: releaseDuration / (1 days),\r\n                amount: amount\r\n        });\r\n        info.amount = index;\r\n        }\r\n\r\n        return true;\r\n        }\r\n\r\n        function getInvestedToken (address investor) public view returns (uint256) {\r\n                require(investor != address(0) && investor != owner && investor != foundationOwner);\r\n\r\n        mapping(uint => LockBin) storage locks = lockbins[investor];\r\n        uint256 balance = 0;\r\n        uint l = locks[0].amount;\r\n        for (uint i = 1; i <= l; i ++) {\r\n                LockBin memory bin = locks[i];\r\n                balance = balance.add(bin.amount);\r\n        }\r\n        return balance;\r\n        }\r\n\r\n        function getLockedToken (address investor) public view returns (uint256) {\r\n                require(investor != address(0) && investor != owner && investor != foundationOwner);\r\n\r\n        mapping(uint => LockBin) storage locks = lockbins[investor];\r\n        uint256 balance = 0;\r\n        uint256 d = 1;\r\n        uint l = locks[0].amount;\r\n        for (uint i = 1; i <= l; i ++) {\r\n                LockBin memory bin = locks[i];\r\n                if (now <= bin.start) {\r\n                        balance = balance.add(bin.amount);\r\n                }\r\n                else if (now < bin.finish) {\r\n                        d = (now - bin.start) / (1 days);\r\n                        balance = balance.add(bin.amount - bin.amount * d / bin.duration);\r\n                }\r\n        }\r\n        return balance;\r\n        }\r\n\r\n        function canPay (address user, uint256 amount) internal view returns (bool) {\r\n                uint256 balance = availableWallet(user);\r\n                return amount <= balance;\r\n        }\r\n\r\n        function transfer (address target, uint256 value) public whenRunning canTransfer(msg.sender, target, value) returns (bool) {\r\n                require(target != owner);\r\n                require(canPay(msg.sender, value));\r\n\r\n        wallets[msg.sender] = wallets[msg.sender].sub(value);\r\n        wallets[target] = wallets[target].add(value);\r\n        emit Transfer(msg.sender, target, value);\r\n        return true;\r\n        }\r\n\r\n\r\n        function batchTransfer (address[] memory receivers, uint256 amount) public whenRunning returns (bool) {\r\n                require(amount > 0);\r\n\r\n        uint receiveLength = receivers.length;\r\n        uint receiverCount = 0;\r\n        uint i;\r\n        address r;\r\n        for (i = 0; i < receiveLength; i ++) {\r\n                r = receivers[i];\r\n                if (r == address(0) || r == owner) continue;\r\n                receiverCount ++;\r\n        }\r\n        require(receiverCount > 0);\r\n\r\n        uint256 totalAmount = amount.mul(uint256(receiverCount));\r\n        require(canPay(msg.sender, totalAmount));\r\n\r\n        wallets[msg.sender] -= totalAmount;\r\n        for (i = 0; i < receiveLength; i++) {\r\n                r = receivers[i];\r\n                if (r == address(0) || r == owner) continue;\r\n                wallets[r] = wallets[r].add(amount);\r\n                emit Transfer(msg.sender, r, amount);\r\n        }\r\n        return true;\r\n        }\r\n\r\n        function batchTransfers (address[] memory receivers, uint256[] memory amounts) public whenRunning returns (bool) {\r\n                uint receiveLength = receivers.length;\r\n                require(receiveLength == amounts.length);\r\n\r\n        uint receiverCount = 0;\r\n        uint256 totalAmount = 0;\r\n        uint i;\r\n        address r;\r\n        for (i = 0; i < receiveLength; i ++) {\r\n                r = receivers[i];\r\n                if (r == address(0) || r == owner) continue;\r\n                receiverCount ++;\r\n                totalAmount += amounts[i];\r\n        }\r\n        require(totalAmount > 0);\r\n        require(canPay(msg.sender, totalAmount));\r\n\r\n        wallets[msg.sender] -= totalAmount;\r\n        uint256 amount;\r\n        for (i = 0; i < receiveLength; i++) {\r\n                r = receivers[i];\r\n                if (r == address(0) || r == owner) continue;\r\n                amount = amounts[i];\r\n                if (amount == 0) continue;\r\n                wallets[r] = wallets[r].add(amount);\r\n                emit Transfer(msg.sender, r, amount);\r\n        }\r\n        return true;\r\n        }\r\n\r\n        function transferFrom (address from, address to, uint256 value) public whenRunning canTransfer(from, to, value) returns (bool) {\r\n                require(from != owner);\r\n                require(to != owner);\r\n                require(canPay(from, value));\r\n\r\n        uint256 warrant;\r\n        if (msg.sender != from) {\r\n                warrant = warrants[from][msg.sender];\r\n                require(value <= warrant);\r\n                warrants[from][msg.sender] = warrant.sub(value);\r\n        }\r\n\r\n        wallets[from] = wallets[from].sub(value);\r\n        wallets[to] = wallets[to].add(value);\r\n        emit Transfer(from, to, value);\r\n        return true;\r\n        }\r\n\r\n        function batchTransferFrom (address from, address[] memory  receivers, uint256 amount) public whenRunning returns (bool) {\r\n                require(from != address(0) && from != owner);\r\n                require(amount > 0);\r\n\r\n        uint receiveLength = receivers.length;\r\n        uint receiverCount = 0;\r\n        uint i;\r\n        address r;\r\n        for (i = 0; i < receiveLength; i ++) {\r\n                r = receivers[i];\r\n                if (r == address(0) || r == owner) continue;\r\n                receiverCount ++;\r\n        }\r\n        require(receiverCount > 0);\r\n\r\n        uint256 totalAmount = amount.mul(uint256(receiverCount));\r\n        require(canPay(from, totalAmount));\r\n\r\n        uint256 warrant;\r\n        if (msg.sender != from) {\r\n                warrant = warrants[from][msg.sender];\r\n                require(totalAmount <= warrant);\r\n                warrants[from][msg.sender] = warrant.sub(totalAmount);\r\n        }\r\n\r\n        wallets[from] -= totalAmount;\r\n        for (i = 0; i < receiveLength; i++) {\r\n                r = receivers[i];\r\n                if (r == address(0) || r == owner) continue;\r\n                wallets[r] = wallets[r].add(amount);\r\n                emit Transfer(from, r, amount);\r\n        }\r\n        return true;\r\n        }\r\n\r\n        function batchTransferFroms (address from, address[] memory receivers, uint256[] memory amounts) public whenRunning returns (bool) {\r\n                require(from != address(0) && from != owner);\r\n\r\n        uint receiveLength = receivers.length;\r\n        require(receiveLength == amounts.length);\r\n\r\n        uint receiverCount = 0;\r\n        uint256 totalAmount = 0;\r\n        uint i;\r\n        address r;\r\n        for (i = 0; i < receiveLength; i ++) {\r\n                r = receivers[i];\r\n                if (r == address(0) || r == owner) continue;\r\n                receiverCount ++;\r\n                totalAmount += amounts[i];\r\n        }\r\n        require(totalAmount > 0);\r\n        require(canPay(from, totalAmount));\r\n\r\n        uint256 warrant;\r\n        if (msg.sender != from) {\r\n                warrant = warrants[from][msg.sender];\r\n                require(totalAmount <= warrant);\r\n                warrants[from][msg.sender] = warrant.sub(totalAmount);\r\n        }\r\n\r\n        wallets[from] -= totalAmount;\r\n        uint256 amount;\r\n        for (i = 0; i < receiveLength; i++) {\r\n                r = receivers[i];\r\n                if (r == address(0) || r == owner) continue;\r\n                amount = amounts[i];\r\n                if (amount == 0) continue;\r\n                wallets[r] = wallets[r].add(amount);\r\n                emit Transfer(from, r, amount);\r\n        }\r\n        return true;\r\n        }\r\n}\r\n\r\ncontract QnetToken is LockableToken {\r\n        string  public constant name     = \"Quota Network\";\r\n        string  public constant symbol   = \"QNET\";\r\n        uint8   public constant decimals = 18;\r\n\r\n        uint256 private constant TOKEN_CAP     = 180000000 * 10 ** uint256(decimals);\r\n        uint256 private constant TOKEN_FOUNDATION_CAP = 180000000   * 10 ** uint256(decimals);\r\n        uint256 private constant TOKEN_INITIAL = 0   * 10 ** uint256(decimals);\r\n\r\n        constructor () public LockableToken(TOKEN_INITIAL, TOKEN_CAP, TOKEN_FOUNDATION_CAP) {\r\n        }\r\n\r\n        \r\n \t    function suicideQent () public onlyOwner{\r\n             selfdestruct(owner);\r\n        }\r\n        \r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delegator\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receivers\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransfers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"release_start\",\"type\":\"uint256\"},{\"name\":\"release_duration\",\"type\":\"uint256\"}],\"name\":\"setInvest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startForge\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"forge_running\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resumeInvest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lockbins\",\"outputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"finish\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"getLockedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"receivers\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferFroms\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"canMint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delegator\",\"type\":\"address\"},{\"name\":\"delta\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investors\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchInvests\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"releaseStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"receivers\",\"type\":\"address[]\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"batchTransferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"changeCap\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receivers\",\"type\":\"address[]\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"batchTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalQnetSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"wallets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"suicideQent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"warrants\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"forceStopInvest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"getInvestedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseInvest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopForge\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investors\",\"type\":\"address[]\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"batchInvest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token_foundation_cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token_foundation_created\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"availableWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delegator\",\"type\":\"address\"},{\"name\":\"delta\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"delegator\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token_created\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token_cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"releaseDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"InvestStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"InvestStop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"release_start\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"release_duration\",\"type\":\"uint256\"}],\"name\":\"NewInvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ContractPause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ContractResume\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"ContractPauseSchedule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ForgeStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ForgeStop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"QnetToken","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a790ad8e0bc72c51222fd8dc597cd230b0bdb29c24d537ff4befc0a5f75469d7"}]}