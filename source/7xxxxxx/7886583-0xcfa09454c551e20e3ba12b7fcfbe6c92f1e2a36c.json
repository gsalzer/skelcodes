{"status":"1","message":"OK","result":[{"SourceCode":"/* Copyright (C) DeFiner Inc - All Rights Reserved\r\n * Unauthorized copying of this file, via any medium is strictly prohibited\r\n */\r\n\r\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20Basic.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\SafeERC20.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    assert(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    assert(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    assert(token.approve(spender, value));\r\n  }\r\n}\r\n\r\n// File: node_modules\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\BasicToken.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\StandardToken.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC721\\ERC721Basic.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Basic {\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function getApproved(uint256 _tokenId) public view returns (address _operator);\r\n\r\n  function setApprovalForAll(address _operator, bool _approved) public;\r\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public;\r\n}\r\n\r\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC721\\ERC721Receiver.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n *  from ERC721 asset contracts.\r\n */\r\ncontract ERC721Receiver {\r\n  /**\r\n   * @dev Magic value to be returned upon successful reception of an NFT\r\n   *  Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`,\r\n   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n   */\r\n  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n  /**\r\n   * @notice Handle the receipt of an NFT\r\n   * @dev The ERC721 smart contract calls this function on the recipient\r\n   *  after a `safetransfer`. This function MAY throw to revert and reject the\r\n   *  transfer. This function MUST use 50,000 gas or less. Return of other\r\n   *  than the magic value MUST result in the transaction being reverted.\r\n   *  Note: the contract address is always the message sender.\r\n   * @param _from The sending address\r\n   * @param _tokenId The NFT identifier which is being transfered\r\n   * @param _data Additional data with no specified format\r\n   * @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n   */\r\n  function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns(bytes4);\r\n}\r\n\r\n// File: node_modules\\openzeppelin-solidity\\contracts\\AddressUtils.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   *  as the code is not actually created until after the constructor finishes.\r\n   * @param addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC721\\ERC721BasicToken.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721BasicToken is ERC721Basic {\r\n  using SafeMath for uint256;\r\n  using AddressUtils for address;\r\n\r\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n  // Mapping from token ID to owner\r\n  mapping (uint256 => address) internal tokenOwner;\r\n\r\n  // Mapping from token ID to approved address\r\n  mapping (uint256 => address) internal tokenApprovals;\r\n\r\n  // Mapping from owner to number of owned token\r\n  mapping (address => uint256) internal ownedTokensCount;\r\n\r\n  // Mapping from owner to operator approvals\r\n  mapping (address => mapping (address => bool)) internal operatorApprovals;\r\n\r\n  /**\r\n   * @dev Guarantees msg.sender is owner of the given token\r\n   * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\r\n   */\r\n  modifier onlyOwnerOf(uint256 _tokenId) {\r\n    require(ownerOf(_tokenId) == msg.sender);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\r\n   * @param _tokenId uint256 ID of the token to validate\r\n   */\r\n  modifier canTransfer(uint256 _tokenId) {\r\n    require(isApprovedOrOwner(msg.sender, _tokenId));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the balance of the specified address\r\n   * @param _owner address to query the balance of\r\n   * @return uint256 representing the amount owned by the passed address\r\n   */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    require(_owner != address(0));\r\n    return ownedTokensCount[_owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the owner of the specified token ID\r\n   * @param _tokenId uint256 ID of the token to query the owner of\r\n   * @return owner address currently marked as the owner of the given token ID\r\n   */\r\n  function ownerOf(uint256 _tokenId) public view returns (address) {\r\n    address owner = tokenOwner[_tokenId];\r\n    require(owner != address(0));\r\n    return owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether the specified token exists\r\n   * @param _tokenId uint256 ID of the token to query the existance of\r\n   * @return whether the token exists\r\n   */\r\n  function exists(uint256 _tokenId) public view returns (bool) {\r\n    address owner = tokenOwner[_tokenId];\r\n    return owner != address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Approves another address to transfer the given token ID\r\n   * @dev The zero address indicates there is no approved address.\r\n   * @dev There can only be one approved address per token at a given time.\r\n   * @dev Can only be called by the token owner or an approved operator.\r\n   * @param _to address to be approved for the given token ID\r\n   * @param _tokenId uint256 ID of the token to be approved\r\n   */\r\n  function approve(address _to, uint256 _tokenId) public {\r\n    address owner = ownerOf(_tokenId);\r\n    require(_to != owner);\r\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n    if (getApproved(_tokenId) != address(0) || _to != address(0)) {\r\n      tokenApprovals[_tokenId] = _to;\r\n      emit Approval(owner, _to, _tokenId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the approved address for a token ID, or zero if no address set\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return address currently approved for a the given token ID\r\n   */\r\n  function getApproved(uint256 _tokenId) public view returns (address) {\r\n    return tokenApprovals[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Sets or unsets the approval of a given operator\r\n   * @dev An operator is allowed to transfer all tokens of the sender on their behalf\r\n   * @param _to operator address to set the approval\r\n   * @param _approved representing the status of the approval to be set\r\n   */\r\n  function setApprovalForAll(address _to, bool _approved) public {\r\n    require(_to != msg.sender);\r\n    operatorApprovals[msg.sender][_to] = _approved;\r\n    emit ApprovalForAll(msg.sender, _to, _approved);\r\n  }\r\n\r\n  /**\r\n   * @dev Tells whether an operator is approved by a given owner\r\n   * @param _owner owner address which you want to query the approval of\r\n   * @param _operator operator address which you want to query the approval of\r\n   * @return bool whether the given operator is approved by the given owner\r\n   */\r\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\r\n    return operatorApprovals[_owner][_operator];\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers the ownership of a given token ID to another address\r\n   * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n   * @dev Requires the msg sender to be the owner, approved, or operator\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {\r\n    require(_from != address(0));\r\n    require(_to != address(0));\r\n\r\n    clearApproval(_from, _tokenId);\r\n    removeTokenFrom(_from, _tokenId);\r\n    addTokenTo(_to, _tokenId);\r\n\r\n    emit Transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers the ownership of a given token ID to another address\r\n   * @dev If the target address is a contract, it must implement `onERC721Received`,\r\n   *  which is called upon a safe transfer, and return the magic value\r\n   *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\r\n   *  the transfer is reverted.\r\n   * @dev Requires the msg sender to be the owner, approved, or operator\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    public\r\n    canTransfer(_tokenId)\r\n  {\r\n    // solium-disable-next-line arg-overflow\r\n    safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers the ownership of a given token ID to another address\r\n   * @dev If the target address is a contract, it must implement `onERC721Received`,\r\n   *  which is called upon a safe transfer, and return the magic value\r\n   *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\r\n   *  the transfer is reverted.\r\n   * @dev Requires the msg sender to be the owner, approved, or operator\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   * @param _data bytes data to send along with a safe transfer check\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public\r\n    canTransfer(_tokenId)\r\n  {\r\n    transferFrom(_from, _to, _tokenId);\r\n    // solium-disable-next-line arg-overflow\r\n    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether the given spender can transfer a given token ID\r\n   * @param _spender address of the spender to query\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   * @return bool whether the msg.sender is approved for the given token ID,\r\n   *  is an operator of the owner, or is the owner of the token\r\n   */\r\n  function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\r\n    address owner = ownerOf(_tokenId);\r\n    return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to mint a new token\r\n   * @dev Reverts if the given token ID already exists\r\n   * @param _to The address that will own the minted token\r\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n   */\r\n  function _mint(address _to, uint256 _tokenId) internal {\r\n    require(_to != address(0));\r\n    addTokenTo(_to, _tokenId);\r\n    emit Transfer(address(0), _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to burn a specific token\r\n   * @dev Reverts if the token does not exist\r\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n   */\r\n  function _burn(address _owner, uint256 _tokenId) internal {\r\n    clearApproval(_owner, _tokenId);\r\n    removeTokenFrom(_owner, _tokenId);\r\n    emit Transfer(_owner, address(0), _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to clear current approval of a given token ID\r\n   * @dev Reverts if the given address is not indeed the owner of the token\r\n   * @param _owner owner of the token\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   */\r\n  function clearApproval(address _owner, uint256 _tokenId) internal {\r\n    require(ownerOf(_tokenId) == _owner);\r\n    if (tokenApprovals[_tokenId] != address(0)) {\r\n      tokenApprovals[_tokenId] = address(0);\r\n      emit Approval(_owner, address(0), _tokenId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to add a token ID to the list of a given address\r\n   * @param _to address representing the new owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n   */\r\n  function addTokenTo(address _to, uint256 _tokenId) internal {\r\n    require(tokenOwner[_tokenId] == address(0));\r\n    tokenOwner[_tokenId] = _to;\r\n    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to remove a token ID from the list of a given address\r\n   * @param _from address representing the previous owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n   */\r\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n    require(ownerOf(_tokenId) == _from);\r\n    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\r\n    tokenOwner[_tokenId] = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to invoke `onERC721Received` on a target address\r\n   * @dev The call is not executed if the target address is not a contract\r\n   * @param _from address representing the previous owner of the given token ID\r\n   * @param _to target address that will receive the tokens\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   * @param _data bytes optional data to send along with the call\r\n   * @return whether the call correctly returned the expected magic value\r\n   */\r\n  function checkAndCallSafeTransfer(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    internal\r\n    returns (bool)\r\n  {\r\n    if (!_to.isContract()) {\r\n      return true;\r\n    }\r\n    bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);\r\n    return (retval == ERC721_RECEIVED);\r\n  }\r\n}\r\n\r\n// File: contracts\\Strings.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\nlibrary Strings {\r\n  // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\r\n  function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\r\n    bytes memory _ba = bytes(_a);\r\n    bytes memory _bb = bytes(_b);\r\n    bytes memory _bc = bytes(_c);\r\n    bytes memory _bd = bytes(_d);\r\n    bytes memory _be = bytes(_e);\r\n    string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n    bytes memory babcde = bytes(abcde);\r\n    uint k = 0;\r\n    for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n    for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n    for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n    for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n    for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n    return string(babcde);\r\n  }\r\n\r\n  function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\r\n    return strConcat(_a, _b, _c, _d, \"\");\r\n  }\r\n\r\n  function strConcat(string _a, string _b, string _c) internal pure returns (string) {\r\n    return strConcat(_a, _b, _c, \"\", \"\");\r\n  }\r\n\r\n  function strConcat(string _a, string _b) internal pure returns (string) {\r\n    return strConcat(_a, _b, \"\", \"\", \"\");\r\n  }\r\n\r\n  function uint2str(uint i) internal pure returns (string) {\r\n    if (i == 0) return \"0\";\r\n    uint j = i;\r\n    uint len;\r\n    while (j != 0){\r\n      len++;\r\n      j /= 10;\r\n    }\r\n    bytes memory bstr = new bytes(len);\r\n    uint k = len - 1;\r\n    while (i != 0){\r\n      bstr[k--] = byte(48 + i % 10);\r\n      i /= 10;\r\n    }\r\n    return string(bstr);\r\n  }\r\n}\r\n\r\n// File: contracts\\DefinerBasicLoan.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n  /// @notice A descriptive name for a collection of NFTs in this contract\r\n  function name() external view returns (string _name);\r\n\r\n  /// @notice An abbreviated name for NFTs in this contract\r\n  function symbol() external view returns (string _symbol);\r\n\r\n  /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n  /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n  ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n  ///  Metadata JSON Schema\".\r\n  function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\ncontract DefinerBasicLoan is ERC721BasicToken, ERC721Metadata {\r\n  using SafeERC20 for ERC20;\r\n  using SafeMath for uint;\r\n\r\n  enum States {\r\n    Init,                 //0\r\n    WaitingForLender,     //1\r\n    WaitingForBorrower,   //2\r\n    WaitingForCollateral, //3\r\n    WaitingForFunds,      //4\r\n    Funded,               //5\r\n    Finished,             //6\r\n    Closed,               //7\r\n    Default,              //8\r\n    Cancelled             //9\r\n  }\r\n\r\n  address public ownerAddress;\r\n  address public borrowerAddress;\r\n  address public lenderAddress;\r\n  string public loanId;\r\n  uint public endTime;  // use to check default\r\n  uint public nextPaymentDateTime; // use to check default\r\n  uint public daysPerInstallment; // use to calculate next payment date\r\n  uint public totalLoanTerm; // in days\r\n  uint public borrowAmount; // total borrowed amount\r\n  uint public collateralAmount; // total collateral amount\r\n  uint public installmentAmount; // amount of each installment\r\n  uint public remainingInstallment; // total installment left\r\n\r\n  States public currentState = States.Init;\r\n\r\n  /**\r\n   * TODO: change address below to actual factory address after deployment\r\n   *       address constant private factoryContract = 0x...\r\n   */\r\n  address internal factoryContract; // = 0x38Bddc3793DbFb3dE178E3dE74cae2E223c02B85;\r\n  modifier onlyFactoryContract() {\r\n      require(factoryContract == 0 || msg.sender == factoryContract, \"not factory contract\");\r\n      _;\r\n  }\r\n\r\n  modifier atState(States state) {\r\n    require(state == currentState, \"Invalid State\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == ownerAddress, \"Invalid Owner Address\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyLender() {\r\n    require(msg.sender == lenderAddress || msg.sender == factoryContract, \"Invalid Lender Address\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyBorrower() {\r\n    require(msg.sender == borrowerAddress || msg.sender == factoryContract, \"Invalid Borrower Address\");\r\n    _;\r\n  }\r\n\r\n  modifier notDefault() {\r\n    require(now < nextPaymentDateTime, \"This Contract has not yet default\");\r\n    require(now < endTime, \"This Contract has not yet default\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * ERC721 Interface\r\n   */\r\n\r\n  function name() public view returns (string _name)\r\n  {\r\n    return \"DeFiner Contract\";\r\n  }\r\n\r\n  function symbol() public view returns (string _symbol)\r\n  {\r\n    return \"DFINC\";\r\n  }\r\n\r\n  function tokenURI(uint256) public view returns (string)\r\n  {\r\n    return Strings.strConcat(\r\n      \"https://api.definer.org/OKh4I2yYpKU8S2af/definer/api/v1.0/opensea/\",\r\n      loanId\r\n    );\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public {\r\n    require(_from != address(0));\r\n    require(_to != address(0));\r\n\r\n    super.transferFrom(_from, _to, _tokenId);\r\n    lenderAddress = tokenOwner[_tokenId];\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n  public\r\n  {\r\n    // solium-disable-next-line arg-overflow\r\n    safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    lenderAddress = tokenOwner[_tokenId];\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n  public\r\n  {\r\n    transferFrom(_from, _to, _tokenId);\r\n    // solium-disable-next-line arg-overflow\r\n    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\r\n    lenderAddress = tokenOwner[_tokenId];\r\n  }\r\n\r\n\r\n  /**\r\n   * Borrower transfer ETH to contract\r\n   */\r\n  function transferCollateral() public payable /*atState(States.WaitingForCollateral)*/;\r\n\r\n  /**\r\n   * Check if borrower transferred correct amount of Token\r\n   */\r\n  function checkCollateral() public /*atState(States.WaitingForCollateral)*/;\r\n\r\n  /**\r\n  *  Borrower cancel the transaction is Default\r\n  */\r\n  function borrowerCancel() public /*onlyLender atState(States.WaitingForLender)*/;\r\n\r\n  /**\r\n  *  Lender cancel the transaction is Default\r\n  */\r\n  function lenderCancel() public /*onlyLender atState(States.WaitingForBorrower)*/;\r\n\r\n  /**\r\n   * Lender transfer ETH to contract\r\n   */\r\n  function transferFunds() public payable /*atState(States.WaitingForFunds)*/;\r\n\r\n  /**\r\n   * Check if lender transferred correct amount of Token\r\n   */\r\n  function checkFunds() public /*atState(States.WaitingForFunds)*/;\r\n\r\n  /**\r\n   *  Borrower pay back ETH or Token\r\n   */\r\n  function borrowerMakePayment() public payable /*onlyBorrower atState(States.Funded) notDefault*/;\r\n\r\n  /**\r\n   *  Borrower gets collateral back\r\n   */\r\n  function borrowerReclaimCollateral() public /*onlyBorrower atState(States.Finished)*/;\r\n\r\n  /**\r\n   *  Lender gets collateral when contract state is Default\r\n   */\r\n  function lenderReclaimCollateral() public /*onlyLender atState(States.Default)*/;\r\n\r\n\r\n  /**\r\n  * Borrower accept loan\r\n  */\r\n  function borrowerAcceptLoan() public atState(States.WaitingForBorrower) {\r\n    require(msg.sender != address(0), \"Invalid address.\");\r\n    borrowerAddress = msg.sender;\r\n    currentState = States.WaitingForCollateral;\r\n  }\r\n\r\n  /**\r\n   * Lender accept loan\r\n   */\r\n  function lenderAcceptLoan() public atState(States.WaitingForLender) {\r\n    require(msg.sender != address(0), \"Invalid address.\");\r\n    lenderAddress = msg.sender;\r\n    currentState = States.WaitingForFunds;\r\n  }\r\n\r\n  function transferETHToBorrowerAndStartLoan() internal {\r\n    borrowerAddress.transfer(borrowAmount);\r\n    endTime = now.add(totalLoanTerm.mul(1 days));\r\n    nextPaymentDateTime = now.add(daysPerInstallment.mul(1 days));\r\n    currentState = States.Funded;\r\n  }\r\n\r\n  function transferTokenToBorrowerAndStartLoan(StandardToken token) internal {\r\n    require(token.transfer(borrowerAddress, borrowAmount), \"Token transfer failed\");\r\n    endTime = now.add(totalLoanTerm.mul(1 days));\r\n    nextPaymentDateTime = now.add(daysPerInstallment.mul(1 days));\r\n    currentState = States.Funded;\r\n  }\r\n\r\n  //TODO not in use yet\r\n  function checkDefault() public onlyLender atState(States.Funded) returns (bool) {\r\n    if (now > endTime || now > nextPaymentDateTime) {\r\n      currentState = States.Default;\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // For testing\r\n  function forceDefault() public onlyOwner {\r\n    currentState = States.Default;\r\n  }\r\n\r\n  function getLoanDetails() public view returns (address,address,address,string,uint,uint,uint,uint,uint,uint,uint,uint,uint) {\r\n//    address public ownerAddress;\r\n//    address public borrowerAddress;\r\n//    address public lenderAddress;\r\n//    string public loanId;\r\n//    uint public endTime;  // use to check default\r\n//    uint public nextPaymentDateTime; // use to check default\r\n//    uint public daysPerInstallment; // use to calculate next payment date\r\n//    uint public totalLoanTerm; // in days\r\n//    uint public borrowAmount; // total borrowed amount\r\n//    uint public collateralAmount; // total collateral amount\r\n//    uint public installmentAmount; // amount of each installment\r\n//    uint public remainingInstallment; // total installment left\r\n//    States public currentState = States.Init;\r\n//\r\n//    return (\r\n//      nextPaymentDateTime,\r\n//      remainingInstallment,\r\n//      uint(currentState),\r\n//      loanId,\r\n//      borrowerAddress,\r\n//      lenderAddress\r\n//    );\r\n    return (\r\n      ownerAddress,\r\n      borrowerAddress,\r\n      lenderAddress,\r\n      loanId,\r\n      endTime,\r\n      nextPaymentDateTime,\r\n      daysPerInstallment,\r\n      totalLoanTerm,\r\n      borrowAmount,\r\n      collateralAmount,\r\n      installmentAmount,\r\n      remainingInstallment,\r\n      uint(currentState)\r\n    );\r\n  }\r\n}\r\n\r\n// File: contracts\\ERC20ETHLoan.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * Collateral: ERC20 Token\r\n * Borrowed: ETH\r\n */\r\ncontract ERC20ETHLoan is DefinerBasicLoan {\r\n\r\n  StandardToken token;\r\n  address public collateralTokenAddress;\r\n\r\n  /**\r\n   * NOT IN USE\r\n   * WHEN COLLATERAL IS TOKEN, TRANSFER IS DONE IN FRONT END\r\n   */\r\n  function transferCollateral() public payable {\r\n    revert();\r\n  }\r\n\r\n  function establishContract() public {\r\n\r\n    // ERC20 as collateral\r\n    uint amount = token.balanceOf(address(this));\r\n    require(amount >= collateralAmount, \"Insufficient collateral amount\");\r\n\r\n    // Ether as Fund\r\n    require(address(this).balance >= borrowAmount, \"Insufficient fund amount\");\r\n\r\n    // Transit to Funded state\r\n    transferETHToBorrowerAndStartLoan();\r\n  }\r\n\r\n  /**\r\n   * NOT IN USE\r\n   * WHEN FUND IS ETH, CHECK IS DONE IN transferFunds()\r\n   */\r\n  function checkFunds() onlyLender atState(States.WaitingForFunds) public {\r\n    return establishContract();\r\n  }\r\n\r\n  /**\r\n   * Check if borrower transferred correct amount of token to this contract\r\n   */\r\n  function checkCollateral() public onlyBorrower atState(States.WaitingForCollateral) {\r\n    uint amount = token.balanceOf(address(this));\r\n    require(amount >= collateralAmount, \"Insufficient collateral amount\");\r\n    currentState = States.WaitingForLender;\r\n  }\r\n\r\n  /**\r\n   *  Lender transfer ETH to fund this contract\r\n   */\r\n  function transferFunds() public payable onlyLender atState(States.WaitingForFunds) {\r\n    if (address(this).balance >= borrowAmount) {\r\n      establishContract();\r\n    }\r\n  }\r\n\r\n  /*\r\n   *  Borrower pay back ETH\r\n   */\r\n  function borrowerMakePayment() public payable onlyBorrower atState(States.Funded) notDefault {\r\n    require(msg.value >= installmentAmount);\r\n    remainingInstallment--;\r\n    lenderAddress.transfer(installmentAmount);\r\n    if (remainingInstallment == 0) {\r\n      currentState = States.Finished;\r\n    } else {\r\n      nextPaymentDateTime = nextPaymentDateTime.add(daysPerInstallment.mul(1 days));\r\n    }\r\n  }\r\n\r\n  /*\r\n   *  Borrower gets collateral token back when contract completed\r\n   */\r\n  function borrowerReclaimCollateral() public onlyBorrower atState(States.Finished) {\r\n    uint amount = token.balanceOf(address(this));\r\n    token.transfer(borrowerAddress, amount);\r\n    currentState = States.Closed;\r\n  }\r\n\r\n  /*\r\n   *  Lender gets collateral token when contract defaulted\r\n   */\r\n  function lenderReclaimCollateral() public onlyLender atState(States.Default) {\r\n    uint amount = token.balanceOf(address(this));\r\n    token.transfer(lenderAddress, amount);\r\n    currentState = States.Closed;\r\n  }\r\n}\r\n\r\n// File: contracts\\ERC20ETHLoanBorrower.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * Collateral: ERC20 Token\r\n * Borrowed: ETH\r\n */\r\ncontract ERC20ETHLoanBorrower is ERC20ETHLoan {\r\n  function init (\r\n    address _ownerAddress,\r\n    address _borrowerAddress,\r\n    address _lenderAddress,\r\n    address _collateralTokenAddress,\r\n    uint _borrowAmount,\r\n    uint _paybackAmount,\r\n    uint _collateralAmount,\r\n    uint _daysPerInstallment,\r\n    uint _remainingInstallment,\r\n    string _loanId\r\n  ) public onlyFactoryContract {\r\n    require(_collateralTokenAddress != address(0), \"Invalid token address\");\r\n    require(_borrowerAddress != address(0), \"Invalid lender address\");\r\n    require(_lenderAddress != address(0), \"Invalid lender address\");\r\n    require(_remainingInstallment > 0, \"Invalid number of installments\");\r\n    require(_borrowAmount > 0, \"Borrow amount must not be 0\");\r\n    require(_paybackAmount > 0, \"Payback amount must not be 0\");\r\n    require(_collateralAmount > 0, \"Collateral amount must not be 0\");\r\n    super._mint(_lenderAddress, 1);\r\n    factoryContract = msg.sender;\r\n    ownerAddress = _ownerAddress;\r\n    loanId = _loanId;\r\n    collateralTokenAddress = _collateralTokenAddress;\r\n    borrowAmount = _borrowAmount;\r\n    collateralAmount = _collateralAmount;\r\n    totalLoanTerm = _remainingInstallment * _daysPerInstallment;\r\n    daysPerInstallment = _daysPerInstallment;\r\n    remainingInstallment = _remainingInstallment;\r\n    installmentAmount = _paybackAmount / _remainingInstallment;\r\n    token = StandardToken(_collateralTokenAddress);\r\n    borrowerAddress = _borrowerAddress;\r\n    lenderAddress = _lenderAddress;\r\n\r\n    // initialial state for borrower initiated ERC20 flow\r\n    currentState = States.WaitingForCollateral;\r\n  }\r\n\r\n  /**\r\n   * NOT IN USE\r\n   * WHEN FUND IS ETH, CHECK IS DONE IN transferFunds()\r\n   */\r\n  function checkFunds() onlyLender atState(States.WaitingForFunds) public {\r\n    return establishContract();\r\n  }\r\n\r\n  /**\r\n   * Check if borrower transferred correct amount of token to this contract\r\n   */\r\n  function checkCollateral() public onlyBorrower atState(States.WaitingForCollateral) {\r\n    uint amount = token.balanceOf(address(this));\r\n    require(amount >= collateralAmount, \"Insufficient collateral amount\");\r\n    currentState = States.WaitingForFunds;\r\n  }\r\n\r\n  /**\r\n   *  Lender transfer ETH to fund this contract\r\n   */\r\n  function transferFunds() public payable onlyLender atState(States.WaitingForFunds) {\r\n    if (address(this).balance >= borrowAmount) {\r\n      establishContract();\r\n    }\r\n  }\r\n\r\n  /*\r\n   *  Borrower gets collateral token back when contract completed\r\n   */\r\n  function borrowerCancel() public onlyBorrower atState(States.WaitingForFunds) {\r\n    uint amount = token.balanceOf(address(this));\r\n    token.transfer(borrowerAddress, amount);\r\n    currentState = States.Cancelled;\r\n  }\r\n\r\n  /*\r\n   *  Lender gets funds token back when contract is cancelled\r\n   */\r\n  function lenderCancel() public onlyLender atState(States.WaitingForCollateral) {\r\n    // For ETH leader, no way to cancel\r\n    revert();\r\n  }\r\n}\r\n\r\n// File: contracts\\ERC20ETHLoanLender.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * Collateral: ERC20 Token\r\n * Borrowed: ETH\r\n */\r\ncontract ERC20ETHLoanLender is ERC20ETHLoan {\r\n  function init (\r\n    address _ownerAddress,\r\n    address _borrowerAddress,\r\n    address _lenderAddress,\r\n    address _collateralTokenAddress,\r\n    uint _borrowAmount,\r\n    uint _paybackAmount,\r\n    uint _collateralAmount,\r\n    uint _daysPerInstallment,\r\n    uint _remainingInstallment,\r\n    string _loanId\r\n  ) public onlyFactoryContract {\r\n    require(_collateralTokenAddress != address(0), \"Invalid token address\");\r\n    require(_borrowerAddress != address(0), \"Invalid lender address\");\r\n    require(_lenderAddress != address(0), \"Invalid lender address\");\r\n    require(_remainingInstallment > 0, \"Invalid number of installments\");\r\n    require(_borrowAmount > 0, \"Borrow amount must not be 0\");\r\n    require(_paybackAmount > 0, \"Payback amount must not be 0\");\r\n    require(_collateralAmount > 0, \"Collateral amount must not be 0\");\r\n    super._mint(_lenderAddress, 1);\r\n    factoryContract = msg.sender;\r\n    ownerAddress = _ownerAddress;\r\n    loanId = _loanId;\r\n    collateralTokenAddress = _collateralTokenAddress;\r\n    borrowAmount = _borrowAmount;\r\n    collateralAmount = _collateralAmount;\r\n    totalLoanTerm = _remainingInstallment * _daysPerInstallment;\r\n    daysPerInstallment = _daysPerInstallment;\r\n    remainingInstallment = _remainingInstallment;\r\n    installmentAmount = _paybackAmount / _remainingInstallment;\r\n    token = StandardToken(_collateralTokenAddress);\r\n    borrowerAddress = _borrowerAddress;\r\n    lenderAddress = _lenderAddress;\r\n\r\n    // initialial state for borrower initiated ERC20 flow\r\n    currentState = States.WaitingForFunds;\r\n  }\r\n\r\n  /**\r\n   * Check if borrower transferred correct amount of token to this contract\r\n   */\r\n  function checkCollateral() public onlyBorrower atState(States.WaitingForCollateral) {\r\n    return establishContract();\r\n  }\r\n\r\n  /**\r\n   *  Lender transfer ETH to fund this contract\r\n   */\r\n  function transferFunds() public payable onlyLender atState(States.WaitingForFunds) {\r\n    if (address(this).balance >= borrowAmount) {\r\n      currentState = States.WaitingForCollateral;\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n   *  Borrower gets collateral token back when contract completed\r\n   */\r\n  function borrowerCancel() public onlyBorrower atState(States.WaitingForFunds) {\r\n    revert();\r\n  }\r\n\r\n  /*\r\n   *  Lender gets funds token back when contract is cancelled\r\n   */\r\n  function lenderCancel() public onlyLender atState(States.WaitingForCollateral) {\r\n    lenderAddress.transfer(address(this).balance);\r\n    currentState = States.Cancelled;\r\n  }\r\n}\r\n\r\n// File: contracts\\ETHERC20Loan.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * Collateral: ETH\r\n * Borrowed: ERC20 Token\r\n */\r\ncontract ETHERC20Loan is DefinerBasicLoan {\r\n\r\n  StandardToken token;\r\n  address public borrowedTokenAddress;\r\n\r\n  function establishContract() public {\r\n\r\n    // ERC20 as collateral\r\n    uint amount = token.balanceOf(address(this));\r\n    require(amount >= collateralAmount, \"Insufficient collateral amount\");\r\n\r\n    // Ether as Fund\r\n    require(address(this).balance >= borrowAmount, \"Insufficient fund amount\");\r\n\r\n    // Transit to Funded state\r\n    transferETHToBorrowerAndStartLoan();\r\n  }\r\n\r\n  /*\r\n   *  Borrower pay back ERC20 Token\r\n   */\r\n  function borrowerMakePayment() public payable onlyBorrower atState(States.Funded) notDefault {\r\n    require(remainingInstallment > 0, \"No remaining installments\");\r\n    require(installmentAmount > 0, \"Installment amount must be non zero\");\r\n    token.transfer(lenderAddress, installmentAmount);\r\n    remainingInstallment--;\r\n    if (remainingInstallment == 0) {\r\n      currentState = States.Finished;\r\n    } else {\r\n      nextPaymentDateTime = nextPaymentDateTime.add(daysPerInstallment.mul(1 days));\r\n    }\r\n  }\r\n\r\n  /*\r\n   *  Borrower gets collateral ETH back when contract completed\r\n   */\r\n  function borrowerReclaimCollateral() public onlyBorrower atState(States.Finished) {\r\n    borrowerAddress.transfer(address(this).balance);\r\n    currentState = States.Closed;\r\n  }\r\n\r\n  /*\r\n   *  Lender gets collateral ETH when contract defaulted\r\n   */\r\n  function lenderReclaimCollateral() public onlyLender atState(States.Default) {\r\n    lenderAddress.transfer(address(this).balance);\r\n    currentState = States.Closed;\r\n  }\r\n}\r\n\r\n// File: contracts\\ETHERC20LoanBorrower.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * Collateral: ETH\r\n * Borrowed: ERC20 Token\r\n */\r\ncontract ETHERC20LoanBorrower is ETHERC20Loan {\r\n  function init (\r\n    address _ownerAddress,\r\n    address _borrowerAddress,\r\n    address _lenderAddress,\r\n    address _borrowedTokenAddress,\r\n    uint _borrowAmount,\r\n    uint _paybackAmount,\r\n    uint _collateralAmount,\r\n    uint _daysPerInstallment,\r\n    uint _remainingInstallment,\r\n    string _loanId\r\n  ) public onlyFactoryContract {\r\n    require(_borrowedTokenAddress != address(0), \"Invalid token address\");\r\n    require(_borrowerAddress != address(0), \"Invalid lender address\");\r\n    require(_lenderAddress != address(0), \"Invalid lender address\");\r\n    require(_remainingInstallment > 0, \"Invalid number of installments\");\r\n    require(_borrowAmount > 0, \"Borrow amount must not be 0\");\r\n    require(_paybackAmount > 0, \"Payback amount must not be 0\");\r\n    require(_collateralAmount > 0, \"Collateral amount must not be 0\");\r\n    super._mint(_lenderAddress, 1);\r\n    factoryContract = msg.sender;\r\n    ownerAddress = _ownerAddress;\r\n    loanId = _loanId;\r\n    borrowedTokenAddress = _borrowedTokenAddress;\r\n    borrowAmount = _borrowAmount;\r\n    collateralAmount = _collateralAmount;\r\n    totalLoanTerm = _remainingInstallment * _daysPerInstallment;\r\n    daysPerInstallment = _daysPerInstallment;\r\n    remainingInstallment = _remainingInstallment;\r\n    installmentAmount = _paybackAmount / _remainingInstallment;\r\n    token = StandardToken(_borrowedTokenAddress);\r\n    borrowerAddress = _borrowerAddress;\r\n    lenderAddress = _lenderAddress;\r\n\r\n    currentState = States.WaitingForCollateral;\r\n  }\r\n\r\n  /**\r\n   * Borrower transfer ETH to contract\r\n   */\r\n  function transferCollateral() public payable atState(States.WaitingForCollateral) {\r\n    if (address(this).balance >= collateralAmount) {\r\n      currentState = States.WaitingForFunds;\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  function checkFunds() public onlyLender atState(States.WaitingForFunds) {\r\n    uint amount = token.balanceOf(address(this));\r\n    require(amount >= borrowAmount, \"Insufficient borrowed amount\");\r\n    transferTokenToBorrowerAndStartLoan(token);\r\n  }\r\n\r\n  /**\r\n   * NOT IN USE\r\n   * WHEN COLLATERAL IS ETH, CHECK IS DONE IN transferCollateral()\r\n   */\r\n  function checkCollateral() public {\r\n    revert();\r\n  }\r\n\r\n  /**\r\n   * NOT IN USE\r\n   * WHEN FUND IS TOKEN, TRANSFER IS DONE IN FRONT END\r\n   */\r\n  function transferFunds() public payable {\r\n    revert();\r\n  }\r\n\r\n  /*\r\n *  Borrower gets collateral ETH back when contract completed\r\n */\r\n  function borrowerCancel() public onlyBorrower atState(States.WaitingForFunds) {\r\n    borrowerAddress.transfer(address(this).balance);\r\n    currentState = States.Cancelled;\r\n  }\r\n\r\n  /*\r\n*  Borrower gets collateral ETH back when contract completed\r\n*/\r\n  function lenderCancel() public onlyLender atState(States.WaitingForCollateral) {\r\n    revert();\r\n  }\r\n}\r\n\r\n// File: contracts\\ETHERC20LoanLender.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * Collateral: ETH\r\n * Borrowed: ERC20 Token\r\n */\r\ncontract ETHERC20LoanLender is ETHERC20Loan {\r\n\r\n  function init (\r\n    address _ownerAddress,\r\n    address _borrowerAddress,\r\n    address _lenderAddress,\r\n    address _borrowedTokenAddress,\r\n    uint _borrowAmount,\r\n    uint _paybackAmount,\r\n    uint _collateralAmount,\r\n    uint _daysPerInstallment,\r\n    uint _remainingInstallment,\r\n    string _loanId\r\n  ) public onlyFactoryContract {\r\n    require(_borrowedTokenAddress != address(0), \"Invalid token address\");\r\n    require(_borrowerAddress != address(0), \"Invalid lender address\");\r\n    require(_lenderAddress != address(0), \"Invalid lender address\");\r\n    require(_remainingInstallment > 0, \"Invalid number of installments\");\r\n    require(_borrowAmount > 0, \"Borrow amount must not be 0\");\r\n    require(_paybackAmount > 0, \"Payback amount must not be 0\");\r\n    require(_collateralAmount > 0, \"Collateral amount must not be 0\");\r\n    super._mint(_lenderAddress, 1);\r\n    factoryContract = msg.sender;\r\n    ownerAddress = _ownerAddress;\r\n    loanId = _loanId;\r\n    borrowedTokenAddress = _borrowedTokenAddress;\r\n    borrowAmount = _borrowAmount;\r\n    collateralAmount = _collateralAmount;\r\n    totalLoanTerm = _remainingInstallment * _daysPerInstallment;\r\n    daysPerInstallment = _daysPerInstallment;\r\n    remainingInstallment = _remainingInstallment;\r\n    installmentAmount = _paybackAmount / _remainingInstallment;\r\n    token = StandardToken(_borrowedTokenAddress);\r\n    borrowerAddress = _borrowerAddress;\r\n    lenderAddress = _lenderAddress;\r\n\r\n    currentState = States.WaitingForFunds;\r\n  }\r\n\r\n  /**\r\n   * Borrower transfer ETH to contract\r\n   */\r\n  function transferCollateral() public payable atState(States.WaitingForCollateral) {\r\n    require(address(this).balance >= collateralAmount, \"Insufficient ETH collateral amount\");\r\n    transferTokenToBorrowerAndStartLoan(token);\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  function checkFunds() public onlyLender atState(States.WaitingForFunds) {\r\n    uint amount = token.balanceOf(address(this));\r\n    require(amount >= borrowAmount, \"Insufficient fund amount\");\r\n    currentState = States.WaitingForCollateral;\r\n  }\r\n\r\n  /**\r\n   * NOT IN USE\r\n   * WHEN COLLATERAL IS ETH, CHECK IS DONE IN transferCollateral()\r\n   */\r\n  function checkCollateral() public {\r\n    revert();\r\n  }\r\n\r\n  /**\r\n   * NOT IN USE\r\n   * WHEN FUND IS TOKEN, TRANSFER IS DONE IN FRONT END\r\n   */\r\n  function transferFunds() public payable {\r\n    revert();\r\n  }\r\n\r\n  /*\r\n *  Borrower gets collateral ETH back when contract completed\r\n */\r\n  function borrowerCancel() public onlyBorrower atState(States.WaitingForFunds) {\r\n    revert();\r\n  }\r\n\r\n  /*\r\n*  Borrower gets collateral ETH back when contract completed\r\n*/\r\n  function lenderCancel() public onlyLender atState(States.WaitingForCollateral) {\r\n    uint amount = token.balanceOf(address(this));\r\n    token.transfer(lenderAddress, amount);\r\n    currentState = States.Cancelled;\r\n  }\r\n}\r\n\r\n// File: contracts\\ERC20ERC20Loan.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * Collateral: ERC20 Token\r\n * Borrowed: ERC20 Token\r\n */\r\ncontract ERC20ERC20Loan is DefinerBasicLoan {\r\n\r\n  StandardToken collateralToken;\r\n  StandardToken borrowedToken;\r\n  address public collateralTokenAddress;\r\n  address public borrowedTokenAddress;\r\n\r\n  /*\r\n   *  Borrower pay back Token\r\n   */\r\n  function borrowerMakePayment() public payable onlyBorrower atState(States.Funded) notDefault {\r\n    require(remainingInstallment > 0, \"No remaining installments\");\r\n    require(installmentAmount > 0, \"Installment amount must be non zero\");\r\n    borrowedToken.transfer(lenderAddress, installmentAmount);\r\n    remainingInstallment--;\r\n    if (remainingInstallment == 0) {\r\n      currentState = States.Finished;\r\n    } else {\r\n      nextPaymentDateTime = nextPaymentDateTime.add(daysPerInstallment.mul(1 days));\r\n    }\r\n  }\r\n\r\n  /*\r\n   *  Borrower gets collateral token back when contract completed\r\n   */\r\n  function borrowerReclaimCollateral() public onlyBorrower atState(States.Finished) {\r\n    uint amount = collateralToken.balanceOf(address(this));\r\n    collateralToken.transfer(borrowerAddress, amount);\r\n    currentState = States.Closed;\r\n  }\r\n\r\n  /*\r\n   *  Lender gets collateral token when contract defaulted\r\n   */\r\n  function lenderReclaimCollateral() public onlyLender atState(States.Default) {\r\n    uint amount = collateralToken.balanceOf(address(this));\r\n    collateralToken.transfer(lenderAddress, amount);\r\n    currentState = States.Closed;\r\n  }\r\n}\r\n\r\n// File: contracts\\ERC20ERC20LoanBorrower.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * Collateral: ERC20 Token\r\n * Borrowed: ERC20 Token\r\n */\r\ncontract ERC20ERC20LoanBorrower is ERC20ERC20Loan {\r\n\r\n  function init (\r\n    address _ownerAddress,\r\n    address _borrowerAddress,\r\n    address _lenderAddress,\r\n    address _collateralTokenAddress,\r\n    address _borrowedTokenAddress,\r\n    uint _borrowAmount,\r\n    uint _paybackAmount,\r\n    uint _collateralAmount,\r\n    uint _daysPerInstallment,\r\n    uint _remainingInstallment,\r\n    string _loanId\r\n  ) public onlyFactoryContract {\r\n    require(_collateralTokenAddress != _borrowedTokenAddress);\r\n    require(_collateralTokenAddress != address(0), \"Invalid token address\");\r\n    require(_borrowedTokenAddress != address(0), \"Invalid token address\");\r\n    require(_borrowerAddress != address(0), \"Invalid lender address\");\r\n    require(_lenderAddress != address(0), \"Invalid lender address\");\r\n    require(_remainingInstallment > 0, \"Invalid number of installments\");\r\n    require(_borrowAmount > 0, \"Borrow amount must not be 0\");\r\n    require(_paybackAmount > 0, \"Payback amount must not be 0\");\r\n    require(_collateralAmount > 0, \"Collateral amount must not be 0\");\r\n    super._mint(_lenderAddress, 1);\r\n    factoryContract = msg.sender;\r\n    ownerAddress = _ownerAddress;\r\n    loanId = _loanId;\r\n    collateralTokenAddress = _collateralTokenAddress;\r\n    borrowedTokenAddress = _borrowedTokenAddress;\r\n    borrowAmount = _borrowAmount;\r\n    collateralAmount = _collateralAmount;\r\n    totalLoanTerm = _remainingInstallment * _daysPerInstallment;\r\n    daysPerInstallment = _daysPerInstallment;\r\n    remainingInstallment = _remainingInstallment;\r\n    installmentAmount = _paybackAmount / _remainingInstallment;\r\n    collateralToken = StandardToken(_collateralTokenAddress);\r\n    borrowedToken = StandardToken(_borrowedTokenAddress);\r\n\r\n    borrowerAddress = _borrowerAddress;\r\n    lenderAddress = _lenderAddress;\r\n    currentState = States.WaitingForCollateral;\r\n  }\r\n\r\n  /**\r\n   * NOT IN USE\r\n   * WHEN COLLATERAL IS TOKEN, TRANSFER IS DONE IN FRONT END\r\n   */\r\n  function transferCollateral() public payable {\r\n    revert();\r\n  }\r\n\r\n  /**\r\n   * NOT IN USE\r\n   * WHEN FUND IS TOKEN, TRANSFER IS DONE IN FRONT END\r\n   */\r\n  function transferFunds() public payable {\r\n    revert();\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  function checkFunds() public onlyLender atState(States.WaitingForFunds) {\r\n    uint amount = borrowedToken.balanceOf(address(this));\r\n    require(amount >= borrowAmount, \"Insufficient borrowed amount\");\r\n    transferTokenToBorrowerAndStartLoan(borrowedToken);\r\n  }\r\n\r\n  /**\r\n   * Check if borrower transferred correct amount of token to this contract\r\n   */\r\n  function checkCollateral() public onlyBorrower atState(States.WaitingForCollateral) {\r\n    uint amount = collateralToken.balanceOf(address(this));\r\n    require(amount >= collateralAmount, \"Insufficient Collateral Token amount\");\r\n    currentState = States.WaitingForFunds;\r\n  }\r\n\r\n  /*\r\n   *  Borrower gets collateral token back when contract cancelled\r\n   */\r\n  function borrowerCancel() public onlyBorrower atState(States.WaitingForFunds) {\r\n    uint amount = collateralToken.balanceOf(address(this));\r\n    collateralToken.transfer(borrowerAddress, amount);\r\n    currentState = States.Cancelled;\r\n  }\r\n\r\n  /*\r\n   *  Lender gets fund token back when contract cancelled\r\n   */\r\n  function lenderCancel() public onlyLender atState(States.WaitingForCollateral) {\r\n    revert();\r\n  }\r\n}\r\n\r\n// File: contracts\\ERC20ERC20LoanLender.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * Collateral: ERC20 Token\r\n * Borrowed: ERC20 Token\r\n */\r\ncontract ERC20ERC20LoanLender is ERC20ERC20Loan {\r\n\r\n  function init (\r\n    address _ownerAddress,\r\n    address _borrowerAddress,\r\n    address _lenderAddress,\r\n    address _collateralTokenAddress,\r\n    address _borrowedTokenAddress,\r\n    uint _borrowAmount,\r\n    uint _paybackAmount,\r\n    uint _collateralAmount,\r\n    uint _daysPerInstallment,\r\n    uint _remainingInstallment,\r\n    string _loanId\r\n  ) public onlyFactoryContract {\r\n    require(_collateralTokenAddress != _borrowedTokenAddress);\r\n    require(_collateralTokenAddress != address(0), \"Invalid token address\");\r\n    require(_borrowedTokenAddress != address(0), \"Invalid token address\");\r\n    require(_borrowerAddress != address(0), \"Invalid lender address\");\r\n    require(_lenderAddress != address(0), \"Invalid lender address\");\r\n    require(_remainingInstallment > 0, \"Invalid number of installments\");\r\n    require(_borrowAmount > 0, \"Borrow amount must not be 0\");\r\n    require(_paybackAmount > 0, \"Payback amount must not be 0\");\r\n    require(_collateralAmount > 0, \"Collateral amount must not be 0\");\r\n    super._mint(_lenderAddress, 1);\r\n    factoryContract = msg.sender;\r\n    ownerAddress = _ownerAddress;\r\n    loanId = _loanId;\r\n    collateralTokenAddress = _collateralTokenAddress;\r\n    borrowedTokenAddress = _borrowedTokenAddress;\r\n    borrowAmount = _borrowAmount;\r\n    collateralAmount = _collateralAmount;\r\n    totalLoanTerm = _remainingInstallment * _daysPerInstallment;\r\n    daysPerInstallment = _daysPerInstallment;\r\n    remainingInstallment = _remainingInstallment;\r\n    installmentAmount = _paybackAmount / _remainingInstallment;\r\n    collateralToken = StandardToken(_collateralTokenAddress);\r\n    borrowedToken = StandardToken(_borrowedTokenAddress);\r\n\r\n    borrowerAddress = _borrowerAddress;\r\n    lenderAddress = _lenderAddress;\r\n    currentState = States.WaitingForFunds;\r\n  }\r\n\r\n  /**\r\n   * NOT IN USE\r\n   * WHEN COLLATERAL IS TOKEN, TRANSFER IS DONE IN FRONT END\r\n   */\r\n  function transferCollateral() public payable {\r\n    revert();\r\n  }\r\n\r\n  /**\r\n   * NOT IN USE\r\n   * WHEN FUND IS TOKEN, TRANSFER IS DONE IN FRONT END\r\n   */\r\n  function transferFunds() public payable {\r\n    revert();\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  function checkFunds() public onlyLender atState(States.WaitingForFunds) {\r\n    uint amount = borrowedToken.balanceOf(address(this));\r\n    require(amount >= borrowAmount, \"Insufficient fund amount\");\r\n    currentState = States.WaitingForCollateral;\r\n  }\r\n\r\n  /**\r\n   * Check if borrower transferred correct amount of token to this contract\r\n   */\r\n  function checkCollateral() public onlyBorrower atState(States.WaitingForCollateral) {\r\n    uint amount = collateralToken.balanceOf(address(this));\r\n    require(amount >= collateralAmount, \"Insufficient Collateral Token amount\");\r\n    transferTokenToBorrowerAndStartLoan(borrowedToken);\r\n  }\r\n\r\n  /*\r\n   *  Borrower gets collateral token back when contract cancelled\r\n   */\r\n  function borrowerCancel() public onlyBorrower atState(States.WaitingForFunds) {\r\n    revert();\r\n  }\r\n\r\n  /*\r\n   *  Lender gets fund token back when contract cancelled\r\n   */\r\n  function lenderCancel() public onlyLender atState(States.WaitingForCollateral) {\r\n    uint amount = borrowedToken.balanceOf(address(this));\r\n    borrowedToken.transfer(lenderAddress, amount);\r\n    currentState = States.Cancelled;\r\n  }\r\n}\r\n\r\n// File: contracts\\DefinerLoanFactory.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary Library {\r\n  struct contractAddress {\r\n    address value;\r\n    bool exists;\r\n  }\r\n}\r\n\r\ncontract CloneFactory {\r\n  event CloneCreated(address indexed target, address clone);\r\n\r\n  function createClone(address target) internal returns (address result) {\r\n    bytes memory clone = hex\"3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3\";\r\n    bytes20 targetBytes = bytes20(target);\r\n    for (uint i = 0; i < 20; i++) {\r\n      clone[20 + i] = targetBytes[i];\r\n    }\r\n    assembly {\r\n      let len := mload(clone)\r\n      let data := add(clone, 0x20)\r\n      result := create(0, data, len)\r\n    }\r\n  }\r\n}\r\n\r\ncontract DefinerLoanFactory is CloneFactory {\r\n\r\n  using Library for Library.contractAddress;\r\n\r\n  address public owner = msg.sender;\r\n  address public ERC20ETHLoanBorrowerMasterContractAddress;\r\n  address public ERC20ETHLoanLenderMasterContractAddress;\r\n\r\n  address public ETHERC20LoanBorrowerMasterContractAddress;\r\n  address public ETHERC20LoanLenderMasterContractAddress;\r\n\r\n  address public ERC20ERC20LoanBorrowerMasterContractAddress;\r\n  address public ERC20ERC20LoanLenderMasterContractAddress;\r\n\r\n  mapping(address => address[]) contractMap;\r\n  mapping(string => Library.contractAddress) contractById;\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"Invalid Owner Address\");\r\n    _;\r\n  }\r\n\r\n  constructor (\r\n    address _ERC20ETHLoanBorrowerMasterContractAddress,\r\n    address _ERC20ETHLoanLenderMasterContractAddress,\r\n    address _ETHERC20LoanBorrowerMasterContractAddress,\r\n    address _ETHERC20LoanLenderMasterContractAddress,\r\n    address _ERC20ERC20LoanBorrowerMasterContractAddress,\r\n    address _ERC20ERC20LoanLenderMasterContractAddress\r\n  ) public {\r\n    owner = msg.sender;\r\n    ERC20ETHLoanBorrowerMasterContractAddress = _ERC20ETHLoanBorrowerMasterContractAddress;\r\n    ERC20ETHLoanLenderMasterContractAddress = _ERC20ETHLoanLenderMasterContractAddress;\r\n    ETHERC20LoanBorrowerMasterContractAddress = _ETHERC20LoanBorrowerMasterContractAddress;\r\n    ETHERC20LoanLenderMasterContractAddress = _ETHERC20LoanLenderMasterContractAddress;\r\n    ERC20ERC20LoanBorrowerMasterContractAddress = _ERC20ERC20LoanBorrowerMasterContractAddress;\r\n    ERC20ERC20LoanLenderMasterContractAddress = _ERC20ERC20LoanLenderMasterContractAddress;\r\n  }\r\n\r\n  function getUserContracts(address userAddress) public view returns (address[]) {\r\n    return contractMap[userAddress];\r\n  }\r\n\r\n  function getContractByLoanId(string _loanId) public view returns (address) {\r\n    return contractById[_loanId].value;\r\n  }\r\n\r\n  function createERC20ETHLoanBorrowerClone(\r\n    address _collateralTokenAddress,\r\n    uint _borrowAmount,\r\n    uint _paybackAmount,\r\n    uint _collateralAmount,\r\n    uint _daysPerInstallment,\r\n    uint _remainingInstallment,\r\n    string _loanId,\r\n    address _lenderAddress\r\n  ) public payable returns (address) {\r\n    require(!contractById[_loanId].exists, \"contract already exists\");\r\n\r\n    address clone = createClone(ERC20ETHLoanBorrowerMasterContractAddress);\r\n    ERC20ETHLoanBorrower(clone).init({\r\n      _ownerAddress : owner,\r\n      _borrowerAddress : msg.sender,\r\n      _lenderAddress : _lenderAddress,\r\n      _collateralTokenAddress : _collateralTokenAddress,\r\n      _borrowAmount : _borrowAmount,\r\n      _paybackAmount : _paybackAmount,\r\n      _collateralAmount : _collateralAmount,\r\n      _daysPerInstallment : _daysPerInstallment,\r\n      _remainingInstallment : _remainingInstallment,\r\n      _loanId : _loanId});\r\n\r\n    contractMap[msg.sender].push(clone);\r\n    contractById[_loanId] = Library.contractAddress(clone, true);\r\n    return clone;\r\n  }\r\n\r\n\r\n  function createERC20ETHLoanLenderClone(\r\n    address _collateralTokenAddress,\r\n    uint _borrowAmount,\r\n    uint _paybackAmount,\r\n    uint _collateralAmount,\r\n    uint _daysPerInstallment,\r\n    uint _remainingInstallment,\r\n    string _loanId,\r\n    address _borrowerAddress\r\n  ) public payable returns (address) {\r\n    require(!contractById[_loanId].exists, \"contract already exists\");\r\n\r\n    address clone = createClone(ERC20ETHLoanLenderMasterContractAddress);\r\n    ERC20ETHLoanLender(clone).init({\r\n      _ownerAddress : owner,\r\n      _borrowerAddress : _borrowerAddress,\r\n      _lenderAddress : msg.sender,\r\n      _collateralTokenAddress : _collateralTokenAddress,\r\n      _borrowAmount : _borrowAmount,\r\n      _paybackAmount : _paybackAmount,\r\n      _collateralAmount : _collateralAmount,\r\n      _daysPerInstallment : _daysPerInstallment,\r\n      _remainingInstallment : _remainingInstallment,\r\n      _loanId : _loanId});\r\n\r\n    if (msg.value > 0) {\r\n      ERC20ETHLoanLender(clone).transferFunds.value(msg.value)();\r\n    }\r\n    contractMap[msg.sender].push(clone);\r\n    contractById[_loanId] = Library.contractAddress(clone, true);\r\n    return clone;\r\n  }\r\n\r\n  function createETHERC20LoanBorrowerClone(\r\n    address _borrowedTokenAddress,\r\n    uint _borrowAmount,\r\n    uint _paybackAmount,\r\n    uint _collateralAmount,\r\n    uint _daysPerInstallment,\r\n    uint _remainingInstallment,\r\n    string _loanId,\r\n    address _lenderAddress\r\n  ) public payable returns (address) {\r\n    require(!contractById[_loanId].exists, \"contract already exists\");\r\n\r\n    address clone = createClone(ETHERC20LoanBorrowerMasterContractAddress);\r\n    ETHERC20LoanBorrower(clone).init({\r\n      _ownerAddress : owner,\r\n      _borrowerAddress : msg.sender,\r\n      _lenderAddress : _lenderAddress,\r\n      _borrowedTokenAddress : _borrowedTokenAddress,\r\n      _borrowAmount : _borrowAmount,\r\n      _paybackAmount : _paybackAmount,\r\n      _collateralAmount : _collateralAmount,\r\n      _daysPerInstallment : _daysPerInstallment,\r\n      _remainingInstallment : _remainingInstallment,\r\n      _loanId : _loanId});\r\n\r\n    if (msg.value >= _collateralAmount) {\r\n      ETHERC20LoanBorrower(clone).transferCollateral.value(msg.value)();\r\n    }\r\n\r\n    contractMap[msg.sender].push(clone);\r\n    contractById[_loanId] = Library.contractAddress(clone, true);\r\n    return clone;\r\n  }\r\n\r\n  function createETHERC20LoanLenderClone(\r\n    address _borrowedTokenAddress,\r\n    uint _borrowAmount,\r\n    uint _paybackAmount,\r\n    uint _collateralAmount,\r\n    uint _daysPerInstallment,\r\n    uint _remainingInstallment,\r\n    string _loanId,\r\n    address _borrowerAddress\r\n  ) public payable returns (address) {\r\n    require(!contractById[_loanId].exists, \"contract already exists\");\r\n\r\n    address clone = createClone(ETHERC20LoanLenderMasterContractAddress);\r\n    ETHERC20LoanLender(clone).init({\r\n      _ownerAddress : owner,\r\n      _borrowerAddress : _borrowerAddress,\r\n      _lenderAddress : msg.sender,\r\n      _borrowedTokenAddress : _borrowedTokenAddress,\r\n      _borrowAmount : _borrowAmount,\r\n      _paybackAmount : _paybackAmount,\r\n      _collateralAmount : _collateralAmount,\r\n      _daysPerInstallment : _daysPerInstallment,\r\n      _remainingInstallment : _remainingInstallment,\r\n      _loanId : _loanId});\r\n\r\n    contractMap[msg.sender].push(clone);\r\n    contractById[_loanId] = Library.contractAddress(clone, true);\r\n    return clone;\r\n  }\r\n\r\n  function createERC20ERC20LoanBorrowerClone(\r\n    address _collateralTokenAddress,\r\n    address _borrowedTokenAddress,\r\n    uint _borrowAmount,\r\n    uint _paybackAmount,\r\n    uint _collateralAmount,\r\n    uint _daysPerInstallment,\r\n    uint _remainingInstallment,\r\n    string _loanId,\r\n    address _lenderAddress\r\n  ) public returns (address) {\r\n    require(!contractById[_loanId].exists, \"contract already exists\");\r\n\r\n    address clone = createClone(ERC20ERC20LoanBorrowerMasterContractAddress);\r\n    ERC20ERC20LoanBorrower(clone).init({\r\n      _ownerAddress : owner,\r\n      _borrowerAddress : msg.sender,\r\n      _lenderAddress : _lenderAddress,\r\n      _collateralTokenAddress : _collateralTokenAddress,\r\n      _borrowedTokenAddress : _borrowedTokenAddress,\r\n      _borrowAmount : _borrowAmount,\r\n      _paybackAmount : _paybackAmount,\r\n      _collateralAmount : _collateralAmount,\r\n      _daysPerInstallment : _daysPerInstallment,\r\n      _remainingInstallment : _remainingInstallment,\r\n      _loanId : _loanId});\r\n    contractMap[msg.sender].push(clone);\r\n    contractById[_loanId] = Library.contractAddress(clone, true);\r\n    return clone;\r\n  }\r\n\r\n  function createERC20ERC20LoanLenderClone(\r\n    address _collateralTokenAddress,\r\n    address _borrowedTokenAddress,\r\n    uint _borrowAmount,\r\n    uint _paybackAmount,\r\n    uint _collateralAmount,\r\n    uint _daysPerInstallment,\r\n    uint _remainingInstallment,\r\n    string _loanId,\r\n    address _borrowerAddress\r\n  ) public returns (address) {\r\n    require(!contractById[_loanId].exists, \"contract already exists\");\r\n\r\n    address clone = createClone(ERC20ERC20LoanLenderMasterContractAddress);\r\n    ERC20ERC20LoanLender(clone).init({\r\n      _ownerAddress : owner,\r\n      _borrowerAddress : _borrowerAddress,\r\n      _lenderAddress : msg.sender,\r\n      _collateralTokenAddress : _collateralTokenAddress,\r\n      _borrowedTokenAddress : _borrowedTokenAddress,\r\n      _borrowAmount : _borrowAmount,\r\n      _paybackAmount : _paybackAmount,\r\n      _collateralAmount : _collateralAmount,\r\n      _daysPerInstallment : _daysPerInstallment,\r\n      _remainingInstallment : _remainingInstallment,\r\n      _loanId : _loanId});\r\n    contractMap[msg.sender].push(clone);\r\n    contractById[_loanId] = Library.contractAddress(clone, true);\r\n    return clone;\r\n  }\r\n\r\n  function changeOwner(address newOwner) public onlyOwner {\r\n    owner = newOwner;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"lenderCancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalLoanTerm\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"borrowerCancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferFunds\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"forceDefault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingInstallment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkDefault\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lenderAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collateralTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferCollateral\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"borrowerReclaimCollateral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"borrowerAcceptLoan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lenderReclaimCollateral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"installmentAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkCollateral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lenderAcceptLoan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collateralAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ownerAddress\",\"type\":\"address\"},{\"name\":\"_borrowerAddress\",\"type\":\"address\"},{\"name\":\"_lenderAddress\",\"type\":\"address\"},{\"name\":\"_collateralTokenAddress\",\"type\":\"address\"},{\"name\":\"_borrowAmount\",\"type\":\"uint256\"},{\"name\":\"_paybackAmount\",\"type\":\"uint256\"},{\"name\":\"_collateralAmount\",\"type\":\"uint256\"},{\"name\":\"_daysPerInstallment\",\"type\":\"uint256\"},{\"name\":\"_remainingInstallment\",\"type\":\"uint256\"},{\"name\":\"_loanId\",\"type\":\"string\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLoanDetails\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"borrowerMakePayment\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"establishContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loanId\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"daysPerInstallment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextPaymentDateTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"ERC20ETHLoanLender","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://940945b99ae9354db0108c8ecf9db36cdca5973a13d26bac18b0bb7ca988a320"}]}