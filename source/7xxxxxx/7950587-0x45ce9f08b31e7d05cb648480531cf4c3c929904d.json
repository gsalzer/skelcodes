{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.7;\r\n\r\n// File: openzeppelin-solidity/contracts/cryptography/ECDSA.sol\r\n\r\n/**\r\n * @title Elliptic curve signature operations\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\r\n * See https://github.com/ethereum/solidity/issues/864\r\n */\r\n\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Recover signer address from a message by using their signature\r\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n     * @param signature bytes signature, the signature is generated using web3.eth.sign()\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            return address(0);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * toEthSignedMessageHash\r\n     * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n     * and hash the result\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\n// File: contracts/AliorDurableMedium.sol\r\n\r\ncontract AliorDurableMedium {\r\n\r\n    // ------------------------------------------------------------------------------------------ //\r\n    // STRUCTS\r\n    // ------------------------------------------------------------------------------------------ //\r\n    \r\n    // Defines a single document\r\n    struct Document {\r\n        string fileName;         // file name of the document\r\n        bytes32 contentHash;     // hash of document's content\r\n        address signer;          // address of the entity who signed the document\r\n        address relayer;         // address of the entity who published the transaction\r\n        uint40 blockNumber;      // number of the block in which the document was added\r\n        uint40 canceled;         // block number in which document was canceled; 0 otherwise\r\n    }\r\n\r\n    // ------------------------------------------------------------------------------------------ //\r\n    // MODIFIERS\r\n    // ------------------------------------------------------------------------------------------ //\r\n\r\n    // Restricts function use by verifying given signature with nonce\r\n    modifier ifCorrectlySignedWithNonce(\r\n        string memory _methodName,\r\n        bytes memory _methodArguments,\r\n        bytes memory _signature\r\n    ) {\r\n        bytes memory abiEncodedParams = abi.encode(address(this), nonce++, _methodName, _methodArguments);\r\n        verifySignature(abiEncodedParams, _signature);\r\n        _;\r\n    }\r\n\r\n    // Restricts function use by verifying given signature without nonce\r\n    modifier ifCorrectlySigned(string memory _methodName, bytes memory _methodArguments, bytes memory _signature) {\r\n        bytes memory abiEncodedParams = abi.encode(address(this), _methodName, _methodArguments);\r\n        verifySignature(abiEncodedParams, _signature);\r\n        _;\r\n    }\r\n\r\n    // Helper function used to verify signature for given bytes array\r\n    function verifySignature(bytes memory abiEncodedParams, bytes memory signature) internal view {\r\n        bytes32 ethSignedMessageHash = ECDSA.toEthSignedMessageHash(keccak256(abiEncodedParams));\r\n        address recoveredAddress = ECDSA.recover(ethSignedMessageHash, signature);\r\n        require(recoveredAddress != address(0), \"Error during the signature recovery\");\r\n        require(recoveredAddress == owner, \"Signature mismatch\");\r\n    }\r\n\r\n    // Restricts function use after contract's retirement\r\n    modifier ifNotRetired() {\r\n        require(upgradedVersion == address(0), \"Contract is retired\");\r\n        _;\r\n    } \r\n\r\n    // ------------------------------------------------------------------------------------------ //\r\n    // EVENTS\r\n    // ------------------------------------------------------------------------------------------ //\r\n\r\n    // An event emitted when the contract gets retired\r\n    event ContractRetired(address indexed upgradedVersion);\r\n\r\n    // An event emitted when a new document is published on the contract\r\n    event DocumentAdded(uint indexed documentId);\r\n\r\n    // An event emitted when a document is canceled\r\n    event DocumentCanceled(uint indexed documentId);\r\n    \r\n    // An event emitted when contract owner changes\r\n    event OwnershipChanged(address indexed newOwner);\r\n\r\n    // ------------------------------------------------------------------------------------------ //\r\n    // FIELDS\r\n    // ------------------------------------------------------------------------------------------ //\r\n\r\n    address public upgradedVersion;                           // if the contract gets retired; address of the new contract\r\n    uint public nonce;                                        // ID of the next action\r\n    uint private documentCount;                               // count of documents published on the contract\r\n    mapping(uint => Document) private documents;              // document storage\r\n    mapping(bytes32 => uint) private contentHashToDocumentId; // mapping that allows retrieving documentId by contentHash\r\n    address public owner;                                     // owner of the contract\r\n    // (this address is checked in signature verification)\r\n\r\n    // ------------------------------------------------------------------------------------------ //\r\n    // CONSTRUCTOR\r\n    // ------------------------------------------------------------------------------------------ //\r\n\r\n    constructor(address _owner) public {\r\n        require(_owner != address(0), \"Owner cannot be initialised to a null address\");\r\n        owner = _owner;    // address given as a constructor parameter becomes the 'owner'\r\n        nonce = 0;         // first nonce is 0\r\n    }\r\n\r\n    // ------------------------------------------------------------------------------------------ //\r\n    // VIEW FUNCTIONS\r\n    // ------------------------------------------------------------------------------------------ //\r\n\r\n    // Returns the number of documents stored in the contract\r\n    function getDocumentCount() public view\r\n    returns (uint)\r\n    {\r\n        return documentCount;\r\n    }\r\n\r\n    // Returns all information about a single document\r\n    function getDocument(uint _documentId) public view\r\n    returns (\r\n        uint documentId,             // id of the document\r\n        string memory fileName,      // file name of the document\r\n        bytes32 contentHash,         // hash of document's content\r\n        address signer,              // address of the entity who signed the document\r\n        address relayer,             // address of the entity who published the transaction\r\n        uint40 blockNumber,          // number of the block in which the document was added\r\n        uint40 canceled              // block number in which document was canceled; 0 otherwise\r\n    )\r\n    {\r\n        Document memory doc = documents[_documentId];\r\n        return (\r\n            _documentId, \r\n            doc.fileName, \r\n            doc.contentHash,\r\n            doc.signer,\r\n            doc.relayer,\r\n            doc.blockNumber,\r\n            doc.canceled\r\n        );\r\n    }\r\n\r\n    // Gets the id of the document with given contentHash\r\n    function getDocumentIdWithContentHash(bytes32 _contentHash) public view\r\n    returns (uint) \r\n    {\r\n        return contentHashToDocumentId[_contentHash];\r\n    }\r\n\r\n    // ------------------------------------------------------------------------------------------ //\r\n    // STATE-CHANGING FUNCTIONS\r\n    // ------------------------------------------------------------------------------------------ //\r\n\r\n    // Changes the contract owner\r\n    function transferOwnership(address _newOwner, bytes memory _signature) public\r\n    ifCorrectlySignedWithNonce(\"transferOwnership\", abi.encode(_newOwner), _signature)\r\n    {\r\n        require(_newOwner != address(0), \"Owner cannot be changed to a null address\");\r\n        require(_newOwner != owner, \"Cannot change owner to be the same address\");\r\n        owner = _newOwner;\r\n        emit OwnershipChanged(_newOwner);\r\n    }\r\n\r\n    // Adds a new document\r\n    function addDocument(\r\n        string memory _fileName,\r\n        bytes32 _contentHash,\r\n        bytes memory _signature\r\n    ) public\r\n    ifNotRetired\r\n    ifCorrectlySigned(\r\n        \"addDocument\", \r\n        abi.encode(\r\n            _fileName,\r\n            _contentHash\r\n        ),\r\n        _signature\r\n    )\r\n    {\r\n        require(contentHashToDocumentId[_contentHash] == 0, \"Document with given hash is already published\");\r\n        uint documentId = documentCount + 1;\r\n        contentHashToDocumentId[_contentHash] = documentId;\r\n        emit DocumentAdded(documentId);\r\n        documents[documentId] = Document(\r\n            _fileName, \r\n            _contentHash,\r\n            owner,\r\n            msg.sender,\r\n            uint40(block.number),\r\n            0\r\n        );\r\n        documentCount++;\r\n    }\r\n\r\n    // Cancels a published document\r\n    function cancelDocument(uint _documentId, bytes memory _signature) public\r\n    ifNotRetired\r\n    ifCorrectlySignedWithNonce(\"cancelDocument\", abi.encode(_documentId), _signature)\r\n    {\r\n        require(_documentId <= documentCount && _documentId > 0, \"Cannot cancel a non-existing document\");\r\n        require(documents[_documentId].canceled == 0, \"Cannot cancel an already canceled document\");\r\n        documents[_documentId].canceled = uint40(block.number);\r\n        emit DocumentCanceled(_documentId);\r\n    }\r\n\r\n    // Retires this contract and saves the address of the new one\r\n    function retire(address _upgradedVersion, bytes memory _signature) public\r\n    ifNotRetired\r\n    ifCorrectlySignedWithNonce(\"retire\", abi.encode(_upgradedVersion), _signature)\r\n    {\r\n        upgradedVersion = _upgradedVersion;\r\n        emit ContractRetired(upgradedVersion);\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_documentId\",\"type\":\"uint256\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"cancelDocument\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDocumentCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fileName\",\"type\":\"string\"},{\"name\":\"_contentHash\",\"type\":\"bytes32\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"addDocument\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_documentId\",\"type\":\"uint256\"}],\"name\":\"getDocument\",\"outputs\":[{\"name\":\"documentId\",\"type\":\"uint256\"},{\"name\":\"fileName\",\"type\":\"string\"},{\"name\":\"contentHash\",\"type\":\"bytes32\"},{\"name\":\"signer\",\"type\":\"address\"},{\"name\":\"relayer\",\"type\":\"address\"},{\"name\":\"blockNumber\",\"type\":\"uint40\"},{\"name\":\"canceled\",\"type\":\"uint40\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contentHash\",\"type\":\"bytes32\"}],\"name\":\"getDocumentIdWithContentHash\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_upgradedVersion\",\"type\":\"address\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"retire\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradedVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"upgradedVersion\",\"type\":\"address\"}],\"name\":\"ContractRetired\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"documentId\",\"type\":\"uint256\"}],\"name\":\"DocumentAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"documentId\",\"type\":\"uint256\"}],\"name\":\"DocumentCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipChanged\",\"type\":\"event\"}]","ContractName":"AliorDurableMedium","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ab44050cbf84371e978dcc959fbb7acacd418133","Library":"","SwarmSource":"bzzr://3a3ee05fcbdeda29e0617c322925f63a6c1819f6a1ab28af5e1710896e249660"}]}