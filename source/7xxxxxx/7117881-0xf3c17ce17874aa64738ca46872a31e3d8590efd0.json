{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * Syndicate\r\n *\r\n * A way to distribute ownership of ether in time\r\n **/\r\n\r\ncontract Syndicate {\r\n\r\n  struct Payment {\r\n    address sender;\r\n    address payable receiver;\r\n    uint256 timestamp;\r\n    uint256 time;\r\n    uint256 weiValue;\r\n    uint256 weiPaid;\r\n    bool isFork;\r\n    uint256 parentIndex;\r\n    bool isForked;\r\n    uint256 fork1Index;\r\n    uint256 fork2Index;\r\n  }\r\n\r\n  Payment[] public payments;\r\n\r\n  event PaymentUpdated(uint256 index);\r\n  event PaymentCreated(uint256 index);\r\n\r\n  mapping(address => mapping (address => bool)) public delegates;\r\n\r\n  /**\r\n   * Change whether _delegate can settle and fork payments on behalf of\r\n   * msg.sender.\r\n   **/\r\n  function delegate(address _delegate, bool delegated) public {\r\n    delegates[msg.sender][_delegate] = delegated;\r\n  }\r\n\r\n  /**\r\n   * Pay from sender to receiver a certain amount over a certain amount of time.\r\n   **/\r\n  function paymentCreate(address payable _receiver, uint256 _time) public payable {\r\n    // Verify that value has been sent\r\n    require(msg.value > 0);\r\n    // Verify the time is non-zero\r\n    require(_time > 0);\r\n    payments.push(Payment({\r\n      sender: msg.sender,\r\n      receiver: _receiver,\r\n      timestamp: block.timestamp,\r\n      time: _time,\r\n      weiValue: msg.value,\r\n      weiPaid: 0,\r\n      isFork: false,\r\n      parentIndex: 0,\r\n      isForked: false,\r\n      fork1Index: 0,\r\n      fork2Index: 0\r\n    }));\r\n    emit PaymentCreated(payments.length - 1);\r\n  }\r\n\r\n  /**\r\n   * Settle an individual payment at the current point in time.\r\n   *\r\n   * Transfers the owedWei at the current point in time to the receiving\r\n   * address.\r\n   **/\r\n  function paymentSettle(uint256 index) public {\r\n    requirePaymentIndexInRange(index);\r\n    Payment storage payment = payments[index];\r\n    requireExecutionAllowed(payment.receiver);\r\n    uint256 owedWei = paymentWeiOwed(index);\r\n    payment.weiPaid += owedWei;\r\n    payment.receiver.transfer(owedWei);\r\n    emit PaymentUpdated(index);\r\n  }\r\n\r\n  /**\r\n   * Return the wei owed on a payment at the current block timestamp.\r\n   **/\r\n  function paymentWeiOwed(uint256 index) public view returns (uint256) {\r\n    requirePaymentIndexInRange(index);\r\n    Payment memory payment = payments[index];\r\n    // Calculate owed wei based on current time and total wei owed/paid\r\n    return max(payment.weiPaid, payment.weiValue * min(block.timestamp - payment.timestamp, payment.time) / payment.time) - payment.weiPaid;\r\n  }\r\n\r\n  /**\r\n   * Forks a payment to another address for the remaining duration of a payment.\r\n   * Allows responsibility of funds to be delegated to other addresses by\r\n   * payment recipient or a delegate.\r\n   *\r\n   * Payment completion time is unaffected by forking, the only thing that\r\n   * changes is recipient(s).\r\n   *\r\n   * Payments can be forked until weiValue is 0, at which point the Payment is\r\n   * settled. Child payments can also be forked.\r\n   *\r\n   * The genealogy of a payment can be represented as a binary tree.\r\n   **/\r\n  function paymentFork(uint256 index, address payable _receiver, uint256 _weiValue) public {\r\n    requirePaymentIndexInRange(index);\r\n    Payment storage payment = payments[index];\r\n    // Make sure the payment receiver or a delegate is operating\r\n    requireExecutionAllowed(payment.receiver);\r\n\r\n    uint256 remainingWei = payment.weiValue - payment.weiPaid;\r\n    uint256 remainingTime = max(0, payment.time - (block.timestamp - payment.timestamp));\r\n\r\n    // Ensure there is more remainingWei than requested fork wei\r\n    require(remainingWei > _weiValue);\r\n    require(_weiValue > 0);\r\n\r\n    // Create a new Payment of _weiValue to _receiver over the remaining time of\r\n    // payment at index\r\n    payment.weiValue = payment.weiPaid;\r\n    emit PaymentUpdated(index);\r\n\r\n    payments.push(Payment({\r\n      sender: payment.receiver,\r\n      receiver: _receiver,\r\n      timestamp: block.timestamp,\r\n      time: remainingTime,\r\n      weiValue: _weiValue,\r\n      weiPaid: 0,\r\n      isFork: true,\r\n      parentIndex: index,\r\n      isForked: false,\r\n      fork1Index: 0,\r\n      fork2Index: 0\r\n    }));\r\n    payment.fork1Index = payments.length - 1;\r\n    emit PaymentCreated(payments.length - 1);\r\n\r\n    payments.push(Payment({\r\n      sender: payment.receiver,\r\n      receiver: payment.receiver,\r\n      timestamp: block.timestamp,\r\n      time: remainingTime,\r\n      weiValue: remainingWei - _weiValue,\r\n      weiPaid: 0,\r\n      isFork: true,\r\n      parentIndex: index,\r\n      isForked: false,\r\n      fork1Index: 0,\r\n      fork2Index: 0\r\n    }));\r\n    payment.fork2Index = payments.length - 1;\r\n    emit PaymentCreated(payments.length - 1);\r\n\r\n    payment.isForked = true;\r\n  }\r\n\r\n  /**\r\n   * Accessor for determining if a given payment is fully settled.\r\n   **/\r\n  function isPaymentSettled(uint256 index) public view returns (bool) {\r\n    requirePaymentIndexInRange(index);\r\n    return payments[index].weiValue == payments[index].weiPaid;\r\n  }\r\n\r\n  /**\r\n   * Reverts if the supplied payment index is out of range.\r\n   **/\r\n  function requirePaymentIndexInRange(uint256 index) public view {\r\n    require(index < payments.length);\r\n  }\r\n\r\n  /**\r\n   * Checks if msg.sender is allowed to modify payments on behalf of receiver.\r\n   **/\r\n  function requireExecutionAllowed(address payable receiver) public view {\r\n    require(msg.sender == receiver || delegates[receiver][msg.sender] == true);\r\n  }\r\n\r\n  /**\r\n   * Accessor for array length.\r\n   **/\r\n  function paymentCount() public view returns (uint) {\r\n    return payments.length;\r\n  }\r\n\r\n  /**\r\n   * Return the smaller of two values.\r\n   **/\r\n  function min(uint a, uint b) private pure returns (uint) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  /**\r\n   * Return the larger of two values.\r\n   **/\r\n  function max(uint a, uint b) private pure returns (uint) {\r\n    return a > b ? a : b;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"requireExecutionAllowed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paymentCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"requirePaymentIndexInRange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"paymentWeiOwed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isPaymentSettled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"paymentSettle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"weiValue\",\"type\":\"uint256\"},{\"name\":\"weiPaid\",\"type\":\"uint256\"},{\"name\":\"isFork\",\"type\":\"bool\"},{\"name\":\"parentIndex\",\"type\":\"uint256\"},{\"name\":\"isForked\",\"type\":\"bool\"},{\"name\":\"fork1Index\",\"type\":\"uint256\"},{\"name\":\"fork2Index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_weiValue\",\"type\":\"uint256\"}],\"name\":\"paymentFork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_delegate\",\"type\":\"address\"},{\"name\":\"delegated\",\"type\":\"bool\"}],\"name\":\"delegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"paymentCreate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegates\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"PaymentUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"PaymentCreated\",\"type\":\"event\"}]","ContractName":"Syndicate","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://35b27d79af4c79cbf54aeaee6597593599a19ad242cfa805905eee6bf7205900"}]}