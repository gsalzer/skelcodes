{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SpinWinInterface\r\n */\r\ninterface SpinWinInterface {\r\n\tfunction refundPendingBets() external returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @title AdvertisingInterface\r\n */\r\ninterface AdvertisingInterface {\r\n\tfunction incrementBetCounter() external returns (bool);\r\n}\r\n\r\n\r\ncontract SpinWinLibraryInterface {\r\n\tfunction calculateWinningReward(uint256 betValue, uint256 playerNumber, uint256 houseEdge) external pure returns (uint256);\r\n\tfunction calculateTokenReward(address settingAddress, uint256 betValue, uint256 playerNumber, uint256 houseEdge) external constant returns (uint256);\r\n\tfunction generateRandomNumber(address settingAddress, uint256 betBlockNumber, uint256 extraData, uint256 divisor) external constant returns (uint256);\r\n\tfunction calculateClearBetBlocksReward(address settingAddress, address lotteryAddress) external constant returns (uint256);\r\n\tfunction calculateLotteryContribution(address settingAddress, address lotteryAddress, uint256 betValue) external constant returns (uint256);\r\n\tfunction calculateExchangeTokenValue(address settingAddress, uint256 tokenAmount) external constant returns (uint256, uint256, uint256, uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title LotteryInterface\r\n */\r\ninterface LotteryInterface {\r\n\tfunction claimReward(address playerAddress, uint256 tokenAmount) external returns (bool);\r\n\tfunction calculateLotteryContributionPercentage() external constant returns (uint256);\r\n\tfunction getNumLottery() external constant returns (uint256);\r\n\tfunction isActive() external constant returns (bool);\r\n\tfunction getCurrentTicketMultiplierHonor() external constant returns (uint256);\r\n\tfunction getCurrentLotteryTargetBalance() external constant returns (uint256, uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title SettingInterface\r\n */\r\ninterface SettingInterface {\r\n\tfunction uintSettings(bytes32 name) external constant returns (uint256);\r\n\tfunction boolSettings(bytes32 name) external constant returns (bool);\r\n\tfunction isActive() external constant returns (bool);\r\n\tfunction canBet(uint256 rewardValue, uint256 betValue, uint256 playerNumber, uint256 houseEdge) external constant returns (bool);\r\n\tfunction isExchangeAllowed(address playerAddress, uint256 tokenAmount) external constant returns (bool);\r\n\r\n\t/******************************************/\r\n\t/*          SPINWIN ONLY METHODS          */\r\n\t/******************************************/\r\n\tfunction spinwinSetUintSetting(bytes32 name, uint256 value) external;\r\n\tfunction spinwinIncrementUintSetting(bytes32 name) external;\r\n\tfunction spinwinSetBoolSetting(bytes32 name, bool value) external;\r\n\tfunction spinwinAddFunds(uint256 amount) external;\r\n\tfunction spinwinUpdateTokenToWeiExchangeRate() external;\r\n\tfunction spinwinRollDice(uint256 betValue) external;\r\n\tfunction spinwinUpdateWinMetric(uint256 playerProfit) external;\r\n\tfunction spinwinUpdateLoseMetric(uint256 betValue, uint256 tokenRewardValue) external;\r\n\tfunction spinwinUpdateLotteryContributionMetric(uint256 lotteryContribution) external;\r\n\tfunction spinwinUpdateExchangeMetric(uint256 exchangeAmount) external;\r\n\r\n\t/******************************************/\r\n\t/*      SPINLOTTERY ONLY METHODS          */\r\n\t/******************************************/\r\n\tfunction spinlotterySetUintSetting(bytes32 name, uint256 value) external;\r\n\tfunction spinlotteryIncrementUintSetting(bytes32 name) external;\r\n\tfunction spinlotterySetBoolSetting(bytes32 name, bool value) external;\r\n\tfunction spinlotteryUpdateTokenToWeiExchangeRate() external;\r\n\tfunction spinlotterySetMinBankroll(uint256 _minBankroll) external returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @title TokenInterface\r\n */\r\ninterface TokenInterface {\r\n\tfunction getTotalSupply() external constant returns (uint256);\r\n\tfunction getBalanceOf(address account) external constant returns (uint256);\r\n\tfunction transfer(address _to, uint256 _value) external returns (bool);\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n\tfunction approve(address _spender, uint256 _value) external returns (bool success);\r\n\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) external returns (bool success);\r\n\tfunction burn(uint256 _value) external returns (bool success);\r\n\tfunction burnFrom(address _from, uint256 _value) external returns (bool success);\r\n\tfunction mintTransfer(address _to, uint _value) external returns (bool);\r\n\tfunction burnAt(address _at, uint _value) external returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 c = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\n\r\n\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\r\n\r\ncontract TokenERC20 {\r\n\t// Public variables of the token\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals = 18;\r\n\t// 18 decimals is the strongly suggested default, avoid changing it\r\n\tuint256 public totalSupply;\r\n\r\n\t// This creates an array with all balances\r\n\tmapping (address => uint256) public balanceOf;\r\n\tmapping (address => mapping (address => uint256)) public allowance;\r\n\r\n\t// This generates a public event on the blockchain that will notify clients\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\t// This generates a public event on the blockchain that will notify clients\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n\t// This notifies clients about the amount burnt\r\n\tevent Burn(address indexed from, uint256 value);\r\n\r\n\t/**\r\n\t * Constructor function\r\n\t *\r\n\t * Initializes contract with initial supply tokens to the creator of the contract\r\n\t */\r\n\tconstructor(\r\n\t\tuint256 initialSupply,\r\n\t\tstring tokenName,\r\n\t\tstring tokenSymbol\r\n\t) public {\r\n\t\ttotalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\r\n\t\tbalanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\r\n\t\tname = tokenName;                                   // Set the name for display purposes\r\n\t\tsymbol = tokenSymbol;                               // Set the symbol for display purposes\r\n\t}\r\n\r\n\t/**\r\n\t * Internal transfer, only can be called by this contract\r\n\t */\r\n\tfunction _transfer(address _from, address _to, uint _value) internal {\r\n\t\t// Prevent transfer to 0x0 address. Use burn() instead\r\n\t\trequire(_to != 0x0);\r\n\t\t// Check if the sender has enough\r\n\t\trequire(balanceOf[_from] >= _value);\r\n\t\t// Check for overflows\r\n\t\trequire(balanceOf[_to] + _value > balanceOf[_to]);\r\n\t\t// Save this for an assertion in the future\r\n\t\tuint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n\t\t// Subtract from the sender\r\n\t\tbalanceOf[_from] -= _value;\r\n\t\t// Add the same to the recipient\r\n\t\tbalanceOf[_to] += _value;\r\n\t\temit Transfer(_from, _to, _value);\r\n\t\t// Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n\t\tassert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n\t}\r\n\r\n\t/**\r\n\t * Transfer tokens\r\n\t *\r\n\t * Send `_value` tokens to `_to` from your account\r\n\t *\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool success) {\r\n\t\t_transfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Transfer tokens from other address\r\n\t *\r\n\t * Send `_value` tokens to `_to` in behalf of `_from`\r\n\t *\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n\t\trequire(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n\t\tallowance[_from][msg.sender] -= _value;\r\n\t\t_transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Set allowance for other address\r\n\t *\r\n\t * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\n\t *\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value the max amount they can spend\r\n\t */\r\n\tfunction approve(address _spender, uint256 _value) public returns (bool success) {\r\n\t\tallowance[msg.sender][_spender] = _value;\r\n\t\temit Approval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Set allowance for other address and notify\r\n\t *\r\n\t * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\r\n\t *\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value the max amount they can spend\r\n\t * @param _extraData some extra information to send to the approved contract\r\n\t */\r\n\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n\t\tpublic\r\n\t\treturns (bool success) {\r\n\t\ttokenRecipient spender = tokenRecipient(_spender);\r\n\t\tif (approve(_spender, _value)) {\r\n\t\t\tspender.receiveApproval(msg.sender, _value, this, _extraData);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Destroy tokens\r\n\t *\r\n\t * Remove `_value` tokens from the system irreversibly\r\n\t *\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction burn(uint256 _value) public returns (bool success) {\r\n\t\trequire(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n\t\tbalanceOf[msg.sender] -= _value;            // Subtract from the sender\r\n\t\ttotalSupply -= _value;                      // Updates totalSupply\r\n\t\temit Burn(msg.sender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Destroy tokens from other account\r\n\t *\r\n\t * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n\t *\r\n\t * @param _from the address of the sender\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n\t\trequire(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n\t\trequire(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n\t\tbalanceOf[_from] -= _value;                         // Subtract from the targeted balance\r\n\t\tallowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n\t\ttotalSupply -= _value;                              // Update totalSupply\r\n\t\temit Burn(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\ncontract developed {\r\n\taddress public developer;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() public {\r\n\t\tdeveloper = msg.sender;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks only developer address is calling\r\n\t */\r\n\tmodifier onlyDeveloper {\r\n\t\trequire(msg.sender == developer);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to switch developer address\r\n\t * @param _developer The new developer address to be set\r\n\t */\r\n\tfunction changeDeveloper(address _developer) public onlyDeveloper {\r\n\t\tdeveloper = _developer;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to withdraw ERC20 Token\r\n\t */\r\n\tfunction withdrawToken(address tokenContractAddress) public onlyDeveloper {\r\n\t\tTokenERC20 _token = TokenERC20(tokenContractAddress);\r\n\t\tif (_token.balanceOf(this) > 0) {\r\n\t\t\t_token.transfer(developer, _token.balanceOf(this));\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SpinWin\r\n */\r\ncontract SpinWin is developed, SpinWinInterface {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public tokenAddress;\r\n\taddress public settingAddress;\r\n\taddress public lotteryAddress;\r\n\r\n\tTokenInterface internal _spintoken;\r\n\tSettingInterface internal _setting;\r\n\tLotteryInterface internal _lottery;\r\n\tSpinWinLibraryInterface internal _lib;\r\n\tAdvertisingInterface internal _advertising;\r\n\r\n\t/**\r\n\t * @dev Player variables\r\n\t */\r\n\tstruct Bet {\r\n\t\taddress playerAddress;\r\n\t\tbytes32 betId;\r\n\t\tuint256 betValue;\r\n\t\tuint256 diceResult;\r\n\t\tuint256 playerNumber;\r\n\t\tuint256 houseEdge;\r\n\t\tuint256 rewardValue;\r\n\t\tuint256 tokenRewardValue;\r\n\t\tuint256 blockNumber;\r\n\t\tbool processed;\r\n\t}\r\n\tstruct TokenExchange {\r\n\t\taddress playerAddress;\r\n\t\tbytes32 exchangeId;\r\n\t\tbool processed;\r\n\t}\r\n\r\n\tmapping (uint256 => Bet) internal bets;\r\n\tmapping (bytes32 => uint256) internal betIdLookup;\r\n\tmapping (address => uint256) public playerPendingWithdrawals;\r\n\tmapping (address => uint256) public playerPendingTokenWithdrawals;\r\n\tmapping (address => address) public referees;\r\n\tmapping (bytes32 => TokenExchange) public tokenExchanges;\r\n\tmapping (address => uint256) public lotteryBlocksAmount;\r\n\r\n\tuint256 constant public TWO_DECIMALS = 100;\r\n\tuint256 constant public PERCENTAGE_DIVISOR = 10 ** 6;   // 1000000 = 100%\r\n\tuint256 constant public CURRENCY_DIVISOR = 10**18;\r\n\r\n\tuint256 public totalPendingBets;\r\n\r\n\t/**\r\n\t * @dev Log when bet is placed\r\n\t */\r\n\tevent LogBet(bytes32 indexed betId, address indexed playerAddress, uint256 playerNumber, uint256 betValue, uint256 houseEdge, uint256 rewardValue, uint256 tokenRewardValue);\r\n\r\n\t/**\r\n\t * @dev Log when bet is cleared\r\n\t *\r\n\t * Status:\r\n\t * -2 = lose + failed mint and transfer\r\n\t * -1 = lose + failed send\r\n\t * 0 = lose\r\n\t * 1 = win\r\n\t * 2 = win + failed send\r\n\t * 3 = refund\r\n\t * 4 = refund + failed send\r\n\t * 5 = owner cancel + refund\r\n\t * 6 = owner cancel + refund + failed send\r\n\t */\r\n\tevent LogResult(bytes32 indexed betId, address indexed playerAddress, uint256 playerNumber, uint256 diceResult, uint256 betValue, uint256 houseEdge, uint256 rewardValue, uint256 tokenRewardValue, int256 status);\r\n\r\n\t/**\r\n\t * @dev Log when spinwin contributes some ETH to the lottery contract address\r\n\t */\r\n\tevent LogLotteryContribution(bytes32 indexed betId, address indexed playerAddress, uint256 weiValue);\r\n\r\n\t/**\r\n\t * @dev Log when spinwin rewards the referee of a bet or the person clears bet\r\n\t * rewardType\r\n\t * 1 = referral\r\n\t * 2 = clearBet\r\n\t */\r\n\tevent LogRewardLotteryBlocks(address indexed receiver, bytes32 indexed betId, uint256 lottoBlocksAmount, uint256 rewardType, uint256 status);\r\n\r\n\t/**\r\n\t * @dev Log when player clears bets\r\n\t */\r\n\tevent LogClearBets(address indexed playerAddress);\r\n\r\n\t/**\r\n\t * @dev Log when player claims the lottery blocks reward\r\n\t *\r\n\t * Status:\r\n\t * 0 = failed\r\n\t * 1 = success\r\n\t */\r\n\tevent LogClaimLotteryBlocks(address indexed playerAddress, uint256 numLottery, uint256 claimAmount, uint256 claimStatus);\r\n\r\n\t/**\r\n\t * @dev Log when player exchanges token to Wei\r\n\t *\r\n\t * Status:\r\n\t * 0 = failed send\r\n\t * 1 = success\r\n\t * 2 = failed destroy token\r\n\t */\r\n\tevent LogTokenExchange(bytes32 indexed exchangeId, address indexed playerAddress, uint256 tokenValue, uint256 tokenToWeiExchangeRate, uint256 weiValue, uint256 receivedWeiValue, uint256 remainderTokenValue, uint256 status);\r\n\r\n\t/**\r\n\t * @dev Log when player withdraws balance from failed transfer\r\n\t *\r\n\t * Status:\r\n\t * 0 = failed\r\n\t * 1 = success\r\n\t */\r\n\tevent LogPlayerWithdrawBalance(address indexed playerAddress, uint256 withdrawAmount, uint256 status);\r\n\r\n\t/**\r\n\t * @dev Log when player withdraw token balance from failed token transfer\r\n\t *\r\n\t * Status:\r\n\t * 0 = failed\r\n\t * 1 = success\r\n\t */\r\n\tevent LogPlayerWithdrawTokenBalance(address indexed playerAddress, uint256 withdrawAmount, uint256 status);\r\n\r\n\t/**\r\n\t * @dev Log when a bet ID is not found during clear bet\r\n\t */\r\n\tevent LogBetNotFound(bytes32 indexed betId);\r\n\r\n\t/**\r\n\t * @dev Log when developer cancel existing active bet\r\n\t */\r\n\tevent LogDeveloperCancelBet(bytes32 indexed betId, address indexed playerAddress);\r\n\r\n\t/**\r\n\t * Constructor\r\n\t * @param _tokenAddress SpinToken contract address\r\n\t * @param _settingAddress GameSetting contract address\r\n\t * @param _libraryAddress SpinWinLibrary contract address\r\n\t */\r\n\tconstructor(address _tokenAddress, address _settingAddress, address _libraryAddress) public {\r\n\t\ttokenAddress = _tokenAddress;\r\n\t\tsettingAddress = _settingAddress;\r\n\t\t_spintoken = TokenInterface(_tokenAddress);\r\n\t\t_setting = SettingInterface(_settingAddress);\r\n\t\t_lib = SpinWinLibraryInterface(_libraryAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if contract is active\r\n\t */\r\n\tmodifier isActive {\r\n\t\trequire(_setting.isActive() == true);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks whether a bet is allowed, and player profit, bet value, house edge and player number are within range\r\n\t */\r\n\tmodifier canBet(uint256 _betValue, uint256 _playerNumber, uint256 _houseEdge) {\r\n\t\trequire(_setting.canBet(_lib.calculateWinningReward(_betValue, _playerNumber, _houseEdge), _betValue, _playerNumber, _houseEdge) == true);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if bet exist\r\n\t */\r\n\tmodifier betExist(bytes32 betId, address playerAddress) {\r\n\t\trequire(betIdLookup[betId] > 0 && bets[betIdLookup[betId]].betId == betId && bets[betIdLookup[betId]].playerAddress == playerAddress);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if token exchange is allowed\r\n\t */\r\n\tmodifier isExchangeAllowed(address playerAddress, uint256 tokenAmount) {\r\n\t\trequire(_setting.isExchangeAllowed(playerAddress, tokenAmount) == true);\r\n\t\t_;\r\n\t}\r\n\r\n\t/******************************************/\r\n\t/*       DEVELOPER ONLY METHODS           */\r\n\t/******************************************/\r\n\t/**\r\n\t * @dev Allows developer to set lottery contract address\r\n\t * @param _lotteryAddress The new lottery contract address to be set\r\n\t */\r\n\tfunction devSetLotteryAddress(address _lotteryAddress) public onlyDeveloper {\r\n\t\trequire (_lotteryAddress != address(0));\r\n\t\tlotteryAddress = _lotteryAddress;\r\n\t\t_lottery = LotteryInterface(_lotteryAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to set advertising contract address\r\n\t * @param _advertisingAddress The new advertising contract address to be set\r\n\t */\r\n\tfunction devSetAdvertisingAddress(address _advertisingAddress) public onlyDeveloper {\r\n\t\trequire (_advertisingAddress != address(0));\r\n\t\t_advertising = AdvertisingInterface(_advertisingAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to get bet internal ID based on public betId\r\n\t * @param betId The public betId\r\n\t * @return The bet internal ID\r\n\t */\r\n\tfunction devGetBetInternalId(bytes32 betId) public onlyDeveloper constant returns (uint256) {\r\n\t\treturn (betIdLookup[betId]);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to get bet info based on `betInternalId`\r\n\t * @param betInternalId The bet internal ID to be queried\r\n\t * @return The bet information\r\n\t */\r\n\tfunction devGetBet(uint256 betInternalId) public\r\n\t\tonlyDeveloper\r\n\t\tconstant returns (address, uint256, uint256, uint256, uint256, uint256, uint256, uint256, bool) {\r\n\t\tBet memory _bet = bets[betInternalId];\r\n\t\treturn (_bet.playerAddress, _bet.betValue, _bet.diceResult, _bet.playerNumber, _bet.houseEdge, _bet.rewardValue, _bet.tokenRewardValue, _bet.blockNumber, _bet.processed);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to manually refund existing active bet.\r\n\t * @param betId The ID of the bet to be cancelled\r\n\t * @return Return true if success\r\n\t */\r\n\tfunction devRefundBet(bytes32 betId) public onlyDeveloper returns (bool) {\r\n\t\trequire (betIdLookup[betId] > 0);\r\n\r\n\t\tBet storage _bet = bets[betIdLookup[betId]];\r\n\r\n\t\trequire(_bet.processed == false);\r\n\r\n\t\t_bet.processed = true;\r\n\t\tuint256 betValue = _bet.betValue;\r\n\t\t_bet.betValue = 0;\r\n\t\t_bet.rewardValue = 0;\r\n\t\t_bet.tokenRewardValue = 0;\r\n\r\n\t\t_refundPlayer(betIdLookup[betId], betValue);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Add funds to the contract\r\n\t */\r\n\tfunction () public payable isActive {\r\n\t\t_setting.spinwinAddFunds(msg.value);\r\n\t}\r\n\r\n\t/******************************************/\r\n\t/*           SETTING METHODS              */\r\n\t/******************************************/\r\n\t/**\r\n\t * @dev Triggered during escape hatch. Go through each pending bets\r\n\t * and move the bet value to playerPendingWithdrawals so that player\r\n\t * can withdraw later\r\n\t */\r\n\tfunction refundPendingBets() public returns (bool) {\r\n\t\trequire (msg.sender == settingAddress);\r\n\t\tuint256 totalBets = _setting.uintSettings('totalBets');\r\n\t\tif (totalBets > 0) {\r\n\t\t\tfor (uint256 i = 1; i <= totalBets; i++) {\r\n\t\t\t\tBet storage _bet = bets[i];\r\n\t\t\t\tif (_bet.processed == false) {\r\n\t\t\t\t\tuint256 _betValue = _bet.betValue;\r\n\t\t\t\t\t_bet.processed = true;\r\n\t\t\t\t\t_bet.betValue = 0;\r\n\t\t\t\t\tplayerPendingWithdrawals[_bet.playerAddress] = playerPendingWithdrawals[_bet.playerAddress].add(_betValue);\r\n\t\t\t\t\temit LogResult(_bet.betId, _bet.playerAddress, _bet.playerNumber, 0, _betValue, _bet.houseEdge, 0, 0, 4);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/******************************************/\r\n\t/*            PUBLIC METHODS              */\r\n\t/******************************************/\r\n\t/**\r\n\t * @dev Player places a bet. If it has a `referrerAddress`, we want to give reward to the referrer accordingly.\r\n\t * @dev If there is a bet that needs to be cleared, we will do it here too.\r\n\t * @param playerNumber The number that the player chose\r\n\t * @param houseEdge The house edge percentage that the player chose\r\n\t * @param clearBetId The bet ID to be cleared\r\n\t * @param referreeAddress The referree address if exist\r\n\t * @return Return true if success\r\n\t */\r\n\tfunction rollDice(uint256 playerNumber, uint256 houseEdge, bytes32 clearBetId, address referreeAddress) public\r\n\t\tpayable\r\n\t\tcanBet(msg.value, playerNumber, houseEdge)\r\n\t\treturns (bool) {\r\n\t\tuint256 betInternalId = _storeBet(msg.value, msg.sender, playerNumber, houseEdge);\r\n\r\n\t\t// Check if we need to clear a pending bet\r\n\t\tif (clearBetId != '') {\r\n\t\t\t_clearSingleBet(msg.sender, clearBetId, _setting.uintSettings('blockSecurityCount'));\r\n\t\t}\r\n\r\n\t\t// Check if we need to reward the referree\r\n\t\t_rewardReferree(referreeAddress, betInternalId);\r\n\r\n\t\t_advertising.incrementBetCounter();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Player can clear multiple bets\r\n\t * @param betIds The bet ids to be cleared\r\n\t */\r\n\tfunction clearBets(bytes32[] betIds) public isActive {\r\n\t\trequire (betIds.length > 0 && betIds.length <= _setting.uintSettings('maxNumClearBets'));\r\n\t\tbool canClear = false;\r\n\t\tuint256 blockSecurityCount = _setting.uintSettings('blockSecurityCount');\r\n\t\tfor (uint256 i = 0; i < betIds.length; i++) {\r\n\t\t\tBet memory _bet = bets[betIdLookup[betIds[i]]];\r\n\t\t\tif (_bet.processed == false && _setting.uintSettings('contractBalance') >= _bet.rewardValue && (block.number.sub(_bet.blockNumber)) >= blockSecurityCount) {\r\n\t\t\t\tcanClear = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\trequire(canClear == true);\r\n\r\n\t\t// Loop through each bets and clear it if possible\r\n\t\tfor (i = 0; i < betIds.length; i++) {\r\n\t\t\t_clearSingleBet(msg.sender, betIds[i], blockSecurityCount);\r\n\t\t}\r\n\t\temit LogClearBets(msg.sender);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allow player to claim lottery blocks reward\r\n\t * and spend it on lottery blocks\r\n\t */\r\n\tfunction claimLotteryBlocks() public isActive {\r\n\t\trequire (_lottery.isActive() == true);\r\n\t\trequire (lotteryBlocksAmount[msg.sender] > 0);\r\n\t\tuint256 claimAmount = lotteryBlocksAmount[msg.sender];\r\n\t\tlotteryBlocksAmount[msg.sender] = 0;\r\n\t\tuint256 claimStatus = 1;\r\n\t\tif (!_lottery.claimReward(msg.sender, claimAmount)) {\r\n\t\t\tclaimStatus = 0;\r\n\t\t\tlotteryBlocksAmount[msg.sender] = claimAmount;\r\n\t\t}\r\n\t\temit LogClaimLotteryBlocks(msg.sender, _lottery.getNumLottery(), claimAmount, claimStatus);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Player exchanges token for Wei\r\n\t * @param tokenAmount The amount of token to be exchanged\r\n\t * @return Return true if success\r\n\t */\r\n\tfunction exchangeToken(uint256 tokenAmount) public\r\n\t\tisExchangeAllowed(msg.sender, tokenAmount) {\r\n\t\t(uint256 weiValue, uint256 sendWei, uint256 tokenRemainder, uint256 burnToken) = _lib.calculateExchangeTokenValue(settingAddress, tokenAmount);\r\n\r\n\t\t_setting.spinwinIncrementUintSetting('totalTokenExchanges');\r\n\r\n\t\t// Generate exchangeId\r\n\t\tbytes32 _exchangeId = keccak256(abi.encodePacked(this, msg.sender, _setting.uintSettings('totalTokenExchanges')));\r\n\t\tTokenExchange storage _tokenExchange = tokenExchanges[_exchangeId];\r\n\r\n\t\t// Make sure we don't process the exchange bet twice\r\n\t\trequire (_tokenExchange.processed == false);\r\n\r\n\t\t// Update exchange metric\r\n\t\t_setting.spinwinUpdateExchangeMetric(sendWei);\r\n\r\n\t\t/*\r\n\t\t * Store the info about this exchange\r\n\t\t */\r\n\t\t_tokenExchange.playerAddress = msg.sender;\r\n\t\t_tokenExchange.exchangeId = _exchangeId;\r\n\t\t_tokenExchange.processed = true;\r\n\r\n\t\t/*\r\n\t\t * Burn token at this address\r\n\t\t */\r\n\t\tif (!_spintoken.burnAt(_tokenExchange.playerAddress, burnToken)) {\r\n\t\t\tuint256 exchangeStatus = 2; // status = failed destroy token\r\n\r\n\t\t} else {\r\n\t\t\tif (!_tokenExchange.playerAddress.send(sendWei)) {\r\n\t\t\t\texchangeStatus = 0; // status = failed send\r\n\r\n\t\t\t\t// If send failed, let player withdraw via playerWithdrawPendingTransactions\r\n\t\t\t\tplayerPendingWithdrawals[_tokenExchange.playerAddress] = playerPendingWithdrawals[_tokenExchange.playerAddress].add(sendWei);\r\n\t\t\t} else {\r\n\t\t\t\texchangeStatus = 1; // status = success\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Update the token to wei exchange rate\r\n\t\t_setting.spinwinUpdateTokenToWeiExchangeRate();\r\n\r\n\t\temit LogTokenExchange(_tokenExchange.exchangeId, _tokenExchange.playerAddress, tokenAmount, _setting.uintSettings('tokenToWeiExchangeRateHonor'), weiValue, sendWei, tokenRemainder, exchangeStatus);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate winning ETH when player wins\r\n\t * @param betValue The amount of ETH for this bet\r\n\t * @param playerNumber The number that player chose\r\n\t * @param houseEdge The house edge for this bet\r\n\t * @return The amount of ETH to be sent to player if he/she wins\r\n\t */\r\n\tfunction calculateWinningReward(uint256 betValue, uint256 playerNumber, uint256 houseEdge) public view returns (uint256) {\r\n\t\treturn _lib.calculateWinningReward(betValue, playerNumber, houseEdge);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculates token reward amount when player loses\r\n\t * @param betValue The amount of ETH for this bet\r\n\t * @param playerNumber The number that player chose\r\n\t * @param houseEdge The house edge for this bet\r\n\t * @return The amount of token to be sent to player if he/she loses\r\n\t */\r\n\tfunction calculateTokenReward(uint256 betValue, uint256 playerNumber, uint256 houseEdge) public constant returns (uint256) {\r\n\t\treturn _lib.calculateTokenReward(settingAddress, betValue, playerNumber, houseEdge);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Player withdraws balance in case of a failed refund or failed win send\r\n\t */\r\n\tfunction playerWithdrawPendingTransactions() public {\r\n\t\trequire(playerPendingWithdrawals[msg.sender] > 0);\r\n\t\tuint256 withdrawAmount = playerPendingWithdrawals[msg.sender];\r\n\t\tplayerPendingWithdrawals[msg.sender] = 0;\r\n\r\n\t\t// External call to untrusted contract\r\n\t\tuint256 status = 1; // status = success\r\n\t\tif (!msg.sender.send(withdrawAmount)) {\r\n\t\t\tstatus = 0; // status = failed\r\n\r\n\t\t\t/*\r\n\t\t\t * If send failed, revert playerPendingWithdrawals[msg.sender] = 0\r\n\t\t\t * so that player can try to withdraw again later\r\n\t\t\t */\r\n\t\t\tplayerPendingWithdrawals[msg.sender] = withdrawAmount;\r\n\t\t}\r\n\t\temit LogPlayerWithdrawBalance(msg.sender, withdrawAmount, status);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Players withdraws SPIN token balance in case of a failed token transfer\r\n\t */\r\n\tfunction playerWithdrawPendingTokenTransactions() public {\r\n\t\trequire(playerPendingTokenWithdrawals[msg.sender] > 0);\r\n\t\tuint256 withdrawAmount = playerPendingTokenWithdrawals[msg.sender];\r\n\t\tplayerPendingTokenWithdrawals[msg.sender] = 0;\r\n\r\n\t\t// Mint and transfer token to msg.sender\r\n\t\tuint256 status = 1; // status = success\r\n\t\tif (!_spintoken.mintTransfer(msg.sender, withdrawAmount)) {\r\n\t\t\tstatus = 0; // status = failed\r\n\t\t\t/*\r\n\t\t\t * If transfer failed, revert playerPendingTokenWithdrawals[msg.sender] = 0\r\n\t\t\t * so that player can try to withdraw again later\r\n\t\t\t */\r\n\t\t\tplayerPendingTokenWithdrawals[msg.sender] = withdrawAmount;\r\n\t\t}\r\n\t\temit LogPlayerWithdrawTokenBalance(msg.sender, withdrawAmount, status);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Player gets bet information based on betId\r\n\t * @return The bet information\r\n\t */\r\n\tfunction playerGetBet(bytes32 betId) public\r\n\t\tconstant returns (uint256, uint256, uint256, uint256, uint256, uint256, bool) {\r\n\t\trequire(betIdLookup[betId] > 0 && bets[betIdLookup[betId]].betId == betId);\r\n\t\tBet memory _bet = bets[betIdLookup[betId]];\r\n\t\treturn (_bet.betValue, _bet.diceResult, _bet.playerNumber, _bet.houseEdge, _bet.rewardValue, _bet.tokenRewardValue, _bet.processed);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Player gets pending bet IDs\r\n\t * @return The pending bet IDs\r\n\t */\r\n\tfunction playerGetPendingBetIds() public constant returns (bytes32[]) {\r\n\t\tbytes32[] memory pendingBetIds = new bytes32[](totalPendingBets);\r\n\t\tif (totalPendingBets > 0) {\r\n\t\t\tuint256 counter = 0;\r\n\t\t\tfor (uint256 i = 1; i <= _setting.uintSettings('totalBets'); i++) {\r\n\t\t\t\tBet memory _bet = bets[i];\r\n\t\t\t\tif (_bet.processed == false) {\r\n\t\t\t\t\tpendingBetIds[counter] = _bet.betId;\r\n\t\t\t\t\tcounter++;\r\n\t\t\t\t}\r\n\t\t\t\tif (counter == totalPendingBets) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn pendingBetIds;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Player gets pending bet information based on betId\r\n\t * @return The bet information\r\n\t */\r\n\tfunction playerGetPendingBet(bytes32 betId) public\r\n\t\tconstant returns (address, uint256, uint256, uint256, uint256) {\r\n\t\trequire(betIdLookup[betId] > 0 && bets[betIdLookup[betId]].betId == betId);\r\n\t\tBet memory _bet = bets[betIdLookup[betId]];\r\n\t\treturn (_bet.playerAddress, _bet.playerNumber, _bet.betValue, _bet.houseEdge, _bet.blockNumber);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculates lottery block rewards when player clears a bet\r\n\t * @return The amount of lottery blocks to be rewarded when player clears bet\r\n\t */\r\n\tfunction calculateClearBetBlocksReward() public constant returns (uint256) {\r\n\t\treturn _lib.calculateClearBetBlocksReward(settingAddress, lotteryAddress);\r\n\t}\r\n\r\n\r\n\t/******************************************/\r\n\t/*           INTERNAL METHODS             */\r\n\t/******************************************/\r\n\r\n\t/**\r\n\t * @dev Stores bet information.\r\n\t * @param betValue The value of the bet\r\n\t * @param playerAddress The player address\r\n\t * @param playerNumber The number that player chose\r\n\t * @param houseEdge The house edge for this bet\r\n\t * @return The internal  bet ID of this bet\r\n\t */\r\n\tfunction _storeBet (uint256 betValue, address playerAddress, uint256 playerNumber, uint256 houseEdge) internal returns (uint256) {\r\n\t\t// Update the setting metric\r\n\t\t_setting.spinwinRollDice(betValue);\r\n\r\n\t\tuint256 betInternalId = _setting.uintSettings('totalBets');\r\n\r\n\t\t// Generate betId\r\n\t\tbytes32 betId = keccak256(abi.encodePacked(this, playerAddress, betInternalId));\r\n\r\n\t\tBet storage _bet = bets[betInternalId];\r\n\r\n\t\t// Make sure we don't process the same bet twice\r\n\t\trequire (_bet.processed == false);\r\n\r\n\t\t// Store the info about this bet\r\n\t\tbetIdLookup[betId] = betInternalId;\r\n\t\t_bet.playerAddress = playerAddress;\r\n\t\t_bet.betId = betId;\r\n\t\t_bet.betValue = betValue;\r\n\t\t_bet.playerNumber = playerNumber;\r\n\t\t_bet.houseEdge = houseEdge;\r\n\r\n\t\t// Safely calculate winning reward\r\n\t\t_bet.rewardValue = calculateWinningReward(betValue, playerNumber, houseEdge);\r\n\r\n\t\t// Safely calculate token payout\r\n\t\t_bet.tokenRewardValue = calculateTokenReward(betValue, playerNumber, houseEdge);\r\n\t\t_bet.blockNumber = block.number;\r\n\r\n\t\t// Update the pendingBets counter\r\n\t\ttotalPendingBets++;\r\n\r\n\t\temit LogBet(_bet.betId, _bet.playerAddress, _bet.playerNumber, _bet.betValue, _bet.houseEdge, _bet.rewardValue, _bet.tokenRewardValue);\r\n\t\treturn betInternalId;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Internal function to clear single bet\r\n\t * @param playerAddress The player who clears this bet\r\n\t * @param betId The bet ID to be cleared\r\n\t * @param blockSecurityCount The block security count to be checked\r\n\t * @return true if success, false otherwise\r\n\t */\r\n\tfunction _clearSingleBet(address playerAddress, bytes32 betId, uint256 blockSecurityCount) internal returns (bool) {\r\n\t\tif (betIdLookup[betId] > 0) {\r\n\t\t\tBet memory _bet = bets[betIdLookup[betId]];\r\n\r\n\t\t\t/* Check if we can clear this bet\r\n\t\t\t * - Make sure we don't process the same bet twice\r\n\t\t\t * - Check if contract can payout on win\r\n\t\t\t * - block number difference >= blockSecurityCount\r\n\t\t\t */\r\n\t\t\tif (_bet.processed == false && _setting.uintSettings('contractBalance') >= _bet.rewardValue && (block.number.sub(_bet.blockNumber)) >= blockSecurityCount) {\r\n\t\t\t\t_processBet(playerAddress, betIdLookup[betId], true);\r\n\t\t\t} else {\r\n\t\t\t\temit LogRewardLotteryBlocks(playerAddress, _bet.betId, 0, 2, 0);\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\temit LogBetNotFound(betId);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Internal function to process existing bet.\r\n\t * If no dice result, then we initiate a refund.\r\n\t * If player wins (dice result < player number), we send player winning ETH.\r\n\t * If player loses (dice result >= player number), we send player some SPIN token.\r\n\t * If player loses and bankroll goal is reached, spinwin will contribute some ETH to lottery contract address.\r\n\t *\r\n\t * @param triggerAddress The player who clears this bet\r\n\t * @param betInternalId The bet internal ID to be processed\r\n\t * @param isClearMultiple Whether or not this is part of clear multiple bets transaction\r\n\t * @return Return true if success\r\n\t */\r\n\tfunction _processBet(address triggerAddress, uint256 betInternalId, bool isClearMultiple) internal returns (bool) {\r\n\t\tBet storage _bet =  bets[betInternalId];\r\n\t\tuint256 _betValue = _bet.betValue;\r\n\t\tuint256 _rewardValue = _bet.rewardValue;\r\n\t\tuint256 _tokenRewardValue = _bet.tokenRewardValue;\r\n\r\n\t\t// Prevent re-entrancy\r\n\t\t_bet.processed = true;\r\n\t\t_bet.betValue = 0;\r\n\t\t_bet.rewardValue = 0;\r\n\t\t_bet.tokenRewardValue = 0;\r\n\r\n\t\t// Generate the result\r\n\t\t_bet.diceResult = _lib.generateRandomNumber(settingAddress, _bet.blockNumber, _setting.uintSettings('totalBets').add(_setting.uintSettings('totalWeiWagered')), 100);\r\n\r\n\t\tif (_bet.diceResult == 0) {\r\n\t\t\t/*\r\n\t\t\t * Invalid random number. Refund the player\r\n\t\t\t */\r\n\t\t\t_refundPlayer(betInternalId, _betValue);\r\n\t\t} else if (_bet.diceResult < _bet.playerNumber) {\r\n\t\t\t/*\r\n\t\t\t * Player wins. Send the player the winning eth amount\r\n\t\t\t */\r\n\t\t\t_payWinner(betInternalId, _betValue, _rewardValue);\r\n\t\t} else {\r\n\t\t\t/*\r\n\t\t\t * Player loses. Send the player 1 wei and the spintoken amount\r\n\t\t\t */\r\n\t\t\t_payLoser(betInternalId, _betValue, _tokenRewardValue);\r\n\t\t}\r\n\t\t// Update the pendingBets counter\r\n\t\ttotalPendingBets--;\r\n\r\n\t\t// Update the token to wei exchange rate\r\n\t\t_setting.spinwinUpdateTokenToWeiExchangeRate();\r\n\r\n\t\t// Calculate the lottery blocks reward for this transaction\r\n\t\tuint256 lotteryBlocksReward = calculateClearBetBlocksReward();\r\n\r\n\t\t// If this is a single clear (from placing bet), we want to multiply this with clearSingleBetMultiplier\r\n\t\tif (isClearMultiple == false) {\r\n\t\t\tuint256 multiplier = _setting.uintSettings('clearSingleBetMultiplier');\r\n\t\t} else {\r\n\t\t\tmultiplier = _setting.uintSettings('clearMultipleBetsMultiplier');\r\n\t\t}\r\n\t\tlotteryBlocksReward = (lotteryBlocksReward.mul(multiplier)).div(TWO_DECIMALS);\r\n\r\n\t\tlotteryBlocksAmount[triggerAddress] = lotteryBlocksAmount[triggerAddress].add(lotteryBlocksReward);\r\n\t\temit LogRewardLotteryBlocks(triggerAddress, _bet.betId, lotteryBlocksReward, 2, 1);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Refund the player when we are unable to determine the dice result\r\n\t * @param betInternalId The bet internal ID\r\n\t * @param refundAmount The amount to be refunded\r\n\t */\r\n\tfunction _refundPlayer(uint256 betInternalId, uint256 refundAmount) internal {\r\n\t\tBet memory _bet =  bets[betInternalId];\r\n\t\t/*\r\n\t\t * Send refund - external call to an untrusted contract\r\n\t\t * If send fails, map refund value to playerPendingWithdrawals[address]\r\n\t\t * for withdrawal later via playerWithdrawPendingTransactions\r\n\t\t */\r\n\t\tint256 betStatus = 3; // status = refund\r\n\t\tif (!_bet.playerAddress.send(refundAmount)) {\r\n\t\t\tbetStatus = 4; // status = refund + failed send\r\n\r\n\t\t\t// If send failed, let player withdraw via playerWithdrawPendingTransactions\r\n\t\t\tplayerPendingWithdrawals[_bet.playerAddress] = playerPendingWithdrawals[_bet.playerAddress].add(refundAmount);\r\n\t\t}\r\n\t\temit LogResult(_bet.betId, _bet.playerAddress, _bet.playerNumber, _bet.diceResult, refundAmount, _bet.houseEdge, 0, 0, betStatus);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Pays the player the winning eth amount\r\n\t * @param betInternalId The bet internal ID\r\n\t * @param betValue The original wager\r\n\t * @param playerProfit The player profit\r\n\t */\r\n\tfunction _payWinner(uint256 betInternalId, uint256 betValue, uint256 playerProfit) internal {\r\n\t\tBet memory _bet =  bets[betInternalId];\r\n\t\t// Update setting's contract balance and total wei won\r\n\t\t_setting.spinwinUpdateWinMetric(playerProfit);\r\n\r\n\t\t// Safely calculate payout via profit plus original wager\r\n\t\tplayerProfit = playerProfit.add(betValue);\r\n\r\n\t\t/*\r\n\t\t * Send win - external call to an untrusted contract\r\n\t\t * If send fails, map reward value to playerPendingWithdrawals[address]\r\n\t\t * for withdrawal later via playerWithdrawPendingTransactions\r\n\t\t */\r\n\t\tint256 betStatus = 1; // status = win\r\n\t\tif (!_bet.playerAddress.send(playerProfit)) {\r\n\t\t\tbetStatus = 2; // status = win + failed send\r\n\r\n\t\t\t// If send failed, let player withdraw via playerWithdrawPendingTransactions\r\n\t\t\tplayerPendingWithdrawals[_bet.playerAddress] = playerPendingWithdrawals[_bet.playerAddress].add(playerProfit);\r\n\t\t}\r\n\t\temit LogResult(_bet.betId, _bet.playerAddress, _bet.playerNumber, _bet.diceResult, betValue, _bet.houseEdge, playerProfit, 0, betStatus);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Pays the player 1 wei and the spintoken amount\r\n\t * @param betInternalId The bet internal ID\r\n\t * @param betValue The original wager\r\n\t * @param tokenRewardValue The token reward for this bet\r\n\t */\r\n\tfunction _payLoser(uint256 betInternalId, uint256 betValue, uint256 tokenRewardValue) internal {\r\n\t\tBet memory _bet =  bets[betInternalId];\r\n\t\t/*\r\n\t\t * Update the game setting metric when player loses\r\n\t\t */\r\n\t\t_setting.spinwinUpdateLoseMetric(betValue, tokenRewardValue);\r\n\r\n\t\tint256 betStatus; // status = lose\r\n\r\n\t\t/*\r\n\t\t * Send 1 Wei to losing bet - external call to an untrusted contract\r\n\t\t */\r\n\t\tif (!_bet.playerAddress.send(1)) {\r\n\t\t\tbetStatus = -1; // status = lose + failed send\r\n\r\n\t\t\t// If send failed, let player withdraw via playerWithdrawPendingTransactions\r\n\t\t\tplayerPendingWithdrawals[_bet.playerAddress] = playerPendingWithdrawals[_bet.playerAddress].add(1);\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Mint and transfer token reward to this player\r\n\t\t */\r\n\t\tif (tokenRewardValue > 0) {\r\n\t\t\tif (!_spintoken.mintTransfer(_bet.playerAddress, tokenRewardValue)) {\r\n\t\t\t\tbetStatus = -2; // status = lose + failed mint and transfer\r\n\r\n\t\t\t\t// If transfer token failed, let player withdraw via playerWithdrawPendingTokenTransactions\r\n\t\t\t\tplayerPendingTokenWithdrawals[_bet.playerAddress] = playerPendingTokenWithdrawals[_bet.playerAddress].add(tokenRewardValue);\r\n\t\t\t}\r\n\t\t}\r\n\t\temit LogResult(_bet.betId, _bet.playerAddress, _bet.playerNumber, _bet.diceResult, betValue, _bet.houseEdge, 1, tokenRewardValue, betStatus);\r\n\t\t_sendLotteryContribution(betInternalId, betValue);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Contribute the house win to lottery address\r\n\t * @param betInternalId The bet internal ID\r\n\t * @param betValue The original wager\r\n\t * @return Return true if success\r\n\t */\r\n\tfunction _sendLotteryContribution(uint256 betInternalId, uint256 betValue) internal returns (bool) {\r\n\t\t/*\r\n\t\t * If contractBalance >= minBankroll, contribute the a percentage of the winning to lottery\r\n\t\t */\r\n\t\tuint256 contractBalance = _setting.uintSettings('contractBalance');\r\n\t\tif (contractBalance >= _setting.uintSettings('minBankroll')) {\r\n\t\t\tBet memory _bet =  bets[betInternalId];\r\n\t\t\tuint256 lotteryContribution = _lib.calculateLotteryContribution(settingAddress, lotteryAddress, betValue);\r\n\r\n\t\t\tif (lotteryContribution > 0 && contractBalance >= lotteryContribution) {\r\n\t\t\t\t// Safely adjust contractBalance\r\n\t\t\t\t_setting.spinwinUpdateLotteryContributionMetric(lotteryContribution);\r\n\r\n\t\t\t\temit LogLotteryContribution(_bet.betId, _bet.playerAddress, lotteryContribution);\r\n\r\n\t\t\t\t// Contribute to the lottery\r\n\t\t\t\tif (!lotteryAddress.call.gas(_setting.uintSettings('gasForLottery')).value(lotteryContribution)()) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Reward the referree if necessary.\r\n\t * @param referreeAddress The address of the referree\r\n\t * @param betInternalId The internal bet ID\r\n\t */\r\n\tfunction _rewardReferree(address referreeAddress, uint256 betInternalId) internal {\r\n\t\tBet memory _bet = bets[betInternalId];\r\n\r\n\t\t// If the player already has a referee, use that address\r\n\t\tif (referees[_bet.playerAddress] != address(0)) {\r\n\t\t\treferreeAddress = referees[_bet.playerAddress];\r\n\t\t}\r\n\t\tif (referreeAddress != address(0) && referreeAddress != _bet.playerAddress) {\r\n\t\t\treferees[_bet.playerAddress] = referreeAddress;\r\n\t\t\tuint256 _tokenForLotto = _bet.tokenRewardValue.mul(_setting.uintSettings('referralPercent')).div(PERCENTAGE_DIVISOR);\r\n\t\t\tlotteryBlocksAmount[referreeAddress] = lotteryBlocksAmount[referreeAddress].add(_tokenForLotto);\r\n\t\t\temit LogRewardLotteryBlocks(referreeAddress, _bet.betId, _tokenForLotto, 1, 1);\r\n\t\t}\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"playerWithdrawPendingTokenTransactions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betIds\",\"type\":\"bytes32[]\"}],\"name\":\"clearBets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerPendingWithdrawals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"betId\",\"type\":\"bytes32\"}],\"name\":\"playerGetBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refundPendingBets\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"betId\",\"type\":\"bytes32\"}],\"name\":\"playerGetPendingBet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"betValue\",\"type\":\"uint256\"},{\"name\":\"playerNumber\",\"type\":\"uint256\"},{\"name\":\"houseEdge\",\"type\":\"uint256\"}],\"name\":\"calculateTokenReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lotteryBlocksAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_developer\",\"type\":\"address\"}],\"name\":\"changeDeveloper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"betValue\",\"type\":\"uint256\"},{\"name\":\"playerNumber\",\"type\":\"uint256\"},{\"name\":\"houseEdge\",\"type\":\"uint256\"}],\"name\":\"calculateWinningReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lotteryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_advertisingAddress\",\"type\":\"address\"}],\"name\":\"devSetAdvertisingAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"betId\",\"type\":\"bytes32\"}],\"name\":\"devGetBetInternalId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calculateClearBetBlocksReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"playerGetPendingBetIds\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referees\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"betInternalId\",\"type\":\"uint256\"}],\"name\":\"devGetBet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenContractAddress\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"exchangeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betId\",\"type\":\"bytes32\"}],\"name\":\"devRefundBet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPendingBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"playerWithdrawPendingTransactions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimLotteryBlocks\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TWO_DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"playerNumber\",\"type\":\"uint256\"},{\"name\":\"houseEdge\",\"type\":\"uint256\"},{\"name\":\"clearBetId\",\"type\":\"bytes32\"},{\"name\":\"referreeAddress\",\"type\":\"address\"}],\"name\":\"rollDice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lotteryAddress\",\"type\":\"address\"}],\"name\":\"devSetLotteryAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"tokenExchanges\",\"outputs\":[{\"name\":\"playerAddress\",\"type\":\"address\"},{\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"name\":\"processed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"developer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERCENTAGE_DIVISOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CURRENCY_DIVISOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerPendingTokenWithdrawals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_settingAddress\",\"type\":\"address\"},{\"name\":\"_libraryAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"betId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"betValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"houseEdge\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rewardValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenRewardValue\",\"type\":\"uint256\"}],\"name\":\"LogBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"betId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"diceResult\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"betValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"houseEdge\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rewardValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenRewardValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"int256\"}],\"name\":\"LogResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"betId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiValue\",\"type\":\"uint256\"}],\"name\":\"LogLotteryContribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"betId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"lottoBlocksAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rewardType\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"LogRewardLotteryBlocks\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"}],\"name\":\"LogClearBets\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"numLottery\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"claimAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"claimStatus\",\"type\":\"uint256\"}],\"name\":\"LogClaimLotteryBlocks\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenToWeiExchangeRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weiValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"receivedWeiValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"remainderTokenValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"LogTokenExchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"LogPlayerWithdrawBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"LogPlayerWithdrawTokenBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"betId\",\"type\":\"bytes32\"}],\"name\":\"LogBetNotFound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"betId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"}],\"name\":\"LogDeveloperCancelBet\",\"type\":\"event\"}]","ContractName":"SpinWin","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b42f5366792ed7c08995451c1a93780b7554762b000000000000000000000000b654457bab03011531ef939cb31f76eb36e2ddf3000000000000000000000000ea1853f9162ba2b6594fc18d60c66bf4b6211e0d","Library":"","SwarmSource":"bzzr://860620f36b26c0e5c6e555a5ea5f9d72b7387e05827e56bedcb52866d15baa2a"}]}