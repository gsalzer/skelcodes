{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >0.5.0;\r\n// ------------------------------------------------------------------------\r\n// TokenSale (TUSD) by Tentech Group OU Limited.\r\n// \r\n// author: Tentech Group Team\r\n// contact: Tentech tentechvn@gmail.com\r\n//--------------------------------------------------------------------------\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n    \r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a>b) return a;\r\n        return b;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    // Get the total token supply\r\n    function totalSupply() public view returns (uint256 _totalSupply);\r\n \r\n    // Get the account balance of another account with address _owner\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    \r\n    function decimals() public view returns (uint8);\r\n \r\n    // Send _value amount of tokens to address _to\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    \r\n    // transfer _value amount of token approved by address _from\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    \r\n    // approve an address with _value amount of tokens\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    // get remaining token approved by _owner to _spender\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n  \r\n    // Triggered when tokens are transferred.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n \r\n    // Triggered whenever approve(address _spender, uint256 _value) is called.\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract ERC20RcvContract {     \r\n    function tokenFallback(address _from, uint _value) public;\r\n}\r\n\r\ncontract TokenSale  is ERC20RcvContract {\r\n\r\n    using SafeMath for uint;\r\n    \r\n    string public description = \"TokenSale by TUSD v1.0\";\r\n    uint baseDecimals = 10**18;\r\n    uint quoteDecimals = 10**6;\r\n    uint ratioDecimals = 10**3;\r\n    uint maxVerifyPerBatch = 50; // Specify the maximum buyers can be verified in a call to verifyBuyer()\r\n\r\n    address internal baseToken =  0x0000000000085d4780B73119b644AE5ecd22b376;        // Address of the base token (TUSD)\r\n    address internal quoteToken = 0xC9b965df61f634b35e34043545572F468aF6599D;        // Address of the quote token (GDEM - TenToken)\r\n    address public fundOwner;           // Who own the fund wallet.\r\n    address public broker;              // Who can fire contract methods\r\n\r\n    uint public refundFeePerc;\r\n\r\n    uint public exchangeRatio=0;        // How much of the quote currency is needed to purchase one unit of the base currency?\r\n    uint public quoteTotal;             // Total token amount of the TokenSale\r\n    uint public quoteBalance;           // The remaining amount of quoteTotal\r\n    uint public baseTotalSold;          // We'll store the total baseToken raised via TokenSale    \r\n    \r\n    bool public issueTokenOnBuy=false;  //Auto issue token on receiving TUSD\r\n\r\n    // Retail mode means\r\n    // - Can purchase many times\r\n    // - Token is issued upon receiving fund (TUSD)\r\n    bool public retailMode=false;\r\n    bool public isClosed=false; \r\n\r\n    uint public buyMin;   \r\n    uint public buyMax;    \r\n    uint public dateStart;\r\n    uint public dateEnd;\r\n\r\n    mapping (address => bool) public isVerified;\r\n    mapping (address => bool) public isQuoteIssued;\r\n    mapping (address => uint) public notVerifiedTransfer;\r\n    \r\n    event eBuyReceived(address indexed _from, uint _baseReceived, uint _quoteIssue);\r\n    event eIssueToken(address indexed _to, uint _baseReceived, uint _quoteIssue);\r\n    event eBuyRefund(address indexed _to, uint _refund, uint _refundFee);\r\n    \r\n    modifier onlyBroker() {\r\n        require(msg.sender == broker, \"The method can only be called by BROKER\");\r\n        _;\r\n    }\r\n\r\n    modifier validBuyDate() {\r\n        require(now >= dateStart && now<=dateEnd, \"TokenSale was not opened now\");\r\n        _;\r\n    }    \r\n      \r\n    constructor ()  public \r\n    {\r\n        // Wallet which deploy contract will become broker\r\n        broker = msg.sender;\r\n    }\r\n            \r\n    // Setup token sale paramenters\r\n    function setup (uint _exChangeRatio, uint _buyMin, uint _buyMax, uint _refundFeePerc, uint _start, uint _end,\r\n                    bool _retailMode)  public onlyBroker \r\n    {\r\n        require(exchangeRatio==0, \"Cannot resetup contract.\");\r\n        require(_exChangeRatio>0, \"exchangeRatio must be greater than 0\");\r\n        require(_refundFeePerc>=0 && _refundFeePerc<ratioDecimals, \"refundFeePerc is out of range\");\r\n        require(_buyMin>0, \"buyMin must be greater than 0\");\r\n        require(_buyMax>=_buyMin, \"buyMax must be greater or equal buyMin\");\r\n        require(_start<=_end, \"dateStart must be greater or equal dateEnd\");\r\n        \r\n        refundFeePerc = _refundFeePerc;\r\n        exchangeRatio = _exChangeRatio.mul(quoteDecimals).div(ratioDecimals);\r\n\r\n        buyMin = _buyMin;\r\n        buyMax = _buyMax;\r\n        dateStart = _start;\r\n        dateEnd = _end;\r\n        retailMode = _retailMode;      \r\n    }\r\n   \r\n    // Calculate baseToken amount in exchange for received TUSD \r\n    function calcSellToken (uint _baseReceived) internal view returns(uint)\r\n    {\r\n        return _baseReceived.mul(exchangeRatio).div(baseDecimals);\r\n    }\r\n\r\n    // Calculate baseToken amount in exchange for received TUSD \r\n    function calcRefundFee (uint _amt) internal view returns(uint)\r\n    {\r\n        return _amt.mul(refundFeePerc).div(ratioDecimals);        \r\n    }\r\n    \r\n    /// Issue baseToken\r\n    function issueToken(address _to) public onlyBroker\r\n    {\r\n        require(retailMode==false, \"Cannot run this method in Retail mode\"); \r\n\r\n        uint _baseReceived = notVerifiedTransfer[_to];\r\n        notVerifiedTransfer[_to] = 0;\r\n\r\n        uint _quoteIssue = calcSellToken(_baseReceived);\r\n        issueTokenInternal(_to,_baseReceived,_quoteIssue);\r\n    }  \r\n   \r\n    /// Refund\r\n    function refund(address _to)  public onlyBroker\r\n    {\r\n        require(retailMode==false, \"Cannot run this method in Retail mode\");  \r\n\r\n        uint _baseReceived = notVerifiedTransfer[_to];\r\n        require(_baseReceived>0, \"No amount to refund\");\r\n        notVerifiedTransfer[_to] = 0;\r\n     \r\n        uint _refundFeeAmt = calcRefundFee(_baseReceived);\r\n        uint _refundAmt = _baseReceived.sub(_refundFeeAmt);\r\n\r\n        //Transfer refund amt from the contract to buyer\r\n        ERC20(baseToken).transfer(_to, _refundAmt);\r\n\r\n        //Transfer refund fee from the contract to fundOwner\r\n        ERC20(baseToken).transfer(fundOwner, _refundFeeAmt);\r\n\r\n        emit eBuyRefund(_to, _refundAmt, _refundFeeAmt); \r\n        \r\n    }\r\n        \r\n    /// Transfer remain baseToken amount to fundOwner when the TokenSale was over/end by fundOwner\r\n    function close() public onlyBroker \r\n    {    \r\n        require(isClosed==false, \"Contract was closed already\");\r\n        isClosed = true;\r\n\r\n        uint _balanceAmt = quoteBalance;\r\n        require(_balanceAmt>0, \"Cannot close : Contract balance is 0\");\r\n        quoteBalance = 0;\r\n        ERC20(quoteToken).transfer(fundOwner,_balanceAmt);\r\n    } \r\n\r\n    // Set verified address who can receive quoteToken imediately upon transfering baseToken\r\n    function verifyBuyer( address[] memory _list)  public onlyBroker \r\n    {\r\n        require(isClosed==false, \"Contract was closed\");\r\n        require(retailMode==false, \"Cannot run this method in Retail mode\");\r\n\r\n        require(_list.length<=maxVerifyPerBatch, \"Out of list : can only verify maxVerifyPerBatch addresses\");\r\n        for (uint idx=0; idx<_list.length; idx++) {\r\n            isVerified[_list[idx]] = true;\r\n        }\r\n    }\r\n\r\n    function setDate(uint _start, uint _end) public onlyBroker\r\n    {    \r\n        require(isClosed==false, \"Contract was closed\");\r\n        dateStart = _start;\r\n        dateEnd = _end;\r\n    }\r\n\r\n    function setBroker(address _broker) public onlyBroker\r\n    {\r\n        require(isClosed==false, \"Contract was closed\");\r\n        require(_broker != broker);\r\n        broker = _broker;\r\n    } \r\n   \r\n    function setAutoIssue(bool _auto)  public onlyBroker \r\n    {\r\n        require(isClosed==false, \"Contract was closed\");\r\n        require(retailMode==false, \"Cannot run this method in Retail mode\");        \r\n        require(exchangeRatio>0, \"exchangeRatio was out of range\");\r\n        require(issueTokenOnBuy!=_auto, \"issueTokenOnBuy was set already\");\r\n        issueTokenOnBuy = _auto;\r\n    }\r\n           \r\n    // Called when baseToken was transfered to setup the contract total\r\n    function tokenFallback(address _from, uint _value)  public \r\n    {\r\n        require(isClosed==false, \"Contract was closed\");\r\n        require(_value>0, \"Invalid : value must be greater than 0\");\r\n        // Buyer transfer token to buy TokenSale\r\n        if (msg.sender==baseToken) {\r\n            purchaseToken(_from, _value);\r\n            return;\r\n        }\r\n\r\n        // Onwer send token to setup the TokenSale amount\r\n        if (msg.sender==quoteToken) {\r\n            setupTokenBalance(_from, _value);\r\n            return;\r\n        }\r\n        revert();\r\n    }\r\n    \r\n    function setupTokenBalance(address _from, uint _value) internal \r\n    {\r\n        require(exchangeRatio>0, \"exchangeRatio was not setup\");\r\n        \r\n        if (fundOwner==address(0)) {\r\n            // Wallet which transfered token will become fund owner\r\n           fundOwner = _from;\r\n        }\r\n        else{\r\n            //Ensure that only the owner can add more fund\r\n            require(fundOwner==_from, \"Only owner can add more fund\");\r\n        }\r\n\r\n        //Add fund   \r\n        uint _quoteTotal = _value;\r\n\r\n        quoteTotal = quoteTotal.add(_quoteTotal);\r\n        quoteBalance = quoteBalance.add(_quoteTotal);\r\n    }\r\n    \r\n    function purchaseToken(address  _from, uint _baseReceived) internal validBuyDate \r\n    {\r\n        require(quoteBalance>0, \"quoteBalance was out of range\");\r\n        require(exchangeRatio>0, \"exchangeRatio was out of range\");\r\n\r\n        uint _quoteIssue = validateBuyValue(_baseReceived);\r\n\r\n        if (retailMode) issueTokenAndCollectFund(_from, _baseReceived, _quoteIssue);\r\n        else{\r\n\r\n            require(isQuoteIssued[_from]==false, \"Cannot buy any more token\");\r\n            if (issueTokenOnBuy || isVerified[_from]==true)\r\n                issueTokenInternal(_from, _baseReceived, _quoteIssue);\r\n            else{\r\n                require(notVerifiedTransfer[_from]==0, \"Cannot transfer to buy more token\");\r\n                notVerifiedTransfer[_from] = _baseReceived;\r\n            }\r\n        }\r\n        emit eBuyReceived(_from, _baseReceived, _quoteIssue); \r\n    }\r\n\r\n    function issueTokenInternal(address _to,uint _baseReceived, uint  _quoteIssue) internal\r\n    {\r\n        require(_baseReceived>0, \"_baseReceived is out of range\");\r\n        require(_quoteIssue>0, \"_quoteIssue is out of range\");     \r\n        require(isQuoteIssued[_to]==false, \"Cannot issue token any more\");\r\n        isQuoteIssued[_to]=true;\r\n        issueTokenAndCollectFund(_to,_baseReceived,_quoteIssue);              \r\n    }\r\n\r\n    // Issue token to buyer and collect fund to owner\r\n    function issueTokenAndCollectFund(address _to, uint _baseReceived, uint _quoteIssue) internal\r\n    {\r\n        require(quoteBalance>=_quoteIssue, \"Insufficient quote token to issue\"); \r\n        quoteBalance = quoteBalance.sub(_quoteIssue);\r\n        baseTotalSold = baseTotalSold.add(_baseReceived);\r\n\r\n        //Transfer quoteToken from the contract to buyer\r\n        ERC20(quoteToken).transfer(_to, _quoteIssue);\r\n\r\n        //Transfer baseToken from the contract to fundOwner\r\n        ERC20(baseToken).transfer(fundOwner, _baseReceived);\r\n\r\n        emit eIssueToken(_to, _quoteIssue, _baseReceived);        \r\n    }\r\n    \r\n    // Validate buy amount and return the valid amount\r\n    function validateBuyValue(uint _value) internal view returns(uint)\r\n    {\r\n        require(isClosed==false, \"Contract was closed\");    \r\n        uint _buyAmt = calcSellToken(_value);\r\n        require(_buyAmt >= buyMin && _buyAmt<=buyMax, \"Buy amount was out of range\");\r\n        require(_buyAmt <= quoteBalance, \"Insufficient token to supply\");\r\n        return _buyAmt;\r\n    }   \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_list\",\"type\":\"address[]\"}],\"name\":\"verifyBuyer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseTotalSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_auto\",\"type\":\"bool\"}],\"name\":\"setAutoIssue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isQuoteIssued\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"quoteTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundFeePerc\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"issueToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dateEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"notVerifiedTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dateStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"retailMode\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"broker\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issueTokenOnBuy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isVerified\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_broker\",\"type\":\"address\"}],\"name\":\"setBroker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"quoteBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"setDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exChangeRatio\",\"type\":\"uint256\"},{\"name\":\"_buyMin\",\"type\":\"uint256\"},{\"name\":\"_buyMax\",\"type\":\"uint256\"},{\"name\":\"_refundFeePerc\",\"type\":\"uint256\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"},{\"name\":\"_retailMode\",\"type\":\"bool\"}],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_baseReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_quoteIssue\",\"type\":\"uint256\"}],\"name\":\"eBuyReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_baseReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_quoteIssue\",\"type\":\"uint256\"}],\"name\":\"eIssueToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_refund\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_refundFee\",\"type\":\"uint256\"}],\"name\":\"eBuyRefund\",\"type\":\"event\"}]","ContractName":"TokenSale","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8e631985c7a15e1224f9fba3b788c5787c12c5f52487e0796f4e7bc22e4bb1af"}]}