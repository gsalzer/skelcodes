{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// https://www.ethereum.org/token\r\n\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\r\n\r\n\r\n/**\r\n * @title SpinWinInterface\r\n */\r\ninterface SpinWinInterface {\r\n\tfunction refundPendingBets() external returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @title SettingInterface\r\n */\r\ninterface SettingInterface {\r\n\tfunction uintSettings(bytes32 name) external constant returns (uint256);\r\n\tfunction boolSettings(bytes32 name) external constant returns (bool);\r\n\tfunction isActive() external constant returns (bool);\r\n\tfunction canBet(uint256 rewardValue, uint256 betValue, uint256 playerNumber, uint256 houseEdge) external constant returns (bool);\r\n\tfunction isExchangeAllowed(address playerAddress, uint256 tokenAmount) external constant returns (bool);\r\n\r\n\t/******************************************/\r\n\t/*          SPINWIN ONLY METHODS          */\r\n\t/******************************************/\r\n\tfunction spinwinSetUintSetting(bytes32 name, uint256 value) external;\r\n\tfunction spinwinIncrementUintSetting(bytes32 name) external;\r\n\tfunction spinwinSetBoolSetting(bytes32 name, bool value) external;\r\n\tfunction spinwinAddFunds(uint256 amount) external;\r\n\tfunction spinwinUpdateTokenToWeiExchangeRate() external;\r\n\tfunction spinwinRollDice(uint256 betValue) external;\r\n\tfunction spinwinUpdateWinMetric(uint256 playerProfit) external;\r\n\tfunction spinwinUpdateLoseMetric(uint256 betValue, uint256 tokenRewardValue) external;\r\n\tfunction spinwinUpdateLotteryContributionMetric(uint256 lotteryContribution) external;\r\n\tfunction spinwinUpdateExchangeMetric(uint256 exchangeAmount) external;\r\n\r\n\t/******************************************/\r\n\t/*      SPINLOTTERY ONLY METHODS          */\r\n\t/******************************************/\r\n\tfunction spinlotterySetUintSetting(bytes32 name, uint256 value) external;\r\n\tfunction spinlotteryIncrementUintSetting(bytes32 name) external;\r\n\tfunction spinlotterySetBoolSetting(bytes32 name, bool value) external;\r\n\tfunction spinlotteryUpdateTokenToWeiExchangeRate() external;\r\n\tfunction spinlotterySetMinBankroll(uint256 _minBankroll) external returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @title TokenInterface\r\n */\r\ninterface TokenInterface {\r\n\tfunction getTotalSupply() external constant returns (uint256);\r\n\tfunction getBalanceOf(address account) external constant returns (uint256);\r\n\tfunction transfer(address _to, uint256 _value) external returns (bool);\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n\tfunction approve(address _spender, uint256 _value) external returns (bool success);\r\n\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) external returns (bool success);\r\n\tfunction burn(uint256 _value) external returns (bool success);\r\n\tfunction burnFrom(address _from, uint256 _value) external returns (bool success);\r\n\tfunction mintTransfer(address _to, uint _value) external returns (bool);\r\n\tfunction burnAt(address _at, uint _value) external returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 c = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n// https://github.com/ethereum/ethereum-org/blob/master/solidity/token-advanced.sol\r\n\r\n\r\n\r\ncontract TokenERC20 {\r\n\t// Public variables of the token\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals = 18;\r\n\t// 18 decimals is the strongly suggested default, avoid changing it\r\n\tuint256 public totalSupply;\r\n\r\n\t// This creates an array with all balances\r\n\tmapping (address => uint256) public balanceOf;\r\n\tmapping (address => mapping (address => uint256)) public allowance;\r\n\r\n\t// This generates a public event on the blockchain that will notify clients\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\t// This generates a public event on the blockchain that will notify clients\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n\t// This notifies clients about the amount burnt\r\n\tevent Burn(address indexed from, uint256 value);\r\n\r\n\t/**\r\n\t * Constructor function\r\n\t *\r\n\t * Initializes contract with initial supply tokens to the creator of the contract\r\n\t */\r\n\tconstructor(\r\n\t\tuint256 initialSupply,\r\n\t\tstring tokenName,\r\n\t\tstring tokenSymbol\r\n\t) public {\r\n\t\ttotalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\r\n\t\tbalanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\r\n\t\tname = tokenName;                                   // Set the name for display purposes\r\n\t\tsymbol = tokenSymbol;                               // Set the symbol for display purposes\r\n\t}\r\n\r\n\t/**\r\n\t * Internal transfer, only can be called by this contract\r\n\t */\r\n\tfunction _transfer(address _from, address _to, uint _value) internal {\r\n\t\t// Prevent transfer to 0x0 address. Use burn() instead\r\n\t\trequire(_to != 0x0);\r\n\t\t// Check if the sender has enough\r\n\t\trequire(balanceOf[_from] >= _value);\r\n\t\t// Check for overflows\r\n\t\trequire(balanceOf[_to] + _value > balanceOf[_to]);\r\n\t\t// Save this for an assertion in the future\r\n\t\tuint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n\t\t// Subtract from the sender\r\n\t\tbalanceOf[_from] -= _value;\r\n\t\t// Add the same to the recipient\r\n\t\tbalanceOf[_to] += _value;\r\n\t\temit Transfer(_from, _to, _value);\r\n\t\t// Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n\t\tassert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n\t}\r\n\r\n\t/**\r\n\t * Transfer tokens\r\n\t *\r\n\t * Send `_value` tokens to `_to` from your account\r\n\t *\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool success) {\r\n\t\t_transfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Transfer tokens from other address\r\n\t *\r\n\t * Send `_value` tokens to `_to` in behalf of `_from`\r\n\t *\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n\t\trequire(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n\t\tallowance[_from][msg.sender] -= _value;\r\n\t\t_transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Set allowance for other address\r\n\t *\r\n\t * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\n\t *\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value the max amount they can spend\r\n\t */\r\n\tfunction approve(address _spender, uint256 _value) public returns (bool success) {\r\n\t\tallowance[msg.sender][_spender] = _value;\r\n\t\temit Approval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Set allowance for other address and notify\r\n\t *\r\n\t * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\r\n\t *\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value the max amount they can spend\r\n\t * @param _extraData some extra information to send to the approved contract\r\n\t */\r\n\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n\t\tpublic\r\n\t\treturns (bool success) {\r\n\t\ttokenRecipient spender = tokenRecipient(_spender);\r\n\t\tif (approve(_spender, _value)) {\r\n\t\t\tspender.receiveApproval(msg.sender, _value, this, _extraData);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Destroy tokens\r\n\t *\r\n\t * Remove `_value` tokens from the system irreversibly\r\n\t *\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction burn(uint256 _value) public returns (bool success) {\r\n\t\trequire(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n\t\tbalanceOf[msg.sender] -= _value;            // Subtract from the sender\r\n\t\ttotalSupply -= _value;                      // Updates totalSupply\r\n\t\temit Burn(msg.sender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Destroy tokens from other account\r\n\t *\r\n\t * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n\t *\r\n\t * @param _from the address of the sender\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n\t\trequire(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n\t\trequire(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n\t\tbalanceOf[_from] -= _value;                         // Subtract from the targeted balance\r\n\t\tallowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n\t\ttotalSupply -= _value;                              // Update totalSupply\r\n\t\temit Burn(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\ncontract developed {\r\n\taddress public developer;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() public {\r\n\t\tdeveloper = msg.sender;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks only developer address is calling\r\n\t */\r\n\tmodifier onlyDeveloper {\r\n\t\trequire(msg.sender == developer);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to switch developer address\r\n\t * @param _developer The new developer address to be set\r\n\t */\r\n\tfunction changeDeveloper(address _developer) public onlyDeveloper {\r\n\t\tdeveloper = _developer;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to withdraw ERC20 Token\r\n\t */\r\n\tfunction withdrawToken(address tokenContractAddress) public onlyDeveloper {\r\n\t\tTokenERC20 _token = TokenERC20(tokenContractAddress);\r\n\t\tif (_token.balanceOf(this) > 0) {\r\n\t\t\t_token.transfer(developer, _token.balanceOf(this));\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\ncontract escaped {\r\n\taddress public escapeActivator;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() public {\r\n\t\tescapeActivator = 0xB15C54b4B9819925Cd2A7eE3079544402Ac33cEe;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks only escapeActivator address is calling\r\n\t */\r\n\tmodifier onlyEscapeActivator {\r\n\t\trequire(msg.sender == escapeActivator);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows escapeActivator to switch escapeActivator address\r\n\t * @param _escapeActivator The new escapeActivator address to be set\r\n\t */\r\n\tfunction changeAddress(address _escapeActivator) public onlyEscapeActivator {\r\n\t\tescapeActivator = _escapeActivator;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title GameSetting\r\n */\r\ncontract GameSetting is developed, escaped, SettingInterface {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public spinwinAddress;\r\n\taddress public spinlotteryAddress;\r\n\r\n\tmapping(bytes32 => uint256) internal _uintSettings;    // Array containing all uint256 settings\r\n\tmapping(bytes32 => bool) internal _boolSettings;       // Array containing all bool settings\r\n\r\n\tuint256 constant public PERCENTAGE_DIVISOR = 10 ** 6;   // 1000000 = 100%\r\n\tuint256 constant public HOUSE_EDGE_DIVISOR = 1000;\r\n\tuint256 constant public CURRENCY_DIVISOR = 10**18;\r\n\tuint256 constant public TWO_DECIMALS = 100;\r\n\tuint256 constant public MAX_NUMBER = 99;\r\n\tuint256 constant public MIN_NUMBER = 2;\r\n\tuint256 constant public MAX_HOUSE_EDGE = 1000;          // 0% House Edge\r\n\tuint256 constant public MIN_HOUSE_EDGE = 0;             // 100% House edge\r\n\r\n\tTokenInterface internal _spintoken;\r\n\tSpinWinInterface internal _spinwin;\r\n\r\n\t/**\r\n\t * @dev Log dev sets uint setting\r\n\t */\r\n\tevent LogSetUintSetting(address indexed who, bytes32 indexed name, uint256 value);\r\n\r\n\t/**\r\n\t * @dev Log dev sets bool setting\r\n\t */\r\n\tevent LogSetBoolSetting(address indexed who, bytes32 indexed name, bool value);\r\n\r\n\t/**\r\n\t * @dev Log when dev adds some funds\r\n\t */\r\n\tevent LogAddBankRoll(uint256 amount);\r\n\r\n\t/**\r\n\t * @dev Log when the token to Wei exchange rate is updated\r\n\t */\r\n\tevent LogUpdateTokenToWeiExchangeRate(uint256 exchangeRate, uint256 exchangeRateBlockNumber);\r\n\r\n\t/**\r\n\t * @dev Log when developer set spinwin contract to emergency mode\r\n\t */\r\n\tevent LogSpinwinEscapeHatch();\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor(address _spintokenAddress) public {\r\n\t\t_spintoken = TokenInterface(_spintokenAddress);\r\n\t\tdevSetUintSetting('minBet', CURRENCY_DIVISOR.div(100));\t\t\t// init min bet (0.01 ether)\r\n\t\tdevSetUintSetting('maxProfitAsPercentOfHouse', 200000);         // init 200000 = 20% commission\r\n\t\tdevSetUintSetting('minBankroll', CURRENCY_DIVISOR.mul(20));     // init min bank roll (20 eth)\r\n\t\tdevSetTokenExchangeMinBankrollPercent(900000);                  // init token exchange min bank roll percentage (90%)\r\n\t\tdevSetUintSetting('referralPercent', 10000);                    // init referral percentage (1%)\r\n\t\tdevSetUintSetting('gasForLottery', 250000);                     // init gas for lottery\r\n\t\tdevSetUintSetting('maxBlockSecurityCount', 256);                // init max block security count (256)\r\n\t\tdevSetUintSetting('blockSecurityCount', 3);                     // init block security count (3)\r\n\t\tdevSetUintSetting('tokenExchangeBlockSecurityCount', 3);        // init token exchange block security count (3)\r\n\t\tdevSetUintSetting('maxProfitBlockSecurityCount', 3);            // init max profit block security count (3)\r\n\t\tdevSetUintSetting('spinEdgeModifier', 80);                      // init spin edge modifier (0.8)\r\n\t\tdevSetUintSetting('spinBankModifier', 50);                      // init spin bank modifier (0.5)\r\n\t\tdevSetUintSetting('spinNumberModifier', 5);                     // init spin number modifier (0.05)\r\n\t\tdevSetUintSetting('maxMinBankroll', CURRENCY_DIVISOR.mul(5000));   // init max value for min bankroll (5,000 eth)\r\n\t\tdevSetUintSetting('lastProcessedBetInternalId', 1);             // init lastProcessedBetInternalId = 1\r\n\t\tdevSetUintSetting('exchangeAmountDivisor', 2);                  // init exchangeAmountDivisor = 2\r\n\t\tdevSetUintSetting('tokenExchangeRatio', 10);                    // init tokenExchangeRatio = 0.1 (divided by TWO_DECIMALS)\r\n\t\tdevSetUintSetting('spinToWeiRate', CURRENCY_DIVISOR);           // init spinToWeiRate = 1\r\n\t\tdevSetUintSetting('blockToSpinRate', CURRENCY_DIVISOR);         // init blockToSpinRate = 1\r\n\t\tdevSetUintSetting('blockToWeiRate', CURRENCY_DIVISOR);          // init blockToWeiRate = 1\r\n\t\tdevSetUintSetting('gasForClearingBet', 320000);                 // init gasForClearingBet = 320000 gas\r\n\t\tdevSetUintSetting('gasPrice', 40000000000);                     // init gasPrice = 40 gwei\r\n\t\tdevSetUintSetting('clearSingleBetMultiplier', 200);             // init clearSingleBetMultiplier = 2x (divided by TWO_DECIMALS)\r\n\t\tdevSetUintSetting('clearMultipleBetsMultiplier', 100);          // init clearMultipleBetMultiplier = 1x (divided by TWO_DECIMALS)\r\n\t\tdevSetUintSetting('maxNumClearBets', 4);                        // init maxNumClearBets = 4\r\n\t\tdevSetUintSetting('lotteryTargetMultiplier', 200);              // init lotteryTargetMultiplier = 2x (divided by TWO_DECIMALS)\r\n\t\t_setMaxProfit(true);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks only spinwinAddress is calling\r\n\t */\r\n\tmodifier onlySpinwin {\r\n\t\trequire(msg.sender == spinwinAddress);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks only spinlotteryAddress is calling\r\n\t */\r\n\tmodifier onlySpinlottery {\r\n\t\trequire(msg.sender == spinlotteryAddress);\r\n\t\t_;\r\n\t}\r\n\r\n\t/******************************************/\r\n\t/*       DEVELOPER ONLY METHODS           */\r\n\t/******************************************/\r\n\r\n\t/**\r\n\t * @dev Allows developer to set spinwin contract address\r\n\t * @param _address The contract address to be set\r\n\t */\r\n\tfunction devSetSpinwinAddress(address _address) public onlyDeveloper {\r\n\t\trequire (_address != address(0));\r\n\t\tspinwinAddress = _address;\r\n\t\t_spinwin = SpinWinInterface(spinwinAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to set spinlottery contract address\r\n\t * @param _address The contract address to be set\r\n\t */\r\n\tfunction devSetSpinlotteryAddress(address _address) public onlyDeveloper {\r\n\t\trequire (_address != address(0));\r\n\t\tspinlotteryAddress = _address;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows dev to set uint setting\r\n\t * @param name The setting name to be set\r\n\t * @param value The value to be set\r\n\t */\r\n\tfunction devSetUintSetting(bytes32 name, uint256 value) public onlyDeveloper {\r\n\t\t_uintSettings[name] = value;\r\n\t\temit LogSetUintSetting(developer, name, value);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows dev to set bool setting\r\n\t * @param name The setting name to be set\r\n\t * @param value The value to be set\r\n\t */\r\n\tfunction devSetBoolSetting(bytes32 name, bool value) public onlyDeveloper {\r\n\t\t_boolSettings[name] = value;\r\n\t\temit LogSetBoolSetting(developer, name, value);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to set min bank roll\r\n\t * @param minBankroll The new min bankroll value to be set\r\n\t */\r\n\tfunction devSetMinBankroll(uint256 minBankroll) public onlyDeveloper {\r\n\t\t_uintSettings['minBankroll'] = minBankroll;\r\n\t\t_uintSettings['tokenExchangeMinBankroll'] = _uintSettings['minBankroll'].mul(_uintSettings['tokenExchangeMinBankrollPercent']).div(PERCENTAGE_DIVISOR);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to set token exchange min bank roll percent\r\n\t * @param tokenExchangeMinBankrollPercent The new value to be set\r\n\t */\r\n\tfunction devSetTokenExchangeMinBankrollPercent(uint256 tokenExchangeMinBankrollPercent) public onlyDeveloper {\r\n\t\t_uintSettings['tokenExchangeMinBankrollPercent'] = tokenExchangeMinBankrollPercent;\r\n\t\t_uintSettings['tokenExchangeMinBankroll'] = _uintSettings['minBankroll'].mul(_uintSettings['tokenExchangeMinBankrollPercent']).div(PERCENTAGE_DIVISOR);\r\n\t}\r\n\r\n\t/******************************************/\r\n\t/*      ESCAPE ACTIVATOR ONLY METHODS     */\r\n\t/******************************************/\r\n\r\n\t/**\r\n\t * @dev Allows escapeActivator to trigger spinwin emergency mode. Will disable all bets and only allow token exchange at a fixed rate\r\n\t */\r\n\tfunction spinwinEscapeHatch() public onlyEscapeActivator {\r\n\t\t_spinwin.refundPendingBets();\r\n\t\t_boolSettings['contractKilled'] = true;\r\n\t\t_uintSettings['contractBalanceHonor'] = _uintSettings['contractBalance'];\r\n\t\t_uintSettings['tokenExchangeMinBankroll'] = 0;\r\n\t\t_uintSettings['tokenExchangeMinBankrollHonor'] = 0;\r\n\t\t/**\r\n\t\t * tokenToWeiExchangeRate is ETH in 36 decimals or WEI in 18 decimals to account for\r\n\t\t * the state when token's totalSupply is 10^18 more than contractBalance.\r\n\t\t * Otherwise the tokenToWeiExchangeRate will always be 0.\r\n\t\t * This means, in the exchange token function, we need to divide\r\n\t\t * tokenToWeiExchangeRate with CURRENCY_DIVISOR\r\n\t\t */\r\n\t\t_uintSettings['tokenToWeiExchangeRate'] = _spintoken.getTotalSupply() > 0 ? _uintSettings['contractBalance'].mul(CURRENCY_DIVISOR).mul(CURRENCY_DIVISOR).div(_spintoken.getTotalSupply()) : 0;\r\n\t\t_uintSettings['tokenToWeiExchangeRateHonor'] = _uintSettings['tokenToWeiExchangeRate'];\r\n\t\t_uintSettings['tokenToWeiExchangeRateBlockNum'] = block.number;\r\n\t\temit LogUpdateTokenToWeiExchangeRate(_uintSettings['tokenToWeiExchangeRateHonor'], _uintSettings['tokenToWeiExchangeRateBlockNum']);\r\n\t\temit LogSpinwinEscapeHatch();\r\n\t}\r\n\r\n\t/******************************************/\r\n\t/*         SPINWIN ONLY METHODS           */\r\n\t/******************************************/\r\n\t/**\r\n\t * @dev Allows spinwin to set uint setting\r\n\t * @param name The setting name to be set\r\n\t * @param value The value to be set\r\n\t */\r\n\tfunction spinwinSetUintSetting(bytes32 name, uint256 value) public onlySpinwin {\r\n\t\t_uintSettings[name] = value;\r\n\t\temit LogSetUintSetting(spinwinAddress, name, value);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows spinwin to increment existing uint setting value\r\n\t * @param name The setting name to be set\r\n\t */\r\n\tfunction spinwinIncrementUintSetting(bytes32 name) public onlySpinwin {\r\n\t\t_uintSettings[name] = _uintSettings[name].add(1);\r\n\t\temit LogSetUintSetting(spinwinAddress, name, _uintSettings[name]);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows spinwin to set bool setting\r\n\t * @param name The setting name to be set\r\n\t * @param value The value to be set\r\n\t */\r\n\tfunction spinwinSetBoolSetting(bytes32 name, bool value) public onlySpinwin {\r\n\t\t_boolSettings[name] = value;\r\n\t\temit LogSetBoolSetting(spinwinAddress, name, value);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Add funds to the spinwin contract\r\n\t * @param amount The amount of eth sent\r\n\t */\r\n\tfunction spinwinAddFunds(uint256 amount) public onlySpinwin {\r\n\t\t// Safely update contract balance\r\n\t\t_uintSettings['contractBalance'] = _uintSettings['contractBalance'].add(amount);\r\n\r\n\t\t// Update max profit\r\n\t\t_setMaxProfit(false);\r\n\r\n\t\temit LogAddBankRoll(amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allow spinwin to update token to Wei exchange rate.\r\n\t */\r\n\tfunction spinwinUpdateTokenToWeiExchangeRate() public onlySpinwin {\r\n\t\t_updateTokenToWeiExchangeRate();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allow spinwin to update settings when roll dice\r\n\t * Increment totalBets\r\n\t * Add betValue to totalWeiWagered\r\n\t *\r\n\t * @param betValue The bet value\r\n\t * @return The internal bet ID\r\n\t */\r\n\tfunction spinwinRollDice(uint256 betValue) public onlySpinwin {\r\n\t\t_uintSettings['totalBets']++;\r\n\t\t_uintSettings['totalWeiWagered'] = _uintSettings['totalWeiWagered'].add(betValue);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows spinwin to update uint setting when player wins\r\n\t * @param playerProfit The player profit to be subtracted from contractBalance and added to totalWeiWon\r\n\t */\r\n\tfunction spinwinUpdateWinMetric(uint256 playerProfit) public onlySpinwin {\r\n\t\t_uintSettings['contractBalance'] = _uintSettings['contractBalance'].sub(playerProfit);\r\n\t\t_uintSettings['totalWeiWon'] = _uintSettings['totalWeiWon'].add(playerProfit);\r\n\t\t_setMaxProfit(false);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows spinwin to update uint setting when player loses\r\n\t * @param betValue The original wager\r\n\t * @param tokenRewardValue The amount of token to be rewarded\r\n\t */\r\n\tfunction spinwinUpdateLoseMetric(uint256 betValue, uint256 tokenRewardValue) public onlySpinwin {\r\n\t\t_uintSettings['contractBalance'] = _uintSettings['contractBalance'].add(betValue).sub(1);\r\n\t\t_uintSettings['totalWeiWon'] = _uintSettings['totalWeiWon'].add(1);\r\n\t\t_uintSettings['totalWeiLost'] = _uintSettings['totalWeiLost'].add(betValue).sub(1);\r\n\t\t_uintSettings['totalTokenPayouts'] = _uintSettings['totalTokenPayouts'].add(tokenRewardValue);\r\n\t\t_setMaxProfit(false);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows spinwin to update uint setting when there is a lottery contribution\r\n\t * @param lotteryContribution The amount to be contributed to lottery\r\n\t */\r\n\tfunction spinwinUpdateLotteryContributionMetric(uint256 lotteryContribution) public onlySpinwin {\r\n\t\t_uintSettings['contractBalance'] = _uintSettings['contractBalance'].sub(lotteryContribution);\r\n\t\t_setMaxProfit(true);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows spinwin to update uint setting when there is a token exchange transaction\r\n\t * @param exchangeAmount The converted exchange amount\r\n\t */\r\n\tfunction spinwinUpdateExchangeMetric(uint256 exchangeAmount) public onlySpinwin {\r\n\t\t_uintSettings['contractBalance'] = _uintSettings['contractBalance'].sub(exchangeAmount);\r\n\t\t_setMaxProfit(false);\r\n\t}\r\n\r\n\r\n\t/******************************************/\r\n\t/*      SPINLOTTERY ONLY METHODS          */\r\n\t/******************************************/\r\n\t/**\r\n\t * @dev Allows spinlottery to set uint setting\r\n\t * @param name The setting name to be set\r\n\t * @param value The value to be set\r\n\t */\r\n\tfunction spinlotterySetUintSetting(bytes32 name, uint256 value) public onlySpinlottery {\r\n\t\t_uintSettings[name] = value;\r\n\t\temit LogSetUintSetting(spinlotteryAddress, name, value);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows spinlottery to increment existing uint setting value\r\n\t * @param name The setting name to be set\r\n\t */\r\n\tfunction spinlotteryIncrementUintSetting(bytes32 name) public onlySpinlottery {\r\n\t\t_uintSettings[name] = _uintSettings[name].add(1);\r\n\t\temit LogSetUintSetting(spinwinAddress, name, _uintSettings[name]);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows spinlottery to set bool setting\r\n\t * @param name The setting name to be set\r\n\t * @param value The value to be set\r\n\t */\r\n\tfunction spinlotterySetBoolSetting(bytes32 name, bool value) public onlySpinlottery {\r\n\t\t_boolSettings[name] = value;\r\n\t\temit LogSetBoolSetting(spinlotteryAddress, name, value);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allow spinlottery to update token to Wei exchange rate.\r\n\t */\r\n\tfunction spinlotteryUpdateTokenToWeiExchangeRate() public onlySpinlottery {\r\n\t\t_updateTokenToWeiExchangeRate();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows lottery to set spinwin minBankroll value\r\n\t * @param _minBankroll The new value to be set\r\n\t * @return Return true if success\r\n\t */\r\n\tfunction spinlotterySetMinBankroll(uint256 _minBankroll) public onlySpinlottery returns (bool) {\r\n\t\tif (_minBankroll > _uintSettings['maxMinBankroll']) {\r\n\t\t\t_minBankroll = _uintSettings['maxMinBankroll'];\r\n\t\t} else if (_minBankroll < _uintSettings['contractBalance']) {\r\n\t\t\t_minBankroll = _uintSettings['contractBalance'];\r\n\t\t}\r\n\t\t_uintSettings['minBankroll'] = _minBankroll;\r\n\t\t_uintSettings['tokenExchangeMinBankroll'] = _uintSettings['minBankroll'].mul(_uintSettings['tokenExchangeMinBankrollPercent']).div(PERCENTAGE_DIVISOR);\r\n\r\n\t\t// Update max profit\r\n\t\t_setMaxProfit(false);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/******************************************/\r\n\t/*         PUBLIC ONLY METHODS            */\r\n\t/******************************************/\r\n\t/**\r\n\t * @dev Gets uint setting value\r\n\t * @param name The name of the uint setting\r\n\t * @return The value of the setting\r\n\t */\r\n\tfunction uintSettings(bytes32 name) public constant returns (uint256) {\r\n\t\treturn _uintSettings[name];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Gets bool setting value\r\n\t * @param name The name of the bool setting\r\n\t * @return The value of the setting\r\n\t */\r\n\tfunction boolSettings(bytes32 name) public constant returns (bool) {\r\n\t\treturn _boolSettings[name];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if contract is active\r\n\t * @return Return true if yes, false otherwise.\r\n\t */\r\n\tfunction isActive() public constant returns (bool) {\r\n\t\tif (_boolSettings['contractKilled'] == false && _boolSettings['gamePaused'] == false) {\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check whether current bet is valid\r\n\t * @param rewardValue The winning amount\r\n\t * @param betValue The original wager\r\n\t * @param playerNumber The player chosen number\r\n\t * @param houseEdge The house edge\r\n\t * @return Return true if yes, false otherwise.\r\n\t */\r\n\tfunction canBet(uint256 rewardValue, uint256 betValue, uint256 playerNumber, uint256 houseEdge) public constant returns (bool) {\r\n\t\tif (_boolSettings['contractKilled'] == false && _boolSettings['gamePaused'] == false && rewardValue <= _uintSettings['maxProfitHonor'] && betValue >= _uintSettings['minBet'] && houseEdge >= MIN_HOUSE_EDGE && houseEdge <= MAX_HOUSE_EDGE && playerNumber >= MIN_NUMBER && playerNumber <= MAX_NUMBER) {\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check whether token exchange is allowed\r\n\t * @param playerAddress The player address to be checked\r\n\t * @param tokenAmount The amount of token to be exchanged\r\n\t * @return Return true if yes, false otherwise.\r\n\t */\r\n\tfunction isExchangeAllowed(address playerAddress, uint256 tokenAmount) public constant returns (bool) {\r\n\t\tif (_boolSettings['gamePaused'] == false && _boolSettings['tokenExchangePaused'] == false && _uintSettings['contractBalanceHonor'] >= _uintSettings['tokenExchangeMinBankrollHonor'] && _uintSettings['tokenToWeiExchangeRateHonor'] > 0 && _spintoken.getBalanceOf(playerAddress) >= tokenAmount) {\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/******************************************/\r\n\t/*        INTERNAL ONLY METHODS           */\r\n\t/******************************************/\r\n\r\n\t/**\r\n\t * @dev Calculates and sets the latest max profit a bet can possibly earn. Also update the honor variables that we are going to promise players.\r\n\t * @param force If true, bypass the block security check and update honor settings\r\n\t */\r\n\tfunction _setMaxProfit(bool force) internal {\r\n\t\t_uintSettings['maxProfit'] = _uintSettings['contractBalance'].mul(_uintSettings['maxProfitAsPercentOfHouse']).div(PERCENTAGE_DIVISOR);\r\n\t\tif (force || block.number > _uintSettings['maxProfitBlockNum'].add(_uintSettings['maxProfitBlockSecurityCount'])) {\r\n\t\t\tif (_uintSettings['contractBalance'] < 10 ether) {\r\n\t\t\t\t_uintSettings['maxProfitAsPercentOfHouse'] = 200000; // 20%\r\n\t\t\t} else if (_uintSettings['contractBalance'] >= 10 ether && _uintSettings['contractBalance'] < 100 ether) {\r\n\t\t\t\t_uintSettings['maxProfitAsPercentOfHouse'] = 100000; // 10%\r\n\t\t\t} else if (_uintSettings['contractBalance'] >= 100 ether && _uintSettings['contractBalance'] < 1000 ether) {\r\n\t\t\t\t_uintSettings['maxProfitAsPercentOfHouse'] = 50000; // 5%\r\n\t\t\t} else {\r\n\t\t\t\t_uintSettings['maxProfitAsPercentOfHouse'] = 10000; // 1%\r\n\t\t\t}\r\n\t\t\t_uintSettings['maxProfitHonor'] = _uintSettings['maxProfit'];\r\n\t\t\t_uintSettings['contractBalanceHonor'] = _uintSettings['contractBalance'];\r\n\t\t\t_uintSettings['minBankrollHonor'] = _uintSettings['minBankroll'];\r\n\t\t\t_uintSettings['tokenExchangeMinBankrollHonor'] = _uintSettings['tokenExchangeMinBankroll'];\r\n\t\t\t_uintSettings['totalWeiLostHonor'] = _uintSettings['totalWeiLost'];\r\n\t\t\t_uintSettings['maxProfitBlockNum'] = block.number;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Updates token to Wei exchange rate.\r\n\t * The exchange rate will be updated everytime there is a transaction happens in spinwin.\r\n\t * If contract is killed, we don't need to do anything\r\n\t */\r\n\tfunction _updateTokenToWeiExchangeRate() internal {\r\n\t\tif (!_boolSettings['contractKilled']) {\r\n\t\t\tif (_uintSettings['contractBalance'] >= _uintSettings['tokenExchangeMinBankroll'] && _spintoken.getTotalSupply() > 0) {\r\n\t\t\t\t/**\r\n\t\t\t\t * tokenToWeiExchangeRate is ETH in 36 decimals or WEI in 18 decimals to account for\r\n\t\t\t\t * the state when token's totalSupply is 10^18 more than contractBalance.\r\n\t\t\t\t * Otherwise the tokenToWeiExchangeRate will always be 0.\r\n\t\t\t\t * This means, in the exchange token function, we need to divide\r\n\t\t\t\t * tokenToWeiExchangeRate with CURRENCY_DIVISOR\r\n\t\t\t\t */\r\n\t\t\t\t_uintSettings['tokenToWeiExchangeRate'] = ((_uintSettings['contractBalance'].sub(_uintSettings['tokenExchangeMinBankroll'])).mul(CURRENCY_DIVISOR).mul(CURRENCY_DIVISOR).div(_uintSettings['exchangeAmountDivisor'])).div(_spintoken.getTotalSupply().mul(_uintSettings['tokenExchangeRatio']).div(TWO_DECIMALS));\r\n\t\t\t} else {\r\n\t\t\t\t_uintSettings['tokenToWeiExchangeRate'] = 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (block.number > _uintSettings['tokenToWeiExchangeRateBlockNum'].add(_uintSettings['tokenExchangeBlockSecurityCount'])) {\r\n\t\t\t\t_uintSettings['tokenToWeiExchangeRateHonor'] = _uintSettings['tokenToWeiExchangeRate'];\r\n\t\t\t\t_uintSettings['tokenToWeiExchangeRateBlockNum'] = block.number;\r\n\t\t\t\temit LogUpdateTokenToWeiExchangeRate(_uintSettings['tokenToWeiExchangeRateHonor'], _uintSettings['tokenToWeiExchangeRateBlockNum']);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"spinlotterySetBoolSetting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"spinlotteryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"devSetSpinlotteryAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"spinwinAddFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"boolSettings\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"playerProfit\",\"type\":\"uint256\"}],\"name\":\"spinwinUpdateWinMetric\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_developer\",\"type\":\"address\"}],\"name\":\"changeDeveloper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"spinwinUpdateTokenToWeiExchangeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"spinlotteryUpdateTokenToWeiExchangeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betValue\",\"type\":\"uint256\"},{\"name\":\"tokenRewardValue\",\"type\":\"uint256\"}],\"name\":\"spinwinUpdateLoseMetric\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rewardValue\",\"type\":\"uint256\"},{\"name\":\"betValue\",\"type\":\"uint256\"},{\"name\":\"playerNumber\",\"type\":\"uint256\"},{\"name\":\"houseEdge\",\"type\":\"uint256\"}],\"name\":\"canBet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minBankroll\",\"type\":\"uint256\"}],\"name\":\"spinlotterySetMinBankroll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"spinlotterySetUintSetting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_HOUSE_EDGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betValue\",\"type\":\"uint256\"}],\"name\":\"spinwinRollDice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"spinwinEscapeHatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"uintSettings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenContractAddress\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exchangeAmount\",\"type\":\"uint256\"}],\"name\":\"spinwinUpdateExchangeMetric\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"spinlotteryIncrementUintSetting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"spinwinIncrementUintSetting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"devSetSpinwinAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"devSetUintSetting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TWO_DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"spinwinSetBoolSetting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"spinwinAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_HOUSE_EDGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escapeActivator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"spinwinSetUintSetting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"developer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERCENTAGE_DIVISOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minBankroll\",\"type\":\"uint256\"}],\"name\":\"devSetMinBankroll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CURRENCY_DIVISOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_NUMBER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"playerAddress\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"isExchangeAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"lotteryContribution\",\"type\":\"uint256\"}],\"name\":\"spinwinUpdateLotteryContributionMetric\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HOUSE_EDGE_DIVISOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenExchangeMinBankrollPercent\",\"type\":\"uint256\"}],\"name\":\"devSetTokenExchangeMinBankrollPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"devSetBoolSetting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_escapeActivator\",\"type\":\"address\"}],\"name\":\"changeAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_NUMBER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_spintokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogSetUintSetting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"LogSetBoolSetting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogAddBankRoll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"exchangeRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"exchangeRateBlockNumber\",\"type\":\"uint256\"}],\"name\":\"LogUpdateTokenToWeiExchangeRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogSpinwinEscapeHatch\",\"type\":\"event\"}]","ContractName":"GameSetting","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b42f5366792ed7c08995451c1a93780b7554762b","Library":"","SwarmSource":"bzzr://dabc5c9c8fc5668ba09565b7f8f16ac0962c991907ba5e250dab652d027cddc2"}]}