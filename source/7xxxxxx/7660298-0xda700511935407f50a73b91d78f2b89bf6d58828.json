{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// ----------------------------------------------------------------------------\r\n//\r\n// ZAB token public sale contract\r\n//\r\n// For details, please visit: http://ZAB.io\r\n//\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n//\r\n// SafeMath\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n//\r\n// Owned\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\ncontract Owned {\r\n\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    mapping(address => bool) public isAdmin;\r\n\r\n    event OwnershipTransferProposed(address indexed _from, address indexed _to);\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n    event AdminChange(address indexed _admin, bool _status);\r\n\r\n    modifier onlyOwner {require(msg.sender == owner); _;}\r\n    modifier onlyAdmin {require(isAdmin[msg.sender]); _;}\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        isAdmin[owner] = true;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0x0));\r\n        emit OwnershipTransferProposed(owner, _newOwner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function addAdmin(address _a) public onlyOwner {\r\n        require(isAdmin[_a] == false);\r\n        isAdmin[_a] = true;\r\n        emit AdminChange(_a, true);\r\n    }\r\n\r\n    function removeAdmin(address _a) public onlyOwner {\r\n        require(isAdmin[_a] == true);\r\n        isAdmin[_a] = false;\r\n        emit AdminChange(_a, false);\r\n    }\r\n\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n//\r\n// Wallet\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\ncontract Wallet is Owned {\r\n\r\n    address public wallet;\r\n\r\n    event WalletUpdated(address newWallet);\r\n\r\n    constructor() public {\r\n        wallet = owner;\r\n    }\r\n\r\n    function setWallet(address _wallet) public onlyOwner {\r\n        require(_wallet != address(0x0));\r\n        wallet = _wallet;\r\n        emit WalletUpdated(_wallet);\r\n    }\r\n\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n//\r\n// ERC20Interface\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\ncontract ERC20Interface {\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address _owner) public view returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n//\r\n// ERC Token Standard #20\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\ncontract ERC20Token is ERC20Interface, Owned {\r\n\r\n    using SafeMath for uint;\r\n\r\n    uint public tokensIssuedTotal;\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping (address => uint)) allowed;\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return tokensIssuedTotal;\r\n    }\r\n    // Includes BOTH locked AND unlocked tokens\r\n\r\n    function balanceOf(address _owner) public view returns (uint) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function transfer(address _to, uint _amount) public returns (bool) {\r\n        require(_to != 0x0);\r\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint _amount) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _amount) public returns (bool) {\r\n        require(_to != 0x0);\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Transfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n//\r\n// LockSlots\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\ncontract LockSlots is ERC20Token {\r\n\r\n    using SafeMath for uint;\r\n\r\n    uint public constant LOCK_SLOTS = 5;\r\n    mapping(address => uint[LOCK_SLOTS]) public lockTerm;\r\n    mapping(address => uint[LOCK_SLOTS]) public lockAmnt;\r\n    mapping(address => bool) public mayHaveLockedTokens;\r\n\r\n    event RegisteredLockedTokens(address indexed account, uint indexed idx, uint tokens, uint term);\r\n\r\n    function registerLockedTokens(address _account, uint _tokens, uint _term) internal returns (uint idx) {\r\n        require(_term > now, \"lock term must be in the future\");\r\n\r\n        // find a slot (clean up while doing this)\r\n        // use either the existing slot with the exact same term,\r\n        // of which there can be at most one, or the first empty slot\r\n        idx = 9999;\r\n        uint[LOCK_SLOTS] storage term = lockTerm[_account];\r\n        uint[LOCK_SLOTS] storage amnt = lockAmnt[_account];\r\n        for (uint i; i < LOCK_SLOTS; i++) {\r\n            if (term[i] < now) {\r\n                term[i] = 0;\r\n                amnt[i] = 0;\r\n                if (idx == 9999) idx = i;\r\n            }\r\n            if (term[i] == _term) idx = i;\r\n        }\r\n\r\n        // fail if no slot was found\r\n        require(idx != 9999, \"registerLockedTokens: no available slot found\");\r\n\r\n        // register locked tokens\r\n        if (term[idx] == 0) term[idx] = _term;\r\n        amnt[idx] = amnt[idx].add(_tokens);\r\n        mayHaveLockedTokens[_account] = true;\r\n        emit RegisteredLockedTokens(_account, idx, _tokens, _term);\r\n    }\r\n\r\n    // public view functions\r\n\r\n    function lockedTokens(address _account) public view returns (uint) {\r\n        if (!mayHaveLockedTokens[_account]) return 0;\r\n        return pNumberOfLockedTokens(_account);\r\n    }\r\n\r\n    function unlockedTokens(address _account) public view returns (uint) {\r\n        return balances[_account].sub(lockedTokens(_account));\r\n    }\r\n\r\n    function isAvailableLockSlot(address _account, uint _term) public view returns (bool) {\r\n        if (!mayHaveLockedTokens[_account]) return true;\r\n        if (_term < now) return true;\r\n        uint[LOCK_SLOTS] storage term = lockTerm[_account];\r\n        for (uint i; i < LOCK_SLOTS; i++) {\r\n            if (term[i] < now || term[i] == _term) return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // internal and private functions\r\n\r\n    function unlockedTokensInternal(address _account) internal returns (uint) {\r\n        // updates mayHaveLockedTokens if necessary\r\n        if (!mayHaveLockedTokens[_account]) return balances[_account];\r\n        uint locked = pNumberOfLockedTokens(_account);\r\n        if (locked == 0) mayHaveLockedTokens[_account] = false;\r\n        return balances[_account].sub(locked);\r\n    }\r\n\r\n    function pNumberOfLockedTokens(address _account) private view returns (uint locked) {\r\n        uint[LOCK_SLOTS] storage term = lockTerm[_account];\r\n        uint[LOCK_SLOTS] storage amnt = lockAmnt[_account];\r\n        for (uint i; i < LOCK_SLOTS; i++) {\r\n            if (term[i] >= now) locked = locked.add(amnt[i]);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n//\r\n// ZabIcoDates\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\ncontract ZabIcoDates is Owned {\r\n\r\n    uint public dateMainStart = 1556524800; // 04/29/2019 @ 8:00am (UTC)\r\n    uint public dateMainEnd   = 1556611200; // 04/30/2019 @ 8:00am (UTC)\r\n    uint public constant DATE_LIMIT = 1556524800 + 180 days; ///AFTER DME\r\n\r\n    event IcoDateUpdated(uint id, uint unixts);\r\n\r\n    // check dates\r\n\r\n    modifier checkDateOrder {\r\n      _ ;\r\n      require ( dateMainStart < dateMainEnd ) ;\r\n      require ( dateMainEnd < DATE_LIMIT ) ;\r\n    }\r\n\r\n    constructor() public checkDateOrder() {\r\n        require(now < dateMainStart);\r\n    }\r\n\r\n    // set ico dates\r\n\r\n    function setDateMainStart(uint _unixts) public onlyOwner checkDateOrder {\r\n        require(now < _unixts && now < dateMainStart);\r\n        dateMainStart = _unixts;\r\n        emit IcoDateUpdated(1, _unixts);\r\n    }\r\n\r\n    function setDateMainEnd(uint _unixts) public onlyOwner checkDateOrder {\r\n        require(now < _unixts && now < dateMainEnd);\r\n        dateMainEnd = _unixts;\r\n        emit IcoDateUpdated(2, _unixts);\r\n    }\r\n\r\n    // where are we? Passed first day or not?\r\n\r\n    function isMainFirstDay() public view returns (bool) {\r\n        if (now > dateMainStart && now <= dateMainStart + 1 days) return true;\r\n        return false;\r\n    }\r\n\r\n    function isMain() public view returns (bool) {\r\n        if (now > dateMainStart && now < dateMainEnd) return true;\r\n        return false;\r\n    }\r\n\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n//\r\n// Zab public token sale\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\ncontract ZabToken is ERC20Token, Wallet, LockSlots, ZabIcoDates {\r\n\r\n    // Utility variable\r\n\r\n    uint constant E18 = 10**18;\r\n\r\n    // Basic token data\r\n\r\n    string public constant name = \"ZAB Token\";\r\n    string public constant symbol = \"ZAB\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    // Token number of possible tokens in existance\r\n\r\n    uint public constant MAX_TOTAL_TOKEN_SUPPLY = 100 * E18;\r\n\r\n\r\n    // crowdsale parameters\r\n    // Opening ETH Rate: USD$463.28\r\n    // Therefore, 1 ETH = 11582 ZAB\r\n\r\n\r\n    uint public tokensPerEth = 100;\r\n\r\n    // USD$2,000,000/463.28 = 4317.043668 ether\r\n    // 4317.043668 ether/2551 addresses = 1.692294656 ether per address for the first 24 hours\r\n\r\n    uint public constant MINIMUM_CONTRIBUTION = 0.02 ether;\r\n    uint public constant MAXIMUM_FIRST_DAY_CONTRIBUTION = 0.05 ether; /// amount token per bayer\r\n\r\n    uint public constant TOKEN_MAIN_CAP = 20 * E18; /// How much you would sale in token sale\r\n\r\n    bool public tokensTradeable;\r\n\r\n    // whitelisting\r\n\r\n    mapping(address => bool) public whitelist;\r\n    uint public numberWhitelisted;\r\n\r\n    // track main sale\r\n\r\n    uint public tokensMain;\r\n    mapping(address => uint) public balancesMain;\r\n\r\n    uint public totalEthContributed;\r\n    mapping(address => uint) public ethContributed;\r\n\r\n    // tracking tokens minted\r\n\r\n    uint public tokensMinted;\r\n    mapping(address => uint) public balancesMinted;\r\n    mapping(address => mapping(uint => uint)) public balancesMintedByType;\r\n\r\n    // migration variable\r\n\r\n    bool public isMigrationPhaseOpen;\r\n\r\n    // Events ---------------------------------------------\r\n\r\n    event UpdatedTokensPerEth(uint tokensPerEth);\r\n    event Whitelisted(address indexed account, uint countWhitelisted);\r\n    event TokensMinted(uint indexed mintType, address indexed account, uint tokens, uint term);\r\n    event RegisterContribution(address indexed account, uint tokensIssued, uint ethContributed, uint ethReturned);\r\n    event TokenExchangeRequested(address indexed account, uint tokens);\r\n\r\n    // Basic Functions ------------------------------------\r\n\r\n    constructor() public {}\r\n\r\n    function () public payable {\r\n        buyTokens();\r\n    }\r\n\r\n    // Information functions\r\n\r\n\r\n    function availableToMint() public view returns (uint) {\r\n        return MAX_TOTAL_TOKEN_SUPPLY.sub(TOKEN_MAIN_CAP).sub(tokensMinted);\r\n    }\r\n\r\n    function firstDayTokenLimit() public view returns (uint) {\r\n        return ethToTokens(MAXIMUM_FIRST_DAY_CONTRIBUTION);\r\n    }\r\n\r\n    function ethToTokens(uint _eth) public view returns (uint tokens) {\r\n        tokens = _eth.mul(tokensPerEth);\r\n    }\r\n\r\n    function tokensToEth(uint _tokens) public view returns (uint eth) {\r\n        eth = _tokens / tokensPerEth;\r\n    }\r\n\r\n    // Admin functions\r\n\r\n    function addToWhitelist(address _account) public onlyAdmin {\r\n        pWhitelist(_account);\r\n    }\r\n\r\n    function addToWhitelistMultiple(address[] _addresses) public onlyAdmin {\r\n        for (uint i; i < _addresses.length; i++) {\r\n            pWhitelist(_addresses[i]);\r\n        }\r\n    }\r\n\r\n    function pWhitelist(address _account) internal {\r\n        if (whitelist[_account]) return;\r\n        whitelist[_account] = true;\r\n        numberWhitelisted = numberWhitelisted.add(1);\r\n        emit Whitelisted(_account, numberWhitelisted);\r\n    }\r\n\r\n    // Owner functions ------------------------------------\r\n\r\n    function updateTokensPerEth(uint _tokens_per_eth) public onlyOwner {\r\n        require(now < dateMainStart);\r\n        tokensPerEth = _tokens_per_eth;\r\n        emit UpdatedTokensPerEth(tokensPerEth);\r\n    }\r\n\r\n    // Only owner can make tokens tradable at any time, or if the date is\r\n    // greater than the end of the mainsale date plus 20 weeks, allow\r\n    // any caller to make tokensTradeable.\r\n\r\n    function makeTradeable() public {\r\n        require(msg.sender == owner || now > dateMainEnd + 20 weeks);\r\n        tokensTradeable = true;\r\n    }\r\n\r\n    function openMigrationPhase() public onlyOwner {\r\n        require(now > dateMainEnd);\r\n        isMigrationPhaseOpen = true;\r\n    }\r\n\r\n    // Token minting --------------------------------------\r\n\r\n    function mintTokens(uint _mint_type, address _account, uint _tokens) public onlyOwner {\r\n        pMintTokens(_mint_type, _account, _tokens, 0);\r\n    }\r\n\r\n    function mintTokensMultiple(uint _mint_type, address[] _accounts, uint[] _tokens) public onlyOwner {\r\n        require(_accounts.length == _tokens.length);\r\n        for (uint i; i < _accounts.length; i++) {\r\n            pMintTokens(_mint_type, _accounts[i], _tokens[i], 0);\r\n        }\r\n    }\r\n\r\n    function mintTokensLocked(uint _mint_type, address _account, uint _tokens, uint _term) public onlyOwner {\r\n        pMintTokens(_mint_type, _account, _tokens, _term);\r\n    }\r\n\r\n    function mintTokensLockedMultiple(uint _mint_type, address[] _accounts, uint[] _tokens, uint[] _terms) public onlyOwner {\r\n        require(_accounts.length == _tokens.length);\r\n        require(_accounts.length == _terms.length);\r\n        for (uint i; i < _accounts.length; i++) {\r\n            pMintTokens(_mint_type, _accounts[i], _tokens[i], _terms[i]);\r\n        }\r\n    }\r\n\r\n    function pMintTokens(uint _mint_type, address _account, uint _tokens, uint _term) private {\r\n        require(whitelist[_account]);\r\n        require(_account != 0x0);\r\n        require(_tokens > 0);\r\n        require(_tokens <= availableToMint(), \"not enough tokens available to mint\");\r\n        require(_term == 0 || _term > now, \"either without lock term, or lock term must be in the future\");\r\n\r\n        // register locked tokens (will throw if no slot is found)\r\n        if (_term > 0) registerLockedTokens(_account, _tokens, _term);\r\n\r\n        // update\r\n        balances[_account] = balances[_account].add(_tokens);\r\n        balancesMinted[_account] = balancesMinted[_account].add(_tokens);\r\n        balancesMintedByType[_account][_mint_type] = balancesMintedByType[_account][_mint_type].add(_tokens);\r\n        tokensMinted = tokensMinted.add(_tokens);\r\n        tokensIssuedTotal = tokensIssuedTotal.add(_tokens);\r\n\r\n        // log event\r\n        emit Transfer(0x0, _account, _tokens);\r\n        emit TokensMinted(_mint_type, _account, _tokens, _term);\r\n    }\r\n\r\n    // Main sale ------------------------------------------\r\n\r\n    function buyTokens() private {\r\n\r\n        require(isMain());\r\n        require(msg.value >= MINIMUM_CONTRIBUTION);\r\n        require(whitelist[msg.sender]);\r\n\r\n        uint tokens_available = TOKEN_MAIN_CAP.sub(tokensMain);\r\n\r\n        // adjust tokens_available on first day, if necessary\r\n        if (isMainFirstDay()) {\r\n            uint tokens_available_first_day = firstDayTokenLimit().sub(balancesMain[msg.sender]);\r\n            if (tokens_available_first_day < tokens_available) {\r\n                tokens_available = tokens_available_first_day;\r\n            }\r\n        }\r\n\r\n        require (tokens_available > 0);\r\n\r\n        uint tokens_requested = ethToTokens(msg.value);\r\n        uint tokens_issued = tokens_requested;\r\n\r\n        uint eth_contributed = msg.value;\r\n        uint eth_returned;\r\n\r\n        if (tokens_requested > tokens_available) {\r\n            tokens_issued = tokens_available;\r\n            eth_returned = tokensToEth(tokens_requested.sub(tokens_available));\r\n            eth_contributed = msg.value.sub(eth_returned);\r\n        }\r\n\r\n        balances[msg.sender] = balances[msg.sender].add(tokens_issued);\r\n        balancesMain[msg.sender] = balancesMain[msg.sender].add(tokens_issued);\r\n        tokensMain = tokensMain.add(tokens_issued);\r\n        tokensIssuedTotal = tokensIssuedTotal.add(tokens_issued);\r\n\r\n        ethContributed[msg.sender] = ethContributed[msg.sender].add(eth_contributed);\r\n        totalEthContributed = totalEthContributed.add(eth_contributed);\r\n\r\n        // ether transfers\r\n        if (eth_returned > 0) msg.sender.transfer(eth_returned);\r\n        wallet.transfer(eth_contributed);\r\n\r\n        // log\r\n        emit Transfer(0x0, msg.sender, tokens_issued);\r\n        emit RegisterContribution(msg.sender, tokens_issued, eth_contributed, eth_returned);\r\n    }\r\n\r\n    // Token exchange / migration to new platform ---------\r\n\r\n    function requestTokenExchangeMax() public {\r\n        requestTokenExchange(unlockedTokensInternal(msg.sender));\r\n    }\r\n\r\n    function requestTokenExchange(uint _tokens) public {\r\n        require(isMigrationPhaseOpen);\r\n        require(_tokens > 0 && _tokens <= unlockedTokensInternal(msg.sender));\r\n        balances[msg.sender] = balances[msg.sender].sub(_tokens);\r\n        tokensIssuedTotal = tokensIssuedTotal.sub(_tokens);\r\n        emit Transfer(msg.sender, 0x0, _tokens);\r\n        emit TokenExchangeRequested(msg.sender, _tokens);\r\n    }\r\n\r\n    // ERC20 functions -------------------\r\n\r\n    /* Transfer out any accidentally sent ERC20 tokens */\r\n\r\n    function transferAnyERC20Token(address _token_address, uint _amount) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(_token_address).transfer(owner, _amount);\r\n    }\r\n\r\n    /* Override \"transfer\" */\r\n\r\n    function transfer(address _to, uint _amount) public returns (bool success) {\r\n        require(tokensTradeable);\r\n        require(_amount <= unlockedTokensInternal(msg.sender));\r\n        return super.transfer(_to, _amount);\r\n    }\r\n\r\n    /* Multiple token transfers from one address to save gas */\r\n\r\n    function transferMultiple(address[] _addresses, uint[] _amounts) external {\r\n        require(_addresses.length <= 100);\r\n        require(_addresses.length == _amounts.length);\r\n\r\n        // do the transfers\r\n        for (uint j; j < _addresses.length; j++) {\r\n            transfer(_addresses[j], _amounts[j]);\r\n        }\r\n\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"DATE_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_a\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TOTAL_TOKEN_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LOCK_SLOTS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balancesMinted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dateMainEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAXIMUM_FIRST_DAY_CONTRIBUTION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mint_type\",\"type\":\"uint256\"},{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"},{\"name\":\"_term\",\"type\":\"uint256\"}],\"name\":\"mintTokensLocked\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mint_type\",\"type\":\"uint256\"},{\"name\":\"_accounts\",\"type\":\"address[]\"},{\"name\":\"_tokens\",\"type\":\"uint256[]\"},{\"name\":\"_terms\",\"type\":\"uint256[]\"}],\"name\":\"mintTokensLockedMultiple\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lockTerm\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_MAIN_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"lockedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"openMigrationPhase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMain\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMainFirstDay\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensMinted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_a\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableToMint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"tokensToEth\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"unlockedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"requestTokenExchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensIssuedTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_unixts\",\"type\":\"uint256\"}],\"name\":\"setDateMainEnd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balancesMintedByType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_CONTRIBUTION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mint_type\",\"type\":\"uint256\"},{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"mintTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balancesMain\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"addToWhitelistMultiple\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"requestTokenExchangeMax\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens_per_eth\",\"type\":\"uint256\"}],\"name\":\"updateTokensPerEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"makeTradeable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"transferMultiple\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"ethToTokens\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dateMainStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_unixts\",\"type\":\"uint256\"}],\"name\":\"setDateMainStart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mint_type\",\"type\":\"uint256\"},{\"name\":\"_accounts\",\"type\":\"address[]\"},{\"name\":\"_tokens\",\"type\":\"uint256[]\"}],\"name\":\"mintTokensMultiple\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMigrationPhaseOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthContributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensTradeable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_term\",\"type\":\"uint256\"}],\"name\":\"isAvailableLockSlot\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token_address\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensMain\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"setWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lockAmnt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstDayTokenLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mayHaveLockedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ethContributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokensPerEth\",\"type\":\"uint256\"}],\"name\":\"UpdatedTokensPerEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"countWhitelisted\",\"type\":\"uint256\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"mintType\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"term\",\"type\":\"uint256\"}],\"name\":\"TokensMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensIssued\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethContributed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethReturned\",\"type\":\"uint256\"}],\"name\":\"RegisterContribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"TokenExchangeRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"unixts\",\"type\":\"uint256\"}],\"name\":\"IcoDateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"idx\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"term\",\"type\":\"uint256\"}],\"name\":\"RegisteredLockedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"WalletUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_admin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"AdminChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ZabToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://258fd12f859cb9a77ccb2b1eb6922bbb185722cf2596c1fc1f60299f43ef1c5a"}]}