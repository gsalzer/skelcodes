{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SEEDDEX\r\n * @dev This is the main contract for the SEEDDEX exchange.\r\n */\r\ncontract SEEDDEX {\r\n\r\n    /// Variables\r\n    address public admin; // the admin address\r\n    address constant public FicAddress = 0x0DD83B5013b2ad7094b1A7783d96ae0168f82621;  // FloraFIC token address\r\n    address public manager; // the manager address\r\n    address public feeAccount; // the account that will receive fees\r\n    uint public feeTakeMaker; // For Maker fee x% *10^18\r\n    uint public feeTakeSender; // For Sender fee x% *10^18\r\n    uint public feeTakeMakerFic;\r\n    uint public feeTakeSenderFic;\r\n    bool private depositingTokenFlag; // True when Token.transferFrom is being called from depositToken\r\n    mapping(address => mapping(address => uint)) public tokens; // mapping of token addresses to mapping of account balances (token=0 means Ether)\r\n    mapping(address => mapping(bytes32 => bool)) public orders; // mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\r\n    mapping(address => mapping(bytes32 => uint)) public orderFills; // mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\r\n    address public predecessor; // Address of the previous version of this contract. If address(0), this is the first version\r\n    address public successor; // Address of the next version of this contract. If address(0), this is the most up to date version.\r\n    uint16 public version; // This is the version # of the contract\r\n\r\n    /// Logging Events\r\n    event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address indexed user, bytes32 hash, uint amount);\r\n    event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address indexed user, uint8 v, bytes32 r, bytes32 s);\r\n    event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give, uint256 timestamp);\r\n    event Deposit(address token, address indexed user, uint amount, uint balance);\r\n    event Withdraw(address token, address indexed user, uint amount, uint balance);\r\n    event FundsMigrated(address indexed user, address newContract);\r\n\r\n    /// This is a modifier for functions to check if the sending user address is the same as the admin user address.\r\n    modifier isAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    /// this is manager can only change feeTakeMaker feeTakeMaker and change manager address (accept only Ethereum address)\r\n    modifier isManager() {\r\n        require(msg.sender == manager || msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    /// Constructor function. This is only called on contract creation.\r\n    function SEEDDEX(address admin_, address manager_, address feeAccount_, uint feeTakeMaker_, uint feeTakeSender_, uint feeTakeMakerFic_, uint feeTakeSenderFic_, address predecessor_) public {\r\n        admin = admin_;\r\n        manager = manager_;\r\n        feeAccount = feeAccount_;\r\n        feeTakeMaker = feeTakeMaker_;\r\n        feeTakeSender = feeTakeSender_;\r\n        feeTakeMakerFic = feeTakeMakerFic_;\r\n        feeTakeSenderFic = feeTakeSenderFic_;\r\n        depositingTokenFlag = false;\r\n        predecessor = predecessor_;\r\n\r\n        if (predecessor != address(0)) {\r\n            version = SEEDDEX(predecessor).version() + 1;\r\n        } else {\r\n            version = 1;\r\n        }\r\n    }\r\n\r\n    /// The fallback function. Ether transfered into the contract is not accepted.\r\n    function() public {\r\n        revert();\r\n    }\r\n\r\n    /// Changes the official admin user address. Accepts Ethereum address.\r\n    function changeAdmin(address admin_) public isAdmin {\r\n        require(admin_ != address(0));\r\n        admin = admin_;\r\n    }\r\n\r\n    /// Changes the manager user address. Accepts Ethereum address.\r\n    function changeManager(address manager_) public isManager {\r\n        require(manager_ != address(0));\r\n        manager = manager_;\r\n    }\r\n\r\n    /// Changes the account address that receives trading fees. Accepts Ethereum address.\r\n    function changeFeeAccount(address feeAccount_) public isAdmin {\r\n        feeAccount = feeAccount_;\r\n    }\r\n\r\n    /// Changes the fee on takes. Can only be changed to a value less than it is currently set at.\r\n    function changeFeeTakeMaker(uint feeTakeMaker_) public isManager {\r\n        feeTakeMaker = feeTakeMaker_;\r\n    }\r\n\r\n    function changeFeeTakeSender(uint feeTakeSender_) public isManager {\r\n        feeTakeSender = feeTakeSender_;\r\n    }\r\n\r\n    function changeFeeTakeMakerFic(uint feeTakeMakerFic_) public isManager {\r\n        feeTakeMakerFic = feeTakeMakerFic_;\r\n    }\r\n\r\n    function changeFeeTakeSenderFic(uint feeTakeSenderFic_) public isManager {\r\n        feeTakeSenderFic = feeTakeSenderFic_;\r\n    }\r\n\r\n    /// Changes the successor. Used in updating the contract.\r\n    function setSuccessor(address successor_) public isAdmin {\r\n        require(successor_ != address(0));\r\n        successor = successor_;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////////////////////\r\n    // Deposits, Withdrawals, Balances\r\n    ////////////////////////////////////////////////////////////////////////////////\r\n\r\n    /**\r\n    * This function handles deposits of Ether into the contract.\r\n    * Emits a Deposit event.\r\n    * Note: With the payable modifier, this function accepts Ether.\r\n    */\r\n    function deposit() public payable {\r\n        tokens[0][msg.sender] = SafeMath.add(tokens[0][msg.sender], msg.value);\r\n        Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\r\n    }\r\n\r\n    /**\r\n    * This function handles withdrawals of Ether from the contract.\r\n    * Verifies that the user has enough funds to cover the withdrawal.\r\n    * Emits a Withdraw event.\r\n    * @param amount uint of the amount of Ether the user wishes to withdraw\r\n    */\r\n    function withdraw(uint amount) {\r\n        if (tokens[0][msg.sender] < amount) throw;\r\n        tokens[0][msg.sender] = SafeMath.sub(tokens[0][msg.sender], amount);\r\n        if (!msg.sender.call.value(amount)()) throw;\r\n        Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\r\n    }\r\n\r\n    /**\r\n    * This function handles deposits of Ethereum based tokens to the contract.\r\n    * Does not allow Ether.\r\n    * If token transfer fails, transaction is reverted and remaining gas is refunded.\r\n    * Emits a Deposit event.\r\n    * Note: Remember to call IERC20(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\r\n    * @param token Ethereum contract address of the token or 0 for Ether\r\n    * @param amount uint of the amount of the token the user wishes to deposit\r\n    */\r\n    function depositToken(address token, uint amount) {\r\n        //remember to call IERC20(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\r\n        if (token == 0) throw;\r\n        if (!IERC20(token).transferFrom(msg.sender, this, amount)) throw;\r\n        tokens[token][msg.sender] = SafeMath.add(tokens[token][msg.sender], amount);\r\n        Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\r\n    }\r\n\r\n    /**\r\n    * This function provides a fallback solution as outlined in ERC223.\r\n    * If tokens are deposited through depositToken(), the transaction will continue.\r\n    * If tokens are sent directly to this contract, the transaction is reverted.\r\n    * @param sender Ethereum address of the sender of the token\r\n    * @param amount amount of the incoming tokens\r\n    * @param data attached data similar to msg.data of Ether transactions\r\n    */\r\n    function tokenFallback(address sender, uint amount, bytes data) public returns (bool ok) {\r\n        if (depositingTokenFlag) {\r\n            // Transfer was initiated from depositToken(). User token balance will be updated there.\r\n            return true;\r\n        } else {\r\n            // Direct ECR223 Token.transfer into this contract not allowed, to keep it consistent\r\n            // with direct transfers of ECR20 and ETH.\r\n            revert();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * This function handles withdrawals of Ethereum based tokens from the contract.\r\n    * Does not allow Ether.\r\n    * If token transfer fails, transaction is reverted and remaining gas is refunded.\r\n    * Emits a Withdraw event.\r\n    * @param token Ethereum contract address of the token or 0 for Ether\r\n    * @param amount uint of the amount of the token the user wishes to withdraw\r\n    */\r\n    function withdrawToken(address token, uint amount) {\r\n        if (token == 0) throw;\r\n        if (tokens[token][msg.sender] < amount) throw;\r\n        tokens[token][msg.sender] = SafeMath.sub(tokens[token][msg.sender], amount);\r\n        if (!IERC20(token).transfer(msg.sender, amount)) throw;\r\n        Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\r\n    }\r\n\r\n    /**\r\n    * Retrieves the balance of a token based on a user address and token address.\r\n    * @param token Ethereum contract address of the token or 0 for Ether\r\n    * @param user Ethereum address of the user\r\n    * @return the amount of tokens on the exchange for a given user address\r\n    */\r\n    function balanceOf(address token, address user) public constant returns (uint) {\r\n        return tokens[token][user];\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////////////////////\r\n    // Trading\r\n    ////////////////////////////////////////////////////////////////////////////////\r\n\r\n    /**\r\n    * Stores the active order inside of the contract.\r\n    * Emits an Order event.\r\n    *\r\n    *\r\n    * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n    * @param tokenGet Ethereum contract address of the token to receive\r\n    * @param amountGet uint amount of tokens being received\r\n    * @param tokenGive Ethereum contract address of the token to give\r\n    * @param amountGive uint amount of tokens being given\r\n    * @param expires uint of block number when this order should expire\r\n    * @param nonce arbitrary random number\r\n    */\r\n    function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) public {\r\n        bytes32 hash = keccak256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n        uint amount;\r\n        orders[msg.sender][hash] = true;\r\n        Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, hash, amount);\r\n    }\r\n\r\n    /**\r\n    * Facilitates a trade from one user to another.\r\n    * Requires that the transaction is signed properly, the trade isn't past its expiration, and all funds are present to fill the trade.\r\n    * Calls tradeBalances().\r\n    * Updates orderFills with the amount traded.\r\n    * Emits a Trade event.\r\n    * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n    * Note: amount is in amountGet / tokenGet terms.\r\n    * @param tokenGet Ethereum contract address of the token to receive\r\n    * @param amountGet uint amount of tokens being received\r\n    * @param tokenGive Ethereum contract address of the token to give\r\n    * @param amountGive uint amount of tokens being given\r\n    * @param expires uint of block number when this order should expire\r\n    * @param nonce arbitrary random number\r\n    * @param user Ethereum address of the user who placed the order\r\n    * @param v part of signature for the order hash as signed by user\r\n    * @param r part of signature for the order hash as signed by user\r\n    * @param s part of signature for the order hash as signed by user\r\n    * @param amount uint amount in terms of tokenGet that will be \"buy\" in the trade\r\n    */\r\n    function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) public {\r\n        bytes32 hash = keccak256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n        require((\r\n            (orders[user][hash] || ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == user) &&\r\n            block.number <= expires &&\r\n            SafeMath.add(orderFills[user][hash], amount) <= amountGet\r\n            ));\r\n        tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\r\n        orderFills[user][hash] = SafeMath.add(orderFills[user][hash], amount);\r\n        Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender, now);\r\n    }\r\n\r\n    /**\r\n    * This is a private function and is only being called from trade().\r\n    * Handles the movement of funds when a trade occurs.\r\n    * Takes fees.\r\n    * Updates token balances for both buyer and seller.\r\n    * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n    * Note: amount is in amountGet / tokenGet terms.\r\n    * @param tokenGet Ethereum contract address of the token to receive\r\n    * @param amountGet uint amount of tokens being received\r\n    * @param tokenGive Ethereum contract address of the token to give\r\n    * @param amountGive uint amount of tokens being given\r\n    * @param user Ethereum address of the user who placed the order\r\n    * @param amount uint amount in terms of tokenGet that will be \"buy\" in the trade\r\n    */\r\n    function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\r\n        if (tokenGet == FicAddress || tokenGive == FicAddress) {\r\n            tokens[tokenGet][msg.sender] = SafeMath.sub(tokens[tokenGet][msg.sender], amount);\r\n            tokens[tokenGet][user] = SafeMath.add(tokens[tokenGet][user], SafeMath.mul(amount, ((1 ether) - feeTakeMakerFic)) / (1 ether));\r\n            tokens[tokenGet][feeAccount] = SafeMath.add(tokens[tokenGet][feeAccount], SafeMath.mul(amount, feeTakeMakerFic) / (1 ether));\r\n            tokens[tokenGive][user] = SafeMath.sub(tokens[tokenGive][user], SafeMath.mul(amountGive, amount) / amountGet);\r\n            tokens[tokenGive][msg.sender] = SafeMath.add(tokens[tokenGive][msg.sender], SafeMath.mul(SafeMath.mul(((1 ether) - feeTakeSenderFic), amountGive), amount) / amountGet / (1 ether));\r\n            tokens[tokenGive][feeAccount] = SafeMath.add(tokens[tokenGive][feeAccount], SafeMath.mul(SafeMath.mul(feeTakeSenderFic, amountGive), amount) / amountGet / (1 ether));\r\n        }\r\n        else {\r\n            tokens[tokenGet][msg.sender] = SafeMath.sub(tokens[tokenGet][msg.sender], amount);\r\n            tokens[tokenGet][user] = SafeMath.add(tokens[tokenGet][user], SafeMath.mul(amount, ((1 ether) - feeTakeMaker)) / (1 ether));\r\n            tokens[tokenGet][feeAccount] = SafeMath.add(tokens[tokenGet][feeAccount], SafeMath.mul(amount, feeTakeMaker) / (1 ether));\r\n            tokens[tokenGive][user] = SafeMath.sub(tokens[tokenGive][user], SafeMath.mul(amountGive, amount) / amountGet);\r\n            tokens[tokenGive][msg.sender] = SafeMath.add(tokens[tokenGive][msg.sender], SafeMath.mul(SafeMath.mul(((1 ether) - feeTakeSender), amountGive), amount) / amountGet / (1 ether));\r\n            tokens[tokenGive][feeAccount] = SafeMath.add(tokens[tokenGive][feeAccount], SafeMath.mul(SafeMath.mul(feeTakeSender, amountGive), amount) / amountGet / (1 ether));\r\n        }\r\n    }\r\n\r\n    /**\r\n    * This function is to test if a trade would go through.\r\n    * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n    * Note: amount is in amountGet / tokenGet terms.\r\n    * @param tokenGet Ethereum contract address of the token to receive\r\n    * @param amountGet uint amount of tokens being received\r\n    * @param tokenGive Ethereum contract address of the token to give\r\n    * @param amountGive uint amount of tokens being given\r\n    * @param expires uint of block number when this order should expire\r\n    * @param nonce arbitrary random number\r\n    * @param user Ethereum address of the user who placed the order\r\n    * @param v part of signature for the order hash as signed by user\r\n    * @param r part of signature for the order hash as signed by user\r\n    * @param s part of signature for the order hash as signed by user\r\n    * @param amount uint amount in terms of tokenGet that will be \"buy\" in the trade\r\n    * @param sender Ethereum address of the user taking the order\r\n    * @return bool: true if the trade would be successful, false otherwise\r\n    */\r\n    function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) public constant returns (bool) {\r\n        if (!(\r\n        tokens[tokenGet][sender] >= amount &&\r\n        availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\r\n        )) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * This function checks the available volume for a given order.\r\n    * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n    * @param tokenGet Ethereum contract address of the token to receive\r\n    * @param amountGet uint amount of tokens being received\r\n    * @param tokenGive Ethereum contract address of the token to give\r\n    * @param amountGive uint amount of tokens being given\r\n    * @param expires uint of block number when this order should expire\r\n    * @param nonce arbitrary random number\r\n    * @param user Ethereum address of the user who placed the order\r\n    * @param v part of signature for the order hash as signed by user\r\n    * @param r part of signature for the order hash as signed by user\r\n    * @param s part of signature for the order hash as signed by user\r\n    * @return uint: amount of volume available for the given order in terms of amountGet / tokenGet\r\n    */\r\n    function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public constant returns (uint) {\r\n        bytes32 hash = keccak256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n        if (!(\r\n        (orders[user][hash] || ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == user) &&\r\n        block.number <= expires\r\n        )) {\r\n            return 0;\r\n        }\r\n        uint[2] memory available;\r\n        available[0] = SafeMath.sub(amountGet, orderFills[user][hash]);\r\n        available[1] = SafeMath.mul(tokens[tokenGive][user], amountGet) / amountGive;\r\n        if (available[0] < available[1]) {\r\n            return available[0];\r\n        } else {\r\n            return available[1];\r\n        }\r\n    }\r\n\r\n    /**\r\n    * This function checks the amount of an order that has already been filled.\r\n    * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n    * @param tokenGet Ethereum contract address of the token to receive\r\n    * @param amountGet uint amount of tokens being received\r\n    * @param tokenGive Ethereum contract address of the token to give\r\n    * @param amountGive uint amount of tokens being given\r\n    * @param expires uint of block number when this order should expire\r\n    * @param nonce arbitrary random number\r\n    * @param user Ethereum address of the user who placed the order\r\n    * @param v part of signature for the order hash as signed by user\r\n    * @param r part of signature for the order hash as signed by user\r\n    * @param s part of signature for the order hash as signed by user\r\n    * @return uint: amount of the given order that has already been filled in terms of amountGet / tokenGet\r\n    */\r\n    function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public constant returns (uint) {\r\n        bytes32 hash = keccak256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n        return orderFills[user][hash];\r\n    }\r\n\r\n    /**\r\n    * This function cancels a given order by editing its fill data to the full amount.\r\n    * Requires that the transaction is signed properly.\r\n    * Updates orderFills to the full amountGet\r\n    * Emits a Cancel event.\r\n    * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n    * @param tokenGet Ethereum contract address of the token to receive\r\n    * @param amountGet uint amount of tokens being received\r\n    * @param tokenGive Ethereum contract address of the token to give\r\n    * @param amountGive uint amount of tokens being given\r\n    * @param expires uint of block number when this order should expire\r\n    * @param nonce arbitrary random number\r\n    * @param v part of signature for the order hash as signed by user\r\n    * @param r part of signature for the order hash as signed by user\r\n    * @param s part of signature for the order hash as signed by user\r\n    * @return uint: amount of the given order that has already been filled in terms of amountGet / tokenGet\r\n    */\r\n    function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) public {\r\n        bytes32 hash = keccak256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n        require((orders[msg.sender][hash] || ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == msg.sender));\r\n        orderFills[msg.sender][hash] = amountGet;\r\n        Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\r\n    }\r\n\r\n\r\n\r\n    ////////////////////////////////////////////////////////////////////////////////\r\n    // Contract Versioning / Migration\r\n    ////////////////////////////////////////////////////////////////////////////////\r\n\r\n    /**\r\n    * User triggered function to migrate funds into a new contract to ease updates.\r\n    * Emits a FundsMigrated event.\r\n    * @param newContract Contract address of the new contract we are migrating funds to\r\n    * @param tokens_ Array of token addresses that we will be migrating to the new contract\r\n    */\r\n    function migrateFunds(address newContract, address[] tokens_) public {\r\n\r\n        require(newContract != address(0));\r\n\r\n        SEEDDEX newExchange = SEEDDEX(newContract);\r\n\r\n        // Move Ether into new exchange.\r\n        uint etherAmount = tokens[0][msg.sender];\r\n        if (etherAmount > 0) {\r\n            tokens[0][msg.sender] = 0;\r\n            newExchange.depositForUser.value(etherAmount)(msg.sender);\r\n        }\r\n\r\n        // Move Tokens into new exchange.\r\n        for (uint16 n = 0; n < tokens_.length; n++) {\r\n            address token = tokens_[n];\r\n            require(token != address(0));\r\n            // Ether is handled above.\r\n            uint tokenAmount = tokens[token][msg.sender];\r\n\r\n            if (tokenAmount != 0) {\r\n                if (!IERC20(token).approve(newExchange, tokenAmount)) throw;\r\n                tokens[token][msg.sender] = 0;\r\n                newExchange.depositTokenForUser(token, tokenAmount, msg.sender);\r\n            }\r\n        }\r\n\r\n        FundsMigrated(msg.sender, newContract);\r\n    }\r\n\r\n\r\n    /**\r\n    * This function handles deposits of Ether into the contract, but allows specification of a user.\r\n    * Note: This is generally used in migration of funds.\r\n    * Note: With the payable modifier, this function accepts Ether.\r\n    */\r\n    function depositForUser(address user) public payable {\r\n        require(user != address(0));\r\n        require(msg.value > 0);\r\n        tokens[0][user] = SafeMath.add(tokens[0][user], (msg.value));\r\n    }\r\n\r\n    /**\r\n    * This function handles deposits of Ethereum based tokens into the contract, but allows specification of a user.\r\n    * Does not allow Ether.\r\n    * If token transfer fails, transaction is reverted and remaining gas is refunded.\r\n    * Note: This is generally used in migration of funds.\r\n    * Note: Remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\r\n    * @param token Ethereum contract address of the token\r\n    * @param amount uint of the amount of the token the user wishes to deposit\r\n    */\r\n    function depositTokenForUser(address token, uint amount, address user) public {\r\n        require(token != address(0));\r\n        require(user != address(0));\r\n        require(amount > 0);\r\n        depositingTokenFlag = true;\r\n        if (!IERC20(token).transferFrom(msg.sender, this, amount)) throw;\r\n        depositingTokenFlag = false;\r\n        tokens[token][user] = SafeMath.add(tokens[token][user], (amount));\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"feeTakeSender\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"trade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"order\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"successor_\",\"type\":\"address\"}],\"name\":\"setSuccessor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feeTakeMaker_\",\"type\":\"uint256\"}],\"name\":\"changeFeeTakeMaker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderFills\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeTakeMaker\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"depositTokenForUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"amountFilled\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newContract\",\"type\":\"address\"},{\"name\":\"tokens_\",\"type\":\"address[]\"}],\"name\":\"migrateFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"depositForUser\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"testTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"successor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feeAccount_\",\"type\":\"address\"}],\"name\":\"changeFeeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feeTakeSenderFic_\",\"type\":\"uint256\"}],\"name\":\"changeFeeTakeSenderFic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeTakeSenderFic\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin_\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeTakeMakerFic\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"manager_\",\"type\":\"address\"}],\"name\":\"changeManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feeTakeMakerFic_\",\"type\":\"uint256\"}],\"name\":\"changeFeeTakeMakerFic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feeTakeSender_\",\"type\":\"uint256\"}],\"name\":\"changeFeeTakeSender\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"predecessor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orders\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FicAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"availableVolume\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"admin_\",\"type\":\"address\"},{\"name\":\"manager_\",\"type\":\"address\"},{\"name\":\"feeAccount_\",\"type\":\"address\"},{\"name\":\"feeTakeMaker_\",\"type\":\"uint256\"},{\"name\":\"feeTakeSender_\",\"type\":\"uint256\"},{\"name\":\"feeTakeMakerFic_\",\"type\":\"uint256\"},{\"name\":\"feeTakeSenderFic_\",\"type\":\"uint256\"},{\"name\":\"predecessor_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenGet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenGive\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expires\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Order\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenGet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenGive\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expires\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"v\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"r\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenGet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenGive\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"get\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"give\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"FundsMigrated\",\"type\":\"event\"}]","ContractName":"SEEDDEX","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a1129df7cbecb9ef71fc29aff2995d6af004d551000000000000000000000000a1129df7cbecb9ef71fc29aff2995d6af004d551000000000000000000000000a1129df7cbecb9ef71fc29aff2995d6af004d55100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://38c4555d7a818d499935ada3539239e2db9548bac67d30256bacc86ee875f6be"}]}