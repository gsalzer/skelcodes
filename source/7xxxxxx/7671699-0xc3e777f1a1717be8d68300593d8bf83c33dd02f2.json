{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.0 <0.6.0;\r\n\r\n/* HEY WELCOME TO MyEther.DATE's OFFICIAL SMART CONTRACT!\r\n\r\n    My name is Tay Tay and I will help you digest the material of this contract, \r\n    all in layman's terms. \r\n     \r\n\r\n*/\r\n\r\ncontract myEtherDate {\r\n    \r\n    struct Player {\r\n        uint commitBlock;\r\n        uint stake;\r\n    }\r\n    \r\n    mapping(address => Player) public player;\r\n    uint public maxStake;\r\n    address public owner;\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    /* Here is where the fun begins. When you materialize your 4 dates, all\r\n    * the contract really cares is WHEN you did it and how big was your stake.\r\n    * so yeah, sorry to burst the bubble but the matchmaking has nothing to do\r\n    * with the outcome of your bet. \r\n    */ \r\n    function set() \r\n        public\r\n        payable\r\n        returns (bool success)\r\n    {\r\n        // this is to make sure our bankroll can cover the maximum payout \r\n        // for your stake and also to make sure your stake is greater than zero. \r\n        require(msg.value > 0 && msg.value <= maxStake);\r\n        \r\n        // Since future hashes are quite hard to predict, \r\n        // your random seed will be the hash of the next block\r\n        player[msg.sender].commitBlock = block.number + 1;\r\n        player[msg.sender].stake = msg.value;\r\n        \r\n        return true;\r\n    }  \r\n    \r\n    /* RANDOM NUMBER GENERATION function \r\n    *\r\n    *  This is pretty much a copy-paste of cryptokitties gene science algorithm but\r\n    *  tailored to our specific purposes.\r\n    *\r\n    *  This function is public (gas-free) so it is called by MyEther.DATE's interface on behalf \r\n    *  of the user, automatically, as soon as random numbers are available.\r\n    *\r\n    *  The interface will then interpret these random numbers and tell the player if he won or not.\r\n    *  If he won, it is up to him to call the \"claim\" function. \r\n    *\r\n    */\r\n    function getRand() \r\n        view\r\n        public\r\n        returns (uint[4] memory) \r\n    {\r\n        // convert our \"pseudo-random\" hash to human-redeable integers\r\n        uint256 randomN = uint256(blockhash(player[msg.sender].commitBlock));\r\n      \r\n        // this function will not work if it is called to soon \r\n        // (like right after the bet was placed, because the hash for the next block is not yet available), \r\n        // or too late (256+ blocks after the bet was placed, because the etheruem blockchain \r\n        // only stores the most recent 256 block hashes) \r\n        require(randomN != 0);\r\n\r\n        uint256 offset;\r\n        uint[4] memory randNums;\r\n        \r\n        // this loop will slice our random number into 4 smaller numbers,\r\n        // each one from 0 to 65535\r\n        for(uint i = 0; i < 4; i++){\r\n            randNums[i] = _sliceNumber(randomN, 16, offset);  \r\n            offset += 32;    \r\n        }\r\n        \r\n        // return our 4 random numbers\r\n        return randNums;\r\n    }\r\n    \r\n    /*  CLAIM function\r\n    *   \r\n    *   This function can be evoked by anybody, but it will only payout ether to actual\r\n    *   winners. \r\n    *\r\n    */\r\n    function claim()\r\n        public\r\n        payable\r\n        returns (bool success)\r\n    {\r\n        uint[4] memory rand = getRand();\r\n        player[msg.sender].commitBlock = 0;\r\n        uint256 stake = player[msg.sender].stake;\r\n        player[msg.sender].stake = 0;\r\n        \r\n        uint256 successfulDate;\r\n        \r\n        // you get 4 random numbers for 4 date outcomes..\r\n        // To get a successful date, any of your random numbers must be less than 8110\r\n        // and since they range from 0 to 65536, you have a winning probability \r\n        // of 0.12375 on each date\r\n        for (uint i = 0; i < 4; i++) {\r\n            if (rand[i] < 8110) \r\n                successfulDate++;\r\n        }\r\n        \r\n        if (successfulDate != 0) {\r\n            // for each successful date, we double your stake, \r\n            // this equals a 1% edge...\r\n            uint256 payout = SafeMath.mul(stake, 2);\r\n            payout = SafeMath.mul(payout, successfulDate);\r\n            msg.sender.transfer(payout);\r\n            updateMaxStake();\r\n        }\r\n\r\n        return true;\r\n    }\r\n    \r\n    /// @dev given a number get a slice of any bits, at certain offset\r\n    /// @param _n a number to be sliced\r\n    /// @param _nbits how many bits long is the new number\r\n    /// @param _offset how many bits to skip\r\n    function _sliceNumber(uint256 _n, uint256 _nbits, uint256 _offset) \r\n        private \r\n        pure \r\n        returns (uint256) \r\n    {\r\n        // mask is made by shifting left an offset number of times\r\n        uint256 mask = uint256((2**_nbits) - 1) << _offset;\r\n        // AND n with mask, and trim to max of _nbits bits\r\n        return uint256((_n & mask) >> _offset);\r\n    }\r\n    \r\n    function fundBankroll()\r\n        public\r\n        payable\r\n        returns(bool success)\r\n    {\r\n        updateMaxStake();\r\n        return true;\r\n    }\r\n    \r\n    function updateMaxStake()\r\n        public\r\n        returns (bool success)\r\n    {\r\n        uint256 newMax = SafeMath.div(address(this).balance, 8);\r\n        maxStake = newMax;\r\n        return true;\r\n    }\r\n        \r\n    function collect(uint256 ammount)\r\n        public\r\n        onlyOwner\r\n        returns (bool success)\r\n    {\r\n        msg.sender.transfer(ammount);\r\n        updateMaxStake();\r\n        return true;\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) \r\n        public\r\n        onlyOwner\r\n    {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n    \r\n}\r\n\r\n    /**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"player\",\"outputs\":[{\"name\":\"commitBlock\",\"type\":\"uint256\"},{\"name\":\"stake\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRand\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fundBankroll\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateMaxStake\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"set\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ammount\",\"type\":\"uint256\"}],\"name\":\"collect\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"myEtherDate","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4322f4821505f09798db39840031fd89262da0b9551640d67362c54fde4be5f5"}]}