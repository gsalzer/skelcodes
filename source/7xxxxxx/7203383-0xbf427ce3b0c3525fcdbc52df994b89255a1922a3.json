{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract EventFactory{\r\n\r\n    bool isStopped = false;\r\n\r\n    address public owner = msg.sender;\r\n\r\n    mapping (address => bool) registerSite;\r\n\r\n    address[] public events;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n    function stopContract() onlyOwner public {\r\n        isStopped = true;\r\n    }\r\n\r\n    function resumeContract() onlyOwner public {\r\n        isStopped = false;\r\n    }\r\n\r\n    function emergencyWithdraw() onlyOwner public {\r\n        require(isStopped == true);\r\n        owner.transfer(address(this).balance);\r\n    }\r\n\r\n    function destroyContract() onlyOwner public {\r\n        require(isStopped == true);\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function createEvent(string _siteName, string _eventName, uint totalTickets, uint defaultPrice) public returns (address) {\r\n        Event newEvent = new Event(msg.sender, _siteName, _eventName, totalTickets, defaultPrice);\r\n        events.push(newEvent);\r\n        return newEvent;\r\n    }\r\n\r\n    function getEvents() public view returns (address[]) {\r\n        return events;\r\n    }\r\n\r\n    function registerEventSite(address siteAddr) onlyOwner public {\r\n        registerSite[siteAddr] = true;\r\n    }\r\n\r\n    function deleteEventSite(address siteAddr) onlyOwner public {\r\n        registerSite[siteAddr] = false;\r\n    }\r\n\r\n    function isValid(address _siteAddr) public view returns (bool){\r\n        if(registerSite[_siteAddr])\r\n            return registerSite[_siteAddr];\r\n        else\r\n            return false;\r\n    }\r\n}\r\n\r\ncontract Event{\r\n    bool isStopped = false;\r\n\r\n    enum EventState {\r\n        READY, OPEN, CLOSED\r\n    }\r\n\r\n    enum TicketState {\r\n        SELLING, OCCUPIED, RESELLING\r\n    }\r\n\r\n    EventState public eventState;\r\n\r\n    struct Ticket {\r\n        TicketState state;\r\n        address owner;\r\n        uint price;\r\n    }\r\n\r\n    mapping (uint => uint) public reSellPrice;\r\n    mapping (uint => address) public reserved;\r\n\r\n    /* ether to refund dedicated to the withdrawer's address */\r\n    mapping (address => uint) public refundable;\r\n\r\n    uint public totalTickets;\r\n    uint public createtionTime = now;\r\n    address public eventOwner;\r\n    string public siteName;\r\n    string public eventName;\r\n    Ticket[] public tickets;\r\n    uint public defaultPrice;\r\n\r\n    constructor(\r\n        address _eventOwner,\r\n        string _siteName,\r\n        string _eventName,\r\n        uint _totalTickets,\r\n        uint _defaultPrice\r\n    ) public {\r\n        eventOwner = _eventOwner;\r\n        siteName = _siteName;\r\n        eventName = _eventName;\r\n        totalTickets = _totalTickets;\r\n        defaultPrice = _defaultPrice;\r\n        Ticket memory defaultTicket = Ticket(TicketState.SELLING, 0, defaultPrice);\r\n\r\n        uint i = 0;\r\n        while (i< totalTickets){\r\n            tickets.push(defaultTicket);\r\n            i++;\r\n        }\r\n    }\r\n\r\n    /* modifiers */\r\n    modifier onlyEventOwner() {\r\n        require(msg.sender == eventOwner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyState(EventState _eventState) {\r\n        require(eventState == _eventState);\r\n        _;\r\n    }\r\n\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n    /* ------------------- Event Owner Only functions -------------------*/\r\n    function stopContract() onlyEventOwner public {\r\n        isStopped = true;\r\n    }\r\n\r\n    function resumeContract() onlyEventOwner public {\r\n        isStopped = false;\r\n    }\r\n\r\n    function emergencyWithdraw() onlyEventOwner public {\r\n        require(isStopped == true);\r\n        eventOwner.transfer(address(this).balance);\r\n    }\r\n\r\n    function destroyContract() onlyEventOwner public {\r\n        require(isStopped == true);\r\n        selfdestruct(eventOwner);\r\n    }\r\n\r\n    function updateEventInfo(uint _totalTickets) onlyEventOwner onlyState(EventState.READY) public {\r\n        Ticket memory defaultTicket = Ticket(TicketState.SELLING, 0, defaultPrice);\r\n        if (_totalTickets > totalTickets){\r\n            uint i = totalTickets;\r\n            while (i < _totalTickets){\r\n                tickets.push(defaultTicket);\r\n                i++;\r\n            }\r\n        }\r\n        totalTickets = _totalTickets;\r\n    }\r\n\r\n\r\n    function updateTicketPrice(uint startTicketNo, uint endTicketNo, uint price) onlyEventOwner onlyState(EventState.READY) public {\r\n        require(endTicketNo >= startTicketNo && endTicketNo < totalTickets);\r\n        for(uint i = startTicketNo; i <= endTicketNo; i++){\r\n            tickets[i].price = price;\r\n        }\r\n    }\r\n\r\n    function changeEventState (EventState es) onlyEventOwner public {\r\n        require(es == EventState.OPEN || es == EventState.CLOSED);\r\n        require(es > eventState);\r\n        eventState = es;\r\n    }\r\n\r\n    /* ------------------- User functions -------------------*/\r\n\r\n    // Use to buy tickets.\r\n    // Ether is transter to the event owner from the caller.\r\n    function buyTicket(uint startTicketNo, uint endTicketNo) onlyState(EventState.OPEN) public payable {\r\n        require(endTicketNo >= startTicketNo && endTicketNo < totalTickets);\r\n        require(getTicketStateSum(startTicketNo, endTicketNo, TicketState.SELLING) ==  (endTicketNo - startTicketNo +1));\r\n\r\n        uint priceSum = getPriceSum(startTicketNo, endTicketNo);\r\n        require (priceSum <= msg.value);\r\n\r\n        for(uint i = startTicketNo; i <= endTicketNo; i++){\r\n            tickets[i].state = TicketState.OCCUPIED;\r\n            tickets[i].owner = msg.sender;\r\n        }\r\n\r\n        refundable[eventOwner] += priceSum;\r\n        refundable[msg.sender] += msg.value - priceSum;\r\n\r\n        assert(getOwnerSum(startTicketNo, endTicketNo, msg.sender) == (endTicketNo - startTicketNo +1));\r\n        assert(getTicketStateSum(startTicketNo, endTicketNo, TicketState.OCCUPIED) == (endTicketNo - startTicketNo +1) );\r\n    }\r\n\r\n    // Use to cancel occupied Tickets.\r\n    // All selected ticket should be the same owner.\r\n    // Ether is transter to the caller from the event owner.\r\n    // Ether is not send rightly, that can be withdraw after cancel the ticket.\r\n    function cancelTicket(uint startTicketNo, uint endTicketNo) onlyState(EventState.OPEN) public {\r\n        require(endTicketNo >= startTicketNo && endTicketNo < totalTickets);\r\n        require(getOwnerSum(startTicketNo, endTicketNo, msg.sender) == (endTicketNo - startTicketNo +1));\r\n\r\n        uint priceSum = getPriceSum(startTicketNo, endTicketNo);\r\n        require(refundable[eventOwner] >= priceSum);\r\n\r\n        for(uint i = startTicketNo; i <= endTicketNo; i++){\r\n            tickets[i].state = TicketState.SELLING;\r\n            tickets[i].owner = 0;\r\n        }\r\n\r\n        refundable[msg.sender] += priceSum;\r\n        refundable[eventOwner] -= priceSum;\r\n\r\n        assert(getOwnerSum(startTicketNo, endTicketNo, msg.sender) == 0);\r\n        assert(getTicketStateSum(startTicketNo, endTicketNo, TicketState.SELLING) == (endTicketNo - startTicketNo +1));\r\n    }\r\n\r\n    // Use to buy reSelling Tickets\r\n    // If someone reserve the ticket, only reserved account can buy the ticket.\r\n    // This function may be use to send friends or someone to reserved in offline.\r\n    function buyReSellTicket(uint startTicketNo, uint endTicketNo) onlyState(EventState.OPEN) public payable {\r\n        require(endTicketNo >= startTicketNo && endTicketNo < totalTickets);\r\n\r\n        uint sum = 0;\r\n        uint validCount = 0;\r\n        address sellingOwner = tickets[startTicketNo].owner;\r\n        uint expectedSellerBalance = 0;\r\n\r\n        for(uint i = startTicketNo; i <= endTicketNo; i++){\r\n            if(tickets[i].state == TicketState.RESELLING && sellingOwner == tickets[i].owner){\r\n                if((reserved[i] == 0) || reserved[i] == msg.sender) {\r\n                    validCount ++;\r\n                    sum += reSellPrice[i];\r\n                }\r\n            }\r\n            else break;\r\n        }\r\n\r\n        require(validCount == (endTicketNo - startTicketNo +1));\r\n        require(sum <= msg.value);\r\n\r\n        expectedSellerBalance = refundable[sellingOwner] + sum;\r\n\r\n        for(i = startTicketNo; i <= endTicketNo; i++){\r\n            tickets[i].state = TicketState.OCCUPIED;\r\n            tickets[i].owner = msg.sender;\r\n            reSellPrice[i] = 0;\r\n            reserved[i] = 0;\r\n        }\r\n\r\n        refundable[msg.sender] += msg.value-sum;\r\n        refundable[sellingOwner] += sum;\r\n\r\n        assert(expectedSellerBalance == refundable[sellingOwner]);\r\n        assert(getOwnerSum(startTicketNo, endTicketNo, msg.sender) == (endTicketNo - startTicketNo +1));\r\n        assert(getTicketStateSum(startTicketNo, endTicketNo, TicketState.OCCUPIED) == (endTicketNo - startTicketNo +1));\r\n    }\r\n\r\n    function reSellTicket(uint startTicketNo, uint endTicketNo, uint price, address _receiver) onlyState(EventState.OPEN) public {\r\n        require(endTicketNo >= startTicketNo && endTicketNo < totalTickets);\r\n        require(getOwnerSum(startTicketNo, endTicketNo, msg.sender) == (endTicketNo - startTicketNo +1));\r\n\r\n        for(uint i = startTicketNo; i <= endTicketNo; i++){\r\n            tickets[i].state = TicketState.RESELLING;\r\n            reSellPrice[i] = price;\r\n            reserved[i] = _receiver;\r\n        }\r\n\r\n        assert(getOwnerSum(startTicketNo, endTicketNo, msg.sender) == (endTicketNo - startTicketNo +1));\r\n    }\r\n\r\n    // user can withdraw wei at any state\r\n    // in case of eventowner can withdraw after end of the Event.\r\n    function withdraw() public{\r\n        if(msg.sender == eventOwner) require(eventState == EventState.CLOSED);\r\n        uint mount = refundable[msg.sender];\r\n        require(mount > 0);\r\n        refundable[msg.sender] = 0;\r\n        msg.sender.transfer(mount);\r\n\r\n        assert(refundable[msg.sender] == 0);\r\n    }\r\n\r\n    /* ------------------- get functions for Web -------------------*/\r\n\r\n    function getEventData(address owner) public view returns(address, string, string, EventState, uint, uint){\r\n        return (eventOwner, siteName, eventName, eventState, totalTickets, refundable[owner]);\r\n    }\r\n\r\n    function getTicketData(address currentAddr) public view returns (TicketState[], uint[], bool[], uint[], address[]){\r\n        TicketState[] memory ts = new TicketState[](totalTickets);\r\n        uint[] memory _price = new uint[](totalTickets);\r\n        bool[] memory isOwner = new bool[](totalTickets);\r\n        uint[] memory _reSellPrice = new uint[](totalTickets);\r\n        address[] memory _reserved = new address[](totalTickets);\r\n        uint i = 0;\r\n        while (i < totalTickets){\r\n            ts[i] = tickets[i].state;\r\n            _price[i] = tickets[i].price;\r\n            if(currentAddr == tickets[i].owner) isOwner[i]= true;\r\n            if(ts[i] == TicketState.RESELLING) {\r\n                _reSellPrice[i] = reSellPrice[i];\r\n                _reserved[i] = reserved[i];\r\n            }\r\n            i++;\r\n        }\r\n\r\n        return (ts, _price, isOwner, _reSellPrice, _reserved);\r\n    }\r\n\r\n    /* ------------------- internal functions (private) -------------------*/\r\n    function getPriceSum(uint startTicketNo, uint endTicketNo) private view returns (uint){\r\n        require(endTicketNo >= startTicketNo && endTicketNo < totalTickets);\r\n        uint sum = 0;\r\n        uint i = startTicketNo;\r\n        while (i <= endTicketNo){\r\n            sum += tickets[i].price;\r\n            i++;\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    function getOwnerSum(uint startTicketNo, uint endTicketNo, address owner) private view returns (uint) {\r\n        require(endTicketNo >= startTicketNo && endTicketNo < totalTickets);\r\n        uint counter = 0;\r\n        uint i = startTicketNo;\r\n        while (i <= endTicketNo){\r\n            if(tickets[i].owner == owner) counter++;\r\n            i++;\r\n        }\r\n        return counter;\r\n    }\r\n\r\n    function getTicketStateSum(uint startTicketNo, uint endTicketNo, TicketState _state) private view returns (uint){\r\n        require(endTicketNo >= startTicketNo && endTicketNo < totalTickets);\r\n        uint counter = 0;\r\n        uint i = startTicketNo;\r\n        while (i <= endTicketNo){\r\n            if(tickets[i].state == _state) counter++;\r\n            i++;\r\n        }\r\n        return counter;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"destroyContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"events\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEvents\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"siteAddr\",\"type\":\"address\"}],\"name\":\"deleteEventSite\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_siteAddr\",\"type\":\"address\"}],\"name\":\"isValid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"siteAddr\",\"type\":\"address\"}],\"name\":\"registerEventSite\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_siteName\",\"type\":\"string\"},{\"name\":\"_eventName\",\"type\":\"string\"},{\"name\":\"totalTickets\",\"type\":\"uint256\"},{\"name\":\"defaultPrice\",\"type\":\"uint256\"}],\"name\":\"createEvent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resumeContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"EventFactory","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://abdd8be7bb6474f801f31e612bb4ccf637861ff5475b05a7e181201f19a76762"}]}