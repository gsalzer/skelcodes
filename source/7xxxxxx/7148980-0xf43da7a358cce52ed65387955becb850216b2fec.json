{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter);\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n\r\n\r\ncontract Crowdsale is ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    \r\n    address public manager;\r\n    address payable public returnWallet;\r\n    uint256 public etherEuroRate;\r\n    uint256 public safetyLimit = 300000*10**18;\r\n    ERC20Interface private _token;\r\n    uint256 public minWeiValue = 10**17;\r\n\r\n    constructor (\r\n            uint256 rate, \r\n            address payable wallet, \r\n            address contractManager, \r\n            ERC20Interface token\r\n                ) public {\r\n        require(rate > 0);\r\n        require(wallet != address(0));\r\n        require(contractManager != address(0));\r\n        require(address(token) != address(0));\r\n\r\n        manager = contractManager;\r\n        etherEuroRate = rate;\r\n        returnWallet = wallet;\r\n        _token = token;\r\n    }\r\n    \r\n    modifier restricted(){\r\n        require(msg.sender == manager );\r\n        _;\r\n    }\r\n\r\n    \r\n    function buyTokens(address beneficiary) public nonReentrant payable {\r\n        uint256 weiAmount = msg.value;\r\n        _preValidatePurchase(beneficiary, weiAmount);\r\n        uint256 tokens = (weiAmount.div(2)).mul(etherEuroRate);\r\n        require(tokens>0);\r\n        require(weiAmount>minWeiValue);\r\n        _forwardFunds();\r\n        _token.transfer(beneficiary,tokens);\r\n    }\r\n\r\n    function () external payable {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {\r\n        require(beneficiary != address(0));\r\n        require(weiAmount != 0);\r\n        require(weiAmount < safetyLimit);\r\n    }\r\n\r\n    function setManager(address newManager) public restricted {\r\n        require(msg.sender == manager);\r\n        require(newManager != address(0));\r\n        manager=newManager;\r\n    }\r\n    \r\n    function updateRate(uint256 newEtherEuroRate) public restricted{\r\n        require(newEtherEuroRate > 0);\r\n        etherEuroRate=newEtherEuroRate;\r\n    }\r\n    \r\n    /**\r\n     * set the limiti in ether\r\n    */\r\n    function setSafeLimit(uint256 limitEther) public restricted{\r\n        require(limitEther>0);\r\n        safetyLimit=limitEther.mul(10**18);\r\n    }\r\n    \r\n    function getNumberOfWeiTokenPerWei(uint256 weiToConvert) public view returns(uint256){\r\n        require(weiToConvert > 0);\r\n        require(weiToConvert < safetyLimit);\r\n        return weiToConvert.mul(etherEuroRate.div(2));\r\n    }\r\n    \r\n    function setMinWeiValue(uint256 minWei) public restricted{\r\n        require(minWei > 10);\r\n        minWeiValue = minWei;\r\n    }\r\n    \r\n    function _forwardFunds() internal {\r\n        returnWallet.transfer(msg.value);\r\n    }\r\n    \r\n    function setReturnWallet(address payable _wallet) public restricted{\r\n        require(_wallet != address(0));\r\n        returnWallet=_wallet;\r\n    }\r\n    \r\n    function reclaimToken() public restricted{\r\n        require(manager!=address(0));\r\n        _token.transfer(manager,_token.balanceOf(address(this)));\r\n    }\r\n    \r\n    function getContractBalance() public view returns(uint256){\r\n        return (_token.balanceOf(address(this)));\r\n    }\r\n    \r\n    function getCurrentTokenContract() public view returns(address){\r\n        return address(_token);\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"minWeiValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"setReturnWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"limitEther\",\"type\":\"uint256\"}],\"name\":\"setSafeLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentTokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newEtherEuroRate\",\"type\":\"uint256\"}],\"name\":\"updateRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"returnWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherEuroRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minWei\",\"type\":\"uint256\"}],\"name\":\"setMinWeiValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"weiToConvert\",\"type\":\"uint256\"}],\"name\":\"getNumberOfWeiTokenPerWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"safetyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"rate\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"contractManager\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000005a000000000000000000000000aaea43180def2bc02ebe26e8b4c546c9a7521d2e000000000000000000000000e1d2b5fd93ab206c7675cb69c85da028234e8d86000000000000000000000000dd65751c0144ee1cad6725c9c98fcb0a8c768a82","Library":"","SwarmSource":"bzzr://6918ffd5afaff3dfbf276643c457d195751c5d9c32914ba7ee099cca9483dc40"}]}