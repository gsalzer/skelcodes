{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.25 <0.6.0;\npragma experimental ABIEncoderV2;\n\n\ncontract Modifiable {\n    \n    \n    \n    modifier notNullAddress(address _address) {\n        require(_address != address(0));\n        _;\n    }\n\n    modifier notThisAddress(address _address) {\n        require(_address != address(this));\n        _;\n    }\n\n    modifier notNullOrThisAddress(address _address) {\n        require(_address != address(0));\n        require(_address != address(this));\n        _;\n    }\n\n    modifier notSameAddresses(address _address1, address _address2) {\n        if (_address1 != _address2)\n            _;\n    }\n}\n\ncontract SelfDestructible {\n    \n    \n    \n    bool public selfDestructionDisabled;\n\n    \n    \n    \n    event SelfDestructionDisabledEvent(address wallet);\n    event TriggerSelfDestructionEvent(address wallet);\n\n    \n    \n    \n    \n    function destructor()\n    public\n    view\n    returns (address);\n\n    \n    \n    function disableSelfDestruction()\n    public\n    {\n        \n        require(destructor() == msg.sender);\n\n        \n        selfDestructionDisabled = true;\n\n        \n        emit SelfDestructionDisabledEvent(msg.sender);\n    }\n\n    \n    function triggerSelfDestruction()\n    public\n    {\n        \n        require(destructor() == msg.sender);\n\n        \n        require(!selfDestructionDisabled);\n\n        \n        emit TriggerSelfDestructionEvent(msg.sender);\n\n        \n        selfdestruct(msg.sender);\n    }\n}\n\ncontract Ownable is Modifiable, SelfDestructible {\n    \n    \n    \n    address public deployer;\n    address public operator;\n\n    \n    \n    \n    event SetDeployerEvent(address oldDeployer, address newDeployer);\n    event SetOperatorEvent(address oldOperator, address newOperator);\n\n    \n    \n    \n    constructor(address _deployer) internal notNullOrThisAddress(_deployer) {\n        deployer = _deployer;\n        operator = _deployer;\n    }\n\n    \n    \n    \n    \n    function destructor()\n    public\n    view\n    returns (address)\n    {\n        return deployer;\n    }\n\n    \n    \n    function setDeployer(address newDeployer)\n    public\n    onlyDeployer\n    notNullOrThisAddress(newDeployer)\n    {\n        if (newDeployer != deployer) {\n            \n            address oldDeployer = deployer;\n            deployer = newDeployer;\n\n            \n            emit SetDeployerEvent(oldDeployer, newDeployer);\n        }\n    }\n\n    \n    \n    function setOperator(address newOperator)\n    public\n    onlyOperator\n    notNullOrThisAddress(newOperator)\n    {\n        if (newOperator != operator) {\n            \n            address oldOperator = operator;\n            operator = newOperator;\n\n            \n            emit SetOperatorEvent(oldOperator, newOperator);\n        }\n    }\n\n    \n    \n    function isDeployer()\n    internal\n    view\n    returns (bool)\n    {\n        return msg.sender == deployer;\n    }\n\n    \n    \n    function isOperator()\n    internal\n    view\n    returns (bool)\n    {\n        return msg.sender == operator;\n    }\n\n    \n    \n    \n    function isDeployerOrOperator()\n    internal\n    view\n    returns (bool)\n    {\n        return isDeployer() || isOperator();\n    }\n\n    \n    \n    modifier onlyDeployer() {\n        require(isDeployer());\n        _;\n    }\n\n    modifier notDeployer() {\n        require(!isDeployer());\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(isOperator());\n        _;\n    }\n\n    modifier notOperator() {\n        require(!isOperator());\n        _;\n    }\n\n    modifier onlyDeployerOrOperator() {\n        require(isDeployerOrOperator());\n        _;\n    }\n\n    modifier notDeployerOrOperator() {\n        require(!isDeployerOrOperator());\n        _;\n    }\n}\n\ncontract Servable is Ownable {\n    \n    \n    \n    struct ServiceInfo {\n        bool registered;\n        uint256 activationTimestamp;\n        mapping(bytes32 => bool) actionsEnabledMap;\n        bytes32[] actionsList;\n    }\n\n    \n    \n    \n    mapping(address => ServiceInfo) internal registeredServicesMap;\n    uint256 public serviceActivationTimeout;\n\n    \n    \n    \n    event ServiceActivationTimeoutEvent(uint256 timeoutInSeconds);\n    event RegisterServiceEvent(address service);\n    event RegisterServiceDeferredEvent(address service, uint256 timeout);\n    event DeregisterServiceEvent(address service);\n    event EnableServiceActionEvent(address service, string action);\n    event DisableServiceActionEvent(address service, string action);\n\n    \n    \n    \n    \n    \n    function setServiceActivationTimeout(uint256 timeoutInSeconds)\n    public\n    onlyDeployer\n    {\n        serviceActivationTimeout = timeoutInSeconds;\n\n        \n        emit ServiceActivationTimeoutEvent(timeoutInSeconds);\n    }\n\n    \n    \n    function registerService(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        _registerService(service, 0);\n\n        \n        emit RegisterServiceEvent(service);\n    }\n\n    \n    \n    function registerServiceDeferred(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        _registerService(service, serviceActivationTimeout);\n\n        \n        emit RegisterServiceDeferredEvent(service, serviceActivationTimeout);\n    }\n\n    \n    \n    function deregisterService(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        registeredServicesMap[service].registered = false;\n\n        \n        emit DeregisterServiceEvent(service);\n    }\n\n    \n    \n    \n    function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        \n        emit EnableServiceActionEvent(service, action);\n    }\n\n    \n    \n    \n    function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        \n        emit DisableServiceActionEvent(service, action);\n    }\n\n    \n    \n    \n    function isRegisteredService(address service)\n    public\n    view\n    returns (bool)\n    {\n        return registeredServicesMap[service].registered;\n    }\n\n    \n    \n    \n    function isRegisteredActiveService(address service)\n    public\n    view\n    returns (bool)\n    {\n        return isRegisteredService(service) && block.timestamp >= registeredServicesMap[service].activationTimestamp;\n    }\n\n    \n    \n    \n    function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }\n\n    \n    \n    \n    function hashString(string memory _string)\n    internal\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_string));\n    }\n\n    \n    \n    \n    function _registerService(address service, uint256 timeout)\n    private\n    {\n        if (!registeredServicesMap[service].registered) {\n            registeredServicesMap[service].registered = true;\n            registeredServicesMap[service].activationTimestamp = block.timestamp + timeout;\n        }\n    }\n\n    \n    \n    \n    modifier onlyActiveService() {\n        require(isRegisteredActiveService(msg.sender));\n        _;\n    }\n\n    modifier onlyEnabledServiceAction(string memory action) {\n        require(isEnabledServiceAction(msg.sender, action));\n        _;\n    }\n}\n\nlibrary SafeMathIntLib {\n    int256 constant INT256_MIN = int256((uint256(1) << 255));\n    int256 constant INT256_MAX = int256(~((uint256(1) << 255)));\n\n    \n    \n    \n    function div(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a != INT256_MIN || b != - 1);\n        return a / b;\n    }\n\n    function mul(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a != - 1 || b != INT256_MIN);\n        \n        require(b != - 1 || a != INT256_MIN);\n        \n        int256 c = a * b;\n        require((b == 0) || (c / b == a));\n        return c;\n    }\n\n    function sub(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require((b >= 0 && a - b <= a) || (b < 0 && a - b > a));\n        return a - b;\n    }\n\n    function add(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\n        return c;\n    }\n\n    \n    \n    \n    function div_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b > 0);\n        return a / b;\n    }\n\n    function mul_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0);\n        int256 c = a * b;\n        require(a == 0 || c / a == b);\n        require(c >= 0);\n        return c;\n    }\n\n    function sub_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0 && b <= a);\n        return a - b;\n    }\n\n    function add_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0);\n        int256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    \n    \n    \n    function abs(int256 a)\n    public\n    pure\n    returns (int256)\n    {\n        return a < 0 ? neg(a) : a;\n    }\n\n    function neg(int256 a)\n    public\n    pure\n    returns (int256)\n    {\n        return mul(a, - 1);\n    }\n\n    function toNonZeroInt256(uint256 a)\n    public\n    pure\n    returns (int256)\n    {\n        require(a > 0 && a < (uint256(1) << 255));\n        return int256(a);\n    }\n\n    function toInt256(uint256 a)\n    public\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && a < (uint256(1) << 255));\n        return int256(a);\n    }\n\n    function toUInt256(int256 a)\n    public\n    pure\n    returns (uint256)\n    {\n        require(a >= 0);\n        return uint256(a);\n    }\n\n    function isNonZeroPositiveInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a > 0);\n    }\n\n    function isPositiveInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a >= 0);\n    }\n\n    function isNonZeroNegativeInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a < 0);\n    }\n\n    function isNegativeInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a <= 0);\n    }\n\n    \n    \n    \n    function clamp(int256 a, int256 min, int256 max)\n    public\n    pure\n    returns (int256)\n    {\n        if (a < min)\n            return min;\n        return (a > max) ? max : a;\n    }\n\n    function clampMin(int256 a, int256 min)\n    public\n    pure\n    returns (int256)\n    {\n        return (a < min) ? min : a;\n    }\n\n    function clampMax(int256 a, int256 max)\n    public\n    pure\n    returns (int256)\n    {\n        return (a > max) ? max : a;\n    }\n}\n\nlibrary BlockNumbUintsLib {\n    \n    \n    \n    struct Entry {\n        uint256 blockNumber;\n        uint256 value;\n    }\n\n    struct BlockNumbUints {\n        Entry[] entries;\n    }\n\n    \n    \n    \n    function currentValue(BlockNumbUints storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return valueAt(self, block.number);\n    }\n\n    function currentEntry(BlockNumbUints storage self)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return entryAt(self, block.number);\n    }\n\n    function valueAt(BlockNumbUints storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        return entryAt(self, _blockNumber).value;\n    }\n\n    function entryAt(BlockNumbUints storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\n    }\n\n    function addEntry(BlockNumbUints storage self, uint256 blockNumber, uint256 value)\n    internal\n    {\n        require(\n            0 == self.entries.length ||\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\n            \"Later entry found [BlockNumbUintsLib.sol:62]\"\n        );\n\n        self.entries.push(Entry(blockNumber, value));\n    }\n\n    function count(BlockNumbUints storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entries.length;\n    }\n\n    function entries(BlockNumbUints storage self)\n    internal\n    view\n    returns (Entry[] memory)\n    {\n        return self.entries;\n    }\n\n    function indexByBlockNumber(BlockNumbUints storage self, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entries.length, \"No entries found [BlockNumbUintsLib.sol:92]\");\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\n            if (blockNumber >= self.entries[i].blockNumber)\n                return i;\n        revert();\n    }\n}\n\nlibrary BlockNumbIntsLib {\n    \n    \n    \n    struct Entry {\n        uint256 blockNumber;\n        int256 value;\n    }\n\n    struct BlockNumbInts {\n        Entry[] entries;\n    }\n\n    \n    \n    \n    function currentValue(BlockNumbInts storage self)\n    internal\n    view\n    returns (int256)\n    {\n        return valueAt(self, block.number);\n    }\n\n    function currentEntry(BlockNumbInts storage self)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return entryAt(self, block.number);\n    }\n\n    function valueAt(BlockNumbInts storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (int256)\n    {\n        return entryAt(self, _blockNumber).value;\n    }\n\n    function entryAt(BlockNumbInts storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\n    }\n\n    function addEntry(BlockNumbInts storage self, uint256 blockNumber, int256 value)\n    internal\n    {\n        require(\n            0 == self.entries.length ||\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\n            \"Later entry found [BlockNumbIntsLib.sol:62]\"\n        );\n\n        self.entries.push(Entry(blockNumber, value));\n    }\n\n    function count(BlockNumbInts storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entries.length;\n    }\n\n    function entries(BlockNumbInts storage self)\n    internal\n    view\n    returns (Entry[] memory)\n    {\n        return self.entries;\n    }\n\n    function indexByBlockNumber(BlockNumbInts storage self, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entries.length, \"No entries found [BlockNumbIntsLib.sol:92]\");\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\n            if (blockNumber >= self.entries[i].blockNumber)\n                return i;\n        revert();\n    }\n}\n\nlibrary ConstantsLib {\n    \n    function PARTS_PER()\n    public\n    pure\n    returns (int256)\n    {\n        return 1e18;\n    }\n}\n\nlibrary BlockNumbDisdIntsLib {\n    using SafeMathIntLib for int256;\n\n    \n    \n    \n    struct Discount {\n        int256 tier;\n        int256 value;\n    }\n\n    struct Entry {\n        uint256 blockNumber;\n        int256 nominal;\n        Discount[] discounts;\n    }\n\n    struct BlockNumbDisdInts {\n        Entry[] entries;\n    }\n\n    \n    \n    \n    function currentNominalValue(BlockNumbDisdInts storage self)\n    internal\n    view\n    returns (int256)\n    {\n        return nominalValueAt(self, block.number);\n    }\n\n    function currentDiscountedValue(BlockNumbDisdInts storage self, int256 tier)\n    internal\n    view\n    returns (int256)\n    {\n        return discountedValueAt(self, block.number, tier);\n    }\n\n    function currentEntry(BlockNumbDisdInts storage self)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return entryAt(self, block.number);\n    }\n\n    function nominalValueAt(BlockNumbDisdInts storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (int256)\n    {\n        return entryAt(self, _blockNumber).nominal;\n    }\n\n    function discountedValueAt(BlockNumbDisdInts storage self, uint256 _blockNumber, int256 tier)\n    internal\n    view\n    returns (int256)\n    {\n        Entry memory entry = entryAt(self, _blockNumber);\n        if (0 < entry.discounts.length) {\n            uint256 index = indexByTier(entry.discounts, tier);\n            if (0 < index)\n                return entry.nominal.mul(\n                    ConstantsLib.PARTS_PER().sub(entry.discounts[index - 1].value)\n                ).div(\n                    ConstantsLib.PARTS_PER()\n                );\n            else\n                return entry.nominal;\n        } else\n            return entry.nominal;\n    }\n\n    function entryAt(BlockNumbDisdInts storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\n    }\n\n    function addNominalEntry(BlockNumbDisdInts storage self, uint256 blockNumber, int256 nominal)\n    internal\n    {\n        require(\n            0 == self.entries.length ||\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\n            \"Later entry found [BlockNumbDisdIntsLib.sol:101]\"\n        );\n\n        self.entries.length++;\n        Entry storage entry = self.entries[self.entries.length - 1];\n\n        entry.blockNumber = blockNumber;\n        entry.nominal = nominal;\n    }\n\n    function addDiscountedEntry(BlockNumbDisdInts storage self, uint256 blockNumber, int256 nominal,\n        int256[] memory discountTiers, int256[] memory discountValues)\n    internal\n    {\n        require(discountTiers.length == discountValues.length, \"Parameter array lengths mismatch [BlockNumbDisdIntsLib.sol:118]\");\n\n        addNominalEntry(self, blockNumber, nominal);\n\n        Entry storage entry = self.entries[self.entries.length - 1];\n        for (uint256 i = 0; i < discountTiers.length; i++)\n            entry.discounts.push(Discount(discountTiers[i], discountValues[i]));\n    }\n\n    function count(BlockNumbDisdInts storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entries.length;\n    }\n\n    function entries(BlockNumbDisdInts storage self)\n    internal\n    view\n    returns (Entry[] memory)\n    {\n        return self.entries;\n    }\n\n    function indexByBlockNumber(BlockNumbDisdInts storage self, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entries.length, \"No entries found [BlockNumbDisdIntsLib.sol:148]\");\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\n            if (blockNumber >= self.entries[i].blockNumber)\n                return i;\n        revert();\n    }\n\n    \n    function indexByTier(Discount[] memory discounts, int256 tier)\n    internal\n    pure\n    returns (uint256)\n    {\n        require(0 < discounts.length, \"No discounts found [BlockNumbDisdIntsLib.sol:161]\");\n        for (uint256 i = discounts.length; i > 0; i--)\n            if (tier >= discounts[i - 1].tier)\n                return i;\n        return 0;\n    }\n}\n\nlibrary MonetaryTypesLib {\n    \n    \n    \n    struct Currency {\n        address ct;\n        uint256 id;\n    }\n\n    struct Figure {\n        int256 amount;\n        Currency currency;\n    }\n\n    struct NoncedAmount {\n        uint256 nonce;\n        int256 amount;\n    }\n}\n\nlibrary BlockNumbReferenceCurrenciesLib {\n    \n    \n    \n    struct Entry {\n        uint256 blockNumber;\n        MonetaryTypesLib.Currency currency;\n    }\n\n    struct BlockNumbReferenceCurrencies {\n        mapping(address => mapping(uint256 => Entry[])) entriesByCurrency;\n    }\n\n    \n    \n    \n    function currentCurrency(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\n    internal\n    view\n    returns (MonetaryTypesLib.Currency storage)\n    {\n        return currencyAt(self, referenceCurrency, block.number);\n    }\n\n    function currentEntry(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\n    internal\n    view\n    returns (Entry storage)\n    {\n        return entryAt(self, referenceCurrency, block.number);\n    }\n\n    function currencyAt(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency,\n        uint256 _blockNumber)\n    internal\n    view\n    returns (MonetaryTypesLib.Currency storage)\n    {\n        return entryAt(self, referenceCurrency, _blockNumber).currency;\n    }\n\n    function entryAt(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency,\n        uint256 _blockNumber)\n    internal\n    view\n    returns (Entry storage)\n    {\n        return self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id][indexByBlockNumber(self, referenceCurrency, _blockNumber)];\n    }\n\n    function addEntry(BlockNumbReferenceCurrencies storage self, uint256 blockNumber,\n        MonetaryTypesLib.Currency memory referenceCurrency, MonetaryTypesLib.Currency memory currency)\n    internal\n    {\n        require(\n            0 == self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length ||\n        blockNumber > self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id][self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length - 1].blockNumber,\n            \"Later entry found for currency [BlockNumbReferenceCurrenciesLib.sol:67]\"\n        );\n\n        self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].push(Entry(blockNumber, currency));\n    }\n\n    function count(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length;\n    }\n\n    function entriesByCurrency(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\n    internal\n    view\n    returns (Entry[] storage)\n    {\n        return self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id];\n    }\n\n    function indexByBlockNumber(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length, \"No entries found for currency [BlockNumbReferenceCurrenciesLib.sol:97]\");\n        for (uint256 i = self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length - 1; i >= 0; i--)\n            if (blockNumber >= self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id][i].blockNumber)\n                return i;\n        revert();\n    }\n}\n\nlibrary BlockNumbFiguresLib {\n    \n    \n    \n    struct Entry {\n        uint256 blockNumber;\n        MonetaryTypesLib.Figure value;\n    }\n\n    struct BlockNumbFigures {\n        Entry[] entries;\n    }\n\n    \n    \n    \n    function currentValue(BlockNumbFigures storage self)\n    internal\n    view\n    returns (MonetaryTypesLib.Figure storage)\n    {\n        return valueAt(self, block.number);\n    }\n\n    function currentEntry(BlockNumbFigures storage self)\n    internal\n    view\n    returns (Entry storage)\n    {\n        return entryAt(self, block.number);\n    }\n\n    function valueAt(BlockNumbFigures storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (MonetaryTypesLib.Figure storage)\n    {\n        return entryAt(self, _blockNumber).value;\n    }\n\n    function entryAt(BlockNumbFigures storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (Entry storage)\n    {\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\n    }\n\n    function addEntry(BlockNumbFigures storage self, uint256 blockNumber, MonetaryTypesLib.Figure memory value)\n    internal\n    {\n        require(\n            0 == self.entries.length ||\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\n            \"Later entry found [BlockNumbFiguresLib.sol:65]\"\n        );\n\n        self.entries.push(Entry(blockNumber, value));\n    }\n\n    function count(BlockNumbFigures storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entries.length;\n    }\n\n    function entries(BlockNumbFigures storage self)\n    internal\n    view\n    returns (Entry[] storage)\n    {\n        return self.entries;\n    }\n\n    function indexByBlockNumber(BlockNumbFigures storage self, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entries.length, \"No entries found [BlockNumbFiguresLib.sol:95]\");\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\n            if (blockNumber >= self.entries[i].blockNumber)\n                return i;\n        revert();\n    }\n}\n\ncontract Configuration is Modifiable, Ownable, Servable {\n    using SafeMathIntLib for int256;\n    using BlockNumbUintsLib for BlockNumbUintsLib.BlockNumbUints;\n    using BlockNumbIntsLib for BlockNumbIntsLib.BlockNumbInts;\n    using BlockNumbDisdIntsLib for BlockNumbDisdIntsLib.BlockNumbDisdInts;\n    using BlockNumbReferenceCurrenciesLib for BlockNumbReferenceCurrenciesLib.BlockNumbReferenceCurrencies;\n    using BlockNumbFiguresLib for BlockNumbFiguresLib.BlockNumbFigures;\n\n    \n    \n    \n    string constant public OPERATIONAL_MODE_ACTION = \"operational_mode\";\n\n    \n    \n    \n    enum OperationalMode {Normal, Exit}\n\n    \n    \n    \n    OperationalMode public operationalMode = OperationalMode.Normal;\n\n    BlockNumbUintsLib.BlockNumbUints private updateDelayBlocksByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private confirmationBlocksByBlockNumber;\n\n    BlockNumbDisdIntsLib.BlockNumbDisdInts private tradeMakerFeeByBlockNumber;\n    BlockNumbDisdIntsLib.BlockNumbDisdInts private tradeTakerFeeByBlockNumber;\n    BlockNumbDisdIntsLib.BlockNumbDisdInts private paymentFeeByBlockNumber;\n    mapping(address => mapping(uint256 => BlockNumbDisdIntsLib.BlockNumbDisdInts)) private currencyPaymentFeeByBlockNumber;\n\n    BlockNumbIntsLib.BlockNumbInts private tradeMakerMinimumFeeByBlockNumber;\n    BlockNumbIntsLib.BlockNumbInts private tradeTakerMinimumFeeByBlockNumber;\n    BlockNumbIntsLib.BlockNumbInts private paymentMinimumFeeByBlockNumber;\n    mapping(address => mapping(uint256 => BlockNumbIntsLib.BlockNumbInts)) private currencyPaymentMinimumFeeByBlockNumber;\n\n    BlockNumbReferenceCurrenciesLib.BlockNumbReferenceCurrencies private feeCurrencyByCurrencyBlockNumber;\n\n    BlockNumbUintsLib.BlockNumbUints private walletLockTimeoutByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private cancelOrderChallengeTimeoutByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private settlementChallengeTimeoutByBlockNumber;\n\n    BlockNumbUintsLib.BlockNumbUints private fraudStakeFractionByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private walletSettlementStakeFractionByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private operatorSettlementStakeFractionByBlockNumber;\n\n    BlockNumbFiguresLib.BlockNumbFigures private operatorSettlementStakeByBlockNumber;\n\n    uint256 public earliestSettlementBlockNumber;\n    bool public earliestSettlementBlockNumberUpdateDisabled;\n\n    \n    \n    \n    event SetOperationalModeExitEvent();\n    event SetUpdateDelayBlocksEvent(uint256 fromBlockNumber, uint256 newBlocks);\n    event SetConfirmationBlocksEvent(uint256 fromBlockNumber, uint256 newBlocks);\n    event SetTradeMakerFeeEvent(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues);\n    event SetTradeTakerFeeEvent(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues);\n    event SetPaymentFeeEvent(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues);\n    event SetCurrencyPaymentFeeEvent(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\n        int256[] discountTiers, int256[] discountValues);\n    event SetTradeMakerMinimumFeeEvent(uint256 fromBlockNumber, int256 nominal);\n    event SetTradeTakerMinimumFeeEvent(uint256 fromBlockNumber, int256 nominal);\n    event SetPaymentMinimumFeeEvent(uint256 fromBlockNumber, int256 nominal);\n    event SetCurrencyPaymentMinimumFeeEvent(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal);\n    event SetFeeCurrencyEvent(uint256 fromBlockNumber, address referenceCurrencyCt, uint256 referenceCurrencyId,\n        address feeCurrencyCt, uint256 feeCurrencyId);\n    event SetWalletLockTimeoutEvent(uint256 fromBlockNumber, uint256 timeoutInSeconds);\n    event SetCancelOrderChallengeTimeoutEvent(uint256 fromBlockNumber, uint256 timeoutInSeconds);\n    event SetSettlementChallengeTimeoutEvent(uint256 fromBlockNumber, uint256 timeoutInSeconds);\n    event SetWalletSettlementStakeFractionEvent(uint256 fromBlockNumber, uint256 stakeFraction);\n    event SetOperatorSettlementStakeFractionEvent(uint256 fromBlockNumber, uint256 stakeFraction);\n    event SetOperatorSettlementStakeEvent(uint256 fromBlockNumber, int256 stakeAmount, address stakeCurrencyCt,\n        uint256 stakeCurrencyId);\n    event SetFraudStakeFractionEvent(uint256 fromBlockNumber, uint256 stakeFraction);\n    event SetEarliestSettlementBlockNumberEvent(uint256 earliestSettlementBlockNumber);\n    event DisableEarliestSettlementBlockNumberUpdateEvent();\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n        updateDelayBlocksByBlockNumber.addEntry(block.number, 0);\n    }\n\n    \n    \n    \n    \n    \n    function setOperationalModeExit()\n    public\n    onlyEnabledServiceAction(OPERATIONAL_MODE_ACTION)\n    {\n        operationalMode = OperationalMode.Exit;\n        emit SetOperationalModeExitEvent();\n    }\n\n    \n    function isOperationalModeNormal()\n    public\n    view\n    returns (bool)\n    {\n        return OperationalMode.Normal == operationalMode;\n    }\n\n    \n    function isOperationalModeExit()\n    public\n    view\n    returns (bool)\n    {\n        return OperationalMode.Exit == operationalMode;\n    }\n\n    \n    \n    function updateDelayBlocks()\n    public\n    view\n    returns (uint256)\n    {\n        return updateDelayBlocksByBlockNumber.currentValue();\n    }\n\n    \n    \n    function updateDelayBlocksCount()\n    public\n    view\n    returns (uint256)\n    {\n        return updateDelayBlocksByBlockNumber.count();\n    }\n\n    \n    \n    \n    function setUpdateDelayBlocks(uint256 fromBlockNumber, uint256 newUpdateDelayBlocks)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        updateDelayBlocksByBlockNumber.addEntry(fromBlockNumber, newUpdateDelayBlocks);\n        emit SetUpdateDelayBlocksEvent(fromBlockNumber, newUpdateDelayBlocks);\n    }\n\n    \n    \n    function confirmationBlocks()\n    public\n    view\n    returns (uint256)\n    {\n        return confirmationBlocksByBlockNumber.currentValue();\n    }\n\n    \n    \n    function confirmationBlocksCount()\n    public\n    view\n    returns (uint256)\n    {\n        return confirmationBlocksByBlockNumber.count();\n    }\n\n    \n    \n    \n    function setConfirmationBlocks(uint256 fromBlockNumber, uint256 newConfirmationBlocks)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        confirmationBlocksByBlockNumber.addEntry(fromBlockNumber, newConfirmationBlocks);\n        emit SetConfirmationBlocksEvent(fromBlockNumber, newConfirmationBlocks);\n    }\n\n    \n    function tradeMakerFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return tradeMakerFeeByBlockNumber.count();\n    }\n\n    \n    \n    \n    function tradeMakerFee(uint256 blockNumber, int256 discountTier)\n    public\n    view\n    returns (int256)\n    {\n        return tradeMakerFeeByBlockNumber.discountedValueAt(blockNumber, discountTier);\n    }\n\n    \n    \n    \n    \n    \n    function setTradeMakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeMakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeMakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }\n\n    \n    function tradeTakerFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return tradeTakerFeeByBlockNumber.count();\n    }\n\n    \n    \n    \n    function tradeTakerFee(uint256 blockNumber, int256 discountTier)\n    public\n    view\n    returns (int256)\n    {\n        return tradeTakerFeeByBlockNumber.discountedValueAt(blockNumber, discountTier);\n    }\n\n    \n    \n    \n    \n    \n    function setTradeTakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeTakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeTakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }\n\n    \n    function paymentFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return paymentFeeByBlockNumber.count();\n    }\n\n    \n    \n    \n    function paymentFee(uint256 blockNumber, int256 discountTier)\n    public\n    view\n    returns (int256)\n    {\n        return paymentFeeByBlockNumber.discountedValueAt(blockNumber, discountTier);\n    }\n\n    \n    \n    \n    \n    \n    function setPaymentFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        paymentFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetPaymentFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }\n\n    \n    \n    \n    function currencyPaymentFeesCount(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return currencyPaymentFeeByBlockNumber[currencyCt][currencyId].count();\n    }\n\n    \n    \n    \n    \n    \n    \n    function currencyPaymentFee(uint256 blockNumber, address currencyCt, uint256 currencyId, int256 discountTier)\n    public\n    view\n    returns (int256)\n    {\n        if (0 < currencyPaymentFeeByBlockNumber[currencyCt][currencyId].count())\n            return currencyPaymentFeeByBlockNumber[currencyCt][currencyId].discountedValueAt(\n                blockNumber, discountTier\n            );\n        else\n            return paymentFee(blockNumber, discountTier);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function setCurrencyPaymentFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\n        int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        currencyPaymentFeeByBlockNumber[currencyCt][currencyId].addDiscountedEntry(\n            fromBlockNumber, nominal, discountTiers, discountValues\n        );\n        emit SetCurrencyPaymentFeeEvent(\n            fromBlockNumber, currencyCt, currencyId, nominal, discountTiers, discountValues\n        );\n    }\n\n    \n    function tradeMakerMinimumFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return tradeMakerMinimumFeeByBlockNumber.count();\n    }\n\n    \n    \n    function tradeMakerMinimumFee(uint256 blockNumber)\n    public\n    view\n    returns (int256)\n    {\n        return tradeMakerMinimumFeeByBlockNumber.valueAt(blockNumber);\n    }\n\n    \n    \n    \n    function setTradeMakerMinimumFee(uint256 fromBlockNumber, int256 nominal)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeMakerMinimumFeeByBlockNumber.addEntry(fromBlockNumber, nominal);\n        emit SetTradeMakerMinimumFeeEvent(fromBlockNumber, nominal);\n    }\n\n    \n    function tradeTakerMinimumFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return tradeTakerMinimumFeeByBlockNumber.count();\n    }\n\n    \n    \n    function tradeTakerMinimumFee(uint256 blockNumber)\n    public\n    view\n    returns (int256)\n    {\n        return tradeTakerMinimumFeeByBlockNumber.valueAt(blockNumber);\n    }\n\n    \n    \n    \n    function setTradeTakerMinimumFee(uint256 fromBlockNumber, int256 nominal)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeTakerMinimumFeeByBlockNumber.addEntry(fromBlockNumber, nominal);\n        emit SetTradeTakerMinimumFeeEvent(fromBlockNumber, nominal);\n    }\n\n    \n    function paymentMinimumFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return paymentMinimumFeeByBlockNumber.count();\n    }\n\n    \n    \n    function paymentMinimumFee(uint256 blockNumber)\n    public\n    view\n    returns (int256)\n    {\n        return paymentMinimumFeeByBlockNumber.valueAt(blockNumber);\n    }\n\n    \n    \n    \n    function setPaymentMinimumFee(uint256 fromBlockNumber, int256 nominal)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        paymentMinimumFeeByBlockNumber.addEntry(fromBlockNumber, nominal);\n        emit SetPaymentMinimumFeeEvent(fromBlockNumber, nominal);\n    }\n\n    \n    \n    \n    function currencyPaymentMinimumFeesCount(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].count();\n    }\n\n    \n    \n    \n    \n    function currencyPaymentMinimumFee(uint256 blockNumber, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        if (0 < currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].count())\n            return currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].valueAt(blockNumber);\n        else\n            return paymentMinimumFee(blockNumber);\n    }\n\n    \n    \n    \n    \n    \n    function setCurrencyPaymentMinimumFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].addEntry(fromBlockNumber, nominal);\n        emit SetCurrencyPaymentMinimumFeeEvent(fromBlockNumber, currencyCt, currencyId, nominal);\n    }\n\n    \n    \n    \n    function feeCurrenciesCount(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return feeCurrencyByCurrencyBlockNumber.count(MonetaryTypesLib.Currency(currencyCt, currencyId));\n    }\n\n    \n    \n    \n    \n    function feeCurrency(uint256 blockNumber, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (address ct, uint256 id)\n    {\n        MonetaryTypesLib.Currency storage _feeCurrency = feeCurrencyByCurrencyBlockNumber.currencyAt(\n            MonetaryTypesLib.Currency(currencyCt, currencyId), blockNumber\n        );\n        ct = _feeCurrency.ct;\n        id = _feeCurrency.id;\n    }\n\n    \n    \n    \n    \n    \n    \n    function setFeeCurrency(uint256 fromBlockNumber, address referenceCurrencyCt, uint256 referenceCurrencyId,\n        address feeCurrencyCt, uint256 feeCurrencyId)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        feeCurrencyByCurrencyBlockNumber.addEntry(\n            fromBlockNumber,\n            MonetaryTypesLib.Currency(referenceCurrencyCt, referenceCurrencyId),\n            MonetaryTypesLib.Currency(feeCurrencyCt, feeCurrencyId)\n        );\n        emit SetFeeCurrencyEvent(fromBlockNumber, referenceCurrencyCt, referenceCurrencyId,\n            feeCurrencyCt, feeCurrencyId);\n    }\n\n    \n    \n    function walletLockTimeout()\n    public\n    view\n    returns (uint256)\n    {\n        return walletLockTimeoutByBlockNumber.currentValue();\n    }\n\n    \n    \n    \n    function setWalletLockTimeout(uint256 fromBlockNumber, uint256 timeoutInSeconds)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        walletLockTimeoutByBlockNumber.addEntry(fromBlockNumber, timeoutInSeconds);\n        emit SetWalletLockTimeoutEvent(fromBlockNumber, timeoutInSeconds);\n    }\n\n    \n    \n    function cancelOrderChallengeTimeout()\n    public\n    view\n    returns (uint256)\n    {\n        return cancelOrderChallengeTimeoutByBlockNumber.currentValue();\n    }\n\n    \n    \n    \n    function setCancelOrderChallengeTimeout(uint256 fromBlockNumber, uint256 timeoutInSeconds)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        cancelOrderChallengeTimeoutByBlockNumber.addEntry(fromBlockNumber, timeoutInSeconds);\n        emit SetCancelOrderChallengeTimeoutEvent(fromBlockNumber, timeoutInSeconds);\n    }\n\n    \n    \n    function settlementChallengeTimeout()\n    public\n    view\n    returns (uint256)\n    {\n        return settlementChallengeTimeoutByBlockNumber.currentValue();\n    }\n\n    \n    \n    \n    function setSettlementChallengeTimeout(uint256 fromBlockNumber, uint256 timeoutInSeconds)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        settlementChallengeTimeoutByBlockNumber.addEntry(fromBlockNumber, timeoutInSeconds);\n        emit SetSettlementChallengeTimeoutEvent(fromBlockNumber, timeoutInSeconds);\n    }\n\n    \n    \n    function fraudStakeFraction()\n    public\n    view\n    returns (uint256)\n    {\n        return fraudStakeFractionByBlockNumber.currentValue();\n    }\n\n    \n    \n    \n    \n    function setFraudStakeFraction(uint256 fromBlockNumber, uint256 stakeFraction)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        fraudStakeFractionByBlockNumber.addEntry(fromBlockNumber, stakeFraction);\n        emit SetFraudStakeFractionEvent(fromBlockNumber, stakeFraction);\n    }\n\n    \n    \n    function walletSettlementStakeFraction()\n    public\n    view\n    returns (uint256)\n    {\n        return walletSettlementStakeFractionByBlockNumber.currentValue();\n    }\n\n    \n    \n    \n    \n    function setWalletSettlementStakeFraction(uint256 fromBlockNumber, uint256 stakeFraction)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        walletSettlementStakeFractionByBlockNumber.addEntry(fromBlockNumber, stakeFraction);\n        emit SetWalletSettlementStakeFractionEvent(fromBlockNumber, stakeFraction);\n    }\n\n    \n    \n    function operatorSettlementStakeFraction()\n    public\n    view\n    returns (uint256)\n    {\n        return operatorSettlementStakeFractionByBlockNumber.currentValue();\n    }\n\n    \n    \n    \n    \n    function setOperatorSettlementStakeFraction(uint256 fromBlockNumber, uint256 stakeFraction)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        operatorSettlementStakeFractionByBlockNumber.addEntry(fromBlockNumber, stakeFraction);\n        emit SetOperatorSettlementStakeFractionEvent(fromBlockNumber, stakeFraction);\n    }\n\n    \n    \n    function operatorSettlementStake()\n    public\n    view\n    returns (int256 amount, address currencyCt, uint256 currencyId)\n    {\n        MonetaryTypesLib.Figure storage stake = operatorSettlementStakeByBlockNumber.currentValue();\n        amount = stake.amount;\n        currencyCt = stake.currency.ct;\n        currencyId = stake.currency.id;\n    }\n\n    \n    \n    \n    \n    \n    \n    function setOperatorSettlementStake(uint256 fromBlockNumber, int256 stakeAmount,\n        address stakeCurrencyCt, uint256 stakeCurrencyId)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        MonetaryTypesLib.Figure memory stake = MonetaryTypesLib.Figure(stakeAmount, MonetaryTypesLib.Currency(stakeCurrencyCt, stakeCurrencyId));\n        operatorSettlementStakeByBlockNumber.addEntry(fromBlockNumber, stake);\n        emit SetOperatorSettlementStakeEvent(fromBlockNumber, stakeAmount, stakeCurrencyCt, stakeCurrencyId);\n    }\n\n    \n    \n    function setEarliestSettlementBlockNumber(uint256 _earliestSettlementBlockNumber)\n    public\n    onlyOperator\n    {\n        require(!earliestSettlementBlockNumberUpdateDisabled, \"Earliest settlement block number update disabled [Configuration.sol:715]\");\n\n        earliestSettlementBlockNumber = _earliestSettlementBlockNumber;\n        emit SetEarliestSettlementBlockNumberEvent(earliestSettlementBlockNumber);\n    }\n\n    \n    \n    function disableEarliestSettlementBlockNumberUpdate()\n    public\n    onlyOperator\n    {\n        earliestSettlementBlockNumberUpdateDisabled = true;\n        emit DisableEarliestSettlementBlockNumberUpdateEvent();\n    }\n\n    \n    \n    \n    modifier onlyDelayedBlockNumber(uint256 blockNumber) {\n        require(\n            0 == updateDelayBlocksByBlockNumber.count() ||\n        blockNumber >= block.number + updateDelayBlocksByBlockNumber.currentValue(),\n            \"Block number not sufficiently delayed [Configuration.sol:735]\"\n        );\n        _;\n    }\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"name\":\"nominal\",\"type\":\"int256\"},{\"name\":\"discountTiers\",\"type\":\"int256[]\"},{\"name\":\"discountValues\",\"type\":\"int256[]\"}],\"name\":\"setTradeMakerFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operationalMode\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"feeCurrenciesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"currencyPaymentMinimumFee\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"isRegisteredActiveService\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"name\":\"referenceCurrencyCt\",\"type\":\"address\"},{\"name\":\"referenceCurrencyId\",\"type\":\"uint256\"},{\"name\":\"feeCurrencyCt\",\"type\":\"address\"},{\"name\":\"feeCurrencyId\",\"type\":\"uint256\"}],\"name\":\"setFeeCurrency\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"},{\"name\":\"discountTier\",\"type\":\"int256\"}],\"name\":\"currencyPaymentFee\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"name\":\"nominal\",\"type\":\"int256\"}],\"name\":\"setPaymentMinimumFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"discountTier\",\"type\":\"int256\"}],\"name\":\"tradeMakerFee\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"triggerSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"paymentMinimumFee\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletSettlementStakeFraction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paymentMinimumFeesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletLockTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"},{\"name\":\"action\",\"type\":\"string\"}],\"name\":\"enableServiceAction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"isRegisteredService\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"selfDestructionDisabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"},{\"name\":\"action\",\"type\":\"string\"}],\"name\":\"disableServiceAction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"serviceActivationTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"name\":\"timeoutInSeconds\",\"type\":\"uint256\"}],\"name\":\"setWalletLockTimeout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"name\":\"stakeFraction\",\"type\":\"uint256\"}],\"name\":\"setWalletSettlementStakeFraction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"destructor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"confirmationBlocks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"name\":\"nominal\",\"type\":\"int256\"},{\"name\":\"discountTiers\",\"type\":\"int256[]\"},{\"name\":\"discountValues\",\"type\":\"int256[]\"}],\"name\":\"setPaymentFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"currencyPaymentMinimumFeesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"deregisterService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradeMakerMinimumFeesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"name\":\"stakeAmount\",\"type\":\"int256\"},{\"name\":\"stakeCurrencyCt\",\"type\":\"address\"},{\"name\":\"stakeCurrencyId\",\"type\":\"uint256\"}],\"name\":\"setOperatorSettlementStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"},{\"name\":\"action\",\"type\":\"string\"}],\"name\":\"isEnabledServiceAction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"name\":\"nominal\",\"type\":\"int256\"},{\"name\":\"discountTiers\",\"type\":\"int256[]\"},{\"name\":\"discountValues\",\"type\":\"int256[]\"}],\"name\":\"setTradeTakerFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"name\":\"nominal\",\"type\":\"int256\"}],\"name\":\"setTradeTakerMinimumFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"discountTier\",\"type\":\"int256\"}],\"name\":\"tradeTakerFee\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"name\":\"stakeFraction\",\"type\":\"uint256\"}],\"name\":\"setOperatorSettlementStakeFraction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"name\":\"timeoutInSeconds\",\"type\":\"uint256\"}],\"name\":\"setSettlementChallengeTimeout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"name\":\"newUpdateDelayBlocks\",\"type\":\"uint256\"}],\"name\":\"setUpdateDelayBlocks\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"name\":\"stakeFraction\",\"type\":\"uint256\"}],\"name\":\"setFraudStakeFraction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"timeoutInSeconds\",\"type\":\"uint256\"}],\"name\":\"setServiceActivationTimeout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"currencyPaymentFeesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradeTakerFeesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"updateDelayBlocksCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paymentFeesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradeTakerMinimumFeesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"registerServiceDeferred\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"name\":\"timeoutInSeconds\",\"type\":\"uint256\"}],\"name\":\"setCancelOrderChallengeTimeout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cancelOrderChallengeTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"setDeployer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fraudStakeFraction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableEarliestSettlementBlockNumberUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"feeCurrency\",\"outputs\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operatorSettlementStakeFraction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"discountTier\",\"type\":\"int256\"}],\"name\":\"paymentFee\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradeMakerFeesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"earliestSettlementBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OPERATIONAL_MODE_ACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOperationalModeExit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"confirmationBlocksCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"},{\"name\":\"nominal\",\"type\":\"int256\"}],\"name\":\"setCurrencyPaymentMinimumFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"updateDelayBlocks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operatorSettlementStake\",\"outputs\":[{\"name\":\"amount\",\"type\":\"int256\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"earliestSettlementBlockNumberUpdateDisabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"tradeMakerMinimumFee\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"tradeTakerMinimumFee\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"name\":\"nominal\",\"type\":\"int256\"}],\"name\":\"setTradeMakerMinimumFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_earliestSettlementBlockNumber\",\"type\":\"uint256\"}],\"name\":\"setEarliestSettlementBlockNumber\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOperationalModeNormal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"},{\"name\":\"nominal\",\"type\":\"int256\"},{\"name\":\"discountTiers\",\"type\":\"int256[]\"},{\"name\":\"discountValues\",\"type\":\"int256[]\"}],\"name\":\"setCurrencyPaymentFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setOperationalModeExit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settlementChallengeTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"registerService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"name\":\"newConfirmationBlocks\",\"type\":\"uint256\"}],\"name\":\"setConfirmationBlocks\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"deployer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SetOperationalModeExitEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newBlocks\",\"type\":\"uint256\"}],\"name\":\"SetUpdateDelayBlocksEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newBlocks\",\"type\":\"uint256\"}],\"name\":\"SetConfirmationBlocksEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nominal\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"discountTiers\",\"type\":\"int256[]\"},{\"indexed\":false,\"name\":\"discountValues\",\"type\":\"int256[]\"}],\"name\":\"SetTradeMakerFeeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nominal\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"discountTiers\",\"type\":\"int256[]\"},{\"indexed\":false,\"name\":\"discountValues\",\"type\":\"int256[]\"}],\"name\":\"SetTradeTakerFeeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nominal\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"discountTiers\",\"type\":\"int256[]\"},{\"indexed\":false,\"name\":\"discountValues\",\"type\":\"int256[]\"}],\"name\":\"SetPaymentFeeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currencyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nominal\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"discountTiers\",\"type\":\"int256[]\"},{\"indexed\":false,\"name\":\"discountValues\",\"type\":\"int256[]\"}],\"name\":\"SetCurrencyPaymentFeeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nominal\",\"type\":\"int256\"}],\"name\":\"SetTradeMakerMinimumFeeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nominal\",\"type\":\"int256\"}],\"name\":\"SetTradeTakerMinimumFeeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nominal\",\"type\":\"int256\"}],\"name\":\"SetPaymentMinimumFeeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currencyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nominal\",\"type\":\"int256\"}],\"name\":\"SetCurrencyPaymentMinimumFeeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"referenceCurrencyCt\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"referenceCurrencyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"feeCurrencyCt\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"feeCurrencyId\",\"type\":\"uint256\"}],\"name\":\"SetFeeCurrencyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeoutInSeconds\",\"type\":\"uint256\"}],\"name\":\"SetWalletLockTimeoutEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeoutInSeconds\",\"type\":\"uint256\"}],\"name\":\"SetCancelOrderChallengeTimeoutEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeoutInSeconds\",\"type\":\"uint256\"}],\"name\":\"SetSettlementChallengeTimeoutEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stakeFraction\",\"type\":\"uint256\"}],\"name\":\"SetWalletSettlementStakeFractionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stakeFraction\",\"type\":\"uint256\"}],\"name\":\"SetOperatorSettlementStakeFractionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stakeAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"stakeCurrencyCt\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"stakeCurrencyId\",\"type\":\"uint256\"}],\"name\":\"SetOperatorSettlementStakeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stakeFraction\",\"type\":\"uint256\"}],\"name\":\"SetFraudStakeFractionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"earliestSettlementBlockNumber\",\"type\":\"uint256\"}],\"name\":\"SetEarliestSettlementBlockNumberEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"DisableEarliestSettlementBlockNumberUpdateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timeoutInSeconds\",\"type\":\"uint256\"}],\"name\":\"ServiceActivationTimeoutEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"}],\"name\":\"RegisterServiceEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timeout\",\"type\":\"uint256\"}],\"name\":\"RegisterServiceDeferredEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"}],\"name\":\"DeregisterServiceEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"action\",\"type\":\"string\"}],\"name\":\"EnableServiceActionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"action\",\"type\":\"string\"}],\"name\":\"DisableServiceActionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldDeployer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"SetDeployerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOperator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"SetOperatorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"SelfDestructionDisabledEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"TriggerSelfDestructionEvent\",\"type\":\"event\"}]","ContractName":"Configuration","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"000000000000000000000000f05179bac3d1fbef58a2fcd7ad0f769840027cc6","Library":"ConstantsLib:5fcf3704016b90ded3c81d75613ceab0a6a26025","SwarmSource":"bzzr://6844c6a0f216f0b03fd046ad9d90afa88c1dee4a4d2946b10c109c21120ce46a"}]}