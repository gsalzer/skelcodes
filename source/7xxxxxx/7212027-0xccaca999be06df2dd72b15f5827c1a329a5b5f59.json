{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\n// File: /Users/anxo/code/gnosis/dx-price-oracle/contracts/IDutchX.sol\r\n\r\ninterface DutchX {\r\n\r\n    function approvedTokens(address)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function getAuctionIndex(\r\n        address token1,\r\n        address token2\r\n    )\r\n        external\r\n        view\r\n        returns (uint auctionIndex);\r\n\r\n    function getClearingTime(\r\n        address token1,\r\n        address token2,\r\n        uint auctionIndex\r\n    )\r\n        external\r\n        view\r\n        returns (uint time);\r\n\r\n    function getPriceInPastAuction(\r\n        address token1,\r\n        address token2,\r\n        uint auctionIndex\r\n    )\r\n        external\r\n        view\r\n        // price < 10^31\r\n        returns (uint num, uint den);\r\n}\r\n\r\n// File: /Users/anxo/code/gnosis/dx-price-oracle/contracts/DutchXPriceOracle.sol\r\n\r\n/// @title A contract that uses the DutchX platform to provide a reliable price oracle for any token traded on the DutchX\r\n/// @author Dominik Teiml - dominik@gnosis.pm\r\n\r\ncontract DutchXPriceOracle {\r\n\r\n    DutchX public dutchX;\r\n    address public ethToken;\r\n    \r\n    /// @notice constructor takes DutchX proxy address and WETH token address\r\n    /// @param _dutchX address of DutchX proxy\r\n    /// @param _ethToken address of WETH token\r\n    constructor(DutchX _dutchX, address _ethToken)\r\n        public\r\n    {\r\n        dutchX = _dutchX;\r\n        ethToken = _ethToken;\r\n    }\r\n\r\n    /// @notice Get price, in ETH, of an ERC-20 token `token.address()`\r\n    /// @param token address of ERC-20 token in question\r\n    /// @return The numerator of the price of the token\r\n    /// @return The denominator of the price of the token\r\n    function getPrice(address token)\r\n        public\r\n        view\r\n        returns (uint num, uint den)\r\n    {\r\n        (num, den) = getPriceCustom(token, 0, true, 4.5 days, 9);\r\n    }\r\n\r\n    /// @dev More fine-grained price oracle for token `token.address()`\r\n    /// @param token address of ERC-20 token in question\r\n    /// @param time 0 for current price, a Unix timestamp for a price at any point in time\r\n    /// @param requireWhitelisted Require the token be whitelisted on the DutchX? (Unwhitelisted addresses might not conform to the ERC-20 standard and/or might be malicious)\r\n    /// @param maximumTimePeriod maximum time period between clearing time of last auction and `time`\r\n    /// @param numberOfAuctions how many auctions to consider. Contract is safe only for odd numbers.\r\n    /// @return The numerator of the price of the token\r\n    /// @return The denominator of the price of the token\r\n    function getPriceCustom(\r\n        address token,\r\n        uint time,\r\n        bool requireWhitelisted,\r\n        uint maximumTimePeriod,\r\n        uint numberOfAuctions\r\n    )\r\n        public\r\n        view\r\n        returns (uint num, uint den)\r\n    {\r\n        // Whitelist check\r\n        if (requireWhitelisted && !isWhitelisted(token)) {\r\n            return (0, 0);\r\n        }\r\n\r\n        address ethTokenMem = ethToken;\r\n\r\n        uint auctionIndex;\r\n        uint latestAuctionIndex = dutchX.getAuctionIndex(token, ethTokenMem);\r\n\r\n        if (time == 0) {\r\n            auctionIndex = latestAuctionIndex;\r\n            time = now;\r\n        } else {\r\n            // We need to add one at the end, because the way getPricesAndMedian works, it starts from \r\n            // the previous auction (see below for why it does that)\r\n            auctionIndex = computeAuctionIndex(token, 1, \r\n                latestAuctionIndex - 1, latestAuctionIndex - 1, time) + 1;\r\n        }\r\n\r\n        // Activity check\r\n        uint clearingTime = dutchX.getClearingTime(token, ethTokenMem, auctionIndex - numberOfAuctions - 1);\r\n\r\n        if (time - clearingTime > maximumTimePeriod) {\r\n            return (0, 0);\r\n        } else {\r\n            (num, den) = getPricesAndMedian(token, numberOfAuctions, auctionIndex);\r\n        }\r\n    }\r\n\r\n    /// @notice gets prices, starting \r\n    /// @dev search starts at auctionIndex - 1. The reason for this is we expect the most common use case to be the latest auction index and for that the clearingTime is not available yet. So we need to start at the one before\r\n    /// @param token address of ERC-20 token in question\r\n    /// @param numberOfAuctions how many auctions to consider. Contract is safe only for add numbers\r\n    /// @param auctionIndex search will begin at auctionIndex - 1\r\n    /// @return The numerator of the price of the token\r\n    /// @return The denominator of the price of the token\r\n    function getPricesAndMedian(\r\n        address token,\r\n        uint numberOfAuctions,\r\n        uint auctionIndex\r\n    )\r\n        public\r\n        view\r\n        returns (uint, uint)\r\n    {\r\n        // This function repeatedly calls dutchX.getPriceInPastAuction\r\n        // (which is a weighted average of the two closing prices for one auction pair)\r\n        // and saves them in nums[] and dens[]\r\n        // It keeps a linked list of indices of the sorted prices so that there is no array shifting\r\n        // Whenever a new price is added, we traverse the indices until we find a smaller price\r\n        // then we update the linked list in O(1)\r\n        // (It could be viewed as a linked list version of insertion sort)\r\n\r\n        uint[] memory nums = new uint[](numberOfAuctions);\r\n        uint[] memory dens = new uint[](numberOfAuctions);\r\n        uint[] memory linkedListOfIndices = new uint[](numberOfAuctions);\r\n        uint indexOfSmallest;\r\n\r\n        for (uint i = 0; i < numberOfAuctions; i++) {\r\n            // Loop begins by calling auctionIndex - 1 and ends by calling auctionIndex - numberOfAcutions\r\n            // That gives numberOfAuctions calls\r\n            (uint num, uint den) = dutchX.getPriceInPastAuction(token, ethToken, auctionIndex - 1 - i);\r\n\r\n            (nums[i], dens[i]) = (num, den);\r\n\r\n            // We begin by comparing latest price to smallest price\r\n            // Smallest price is given by prices[linkedListOfIndices.indexOfLargest]\r\n            uint previousIndex;\r\n            uint index = linkedListOfIndices[indexOfSmallest];\r\n\r\n            for (uint j = 0; j < i; j++) {\r\n                if (isSmaller(num, den, nums[index], dens[index])) {\r\n\r\n                    // Update new term to point to next term\r\n                    linkedListOfIndices[i] = index;\r\n\r\n                    if (j == 0) {\r\n                        // Loop is at first iteration\r\n                        linkedListOfIndices[indexOfSmallest] = i;\r\n                    } else {\r\n                        // Update current term to point to new term\r\n                        // Current term is given by \r\n                        linkedListOfIndices[previousIndex] = i;\r\n                    }\r\n\r\n                    break;\r\n                }\r\n\r\n                if (j == i - 1) {\r\n                    // Loop is at last iteration\r\n                    linkedListOfIndices[i] = linkedListOfIndices[indexOfSmallest];\r\n                    linkedListOfIndices[index] = i;\r\n                    indexOfSmallest = i;\r\n                } else {\r\n                    // Nothing happened, update temp vars and run body again\r\n                    previousIndex = index;\r\n                    index = linkedListOfIndices[index];\r\n                }\r\n            }\r\n        }\r\n\r\n        // Array is fully sorted\r\n\r\n        uint index = indexOfSmallest;\r\n\r\n        // Traverse array to find median\r\n        for (uint i = 0; i < (numberOfAuctions + 1) / 2; i++) {\r\n            index = linkedListOfIndices[index];\r\n        }\r\n\r\n        // We return floor-of-half value \r\n        // The reason is if we computed arithmetic average of the two middle values\r\n        // as a traditional median does, that would increase the order of the numbers\r\n        // DutchX price oracle gives a fraction with num & den at an order of 10^30\r\n        // If instead of a/b we do (a/b + c/d)/2 = (ad+bc)/(2bd), we see the order\r\n        // would become 10^60. That would increase chance of overflow in contracts \r\n        // that depend on this price oracle\r\n        // This also means the Price Oracle is safe only for odd values of numberOfAuctions!\r\n\r\n        return (nums[index], dens[index]);\r\n    }\r\n\r\n    /// @dev compute largest auctionIndex with clearing time smaller than desired time. Use case: user provides a time and this function will find the largest auctionIndex that had a cleared auction before that time. It is used to get historical price oracle values\r\n    /// @param token address of ERC-20 token in question\r\n    /// @param lowerBound lowerBound of result. Recommended that it is > 0, because 0th price is set by whoever adds token pair\r\n    /// @param initialUpperBound initial upper bound when this recursive fn is called for the first time\r\n    /// @param upperBound current upper bound of result\r\n    /// @param time desired time\r\n    /// @return largest auctionIndex s.t. clearingTime[auctionIndex] <= time\r\n    function computeAuctionIndex(\r\n        address token,\r\n        uint lowerBound, \r\n        uint initialUpperBound,\r\n        uint upperBound,\r\n        uint time\r\n    )\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        // computeAuctionIndex works by recursively lowering lower and upperBound\r\n        // The result begins in [lowerBound, upperBound] (invariant)\r\n        // If we never decrease the upperBound, it will stay in that range\r\n        // If we ever decrease it, the result will be in [lowerBound, upperBound - 1]\r\n\r\n        uint clearingTime;\r\n\r\n        if (upperBound - lowerBound == 1) {\r\n            // Recursion base case\r\n\r\n            if (lowerBound <= 1) {\r\n                clearingTime = dutchX.getClearingTime(token, ethToken, lowerBound); \r\n\r\n                if (time < clearingTime) {\r\n                    revert(\"time too small\");\r\n                }\r\n            }\r\n\r\n            if (upperBound == initialUpperBound) {\r\n                clearingTime = dutchX.getClearingTime(token, ethToken, upperBound);\r\n\r\n                if (time < clearingTime) {\r\n                    return lowerBound;\r\n                } else {\r\n                    // Can only happen if answer is initialUpperBound\r\n                    return upperBound;\r\n                }            \r\n            } else {\r\n                // In most cases, we'll have bounds [loweBound, loweBound + 1), which results in lowerBound\r\n                return lowerBound;\r\n            }\r\n        }\r\n\r\n        uint mid = (lowerBound + upperBound) / 2;\r\n        clearingTime = dutchX.getClearingTime(token, ethToken, mid);\r\n\r\n        if (time < clearingTime) {\r\n            // Answer is in lower half\r\n            return computeAuctionIndex(token, lowerBound, initialUpperBound, mid, time);\r\n        } else if (time == clearingTime) {\r\n            // We found answer\r\n            return mid;\r\n        } else {\r\n            // Answer is in upper half\r\n            return computeAuctionIndex(token, mid, initialUpperBound, upperBound, time);\r\n        }\r\n    }\r\n\r\n    /// @notice compares two fractions and returns if first is smaller\r\n    /// @param num1 Numerator of first fraction\r\n    /// @param den1 Denominator of first fraction\r\n    /// @param num2 Numerator of second fraction\r\n    /// @param den2 Denominator of second fraction\r\n    /// @return bool - whether first fraction is (strictly) smaller than second\r\n    function isSmaller(uint num1, uint den1, uint num2, uint den2)\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        // Safe math\r\n        require(den1 != 0, \"undefined fraction\");\r\n        require(den2 != 0, \"undefined fraction\");\r\n        require(num1 * den2 / den2 == num1, \"overflow\");\r\n        require(num2 * den1 / den1 == num2, \"overflow\");\r\n\r\n        return (num1 * den2 < num2 * den1);\r\n    }\r\n\r\n    /// @notice determines whether token has been approved (whitelisted) on DutchX\r\n    /// @param token address of ERC-20 token in question\r\n    /// @return bool - whether token has been approved (whitelisted)\r\n    function isWhitelisted(address token) \r\n        public\r\n        view\r\n        returns (bool) \r\n    {\r\n        return dutchX.approvedTokens(token);\r\n    }\r\n}\r\n\r\n// File: /Users/anxo/code/gnosis/dx-price-oracle/node_modules/@gnosis.pm/dx-contracts/contracts/base/AuctioneerManaged.sol\r\n\r\ncontract AuctioneerManaged {\r\n    // auctioneer has the power to manage some variables\r\n    address public auctioneer;\r\n\r\n    function updateAuctioneer(address _auctioneer) public onlyAuctioneer {\r\n        require(_auctioneer != address(0), \"The auctioneer must be a valid address\");\r\n        auctioneer = _auctioneer;\r\n    }\r\n\r\n    // > Modifiers\r\n    modifier onlyAuctioneer() {\r\n        // Only allows auctioneer to proceed\r\n        // R1\r\n        // require(msg.sender == auctioneer, \"Only auctioneer can perform this operation\");\r\n        require(msg.sender == auctioneer, \"Only the auctioneer can nominate a new one\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File: @gnosis.pm/dx-contracts/contracts/base/TokenWhitelist.sol\r\n\r\ncontract TokenWhitelist is AuctioneerManaged {\r\n    // Mapping that stores the tokens, which are approved\r\n    // Only tokens approved by auctioneer generate frtToken tokens\r\n    // addressToken => boolApproved\r\n    mapping(address => bool) public approvedTokens;\r\n\r\n    event Approval(address indexed token, bool approved);\r\n\r\n    /// @dev for quick overview of approved Tokens\r\n    /// @param addressesToCheck are the ERC-20 token addresses to be checked whether they are approved\r\n    function getApprovedAddressesOfList(address[] calldata addressesToCheck) external view returns (bool[] memory) {\r\n        uint length = addressesToCheck.length;\r\n\r\n        bool[] memory isApproved = new bool[](length);\r\n\r\n        for (uint i = 0; i < length; i++) {\r\n            isApproved[i] = approvedTokens[addressesToCheck[i]];\r\n        }\r\n\r\n        return isApproved;\r\n    }\r\n    \r\n    function updateApprovalOfToken(address[] memory token, bool approved) public onlyAuctioneer {\r\n        for (uint i = 0; i < token.length; i++) {\r\n            approvedTokens[token[i]] = approved;\r\n            emit Approval(token[i], approved);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/WhitelistPriceOracle.sol\r\n\r\n/// @title A DutchXPriceOracle that uses it's own whitelisted tokens instead of the ones of the DutchX\r\n/// @author Angel Rodriguez - angel@gnosis.pm\r\ncontract WhitelistPriceOracle is TokenWhitelist, DutchXPriceOracle {\r\n    constructor(DutchX _dutchX, address _ethToken, address _auctioneer)\r\n        DutchXPriceOracle(_dutchX, _ethToken)\r\n        public\r\n    {\r\n        auctioneer = _auctioneer;\r\n    }\r\n\r\n    function isWhitelisted(address token) \r\n        public\r\n        view\r\n        returns (bool) \r\n    {\r\n        return approvedTokens[token];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"addressesToCheck\",\"type\":\"address[]\"}],\"name\":\"getApprovedAddressesOfList\",\"outputs\":[{\"name\":\"\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dutchX\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"numberOfAuctions\",\"type\":\"uint256\"},{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"getPricesAndMedian\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"den\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"requireWhitelisted\",\"type\":\"bool\"},{\"name\":\"maximumTimePeriod\",\"type\":\"uint256\"},{\"name\":\"numberOfAuctions\",\"type\":\"uint256\"}],\"name\":\"getPriceCustom\",\"outputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"den\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctioneer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address[]\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"updateApprovalOfToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_auctioneer\",\"type\":\"address\"}],\"name\":\"updateAuctioneer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"num1\",\"type\":\"uint256\"},{\"name\":\"den1\",\"type\":\"uint256\"},{\"name\":\"num2\",\"type\":\"uint256\"},{\"name\":\"den2\",\"type\":\"uint256\"}],\"name\":\"isSmaller\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"lowerBound\",\"type\":\"uint256\"},{\"name\":\"initialUpperBound\",\"type\":\"uint256\"},{\"name\":\"upperBound\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"computeAuctionIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_dutchX\",\"type\":\"address\"},{\"name\":\"_ethToken\",\"type\":\"address\"},{\"name\":\"_auctioneer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"WhitelistPriceOracle","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b9812e2fa995ec53b5b6df34d21f9304762c5497000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000b1f919db227048a1a45883138b9d12b9ef03df25","Library":"","SwarmSource":"bzzr://f23ed161e62bf9c5bb38b62b9562e604b6bb2ecc56c5be60a4082592991de1e6"}]}