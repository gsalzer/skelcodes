{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/// @title SelfAuthorized - authorizes current contract to perform actions\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract SelfAuthorized {\r\n    modifier authorized() {\r\n        require(msg.sender == address(this), \"Method can only be called from this contract\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n/// @title MasterCopy - Base for master copy contracts (should always be first super contract)\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract MasterCopy is SelfAuthorized {\r\n  // masterCopy always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\r\n  // It should also always be ensured that the address is stored alone (uses a full word)\r\n    address masterCopy;\r\n\r\n  /// @dev Allows to upgrade the contract. This can only be done via a Safe transaction.\r\n  /// @param _masterCopy New contract address.\r\n    function changeMasterCopy(address _masterCopy)\r\n        public\r\n        authorized\r\n    {\r\n        // Master copy address cannot be null.\r\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\r\n        masterCopy = _masterCopy;\r\n    }\r\n}\r\n\r\n\r\n/// @title Enum - Collection of enums\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract Enum {\r\n    enum Operation {\r\n        Call,\r\n        DelegateCall,\r\n        Create\r\n    }\r\n}\r\n\r\n\r\n/// @title EtherPaymentFallback - A contract that has a fallback to accept ether payments\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract EtherPaymentFallback {\r\n\r\n    /// @dev Fallback function accepts Ether transactions.\r\n    function ()\r\n        external\r\n        payable\r\n    {\r\n\r\n    }\r\n}\r\n\r\n\r\n/// @title Executor - A contract that can execute transactions\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract Executor is EtherPaymentFallback {\r\n\r\n    event ContractCreation(address newContract);\r\n\r\n    function execute(address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        if (operation == Enum.Operation.Call)\r\n            success = executeCall(to, value, data, txGas);\r\n        else if (operation == Enum.Operation.DelegateCall)\r\n            success = executeDelegateCall(to, data, txGas);\r\n        else {\r\n            address newContract = executeCreate(data);\r\n            success = newContract != address(0);\r\n            emit ContractCreation(newContract);\r\n        }\r\n    }\r\n\r\n    function executeCall(address to, uint256 value, bytes memory data, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n\r\n    function executeDelegateCall(address to, bytes memory data, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n\r\n    function executeCreate(bytes memory data)\r\n        internal\r\n        returns (address newContract)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            newContract := create(0, add(data, 0x20), mload(data))\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract ModuleManager is SelfAuthorized, Executor {\r\n\r\n    event EnabledModule(Module module);\r\n    event DisabledModule(Module module);\r\n\r\n    address public constant SENTINEL_MODULES = address(0x1);\r\n\r\n    mapping (address => address) internal modules;\r\n    \r\n    function setupModules(address to, bytes memory data)\r\n        internal\r\n    {\r\n        require(modules[SENTINEL_MODULES] == address(0), \"Modules have already been initialized\");\r\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\r\n        if (to != address(0))\r\n            // Setup has to complete successfully or transaction fails.\r\n            require(executeDelegateCall(to, data, gasleft()), \"Could not finish initialization\");\r\n    }\r\n\r\n    /// @dev Allows to add a module to the whitelist.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param module Module to be whitelisted.\r\n    function enableModule(Module module)\r\n        public\r\n        authorized\r\n    {\r\n        // Module address cannot be null or sentinel.\r\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\r\n        // Module cannot be added twice.\r\n        require(modules[address(module)] == address(0), \"Module has already been added\");\r\n        modules[address(module)] = modules[SENTINEL_MODULES];\r\n        modules[SENTINEL_MODULES] = address(module);\r\n        emit EnabledModule(module);\r\n    }\r\n\r\n    /// @dev Allows to remove a module from the whitelist.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\r\n    /// @param module Module to be removed.\r\n    function disableModule(Module prevModule, Module module)\r\n        public\r\n        authorized\r\n    {\r\n        // Validate module address and check that it corresponds to module index.\r\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\r\n        require(modules[address(prevModule)] == address(module), \"Invalid prevModule, module pair provided\");\r\n        modules[address(prevModule)] = modules[address(module)];\r\n        modules[address(module)] = address(0);\r\n        emit DisabledModule(module);\r\n    }\r\n\r\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\r\n    /// @param to Destination address of module transaction.\r\n    /// @param value Ether value of module transaction.\r\n    /// @param data Data payload of module transaction.\r\n    /// @param operation Operation type of module transaction.\r\n    function execTransactionFromModule(address to, uint256 value, bytes memory data, Enum.Operation operation)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        // Only whitelisted modules are allowed.\r\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"Method can only be called from an enabled module\");\r\n        // Execute transaction without further confirmations.\r\n        success = execute(to, value, data, operation, gasleft());\r\n    }\r\n\r\n    /// @dev Returns array of modules.\r\n    /// @return Array of modules.\r\n    function getModules()\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        // Calculate module count\r\n        uint256 moduleCount = 0;\r\n        address currentModule = modules[SENTINEL_MODULES];\r\n        while(currentModule != SENTINEL_MODULES) {\r\n            currentModule = modules[currentModule];\r\n            moduleCount ++;\r\n        }\r\n        address[] memory array = new address[](moduleCount);\r\n\r\n        // populate return array\r\n        moduleCount = 0;\r\n        currentModule = modules[SENTINEL_MODULES];\r\n        while(currentModule != SENTINEL_MODULES) {\r\n            array[moduleCount] = currentModule;\r\n            currentModule = modules[currentModule];\r\n            moduleCount ++;\r\n        }\r\n        return array;\r\n    }\r\n}\r\n\r\n\r\n/// @title Module - Base class for modules.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract Module is MasterCopy {\r\n\r\n    ModuleManager public manager;\r\n\r\n    modifier authorized() {\r\n        require(msg.sender == address(manager), \"Method can only be called from manager\");\r\n        _;\r\n    }\r\n\r\n    function setManager()\r\n        internal\r\n    {\r\n        // manager can only be 0 at initalization of contract.\r\n        // Check ensures that setup function can only be called once.\r\n        require(address(manager) == address(0), \"Manager has already been set\");\r\n        manager = ModuleManager(msg.sender);\r\n    }\r\n}\r\n\r\ninterface SM {\r\n\r\n    function isValidSubscription(\r\n        bytes32 subscriptionHash,\r\n        bytes calldata signatures\r\n    ) external view returns (bool);\r\n\r\n    function execSubscription (\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        uint256 dataGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address payable refundReceiver,\r\n        bytes calldata meta,\r\n        bytes calldata signatures) external returns (bool);\r\n\r\n    function cancelSubscriptionAsRecipient(\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        uint256 dataGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address payable refundReceiver,\r\n        bytes calldata meta,\r\n        bytes calldata signatures) external returns (bool);\r\n}\r\n/// math.sol -- mixin for inline numerical wizardry\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\nlibrary DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    function tmul(uint x, uint y, uint z) internal pure returns (uint a) {\r\n        require(z != 0);\r\n        a = add(mul(x, y), z / 2) / z;\r\n    }\r\n\r\n    function tdiv(uint x, uint y, uint z) internal pure returns (uint a) {\r\n        a = add(mul(x, z), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\ninterface OracleRegistry {\r\n\r\n    function read(\r\n        uint256 currencyPair\r\n    ) external view returns (bytes32);\r\n\r\n    function getNetworkExecutor()\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n    function getNetworkWallet()\r\n    external\r\n    view\r\n    returns (address payable);\r\n\r\n    function getNetworkFee(address asset)\r\n    external\r\n    view\r\n    returns (uint256 fee);\r\n}\r\n\r\n\r\n/// @title SecuredTokenTransfer - Secure token transfer\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract SecuredTokenTransfer {\r\n\r\n    /// @dev Transfers a token and returns if it was a success\r\n    /// @param token Token that should be transferred\r\n    /// @param receiver Receiver to whom the token should be transferred\r\n    /// @param amount The amount of tokens that should be transferred\r\n    function transferToken (\r\n        address token, \r\n        address receiver,\r\n        uint256 amount\r\n    )\r\n        internal\r\n        returns (bool transferred)\r\n    {\r\n        bytes memory data = abi.encodeWithSignature(\"transfer(address,uint256)\", receiver, amount);\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let success := call(sub(gas, 10000), token, 0, add(data, 0x20), mload(data), 0, 0)\r\n            let ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, returndatasize)\r\n            switch returndatasize \r\n            case 0 { transferred := success }\r\n            case 0x20 { transferred := iszero(or(iszero(success), iszero(mload(ptr)))) }\r\n            default { transferred := 0 }\r\n        }\r\n    }\r\n}\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint256 supply);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n\r\n    function decimals() external view returns (uint256 digits);\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\ncontract MerchantModule is Module, SecuredTokenTransfer {\r\n\r\n    using DSMath for uint256;\r\n\r\n    OracleRegistry public oracleRegistry;\r\n\r\n    event IncomingPayment(uint256 payment);\r\n    event PaymentSent(address asset, address receiver, uint256 payment);\r\n\r\n\r\n    function setup(address _oracleRegistry)\r\n    public\r\n    {\r\n        setManager();\r\n        require(\r\n            address(oracleRegistry) == address(0),\r\n            \"MerchantModule::setup: INVALID_STATE: ORACLE_REGISTRY_SET\"\r\n        );\r\n        oracleRegistry = OracleRegistry(_oracleRegistry);\r\n    }\r\n\r\n    function()\r\n    payable\r\n    external\r\n    {\r\n        emit IncomingPayment(msg.value);\r\n    }\r\n\r\n    function split(\r\n        address tokenAddress\r\n    )\r\n    public\r\n    returns (bool)\r\n    {\r\n        require(\r\n            msg.sender == oracleRegistry.getNetworkExecutor(),\r\n            \"MerchantModule::split: INVALID_DATA: MSG_SENDER_NOT_EXECUTOR\"\r\n        );\r\n\r\n        address payable networkWallet = oracleRegistry.getNetworkWallet();\r\n        address payable merchantWallet = address(manager);\r\n\r\n        if (tokenAddress == address(0)) {\r\n\r\n            uint256 splitterBalanceStart = address(this).balance;\r\n            if (splitterBalanceStart == 0) return false;\r\n            //\r\n            uint256 fee = oracleRegistry.getNetworkFee(address(0));\r\n\r\n\r\n            uint256 networkBalanceStart = networkWallet.balance;\r\n\r\n            uint256 merchantBalanceStart = merchantWallet.balance;\r\n\r\n\r\n            uint256 networkSplit = splitterBalanceStart.wmul(fee);\r\n\r\n            uint256 merchantSplit = splitterBalanceStart.sub(networkSplit);\r\n\r\n\r\n            require(merchantSplit > networkSplit, \"Split Math is Wrong\");\r\n            //pay network\r\n\r\n            networkWallet.transfer(networkSplit);\r\n            emit PaymentSent(address(0x0), networkWallet, networkSplit);\r\n            //pay merchant\r\n\r\n            merchantWallet.transfer(merchantSplit);\r\n            emit PaymentSent(address(0x0), merchantWallet, merchantSplit);\r\n\r\n            require(\r\n                (networkBalanceStart.add(networkSplit) == networkWallet.balance)\r\n                &&\r\n                (merchantBalanceStart.add(merchantSplit) == merchantWallet.balance),\r\n                \"MerchantModule::withdraw: INVALID_EXEC SPLIT_PAYOUT\"\r\n            );\r\n        } else {\r\n\r\n            ERC20 token = ERC20(tokenAddress);\r\n\r\n            uint256 splitterBalanceStart = token.balanceOf(address(this));\r\n\r\n\r\n            if (splitterBalanceStart == 0) return false;\r\n\r\n            uint256 fee = oracleRegistry.getNetworkFee(address(token));\r\n\r\n\r\n            uint256 merchantBalanceStart = token.balanceOf(merchantWallet);\r\n\r\n\r\n            uint256 networkSplit = splitterBalanceStart.wmul(fee);\r\n\r\n\r\n            uint256 merchantSplit = splitterBalanceStart.sub(networkSplit);\r\n\r\n\r\n            require(\r\n                networkSplit.add(merchantSplit) == splitterBalanceStart,\r\n                \"MerchantModule::withdraw: INVALID_EXEC TOKEN_SPLIT\"\r\n            );\r\n\r\n            //pay network\r\n\r\n            require(\r\n                transferToken(address(token), networkWallet, networkSplit),\r\n                \"MerchantModule::withdraw: INVALID_EXEC TOKEN_NETWORK_PAYOUT\"\r\n            );\r\n\r\n            emit PaymentSent(address(token), networkWallet, networkSplit);\r\n\r\n            //pay merchant\r\n            require(\r\n                transferToken(address(token), merchantWallet, merchantSplit),\r\n                \"MerchantModule::withdraw: INVALID_EXEC TOKEN_MERCHANT_PAYOUT\"\r\n            );\r\n            emit PaymentSent(address(token), merchantWallet, merchantSplit);\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    function cancelCXSubscription(\r\n        address customer,\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        uint256 dataGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address payable refundReceiver,\r\n        bytes memory meta,\r\n        bytes memory signatures\r\n    )\r\n    public\r\n    authorized\r\n    {\r\n        SM(customer).cancelSubscriptionAsRecipient(\r\n            to,\r\n            value,\r\n            data,\r\n            operation,\r\n            safeTxGas,\r\n            dataGas,\r\n            gasPrice,\r\n            gasToken,\r\n            refundReceiver,\r\n            meta,\r\n            signatures\r\n        );\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracleRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"split\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oracleRegistry\",\"type\":\"address\"}],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_masterCopy\",\"type\":\"address\"}],\"name\":\"changeMasterCopy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"customer\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operation\",\"type\":\"uint8\"},{\"name\":\"safeTxGas\",\"type\":\"uint256\"},{\"name\":\"dataGas\",\"type\":\"uint256\"},{\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"name\":\"gasToken\",\"type\":\"address\"},{\"name\":\"refundReceiver\",\"type\":\"address\"},{\"name\":\"meta\",\"type\":\"bytes\"},{\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"cancelCXSubscription\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"payment\",\"type\":\"uint256\"}],\"name\":\"IncomingPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"payment\",\"type\":\"uint256\"}],\"name\":\"PaymentSent\",\"type\":\"event\"}]","ContractName":"MerchantModule","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://cf7c000f70df4d9c3d0dc6dc10f28f6eaff17f1bd67e90be045c8eff3c031123"}]}