{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\ncontract DecentralizationSmartGames{\r\n    using SafeMath for uint256;\r\n    \r\n    string public constant name   = \"Decentralization Smart Games\";\r\n    string public constant symbol = \"DSG\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant tokenPrice = 0.00065 ether;\r\n    uint256 public totalSupply; /* Total number of existing DSG tokens */\r\n    uint256 public divPerTokenPool; /* Trigger for calculating dividends on \"Pool dividends\" program */\r\n    uint256 public divPerTokenGaming; /* Trigger for calculating dividends on \"Gaming dividends\" program */\r\n    uint256 public developmentBalance; /* Balance that is used to support the project and games development */\r\n    uint256 public charityBalance;  /* Balance that is used for charity */\r\n    address[2] public owners;  /* Addresses of the contract owners */\r\n    address[2] public candidates; /* Addresses of the future contract owners */\r\n    /**Fee public fee - Structure where all percentages of the distribution of incoming funds are stored\r\n     * uint8 fee.r0 - First referrer - 6%\r\n     * uint8 fee.r1 - Second referrer - 4%\r\n     * uint8 fee.r2 - Third referrer - 3%\r\n     * uint8 fee.r3 - Fourth referrer - 2%\r\n     * uint8 fee.r4 - Fifth referrer - 1%\r\n     * uint8 fee.charity - Charity - 1%\r\n     * uint8 fee.development - For game development and project support - 18%\r\n     * uint8 fee.buy - For buying DSG tokens - 65%\r\n     */\r\n    Fee public fee = Fee(6,4,3,2,1,1,18,65);\r\n    /**Dividends public totalDividends - Structure where general dividend payments are kept\r\n     * uint256 totalDividends.referrer - Referrer Dividends\r\n     * uint256 totalDividends.gaming - Gaming Dividends\r\n     * uint256 totalDividends.pool - Pool Dividends\r\n     */\r\n    Dividends public totalDividends  = Dividends(0,0,0);\r\n    mapping (address => mapping (address => uint256)) private allowed;\r\n    /**mapping (address => Account) private account - Investors accounts data\r\n     * uint256 account[address].tokenBalance - Number of DSG tokens on balance\r\n     * uint256 account[address].ethereumBalance - The amount of ETH on balance (dividends)\r\n     * uint256 account[address].lastDivPerTokenPool - The trigger of last dividend payment upon the \"Pool dividends\" program \r\n     * uint256 account[address].lastDivPerTokenGaming - The trigger of last dividend payment upon the \"Gaming dividends\" program\r\n     * uint256 account[address].totalDividendsReferrer - Total amount of dividends upon the \"Referrer dividends\" program\r\n     * uint256 account[address].totalDividendsGaming - Total amount of dividends upon the \"Gaming dividends\" program \r\n     * uint256 account[address].totalDividendsPool -Total amount of dividends upon the \"Pool dividends\" program\r\n     * address[5] account[address].referrer - Array of all the referrers\r\n     * bool account[address].active - True, if the account is active\r\n     */\r\n    mapping (address => Account) public account;\r\n    mapping (address => bool) public games; /* The list of contracts from which dividends are allowed */\r\n    \r\n    struct Account {\r\n        uint256 tokenBalance;\r\n        uint256 ethereumBalance;\r\n        uint256 lastDivPerTokenPool;\r\n        uint256 lastDivPerTokenGaming;\r\n        uint256 totalDividendsReferrer;\r\n        uint256 totalDividendsGaming;\r\n        uint256 totalDividendsPool;\r\n        address[5] referrer;\r\n        bool active;\r\n    }\r\n    struct Fee{\r\n        uint8 r1;\r\n        uint8 r2;\r\n        uint8 r3;\r\n        uint8 r4;\r\n        uint8 r5;\r\n        uint8 charity;\r\n        uint8 development;\r\n        uint8 buy;\r\n    }\r\n    struct Dividends{\r\n        uint256 referrer;\r\n        uint256 gaming;\r\n        uint256 pool;\r\n    }\r\n    /* Allowed if the address is not 0x */\r\n    modifier check0x(address address0x) {\r\n        require(address0x != address(0), \"Address is 0x\");\r\n        _;\r\n    }\r\n    /* Allowed if on balance of DSG tokens >= amountDSG */\r\n    modifier checkDSG(uint256 amountDSG) {\r\n        require(account[msg.sender].tokenBalance >= amountDSG, \"You don't have enough DSG on balance\");\r\n        _;\r\n    }\r\n    /* Allowed if on balance ETH >= amountETH */\r\n    modifier checkETH(uint256 amountETH) {\r\n        require(account[msg.sender].ethereumBalance >= amountETH, \"You don't have enough ETH on balance\");\r\n        _;\r\n    }\r\n    /* Allowed if the function is called by one the contract owners */\r\n    modifier onlyOwners() {\r\n        require(msg.sender == owners[0] || msg.sender == owners[1], \"You are not owner\");\r\n        _;\r\n    }\r\n    /* Allowed if the sale is still active */\r\n    modifier sellTime() { \r\n        require(now <= 1560211200, \"The sale is over\");\r\n        _;\r\n    }\r\n    /* Dividends upon the \"Pool Dividends\" program are being paid */\r\n    /* Dividends upon the \"Gaming Dividends\" program are being paid */\r\n    modifier payDividends(address sender) {\r\n        uint256 poolDividends = getPoolDividends();\r\n        uint256 gamingDividends = getGamingDividends();\r\n\t\tif(poolDividends > 0 && account[sender].active == true){\r\n\t\t\taccount[sender].totalDividendsPool = account[sender].totalDividendsPool.add(poolDividends);\r\n\t\t\taccount[sender].ethereumBalance = account[sender].ethereumBalance.add(poolDividends);\r\n\t\t}\r\n        if(gamingDividends > 0 && account[sender].active == true){\r\n\t\t\taccount[sender].totalDividendsGaming = account[sender].totalDividendsGaming.add(gamingDividends);\r\n\t\t\taccount[sender].ethereumBalance = account[sender].ethereumBalance.add(gamingDividends);\r\n\t\t}\r\n        _;\r\n\t    account[sender].lastDivPerTokenPool = divPerTokenPool;\r\n        account[sender].lastDivPerTokenGaming = divPerTokenGaming;\r\n        \r\n    }\r\n    /**We assign two contract owners, whose referrers are from the same address\r\n     * In the same manner we activate their accounts\r\n     */\r\n    constructor(address owner2) public{\r\n        address owner1 = msg.sender;\r\n        owners[0]                = owner1;\r\n        owners[1]                = owner2;\r\n        account[owner1].active   = true;\r\n        account[owner2].active   = true;\r\n        account[owner1].referrer = [owner1, owner1, owner1, owner1, owner1];\r\n        account[owner2].referrer = [owner2, owner2, owner2, owner2, owner2];\r\n    }\r\n    /**buy() - the function of buying DSG tokens.\r\n     * It is active only during the time interval specified in sellTime()\r\n     * Dividends upon Pool Dividends program are being paid\r\n     * Dividends upon the Gaming Dividends program are being paid\r\n     * address referrerAddress - The address of the referrer who invited to the program\r\n     * require - Minimum purchase is 100 DSG or 0.1 ETH\r\n     */\r\n    function buy(address referrerAddress) payDividends(msg.sender) sellTime public payable\r\n    {\r\n        require(msg.value >= 0.1 ether, \"Minimum investment is 0.1 ETH\");\r\n        uint256 forTokensPurchase = msg.value.mul(fee.buy).div(100); /* 65% */\r\n        uint256 forDevelopment = msg.value.mul(fee.development).div(100); /* 18% */\r\n        uint256 forCharity = msg.value.mul(fee.charity).div(100); /* 1% */\r\n        uint256 tokens = forTokensPurchase.mul(10 ** uint(decimals)).div(tokenPrice); /* The number of DSG tokens is counted (1ETH = 1000 DSG) */\r\n        _setReferrer(referrerAddress, msg.sender);  /* Assigning of referrers */\r\n        _mint(msg.sender, tokens); /* We create new DSG tokens and add to balance */\r\n        _setProjectDividends(forDevelopment, forCharity); /*  ETH is accrued to the project balances (18%, 1%) */\r\n        _distribution(msg.sender, msg.value.mul(fee.r1).div(100), 0); /* Dividends are accrued to the first refferer - 6% */\r\n        _distribution(msg.sender, msg.value.mul(fee.r2).div(100), 1); /* Dividends are accrued to the second refferer - 4% */\r\n        _distribution(msg.sender, msg.value.mul(fee.r3).div(100), 2); /* Dividends are accrued to the third refferer - 3% */\r\n        _distribution(msg.sender, msg.value.mul(fee.r4).div(100), 3); /* Dividends are accrued to the fourth refferer - 2% */\r\n        _distribution(msg.sender, msg.value.mul(fee.r5).div(100), 4); /* Dividends are accrued to the fifth referrer - 1% */\r\n        emit Buy(msg.sender, msg.value, tokens, totalSupply, now);\r\n    }\r\n    /**reinvest() - dividends reinvestment function.\r\n     * It is active only during the time interval specified in sellTime()\r\n     * Dividends upon the Pool Dividends and Gaming Dividends programs are being paid - payDividends(msg.sender)\r\n     * Checking whether the investor has a given amount of ETH in the contract - checkETH(amountEthereum)\r\n     * address amountEthereum - The amount of ETH sent for reinvestment (dividends)\r\n     */\r\n    function reinvest(uint256 amountEthereum) payDividends(msg.sender) checkETH(amountEthereum) sellTime public\r\n    {\r\n        uint256 tokens = amountEthereum.mul(10 ** uint(decimals)).div(tokenPrice); /* The amount of DSG tokens is counted (1ETH = 1000 DSG) */\r\n        _mint(msg.sender, tokens); /* We create DSG tokens and add to the balance */\r\n        account[msg.sender].ethereumBalance = account[msg.sender].ethereumBalance.sub(amountEthereum);/* The amount of ETH from the investor is decreased */\r\n        emit Reinvest(msg.sender, amountEthereum, tokens, totalSupply, now);\r\n    }\r\n    /**reinvest() - dividends reinvestment function.\r\n     * Checking whether there are enough DSG tokens on balance - checkDSG(amountTokens)\r\n     * Dividends upon the Pool Dividends and Gaming Dividends program are being paid - payDividends(msg.sender)\r\n     * address amountEthereum - The amount of ETH sent for reinvestment (dividends)\r\n     * require - Checking whether the investor has a given amount of ETH in the contract\r\n     */\r\n    function sell(uint256 amountTokens) payDividends(msg.sender) checkDSG(amountTokens) public\r\n    {\r\n        uint256 ethereum = amountTokens.mul(tokenPrice).div(10 ** uint(decimals));/* Counting the number of ETH (1000 DSG = 1ETH) */\r\n        account[msg.sender].ethereumBalance = account[msg.sender].ethereumBalance.add(ethereum);\r\n        _burn(msg.sender, amountTokens);/* Tokens are burnt */\r\n        emit Sell(msg.sender, amountTokens, ethereum, totalSupply, now);\r\n    }\r\n    /**withdraw() - the function of ETH withdrawal from the contract\r\n     * Dividends upon the Pool Dividends and Gaming Dividends programs are being paid - payDividends(msg.sender)\r\n     * Checking whether the investor has a given amount of ETH in the contract - checkETH(amountEthereum)\r\n     * address amountEthereum - The amount of ETH requested for withdrawal\r\n     */\r\n    function withdraw(uint256 amountEthereum) payDividends(msg.sender) checkETH(amountEthereum) public\r\n    {\r\n        msg.sender.transfer(amountEthereum); /* ETH is sent */\r\n        account[msg.sender].ethereumBalance = account[msg.sender].ethereumBalance.sub(amountEthereum);/* Decreasing the amount of ETH from the investor */\r\n        emit Withdraw(msg.sender, amountEthereum, now);\r\n    }\r\n    /**gamingDividendsReception() - function that receives and distributes dividends upon the \"Gaming Dividends\" program\r\n     * require - if the address of the game is not registered in mapping games, the transaction will be declined\r\n     */\r\n    function gamingDividendsReception() payable external{\r\n        require(getGame(msg.sender) == true, \"Game not active\");\r\n        uint256 eth            = msg.value;\r\n        uint256 forDevelopment = eth.mul(19).div(100); /* To support the project - 19% */\r\n        uint256 forInvesotrs   = eth.mul(80).div(100); /* To all DSG holders - 80% */\r\n        uint256 forCharity     = eth.div(100); /* For charity - 1% */\r\n        _setProjectDividends(forDevelopment, forCharity); /* Dividends for supporting the projects are distributed */\r\n        _setGamingDividends(forInvesotrs); /* Gaming dividends are distributed */\r\n    }\r\n    /**_distribution() - function of dividends distribution upon the \"Referrer Dividends\" program\r\n     * With a mimimum purchase ranging from 100 to 9999 DSG\r\n     * Only the first level of the referral program is open and a floating percentage is offered, which depends on the amount of investment.\r\n     * Formula - ETH * DSG / 10000 = %\r\n     * ETH   - the amount of Ethereum, which the investor should have received  if the balance had been >= 10000 DSG (6%)\r\n     * DSG   - the amount of tokens on the referrer's balance, which accrues interest\r\n     * 10000 - minimum amount of tokens when all the percentage levels are open\r\n     * - The first level is a floating percentage depending on the amount of holding\r\n     * - The second level - for all upon the \"Pool dividends\" program\r\n     * - The third level - for all upon the \"Pool dividends\" program\r\n     * - The fourth level - for all upon the \"Pool dividends\" program\r\n     * - The fifth level - for all upon the \"Pool dividends\" program\r\n     * With 10000 DSG on balance and more the entire referral system will be activated and the investor will receive all interest from all levels\r\n     * The function automatically checks the investor's DSG balance at the time of dividends distribution, this that referral\r\n     * program can be fully activated or deactivated automatically depending on the DSG balance at the time of distribution\r\n     * address senderAddress - the address of referral that sends dividends to his referrer\r\n     * uint256 eth - the amount of ETH which referrer should send to the referrer\r\n     * uint8 k - the number of referrer\r\n     */\r\n    function _distribution(address senderAddress, uint256 eth, uint8 k) private{\r\n        address referrer = account[senderAddress].referrer[k];\r\n        uint256 referrerBalance = account[referrer].tokenBalance;\r\n        uint256 senderTokenBalance = account[senderAddress].tokenBalance;\r\n        uint256 minReferrerBalance = 10000e18;\r\n        if(referrerBalance >= minReferrerBalance){\r\n            _setReferrerDividends(referrer, eth);/* The interest is sent to the referrer */\r\n        }\r\n        else if(k == 0 && referrerBalance < minReferrerBalance && referrer != address(0)){\r\n            uint256 forReferrer = eth.mul(referrerBalance).div(minReferrerBalance);/* The floating percentage is counted */\r\n            uint256 forPool = eth.sub(forReferrer);/* Amount for Pool Dividends (all DSG holders) */\r\n            _setReferrerDividends(referrer, forReferrer);/* The referrer is sent his interest */\r\n            _setPoolDividends(forPool, senderTokenBalance);/* Dividends are paid to all the DSG token holders */\r\n        }\r\n        else{\r\n            _setPoolDividends(eth, senderTokenBalance);/* If the refferal is 0x - Dividends are paid to all the DSG token holders */\r\n        }\r\n    }\r\n    /* _setReferrerDividends() - the function which sends referrer his dividends */\r\n    function _setReferrerDividends(address referrer, uint256 eth) private {\r\n        account[referrer].ethereumBalance = account[referrer].ethereumBalance.add(eth);\r\n        account[referrer].totalDividendsReferrer = account[referrer].totalDividendsReferrer.add(eth);\r\n        totalDividends.referrer = totalDividends.referrer.add(eth);\r\n    }\r\n    /**_setReferrer() - the function which assigns referrers to the buyer\r\n     * address referrerAddress - the address of referrer who invited the investor to the project\r\n     * address senderAddress - the buyer's address\r\n     * The function assigns referrers only once when buying tokens\r\n     * Referrers can not be changed\r\n     * require(referrerAddress != senderAddress) - Checks whether the buyer is not a referrer himself\r\n     * require(account[referrerAddress].active == true || referrerAddress == address(0))\r\n     * Checks whether the referrer exists in the project\r\n     */\r\n    function _setReferrer(address referrerAddress, address senderAddress) private\r\n    {\r\n        if(account[senderAddress].active == false){\r\n            require(referrerAddress != senderAddress, \"You can't be referrer for yourself\");\r\n            require(account[referrerAddress].active == true || referrerAddress == address(0), \"Your referrer was not found in the contract\");\r\n            account[senderAddress].referrer = [\r\n                                               referrerAddress, /* The referrer who invited the investor */\r\n                                               account[referrerAddress].referrer[0],\r\n                                               account[referrerAddress].referrer[1],\r\n                                               account[referrerAddress].referrer[2],\r\n                                               account[referrerAddress].referrer[3]\r\n                                              ];\r\n            account[senderAddress].active   = true; /* The account is activated */\r\n            emit Referrer(\r\n                senderAddress,\r\n                account[senderAddress].referrer[0],\r\n                account[senderAddress].referrer[1],\r\n                account[senderAddress].referrer[2],\r\n                account[senderAddress].referrer[3],\r\n                account[senderAddress].referrer[4],\r\n                now\r\n            );\r\n        }\r\n    }\r\n    /**setRef_setProjectDividendserrer() - the function of dividends payment to support the project\r\n     * uint256 forDevelopment - To support the project - 18%\r\n     * uint256 forCharity - For charity - 1%\r\n     */\r\n    function _setProjectDividends(uint256 forDevelopment, uint256 forCharity) private{\r\n        developmentBalance = developmentBalance.add(forDevelopment);\r\n        charityBalance = charityBalance.add(forCharity);\r\n    }\r\n    /**_setPoolDividends() - the function of uniform distribution of dividends to all DSG holders upon the \"Pool Dividends\" program\r\n     * During the distribution of dividends, the amount of tokens that are on the buyer's balance is not taken into account,\r\n     * since he does not participate in the distribution of dividends\r\n     * uint256 amountEthereum - the amount of ETH which should be distributed to all DSG holders\r\n     * uint256 userTokens - the amount of DSG that is on the buyer's balance\r\n     */\r\n    function _setPoolDividends(uint256 amountEthereum, uint256 userTokens) private{\r\n        if(amountEthereum > 0){\r\n\t\t    divPerTokenPool = divPerTokenPool.add(amountEthereum.mul(10 ** uint(decimals)).div(totalSupply.sub(userTokens)));\r\n\t\t    totalDividends.pool = totalDividends.pool.add(amountEthereum);\r\n        }\r\n    }\r\n    /**_setGamingDividends() - the function of uniform distribution of dividends to all DSG holders upon the \"Gaming Dividends\" program\r\n     * uint256 amountEthereum - the amount of ETH which should be distributed to all DSG holders\r\n     */\r\n    function _setGamingDividends(uint256 amountEthereum) private{\r\n        if(amountEthereum > 0){\r\n\t\t    divPerTokenGaming = divPerTokenGaming.add(amountEthereum.mul(10 ** uint(decimals)).div(totalSupply));\r\n\t\t    totalDividends.gaming = totalDividends.gaming.add(amountEthereum);\r\n        }\r\n    }\r\n    /**setGame() - the function of adding a new address of the game contract, from which you can receive dividends\r\n     * address gameAddress - the address of the game contract\r\n     * bool active - if TRUE, the dividends can be received\r\n     */\r\n    function setGame(address gameAddress, bool active) public onlyOwners returns(bool){\r\n        games[gameAddress] = active;\r\n        return true;\r\n    }\r\n    /**getPoolDividends() - the function of calculating dividends for the investor upon the \"Pool Dividends\" program\r\n     * returns(uint256) - the amount of ETH that was counted to the investor is returned\r\n     * and which has not been paid to him yet\r\n     */\r\n    function getPoolDividends() public view returns(uint256)\r\n    {\r\n        uint newDividendsPerToken = divPerTokenPool.sub(account[msg.sender].lastDivPerTokenPool);\r\n        return account[msg.sender].tokenBalance.mul(newDividendsPerToken).div(10 ** uint(decimals));\r\n    }\r\n    /**getGameDividends() - the function of calculating dividends for the investor upon the \"Gaming Dividends\" program\r\n     * returns(uint256) - the amount of ETH that was counted to the investor is returned,\r\n     * and which has not been paid to him yet\r\n     */\r\n    function getGamingDividends() public view returns(uint256)\r\n    {\r\n        uint newDividendsPerToken = divPerTokenGaming.sub(account[msg.sender].lastDivPerTokenGaming);\r\n        return account[msg.sender].tokenBalance.mul(newDividendsPerToken).div(10 ** uint(decimals));\r\n    }\r\n    /* getAccountData() - the function that returns all the data of the investor */\r\n    function getAccountData() public view returns(\r\n        uint256 tokenBalance,\r\n        uint256 ethereumBalance, \r\n        uint256 lastDivPerTokenPool,\r\n        uint256 lastDivPerTokenGaming,\r\n        uint256 totalDividendsPool,\r\n        uint256 totalDividendsReferrer,\r\n        uint256 totalDividendsGaming,\r\n        address[5] memory referrer,\r\n        bool active)\r\n    {\r\n        return(\r\n            account[msg.sender].tokenBalance,\r\n            account[msg.sender].ethereumBalance,\r\n            account[msg.sender].lastDivPerTokenPool,\r\n            account[msg.sender].lastDivPerTokenGaming,\r\n            account[msg.sender].totalDividendsPool,\r\n            account[msg.sender].totalDividendsReferrer,\r\n            account[msg.sender].totalDividendsGaming,\r\n            account[msg.sender].referrer,\r\n            account[msg.sender].active\r\n        );\r\n    }\r\n    /* getContractBalance() - the function that returns a contract balance */\r\n    function getContractBalance() view public returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n    /* getGame() - the function that checks whether the game is active or not. If TRUE - the game is active. If FALSE - the game is not active */\r\n    function getGame(address gameAddress) view public returns (bool) {\r\n        return games[gameAddress];\r\n    }\r\n    /* transferOwnership() - the function that assigns the future founder of the contract */\r\n    function transferOwnership(address candidate, uint8 k) check0x(candidate) onlyOwners public\r\n    {\r\n        candidates[k] = candidate;\r\n    }\r\n    /* confirmOwner() - the function that confirms the new founder of the contract and assigns him */\r\n    function confirmOwner(uint8 k) public\r\n    {\r\n        require(msg.sender == candidates[k], \"You are not candidate\");\r\n        owners[k] = candidates[k];\r\n        delete candidates[k];\r\n    }\r\n    /* charitytWithdraw() - the function of withdrawal for charity */\r\n    function charitytWithdraw(address recipient) onlyOwners check0x(recipient) public\r\n    {\r\n        recipient.transfer(charityBalance);\r\n        delete charityBalance;\r\n    }\r\n    /* developmentWithdraw() - the function of withdrawal for the project support */\r\n    function developmentWithdraw(address recipient) onlyOwners check0x(recipient) public\r\n    {\r\n        recipient.transfer(developmentBalance);\r\n        delete developmentBalance;\r\n    }\r\n    /* balanceOf() - the function that returns the amount of DSG tokens on balance (ERC20 standart) */\r\n    function balanceOf(address owner) public view returns(uint256)\r\n    {\r\n        return account[owner].tokenBalance;\r\n    }\r\n    /* allowance() - the function that checks how much spender can spend tokens of the owner user (ERC20 standart) */\r\n    function allowance(address owner, address spender) public view returns(uint256)\r\n    {\r\n        return allowed[owner][spender];\r\n    }\r\n    /* transferTo() - the function sends DSG tokens to another user (ERC20 standart) */\r\n    function transfer(address to, uint256 value) public returns(bool)\r\n    {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n    /* transferTo() - the function that allows the user to spend n-number of tokens for spender (ERC20 standart) */\r\n    function approve(address spender, uint256 value) check0x(spender) checkDSG(value) public returns(bool)\r\n    {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    /* transferFrom() - the function sends tokens from one address to another, only to the address that gave the permission (ERC20 standart) */\r\n    function transferFrom(address from, address to, uint256 value) public returns(bool)\r\n    {\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\r\n        _transfer(from, to, value);\r\n        emit Approval(from, msg.sender, allowed[from][msg.sender]);\r\n        return true;\r\n    }\r\n    /* _transfer() - the function of tokens sending  (ERC20 standart) */\r\n    function _transfer(address from, address to, uint256 value) payDividends(from) payDividends(to) checkDSG(value) check0x(to) private\r\n    {\r\n        account[from].tokenBalance = account[from].tokenBalance.sub(value);\r\n        account[to].tokenBalance = account[to].tokenBalance.add(value);\r\n        if(account[to].active == false) account[to].active = true;\r\n        emit Transfer(from, to, value);\r\n    }\r\n    /* transferFrom() - the function of tokens creating (ERC20 standart) */\r\n    function _mint(address customerAddress, uint256 value) check0x(customerAddress) private\r\n    {\r\n        totalSupply = totalSupply.add(value);\r\n        account[customerAddress].tokenBalance = account[customerAddress].tokenBalance.add(value);\r\n        emit Transfer(address(0), customerAddress, value);\r\n    }\r\n    /* transferFrom() - the function of tokens _burning (ERC20 standart) */\r\n    function _burn(address customerAddress, uint256 value) check0x(customerAddress) private\r\n    {\r\n        totalSupply = totalSupply.sub(value);\r\n        account[customerAddress].tokenBalance = account[customerAddress].tokenBalance.sub(value);\r\n        emit Transfer(customerAddress, address(0), value);\r\n    }\r\n    event Buy(\r\n        address indexed customerAddress,\r\n        uint256 inputEthereum,\r\n        uint256 outputToken,\r\n        uint256 totalSupply,\r\n        uint256 timestamp\r\n    );\r\n    event Sell(\r\n        address indexed customerAddress,\r\n        uint256 amountTokens,\r\n        uint256 outputEthereum,\r\n        uint256 totalSupply,\r\n        uint256 timestamp\r\n    );\r\n    event Reinvest(\r\n        address indexed customerAddress,\r\n        uint256 amountEthereum,\r\n        uint256 outputToken,\r\n        uint256 totalSupply,\r\n        uint256 timestamp\r\n    );\r\n    event Withdraw(\r\n        address indexed customerAddress,\r\n        uint256 indexed amountEthereum,\r\n        uint256 timestamp\r\n    );\r\n    event Referrer(\r\n        address indexed customerAddress,\r\n        address indexed referrer1,\r\n        address referrer2,\r\n        address referrer3,\r\n        address referrer4,\r\n        address referrer5,\r\n        uint256 timestamp\r\n    );\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint tokens\r\n    );\r\n    event Approval(\r\n        address indexed tokenOwner,\r\n        address indexed spender,\r\n        uint tokens\r\n    );\r\n}\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {  return 0; }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"Mul error\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"Div error\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"Sub error\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"Add error\");\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"Mod error\");\r\n        return a % b;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountEthereum\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"developmentBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"candidates\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGamingDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"divPerTokenGaming\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"charitytWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"divPerTokenPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"candidate\",\"type\":\"address\"},{\"name\":\"k\",\"type\":\"uint8\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"account\",\"outputs\":[{\"name\":\"tokenBalance\",\"type\":\"uint256\"},{\"name\":\"ethereumBalance\",\"type\":\"uint256\"},{\"name\":\"lastDivPerTokenPool\",\"type\":\"uint256\"},{\"name\":\"lastDivPerTokenGaming\",\"type\":\"uint256\"},{\"name\":\"totalDividendsReferrer\",\"type\":\"uint256\"},{\"name\":\"totalDividendsGaming\",\"type\":\"uint256\"},{\"name\":\"totalDividendsPool\",\"type\":\"uint256\"},{\"name\":\"active\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"games\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAccountData\",\"outputs\":[{\"name\":\"tokenBalance\",\"type\":\"uint256\"},{\"name\":\"ethereumBalance\",\"type\":\"uint256\"},{\"name\":\"lastDivPerTokenPool\",\"type\":\"uint256\"},{\"name\":\"lastDivPerTokenGaming\",\"type\":\"uint256\"},{\"name\":\"totalDividendsPool\",\"type\":\"uint256\"},{\"name\":\"totalDividendsReferrer\",\"type\":\"uint256\"},{\"name\":\"totalDividendsGaming\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address[5]\"},{\"name\":\"active\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"developmentWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountEthereum\",\"type\":\"uint256\"}],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameAddress\",\"type\":\"address\"}],\"name\":\"getGame\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDividends\",\"outputs\":[{\"name\":\"referrer\",\"type\":\"uint256\"},{\"name\":\"gaming\",\"type\":\"uint256\"},{\"name\":\"pool\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"charityBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"gamingDividendsReception\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameAddress\",\"type\":\"address\"},{\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"setGame\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPoolDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"name\":\"r1\",\"type\":\"uint8\"},{\"name\":\"r2\",\"type\":\"uint8\"},{\"name\":\"r3\",\"type\":\"uint8\"},{\"name\":\"r4\",\"type\":\"uint8\"},{\"name\":\"r5\",\"type\":\"uint8\"},{\"name\":\"charity\",\"type\":\"uint8\"},{\"name\":\"development\",\"type\":\"uint8\"},{\"name\":\"buy\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrerAddress\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"k\",\"type\":\"uint8\"}],\"name\":\"confirmOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"owner2\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"inputEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"outputToken\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"outputEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"outputToken\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Reinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amountEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrer1\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"referrer2\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"referrer3\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"referrer4\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"referrer5\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Referrer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"DecentralizationSmartGames","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003270abd6c2a3c4e47e054c45160fa2bd430b33fc","Library":"","SwarmSource":"bzzr://bba87c7b5c395d723747e432994c0d6ef1fc528c4d06f33f24b52b3aee26200d"}]}