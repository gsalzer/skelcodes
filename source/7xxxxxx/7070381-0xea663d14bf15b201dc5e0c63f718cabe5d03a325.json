{"status":"1","message":"OK","result":[{"SourceCode":"// solium-disable linebreak-style\r\npragma solidity ^0.5.0;\r\n\r\ncontract CryptoTycoonsVIPLib{\r\n    \r\n    address payable public owner;\r\n\r\n    mapping (address => uint) userExpPool;\r\n    mapping (address => bool) public callerMap;\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"OnlyOwner methods called by non-owner.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyCaller {\r\n        bool isCaller = callerMap[msg.sender];\r\n        require(isCaller, \"onlyCaller methods called by non-caller.\");\r\n        _;\r\n    }\r\n\r\n    constructor() public{\r\n        owner = msg.sender;\r\n        callerMap[owner] = true;\r\n    }\r\n\r\n    function kill() external onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function addCaller(address caller) public onlyOwner{\r\n        bool isCaller = callerMap[caller];\r\n        if (isCaller == false){\r\n            callerMap[caller] = true;\r\n        }\r\n    }\r\n\r\n    function deleteCaller(address caller) external onlyOwner {\r\n        bool isCaller = callerMap[caller];\r\n        if (isCaller == true) {\r\n            callerMap[caller] = false;\r\n        }\r\n    }\r\n\r\n    function addUserExp(address addr, uint256 amount) public onlyCaller{\r\n        uint exp = userExpPool[addr];\r\n        exp = exp + amount;\r\n        userExpPool[addr] = exp;\r\n    }\r\n\r\n    function getUserExp(address addr) public view returns(uint256 exp){\r\n        return userExpPool[addr];\r\n    }\r\n\r\n    function getVIPLevel(address user) public view returns (uint256 level) {\r\n        uint exp = userExpPool[user];\r\n\r\n        if(exp >= 30 ether && exp < 150 ether){\r\n            level = 1;\r\n        } else if(exp >= 150 ether && exp < 300 ether){\r\n            level = 2;\r\n        } else if(exp >= 300 ether && exp < 1500 ether){\r\n            level = 3;\r\n        } else if(exp >= 1500 ether && exp < 3000 ether){\r\n            level = 4;\r\n        } else if(exp >= 3000 ether && exp < 15000 ether){\r\n            level = 5;\r\n        } else if(exp >= 15000 ether && exp < 30000 ether){\r\n            level = 6;\r\n        } else if(exp >= 30000 ether && exp < 150000 ether){\r\n            level = 7;\r\n        } else if(exp >= 150000 ether){\r\n            level = 8;\r\n        } else{\r\n            level = 0;\r\n        }\r\n\r\n        return level;\r\n    }\r\n\r\n    function getVIPBounusRate(address user) public view returns (uint256 rate){\r\n        uint level = getVIPLevel(user);\r\n\r\n        if(level == 1){\r\n            rate = 1;\r\n        } else if(level == 2){\r\n            rate = 2;\r\n        } else if(level == 3){\r\n            rate = 3;\r\n        } else if(level == 4){\r\n            rate = 4;\r\n        } else if(level == 5){\r\n            rate = 5;\r\n        } else if(level == 6){\r\n            rate = 7;\r\n        } else if(level == 7){\r\n            rate = 9;\r\n        } else if(level == 8){\r\n            rate = 11;\r\n        } else if(level == 9){\r\n            rate = 13;\r\n        } else if(level == 10){\r\n            rate = 15;\r\n        } else{\r\n            rate = 0;\r\n        }\r\n    }\r\n}\r\n\r\ncontract AceDice {\r\n    /// *** Constants section\r\n\r\n    // Each bet is deducted 1% in favour of the house, but no less than some minimum.\r\n    // The lower bound is dictated by gas costs of the settleBet transaction, providing\r\n    // headroom for up to 10 Gwei prices.\r\n    uint constant HOUSE_EDGE_PERCENT = 1;\r\n    uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0004 ether;\r\n\r\n    // Bets lower than this amount do not participate in jackpot rolls (and are\r\n    // not deducted JACKPOT_FEE).\r\n    uint constant MIN_JACKPOT_BET = 0.1 ether;\r\n\r\n    // Chance to win jackpot (currently 0.1%) and fee deducted into jackpot fund.\r\n    uint constant JACKPOT_MODULO = 1000;\r\n    uint constant JACKPOT_FEE = 0.001 ether;\r\n\r\n    // There is minimum and maximum bets.\r\n    uint constant MIN_BET = 0.01 ether;\r\n    uint constant MAX_AMOUNT = 300000 ether;\r\n\r\n    // Modulo is a number of equiprobable outcomes in a game:\r\n    // - 2 for coin flip\r\n    // - 6 for dice\r\n    // - 6*6 = 36 for double dice\r\n    // - 100 for etheroll\r\n    // - 37 for roulette\r\n    // etc.\r\n    // It's called so because 256-bit entropy is treated like a huge integer and\r\n    // the remainder of its division by modulo is considered bet outcome.\r\n    // uint constant MAX_MODULO = 100;\r\n\r\n    // For modulos below this threshold rolls are checked against a bit mask,\r\n    // thus allowing betting on any combination of outcomes. For example, given\r\n    // modulo 6 for dice, 101000 mask (base-2, big endian) means betting on\r\n    // 4 and 6; for games with modulos higher than threshold (Etheroll), a simple\r\n    // limit is used, allowing betting on any outcome in [0, N) range.\r\n    //\r\n    // The specific value is dictated by the fact that 256-bit intermediate\r\n    // multiplication result allows implementing population count efficiently\r\n    // for numbers that are up to 42 bits, and 40 is the highest multiple of\r\n    // eight below 42.\r\n    uint constant MAX_MASK_MODULO = 40;\r\n\r\n    // This is a check on bet mask overflow.\r\n    uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO;\r\n\r\n    // EVM BLOCKHASH opcode can query no further than 256 blocks into the\r\n    // past. Given that settleBet uses block hash of placeBet as one of\r\n    // complementary entropy sources, we cannot process bets older than this\r\n    // threshold. On rare occasions AceDice croupier may fail to invoke\r\n    // settleBet in this timespan due to technical issues or extreme Ethereum\r\n    // congestion; such bets can be refunded via invoking refundBet.\r\n    uint constant BET_EXPIRATION_BLOCKS = 250;\r\n\r\n    // Some deliberately invalid address to initialize the secret signer with.\r\n    // Forces maintainers to invoke setSecretSigner before processing any bets.\r\n    address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    // Standard contract ownership transfer.\r\n    address payable public owner;\r\n    address payable private nextOwner;\r\n\r\n    // Adjustable max bet profit. Used to cap bets against dynamic odds.\r\n    uint public maxProfit;\r\n\r\n    // The address corresponding to a private key used to sign placeBet commits.\r\n    address public secretSigner;\r\n\r\n    // Accumulated jackpot fund.\r\n    uint128 public jackpotSize;\r\n\r\n    uint public todaysRewardSize;\r\n\r\n    // Funds that are locked in potentially winning bets. Prevents contract from\r\n    // committing to bets it cannot pay out.\r\n    uint128 public lockedInBets;\r\n\r\n    // A structure representing a single bet.\r\n    struct Bet {\r\n        // Wager amount in wei.\r\n        uint amount;\r\n        // Modulo of a game.\r\n        // uint8 modulo;\r\n        // Number of winning outcomes, used to compute winning payment (* modulo/rollUnder),\r\n        // and used instead of mask for games with modulo > MAX_MASK_MODULO.\r\n        uint8 rollUnder;\r\n        // Block number of placeBet tx.\r\n        uint40 placeBlockNumber;\r\n        // Bit mask representing winning bet outcomes (see MAX_MASK_MODULO comment).\r\n        uint40 mask;\r\n        // Address of a gambler, used to pay out winning bets.\r\n        address payable gambler;\r\n        // Address of inviter\r\n        address payable inviter;\r\n    }\r\n\r\n    struct Profile{\r\n        // picture index of profile avatar\r\n        uint avatarIndex;\r\n        // nickname of user\r\n        bytes32 nickName;\r\n    }\r\n\r\n    // Mapping from commits to all currently active & processed bets.\r\n    mapping (uint => Bet) bets;\r\n\r\n    mapping (address => Profile) profiles;\r\n\r\n    // Croupier account.\r\n    mapping (address => bool ) croupierMap;\r\n\r\n    address public VIPLibraryAddress;\r\n\r\n    // Events that are issued to make statistic recovery easier.\r\n    event FailedPayment(address indexed beneficiary, uint amount);\r\n    event Payment(address indexed beneficiary, uint amount, uint dice, uint rollUnder, uint betAmount);\r\n    event JackpotPayment(address indexed beneficiary, uint amount, uint dice, uint rollUnder, uint betAmount);\r\n    event VIPPayback(address indexed beneficiary, uint amount);\r\n\r\n    // This event is emitted in placeBet to record commit in the logs.\r\n    event Commit(uint commit);\r\n\r\n    // 오늘의 랭킹 보상 지급 이벤트\r\n    event TodaysRankingPayment(address indexed beneficiary, uint amount);\r\n\r\n    // Constructor. Deliberately does not take any parameters.\r\n    constructor () public {\r\n        owner = msg.sender;\r\n        secretSigner = DUMMY_ADDRESS;\r\n    }\r\n\r\n    // Standard modifier on methods invokable only by contract owner.\r\n    modifier onlyOwner {\r\n        require (msg.sender == owner, \"OnlyOwner methods called by non-owner.\");\r\n        _;\r\n    }\r\n\r\n    // Standard modifier on methods invokable only by contract owner.\r\n    modifier onlyCroupier {\r\n    bool isCroupier = croupierMap[msg.sender];\r\n        require(isCroupier, \"OnlyCroupier methods called by non-croupier.\");\r\n        _;\r\n    }\r\n\r\n    // Standard contract ownership transfer implementation,\r\n    function approveNextOwner(address payable _nextOwner) external onlyOwner {\r\n        require (_nextOwner != owner, \"Cannot approve current owner.\");\r\n        nextOwner = _nextOwner;\r\n    }\r\n\r\n    function acceptNextOwner() external {\r\n        require (msg.sender == nextOwner, \"Can only accept preapproved new owner.\");\r\n        owner = nextOwner;\r\n    }\r\n\r\n    // Fallback function deliberately left empty. It's primary use case\r\n    // is to top up the bank roll.\r\n    function () external payable {\r\n    }\r\n\r\n    // See comment for \"secretSigner\" variable.\r\n    function setSecretSigner(address newSecretSigner) external onlyOwner {\r\n        secretSigner = newSecretSigner;\r\n    }\r\n\r\n    function getSecretSigner() external onlyOwner view returns(address){\r\n        return secretSigner;\r\n    }\r\n\r\n    function addCroupier(address newCroupier) external onlyOwner {\r\n        bool isCroupier = croupierMap[newCroupier];\r\n        if (isCroupier == false) {\r\n            croupierMap[newCroupier] = true;\r\n        }\r\n    }\r\n    \r\n    function deleteCroupier(address newCroupier) external onlyOwner {\r\n        bool isCroupier = croupierMap[newCroupier];\r\n        if (isCroupier == true) {\r\n            croupierMap[newCroupier] = false;\r\n        }\r\n    }\r\n\r\n    function setVIPLibraryAddress(address addr) external onlyOwner{\r\n        VIPLibraryAddress = addr;\r\n    }\r\n\r\n    // Change max bet reward. Setting this to zero effectively disables betting.\r\n    function setMaxProfit(uint _maxProfit) public onlyOwner {\r\n        require (_maxProfit < MAX_AMOUNT, \"maxProfit should be a sane number.\");\r\n        maxProfit = _maxProfit;\r\n    }\r\n\r\n    // This function is used to bump up the jackpot fund. Cannot be used to lower it.\r\n    function increaseJackpot(uint increaseAmount) external onlyOwner {\r\n        require (increaseAmount <= address(this).balance, \"Increase amount larger than balance.\");\r\n        require (jackpotSize + lockedInBets + increaseAmount <= address(this).balance, \"Not enough funds.\");\r\n        jackpotSize += uint128(increaseAmount);\r\n    }\r\n\r\n    // Funds withdrawal to cover costs of AceDice operation.\r\n    function withdrawFunds(address payable beneficiary, uint withdrawAmount) external onlyOwner {\r\n        require (withdrawAmount <= address(this).balance, \"Increase amount larger than balance.\");\r\n        require (jackpotSize + lockedInBets + withdrawAmount <= address(this).balance, \"Not enough funds.\");\r\n        sendFunds(beneficiary, withdrawAmount, withdrawAmount, 0, 0, 0);\r\n    }\r\n\r\n    function kill() external onlyOwner {\r\n        require (lockedInBets == 0, \"All bets should be processed (settled or refunded) before self-destruct.\");\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function encodePacketCommit(uint commitLastBlock, uint commit) private pure returns(bytes memory){\r\n        return abi.encodePacked(uint40(commitLastBlock), commit);\r\n    }\r\n\r\n    function verifyCommit(uint commitLastBlock, uint commit, uint8 v, bytes32 r, bytes32 s) private view {\r\n        // Check that commit is valid - it has not expired and its signature is valid.\r\n        require (block.number <= commitLastBlock, \"Commit has expired.\");\r\n        //bytes32 signatureHash = keccak256(abi.encodePacked(commitLastBlock, commit));\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes memory message = encodePacketCommit(commitLastBlock, commit);\r\n        bytes32 messageHash = keccak256(abi.encodePacked(prefix, keccak256(message)));\r\n        require (secretSigner == ecrecover(messageHash, v, r, s), \"ECDSA signature is not valid.\");\r\n    }\r\n\r\n    function placeBet(uint betMask, uint commitLastBlock, uint commit, uint8 v, bytes32 r, bytes32 s) external payable {\r\n        // Check that the bet is in 'clean' state.\r\n        Bet storage bet = bets[commit];\r\n        require (bet.gambler == address(0), \"Bet should be in a 'clean' state.\");\r\n\r\n        // Validate input data ranges.\r\n        uint amount = msg.value;\r\n        //require (modulo > 1 && modulo <= MAX_MODULO, \"Modulo should be within range.\");\r\n        require (amount >= MIN_BET && amount <= MAX_AMOUNT, \"Amount should be within range.\");\r\n        require (betMask > 0 && betMask < MAX_BET_MASK, \"Mask should be within range.\");\r\n\r\n        verifyCommit(commitLastBlock, commit, v, r, s);\r\n\r\n        // uint rollUnder;\r\n        uint mask;\r\n\r\n        // if (modulo <= MAX_MASK_MODULO) {\r\n        //   // Small modulo games specify bet outcomes via bit mask.\r\n        //   // rollUnder is a number of 1 bits in this mask (population count).\r\n        //   // This magic looking formula is an efficient way to compute population\r\n        //   // count on EVM for numbers below 2**40. For detailed proof consult\r\n        //   // the AceDice whitepaper.\r\n        //   rollUnder = ((betMask * POPCNT_MULT) & POPCNT_MASK) % POPCNT_MODULO;\r\n        //   mask = betMask;\r\n        //   } else {\r\n        // Larger modulos specify the right edge of half-open interval of\r\n        // winning bet outcomes.\r\n        require (betMask > 0 && betMask <= 100, \"High modulo range, betMask larger than modulo.\");\r\n        // rollUnder = betMask;\r\n        // }\r\n\r\n        // Winning amount and jackpot increase.\r\n        uint possibleWinAmount;\r\n        uint jackpotFee;\r\n\r\n        (possibleWinAmount, jackpotFee) = getDiceWinAmount(amount, betMask);\r\n\r\n        // Enforce max profit limit.\r\n        require (possibleWinAmount <= amount + maxProfit, \"maxProfit limit violation. \");\r\n\r\n        // Lock funds.\r\n        lockedInBets += uint128(possibleWinAmount);\r\n        jackpotSize += uint128(jackpotFee);\r\n\r\n        // Check whether contract has enough funds to process this bet.\r\n        require (jackpotSize + lockedInBets <= address(this).balance, \"Cannot afford to lose this bet.\");\r\n\r\n        // Record commit in logs.\r\n        emit Commit(commit);\r\n\r\n        // Store bet parameters on blockchain.\r\n        bet.amount = amount;\r\n        // bet.modulo = uint8(modulo);\r\n        bet.rollUnder = uint8(betMask);\r\n        bet.placeBlockNumber = uint40(block.number);\r\n        bet.mask = uint40(mask);\r\n        bet.gambler = msg.sender;\r\n\r\n        CryptoTycoonsVIPLib vipLib = CryptoTycoonsVIPLib(VIPLibraryAddress);\r\n        vipLib.addUserExp(msg.sender, amount);\r\n    }\r\n\r\n    function applyVIPLevel(address payable gambler, uint amount) private {\r\n        CryptoTycoonsVIPLib vipLib = CryptoTycoonsVIPLib(VIPLibraryAddress);\r\n        uint rate = vipLib.getVIPBounusRate(gambler);\r\n        // uint accuAmount = accuBetAmount[gambler];\r\n        // uint rate;\r\n        // if(accuAmount >= 30 ether && accuAmount < 150 ether){\r\n        //     rate = 1;\r\n        // } else if(accuAmount >= 150 ether && accuAmount < 300 ether){\r\n        //     rate = 2;\r\n        // } else if(accuAmount >= 300 ether && accuAmount < 1500 ether){\r\n        //     rate = 4;\r\n        // } else if(accuAmount >= 1500 ether && accuAmount < 3000 ether){\r\n        //     rate = 6;\r\n        // } else if(accuAmount >= 3000 ether && accuAmount < 15000 ether){\r\n        //     rate = 8;\r\n        // } else if(accuAmount >= 15000 ether && accuAmount < 30000 ether){\r\n        //     rate = 10;\r\n        // } else if(accuAmount >= 30000 ether && accuAmount < 150000 ether){\r\n        //     rate = 12;\r\n        // } else if(accuAmount >= 150000 ether){\r\n        //     rate = 15;\r\n        // } else{\r\n        //     return;\r\n        // }\r\n        if (rate <= 0)\r\n            return;\r\n\r\n        uint vipPayback = amount * rate / 10000;\r\n        if(gambler.send(vipPayback)){\r\n            emit VIPPayback(gambler, vipPayback);\r\n        }\r\n    }\r\n\r\n    function placeBetWithInviter(uint betMask, uint commitLastBlock, uint commit, uint8 v, bytes32 r, bytes32 s, address payable inviter) external payable {\r\n        // Check that the bet is in 'clean' state.\r\n        Bet storage bet = bets[commit];\r\n        require (bet.gambler == address(0), \"Bet should be in a 'clean' state.\");\r\n\r\n        // Validate input data ranges.\r\n        uint amount = msg.value;\r\n        // require (modulo > 1 && modulo <= MAX_MODULO, \"Modulo should be within range.\");\r\n        require (amount >= MIN_BET && amount <= MAX_AMOUNT, \"Amount should be within range.\");\r\n        require (betMask > 0 && betMask < MAX_BET_MASK, \"Mask should be within range.\");\r\n        require (address(this) != inviter && inviter != address(0), \"cannot invite mysql\");\r\n\r\n        verifyCommit(commitLastBlock, commit, v, r, s);\r\n\r\n        // uint rollUnder;\r\n        uint mask;\r\n\r\n        // if (modulo <= MAX_MASK_MODULO) {\r\n        //   // Small modulo games specify bet outcomes via bit mask.\r\n        //   // rollUnder is a number of 1 bits in this mask (population count).\r\n        //   // This magic looking formula is an efficient way to compute population\r\n        //   // count on EVM for numbers below 2**40. For detailed proof consult\r\n        //   // the AceDice whitepaper.\r\n        //   rollUnder = ((betMask * POPCNT_MULT) & POPCNT_MASK) % POPCNT_MODULO;\r\n        //   mask = betMask;\r\n        // } else {\r\n        // Larger modulos specify the right edge of half-open interval of\r\n        // winning bet outcomes.\r\n        require (betMask > 0 && betMask <= 100, \"High modulo range, betMask larger than modulo.\");\r\n        // rollUnder = betMask;\r\n        // }\r\n\r\n        // Winning amount and jackpot increase.\r\n        uint possibleWinAmount;\r\n        uint jackpotFee;\r\n\r\n        (possibleWinAmount, jackpotFee) = getDiceWinAmount(amount, betMask);\r\n\r\n        // Enforce max profit limit.\r\n        require (possibleWinAmount <= amount + maxProfit, \"maxProfit limit violation. \");\r\n\r\n        // Lock funds.\r\n        lockedInBets += uint128(possibleWinAmount);\r\n        jackpotSize += uint128(jackpotFee);\r\n\r\n        // Check whether contract has enough funds to process this bet.\r\n        require (jackpotSize + lockedInBets <= address(this).balance, \"Cannot afford to lose this bet.\");\r\n\r\n        // Record commit in logs.\r\n        emit Commit(commit);\r\n\r\n        // Store bet parameters on blockchain.\r\n        bet.amount = amount;\r\n        // bet.modulo = uint8(modulo);\r\n        bet.rollUnder = uint8(betMask);\r\n        bet.placeBlockNumber = uint40(block.number);\r\n        bet.mask = uint40(mask);\r\n        bet.gambler = msg.sender;\r\n        bet.inviter = inviter;\r\n\r\n        CryptoTycoonsVIPLib vipLib = CryptoTycoonsVIPLib(VIPLibraryAddress);\r\n        vipLib.addUserExp(msg.sender, amount);\r\n    }\r\n\r\n    function getMyAccuAmount() external view returns (uint){\r\n        CryptoTycoonsVIPLib vipLib = CryptoTycoonsVIPLib(VIPLibraryAddress);\r\n        return vipLib.getUserExp(msg.sender);\r\n    }\r\n\r\n    // This is the method used to settle 99% of bets. To process a bet with a specific\r\n    // \"commit\", settleBet should supply a \"reveal\" number that would Keccak256-hash to\r\n    // \"commit\". \"blockHash\" is the block hash of placeBet block as seen by croupier; it\r\n    // is additionally asserted to prevent changing the bet outcomes on Ethereum reorgs.\r\n    function settleBet(uint reveal, bytes32 blockHash) external onlyCroupier {\r\n        uint commit = uint(keccak256(abi.encodePacked(reveal)));\r\n\r\n        Bet storage bet = bets[commit];\r\n        uint placeBlockNumber = bet.placeBlockNumber;\r\n\r\n        // Check that bet has not expired yet (see comment to BET_EXPIRATION_BLOCKS).\r\n        require (block.number > placeBlockNumber, \"settleBet in the same block as placeBet, or before.\");\r\n        require (block.number <= placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Blockhash can't be queried by EVM.\");\r\n        require (blockhash(placeBlockNumber) == blockHash);\r\n\r\n        // Settle bet using reveal and blockHash as entropy sources.\r\n        settleBetCommon(bet, reveal, blockHash);\r\n    }\r\n\r\n        // Common settlement code for settleBet & settleBetUncleMerkleProof.\r\n    function settleBetCommon(Bet storage bet, uint reveal, bytes32 entropyBlockHash) private {\r\n        // Fetch bet parameters into local variables (to save gas).\r\n        uint amount = bet.amount;\r\n        // uint modulo = bet.modulo;\r\n        uint rollUnder = bet.rollUnder;\r\n        address payable gambler = bet.gambler;\r\n\r\n        // Check that bet is in 'active' state.\r\n        require (amount != 0, \"Bet should be in an 'active' state\");\r\n\r\n        applyVIPLevel(gambler, amount);\r\n\r\n        // Move bet into 'processed' state already.\r\n        bet.amount = 0;\r\n\r\n        // The RNG - combine \"reveal\" and blockhash of placeBet using Keccak256. Miners\r\n        // are not aware of \"reveal\" and cannot deduce it from \"commit\" (as Keccak256\r\n        // preimage is intractable), and house is unable to alter the \"reveal\" after\r\n        // placeBet have been mined (as Keccak256 collision finding is also intractable).\r\n        bytes32 entropy = keccak256(abi.encodePacked(reveal, entropyBlockHash));\r\n\r\n        // Do a roll by taking a modulo of entropy. Compute winning amount.\r\n        uint modulo = 100;\r\n        uint dice = uint(entropy) % modulo;\r\n\r\n        uint diceWinAmount;\r\n        uint _jackpotFee;\r\n        (diceWinAmount, _jackpotFee) = getDiceWinAmount(amount, rollUnder);\r\n\r\n        uint diceWin = 0;\r\n        uint jackpotWin = 0;\r\n\r\n        // Determine dice outcome.\r\n        if (modulo <= MAX_MASK_MODULO) {\r\n            // For small modulo games, check the outcome against a bit mask.\r\n            if ((2 ** dice) & bet.mask != 0) {\r\n                diceWin = diceWinAmount;\r\n            }\r\n\r\n        } else {\r\n            // For larger modulos, check inclusion into half-open interval.\r\n            if (dice < rollUnder) {\r\n                diceWin = diceWinAmount;\r\n            }\r\n\r\n        }\r\n\r\n        // Unlock the bet amount, regardless of the outcome.\r\n        lockedInBets -= uint128(diceWinAmount);\r\n\r\n        // Roll for a jackpot (if eligible).\r\n        if (amount >= MIN_JACKPOT_BET) {\r\n            // The second modulo, statistically independent from the \"main\" dice roll.\r\n            // Effectively you are playing two games at once!\r\n            // uint jackpotRng = (uint(entropy) / modulo) % JACKPOT_MODULO;\r\n\r\n            // Bingo!\r\n            if ((uint(entropy) / modulo) % JACKPOT_MODULO == 0) {\r\n                jackpotWin = jackpotSize;\r\n                jackpotSize = 0;\r\n            }\r\n        }\r\n\r\n        // Log jackpot win.\r\n        if (jackpotWin > 0) {\r\n            emit JackpotPayment(gambler, jackpotWin, dice, rollUnder, amount);\r\n        }\r\n\r\n        if(bet.inviter != address(0)){\r\n            // 친구 초대하면 친구한대 15% 때어줌\r\n            // uint inviterFee = amount * HOUSE_EDGE_PERCENT / 100 * 15 /100;\r\n            bet.inviter.transfer(amount * HOUSE_EDGE_PERCENT / 100 * 10 /100);\r\n        }\r\n        todaysRewardSize += amount * HOUSE_EDGE_PERCENT / 100 * 9 /100;\r\n        // Send the funds to gambler.\r\n        sendFunds(gambler, diceWin + jackpotWin == 0 ? 1 wei : diceWin + jackpotWin, diceWin, dice, rollUnder, amount);\r\n    }\r\n\r\n    // Refund transaction - return the bet amount of a roll that was not processed in a\r\n    // due timeframe. Processing such blocks is not possible due to EVM limitations (see\r\n    // BET_EXPIRATION_BLOCKS comment above for details). In case you ever find yourself\r\n    // in a situation like this, just contact the AceDice support, however nothing\r\n    // precludes you from invoking this method yourself.\r\n    function refundBet(uint commit) external {\r\n        // Check that bet is in 'active' state.\r\n        Bet storage bet = bets[commit];\r\n        uint amount = bet.amount;\r\n\r\n        require (amount != 0, \"Bet should be in an 'active' state\");\r\n\r\n        // Check that bet has already expired.\r\n        require (block.number > bet.placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Blockhash can't be queried by EVM.\");\r\n\r\n        // Move bet into 'processed' state, release funds.\r\n        bet.amount = 0;\r\n\r\n        uint diceWinAmount;\r\n        uint jackpotFee;\r\n        (diceWinAmount, jackpotFee) = getDiceWinAmount(amount, bet.rollUnder);\r\n\r\n        lockedInBets -= uint128(diceWinAmount);\r\n        jackpotSize -= uint128(jackpotFee);\r\n\r\n        // Send the refund.\r\n        sendFunds(bet.gambler, amount, amount, 0, 0, 0);\r\n    }\r\n\r\n    // Get the expected win amount after house edge is subtracted.\r\n    function getDiceWinAmount(uint amount, uint rollUnder) private pure returns (uint winAmount, uint jackpotFee) {\r\n        require (0 < rollUnder && rollUnder <= 100, \"Win probability out of range.\");\r\n\r\n        jackpotFee = amount >= MIN_JACKPOT_BET ? JACKPOT_FEE : 0;\r\n\r\n        uint houseEdge = amount * HOUSE_EDGE_PERCENT / 100;\r\n\r\n        if (houseEdge < HOUSE_EDGE_MINIMUM_AMOUNT) {\r\n        houseEdge = HOUSE_EDGE_MINIMUM_AMOUNT;\r\n        }\r\n\r\n        require (houseEdge + jackpotFee <= amount, \"Bet doesn't even cover house edge.\");\r\n        winAmount = (amount - houseEdge - jackpotFee) * 100 / rollUnder;\r\n    }\r\n\r\n    // Helper routine to process the payment.\r\n    function sendFunds(address payable beneficiary, uint amount, uint successLogAmount, uint dice, uint rollUnder, uint betAmount) private {\r\n        if (beneficiary.send(amount)) {\r\n            emit Payment(beneficiary, successLogAmount, dice, rollUnder, betAmount);\r\n        } else {\r\n            emit FailedPayment(beneficiary, amount);\r\n        }\r\n    }\r\n\r\n    function thisBalance() public view returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function setAvatarIndex(uint index) external{\r\n        require (index >=0 && index <= 100, \"avatar index should be in range\");\r\n        Profile storage profile = profiles[msg.sender];\r\n        profile.avatarIndex = index;\r\n    }\r\n\r\n    function setNickName(bytes32 nickName) external{\r\n        Profile storage profile = profiles[msg.sender];\r\n        profile.nickName = nickName;\r\n    }\r\n\r\n    function getProfile() external view returns(uint, bytes32){\r\n        Profile storage profile = profiles[msg.sender];\r\n        return (profile.avatarIndex, profile.nickName);\r\n    }\r\n\r\n    function payTodayReward(address payable to) external onlyOwner {\r\n        uint prize = todaysRewardSize / 2;\r\n        todaysRewardSize = todaysRewardSize - prize;\r\n        if(to.send(prize)){\r\n            emit TodaysRankingPayment(to, prize);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"thisBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"payTodayReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setVIPLibraryAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"setAvatarIndex\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCroupier\",\"type\":\"address\"}],\"name\":\"addCroupier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secretSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nickName\",\"type\":\"bytes32\"}],\"name\":\"setNickName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMyAccuAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSecretSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VIPLibraryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"todaysRewardSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint256\"},{\"name\":\"commitLastBlock\",\"type\":\"uint256\"},{\"name\":\"commit\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"placeBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reveal\",\"type\":\"uint256\"},{\"name\":\"blockHash\",\"type\":\"bytes32\"}],\"name\":\"settleBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCroupier\",\"type\":\"address\"}],\"name\":\"deleteCroupier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nextOwner\",\"type\":\"address\"}],\"name\":\"approveNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProfile\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"increaseAmount\",\"type\":\"uint256\"}],\"name\":\"increaseJackpot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newSecretSigner\",\"type\":\"address\"}],\"name\":\"setSecretSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedInBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint256\"},{\"name\":\"commitLastBlock\",\"type\":\"uint256\"},{\"name\":\"commit\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"inviter\",\"type\":\"address\"}],\"name\":\"placeBetWithInviter\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"refundBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxProfit\",\"type\":\"uint256\"}],\"name\":\"setMaxProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FailedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rollUnder\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"betAmount\",\"type\":\"uint256\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rollUnder\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"betAmount\",\"type\":\"uint256\"}],\"name\":\"JackpotPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VIPPayback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"Commit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TodaysRankingPayment\",\"type\":\"event\"}]","ContractName":"AceDice","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3806e5513fe5056ac17e887cac6c9c26154c52d781420035982c096416a3f8c3"}]}