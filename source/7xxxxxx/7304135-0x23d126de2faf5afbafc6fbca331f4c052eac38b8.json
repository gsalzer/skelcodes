{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n// thanks to https://github.com/willitscale/solidity-util and https://github.com/Arachnid/solidity-stringutils\r\nlibrary StringUtils {\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire string.\r\n     * @param self The string to make a slice from.\r\n     * @return A newly allocated slice containing the entire string.\r\n     */\r\n    function toSlice(string memory self) internal pure returns (slice memory ) {\r\n        uint ptr;\r\n        assembly { ptr := add(self, 0x20) } // solium-disable-line security/no-inline-assembly\r\n        return slice(bytes(self).length, ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a new slice containing the same data as the current slice.\r\n     * @param self The slice to copy.\r\n     * @return A new slice containing the same data as `self`.\r\n     */\r\n    function copy(slice memory self) internal pure returns (slice memory ) {\r\n        return slice(self._len, self._ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Copies a slice to a new string.\r\n     * @param self The slice to copy.\r\n     * @return A newly allocated string containing the slice's text.\r\n     */\r\n    function toString(slice memory self) internal pure returns (string memory ) {\r\n        string memory ret = new string(self._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 0x20) } // solium-disable-line security/no-inline-assembly\r\n\r\n        memcpy(retptr, self._ptr, self._len);\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n    * Lower\r\n    *\r\n    * Converts all the values of a string to their corresponding lower case\r\n    * value.\r\n    *\r\n    * @param _base When being used for a data type this is the extended object\r\n    *              otherwise this is the string base to convert to lower case\r\n    * @return string\r\n    */\r\n    function lower(string memory _base) internal pure returns (string memory ) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        for (uint i = 0; i < _baseBytes.length; i++) {\r\n            _baseBytes[i] = _lower(_baseBytes[i]);\r\n        }\r\n        return string(_baseBytes);\r\n    }\r\n\r\n    /**\r\n    * Lower\r\n    *\r\n    * Convert an alphabetic character to lower case and return the original\r\n    * value when not alphabetic\r\n    *\r\n    * @param _b1 The byte to be converted to lower case\r\n    * @return bytes1 The converted value if the passed value was alphabetic\r\n    *                and in a upper case otherwise returns the original value\r\n    */\r\n    function _lower(bytes1 _b1) internal pure returns (bytes1) {\r\n        if (_b1 >= 0x41 && _b1 <= 0x5A) {\r\n            return bytes1(uint8(_b1) + 32);\r\n        }\r\n        return _b1;\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private pure { // solium-disable-line security/no-assign-params\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly { mstore(dest, mload(src)) } // solium-disable-line security/no-inline-assembly\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}\r\n\r\ninterface OldClientRaindropInterface {\r\n    function userNameTaken(string calldata userName) external view returns (bool);\r\n    function getUserByName(string calldata userName) external view returns (string memory, address);\r\n}\r\n\r\n/**\r\n* @title Ownable\r\n* @dev The Ownable contract has an owner address, and provides basic authorization control\r\n* functions, this simplifies the implementation of \"user permissions\".\r\n*/\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor() public {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n    * @return the address of the owner.\r\n    */\r\n    function owner() public view returns(address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @return true if `msg.sender` is the owner of the contract.\r\n    */\r\n    function isOwner() public view returns(bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to relinquish control of the contract.\r\n    * @notice Renouncing to ownership will leave the contract without an owner.\r\n    * It will not be possible to call the functions with the `onlyOwner`\r\n    * modifier anymore.\r\n    */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface HydroInterface {\r\n    function balances(address) external view returns (uint);\r\n    function allowed(address, address) external view returns (uint);\r\n    function transfer(address _to, uint256 _amount) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool success);\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n    function approve(address _spender, uint256 _amount) external returns (bool success);\r\n    function approveAndCall(address _spender, uint256 _value, bytes calldata _extraData)\r\n        external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function authenticate(uint _value, uint _challenge, uint _partnerId) external;\r\n}\r\n\r\ninterface SnowflakeInterface {\r\n    function deposits(uint) external view returns (uint);\r\n    function resolverAllowances(uint, address) external view returns (uint);\r\n\r\n    function identityRegistryAddress() external returns (address);\r\n    function hydroTokenAddress() external returns (address);\r\n    function clientRaindropAddress() external returns (address);\r\n\r\n    function setAddresses(address _identityRegistryAddress, address _hydroTokenAddress) external;\r\n    function setClientRaindropAddress(address _clientRaindropAddress) external;\r\n\r\n    function createIdentityDelegated(\r\n        address recoveryAddress, address associatedAddress, address[] calldata providers, string calldata casedHydroId,\r\n        uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external returns (uint ein);\r\n    function addProvidersFor(\r\n        address approvingAddress, address[] calldata providers, uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external;\r\n    function removeProvidersFor(\r\n        address approvingAddress, address[] calldata providers, uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external;\r\n    function upgradeProvidersFor(\r\n        address approvingAddress, address[] calldata newProviders, address[] calldata oldProviders,\r\n        uint8[2] calldata v, bytes32[2] calldata r, bytes32[2] calldata s, uint[2] calldata timestamp\r\n    ) external;\r\n    function addResolver(address resolver, bool isSnowflake, uint withdrawAllowance, bytes calldata extraData) external;\r\n    function addResolverAsProvider(\r\n        uint ein, address resolver, bool isSnowflake, uint withdrawAllowance, bytes calldata extraData\r\n    ) external;\r\n    function addResolverFor(\r\n        address approvingAddress, address resolver, bool isSnowflake, uint withdrawAllowance, bytes calldata extraData,\r\n        uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external;\r\n    function changeResolverAllowances(address[] calldata resolvers, uint[] calldata withdrawAllowances) external;\r\n    function changeResolverAllowancesDelegated(\r\n        address approvingAddress, address[] calldata resolvers, uint[] calldata withdrawAllowances,\r\n        uint8 v, bytes32 r, bytes32 s\r\n    ) external;\r\n    function removeResolver(address resolver, bool isSnowflake, bytes calldata extraData) external;\r\n    function removeResolverFor(\r\n        address approvingAddress, address resolver, bool isSnowflake, bytes calldata extraData,\r\n        uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external;\r\n\r\n    function triggerRecoveryAddressChangeFor(\r\n        address approvingAddress, address newRecoveryAddress, uint8 v, bytes32 r, bytes32 s\r\n    ) external;\r\n\r\n    function transferSnowflakeBalance(uint einTo, uint amount) external;\r\n    function withdrawSnowflakeBalance(address to, uint amount) external;\r\n    function transferSnowflakeBalanceFrom(uint einFrom, uint einTo, uint amount) external;\r\n    function withdrawSnowflakeBalanceFrom(uint einFrom, address to, uint amount) external;\r\n    function transferSnowflakeBalanceFromVia(uint einFrom, address via, uint einTo, uint amount, bytes calldata _bytes)\r\n        external;\r\n    function withdrawSnowflakeBalanceFromVia(uint einFrom, address via, address to, uint amount, bytes calldata _bytes)\r\n        external;\r\n}\r\n\r\ninterface SnowflakeResolverInterface {\r\n    function callOnAddition() external view returns (bool);\r\n    function callOnRemoval() external view returns (bool);\r\n    function onAddition(uint ein, uint allowance, bytes calldata extraData) external returns (bool);\r\n    function onRemoval(uint ein, bytes calldata extraData) external returns (bool);\r\n}\r\n\r\ncontract SnowflakeResolver is Ownable {\r\n    string public snowflakeName;\r\n    string public snowflakeDescription;\r\n\r\n    address public snowflakeAddress;\r\n\r\n    bool public callOnAddition;\r\n    bool public callOnRemoval;\r\n\r\n    constructor(\r\n        string memory _snowflakeName, string memory _snowflakeDescription,\r\n        address _snowflakeAddress,\r\n        bool _callOnAddition, bool _callOnRemoval\r\n    )\r\n        public\r\n    {\r\n        snowflakeName = _snowflakeName;\r\n        snowflakeDescription = _snowflakeDescription;\r\n\r\n        setSnowflakeAddress(_snowflakeAddress);\r\n\r\n        callOnAddition = _callOnAddition;\r\n        callOnRemoval = _callOnRemoval;\r\n    }\r\n\r\n    modifier senderIsSnowflake() {\r\n        require(msg.sender == snowflakeAddress, \"Did not originate from Snowflake.\");\r\n        _;\r\n    }\r\n\r\n    // this can be overriden to initialize other variables, such as e.g. an ERC20 object to wrap the HYDRO token\r\n    function setSnowflakeAddress(address _snowflakeAddress) public onlyOwner {\r\n        snowflakeAddress = _snowflakeAddress;\r\n    }\r\n\r\n    // if callOnAddition is true, onAddition is called every time a user adds the contract as a resolver\r\n    // this implementation **must** use the senderIsSnowflake modifier\r\n    // returning false will disallow users from adding the contract as a resolver\r\n    function onAddition(uint ein, uint allowance, bytes memory extraData) public returns (bool);\r\n\r\n    // if callOnRemoval is true, onRemoval is called every time a user removes the contract as a resolver\r\n    // this function **must** use the senderIsSnowflake modifier\r\n    // returning false soft prevents users from removing the contract as a resolver\r\n    // however, note that they can force remove the resolver, bypassing onRemoval\r\n    function onRemoval(uint ein, bytes memory extraData) public returns (bool);\r\n\r\n    function transferHydroBalanceTo(uint einTo, uint amount) internal {\r\n        HydroInterface hydro = HydroInterface(SnowflakeInterface(snowflakeAddress).hydroTokenAddress());\r\n        require(hydro.approveAndCall(snowflakeAddress, amount, abi.encode(einTo)), \"Unsuccessful approveAndCall.\");\r\n    }\r\n\r\n    function withdrawHydroBalanceTo(address to, uint amount) internal {\r\n        HydroInterface hydro = HydroInterface(SnowflakeInterface(snowflakeAddress).hydroTokenAddress());\r\n        require(hydro.transfer(to, amount), \"Unsuccessful transfer.\");\r\n    }\r\n\r\n    function transferHydroBalanceToVia(address via, uint einTo, uint amount, bytes memory snowflakeCallBytes) internal {\r\n        HydroInterface hydro = HydroInterface(SnowflakeInterface(snowflakeAddress).hydroTokenAddress());\r\n        require(\r\n            hydro.approveAndCall(\r\n                snowflakeAddress, amount, abi.encode(true, address(this), via, einTo, snowflakeCallBytes)\r\n            ),\r\n            \"Unsuccessful approveAndCall.\"\r\n        );\r\n    }\r\n\r\n    function withdrawHydroBalanceToVia(address via, address to, uint amount, bytes memory snowflakeCallBytes) internal {\r\n        HydroInterface hydro = HydroInterface(SnowflakeInterface(snowflakeAddress).hydroTokenAddress());\r\n        require(\r\n            hydro.approveAndCall(\r\n                snowflakeAddress, amount, abi.encode(false, address(this), via, to, snowflakeCallBytes)\r\n            ),\r\n            \"Unsuccessful approveAndCall.\"\r\n        );\r\n    }\r\n}\r\n\r\ninterface IdentityRegistryInterface {\r\n    function isSigned(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s)\r\n        external pure returns (bool);\r\n\r\n    // Identity View Functions /////////////////////////////////////////////////////////////////////////////////////////\r\n    function identityExists(uint ein) external view returns (bool);\r\n    function hasIdentity(address _address) external view returns (bool);\r\n    function getEIN(address _address) external view returns (uint ein);\r\n    function isAssociatedAddressFor(uint ein, address _address) external view returns (bool);\r\n    function isProviderFor(uint ein, address provider) external view returns (bool);\r\n    function isResolverFor(uint ein, address resolver) external view returns (bool);\r\n    function getIdentity(uint ein) external view returns (\r\n        address recoveryAddress,\r\n        address[] memory associatedAddresses, address[] memory providers, address[] memory resolvers\r\n    );\r\n\r\n    // Identity Management Functions ///////////////////////////////////////////////////////////////////////////////////\r\n    function createIdentity(address recoveryAddress, address[] calldata providers, address[] calldata resolvers)\r\n        external returns (uint ein);\r\n    function createIdentityDelegated(\r\n        address recoveryAddress, address associatedAddress, address[] calldata providers, address[] calldata resolvers,\r\n        uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external returns (uint ein);\r\n    function addAssociatedAddress(\r\n        address approvingAddress, address addressToAdd, uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external;\r\n    function addAssociatedAddressDelegated(\r\n        address approvingAddress, address addressToAdd,\r\n        uint8[2] calldata v, bytes32[2] calldata r, bytes32[2] calldata s, uint[2] calldata timestamp\r\n    ) external;\r\n    function removeAssociatedAddress() external;\r\n    function removeAssociatedAddressDelegated(address addressToRemove, uint8 v, bytes32 r, bytes32 s, uint timestamp)\r\n        external;\r\n    function addProviders(address[] calldata providers) external;\r\n    function addProvidersFor(uint ein, address[] calldata providers) external;\r\n    function removeProviders(address[] calldata providers) external;\r\n    function removeProvidersFor(uint ein, address[] calldata providers) external;\r\n    function addResolvers(address[] calldata resolvers) external;\r\n    function addResolversFor(uint ein, address[] calldata resolvers) external;\r\n    function removeResolvers(address[] calldata resolvers) external;\r\n    function removeResolversFor(uint ein, address[] calldata resolvers) external;\r\n\r\n    // Recovery Management Functions ///////////////////////////////////////////////////////////////////////////////////\r\n    function triggerRecoveryAddressChange(address newRecoveryAddress) external;\r\n    function triggerRecoveryAddressChangeFor(uint ein, address newRecoveryAddress) external;\r\n    function triggerRecovery(uint ein, address newAssociatedAddress, uint8 v, bytes32 r, bytes32 s, uint timestamp)\r\n        external;\r\n    function triggerDestruction(\r\n        uint ein, address[] calldata firstChunk, address[] calldata lastChunk, bool resetResolvers\r\n    ) external;\r\n}\r\n\r\ncontract ClientRaindrop is SnowflakeResolver {\r\n    // attach the StringUtils library\r\n    using StringUtils for string;\r\n    using StringUtils for StringUtils.slice;\r\n\r\n    // other SCs\r\n    HydroInterface private hydroToken;\r\n    IdentityRegistryInterface private identityRegistry;\r\n    OldClientRaindropInterface private oldClientRaindrop;\r\n\r\n    // staking requirements\r\n    uint public hydroStakeUser;\r\n    uint public hydroStakeDelegatedUser;\r\n\r\n    // User account template\r\n    struct User {\r\n        uint ein;\r\n        address _address;\r\n        string casedHydroID;\r\n        bool initialized;\r\n        bool destroyed;\r\n    }\r\n\r\n    // Mapping from uncased hydroID hashes to users\r\n    mapping (bytes32 => User) private userDirectory;\r\n    // Mapping from EIN to uncased hydroID hashes\r\n    mapping (uint => bytes32) private einDirectory;\r\n    // Mapping from address to uncased hydroID hashes\r\n    mapping (address => bytes32) private addressDirectory;\r\n\r\n    constructor(\r\n        address snowflakeAddress, address oldClientRaindropAddress, uint _hydroStakeUser, uint _hydroStakeDelegatedUser\r\n    )\r\n        SnowflakeResolver(\r\n            \"Client Raindrop\", \"A registry that links EINs to HydroIDs to power Client Raindrop MFA.\",\r\n            snowflakeAddress,\r\n            true, true\r\n        )\r\n        public\r\n    {\r\n        setSnowflakeAddress(snowflakeAddress);\r\n        setOldClientRaindropAddress(oldClientRaindropAddress);\r\n        setStakes(_hydroStakeUser, _hydroStakeDelegatedUser);\r\n    }\r\n\r\n    // Requires an address to have a minimum number of Hydro\r\n    modifier requireStake(address _address, uint stake) {\r\n        require(hydroToken.balanceOf(_address) >= stake, \"Insufficient staked HYDRO balance.\");\r\n        _;\r\n    }\r\n\r\n    // set the snowflake address, and hydro token + identity registry contract wrappers\r\n    function setSnowflakeAddress(address snowflakeAddress) public onlyOwner() {\r\n        super.setSnowflakeAddress(snowflakeAddress);\r\n\r\n        SnowflakeInterface snowflake = SnowflakeInterface(snowflakeAddress);\r\n        hydroToken = HydroInterface(snowflake.hydroTokenAddress());\r\n        identityRegistry = IdentityRegistryInterface(snowflake.identityRegistryAddress());\r\n    }\r\n\r\n    // set the old client raindrop address\r\n    function setOldClientRaindropAddress(address oldClientRaindropAddress) public onlyOwner() {\r\n        oldClientRaindrop = OldClientRaindropInterface(oldClientRaindropAddress);\r\n    }\r\n\r\n    // set minimum hydro balances required for sign ups\r\n    function setStakes(uint _hydroStakeUser, uint _hydroStakeDelegatedUser) public onlyOwner() {\r\n        // <= the airdrop amount\r\n        require(_hydroStakeUser <= 222222 * 10**18, \"Stake is too high.\");\r\n        hydroStakeUser = _hydroStakeDelegatedUser;\r\n\r\n        // <= 1% of total supply\r\n        require(_hydroStakeDelegatedUser <= hydroToken.totalSupply() / 100, \"Stake is too high.\");\r\n        hydroStakeDelegatedUser = _hydroStakeDelegatedUser;\r\n    }\r\n\r\n    // function for users calling signup for themselves\r\n    function signUp(address _address, string memory casedHydroId) public requireStake(msg.sender, hydroStakeUser) {\r\n        _signUp(identityRegistry.getEIN(msg.sender), casedHydroId, _address);\r\n    }\r\n\r\n    // function for users signing up through the snowflake provider\r\n    function onAddition(uint ein, uint, bytes memory extraData)\r\n        // solium-disable-next-line security/no-tx-origin\r\n        public senderIsSnowflake() requireStake(tx.origin, hydroStakeDelegatedUser) returns (bool)\r\n    {\r\n        (address _address, string memory casedHydroID) = abi.decode(extraData, (address, string));\r\n        require(identityRegistry.isProviderFor(ein, msg.sender), \"Snowflake is not a Provider for the passed EIN.\");\r\n        _signUp(ein, casedHydroID, _address);\r\n     \r\n        return true;\r\n    }\r\n\r\n    // Common internal logic for all user signups\r\n    function _signUp(uint ein, string memory casedHydroID, address _address) internal {\r\n        require(bytes(casedHydroID).length > 2 && bytes(casedHydroID).length < 33, \"HydroID has invalid length.\");\r\n        require(identityRegistry.isResolverFor(ein, address(this)), \"The passed EIN has not set this resolver.\");\r\n        require(\r\n            identityRegistry.isAssociatedAddressFor(ein, _address),\r\n            \"The passed address is not associated with the calling Identity.\"\r\n        );\r\n        checkForOldHydroID(casedHydroID, _address);\r\n\r\n        bytes32 uncasedHydroIDHash = keccak256(abi.encodePacked(casedHydroID.toSlice().copy().toString().lower()));\r\n        // check conditions specific to this resolver\r\n        require(hydroIDAvailable(uncasedHydroIDHash), \"HydroID is unavailable.\");\r\n        require(einDirectory[ein] == bytes32(0), \"EIN is already mapped to a HydroID.\");\r\n        require(addressDirectory[_address] == bytes32(0), \"Address is already mapped to a HydroID.\");\r\n\r\n        // update mappings\r\n        userDirectory[uncasedHydroIDHash] = User(ein, _address, casedHydroID, true, false);\r\n        einDirectory[ein] = uncasedHydroIDHash;\r\n        addressDirectory[_address] = uncasedHydroIDHash;\r\n\r\n        emit HydroIDClaimed(ein, casedHydroID, _address);\r\n    }\r\n\r\n    function checkForOldHydroID(string memory casedHydroID, address _address) public view {\r\n        bool usernameTaken = oldClientRaindrop.userNameTaken(casedHydroID);\r\n        if (usernameTaken) {\r\n            (, address takenAddress) = oldClientRaindrop.getUserByName(casedHydroID);\r\n            require(_address == takenAddress, \"This Hydro ID is already claimed by another address.\");\r\n        }\r\n    }\r\n\r\n    function onRemoval(uint ein, bytes memory) public senderIsSnowflake() returns (bool) {\r\n        bytes32 uncasedHydroIDHash = einDirectory[ein];\r\n        assert(uncasedHydroIDHashActive(uncasedHydroIDHash));\r\n\r\n        emit HydroIDDestroyed(\r\n            ein, userDirectory[uncasedHydroIDHash].casedHydroID, userDirectory[uncasedHydroIDHash]._address\r\n        );\r\n\r\n        delete addressDirectory[userDirectory[uncasedHydroIDHash]._address];\r\n        delete einDirectory[ein];\r\n        delete userDirectory[uncasedHydroIDHash].casedHydroID;\r\n        delete userDirectory[uncasedHydroIDHash]._address;\r\n        userDirectory[uncasedHydroIDHash].destroyed = true;\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    // returns whether a given hydroID is available\r\n    function hydroIDAvailable(string memory uncasedHydroID) public view returns (bool available) {\r\n        return hydroIDAvailable(keccak256(abi.encodePacked(uncasedHydroID.lower())));\r\n    }\r\n\r\n    // Returns a bool indicating whether a given uncasedHydroIDHash is available\r\n    function hydroIDAvailable(bytes32 uncasedHydroIDHash) private view returns (bool) {\r\n        return !userDirectory[uncasedHydroIDHash].initialized;\r\n    }\r\n\r\n    // returns whether a given hydroID is destroyed\r\n    function hydroIDDestroyed(string memory uncasedHydroID) public view returns (bool destroyed) {\r\n        return hydroIDDestroyed(keccak256(abi.encodePacked(uncasedHydroID.lower())));\r\n    }\r\n\r\n    // Returns a bool indicating whether a given hydroID is destroyed\r\n    function hydroIDDestroyed(bytes32 uncasedHydroIDHash) private view returns (bool) {\r\n        return userDirectory[uncasedHydroIDHash].destroyed;\r\n    }\r\n\r\n    // returns whether a given hydroID is active\r\n    function hydroIDActive(string memory uncasedHydroID) public view returns (bool active) {\r\n        return uncasedHydroIDHashActive(keccak256(abi.encodePacked(uncasedHydroID.lower())));\r\n    }\r\n\r\n    // Returns a bool indicating whether a given hydroID is active\r\n    function uncasedHydroIDHashActive(bytes32 uncasedHydroIDHash) private view returns (bool) {\r\n        return !hydroIDAvailable(uncasedHydroIDHash) && !hydroIDDestroyed(uncasedHydroIDHash);\r\n    }\r\n\r\n\r\n    // Returns details by uncased hydroID\r\n    function getDetails(string memory uncasedHydroID) public view\r\n        returns (uint ein, address _address, string memory casedHydroID)\r\n    {\r\n        User storage user = getDetails(keccak256(abi.encodePacked(uncasedHydroID.lower())));\r\n        return (user.ein, user._address, user.casedHydroID);\r\n    }\r\n\r\n    // Returns details by EIN\r\n    function getDetails(uint ein) public view returns (address _address, string memory casedHydroID) {\r\n        User storage user = getDetails(einDirectory[ein]);\r\n        return (user._address, user.casedHydroID);\r\n    }\r\n\r\n    // Returns details by address\r\n    function getDetails(address _address) public view returns (uint ein, string memory casedHydroID) {\r\n        User storage user = getDetails(addressDirectory[_address]);\r\n        return (user.ein, user.casedHydroID);\r\n    }\r\n\r\n    // common logic for all getDetails\r\n    function getDetails(bytes32 uncasedHydroIDHash) private view returns (User storage) {\r\n        require(uncasedHydroIDHashActive(uncasedHydroIDHash), \"HydroID is not active.\");\r\n        return userDirectory[uncasedHydroIDHash];\r\n    }\r\n\r\n    // Events for when a user signs up for Raindrop Client and when their account is deleted\r\n    event HydroIDClaimed(uint indexed ein, string hydroID, address userAddress);\r\n    event HydroIDDestroyed(uint indexed ein, string hydroID, address userAddress);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"uncasedHydroID\",\"type\":\"string\"}],\"name\":\"getDetails\",\"outputs\":[{\"name\":\"ein\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"casedHydroID\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getDetails\",\"outputs\":[{\"name\":\"ein\",\"type\":\"uint256\"},{\"name\":\"casedHydroID\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hydroStakeUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hydroStakeDelegatedUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"callOnAddition\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"snowflakeDescription\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"oldClientRaindropAddress\",\"type\":\"address\"}],\"name\":\"setOldClientRaindropAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"snowflakeName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"callOnRemoval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ein\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"onAddition\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ein\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onRemoval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"casedHydroID\",\"type\":\"string\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"checkForOldHydroID\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uncasedHydroID\",\"type\":\"string\"}],\"name\":\"hydroIDActive\",\"outputs\":[{\"name\":\"active\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uncasedHydroID\",\"type\":\"string\"}],\"name\":\"hydroIDAvailable\",\"outputs\":[{\"name\":\"available\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"casedHydroId\",\"type\":\"string\"}],\"name\":\"signUp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ein\",\"type\":\"uint256\"}],\"name\":\"getDetails\",\"outputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"casedHydroID\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hydroStakeUser\",\"type\":\"uint256\"},{\"name\":\"_hydroStakeDelegatedUser\",\"type\":\"uint256\"}],\"name\":\"setStakes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"snowflakeAddress\",\"type\":\"address\"}],\"name\":\"setSnowflakeAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uncasedHydroID\",\"type\":\"string\"}],\"name\":\"hydroIDDestroyed\",\"outputs\":[{\"name\":\"destroyed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"snowflakeAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"snowflakeAddress\",\"type\":\"address\"},{\"name\":\"oldClientRaindropAddress\",\"type\":\"address\"},{\"name\":\"_hydroStakeUser\",\"type\":\"uint256\"},{\"name\":\"_hydroStakeDelegatedUser\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ein\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hydroID\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"HydroIDClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ein\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hydroID\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"HydroIDDestroyed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ClientRaindrop","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000094a65bac5f601503847ee9ec5beaca92a511af92000000000000000000000000c58466b48d4f1554ac999920e358aeaf6de63a4700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://eb4a5fb729aa2158298f159ad6868319f07aa77122eb50e6479cd982da362936"}]}