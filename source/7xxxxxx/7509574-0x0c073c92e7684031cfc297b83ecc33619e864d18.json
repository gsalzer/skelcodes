{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.6;\r\n\r\n// * xether.io - is a gambling ecosystem, which makes a difference by caring about its users.\r\n// Itâ€™s our passion for perfection, as well as finding and creating neat solutions,\r\n// that keeps us driven towards our goals.\r\n//\r\n// * Uses hybrid commit-reveal + block hash random number generation that is immune\r\n//   to tampering by players, house and miners. Apart from being fully transparent,\r\n//   this also allows arbitrarily high bets.\r\n\r\n\r\ninterface xEtherTokensContractInterface {\r\n  function ecosystemDividends() external payable;\r\n}\r\n\r\ncontract XetherGames {\r\n    uint256 constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether;\r\n    uint256 constant MIN_JACKPOT_BET = 0.1 ether;\r\n    uint16 constant JACKPOT_MODULO = 1000;\r\n    uint256 constant JACKPOT_FEE = 0.001 ether;\r\n    uint256 constant MIN_BET = 0.01 ether;\r\n    uint256 constant MAX_AMOUNT = 300000 ether;\r\n    uint8 constant MAX_MODULO = 100;\r\n    uint8 constant MAX_MASK_MODULO = 40;\r\n    uint256 constant MAX_BET_MASK = 2 ** uint256(MAX_MASK_MODULO);\r\n    uint8 constant BET_EXPIRATION_BLOCKS = 250;\r\n    uint256 public DIVIDENDS_LIMIT = 1 ether;\r\n    uint16 constant PERCENTAGES_BASE = 1000;\r\n    address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    uint16 public luckyNumber = 777;\r\n\r\n    uint8 public DIVIDENDS_PERCENT = 10; // 1% example: 15 will be 1.5%\r\n    uint8 public ADVERTISE_PERCENT = 0; // 0%\r\n    uint8 public HOUSE_EDGE_PERCENT = 10; // 1%\r\n\r\n    uint8 constant ROULETTE_ID = 37;\r\n    uint8 constant ROULETTE_STAKES_LIMIT = 36;\r\n    uint8 public rouletteSkipComission = 1;\r\n    uint256 public rouletteTableLimit = 1.8 ether;\r\n    uint8 public ROULETTE_PERCENT = 10;\r\n\r\n    uint8 constant PLINKO_BYTES = 16;\r\n    uint256 constant PLINKO_ID = 2 ** uint256(PLINKO_BYTES);\r\n    uint16[17] PLINKO1Ratios = [1000,800,600,300,200,130,100,80,50,80,100,130,200,300,600,800,1000];\r\n    uint16[17] PLINKO2Ratios = [2000,700,500,300,200,110,100,60,100,60,100,110,200,300,500,700,2000];\r\n    uint16[17] PLINKO3Ratios = [5000,800,300,200,140,120,110,100,40,100,110,120,140,200,300,800,5000];\r\n    uint8 public plinkoSkipComission = 2;\r\n    uint8 public PLINKO_PERCENT = HOUSE_EDGE_PERCENT;\r\n\r\n    uint16 constant SLOTS_ID = 999;\r\n    uint8 constant SLOTS_COUNT = 5;\r\n    uint16[] SLOTSWinsRatios = [0, 50, 120, 200, 1500];\r\n    uint32[] SLOTSWildRatios = [0, 110, 250, 400, 3000, 10000];\r\n\r\n    xEtherTokensContractInterface public xEtherTokensContract;\r\n\r\n    address payable public owner;\r\n    address payable private nextOwner;\r\n\r\n    uint256 public totalDividends = 0;\r\n    uint256 public totalAdvertise = 0;\r\n\r\n    uint256 public maxProfit = 5 ether;\r\n    uint256 public maxProfitPlinko = 10 ether;\r\n    uint256 public maxProfitRoulette = 3.6 ether;\r\n\r\n    address public secretSigner;\r\n    address public moderator;\r\n    address public croupier;\r\n    uint128 public jackpotSize;\r\n    uint128 public lockedInBets;\r\n\r\n    struct Bet {\r\n        uint256 amount;\r\n        uint128 locked;\r\n        uint32 modulo;\r\n        uint8 rollUnder;\r\n        uint40 placeBlockNumber;\r\n        uint256 clientSeed;\r\n        uint40 mask;\r\n        address payable gambler;\r\n    }\r\n\r\n    struct BetRoulette {\r\n      uint256 totalBetAmount;\r\n      uint128 locked;\r\n      mapping (uint8 => uint256) amount;\r\n      mapping (uint8 => uint8) rollUnder;\r\n      uint40 placeBlockNumber;\r\n      uint256 clientSeed;\r\n      mapping (uint8 => uint40) mask;\r\n      address payable gambler;\r\n      uint8 betsCount;\r\n    }\r\n\r\n    mapping (uint => Bet) bets;\r\n    mapping (uint => BetRoulette) betsRoulette;\r\n    mapping (address => uint256) public bonusProgrammAccumulated;\r\n\r\n    event FailedPayment(address beneficiary, uint commit, uint amount, string paymentType);\r\n    event Payment(address beneficiary, uint commit, uint amount, string paymentType);\r\n    event JackpotPayment(address indexed beneficiary, uint commit, uint amount);\r\n\r\n    event PayDividendsSuccess(uint time, uint amount);\r\n    event PayDividendsFailed(uint time, uint amount);\r\n\r\n    event Commit(uint commit, uint clietSeed, uint amount);\r\n\r\n    constructor () public {\r\n        owner = msg.sender;\r\n        secretSigner = DUMMY_ADDRESS;\r\n        croupier = DUMMY_ADDRESS;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require (msg.sender == owner, \"OnlyOwner methods called by non-owner.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyModeration {\r\n        require (msg.sender == owner || msg.sender == moderator, \"Moderation methods called by non-moderator.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyCroupier {\r\n        require (msg.sender == croupier, \"OnlyCroupier methods called by non-croupier.\");\r\n        _;\r\n    }\r\n\r\n    function approveNextOwner(address payable _nextOwner) external onlyOwner {\r\n        require (_nextOwner != owner, \"Cannot approve current owner.\");\r\n        nextOwner = _nextOwner;\r\n    }\r\n\r\n    function acceptNextOwner() external {\r\n        require (msg.sender == nextOwner, \"Can only accept preapproved new owner.\");\r\n        owner = nextOwner;\r\n    }\r\n\r\n    function () external payable {\r\n    }\r\n\r\n    function setNewPercents(\r\n      uint8 newHouseEdgePercent,\r\n      uint8 newDividendsPercent,\r\n      uint8 newAdvertPercent\r\n    ) external onlyOwner {\r\n        // We guarantee that dividends will be minimum 0.5%\r\n        require(newDividendsPercent >= 5);\r\n        // Total percentages not greater then 3%\r\n        require(newHouseEdgePercent + newDividendsPercent + newAdvertPercent <= 30);\r\n\r\n        HOUSE_EDGE_PERCENT = newHouseEdgePercent;\r\n        ADVERTISE_PERCENT = newAdvertPercent;\r\n        DIVIDENDS_PERCENT = newDividendsPercent;\r\n    }\r\n\r\n    function setNewRoulettePercents(uint8 newRoulettePercent) external onlyModeration {\r\n        require(0 <= newRoulettePercent && newRoulettePercent <= 10);\r\n        ROULETTE_PERCENT = newRoulettePercent;\r\n    }\r\n\r\n    function setNewPlinkoPercents(uint8 newPlinkoPercent) external onlyModeration {\r\n        require(0 <= newPlinkoPercent && newPlinkoPercent <= 10);\r\n        PLINKO_PERCENT = newPlinkoPercent;\r\n    }\r\n\r\n    function setXEtherContract(address payable xEtherContract) external onlyOwner{\r\n        xEtherTokensContract = xEtherTokensContractInterface(xEtherContract);\r\n    }\r\n\r\n    function setAddresses(address newCroupier, address newSecretSigner, address newModerator) external onlyOwner {\r\n        secretSigner = newSecretSigner;\r\n        croupier = newCroupier;\r\n        moderator = newModerator;\r\n    }\r\n\r\n    function changeDividendsLimit(uint _newDividendsLimit) public onlyModeration {\r\n        DIVIDENDS_LIMIT = _newDividendsLimit;\r\n    }\r\n\r\n    function setMaxProfit(uint _maxProfit) public onlyModeration {\r\n        require (_maxProfit < MAX_AMOUNT, \"maxProfit cant be great then top limit.\");\r\n        maxProfit = _maxProfit;\r\n    }\r\n\r\n    function setMaxProfitPlinko(uint _maxProfitPlinko) public onlyModeration {\r\n        require (_maxProfitPlinko < MAX_AMOUNT, \"maxProfitPlinko cant be great then top limit.\");\r\n        maxProfitPlinko = _maxProfitPlinko;\r\n    }\r\n\r\n    function setMaxProfitRoulette(uint _maxProfitRoulette) public onlyModeration {\r\n        require (_maxProfitRoulette < MAX_AMOUNT, \"maxProfitRoulette cant be great then top limit.\");\r\n        maxProfitRoulette = _maxProfitRoulette;\r\n    }\r\n\r\n    function setRouletteTableLimit(uint _newRouletteTableLimit) public onlyModeration {\r\n        require (_newRouletteTableLimit < MAX_AMOUNT, \"roultteTableLimit cant be great then top limit.\");\r\n        rouletteTableLimit = _newRouletteTableLimit;\r\n    }\r\n\r\n    function setComissionState(uint8 _newRouletteState, uint8 _newPlinkoState) public onlyModeration {\r\n        rouletteSkipComission = _newRouletteState;\r\n        plinkoSkipComission = _newPlinkoState;\r\n    }\r\n\r\n    function releaseLockedInBetAmount() external onlyModeration {\r\n        lockedInBets = 0;\r\n    }\r\n\r\n    function increaseJackpot(uint increaseAmount) external onlyModeration {\r\n        require (increaseAmount <= address(this).balance, \"Increase amount larger than balance.\");\r\n        require (jackpotSize + lockedInBets + increaseAmount <= address(this).balance, \"Not enough funds.\");\r\n        jackpotSize += uint128(increaseAmount);\r\n    }\r\n\r\n    function withdrawFunds(address payable beneficiary, uint withdrawAmount) external onlyOwner {\r\n        require (withdrawAmount <= address(this).balance, \"Increase amount larger than balance.\");\r\n        require (jackpotSize + lockedInBets + withdrawAmount <= address(this).balance, \"Not enough funds.\");\r\n        sendFunds(beneficiary, withdrawAmount, withdrawAmount, 0, 'withdraw');\r\n    }\r\n\r\n    function withdrawAdvertiseFunds(address payable beneficiary, uint withdrawAmount) external onlyOwner {\r\n        require (withdrawAmount <= totalAdvertise, \"Increase amount larger than balance.\");\r\n        totalAdvertise -= withdrawAmount;\r\n        sendFunds(beneficiary, withdrawAmount, withdrawAmount, 0, 'withdraw');\r\n    }\r\n\r\n    function getBonusProgrammLevel(address gambler) public view returns (uint8 discount) {\r\n      uint accumulated = bonusProgrammAccumulated[gambler];\r\n      discount = 0;\r\n\r\n      if (accumulated >= 20 ether && accumulated < 100 ether) {\r\n        discount = 1;\r\n      } else if (accumulated >= 100 ether && accumulated < 500 ether) {\r\n        discount = 2;\r\n      } else if (accumulated >= 500 ether && accumulated < 1000 ether) {\r\n        discount = 3;\r\n      } else if (accumulated >= 1000 ether && accumulated < 5000 ether) {\r\n        discount = 4;\r\n      } else if (accumulated >= 5000 ether) {\r\n        discount = 5;\r\n      }\r\n    }\r\n\r\n    function kill() external onlyOwner {\r\n        require (lockedInBets == 0, \"All bets should be processed (settled or refunded) before self-destruct.\");\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function sendDividends() public payable {\r\n        if (address(xEtherTokensContract) != address(0)) {\r\n            uint tmpDividends = totalDividends;\r\n            xEtherTokensContract.ecosystemDividends.value(tmpDividends)();\r\n            totalDividends = 0;\r\n\r\n            emit PayDividendsSuccess(now, tmpDividends);\r\n        }\r\n    }\r\n\r\n    function placeBet(\r\n        uint betMask,\r\n        uint32 modulo,\r\n        uint commitLastBlock,\r\n        uint commit, uint256 clientSeed,\r\n        bytes32 r, bytes32 s\r\n    ) external payable {\r\n        Bet storage bet = bets[commit];\r\n        require (bet.gambler == address(0), \"Bet should be in a 'clean' state.\");\r\n\r\n        uint amount = msg.value;\r\n        if (modulo > MAX_MODULO) {\r\n            require (modulo == PLINKO_ID || modulo == SLOTS_ID, \"Modulo should be within range.\");\r\n        } else {\r\n            require (modulo > 1 && modulo <= MAX_MODULO, \"Modulo should be within range.\");\r\n        }\r\n\r\n        require (amount >= MIN_BET && amount <= MAX_AMOUNT, \"Amount should be within range.\");\r\n        require (betMask > 0 && betMask < MAX_BET_MASK, \"Mask should be within range.\");\r\n        require (block.number <= commitLastBlock, \"Commit has expired.\");\r\n        require (\r\n          secretSigner == ecrecover(keccak256(abi.encodePacked(uint40(commitLastBlock), commit)), 27, r, s) ||\r\n          secretSigner == ecrecover(keccak256(abi.encodePacked(uint40(commitLastBlock), commit)), 28, r, s),\r\n          \"ECDSA signature is not valid.\"\r\n        );\r\n\r\n        if (totalDividends >= DIVIDENDS_LIMIT) {\r\n          sendDividends();\r\n        }\r\n\r\n        uint rollUnder;\r\n        uint mask;\r\n\r\n        (mask, rollUnder, bet.locked) = prepareBet(betMask, modulo, amount, commit, clientSeed, msg.sender);\r\n\r\n        bet.amount = amount;\r\n        bet.modulo = uint32(modulo);\r\n        bet.rollUnder = uint8(rollUnder);\r\n        bet.placeBlockNumber = uint40(block.number);\r\n        bet.mask = uint40(mask);\r\n        bet.clientSeed = clientSeed;\r\n        bet.gambler = msg.sender;\r\n    }\r\n\r\n    function placeBetRoulette(\r\n        uint[] calldata betMask,\r\n        uint[] calldata betAmount,\r\n        uint commitLastBlock,\r\n        uint commit, uint256 clientSeed,\r\n        bytes32 r, bytes32 s\r\n    ) external payable {\r\n        BetRoulette storage betRoulette = betsRoulette[commit];\r\n\r\n        require(msg.value <= rouletteTableLimit, \"Bets sum must be LTE table limit\");\r\n        betRoulette.betsCount = uint8(betMask.length);\r\n\r\n        require (betRoulette.gambler == address(0), \"Bet should be in a 'clean' state.\");\r\n        require (block.number <= commitLastBlock, \"Commit has expired.\");\r\n        require (\r\n          secretSigner == ecrecover(keccak256(abi.encodePacked(uint40(commitLastBlock), commit)), 27, r, s) ||\r\n          secretSigner == ecrecover(keccak256(abi.encodePacked(uint40(commitLastBlock), commit)), 28, r, s),\r\n          \"ECDSA signature is not valid.\"\r\n        );\r\n\r\n        if (totalDividends >= DIVIDENDS_LIMIT) {\r\n          sendDividends();\r\n        }\r\n\r\n        (betRoulette.betsCount, betRoulette.locked) = placeBetRouletteProcess(commit, betMask, betAmount);\r\n\r\n        lockedInBets += betRoulette.locked;\r\n        require (lockedInBets <= address(this).balance, \"Cannot afford to lose this bet.\");\r\n\r\n        if (rouletteSkipComission != 1) {\r\n          bonusProgrammAccumulated[msg.sender] += msg.value;\r\n        }\r\n\r\n        betRoulette.totalBetAmount = msg.value;\r\n        betRoulette.placeBlockNumber = uint40(block.number);\r\n        betRoulette.clientSeed = clientSeed;\r\n        betRoulette.gambler = msg.sender;\r\n\r\n        jackpotSize += msg.value >= MIN_JACKPOT_BET ? uint128(JACKPOT_FEE) : 0;\r\n\r\n        emit Commit(commit, clientSeed, msg.value);\r\n    }\r\n\r\n    function placeBetRouletteProcess (\r\n      uint commit, uint[] memory betMask, uint[] memory betAmount\r\n    ) internal returns (uint8 betsCount, uint128 locked) {\r\n      BetRoulette storage betRoulette = betsRoulette[commit];\r\n      betsCount = 0;\r\n      uint totalBetAmount = 0;\r\n      uint8 addBets = betRoulette.betsCount;\r\n      uint8 tmpBetCount = betRoulette.betsCount - 1;\r\n      uint128 curLocked = 0;\r\n      uint128 tmpLocked = 0;\r\n      bool numIsAlredyLocked = false;\r\n      uint8 bonuses = getBonusProgrammLevel(betRoulette.gambler);\r\n\r\n      while (0 <= tmpBetCount) {\r\n        require (betMask[tmpBetCount] > 0 && betMask[tmpBetCount] < MAX_BET_MASK, \"Mask should be within range.\");\r\n\r\n        // Check track sectors bets\r\n        if (betMask[tmpBetCount] == 38721851401) {  // Jeu 0\r\n          require (betAmount[tmpBetCount] >= MIN_BET * 4 && betAmount[tmpBetCount] <= MAX_AMOUNT, \"Amount should be within range.\");\r\n\r\n          totalBetAmount += betAmount[tmpBetCount];\r\n          require (totalBetAmount <= msg.value, \"Total bets amount should be LTE amount\");\r\n\r\n          // 12/15\r\n          (betRoulette.mask[tmpBetCount], betRoulette.rollUnder[tmpBetCount], curLocked) = prepareBetRoulette(36864, betAmount[tmpBetCount] / 4, bonuses);\r\n          betRoulette.amount[tmpBetCount] = betAmount[tmpBetCount] / 4;\r\n\r\n          // 35/32\r\n          (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(38654705664, betAmount[tmpBetCount] / 4, bonuses);\r\n          betRoulette.amount[addBets] = betAmount[tmpBetCount] / 4;\r\n          curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked;\r\n\r\n          // 3/0\r\n          addBets += 1;\r\n          (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(9, betAmount[tmpBetCount] / 4, bonuses);\r\n          betRoulette.amount[addBets] = betAmount[tmpBetCount] / 4;\r\n          curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked;\r\n\r\n          // 26\r\n          addBets += 1;\r\n          (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(67108864, betAmount[tmpBetCount] / 4, bonuses);\r\n          betRoulette.amount[addBets] = betAmount[tmpBetCount] / 4;\r\n          curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked;\r\n\r\n          locked += curLocked;\r\n\r\n          addBets += 1;\r\n          betsCount += 4;\r\n        } else if (betMask[tmpBetCount] == 39567790237) { // Voisins mask\r\n          require (betAmount[tmpBetCount] >= MIN_BET * 9 && betAmount[tmpBetCount] <= MAX_AMOUNT, \"Amount should be within range.\");\r\n\r\n          totalBetAmount += betAmount[tmpBetCount];\r\n          require (totalBetAmount <= msg.value, \"Total bets amount should be LTE amount\");\r\n\r\n          // 4/7\r\n          (betRoulette.mask[tmpBetCount], betRoulette.rollUnder[tmpBetCount], curLocked) = prepareBetRoulette(\r\n            144, betAmount[tmpBetCount] / 9, bonuses);\r\n          betRoulette.amount[tmpBetCount] = betAmount[tmpBetCount] / 9;\r\n\r\n          // 12/15\r\n          (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(\r\n            36864, betAmount[tmpBetCount] / 9, bonuses);\r\n          betRoulette.amount[addBets] = betAmount[tmpBetCount] / 9;\r\n          curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked;\r\n\r\n          // 18/21\r\n          addBets += 1;\r\n          (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(\r\n            2359296, betAmount[tmpBetCount] / 9, bonuses);\r\n          betRoulette.amount[addBets] = betAmount[tmpBetCount] / 9;\r\n          curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked;\r\n\r\n          // 19/22\r\n          addBets += 1;\r\n          (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(\r\n            4718592, betAmount[tmpBetCount] / 9, bonuses);\r\n          betRoulette.amount[addBets] = betAmount[tmpBetCount] / 9;\r\n          curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked;\r\n\r\n          // 35/32\r\n          addBets += 1;\r\n          (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(\r\n            38654705664, betAmount[tmpBetCount] / 9, bonuses);\r\n          betRoulette.amount[addBets] = betAmount[tmpBetCount] / 9;\r\n          curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked;\r\n\r\n          // 25/26/28/29 (x2)\r\n          addBets += 1;\r\n          (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(\r\n            905969664, betAmount[tmpBetCount] * 2 / 9, bonuses);\r\n          betRoulette.amount[addBets] = betAmount[tmpBetCount] * 2 / 9;\r\n          curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked;\r\n\r\n          // 0/2/3 (x2)\r\n          addBets += 1;\r\n          (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(\r\n            13, betAmount[tmpBetCount] * 2 / 9, bonuses);\r\n          betRoulette.amount[addBets] = betAmount[tmpBetCount] * 2 / 9;\r\n          curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked;\r\n\r\n          locked += curLocked;\r\n\r\n          addBets += 1;\r\n          betsCount += 7;\r\n        } else if (betMask[tmpBetCount] == 19328549442) { // Orphelins mask\r\n          require (betAmount[tmpBetCount] >= MIN_BET * 5 && betAmount[tmpBetCount] <= MAX_AMOUNT, \"Amount should be within range.\");\r\n\r\n          totalBetAmount += betAmount[tmpBetCount];\r\n          require (totalBetAmount <= msg.value, \"Total bets amount should be LTE amount\");\r\n\r\n          // 14/17\r\n          (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], curLocked) = prepareBetRoulette(\r\n            147456, betAmount[tmpBetCount] / 5, bonuses);\r\n          betRoulette.amount[addBets] = betAmount[tmpBetCount] / 5;\r\n\r\n          // 17/20\r\n          addBets += 1;\r\n          (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(\r\n            1179648, betAmount[tmpBetCount] / 5, bonuses);\r\n          betRoulette.amount[addBets] = betAmount[tmpBetCount] / 5;\r\n          curLocked += tmpLocked;\r\n\r\n          // 6/9\r\n          (betRoulette.mask[tmpBetCount], betRoulette.rollUnder[tmpBetCount], tmpLocked) = prepareBetRoulette(\r\n            576, betAmount[tmpBetCount] / 5, bonuses);\r\n          betRoulette.amount[tmpBetCount] = betAmount[tmpBetCount] / 5;\r\n          curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked;\r\n\r\n          // 31/34\r\n          addBets += 1;\r\n          (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(\r\n            19327352832, betAmount[tmpBetCount] / 5, bonuses);\r\n          betRoulette.amount[addBets] = betAmount[tmpBetCount] / 5;\r\n          curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked;\r\n\r\n          // 1\r\n          addBets += 1;\r\n          (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(\r\n            2, betAmount[tmpBetCount] / 5, bonuses);\r\n          betRoulette.amount[addBets] = betAmount[tmpBetCount] / 5;\r\n          curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked;\r\n\r\n          locked += curLocked;\r\n\r\n          addBets += 1;\r\n          betsCount += 5;\r\n        } else if (betMask[tmpBetCount] == 78542613792) { // Tier mask\r\n          require (betAmount[tmpBetCount] >= MIN_BET * 6 && betAmount[tmpBetCount] <= MAX_AMOUNT, \"Amount should be within range.\");\r\n\r\n          totalBetAmount += betAmount[tmpBetCount];\r\n          require (totalBetAmount <= msg.value, \"Total bets amount should be LTE amount\");\r\n\r\n          // 5/8\r\n          (betRoulette.mask[tmpBetCount], betRoulette.rollUnder[tmpBetCount], curLocked) = prepareBetRoulette(\r\n            288, betAmount[tmpBetCount] / 6, bonuses);\r\n          betRoulette.amount[tmpBetCount] = betAmount[tmpBetCount] / 6;\r\n\r\n          // 10/11\r\n          (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(\r\n            3072, betAmount[tmpBetCount] / 6, bonuses);\r\n          betRoulette.amount[addBets] = betAmount[tmpBetCount] / 6;\r\n          curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked;\r\n\r\n          // 13/16\r\n          addBets += 1;\r\n          (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(\r\n            73728, betAmount[tmpBetCount] / 6, bonuses);\r\n          betRoulette.amount[addBets] = betAmount[tmpBetCount] / 6;\r\n          curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked;\r\n\r\n          // 23/24\r\n          addBets += 1;\r\n          (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(\r\n            25165824, betAmount[tmpBetCount] / 6, bonuses);\r\n          betRoulette.amount[addBets] = betAmount[tmpBetCount] / 6;\r\n          curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked;\r\n\r\n          // 27/30\r\n          addBets += 1;\r\n          (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(\r\n            1207959552, betAmount[tmpBetCount] / 6, bonuses);\r\n          betRoulette.amount[addBets] = betAmount[tmpBetCount] / 6;\r\n          curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked;\r\n\r\n          // 33/36\r\n          addBets += 1;\r\n          (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(\r\n            77309411328, betAmount[tmpBetCount] / 6, bonuses);\r\n          betRoulette.amount[addBets] = betAmount[tmpBetCount] / 6;\r\n          curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked;\r\n\r\n          locked += curLocked;\r\n\r\n          addBets += 1;\r\n          betsCount += 6;\r\n        } else {\r\n          require (betAmount[tmpBetCount] >= MIN_BET && betAmount[tmpBetCount] <= MAX_AMOUNT, \"Amount should be within range.\");\r\n          totalBetAmount += betAmount[tmpBetCount];\r\n          require (totalBetAmount <= msg.value, \"Total bets amount should be LTE amount\");\r\n          (betRoulette.mask[tmpBetCount], betRoulette.rollUnder[tmpBetCount], tmpLocked) = prepareBetRoulette(\r\n            betMask[tmpBetCount], betAmount[tmpBetCount], bonuses);\r\n\r\n          if (uint8(((betRoulette.mask[tmpBetCount] * POPCNT_MULT) & POPCNT_MASK) % POPCNT_MODULO) != 1) {\r\n            locked += tmpLocked;\r\n          } else {\r\n            if (!numIsAlredyLocked) {\r\n              numIsAlredyLocked = true;\r\n              locked += tmpLocked;\r\n            }\r\n          }\r\n\r\n          betRoulette.amount[tmpBetCount] = betAmount[tmpBetCount];\r\n          betsCount += 1;\r\n        }\r\n\r\n        if (tmpBetCount == 0) break;\r\n        tmpBetCount -= 1;\r\n      }\r\n    }\r\n\r\n    function prepareBet(uint betMask, uint32 modulo, uint amount, uint commit, uint clientSeed, address gambler) private returns (uint mask, uint8 rollUnder, uint128 possibleWinAmount) {\r\n        if (modulo <= MAX_MASK_MODULO) {\r\n            rollUnder = uint8(((betMask * POPCNT_MULT) & POPCNT_MASK) % POPCNT_MODULO);\r\n            mask = betMask;\r\n        } else {\r\n            require (betMask > 0 && betMask <= modulo, \"High modulo range, betMask larger than modulo.\");\r\n            rollUnder = uint8(betMask);\r\n        }\r\n\r\n        uint jackpotFee;\r\n\r\n        (possibleWinAmount, jackpotFee) = getDiceWinAmount(amount, modulo, rollUnder, gambler, true);\r\n        require (possibleWinAmount <= amount + maxProfitPlinko, \"maxProfitPlinko limit violation.\");\r\n\r\n        bonusProgrammAccumulated[gambler] += amount;\r\n        lockedInBets += uint128(possibleWinAmount);\r\n        jackpotSize += uint128(jackpotFee);\r\n\r\n        require (jackpotSize + lockedInBets <= address(this).balance, \"Cannot afford to lose this bet.\");\r\n\r\n        emit Commit(commit, clientSeed, amount);\r\n    }\r\n\r\n    function prepareBetRoulette(uint betMask, uint amount, uint8 bonuses) private returns (uint40 retMask, uint8 retRollUnder, uint128 possibleWinAmount) {\r\n        uint8 rollUnder = uint8(((betMask * POPCNT_MULT) & POPCNT_MASK) % POPCNT_MODULO);\r\n        uint mask = betMask;\r\n\r\n        possibleWinAmount = getRouletteWinAmount(amount, 36, rollUnder, bonuses, true);\r\n        require (possibleWinAmount <= amount + maxProfitRoulette, \"maxProfitRoulette limit violation.\");\r\n\r\n        retMask = uint40(mask);\r\n        retRollUnder = rollUnder;\r\n    }\r\n\r\n    function settleBet(uint reveal) external onlyCroupier {\r\n        uint commit = uint(keccak256(abi.encodePacked(reveal)));\r\n\r\n        Bet storage bet = bets[commit];\r\n        uint placeBlockNumber = bet.placeBlockNumber;\r\n\r\n        require (block.number > placeBlockNumber, \"settleBet in the same block as placeBet, or before.\");\r\n        require (block.number <= placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Can't be queried by EVM.\");\r\n\r\n        if (bet.modulo == PLINKO_ID) {\r\n            settleBetPlinko(bet, reveal);\r\n        } else if (bet.modulo == SLOTS_ID) {\r\n            settleBetSlots(bet, reveal);\r\n        } else {\r\n            settleBetCommon(bet, reveal);\r\n        }\r\n\r\n    }\r\n\r\n    function settleBetRoulette(uint reveal) external onlyCroupier {\r\n        uint commit = uint(keccak256(abi.encodePacked(reveal)));\r\n\r\n        BetRoulette storage betRoulette = betsRoulette[commit];\r\n        uint placeBlockNumber = betRoulette.placeBlockNumber;\r\n\r\n        require (betRoulette.totalBetAmount > 0, \"Bet already processed\");\r\n        require (block.number > placeBlockNumber, \"settleBet in the same block as placeBet, or before.\");\r\n        require (block.number <= placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Can't be queried by EVM.\");\r\n\r\n        settleBetRoulette(betRoulette, reveal);\r\n    }\r\n\r\n    // Common bets\r\n    function settleBetCommon(Bet storage bet, uint reveal) private {\r\n        uint amount = bet.amount;\r\n        uint8 rollUnder = bet.rollUnder;\r\n\r\n        require (amount != 0, \"Bet should be in an 'active' state\");\r\n\r\n        bet.amount = 0;\r\n        bytes32 entropy = keccak256(abi.encodePacked(reveal, bet.clientSeed));\r\n        uint dice = uint(entropy) % bet.modulo;\r\n        uint diceWinAmount;\r\n        uint _jackpotFee;\r\n        uint diceWin;\r\n\r\n        if (bet.modulo <= MAX_MASK_MODULO) {\r\n            if ((2 ** dice) & bet.mask != 0) {\r\n                (diceWinAmount, _jackpotFee) = getDiceWinAmount(amount, bet.modulo, rollUnder, bet.gambler, false);\r\n                diceWin = diceWinAmount;\r\n            }\r\n        } else {\r\n            if (dice < rollUnder) {\r\n                (diceWinAmount, _jackpotFee) = getDiceWinAmount(amount, bet.modulo, rollUnder, bet.gambler, false);\r\n                diceWin = diceWinAmount;\r\n            }\r\n        }\r\n\r\n        lockedInBets -= uint128(bet.locked);\r\n\r\n        uint jackpotWin = checkJackPotWin(entropy, amount, bet.modulo);\r\n        if (jackpotWin > 0) {\r\n            emit JackpotPayment(bet.gambler, uint(keccak256(abi.encodePacked(reveal))), jackpotWin);\r\n        }\r\n\r\n        sendFunds(\r\n          bet.gambler,\r\n          diceWin + jackpotWin == 0 ? 1 wei : diceWin + jackpotWin,\r\n          diceWin,\r\n          uint(keccak256(abi.encodePacked(reveal))),\r\n          'payment'\r\n        );\r\n    }\r\n\r\n    // Plinko\r\n    function settleBetPlinko(Bet storage bet, uint reveal) private {\r\n        uint amount = bet.amount;\r\n        uint rollUnder = bet.rollUnder;\r\n\r\n        require (amount != 0, \"Bet should be in an 'active' state\");\r\n\r\n        bet.amount = 0;\r\n        bytes32 entropy = keccak256(abi.encodePacked(reveal, bet.clientSeed));\r\n        uint dice = uint(entropy) % bet.modulo;\r\n        uint diceWin = _plinkoGetDiceWin(dice, amount, rollUnder, bet.gambler);\r\n\r\n        lockedInBets -= uint128(bet.locked);\r\n\r\n        uint jackpotWin = checkJackPotWin(entropy, amount, bet.modulo);\r\n        if (jackpotWin > 0) {\r\n            emit JackpotPayment(bet.gambler, uint(keccak256(abi.encodePacked(reveal))), jackpotWin);\r\n        }\r\n\r\n        sendFunds(\r\n          bet.gambler,\r\n          diceWin + jackpotWin == 0 ? 1 wei : diceWin + jackpotWin,\r\n          diceWin,\r\n          uint(keccak256(abi.encodePacked(reveal))),\r\n          'payment'\r\n        );\r\n    }\r\n\r\n    function _plinkoGetDiceWin(uint dice, uint amount, uint rollUnder, address gambler) internal view returns (uint) {\r\n        uint bytesCount = 0;\r\n        uint diceWin = 1;\r\n\r\n        for (uint byteNum = 0; byteNum < PLINKO_BYTES; byteNum += 1) {\r\n            if ((2 ** byteNum) & dice != 0) {\r\n                bytesCount += 1;\r\n            }\r\n        }\r\n\r\n        uint inCellRatio = _getPlinkoCellRatio(rollUnder, bytesCount);\r\n        uint jackpotFee = amount >= MIN_JACKPOT_BET ? JACKPOT_FEE : 0;\r\n        uint totalPercentages;\r\n\r\n        if (plinkoSkipComission == 2) {\r\n          totalPercentages = PLINKO_PERCENT + ADVERTISE_PERCENT + DIVIDENDS_PERCENT;\r\n        } else {\r\n          totalPercentages = HOUSE_EDGE_PERCENT + ADVERTISE_PERCENT + DIVIDENDS_PERCENT;\r\n        }\r\n\r\n        uint houseEdge = amount * (totalPercentages - getBonusProgrammLevel(gambler)) / PERCENTAGES_BASE;\r\n        if (houseEdge < HOUSE_EDGE_MINIMUM_AMOUNT) {\r\n            houseEdge = HOUSE_EDGE_MINIMUM_AMOUNT;\r\n        }\r\n\r\n        diceWin = (amount - houseEdge - jackpotFee) * inCellRatio / 100;\r\n\r\n        return diceWin;\r\n    }\r\n\r\n    function _getPlinkoCellRatio(uint plinkoNum, uint cell) internal view returns (uint cellRatio) {\r\n      if (plinkoNum == 1) {\r\n        cellRatio = PLINKO1Ratios[cell];\r\n      } else if (plinkoNum == 2) {\r\n        cellRatio = PLINKO2Ratios[cell];\r\n      } else {\r\n        cellRatio = PLINKO3Ratios[cell];\r\n      }\r\n    }\r\n\r\n    // Slots\r\n    function settleBetSlots(Bet storage bet, uint reveal) private {\r\n        uint amount = bet.amount;\r\n        uint modulo = bet.modulo;\r\n\r\n        require (amount != 0, \"Bet should be in an 'active' state\");\r\n\r\n        bet.amount = 0;\r\n        bytes32 entropy = keccak256(abi.encodePacked(reveal, bet.clientSeed));\r\n        uint diceWin = _slotsWinAmount(entropy, amount, bet.gambler);\r\n\r\n        lockedInBets -= uint128(bet.locked);\r\n\r\n        uint jackpotWin = checkJackPotWin(entropy, amount, modulo);\r\n        if (jackpotWin > 0) {\r\n            emit JackpotPayment(bet.gambler, uint(keccak256(abi.encodePacked(reveal))), jackpotWin);\r\n        }\r\n\r\n        sendFunds(\r\n          bet.gambler,\r\n          diceWin + jackpotWin == 0 ? 1 wei : diceWin + jackpotWin,\r\n          diceWin,\r\n          uint(keccak256(abi.encodePacked(reveal))),\r\n          'payment'\r\n        );\r\n    }\r\n\r\n    function _slotsWinAmount(bytes32 entropy, uint amount, address gambler) internal view returns (uint winAmount) {\r\n        uint8 wins;\r\n        uint8 wild;\r\n\r\n        (wins, wild) = _slotsCheckWin(entropy);\r\n\r\n        winAmount = 0;\r\n\r\n        uint jackpotFee = amount >= MIN_JACKPOT_BET ? JACKPOT_FEE : 0;\r\n        uint totalPercentages = HOUSE_EDGE_PERCENT + ADVERTISE_PERCENT + DIVIDENDS_PERCENT;\r\n        uint houseEdge = amount * (totalPercentages - getBonusProgrammLevel(gambler)) / PERCENTAGES_BASE;\r\n\r\n        if (houseEdge < HOUSE_EDGE_MINIMUM_AMOUNT) {\r\n            houseEdge = HOUSE_EDGE_MINIMUM_AMOUNT;\r\n        }\r\n\r\n        winAmount = (amount - houseEdge - jackpotFee) / 100 * SLOTSWinsRatios[wins];\r\n        winAmount += (amount - houseEdge - jackpotFee) / 100 * SLOTSWildRatios[wild];\r\n    }\r\n\r\n    function _slotsCheckWin(bytes32 slots) internal pure returns(uint8 wins, uint8 wild) {\r\n        uint curNum;\r\n        uint prevNum;\r\n        bytes1 charAtPos;\r\n        uint8 firstNums;\r\n        uint8 prevWins = 0;\r\n        uint8 curWins = 0;\r\n\r\n        wins = 0;\r\n        wild = 0;\r\n\r\n        for(uint8 i = 0; i < SLOTS_COUNT; i++) {\r\n            charAtPos = charAt(slots, i + 2);\r\n            firstNums = getLastN(charAtPos, 4);\r\n            curNum = uint(firstNums);\r\n\r\n            if (curNum > 8) {\r\n                curNum = 16 - curNum;\r\n            }\r\n\r\n            if (curNum == 7) wild += 1;\r\n\r\n            if (i == 0) {\r\n                prevNum = curNum;\r\n                continue;\r\n            }\r\n\r\n            if (prevNum == curNum) {\r\n                curWins += 1;\r\n            } else {\r\n                prevWins = (curWins > prevWins) ? curWins : prevWins;\r\n                curWins = 0;\r\n            }\r\n\r\n            prevNum = curNum;\r\n        }\r\n\r\n        wins = (curWins > prevWins) ? curWins : prevWins;\r\n    }\r\n\r\n    function settleBetRoulette(BetRoulette storage betRoulette, uint reveal) private {\r\n        require (betRoulette.totalBetAmount != 0, \"Bet should be in an 'active' state\");\r\n        address payable gambler = betRoulette.gambler;\r\n        bytes32 entropy = keccak256(abi.encodePacked(reveal, betRoulette.clientSeed));\r\n        uint diceWin = 0;\r\n        uint diceWinAmount;\r\n        uint feeToJP = betRoulette.totalBetAmount >= MIN_JACKPOT_BET ? JACKPOT_FEE / betRoulette.betsCount : 0;\r\n\r\n        uint dice = uint(entropy) % ROULETTE_ID;\r\n\r\n        uint8 bonuses = getBonusProgrammLevel(betRoulette.gambler);\r\n\r\n        for(uint8 index = 0; index < betRoulette.betsCount; index += 1) {\r\n          if ((2 ** dice) & betRoulette.mask[index] != 0) {\r\n              diceWinAmount = getRouletteWinAmount(betRoulette.amount[index] - feeToJP, ROULETTE_ID - 1, betRoulette.rollUnder[index], bonuses, false);\r\n              diceWin += diceWinAmount;\r\n          }\r\n        }\r\n\r\n        lockedInBets -= betRoulette.locked;\r\n\r\n        uint jackpotWin = checkJackPotWin(entropy, betRoulette.totalBetAmount, ROULETTE_ID);\r\n        if (jackpotWin > 0) {\r\n            emit JackpotPayment(gambler, uint(keccak256(abi.encodePacked(reveal))), jackpotWin);\r\n        }\r\n\r\n        sendFunds(\r\n          gambler,\r\n          diceWin + jackpotWin == 0 ? 1 wei : diceWin + jackpotWin,\r\n          diceWin,\r\n          uint(keccak256(abi.encodePacked(reveal))),\r\n          'payment'\r\n        );\r\n\r\n        betRoulette.totalBetAmount = 0;\r\n    }\r\n\r\n    function refundBet(uint commit) external {\r\n        Bet storage bet = bets[commit];\r\n        uint amount = bet.amount;\r\n\r\n        require (amount != 0, \"Bet should be in an 'active' state\");\r\n        require (block.number > bet.placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Blockhash can't be queried by EVM.\");\r\n\r\n        bet.amount = 0;\r\n        lockedInBets -= uint128(bet.locked);\r\n\r\n        if (amount >= MIN_JACKPOT_BET && jackpotSize > JACKPOT_FEE) {\r\n          jackpotSize -= uint128(JACKPOT_FEE);\r\n        }\r\n\r\n        sendFunds(bet.gambler, amount, amount, commit, 'refund');\r\n    }\r\n\r\n    function refundBetRoulette(uint commit) external {\r\n        BetRoulette storage betRoulette = betsRoulette[commit];\r\n        uint amount = betRoulette.totalBetAmount;\r\n\r\n        require (amount != 0, \"Bet should be in an 'active' state\");\r\n        require (block.number > betRoulette.placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Blockhash can't be queried by EVM.\");\r\n\r\n        betRoulette.totalBetAmount = 0;\r\n\r\n        for(uint8 index = 0; index < betRoulette.betsCount; index += 1) {\r\n          betRoulette.amount[index] = 0;\r\n        }\r\n\r\n        lockedInBets -= betRoulette.locked;\r\n\r\n        if (amount >= MIN_JACKPOT_BET && jackpotSize > JACKPOT_FEE) {\r\n          jackpotSize -= uint128(JACKPOT_FEE);\r\n        }\r\n\r\n        sendFunds(betRoulette.gambler, amount, amount, commit, 'refund');\r\n    }\r\n\r\n    function getDiceWinAmount(uint amount, uint32 modulo, uint8 rollUnder, address gambler, bool init) private returns (uint128 winAmount, uint jackpotFee) {\r\n        require (0 < rollUnder && rollUnder <= modulo, \"Win probability out of range.\");\r\n\r\n        jackpotFee = amount >= MIN_JACKPOT_BET ? JACKPOT_FEE : 0;\r\n        uint8 totalPercentages;\r\n\r\n        if (plinkoSkipComission == 2) { // Plinko\r\n          totalPercentages = PLINKO_PERCENT + ADVERTISE_PERCENT + DIVIDENDS_PERCENT;\r\n        } else { // All other games\r\n          totalPercentages = HOUSE_EDGE_PERCENT + ADVERTISE_PERCENT + DIVIDENDS_PERCENT;\r\n        }\r\n\r\n        uint houseEdge = amount * (totalPercentages - getBonusProgrammLevel(gambler)) / PERCENTAGES_BASE;\r\n        if (houseEdge < HOUSE_EDGE_MINIMUM_AMOUNT) {\r\n            houseEdge = HOUSE_EDGE_MINIMUM_AMOUNT;\r\n        }\r\n\r\n        require (houseEdge + jackpotFee <= amount, \"Bet doesn't even cover house edge.\");\r\n\r\n        if (init) {\r\n          totalDividends += amount * DIVIDENDS_PERCENT / PERCENTAGES_BASE;\r\n          totalAdvertise += amount * ADVERTISE_PERCENT / PERCENTAGES_BASE;\r\n        }\r\n\r\n        if (modulo == PLINKO_ID) {\r\n          // We lock maximum for selected plinko row\r\n          if (rollUnder == 1) {\r\n            modulo = 10; // equal to  PLINKO1Ratios[0] / 100\r\n          } else if (rollUnder == 2) {\r\n            modulo = 20; // equal to  PLINKO2Ratios[0] / 100\r\n          } else {\r\n            modulo = 50; // equal to  PLINKO3Ratios[0] / 100\r\n          }\r\n\r\n          rollUnder = 1;\r\n        }\r\n\r\n        if (modulo == SLOTS_ID) {\r\n          modulo = 5; // We lock x5 for slots\r\n          rollUnder = 1;\r\n        }\r\n\r\n        winAmount = uint128((amount - houseEdge - jackpotFee) * modulo / rollUnder);\r\n    }\r\n\r\n    function getRouletteWinAmount(uint amount, uint32 modulo, uint8 rollUnder, uint8 bonuses, bool init) private returns (uint128 winAmount) {\r\n        require (0 < rollUnder && rollUnder <= modulo, \"Win probability out of range.\");\r\n        uint houseEdge;\r\n\r\n        if (rouletteSkipComission == 1) { // Roulette\r\n          houseEdge = amount * ROULETTE_PERCENT / PERCENTAGES_BASE;\r\n        } else {\r\n          if (init) {\r\n            totalDividends += amount * DIVIDENDS_PERCENT / PERCENTAGES_BASE;\r\n            totalAdvertise += amount * ADVERTISE_PERCENT / PERCENTAGES_BASE;\r\n          }\r\n\r\n          houseEdge = amount * (HOUSE_EDGE_PERCENT + ADVERTISE_PERCENT + DIVIDENDS_PERCENT - bonuses) / PERCENTAGES_BASE;\r\n        }\r\n\r\n        if (houseEdge < HOUSE_EDGE_MINIMUM_AMOUNT) {\r\n            houseEdge = HOUSE_EDGE_MINIMUM_AMOUNT;\r\n        }\r\n        require (houseEdge <= amount, \"Bet doesn't even cover house edge.\");\r\n\r\n        winAmount = uint128((amount - houseEdge) * modulo / rollUnder);\r\n    }\r\n\r\n    function sendFunds(address payable beneficiary, uint amount, uint successLogAmount, uint commit, string memory paymentType) private {\r\n        if (beneficiary.send(amount)) {\r\n            emit Payment(beneficiary, commit, successLogAmount, paymentType);\r\n        } else {\r\n            emit FailedPayment(beneficiary, commit, amount, paymentType);\r\n        }\r\n    }\r\n\r\n    function checkJackPotWin(bytes32 entropy, uint amount, uint modulo) internal returns (uint jackpotWin) {\r\n        jackpotWin = 0;\r\n        if (amount >= MIN_JACKPOT_BET) {\r\n            uint jackpotRng = (uint(entropy) / modulo) % JACKPOT_MODULO;\r\n\r\n            if (jackpotRng == luckyNumber) {\r\n                jackpotWin = jackpotSize;\r\n                jackpotSize = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    uint constant POPCNT_MULT = 0x0000000000002000000000100000000008000000000400000000020000000001;\r\n    uint constant POPCNT_MASK = 0x0001041041041041041041041041041041041041041041041041041041041041;\r\n    uint constant POPCNT_MODULO = 0x3F;\r\n\r\n    function charAt(bytes32 b, uint char) private pure returns (bytes1) {\r\n        return bytes1(uint8(uint(b) / (2**((31 - char) * 8))));\r\n    }\r\n\r\n    function getLastN(bytes1 a, uint8 n) private pure returns (uint8) {\r\n        uint8 lastN = uint8(a) % uint8(2) ** n;\r\n        return lastN;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"ADVERTISE_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reveal\",\"type\":\"uint256\"}],\"name\":\"settleBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bonusProgrammAccumulated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xEtherTokensContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rouletteSkipComission\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfitRoulette\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCroupier\",\"type\":\"address\"},{\"name\":\"newSecretSigner\",\"type\":\"address\"},{\"name\":\"newModerator\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rouletteTableLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"moderator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gambler\",\"type\":\"address\"}],\"name\":\"getBonusProgrammLevel\",\"outputs\":[{\"name\":\"discount\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"xEtherContract\",\"type\":\"address\"}],\"name\":\"setXEtherContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secretSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDividendsLimit\",\"type\":\"uint256\"}],\"name\":\"changeDividendsLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPlinkoPercent\",\"type\":\"uint8\"}],\"name\":\"setNewPlinkoPercents\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"croupier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRouletteTableLimit\",\"type\":\"uint256\"}],\"name\":\"setRouletteTableLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawAdvertiseFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint256[]\"},{\"name\":\"betAmount\",\"type\":\"uint256[]\"},{\"name\":\"commitLastBlock\",\"type\":\"uint256\"},{\"name\":\"commit\",\"type\":\"uint256\"},{\"name\":\"clientSeed\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"placeBetRoulette\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxProfitPlinko\",\"type\":\"uint256\"}],\"name\":\"setMaxProfitPlinko\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRouletteState\",\"type\":\"uint8\"},{\"name\":\"_newPlinkoState\",\"type\":\"uint8\"}],\"name\":\"setComissionState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxProfitRoulette\",\"type\":\"uint256\"}],\"name\":\"setMaxProfitRoulette\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"refundBetRoulette\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAdvertise\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newHouseEdgePercent\",\"type\":\"uint8\"},{\"name\":\"newDividendsPercent\",\"type\":\"uint8\"},{\"name\":\"newAdvertPercent\",\"type\":\"uint8\"}],\"name\":\"setNewPercents\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sendDividends\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PLINKO_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HOUSE_EDGE_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"luckyNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nextOwner\",\"type\":\"address\"}],\"name\":\"approveNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"increaseAmount\",\"type\":\"uint256\"}],\"name\":\"increaseJackpot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"plinkoSkipComission\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseLockedInBetAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newRoulettePercent\",\"type\":\"uint8\"}],\"name\":\"setNewRoulettePercents\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint256\"},{\"name\":\"modulo\",\"type\":\"uint32\"},{\"name\":\"commitLastBlock\",\"type\":\"uint256\"},{\"name\":\"commit\",\"type\":\"uint256\"},{\"name\":\"clientSeed\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"placeBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedInBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DIVIDENDS_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"refundBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reveal\",\"type\":\"uint256\"}],\"name\":\"settleBetRoulette\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DIVIDENDS_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROULETTE_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxProfit\",\"type\":\"uint256\"}],\"name\":\"setMaxProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfitPlinko\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"paymentType\",\"type\":\"string\"}],\"name\":\"FailedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"paymentType\",\"type\":\"string\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"JackpotPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PayDividendsSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PayDividendsFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"clietSeed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Commit\",\"type\":\"event\"}]","ContractName":"XetherGames","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://bc9d43aef8f6c18e47787228d2f7107318a36b538819d2381f37f3055bc2f667"}]}