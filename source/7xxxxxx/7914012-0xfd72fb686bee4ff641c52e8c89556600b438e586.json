{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.22 <0.6.0;\r\n// ----------------------------------------------------------------------------\r\n// VeChain Fungible Token Standard Interface\r\n// https://github.com/vechain/VIPs/blob/master/vips/VIP-180.md\r\n// ----------------------------------------------------------------------------\r\ninterface VIP180 {\r\n    function decimals() external view returns(uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _tokenOwner) external view returns (uint256);\r\n    function transfer(address _to, uint _tokens) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint _tokens) external returns (bool);\r\n    function approve(address _spender, uint _tokens) external returns (bool);\r\n    function allowance(address _tokenOwner, address _spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _tokens);\r\n    event Approval(address indexed _tokenOwner, address indexed _spender, uint _tokens);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n/// @title Locked Token contract\r\n/// @notice defines token locking and unlocking functionality.\r\n//-----------------------------------------------------------------------------\r\ncontract LockedTokenManager {\r\n    //-------------------------------------------------------------------------\r\n    /// @dev Emits when VIP-180 tokens become locked for any number of months by\r\n    ///  any mechanism.\r\n    //-------------------------------------------------------------------------\r\n    event Lock (address indexed _tokenOwner, address indexed _tokenAddress, uint _tokens);\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @dev Emits when VIP-180 tokens become unlocked by any mechanism.\r\n    //-------------------------------------------------------------------------\r\n    event Unlock (address indexed _tokenOwner, address indexed _tokenAddress, uint _tokens);\r\n\r\n    // Unix Timestamp for 4-1-2019 at 00:00:00.\r\n    //  Used to calculate months since release.\r\n    uint constant FIRST_MONTH_TIMESTAMP = 1554076800;\r\n    // Maximum number of months into the future locked tokens can be recovered.\r\n    uint constant MAXIMUM_LOCK_MONTHS = 240;\r\n    // Tracks months since release. Starts at 0 and increments every 30.4375 days.\r\n    uint public currentMonth;\r\n    // Locked token balances by unlock month\r\n    mapping (address => mapping(address => mapping(uint => uint))) tokensLockedUntilMonth;\r\n    \r\n    //-------------------------------------------------------------------------\r\n    /// @dev Throws if parameter is zero\r\n    //-------------------------------------------------------------------------\r\n    modifier notZero(uint _param) {\r\n        require (_param != 0, \"Parameter cannot be zero\");\r\n        _;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Lock `_tokens` tokens for `_numberOfMonths` months.\r\n    /// @dev Throws if amount to lock is zero. Throws if numberOfMonths is zero\r\n    ///  or greater than maximum months. Throws if sender has insufficient \r\n    ///  balance to lock. Throws if token address does not allow transfer.\r\n    /// @param _tokenAddress Address of the token contract to lock from.\r\n    /// @param _numberOfMonths The number of months the tokens will be locked.\r\n    /// @param _tokens The number of tokens to lock.\r\n    //-------------------------------------------------------------------------\r\n    function lock(address _tokenAddress, uint _tokens, uint _numberOfMonths) \r\n        public \r\n        notZero(_tokens)\r\n        returns(bool)\r\n    {\r\n        // number of months must be a valid amount.\r\n        require (\r\n            _numberOfMonths > 0 && _numberOfMonths <= MAXIMUM_LOCK_MONTHS,\r\n            \"Invalid number of months\"\r\n        );\r\n\r\n        // transfer amount from sender\r\n        VIP180 tokenContract = VIP180(_tokenAddress);\r\n        tokenContract.transferFrom(msg.sender, address(this), _tokens);\r\n        \r\n        // add amount to sender's locked token balance\r\n        tokensLockedUntilMonth[msg.sender][_tokenAddress][currentMonth + _numberOfMonths] += _tokens;\r\n        // emit lock event\r\n        emit Lock(msg.sender, _tokenAddress, _tokens);\r\n\r\n        return true;\r\n    }\r\n    \r\n    //-------------------------------------------------------------------------\r\n    /// @notice LockFrom `_tokens` tokens for `_numberOfMonths` months.\r\n    /// @dev Throws if amount to lock is zero. Throws if numberOfMonths is zero\r\n    ///  or greater than maximum months. Throws if token holder has insufficient \r\n    ///  balance to lock. Throws if transferFrom fails.\r\n    /// @param _tokenHolder Address of token holder whose tokens will be locked.\r\n    /// @param _tokenAddress Address of the token contract to lock from.\r\n    /// @param _numberOfMonths The number of months the tokens will be locked.\r\n    /// @param _tokens The number of tokens to lock.\r\n    //-------------------------------------------------------------------------\r\n    function lockFrom(\r\n        address _tokenHolder, \r\n        address _tokenAddress, \r\n        uint _tokens, \r\n        uint _numberOfMonths\r\n    ) public notZero(_tokens) returns(bool) {\r\n        // number of months must be a valid amount.\r\n        require (\r\n            _numberOfMonths > 0 && _numberOfMonths <= MAXIMUM_LOCK_MONTHS,\r\n            \"Invalid number of months\"\r\n        );\r\n\r\n        // transfer amount from sender\r\n        VIP180 tokenContract = VIP180(_tokenAddress);\r\n        tokenContract.transferFrom(_tokenHolder, address(this), _tokens);\r\n        \r\n        // add amount to sender's locked token balance\r\n        tokensLockedUntilMonth[_tokenHolder][_tokenAddress][currentMonth + _numberOfMonths] += _tokens;\r\n        // emit lock event\r\n        emit Lock(_tokenHolder, _tokenAddress, _tokens);\r\n\r\n        return true;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Send `_tokens` tokens to `_to`, then lock for `_numberOfMonths`\r\n    ///  months.\r\n    /// @dev Throws if amount to send is zero. Throws if `msg.sender` has\r\n    ///  insufficient balance for transfer. Throws if _to is the zero address.\r\n    ///  Throws if numberOfMonths is zero or greater than maximum months.\r\n    ///  Emits transfer and lock events.\r\n    /// @param _to The address to where tokens are being sent and locked.\r\n    /// @param _tokenAddress Address of the contract to transfer and lock from.\r\n    /// @param _numberOfMonths The number of months the tokens will be locked.\r\n    /// @param _tokens The number of tokens to send and lock.\r\n    //-------------------------------------------------------------------------\r\n    function transferAndLock(\r\n        address _to,\r\n        address _tokenAddress,\r\n        uint _tokens,\r\n        uint _numberOfMonths\r\n    ) external returns (bool) {\r\n        // number of months must be a valid amount.\r\n        require (\r\n            _numberOfMonths > 0 && _numberOfMonths <= MAXIMUM_LOCK_MONTHS,\r\n            \"Invalid number of months\"\r\n        );\r\n\r\n        // transfer amount from sender\r\n        VIP180 tokenContract = VIP180(_tokenAddress);\r\n        tokenContract.transferFrom(msg.sender, address(this), _tokens);\r\n        \r\n        // add amount to sender's locked token balance\r\n        tokensLockedUntilMonth[_to][_tokenAddress][currentMonth + _numberOfMonths] += _tokens;\r\n        // emit lock event\r\n        emit Lock(_to, _tokenAddress, _tokens);\r\n\r\n        return true;\r\n    }\r\n    \r\n    //-------------------------------------------------------------------------\r\n    /// @notice Send `_tokens` tokens to `_to`, then lock for `_numberOfMonths`\r\n    ///  months.\r\n    /// @dev Throws if amount to send is zero. Throws if `msg.sender` has\r\n    ///  insufficient balance for transfer. Throws if _to is the zero address.\r\n    ///  Throws if numberOfMonths is zero or greater than maximum months.\r\n    ///  Throws if transferFrom fails. Emits transfer and lock events.\r\n    /// @param _from The address from where tokens are being sent.\r\n    /// @param _to The address to where tokens are being sent and locked.\r\n    /// @param _tokenAddress Address of the contract to transfer and lock from.\r\n    /// @param _numberOfMonths The number of months the tokens will be locked.\r\n    /// @param _tokens The number of tokens to send and lock.\r\n    //-------------------------------------------------------------------------\r\n    function transferFromAndLock(\r\n        address _from,\r\n        address _to,\r\n        address _tokenAddress,\r\n        uint _tokens,\r\n        uint _numberOfMonths\r\n    ) external returns (bool) {\r\n        // number of months must be a valid amount.\r\n        require (\r\n            _numberOfMonths > 0 && _numberOfMonths <= MAXIMUM_LOCK_MONTHS,\r\n            \"Invalid number of months\"\r\n        );\r\n\r\n        // transfer amount from sender\r\n        VIP180 tokenContract = VIP180(_tokenAddress);\r\n        tokenContract.transferFrom(_from, address(this), _tokens);\r\n        \r\n        // add amount to sender's locked token balance\r\n        tokensLockedUntilMonth[_to][_tokenAddress][currentMonth + _numberOfMonths] += _tokens;\r\n        // emit lock event\r\n        emit Lock(_to, _tokenAddress, _tokens);\r\n\r\n        return true;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Unlock all qualifying tokens for `_tokenOwner`. Sender must \r\n    ///  either be tokenOwner or an approved address.\r\n    /// @dev If tokenOwner is empty, tokenOwner is set to msg.sender. Throws\r\n    ///  if sender is not tokenOwner or an approved spender (allowance > 0).\r\n    /// @param _tokenOwner The token owner whose tokens will unlock.\r\n    /// @param _tokenAddress The token contract address.\r\n    //-------------------------------------------------------------------------\r\n    function unlockAll(address _tokenOwner, address _tokenAddress) external {\r\n        // create local variable for token owner\r\n        address addressToUnlock = _tokenOwner;\r\n        // if tokenOwner parameter is empty, set tokenOwner to sender\r\n        if (addressToUnlock == address(0)) {\r\n            addressToUnlock = msg.sender;\r\n        }\r\n        VIP180 tokenContract = VIP180(_tokenAddress);\r\n        // sender must either be tokenOwner or an approved address\r\n        if (msg.sender != addressToUnlock) {\r\n            require (\r\n                tokenContract.allowance(addressToUnlock, msg.sender) > 0,\r\n                \"Not authorized to unlock for this address\"\r\n            );\r\n        }\r\n\r\n        // create local variable for unlock total\r\n        uint tokensToUnlock;\r\n        // check each month starting from 1 month after release\r\n        for (uint i = 1; i <= currentMonth; ++i) {\r\n            // add qualifying tokens to tokens to unlock variable\r\n            tokensToUnlock += tokensLockedUntilMonth[addressToUnlock][_tokenAddress][i];\r\n            // set locked token balance of month i to 0 \r\n            tokensLockedUntilMonth[addressToUnlock][_tokenAddress][i] = 0;\r\n        }\r\n        // add qualifying tokens back to token owner's account balance\r\n        tokenContract.transfer(addressToUnlock, tokensToUnlock);\r\n        // emit unlock event\r\n        emit Unlock (addressToUnlock, _tokenAddress, tokensToUnlock);\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Unlock all tokens locked until `month` months since April 2019 \r\n    ///  for `tokenOwner`. Sender must be tokenOwner or an approved address.\r\n    /// @dev If tokenOwner is empty, tokenOwner is set to msg.sender. Throws\r\n    ///  if sender is not tokenOwner or an approved spender (allowance > 0).\r\n    /// @param _tokenOwner The token owner whose tokens will unlock.\r\n    /// @param _tokenAddress The token contract address.\r\n    /// @param _month Number of months since April 2019.\r\n    //-------------------------------------------------------------------------\r\n    function unlockByMonth(\r\n        address _tokenOwner, \r\n        address _tokenAddress, \r\n        uint _month\r\n    ) external {\r\n        // create local variable for token owner\r\n        address addressToUnlock = _tokenOwner;\r\n        // if tokenOwner parameter is empty, set tokenOwner to sender\r\n        if (addressToUnlock == address(0)) {\r\n            addressToUnlock = msg.sender;\r\n        }\r\n        VIP180 tokenContract = VIP180(_tokenAddress);\r\n        // sender must either be tokenOwner or an approved address\r\n        if (msg.sender != addressToUnlock) {\r\n            require (\r\n                tokenContract.allowance(addressToUnlock, msg.sender) > 0,\r\n                \"Not authorized to unlock for this address\"\r\n            );\r\n        }\r\n        // month of locked tokens must be less than or equal to current month\r\n        require (\r\n            currentMonth >= _month,\r\n            \"Tokens from this month cannot be unlocked yet\"\r\n        );\r\n        // create local variable for unlock amount\r\n        uint tokensToUnlock = tokensLockedUntilMonth[addressToUnlock][_tokenAddress][_month];\r\n        // set locked token balance of month to 0\r\n        tokensLockedUntilMonth[addressToUnlock][_tokenAddress][_month] = 0;\r\n        // add qualifying tokens back to token owner's account balance\r\n        tokenContract.transfer(addressToUnlock, tokensToUnlock);\r\n        // emit unlock event\r\n        emit Unlock(addressToUnlock, _tokenAddress, tokensToUnlock);\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Update the current month.\r\n    /// @dev Throws if less than 30.4375 days has passed since currentMonth.\r\n    //-------------------------------------------------------------------------\r\n    function updateMonthsSinceRelease() external {\r\n        // check if months since first month is greater than the currentMonth\r\n        uint secondsSinceRelease = block.timestamp - FIRST_MONTH_TIMESTAMP;\r\n        require (\r\n            currentMonth < secondsSinceRelease / (30 * 1 days + 10 * 1 hours + 30 * 1 minutes),\r\n            \"Cannot update month yet\"\r\n        );\r\n        // increment months since release\r\n        ++currentMonth;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice View the total locked token holdings of `tokenOwner`. Only\r\n    ///  displays tokens from _tokenAddress.\r\n    /// @param _tokenOwner The locked token owner.\r\n    /// @param _tokenAddress The token contract address.\r\n    /// @return Total locked token holdings of a token owner.\r\n    //-------------------------------------------------------------------------\r\n    function viewTotalLockedTokens(\r\n        address _tokenOwner,\r\n        address _tokenAddress\r\n    ) public view returns (uint lockedTokens) {\r\n        for (uint i = 1; i < currentMonth + MAXIMUM_LOCK_MONTHS; ++i) {\r\n            lockedTokens += tokensLockedUntilMonth[_tokenOwner][_tokenAddress][i];\r\n        }\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice View the locked token holdings of `tokenOwner` unlockable in\r\n    ///  `_month` months since April 2019.\r\n    /// @param _tokenOwner The locked token owner.\r\n    /// @param _tokenAddress The token contract's address.\r\n    /// @param _month Months since April 2019 the tokens are locked until.\r\n    /// @return Locked token holdings by month.\r\n    //-------------------------------------------------------------------------\r\n    function viewLockedTokensByMonth(\r\n        address _tokenOwner,\r\n        address _tokenAddress,\r\n        uint _month\r\n    ) external view returns (uint) {\r\n        return tokensLockedUntilMonth[_tokenOwner][_tokenAddress][_month];\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"unlockAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_month\",\"type\":\"uint256\"}],\"name\":\"viewLockedTokensByMonth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"},{\"name\":\"_numberOfMonths\",\"type\":\"uint256\"}],\"name\":\"transferAndLock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_month\",\"type\":\"uint256\"}],\"name\":\"unlockByMonth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateMonthsSinceRelease\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentMonth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"viewTotalLockedTokens\",\"outputs\":[{\"name\":\"lockedTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"},{\"name\":\"_numberOfMonths\",\"type\":\"uint256\"}],\"name\":\"transferFromAndLock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenHolder\",\"type\":\"address\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"},{\"name\":\"_numberOfMonths\",\"type\":\"uint256\"}],\"name\":\"lockFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"},{\"name\":\"_numberOfMonths\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"Unlock\",\"type\":\"event\"}]","ContractName":"LockedTokenManager","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://64979839b7adf6e6f9e1a0db4027150a9e22bb9b6d38ad119fe86c6ea4dfe229"}]}