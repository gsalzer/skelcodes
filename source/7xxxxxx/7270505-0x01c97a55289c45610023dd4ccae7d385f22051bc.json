{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n * Originally based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n *\r\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\r\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\r\n * compliant implementations may not do it.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param owner The address to query the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n        _transfer(from, to, value);\r\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed_[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed_[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified addresses\r\n    * @param from The address to transfer from.\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0));\r\n\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that mints an amount of the token and assigns it to\r\n     * an account. This encapsulates the modification of balances such that the\r\n     * proper events are emitted.\r\n     * @param account The account that will receive the created tokens.\r\n     * @param value The amount that will be created.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.add(value);\r\n        _balances[account] = _balances[account].add(value);\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account.\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account, deducting from the sender's allowance for said account. Uses the\r\n     * internal burn function.\r\n     * Emits an Approval event (reflecting the reduced allowance).\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burnFrom(address account, uint256 value) internal {\r\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\r\n        _burn(account, value);\r\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\r\n    }\r\n}\r\n\r\n// File: contracts/crowdsale/interfaces/IGlobalIndex.sol\r\n\r\ninterface IGlobalIndex {\r\n    function getControllerAddress() external view returns (address);\r\n    function setControllerAddress(address _newControllerAddress) external;\r\n}\r\n\r\n// File: contracts/crowdsale/interfaces/ICRWDController.sol\r\n\r\ninterface ICRWDController {\r\n    function buyFromCrowdsale(address _to, uint256 _amountInWei) external returns (uint256 _tokensCreated, uint256 _overpaidRefund); //from Crowdsale\r\n    function assignFromCrowdsale(address _to, uint256 _tokenAmount, bytes8 _tag) external returns (uint256 _tokensCreated); //from Crowdsale\r\n    function calcTokensForEth(uint256 _amountInWei) external view returns (uint256 _tokensWouldBeCreated); //from Crowdsale\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Secondary.sol\r\n\r\n/**\r\n * @title Secondary\r\n * @dev A Secondary contract can only be used by its primary account (the one that created it)\r\n */\r\ncontract Secondary {\r\n    address private _primary;\r\n\r\n    event PrimaryTransferred(\r\n        address recipient\r\n    );\r\n\r\n    /**\r\n     * @dev Sets the primary account to the one that is creating the Secondary contract.\r\n     */\r\n    constructor () internal {\r\n        _primary = msg.sender;\r\n        emit PrimaryTransferred(_primary);\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if called from any account other than the primary.\r\n     */\r\n    modifier onlyPrimary() {\r\n        require(msg.sender == _primary);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return the address of the primary.\r\n     */\r\n    function primary() public view returns (address) {\r\n        return _primary;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers contract to a new primary.\r\n     * @param recipient The address of new primary.\r\n     */\r\n    function transferPrimary(address recipient) public onlyPrimary {\r\n        require(recipient != address(0));\r\n        _primary = recipient;\r\n        emit PrimaryTransferred(_primary);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/payment/escrow/Escrow.sol\r\n\r\n/**\r\n * @title Escrow\r\n * @dev Base escrow contract, holds funds designated for a payee until they\r\n * withdraw them.\r\n * @dev Intended usage: This contract (and derived escrow contracts) should be a\r\n * standalone contract, that only interacts with the contract that instantiated\r\n * it. That way, it is guaranteed that all Ether will be handled according to\r\n * the Escrow rules, and there is no need to check for payable functions or\r\n * transfers in the inheritance tree. The contract that uses the escrow as its\r\n * payment method should be its primary, and provide public methods redirecting\r\n * to the escrow's deposit and withdraw.\r\n */\r\ncontract Escrow is Secondary {\r\n    using SafeMath for uint256;\r\n\r\n    event Deposited(address indexed payee, uint256 weiAmount);\r\n    event Withdrawn(address indexed payee, uint256 weiAmount);\r\n\r\n    mapping(address => uint256) private _deposits;\r\n\r\n    function depositsOf(address payee) public view returns (uint256) {\r\n        return _deposits[payee];\r\n    }\r\n\r\n    /**\r\n    * @dev Stores the sent amount as credit to be withdrawn.\r\n    * @param payee The destination address of the funds.\r\n    */\r\n    function deposit(address payee) public onlyPrimary payable {\r\n        uint256 amount = msg.value;\r\n        _deposits[payee] = _deposits[payee].add(amount);\r\n\r\n        emit Deposited(payee, amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw accumulated balance for a payee.\r\n    * @param payee The address whose funds will be withdrawn and transferred to.\r\n    */\r\n    function withdraw(address payable payee) public onlyPrimary {\r\n        uint256 payment = _deposits[payee];\r\n\r\n        _deposits[payee] = 0;\r\n\r\n        payee.transfer(payment);\r\n\r\n        emit Withdrawn(payee, payment);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/payment/escrow/ConditionalEscrow.sol\r\n\r\n/**\r\n * @title ConditionalEscrow\r\n * @dev Base abstract escrow to only allow withdrawal if a condition is met.\r\n * @dev Intended usage: See Escrow.sol. Same usage guidelines apply here.\r\n */\r\ncontract ConditionalEscrow is Escrow {\r\n    /**\r\n    * @dev Returns whether an address is allowed to withdraw their funds. To be\r\n    * implemented by derived contracts.\r\n    * @param payee The destination address of the funds.\r\n    */\r\n    function withdrawalAllowed(address payee) public view returns (bool);\r\n\r\n    function withdraw(address payable payee) public {\r\n        require(withdrawalAllowed(payee));\r\n        super.withdraw(payee);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/payment/escrow/RefundEscrow.sol\r\n\r\n/**\r\n * @title RefundEscrow\r\n * @dev Escrow that holds funds for a beneficiary, deposited from multiple\r\n * parties.\r\n * @dev Intended usage: See Escrow.sol. Same usage guidelines apply here.\r\n * @dev The primary account (that is, the contract that instantiates this\r\n * contract) may deposit, close the deposit period, and allow for either\r\n * withdrawal by the beneficiary, or refunds to the depositors. All interactions\r\n * with RefundEscrow will be made through the primary contract. See the\r\n * RefundableCrowdsale contract for an example of RefundEscrow’s use.\r\n */\r\ncontract RefundEscrow is ConditionalEscrow {\r\n    enum State { Active, Refunding, Closed }\r\n\r\n    event RefundsClosed();\r\n    event RefundsEnabled();\r\n\r\n    State private _state;\r\n    address payable private _beneficiary;\r\n\r\n    /**\r\n     * @dev Constructor.\r\n     * @param beneficiary The beneficiary of the deposits.\r\n     */\r\n    constructor (address payable beneficiary) public {\r\n        require(beneficiary != address(0));\r\n        _beneficiary = beneficiary;\r\n        _state = State.Active;\r\n    }\r\n\r\n    /**\r\n     * @return the current state of the escrow.\r\n     */\r\n    function state() public view returns (State) {\r\n        return _state;\r\n    }\r\n\r\n    /**\r\n     * @return the beneficiary of the escrow.\r\n     */\r\n    function beneficiary() public view returns (address) {\r\n        return _beneficiary;\r\n    }\r\n\r\n    /**\r\n     * @dev Stores funds that may later be refunded.\r\n     * @param refundee The address funds will be sent to if a refund occurs.\r\n     */\r\n    function deposit(address refundee) public payable {\r\n        require(_state == State.Active);\r\n        super.deposit(refundee);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows for the beneficiary to withdraw their funds, rejecting\r\n     * further deposits.\r\n     */\r\n    function close() public onlyPrimary {\r\n        require(_state == State.Active);\r\n        _state = State.Closed;\r\n        emit RefundsClosed();\r\n    }\r\n\r\n    /**\r\n     * @dev Allows for refunds to take place, rejecting further deposits.\r\n     */\r\n    function enableRefunds() public onlyPrimary {\r\n        require(_state == State.Active);\r\n        _state = State.Refunding;\r\n        emit RefundsEnabled();\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws the beneficiary's funds.\r\n     */\r\n    function beneficiaryWithdraw() public {\r\n        require(_state == State.Closed);\r\n        _beneficiary.transfer(address(this).balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether refundees can withdraw their deposits (be refunded). The overriden function receives a\r\n     * 'payee' argument, but we ignore it here since the condition is global, not per-payee.\r\n     */\r\n    function withdrawalAllowed(address) public view returns (bool) {\r\n        return _state == State.Refunding;\r\n    }\r\n}\r\n\r\n// File: contracts/crowdsale/library/CrowdsaleL.sol\r\n\r\n/*\r\n    Copyright 2018, CONDA\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n/** @title CrowdsaleL library. */\r\nlibrary CrowdsaleL {\r\n    using SafeMath for uint256;\r\n\r\n///////////////////\r\n// Structs\r\n///////////////////\r\n\r\n    /// @dev All crowdsale states.\r\n    enum State { Draft, Started, Ended, Finalized, Refunding, Closed }\r\n\r\n    struct Data {\r\n        // The token being sold type ERC20\r\n        address token;\r\n\r\n        // status of crowdsale\r\n        State state;\r\n\r\n        // the max cap of tokens being sold\r\n        uint256 cap;\r\n\r\n        // the start time of crowdsale.\r\n        uint256 startTime;\r\n        \r\n        // the end time of crowdsale\r\n        uint256 endTime;\r\n\r\n        // address where funds are collected\r\n        address payable wallet;\r\n\r\n        // the global index holding contract addresses\r\n        IGlobalIndex globalIndex;\r\n\r\n        // amount of tokens raised by money in all allowed currencies\r\n        uint256 tokensRaised;\r\n    }\r\n\r\n    struct Roles {\r\n        // can assign tokens on off-chain payments\r\n        address tokenAssignmentControl;\r\n\r\n        // role that can rescue accidentally sent tokens\r\n        address tokenRescueControl;\r\n    }\r\n\r\n///////////////////\r\n// Functions\r\n///////////////////\r\n\r\n    /// @notice Initialize function for initial setup (during construction).\r\n    /// @param _assetToken The asset token being sold.\r\n    function init(Data storage _self, address _assetToken) public {\r\n        _self.token = _assetToken;\r\n        _self.state = State.Draft;\r\n    }\r\n\r\n    /// @notice Confiugure function for setup (during negotiations).\r\n    /// @param _wallet beneficiary wallet on successful crowdsale.\r\n    /// @param _globalIndex the contract holding current contract addresses.\r\n    function configure(\r\n        Data storage _self, \r\n        address payable _wallet, \r\n        address _globalIndex)\r\n    public \r\n    {\r\n        require(_self.state == CrowdsaleL.State.Draft, \"not draft state\");\r\n        require(_wallet != address(0), \"wallet zero addr\");\r\n        require(_globalIndex != address(0), \"globalIdx zero addr\");\r\n\r\n        _self.wallet = _wallet;\r\n        _self.globalIndex = IGlobalIndex(_globalIndex);\r\n\r\n        emit CrowdsaleConfigurationChanged(_wallet, _globalIndex);\r\n    }\r\n\r\n    /// @notice Set roles/operators.\r\n    /// @param _tokenAssignmentControl token assignment control (off-chain payment).\r\n    /// @param _tokenRescueControl token rescue control (accidentally assigned tokens).\r\n    function setRoles(Roles storage _self, address _tokenAssignmentControl, address _tokenRescueControl) public {\r\n        require(_tokenAssignmentControl != address(0), \"addr0\");\r\n        require(_tokenRescueControl != address(0), \"addr0\");\r\n        \r\n        _self.tokenAssignmentControl = _tokenAssignmentControl;\r\n        _self.tokenRescueControl = _tokenRescueControl;\r\n\r\n        emit RolesChanged(msg.sender, _tokenAssignmentControl, _tokenRescueControl);\r\n    }\r\n\r\n    /// @notice gets current controller address.\r\n    function getControllerAddress(Data storage _self) public view returns (address) {\r\n        return IGlobalIndex(_self.globalIndex).getControllerAddress();\r\n    }\r\n\r\n    /// @dev gets controller with interface for internal use.\r\n    function getController(Data storage _self) private view returns (ICRWDController) {\r\n        return ICRWDController(getControllerAddress(_self));\r\n    }\r\n\r\n    /// @notice set cap.\r\n    /// @param _cap token cap of tokens being sold.\r\n    function setCap(Data storage _self, uint256 _cap) public {\r\n        // require(requireActiveOrDraftState(_self), \"require active/draft\"); // No! Could have been changed by AT owner...\r\n        // require(_cap > 0, \"cap 0\"); // No! Decided by AssetToken owner...\r\n        _self.cap = _cap;\r\n    }\r\n\r\n    /// @notice Low level token purchase function with ether.\r\n    /// @param _beneficiary who receives tokens.\r\n    /// @param _investedAmount the invested ETH amount.\r\n    function buyTokensFor(Data storage _self, address _beneficiary, uint256 _investedAmount) \r\n    public \r\n    returns (uint256)\r\n    {\r\n        require(validPurchasePreCheck(_self), \"invalid purchase precheck\");\r\n\r\n        (uint256 tokenAmount, uint256 overpaidRefund) = getController(_self).buyFromCrowdsale(_beneficiary, _investedAmount);\r\n\r\n        if(tokenAmount == 0) {\r\n            // Special handling full refund if too little ETH (could be small drift depending on off-chain API accuracy)\r\n            overpaidRefund = _investedAmount;\r\n        }\r\n\r\n        require(validPurchasePostCheck(_self, tokenAmount), \"invalid purchase postcheck\");\r\n        _self.tokensRaised = _self.tokensRaised.add(tokenAmount);\r\n\r\n        emit TokenPurchase(msg.sender, _beneficiary, tokenAmount, overpaidRefund, \"ETH\");\r\n\r\n        return overpaidRefund;\r\n    }\r\n\r\n    /// @dev Fails if not active or draft state\r\n    function requireActiveOrDraftState(Data storage _self) public view returns (bool) {\r\n        require((_self.state == State.Draft) || (_self.state == State.Started), \"only active or draft state\");\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Valid start basic logic.\r\n    /// @dev In contract could be extended logic e.g. checking goal)\r\n    function validStart(Data storage _self) public view returns (bool) {\r\n        require(_self.wallet != address(0), \"wallet is zero addr\");\r\n        require(_self.token != address(0), \"token is zero addr\");\r\n        require(_self.cap > 0, \"cap is 0\");\r\n        require(_self.startTime != 0, \"time not set\");\r\n        require(now >= _self.startTime, \"too early\");\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Set the timeframe.\r\n    /// @param _startTime the start time of crowdsale.\r\n    /// @param _endTime the end time of crowdsale.\r\n    function setTime(Data storage _self, uint256 _startTime, uint256 _endTime) public\r\n    {\r\n        _self.startTime = _startTime;\r\n        _self.endTime = _endTime;\r\n\r\n        emit CrowdsaleTimeChanged(_startTime, _endTime);\r\n    }\r\n\r\n    /// @notice crowdsale has ended check.\r\n    /// @dev Same code if goal is used.\r\n    /// @return true if crowdsale event has ended\r\n    function hasEnded(Data storage _self) public view returns (bool) {\r\n        bool capReached = _self.tokensRaised >= _self.cap; \r\n        bool endStateReached = (_self.state == CrowdsaleL.State.Ended || _self.state == CrowdsaleL.State.Finalized || _self.state == CrowdsaleL.State.Closed || _self.state == CrowdsaleL.State.Refunding);\r\n        \r\n        return endStateReached || capReached || now > _self.endTime;\r\n    }\r\n\r\n    /// @notice Set from finalized to state closed.\r\n    /// @dev Must be called to close the crowdsale manually\r\n    function closeCrowdsale(Data storage _self) public {\r\n        require((_self.state == State.Finalized) || (_self.state == State.Refunding), \"state\");\r\n\r\n        _self.state = State.Closed;\r\n    }\r\n\r\n    /// @notice Checks if valid purchase before other ecosystem contracts roundtrip (fail early).\r\n    /// @return true if the transaction can buy tokens\r\n    function validPurchasePreCheck(Data storage _self) private view returns (bool) {\r\n        require(_self.state == State.Started, \"not in state started\");\r\n        bool withinPeriod = now >= _self.startTime && _self.endTime >= now;\r\n        require(withinPeriod, \"not within period\");\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Checks if valid purchase after other ecosystem contracts roundtrip (double check).\r\n    /// @return true if the transaction can buy tokens\r\n    function validPurchasePostCheck(Data storage _self, uint256 _tokensCreated) private view returns (bool) {\r\n        require(_self.state == State.Started, \"not in state started\");\r\n        bool withinCap = _self.tokensRaised.add(_tokensCreated) <= _self.cap; \r\n        require(withinCap, \"not within cap\");\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice simple token assignment.\r\n    function assignTokens(\r\n        Data storage _self, \r\n        address _beneficiaryWallet, \r\n        uint256 _tokenAmount, \r\n        bytes8 _tag) \r\n        public returns (uint256 _tokensCreated)\r\n    {\r\n        _tokensCreated = getController(_self).assignFromCrowdsale(\r\n            _beneficiaryWallet, \r\n            _tokenAmount,\r\n            _tag);\r\n        \r\n        emit TokenPurchase(msg.sender, _beneficiaryWallet, _tokensCreated, 0, _tag);\r\n\r\n        return _tokensCreated;\r\n    }\r\n\r\n    /// @notice calc how much tokens you would receive for given ETH amount (all in unit WEI)\r\n    /// @dev no view keyword even if it SHOULD not change the state. But let's not trust other contracts...\r\n    function calcTokensForEth(Data storage _self, uint256 _ethAmountInWei) public view returns (uint256 _tokensWouldBeCreated) {\r\n        return getController(_self).calcTokensForEth(_ethAmountInWei);\r\n    }\r\n\r\n    /// @notice If this contract gets a balance in some other ERC20 contract - or even iself - then we can rescue it.\r\n    /// @param _foreignTokenAddress token where contract has balance.\r\n    /// @param _to the beneficiary.\r\n    function rescueToken(Data storage _self, address _foreignTokenAddress, address _to) public\r\n    {\r\n        ERC20(_foreignTokenAddress).transfer(_to, ERC20(_foreignTokenAddress).balanceOf(address(this)));\r\n    }\r\n\r\n///////////////////\r\n// Events (must be redundant in calling contract to work!)\r\n///////////////////\r\n\r\n    event TokenPurchase(address indexed invoker, address indexed beneficiary, uint256 tokenAmount, uint256 overpaidRefund, bytes8 tag);\r\n    event CrowdsaleTimeChanged(uint256 startTime, uint256 endTime);\r\n    event CrowdsaleConfigurationChanged(address wallet, address globalIndex);\r\n    event RolesChanged(address indexed initiator, address tokenAssignmentControl, address tokenRescueControl);\r\n}\r\n\r\n// File: contracts/crowdsale/library/VaultGeneratorL.sol\r\n\r\n/*\r\n    Copyright 2018, CONDA\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n/** @title VaultGeneratorL library. */\r\nlibrary VaultGeneratorL {\r\n\r\n    /// @notice generate RefundEscrow vault.\r\n    /// @param _wallet beneficiary on success.\r\n    /// @return vault address that can be casted to interface.\r\n    function generateEthVault(address payable _wallet) public returns (address ethVaultInterface) {\r\n        return address(new RefundEscrow(_wallet));\r\n    }\r\n}\r\n\r\n// File: contracts/crowdsale/interfaces/IBasicAssetToken.sol\r\n\r\ninterface IBasicAssetToken {\r\n    //AssetToken specific\r\n    function getLimits() external view returns (uint256, uint256, uint256, uint256);\r\n    function isTokenAlive() external view returns (bool);\r\n\r\n    //Mintable\r\n    function mint(address _to, uint256 _amount) external returns (bool);\r\n    function finishMinting() external returns (bool);\r\n}\r\n\r\n// File: contracts/crowdsale/interface/EthVaultInterface.sol\r\n\r\n/**\r\n * Based on OpenZeppelin RefundEscrow.sol\r\n */\r\ninterface EthVaultInterface {\r\n\r\n    event Closed();\r\n    event RefundsEnabled();\r\n\r\n    /// @dev Stores funds that may later be refunded.\r\n    /// @param _refundee The address funds will be sent to if a refund occurs.\r\n    function deposit(address _refundee) external payable;\r\n\r\n    /// @dev Allows for the beneficiary to withdraw their funds, rejecting\r\n    /// further deposits.\r\n    function close() external;\r\n\r\n    /// @dev Allows for refunds to take place, rejecting further deposits.\r\n    function enableRefunds() external;\r\n\r\n    /// @dev Withdraws the beneficiary's funds.\r\n    function beneficiaryWithdraw() external;\r\n\r\n    /// @dev Returns whether refundees can withdraw their deposits (be refunded).\r\n    function withdrawalAllowed(address _payee) external view returns (bool);\r\n\r\n    /// @dev Withdraw what someone paid into vault.\r\n    function withdraw(address _payee) external;\r\n}\r\n\r\n// File: contracts/crowdsale/BasicAssetTokenCrowdsaleNoFeature.sol\r\n\r\n/*\r\n    Copyright 2018, CONDA\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/** @title BasicCompanyCrowdsale. Investment is stored in vault and forwarded to wallet on end. */\r\ncontract BasicAssetTokenCrowdsaleNoFeature is Ownable {\r\n    using SafeMath for uint256;\r\n    using CrowdsaleL for CrowdsaleL.Data;\r\n    using CrowdsaleL for CrowdsaleL.Roles;\r\n\r\n    /**\r\n    * Crowdsale process has the following steps:\r\n    *   1) startCrowdsale\r\n    *   2) buyTokens\r\n    *   3) endCrowdsale\r\n    *   4) finalizeCrowdsale\r\n    */\r\n\r\n///////////////////\r\n// Variables\r\n///////////////////\r\n\r\n    CrowdsaleL.Data crowdsaleData;\r\n    CrowdsaleL.Roles roles;\r\n\r\n///////////////////\r\n// Constructor\r\n///////////////////\r\n\r\n    constructor(address _assetToken) public {\r\n        crowdsaleData.init(_assetToken);\r\n    }\r\n\r\n///////////////////\r\n// Modifier\r\n///////////////////\r\n\r\n    modifier onlyTokenRescueControl() {\r\n        require(msg.sender == roles.tokenRescueControl, \"rescueCtrl\");\r\n        _;\r\n    }\r\n\r\n///////////////////\r\n// Simple state getters\r\n///////////////////\r\n\r\n    function token() public view returns (address) {\r\n        return crowdsaleData.token;\r\n    }\r\n\r\n    function wallet() public view returns (address) {\r\n        return crowdsaleData.wallet;\r\n    }\r\n\r\n    function tokensRaised() public view returns (uint256) {\r\n        return crowdsaleData.tokensRaised;\r\n    }\r\n\r\n    function cap() public view returns (uint256) {\r\n        return crowdsaleData.cap;\r\n    }\r\n\r\n    function state() public view returns (CrowdsaleL.State) {\r\n        return crowdsaleData.state;\r\n    }\r\n\r\n    function startTime() public view returns (uint256) {\r\n        return crowdsaleData.startTime;\r\n    }\r\n\r\n    function endTime() public view returns (uint256) {\r\n        return crowdsaleData.endTime;\r\n    }\r\n\r\n    function getControllerAddress() public view returns (address) {\r\n        return address(crowdsaleData.getControllerAddress());\r\n    }\r\n\r\n///////////////////\r\n// Events\r\n///////////////////\r\n\r\n    event TokenPurchase(address indexed invoker, address indexed beneficiary, uint256 tokenAmount, uint256 overpaidRefund, bytes8 tag);\r\n    event CrowdsaleTimeChanged(uint256 startTime, uint256 endTime);\r\n    event CrowdsaleConfigurationChanged(address wallet, address globalIndex);\r\n    event RolesChanged(address indexed initiator, address tokenAssignmentControl, address tokenRescueControl);\r\n    event Started();\r\n    event Ended();\r\n    event Finalized();\r\n\r\n///////////////////\r\n// Modifiers\r\n///////////////////\r\n\r\n    modifier onlyTokenAssignmentControl() {\r\n        require(_isTokenAssignmentControl(), \"only tokenAssignmentControl\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyDraftState() {\r\n        require(crowdsaleData.state == CrowdsaleL.State.Draft, \"only draft state\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyActive() {\r\n        require(_isActive(), \"only when active\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyActiveOrDraftState() {\r\n        require(_isActiveOrDraftState(), \"only active/draft\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyUnfinalized() {\r\n        require(crowdsaleData.state != CrowdsaleL.State.Finalized, \"only unfinalized\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev is crowdsale active or draft state that can be overriden.\r\n    */\r\n    function _isActiveOrDraftState() internal view returns (bool) {\r\n        return crowdsaleData.requireActiveOrDraftState();\r\n    }\r\n\r\n    /**\r\n    * @dev is token assignmentcontrol that can be overriden.\r\n    */\r\n    function _isTokenAssignmentControl() internal view returns (bool) {\r\n        return msg.sender == roles.tokenAssignmentControl;\r\n    }\r\n\r\n    /**\r\n    * @dev is active check that can be overriden.\r\n    */\r\n    function _isActive() internal view returns (bool) {\r\n        return crowdsaleData.state == CrowdsaleL.State.Started;\r\n    }\r\n \r\n///////////////////\r\n// Status Draft\r\n///////////////////\r\n\r\n    /// @notice set required data like wallet and global index.\r\n    /// @param _wallet beneficiary of crowdsale.\r\n    /// @param _globalIndex global index contract holding up2date contract addresses.\r\n    function setCrowdsaleData(\r\n        address payable _wallet,\r\n        address _globalIndex)\r\n    public\r\n    onlyOwner \r\n    {\r\n        crowdsaleData.configure(_wallet, _globalIndex);\r\n    }\r\n\r\n    /// @notice get token AssignmenControl who can assign tokens (off-chain payments).\r\n    function getTokenAssignmentControl() public view returns (address) {\r\n        return roles.tokenAssignmentControl;\r\n    }\r\n\r\n    /// @notice get token RescueControl who can rescue accidentally assigned tokens to this contract.\r\n    function getTokenRescueControl() public view returns (address) {\r\n        return roles.tokenRescueControl;\r\n    }\r\n\r\n    /// @notice set cap. That's the limit how much is accepted.\r\n    /// @param _cap the cap in unit token (minted AssetToken)\r\n    function setCap(uint256 _cap) internal onlyUnfinalized {\r\n        crowdsaleData.setCap(_cap);\r\n    }\r\n\r\n    /// @notice set roles/operators.\r\n    /// @param _tokenAssignmentControl can assign tokens (off-chain payments).\r\n    /// @param _tokenRescueControl address that is allowed rescue tokens.\r\n    function setRoles(address _tokenAssignmentControl, address _tokenRescueControl) public onlyOwner {\r\n        roles.setRoles(_tokenAssignmentControl, _tokenRescueControl);\r\n    }\r\n\r\n    /// @notice set crowdsale timeframe.\r\n    /// @param _startTime crowdsale start time.\r\n    /// @param _endTime crowdsale end time.\r\n    function setCrowdsaleTime(uint256 _startTime, uint256 _endTime) internal onlyUnfinalized {\r\n        // require(_startTime >= now, \"starTime in the past\"); //when getting from AT that is possible\r\n        require(_endTime >= _startTime, \"endTime smaller start\");\r\n\r\n        crowdsaleData.setTime(_startTime, _endTime);\r\n    }\r\n\r\n    /// @notice Update metadata like cap, time etc. from AssetToken.\r\n    /// @dev It is essential that this method is at least called before start and before end.\r\n    function updateFromAssetToken() public {\r\n        (uint256 _cap, /*goal*/, uint256 _startTime, uint256 _endTime) = IBasicAssetToken(crowdsaleData.token).getLimits();\r\n        setCap(_cap);\r\n        setCrowdsaleTime(_startTime, _endTime);\r\n    }\r\n\r\n///\r\n// Status Started\r\n///\r\n\r\n    /// @notice checks all variables and starts crowdsale\r\n    function startCrowdsale() public onlyDraftState {\r\n        updateFromAssetToken(); //IMPORTANT\r\n        \r\n        require(validStart(), \"validStart\");\r\n        prepareStart();\r\n        crowdsaleData.state = CrowdsaleL.State.Started;\r\n        emit Started();\r\n    }\r\n\r\n    /// @dev Calc how many tokens you would receive for given ETH amount (all in unit WEI)\r\n    function calcTokensForEth(uint256 _ethAmountInWei) public view returns (uint256 _tokensWouldBeCreated) {\r\n        return crowdsaleData.calcTokensForEth(_ethAmountInWei);\r\n    }\r\n\r\n    /// @dev Can be overridden to add start validation logic. The overriding function\r\n    ///  should call super.validStart() to ensure the chain of validation is\r\n    ///  executed entirely.\r\n    function validStart() internal view returns (bool) {\r\n        return crowdsaleData.validStart();\r\n    }\r\n\r\n    /// @dev Can be overridden to add preparation logic. The overriding function\r\n    ///  should call super.prepareStart() to ensure the chain of finalization is\r\n    ///  executed entirely.\r\n    function prepareStart() internal {\r\n    }\r\n\r\n    /// @dev Determines how ETH is stored/forwarded on purchases.\r\n    /// @param _overpaidRefund overpaid ETH amount (because AssetToken is 0 decimals)\r\n    function forwardWeiFunds(uint256 _overpaidRefund) internal {\r\n        require(_overpaidRefund <= msg.value, \"unrealistic overpay\");\r\n        crowdsaleData.wallet.transfer(msg.value.sub(_overpaidRefund));\r\n        \r\n        //send overpayment back to sender. notice: only safe because executed in the end!\r\n        msg.sender.transfer(_overpaidRefund);\r\n    }\r\n\r\n///\r\n// Status Ended\r\n///\r\n\r\n    /// @dev Can be called by owner to end the crowdsale manually\r\n    function endCrowdsale() public onlyOwner onlyActive {\r\n        updateFromAssetToken();\r\n\r\n        crowdsaleData.state = CrowdsaleL.State.Ended;\r\n\r\n        emit Ended();\r\n    }\r\n\r\n\r\n///\r\n// Status Finalized\r\n///\r\n\r\n    /// @dev Must be called after crowdsale ends, to do some extra finalization.\r\n    function finalizeCrowdsale() public {\r\n        updateFromAssetToken(); //IMPORTANT\r\n\r\n        require(crowdsaleData.state == CrowdsaleL.State.Ended || crowdsaleData.state == CrowdsaleL.State.Started, \"state\");\r\n        require(hasEnded(), \"not ended\");\r\n        crowdsaleData.state = CrowdsaleL.State.Finalized;\r\n        \r\n        finalization();\r\n        emit Finalized();\r\n    }\r\n\r\n    /// @notice status if crowdsale has ended yet.\r\n    /// @return true if crowdsale event has ended.\r\n    function hasEnded() public view returns (bool) {\r\n        return crowdsaleData.hasEnded();\r\n    }\r\n\r\n    /// @dev Can be overridden to add finalization logic. The overriding function\r\n    ///  should call super.finalization() to ensure the chain of finalization is\r\n    ///  executed entirely.\r\n    function finalization() internal {\r\n    }\r\n    \r\n///\r\n// Status Closed\r\n///\r\n\r\n    /// @dev Must be called to close the crowdsale manually. The overriding function\r\n    /// should call super.closeCrowdsale()\r\n    function closeCrowdsale() public onlyOwner {\r\n        crowdsaleData.closeCrowdsale();\r\n    }\r\n\r\n////////////////\r\n// Rescue Tokens \r\n////////////////\r\n\r\n    /// @dev Can rescue tokens accidentally assigned to this contract\r\n    /// @param _foreignTokenAddress The address from which the balance will be retrieved\r\n    /// @param _to beneficiary\r\n    function rescueToken(address _foreignTokenAddress, address _to)\r\n    public\r\n    onlyTokenRescueControl\r\n    {\r\n        crowdsaleData.rescueToken(_foreignTokenAddress, _to);\r\n    }\r\n}\r\n\r\n// File: contracts/crowdsale/feature/AssignTokensOffChainPaymentFeature.sol\r\n\r\n/*\r\n    Copyright 2018, CONDA\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n/** @title AssignTokensOffChainPaymentFeature that if inherited adds possibility mintFor(investorXY) without ETH payment. */\r\ncontract AssignTokensOffChainPaymentFeature {\r\n\r\n///////////////////\r\n// Modifiers\r\n///////////////////\r\n\r\n    modifier assignTokensPrerequisit {\r\n        require(_assignTokensPrerequisit(), \"assign prerequisit\");\r\n        _;\r\n    }\r\n\r\n///////////////////\r\n// Functions\r\n///////////////////\r\n\r\n    /// @notice If entitled call this method to assign tokens to beneficiary (use case: off-chain payment)\r\n    /// @dev Token amount is assigned unmodified (no rate etc. on top)\r\n    function assignTokensOffChainPayment(\r\n        address _beneficiaryWallet, \r\n        uint256 _tokenAmount,\r\n        bytes8 _tag) \r\n        public \r\n        assignTokensPrerequisit\r\n    {\r\n        _assignTokensOffChainPaymentAct(_beneficiaryWallet, _tokenAmount, _tag);\r\n    }\r\n\r\n///////////////////\r\n// Functions to override\r\n///////////////////\r\n\r\n    /// @dev Checks prerequisits (e.g. if active/draft crowdsale, permission) ***MUST OVERRIDE***\r\n    function _assignTokensPrerequisit() internal view returns (bool) {\r\n        revert(\"override assignTokensPrerequisit\");\r\n    }\r\n\r\n    /// @dev Assign tokens act ***MUST OVERRIDE***\r\n    function _assignTokensOffChainPaymentAct(address /*_beneficiaryWallet*/, uint256 /*_tokenAmount*/, bytes8 /*_tag*/) \r\n        internal returns (bool)\r\n    {\r\n        revert(\"override buyTokensWithEtherAct\");\r\n    }\r\n}\r\n\r\n// File: contracts/crowdsale/STOs/AssetTokenCrowdsaleT001.sol\r\n\r\n/// @title AssetTokenCrowdsaleT001. Functionality of BasicAssetTokenNoFeatures with the AssignTokensOffChainPaymentFeature feature.\r\ncontract AssetTokenCrowdsaleT001 is BasicAssetTokenCrowdsaleNoFeature, AssignTokensOffChainPaymentFeature {\r\n\r\n///////////////////\r\n// Constructor\r\n///////////////////\r\n\r\n    constructor(address _assetToken) public BasicAssetTokenCrowdsaleNoFeature(_assetToken) {\r\n\r\n    }\r\n\r\n///////////////////\r\n// Feature functions internal overrides\r\n///////////////////\r\n\r\n    /// @dev override of assign tokens prerequisit of possible features.\r\n    function _assignTokensPrerequisit() internal view returns (bool) {\r\n        return (_isTokenAssignmentControl() && _isActiveOrDraftState());\r\n    }\r\n\r\n    /// @dev method executed on assign tokens because of off-chain payment (if feature is inherited).\r\n    function _assignTokensOffChainPaymentAct(address _beneficiaryWallet, uint256 _tokenAmount, bytes8 _tag)\r\n        internal returns (bool) \r\n    {\r\n        crowdsaleData.assignTokens(_beneficiaryWallet, _tokenAmount, _tag);\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_ethAmountInWei\",\"type\":\"uint256\"}],\"name\":\"calcTokensForEth\",\"outputs\":[{\"name\":\"_tokensWouldBeCreated\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenRescueControl\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenAssignmentControl\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_globalIndex\",\"type\":\"address\"}],\"name\":\"setCrowdsaleData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_foreignTokenAddress\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"rescueToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaryWallet\",\"type\":\"address\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_tag\",\"type\":\"bytes8\"}],\"name\":\"assignTokensOffChainPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getControllerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateFromAssetToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAssignmentControl\",\"type\":\"address\"},{\"name\":\"_tokenRescueControl\",\"type\":\"address\"}],\"name\":\"setRoles\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_assetToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"invoker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"overpaidRefund\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tag\",\"type\":\"bytes8\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleTimeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"globalIndex\",\"type\":\"address\"}],\"name\":\"CrowdsaleConfigurationChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAssignmentControl\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenRescueControl\",\"type\":\"address\"}],\"name\":\"RolesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Started\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Ended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"AssetTokenCrowdsaleT001","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000065b840f5ac981e553dd643c9dadd8ccf5a716168","Library":"CrowdsaleL:58d0dd25Fb8d95502b4732e10bD8cF8901230176;VaultGeneratorL:9C5F2495F714Bdf9e5e2a1aeCE36a4365E12C863","SwarmSource":"bzzr://a5ac6be620ae5e87eedaf952a7e34da6fa1cf569bec8ff0a4c9c76f13a74c853"}]}