{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Copyright 2017-2019, bZeroX, LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n \r\npragma solidity 0.5.8;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/**\r\n * @title EIP20/ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract EIP20 is ERC20 {\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n}\r\n\r\ncontract WETHInterface is EIP20 {\r\n    function deposit() external payable;\r\n    function withdraw(uint256 wad) external;\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, rounding up and truncating the quotient\r\n  */\r\n  function divCeil(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    return ((_a - 1) / _b) + 1;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /// @dev Constant for unlocked guard state - non-zero to prevent extra gas costs.\r\n  /// See: https://github.com/OpenZeppelin/openzeppelin-solidity/issues/1056\r\n  uint256 internal constant REENTRANCY_GUARD_FREE = 1;\r\n\r\n  /// @dev Constant for locked guard state\r\n  uint256 internal constant REENTRANCY_GUARD_LOCKED = 2;\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  uint256 internal reentrancyLock = REENTRANCY_GUARD_FREE;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one `nonReentrant` function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and an `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(reentrancyLock == REENTRANCY_GUARD_FREE, \"nonReentrant\");\r\n    reentrancyLock = REENTRANCY_GUARD_LOCKED;\r\n    _;\r\n    reentrancyLock = REENTRANCY_GUARD_FREE;\r\n  }\r\n\r\n}\r\n\r\ncontract LoanTokenization is ReentrancyGuard, Ownable {\r\n\r\n    uint256 internal constant MAX_UINT = 2**256 - 1;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    address public bZxContract;\r\n    address public bZxVault;\r\n    address public bZxOracle;\r\n    address public wethContract;\r\n\r\n    address public loanTokenAddress;\r\n\r\n    // price of token at last user checkpoint\r\n    mapping (address => uint256) internal checkpointPrices_;\r\n}\r\n\r\ncontract LoanTokenStorage is LoanTokenization {\r\n\r\n    struct ListIndex {\r\n        uint256 index;\r\n        bool isSet;\r\n    }\r\n\r\n    struct LoanData {\r\n        bytes32 loanOrderHash;\r\n        uint256 leverageAmount;\r\n        uint256 initialMarginAmount;\r\n        uint256 maintenanceMarginAmount;\r\n        uint256 maxDurationUnixTimestampSec;\r\n        uint256 index;\r\n    }\r\n\r\n    struct TokenReserves {\r\n        address lender;\r\n        uint256 amount;\r\n    }\r\n\r\n    event Borrow(\r\n        address indexed borrower,\r\n        uint256 borrowAmount,\r\n        uint256 interestRate,\r\n        address collateralTokenAddress,\r\n        address tradeTokenToFillAddress,\r\n        bool withdrawOnOpen\r\n    );\r\n\r\n    event Claim(\r\n        address indexed claimant,\r\n        uint256 tokenAmount,\r\n        uint256 assetAmount,\r\n        uint256 remainingTokenAmount,\r\n        uint256 price\r\n    );\r\n\r\n    bool internal isInitialized_ = false;\r\n\r\n    address public tokenizedRegistry;\r\n\r\n    uint256 public baseRate = 1000000000000000000; // 1.0%\r\n    uint256 public rateMultiplier = 39000000000000000000; // 39%\r\n\r\n    // \"fee percentage retained by the oracle\" = SafeMath.sub(10**20, spreadMultiplier);\r\n    uint256 public spreadMultiplier;\r\n\r\n    mapping (uint256 => bytes32) public loanOrderHashes; // mapping of levergeAmount to loanOrderHash\r\n    mapping (bytes32 => LoanData) public loanOrderData; // mapping of loanOrderHash to LoanOrder\r\n    uint256[] public leverageList;\r\n\r\n    TokenReserves[] public burntTokenReserveList; // array of TokenReserves\r\n    mapping (address => ListIndex) public burntTokenReserveListIndex; // mapping of lender address to ListIndex objects\r\n    uint256 public burntTokenReserved; // total outstanding burnt token amount\r\n    address internal nextOwedLender_;\r\n\r\n    uint256 public totalAssetBorrow = 0; // current amount of loan token amount tied up in loans\r\n\r\n    uint256 internal checkpointSupply_;\r\n\r\n    uint256 internal lastSettleTime_;\r\n\r\n    uint256 public initialPrice;\r\n}\r\n\r\ncontract AdvancedTokenStorage is LoanTokenStorage {\r\n    using SafeMath for uint256;\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Mint(\r\n        address indexed minter,\r\n        uint256 tokenAmount,\r\n        uint256 assetAmount,\r\n        uint256 price\r\n    );\r\n    event Burn(\r\n        address indexed burner,\r\n        uint256 tokenAmount,\r\n        uint256 assetAmount,\r\n        uint256 price\r\n    );\r\n\r\n    mapping(address => uint256) internal balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n    uint256 internal totalSupply_;\r\n\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalSupply_;\r\n    }\r\n\r\n    function balanceOf(\r\n        address _owner)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function allowance(\r\n        address _owner,\r\n        address _spender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract AdvancedToken is AdvancedTokenStorage {\r\n    using SafeMath for uint256;\r\n\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(\r\n        address _spender,\r\n        uint256 _addedValue)\r\n        public\r\n        returns (bool)\r\n    {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(\r\n        address _spender,\r\n        uint256 _subtractedValue)\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint256 oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue >= oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function _mint(\r\n        address _to,\r\n        uint256 _tokenAmount,\r\n        uint256 _assetAmount,\r\n        uint256 _price)\r\n        internal\r\n    {\r\n        require(_to != address(0), \"invalid address\");\r\n        totalSupply_ = totalSupply_.add(_tokenAmount);\r\n        balances[_to] = balances[_to].add(_tokenAmount);\r\n\r\n        emit Mint(_to, _tokenAmount, _assetAmount, _price);\r\n        emit Transfer(address(0), _to, _tokenAmount);\r\n    }\r\n\r\n    function _burn(\r\n        address _who,\r\n        uint256 _tokenAmount,\r\n        uint256 _assetAmount,\r\n        uint256 _price)\r\n        internal\r\n    {\r\n        require(_tokenAmount <= balances[_who], \"burn value exceeds balance\");\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        balances[_who] = balances[_who].sub(_tokenAmount);\r\n        if (balances[_who] <= 10) { // we can't leave such small balance quantities\r\n            _tokenAmount = _tokenAmount.add(balances[_who]);\r\n            balances[_who] = 0;\r\n        }\r\n\r\n        totalSupply_ = totalSupply_.sub(_tokenAmount);\r\n\r\n        emit Burn(_who, _tokenAmount, _assetAmount, _price);\r\n        emit Transfer(_who, address(0), _tokenAmount);\r\n    }\r\n}\r\n\r\ncontract BZxObjects {\r\n\r\n    struct LoanOrder {\r\n        address loanTokenAddress;\r\n        address interestTokenAddress;\r\n        address collateralTokenAddress;\r\n        address oracleAddress;\r\n        uint256 loanTokenAmount;\r\n        uint256 interestAmount;\r\n        uint256 initialMarginAmount;\r\n        uint256 maintenanceMarginAmount;\r\n        uint256 maxDurationUnixTimestampSec;\r\n        bytes32 loanOrderHash;\r\n    }\r\n\r\n    struct LoanPosition {\r\n        address trader;\r\n        address collateralTokenAddressFilled;\r\n        address positionTokenAddressFilled;\r\n        uint256 loanTokenAmountFilled;\r\n        uint256 loanTokenAmountUsed;\r\n        uint256 collateralTokenAmountFilled;\r\n        uint256 positionTokenAmountFilled;\r\n        uint256 loanStartUnixTimestampSec;\r\n        uint256 loanEndUnixTimestampSec;\r\n        bool active;\r\n        uint256 positionId;\r\n    }\r\n}\r\n\r\ncontract OracleNotifierInterface {\r\n\r\n    function closeLoanNotifier(\r\n        BZxObjects.LoanOrder memory loanOrder,\r\n        BZxObjects.LoanPosition memory loanPosition,\r\n        address loanCloser,\r\n        uint256 closeAmount,\r\n        bool isLiquidation)\r\n        public\r\n        returns (bool);\r\n}\r\n\r\ninterface IBZx {\r\n    function pushLoanOrderOnChain(\r\n        address[8] calldata orderAddresses,\r\n        uint256[11] calldata orderValues,\r\n        bytes calldata oracleData,\r\n        bytes calldata signature)\r\n        external\r\n        returns (bytes32); // loanOrderHash\r\n\r\n    function setLoanOrderDesc(\r\n        bytes32 loanOrderHash,\r\n        string calldata desc)\r\n        external\r\n        returns (bool);\r\n\r\n    function updateLoanAsLender(\r\n        bytes32 loanOrderHash,\r\n        uint256 increaseAmountForLoan,\r\n        uint256 newInterestRate,\r\n        uint256 newExpirationTimestamp)\r\n        external\r\n        returns (bool);\r\n\r\n    function takeLoanOrderOnChainAsTraderByDelegate(\r\n        address trader,\r\n        bytes32 loanOrderHash,\r\n        address collateralTokenFilled,\r\n        uint256 loanTokenAmountFilled,\r\n        address tradeTokenToFillAddress,\r\n        bool withdrawOnOpen)\r\n        external\r\n        returns (uint256);\r\n\r\n    function getLenderInterestForOracle(\r\n        address lender,\r\n        address oracleAddress,\r\n        address interestTokenAddress)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,    // interestPaid\r\n            uint256,    // interestPaidDate\r\n            uint256,    // interestOwedPerDay\r\n            uint256);   // interestUnPaid\r\n\r\n    function oracleAddresses(\r\n        address oracleAddress)\r\n        external\r\n        view\r\n        returns (address);\r\n}\r\n\r\ninterface IBZxOracle {\r\n    function tradeUserAsset(\r\n        address sourceTokenAddress,\r\n        address destTokenAddress,\r\n        address receiverAddress,\r\n        address returnToSenderAddress,\r\n        uint256 sourceTokenAmount,\r\n        uint256 maxDestTokenAmount,\r\n        uint256 minConversionRate)\r\n        external\r\n        returns (uint256 destTokenAmountReceived, uint256 sourceTokenAmountUsed);\r\n\r\n    function interestFeePercent()\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\ninterface iTokenizedRegistry {\r\n    function getTokenAsset(\r\n        address _token,\r\n        uint256 _tokenType)\r\n        external\r\n        view\r\n        returns (address);\r\n}\r\n\r\ncontract LoanTokenLogic is AdvancedToken, OracleNotifierInterface {\r\n    using SafeMath for uint256;\r\n\r\n    modifier onlyOracle() {\r\n        require(msg.sender == IBZx(bZxContract).oracleAddresses(bZxOracle), \"unauthorized\");\r\n        _;\r\n    }\r\n\r\n\r\n    function()\r\n        external\r\n        payable\r\n    {}\r\n\r\n\r\n    /* Public functions */\r\n\r\n    function mintWithEther(\r\n        address receiver)\r\n        external\r\n        payable\r\n        nonReentrant\r\n        returns (uint256 mintAmount)\r\n    {\r\n        require(loanTokenAddress == wethContract, \"no ether\");\r\n        return _mintToken(\r\n            receiver,\r\n            msg.value\r\n        );\r\n    }\r\n\r\n    function mint(\r\n        address receiver,\r\n        uint256 depositAmount)\r\n        external\r\n        nonReentrant\r\n        returns (uint256 mintAmount)\r\n    {\r\n        return _mintToken(\r\n            receiver,\r\n            depositAmount\r\n        );\r\n    }\r\n\r\n    function burnToEther(\r\n        address payable receiver,\r\n        uint256 burnAmount)\r\n        external\r\n        nonReentrant\r\n        returns (uint256 loanAmountPaid)\r\n    {\r\n        require(loanTokenAddress == wethContract, \"no ether\");\r\n        loanAmountPaid = _burnToken(\r\n            receiver,\r\n            burnAmount\r\n        );\r\n\r\n        if (loanAmountPaid > 0) {\r\n            WETHInterface(wethContract).withdraw(loanAmountPaid);\r\n            require(receiver.send(loanAmountPaid), \"transfer failed\");\r\n        }\r\n    }\r\n\r\n    function burn(\r\n        address receiver,\r\n        uint256 burnAmount)\r\n        external\r\n        nonReentrant\r\n        returns (uint256 loanAmountPaid)\r\n    {\r\n        loanAmountPaid = _burnToken(\r\n            receiver,\r\n            burnAmount\r\n        );\r\n\r\n        if (loanAmountPaid > 0) {\r\n            require(ERC20(loanTokenAddress).transfer(\r\n                receiver,\r\n                loanAmountPaid\r\n            ), \"transfer failed\");\r\n        }\r\n    }\r\n\r\n    // called by a borrower to open a loan\r\n    // loan can be collateralized using any supported token (collateralTokenAddress)\r\n    // interest collected is denominated the same as loanToken\r\n    // returns borrowAmount\r\n    function borrowToken(\r\n        uint256 borrowAmount,\r\n        uint256 leverageAmount,\r\n        address collateralTokenAddress,\r\n        address tradeTokenToFillAddress,\r\n        bool withdrawOnOpen)\r\n        external\r\n        nonReentrant\r\n        returns (uint256)\r\n    {\r\n        uint256 amount = _borrowToken(\r\n            msg.sender,\r\n            borrowAmount,\r\n            leverageAmount,\r\n            collateralTokenAddress,\r\n            tradeTokenToFillAddress,\r\n            withdrawOnOpen,\r\n            false // calcBorrow\r\n        );\r\n        require(amount > 0, \"can't borrow\");\r\n        return amount;\r\n    }\r\n\r\n    // called by a borrower to open a loan\r\n    // escrowAmount == total collateral + interest available to back the loan\r\n    // escrowAmount is denominated the same as loanToken\r\n    // returns borrowAmount\r\n    function borrowTokenFromEscrow(\r\n        uint256 escrowAmount,\r\n        uint256 leverageAmount,\r\n        address tradeTokenToFillAddress,\r\n        bool withdrawOnOpen)\r\n        external\r\n        nonReentrant\r\n        returns (uint256)\r\n    {\r\n        uint256 amount = _borrowToken(\r\n            msg.sender,\r\n            escrowAmount,\r\n            leverageAmount,\r\n            loanTokenAddress, // collateralTokenAddress\r\n            tradeTokenToFillAddress,\r\n            withdrawOnOpen,\r\n            true // calcBorrow\r\n        );\r\n        require(amount > 0, \"can't borrow\");\r\n        return amount;\r\n    }\r\n\r\n    function rolloverPosition(\r\n        address borrower,\r\n        uint256 leverageAmount,\r\n        uint256 escrowAmount,\r\n        address tradeTokenToFillAddress)\r\n        external\r\n        returns (uint256)\r\n    {\r\n        require(msg.sender == address(this), \"unauthorized\");\r\n\r\n        return _borrowToken(\r\n            borrower,\r\n            escrowAmount,\r\n            leverageAmount,\r\n            loanTokenAddress, // collateralTokenAddress\r\n            tradeTokenToFillAddress,\r\n            false, // withdrawOnOpen\r\n            true // calcBorrow\r\n        );\r\n    }\r\n\r\n    // Claims owned loan token for the caller\r\n    // Also claims for user with the longest reserves\r\n    // returns amount claimed for the caller\r\n    function claimLoanToken()\r\n        external\r\n        nonReentrant\r\n        returns (uint256 claimedAmount)\r\n    {\r\n        claimedAmount = _claimLoanToken(msg.sender);\r\n\r\n        if (burntTokenReserveList.length > 0) {\r\n            _claimLoanToken(_getNextOwed());\r\n\r\n            if (burntTokenReserveListIndex[msg.sender].isSet && nextOwedLender_ != msg.sender) {\r\n                // ensure lender is paid next\r\n                nextOwedLender_ = msg.sender;\r\n            }\r\n        }\r\n    }\r\n\r\n    function settleInterest()\r\n        external\r\n        nonReentrant\r\n    {\r\n        _settleInterest();\r\n    }\r\n\r\n    function wrapEther()\r\n        public\r\n    {\r\n        if (address(this).balance > 0) {\r\n            WETHInterface(wethContract).deposit.value(address(this).balance)();\r\n        }\r\n    }\r\n\r\n    // Sends non-LoanToken assets to the Oracle fund\r\n    // These are assets that would otherwise be \"stuck\" due to a user accidently sending them to the contract\r\n    function donateAsset(\r\n        address tokenAddress)\r\n        public\r\n        returns (bool)\r\n    {\r\n        if (tokenAddress == loanTokenAddress)\r\n            return false;\r\n\r\n        uint256 balance = ERC20(tokenAddress).balanceOf(address(this));\r\n        if (balance == 0)\r\n            return false;\r\n\r\n        require(ERC20(tokenAddress).transfer(\r\n            IBZx(bZxContract).oracleAddresses(bZxOracle),\r\n            balance\r\n        ), \"transfer failed\");\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(\r\n        address _to,\r\n        uint256 _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_value <= balances[msg.sender], \"insufficient balance\");\r\n        require(_to != address(0), \"token burn not allowed\");\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        // handle checkpoint update\r\n        uint256 currentPrice = tokenPrice();\r\n        if (burntTokenReserveListIndex[msg.sender].isSet || balances[msg.sender] > 0) {\r\n            checkpointPrices_[msg.sender] = currentPrice;\r\n        } else {\r\n            checkpointPrices_[msg.sender] = 0;\r\n        }\r\n        if (burntTokenReserveListIndex[_to].isSet || balances[_to] > 0) {\r\n            checkpointPrices_[_to] = currentPrice;\r\n        } else {\r\n            checkpointPrices_[_to] = 0;\r\n        }\r\n\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint256 allowanceAmount = allowed[_from][msg.sender];\r\n        require(_value <= balances[_from], \"insufficient balance\");\r\n        require(_value <= allowanceAmount, \"insufficient allowance\");\r\n        require(_to != address(0), \"token burn not allowed\");\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if (allowanceAmount < MAX_UINT) {\r\n            allowed[_from][msg.sender] = allowanceAmount.sub(_value);\r\n        }\r\n\r\n        // handle checkpoint update\r\n        uint256 currentPrice = tokenPrice();\r\n        if (burntTokenReserveListIndex[_from].isSet || balances[_from] > 0) {\r\n            checkpointPrices_[_from] = currentPrice;\r\n        } else {\r\n            checkpointPrices_[_from] = 0;\r\n        }\r\n        if (burntTokenReserveListIndex[_to].isSet || balances[_to] > 0) {\r\n            checkpointPrices_[_to] = currentPrice;\r\n        } else {\r\n            checkpointPrices_[_to] = 0;\r\n        }\r\n\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    /* Public View functions */\r\n\r\n    function tokenPrice()\r\n        public\r\n        view\r\n        returns (uint256 price)\r\n    {\r\n        uint256 interestUnPaid = 0;\r\n        if (lastSettleTime_ != block.timestamp) {\r\n            (,,interestUnPaid) = _getAllInterest();\r\n\r\n            interestUnPaid = interestUnPaid\r\n                .mul(spreadMultiplier)\r\n                .div(10**20);\r\n        }\r\n\r\n        return _tokenPrice(_totalAssetSupply(interestUnPaid));\r\n    }\r\n\r\n    function checkpointPrice(\r\n        address _user)\r\n        public\r\n        view\r\n        returns (uint256 price)\r\n    {\r\n        return checkpointPrices_[_user];\r\n    }\r\n\r\n    function totalReservedSupply()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return burntTokenReserved.mul(tokenPrice()).div(10**18);\r\n    }\r\n\r\n    function marketLiquidity()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 totalSupply = totalAssetSupply();\r\n        uint256 reservedSupply = totalReservedSupply();\r\n        if (totalSupply > reservedSupply) {\r\n            totalSupply = totalSupply.sub(reservedSupply);\r\n        } else {\r\n            return 0;\r\n        }\r\n\r\n        if (totalSupply > totalAssetBorrow) {\r\n            return totalSupply.sub(totalAssetBorrow);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    // interest that borrowers are currently paying for open loans, prior to any fees\r\n    function borrowInterestRate()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (totalAssetBorrow > 0) {\r\n            return _protocolInterestRate(totalAssetSupply());\r\n        } else {\r\n            return baseRate;\r\n        }\r\n    }\r\n\r\n    // interest that lenders are currently receiving for open loans, prior to any fees\r\n    function supplyInterestRate()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 assetSupply = totalAssetSupply();\r\n        if (totalAssetBorrow > 0) {\r\n            return _protocolInterestRate(assetSupply)\r\n                .mul(_getUtilizationRate(assetSupply))\r\n                .div(10**20);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    // the rate the next base protocol borrower will receive based on the amount being borrowed\r\n    function nextLoanInterestRate(\r\n        uint256 borrowAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (borrowAmount > 0) {\r\n            uint256 interestUnPaid = 0;\r\n            if (lastSettleTime_ != block.timestamp) {\r\n                (,,interestUnPaid) = _getAllInterest();\r\n\r\n                interestUnPaid = interestUnPaid\r\n                    .mul(spreadMultiplier)\r\n                    .div(10**20);\r\n            }\r\n\r\n            uint256 balance = ERC20(loanTokenAddress).balanceOf(address(this)).add(interestUnPaid);\r\n            if (borrowAmount > balance) {\r\n                borrowAmount = balance;\r\n            }\r\n        }\r\n\r\n        return _nextLoanInterestRate(borrowAmount);\r\n    }\r\n\r\n    // returns the total amount of interest earned for all active loans\r\n    function interestReceived()\r\n        public\r\n        view\r\n        returns (uint256 interestTotalAccrued)\r\n    {\r\n        (uint256 interestPaidSoFar,,uint256 interestUnPaid) = _getAllInterest();\r\n\r\n        return interestPaidSoFar\r\n            .add(interestUnPaid)\r\n            .mul(spreadMultiplier)\r\n            .div(10**20);\r\n    }\r\n\r\n    function totalAssetSupply()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 interestUnPaid = 0;\r\n        if (lastSettleTime_ != block.timestamp) {\r\n            (,,interestUnPaid) = _getAllInterest();\r\n\r\n            interestUnPaid = interestUnPaid\r\n                .mul(spreadMultiplier)\r\n                .div(10**20);\r\n        }\r\n\r\n        return _totalAssetSupply(interestUnPaid);\r\n    }\r\n\r\n    function getMaxEscrowAmount(\r\n        uint256 leverageAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        LoanData memory loanData = loanOrderData[loanOrderHashes[leverageAmount]];\r\n        if (loanData.initialMarginAmount == 0)\r\n            return 0;\r\n\r\n        return marketLiquidity()\r\n            .mul(loanData.initialMarginAmount)\r\n            .div(_adjustValue(\r\n                10**20, // maximum possible interest (100%)\r\n                loanData.maxDurationUnixTimestampSec,\r\n                loanData.initialMarginAmount));\r\n    }\r\n\r\n    function getBorrowAmount(\r\n        uint256 escrowAmount,\r\n        uint256 leverageAmount,\r\n        bool withdrawOnOpen)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (escrowAmount == 0)\r\n            return 0;\r\n\r\n        LoanData memory loanData = loanOrderData[loanOrderHashes[leverageAmount]];\r\n        if (loanData.initialMarginAmount == 0)\r\n            return 0;\r\n\r\n        return _getBorrowAmount(\r\n            loanData.initialMarginAmount,\r\n            escrowAmount,\r\n            nextLoanInterestRate(\r\n                escrowAmount\r\n                    .mul(10**20)\r\n                    .div(loanData.initialMarginAmount)\r\n            ),\r\n            loanData.maxDurationUnixTimestampSec,\r\n            withdrawOnOpen\r\n        );\r\n    }\r\n\r\n    function getLoanData(\r\n        uint256 levergeAmount)\r\n        public\r\n        view\r\n        returns (LoanData memory)\r\n    {\r\n        return loanOrderData[loanOrderHashes[levergeAmount]];\r\n    }\r\n\r\n    function getLeverageList()\r\n        public\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        return leverageList;\r\n    }\r\n\r\n    // returns the user's balance of underlying token\r\n    function assetBalanceOf(\r\n        address _owner)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return balanceOf(_owner)\r\n            .mul(tokenPrice())\r\n            .div(10**18);\r\n    }\r\n\r\n\r\n    /* Internal functions */\r\n\r\n    function _mintToken(\r\n        address receiver,\r\n        uint256 depositAmount)\r\n        internal\r\n        returns (uint256 mintAmount)\r\n    {\r\n        require (depositAmount > 0, \"amount == 0\");\r\n\r\n        if (burntTokenReserveList.length > 0) {\r\n            _claimLoanToken(_getNextOwed());\r\n            _claimLoanToken(receiver);\r\n            if (msg.sender != receiver)\r\n                _claimLoanToken(msg.sender);\r\n        } else {\r\n            _settleInterest();\r\n        }\r\n\r\n        uint256 currentPrice = _tokenPrice(_totalAssetSupply(0));\r\n        mintAmount = depositAmount.mul(10**18).div(currentPrice);\r\n\r\n        if (msg.value == 0) {\r\n            require(ERC20(loanTokenAddress).transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                depositAmount\r\n            ), \"transfer failed\");\r\n        } else {\r\n            WETHInterface(wethContract).deposit.value(depositAmount)();\r\n        }\r\n\r\n        _mint(receiver, mintAmount, depositAmount, currentPrice);\r\n\r\n        checkpointPrices_[receiver] = currentPrice;\r\n    }\r\n\r\n    function _burnToken(\r\n        address receiver,\r\n        uint256 burnAmount)\r\n        internal\r\n        returns (uint256 loanAmountPaid)\r\n    {\r\n        require(burnAmount > 0, \"amount == 0\");\r\n\r\n        if (burnAmount > balanceOf(msg.sender)) {\r\n            burnAmount = balanceOf(msg.sender);\r\n        }\r\n\r\n        if (burntTokenReserveList.length > 0) {\r\n            _claimLoanToken(_getNextOwed());\r\n            _claimLoanToken(receiver);\r\n            if (msg.sender != receiver)\r\n                _claimLoanToken(msg.sender);\r\n        } else {\r\n            _settleInterest();\r\n        }\r\n\r\n        uint256 currentPrice = _tokenPrice(_totalAssetSupply(0));\r\n\r\n        uint256 loanAmountOwed = burnAmount.mul(currentPrice).div(10**18);\r\n        uint256 loanAmountAvailableInContract = ERC20(loanTokenAddress).balanceOf(address(this));\r\n\r\n        loanAmountPaid = loanAmountOwed;\r\n        if (loanAmountPaid > loanAmountAvailableInContract) {\r\n            uint256 reserveAmount = loanAmountPaid.sub(loanAmountAvailableInContract);\r\n            uint256 reserveTokenAmount = reserveAmount.mul(10**18).div(currentPrice);\r\n\r\n            burntTokenReserved = burntTokenReserved.add(reserveTokenAmount);\r\n            if (burntTokenReserveListIndex[receiver].isSet) {\r\n                uint256 index = burntTokenReserveListIndex[receiver].index;\r\n                burntTokenReserveList[index].amount = burntTokenReserveList[index].amount.add(reserveTokenAmount);\r\n            } else {\r\n                burntTokenReserveList.push(TokenReserves({\r\n                    lender: receiver,\r\n                    amount: reserveTokenAmount\r\n                }));\r\n                burntTokenReserveListIndex[receiver] = ListIndex({\r\n                    index: burntTokenReserveList.length-1,\r\n                    isSet: true\r\n                });\r\n            }\r\n\r\n            loanAmountPaid = loanAmountAvailableInContract;\r\n        }\r\n\r\n        _burn(msg.sender, burnAmount, loanAmountPaid, currentPrice);\r\n\r\n        if (burntTokenReserveListIndex[msg.sender].isSet || balances[msg.sender] > 0) {\r\n            checkpointPrices_[msg.sender] = currentPrice;\r\n        } else {\r\n            checkpointPrices_[msg.sender] = 0;\r\n        }\r\n    }\r\n\r\n    function _settleInterest()\r\n        internal\r\n    {\r\n        if (lastSettleTime_ != block.timestamp) {\r\n            (bool success,) = bZxContract.call.gas(gasleft())(\r\n                abi.encodeWithSignature(\r\n                    \"payInterestForOracle(address,address)\",\r\n                    bZxOracle, // (leave as original value)\r\n                    loanTokenAddress // same as interestTokenAddress\r\n                )\r\n            );\r\n            success;\r\n            lastSettleTime_ = block.timestamp;\r\n        }\r\n    }\r\n\r\n    function _getNextOwed()\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        if (nextOwedLender_ != address(0))\r\n            return nextOwedLender_;\r\n        else if (burntTokenReserveList.length > 0)\r\n            return burntTokenReserveList[0].lender;\r\n        else\r\n            return address(0);\r\n    }\r\n\r\n    function _claimLoanToken(\r\n        address lender)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        _settleInterest();\r\n\r\n        if (!burntTokenReserveListIndex[lender].isSet)\r\n            return 0;\r\n\r\n        uint256 index = burntTokenReserveListIndex[lender].index;\r\n        uint256 currentPrice = _tokenPrice(_totalAssetSupply(0));\r\n\r\n        uint256 claimAmount = burntTokenReserveList[index].amount.mul(currentPrice).div(10**18);\r\n        if (claimAmount == 0)\r\n            return 0;\r\n\r\n        uint256 availableAmount = ERC20(loanTokenAddress).balanceOf(address(this));\r\n        if (availableAmount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 claimTokenAmount;\r\n        if (claimAmount <= availableAmount) {\r\n            claimTokenAmount = burntTokenReserveList[index].amount;\r\n            _removeFromList(lender, index);\r\n        } else {\r\n            claimAmount = availableAmount;\r\n            claimTokenAmount = claimAmount.mul(10**18).div(currentPrice);\r\n\r\n            // prevents less than 10 being left in burntTokenReserveList[index].amount\r\n            if (claimTokenAmount.add(10) < burntTokenReserveList[index].amount) {\r\n                burntTokenReserveList[index].amount = burntTokenReserveList[index].amount.sub(claimTokenAmount);\r\n            } else {\r\n                _removeFromList(lender, index);\r\n            }\r\n        }\r\n\r\n        require(ERC20(loanTokenAddress).transfer(\r\n            lender,\r\n            claimAmount\r\n        ), \"transfer failed\");\r\n\r\n        if (burntTokenReserveListIndex[lender].isSet || balances[lender] > 0) {\r\n            checkpointPrices_[lender] = currentPrice;\r\n        } else {\r\n            checkpointPrices_[lender] = 0;\r\n        }\r\n\r\n        burntTokenReserved = burntTokenReserved > claimTokenAmount ?\r\n            burntTokenReserved.sub(claimTokenAmount) :\r\n            0;\r\n\r\n        emit Claim(\r\n            lender,\r\n            claimTokenAmount,\r\n            claimAmount,\r\n            burntTokenReserveListIndex[lender].isSet ?\r\n                burntTokenReserveList[burntTokenReserveListIndex[lender].index].amount :\r\n                0,\r\n            currentPrice\r\n        );\r\n\r\n        return claimAmount;\r\n    }\r\n\r\n    function _borrowToken(\r\n        address msgsender,\r\n        uint256 borrowAmount,\r\n        uint256 leverageAmount,\r\n        address collateralTokenAddress,\r\n        address tradeTokenToFillAddress,\r\n        bool withdrawOnOpen,\r\n        bool calcBorrow)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        if (borrowAmount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        bytes32 loanOrderHash = loanOrderHashes[leverageAmount];\r\n        LoanData memory loanData = loanOrderData[loanOrderHash];\r\n        require(loanData.initialMarginAmount != 0, \"invalid leverage\");\r\n\r\n        _settleInterest();\r\n\r\n        uint256 interestRate;\r\n        if (calcBorrow) {\r\n            interestRate = _nextLoanInterestRate(\r\n                borrowAmount // escrowAmount\r\n                    .mul(10**20)\r\n                    .div(loanData.initialMarginAmount)\r\n            );\r\n\r\n            borrowAmount = _getBorrowAmount(\r\n                loanData.initialMarginAmount,\r\n                borrowAmount, // escrowAmount,\r\n                interestRate,\r\n                loanData.maxDurationUnixTimestampSec,\r\n                withdrawOnOpen\r\n            );\r\n        } else {\r\n            interestRate = _nextLoanInterestRate(borrowAmount);\r\n        }\r\n\r\n        return _borrowTokenFinal(\r\n            msgsender,\r\n            loanOrderHash,\r\n            borrowAmount,\r\n            interestRate,\r\n            collateralTokenAddress,\r\n            tradeTokenToFillAddress,\r\n            withdrawOnOpen\r\n        );\r\n    }\r\n\r\n    // returns borrowAmount\r\n    function _borrowTokenFinal(\r\n        address msgsender,\r\n        bytes32 loanOrderHash,\r\n        uint256 borrowAmount,\r\n        uint256 interestRate,\r\n        address collateralTokenAddress,\r\n        address tradeTokenToFillAddress,\r\n        bool withdrawOnOpen)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        //require(ERC20(loanTokenAddress).balanceOf(address(this)) >= borrowAmount, \"insufficient loan supply\");\r\n        uint256 availableToBorrow = ERC20(loanTokenAddress).balanceOf(address(this));\r\n        if (availableToBorrow == 0)\r\n            return 0;\r\n\r\n        uint256 reservedSupply = totalReservedSupply();\r\n        if (availableToBorrow > reservedSupply) {\r\n            availableToBorrow = availableToBorrow.sub(reservedSupply);\r\n        } else {\r\n            return 0;\r\n        }\r\n\r\n        if (borrowAmount > availableToBorrow) {\r\n            borrowAmount = availableToBorrow;\r\n        }\r\n\r\n        // re-up the BZxVault spend approval if needed\r\n        uint256 tempAllowance = ERC20(loanTokenAddress).allowance(address(this), bZxVault);\r\n        if (tempAllowance < borrowAmount) {\r\n            if (tempAllowance > 0) {\r\n                // reset approval to 0\r\n                require(ERC20(loanTokenAddress).approve(bZxVault, 0), \"approval failed\");\r\n            }\r\n\r\n            require(ERC20(loanTokenAddress).approve(bZxVault, MAX_UINT), \"approval failed\");\r\n        }\r\n\r\n        require(IBZx(bZxContract).updateLoanAsLender(\r\n            loanOrderHash,\r\n            borrowAmount,\r\n            interestRate.div(365),\r\n            block.timestamp+1),\r\n            \"updateLoan failed\"\r\n        );\r\n\r\n        require (IBZx(bZxContract).takeLoanOrderOnChainAsTraderByDelegate(\r\n            msgsender,\r\n            loanOrderHash,\r\n            collateralTokenAddress,\r\n            borrowAmount,\r\n            tradeTokenToFillAddress,\r\n            withdrawOnOpen) == borrowAmount,\r\n            \"takeLoan failed\"\r\n        );\r\n\r\n        // update total borrowed amount outstanding in loans\r\n        totalAssetBorrow = totalAssetBorrow.add(borrowAmount);\r\n\r\n        // checkpoint supply since the base protocol borrow stats have changed\r\n        checkpointSupply_ = _totalAssetSupply(0);\r\n\r\n        if (burntTokenReserveList.length > 0) {\r\n            _claimLoanToken(_getNextOwed());\r\n            _claimLoanToken(msgsender);\r\n        }\r\n\r\n        emit Borrow(\r\n            msgsender,\r\n            borrowAmount,\r\n            interestRate,\r\n            collateralTokenAddress,\r\n            tradeTokenToFillAddress,\r\n            withdrawOnOpen\r\n        );\r\n\r\n        return borrowAmount;\r\n    }\r\n\r\n    function _removeFromList(\r\n        address lender,\r\n        uint256 index)\r\n        internal\r\n    {\r\n        // remove lender from burntToken list\r\n        if (burntTokenReserveList.length > 1) {\r\n            // replace item in list with last item in array\r\n            burntTokenReserveList[index] = burntTokenReserveList[burntTokenReserveList.length - 1];\r\n\r\n            // update the position of this replacement\r\n            burntTokenReserveListIndex[burntTokenReserveList[index].lender].index = index;\r\n        }\r\n\r\n        // trim array and clear storage\r\n        burntTokenReserveList.length--;\r\n        burntTokenReserveListIndex[lender].index = 0;\r\n        burntTokenReserveListIndex[lender].isSet = false;\r\n\r\n        if (lender == nextOwedLender_) {\r\n            nextOwedLender_ = address(0);\r\n        }\r\n    }\r\n\r\n\r\n    /* Internal View functions */\r\n\r\n    function _tokenPrice(\r\n        uint256 assetSupply)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 totalTokenSupply = totalSupply_.add(burntTokenReserved);\r\n\r\n        return totalTokenSupply > 0 ?\r\n            assetSupply\r\n                .mul(10**18)\r\n                .div(totalTokenSupply) : initialPrice;\r\n    }\r\n\r\n    function _protocolInterestRate(\r\n        uint256 assetSupply)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 interestRate;\r\n        if (totalAssetBorrow > 0) {\r\n            (,uint256 interestOwedPerDay,) = _getAllInterest();\r\n            interestRate = interestOwedPerDay\r\n                .mul(10**20)\r\n                .div(totalAssetBorrow)\r\n                .mul(365)\r\n                .mul(checkpointSupply_)\r\n                .div(assetSupply);\r\n        } else {\r\n            interestRate = baseRate;\r\n        }\r\n\r\n        return interestRate;\r\n    }\r\n\r\n    // next loan interest adjustment\r\n    function _nextLoanInterestRate(\r\n        uint256 newBorrowAmount)\r\n        internal\r\n        view\r\n        returns (uint256 nextRate)\r\n    {\r\n        uint256 assetSupply = totalAssetSupply();\r\n\r\n        uint256 utilizationRate = _getUtilizationRate(assetSupply)\r\n            .add(newBorrowAmount > 0 ?\r\n                newBorrowAmount\r\n                .mul(10**20)\r\n                .div(assetSupply) : 0);\r\n\r\n        uint256 minRate = baseRate;\r\n        uint256 maxRate = rateMultiplier.add(baseRate);\r\n\r\n        if (utilizationRate > 90 ether) {\r\n            // scale rate proportionally up to 100%\r\n\r\n            utilizationRate = utilizationRate.sub(90 ether);\r\n            if (utilizationRate > 10 ether)\r\n                utilizationRate = 10 ether;\r\n\r\n            maxRate = maxRate\r\n                .mul(90)\r\n                .div(100);\r\n\r\n            nextRate = utilizationRate\r\n                .mul(SafeMath.sub(100 ether, maxRate))\r\n                .div(10 ether)\r\n                .add(maxRate);\r\n        } else {\r\n            nextRate = utilizationRate\r\n                .mul(rateMultiplier)\r\n                .div(10**20)\r\n                .add(baseRate);\r\n\r\n            if (nextRate < minRate)\r\n                nextRate = minRate;\r\n            else if (nextRate > maxRate)\r\n                nextRate = maxRate;\r\n        }\r\n\r\n        return nextRate;\r\n    }\r\n\r\n    function _getAllInterest()\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 interestPaidSoFar,\r\n            uint256 interestOwedPerDay,\r\n            uint256 interestUnPaid)\r\n    {\r\n        // these values don't account for any fees retained by the oracle, so we account for it elsewhere with spreadMultiplier\r\n        (interestPaidSoFar,,interestOwedPerDay,interestUnPaid) = IBZx(bZxContract).getLenderInterestForOracle(\r\n            address(this),\r\n            bZxOracle, // (leave as original value)\r\n            loanTokenAddress // same as interestTokenAddress\r\n        );\r\n    }\r\n\r\n    function _getBorrowAmount(\r\n        uint256 marginAmount,\r\n        uint256 escrowAmount,\r\n        uint256 interestRate,\r\n        uint256 maxDuration,\r\n        bool withdrawOnOpen)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (withdrawOnOpen) {\r\n            // adjust for over-collateralized loan (initial margin + 100% margin)\r\n            marginAmount = marginAmount.add(10**20);\r\n        }\r\n\r\n        // assumes that loan, collateral, and interest token are the same\r\n        return escrowAmount\r\n            .mul(10**40)\r\n            .div(_adjustValue(\r\n                interestRate,\r\n                maxDuration,\r\n                marginAmount))\r\n            .div(marginAmount);\r\n    }\r\n\r\n    function _adjustValue(\r\n        uint256 interestRate,\r\n        uint256 maxDuration,\r\n        uint256 marginAmount)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return maxDuration > 0 ?\r\n            interestRate\r\n                .mul(10**20)\r\n                .div(31536000) // 86400 * 365\r\n                .mul(maxDuration)\r\n                .div(marginAmount)\r\n                .add(10**20) :\r\n            10**20;\r\n    }\r\n\r\n    function _getUtilizationRate(\r\n        uint256 assetSupply)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (totalAssetBorrow > 0 && assetSupply > 0) {\r\n            // U = total_borrow / total_supply\r\n            return totalAssetBorrow\r\n                .mul(10**20)\r\n                .div(assetSupply);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function _totalAssetSupply(\r\n        uint256 interestUnPaid)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalSupply_.add(burntTokenReserved) > 0 ?\r\n            ERC20(loanTokenAddress).balanceOf(address(this))\r\n                .add(totalAssetBorrow)\r\n                .add(interestUnPaid) : 0;\r\n    }\r\n\r\n\r\n    /* Oracle-Only functions */\r\n\r\n    // called only by BZxOracle when a loan is partially or fully closed\r\n    function closeLoanNotifier(\r\n        BZxObjects.LoanOrder memory loanOrder,\r\n        BZxObjects.LoanPosition memory loanPosition,\r\n        address loanCloser,\r\n        uint256 closeAmount,\r\n        bool /* isLiquidation */)\r\n        public\r\n        onlyOracle\r\n        returns (bool)\r\n    {\r\n        LoanData memory loanData = loanOrderData[loanOrder.loanOrderHash];\r\n        if (loanData.loanOrderHash == loanOrder.loanOrderHash) {\r\n\r\n            totalAssetBorrow = totalAssetBorrow > closeAmount ?\r\n                totalAssetBorrow.sub(closeAmount) : 0;\r\n\r\n            if (burntTokenReserveList.length > 0) {\r\n                _claimLoanToken(_getNextOwed());\r\n            } else {\r\n                _settleInterest();\r\n            }\r\n\r\n            if (closeAmount == 0)\r\n                return true;\r\n\r\n            // checkpoint supply since the base protocol borrow stats have changed\r\n            checkpointSupply_ = _totalAssetSupply(0);\r\n\r\n            if (loanCloser != loanPosition.trader) {\r\n\r\n                address tradeTokenAddress = iTokenizedRegistry(tokenizedRegistry).getTokenAsset(\r\n                    loanPosition.trader,\r\n                    2 // tokenType=pToken\r\n                );\r\n\r\n                if (tradeTokenAddress != address(0)) {\r\n\r\n                    uint256 escrowAmount = ERC20(loanTokenAddress).balanceOf(loanPosition.trader);\r\n\r\n                    if (escrowAmount > 0) {\r\n                        (bool success,) = address(this).call.gas(gasleft())(\r\n                            abi.encodeWithSignature(\r\n                                \"rolloverPosition(address,uint256,uint256,address)\",\r\n                                loanPosition.trader,\r\n                                loanData.leverageAmount,\r\n                                escrowAmount,\r\n                                tradeTokenAddress\r\n                            )\r\n                        );\r\n                        success;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    /* Owner-Only functions */\r\n\r\n    function initLeverage(\r\n        uint256[4] memory orderParams) // leverageAmount, initialMarginAmount, maintenanceMarginAmount, maxDurationUnixTimestampSec\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(loanOrderHashes[orderParams[0]] == 0);\r\n\r\n        address[8] memory orderAddresses = [\r\n            address(this), // makerAddress\r\n            loanTokenAddress, // loanTokenAddress\r\n            loanTokenAddress, // interestTokenAddress (same as loanToken)\r\n            address(0), // collateralTokenAddress\r\n            address(0), // feeRecipientAddress\r\n            bZxOracle, // (leave as original value)\r\n            address(0), // takerAddress\r\n            address(0) // tradeTokenToFillAddress\r\n        ];\r\n\r\n        uint256[11] memory orderValues = [\r\n            0, // loanTokenAmount\r\n            0, // interestAmountPerDay\r\n            orderParams[1], // initialMarginAmount,\r\n            orderParams[2], // maintenanceMarginAmount,\r\n            0, // lenderRelayFee\r\n            0, // traderRelayFee\r\n            orderParams[3], // maxDurationUnixTimestampSec,\r\n            0, // expirationUnixTimestampSec\r\n            0, // makerRole (0 = lender)\r\n            0, // withdrawOnOpen\r\n            uint(keccak256(abi.encodePacked(msg.sender, block.timestamp))) // salt\r\n        ];\r\n\r\n        bytes32 loanOrderHash = IBZx(bZxContract).pushLoanOrderOnChain(\r\n            orderAddresses,\r\n            orderValues,\r\n            abi.encodePacked(address(this)), // oracleData -> closeLoanNotifier\r\n            \"\"\r\n        );\r\n        IBZx(bZxContract).setLoanOrderDesc(\r\n            loanOrderHash,\r\n            name\r\n        );\r\n        loanOrderData[loanOrderHash] = LoanData({\r\n            loanOrderHash: loanOrderHash,\r\n            leverageAmount: orderParams[0],\r\n            initialMarginAmount: orderParams[1],\r\n            maintenanceMarginAmount: orderParams[2],\r\n            maxDurationUnixTimestampSec: orderParams[3],\r\n            index: leverageList.length\r\n        });\r\n        loanOrderHashes[orderParams[0]] = loanOrderHash;\r\n        leverageList.push(orderParams[0]);\r\n    }\r\n\r\n    function removeLeverage(\r\n        uint256 leverageAmount)\r\n        public\r\n        onlyOwner\r\n    {\r\n        bytes32 loanOrderHash = loanOrderHashes[leverageAmount];\r\n        require(loanOrderHash != 0);\r\n\r\n        if (leverageList.length > 1) {\r\n            uint256 index = loanOrderData[loanOrderHash].index;\r\n            leverageList[index] = leverageList[leverageList.length - 1];\r\n            loanOrderData[loanOrderHashes[leverageList[index]]].index = index;\r\n        }\r\n        leverageList.length--;\r\n\r\n        delete loanOrderHashes[leverageAmount];\r\n        delete loanOrderData[loanOrderHash];\r\n    }\r\n\r\n    // These params should be percentages represented like so: 5% = 5000000000000000000\r\n    // rateMultiplier + baseRate can't exceed 100%\r\n    function setDemandCurve(\r\n        uint256 _baseRate,\r\n        uint256 _rateMultiplier)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(rateMultiplier.add(baseRate) <= 10**20);\r\n        baseRate = _baseRate;\r\n        rateMultiplier = _rateMultiplier;\r\n    }\r\n\r\n    function setInterestFeePercent(\r\n        uint256 _newRate)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(_newRate <= 10**20);\r\n        spreadMultiplier = SafeMath.sub(10**20, _newRate);\r\n    }\r\n\r\n    function setBZxContract(\r\n        address _addr)\r\n        public\r\n        onlyOwner\r\n    {\r\n        bZxContract = _addr;\r\n    }\r\n\r\n    function setBZxVault(\r\n        address _addr)\r\n        public\r\n        onlyOwner\r\n    {\r\n        bZxVault = _addr;\r\n    }\r\n\r\n    function setBZxOracle(\r\n        address _addr)\r\n        public\r\n        onlyOwner\r\n    {\r\n        bZxOracle = _addr;\r\n    }\r\n\r\n    function setTokenizedRegistry(\r\n        address _addr)\r\n        public\r\n        onlyOwner\r\n    {\r\n        tokenizedRegistry = _addr;\r\n    }\r\n\r\n    function setWETHContract(\r\n        address _addr)\r\n        public\r\n        onlyOwner\r\n    {\r\n        wethContract = _addr;\r\n    }\r\n\r\n    function setInitialPrice(\r\n        uint256 _value)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(_value > 0);\r\n        initialPrice = _value;\r\n    }\r\n\r\n    function initialize(\r\n        address _bZxContract,\r\n        address _bZxVault,\r\n        address _bZxOracle,\r\n        address _wethContract,\r\n        address _loanTokenAddress,\r\n        address _tokenizedRegistry,\r\n        string memory _name,\r\n        string memory _symbol)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require (!isInitialized_);\r\n\r\n        bZxContract = _bZxContract;\r\n        bZxVault = _bZxVault;\r\n        bZxOracle = _bZxOracle;\r\n        wethContract = _wethContract;\r\n        loanTokenAddress = _loanTokenAddress;\r\n        tokenizedRegistry = _tokenizedRegistry;\r\n\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = EIP20(loanTokenAddress).decimals();\r\n\r\n        spreadMultiplier = SafeMath.sub(10**20, IBZxOracle(_bZxOracle).interestFeePercent());\r\n\r\n        initialPrice = 10**18; // starting price of 1\r\n\r\n        isInitialized_ = true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"assetBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimLoanToken\",\"outputs\":[{\"name\":\"claimedAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supplyInterestRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burntTokenReserved\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"name\":\"leverageAmount\",\"type\":\"uint256\"},{\"name\":\"collateralTokenAddress\",\"type\":\"address\"},{\"name\":\"tradeTokenToFillAddress\",\"type\":\"address\"},{\"name\":\"withdrawOnOpen\",\"type\":\"bool\"}],\"name\":\"borrowToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setWETHContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setTokenizedRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAssetBorrow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"escrowAmount\",\"type\":\"uint256\"},{\"name\":\"leverageAmount\",\"type\":\"uint256\"},{\"name\":\"tradeTokenToFillAddress\",\"type\":\"address\"},{\"name\":\"withdrawOnOpen\",\"type\":\"bool\"}],\"name\":\"borrowTokenFromEscrow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"loanOrderData\",\"outputs\":[{\"name\":\"loanOrderHash\",\"type\":\"bytes32\"},{\"name\":\"leverageAmount\",\"type\":\"uint256\"},{\"name\":\"initialMarginAmount\",\"type\":\"uint256\"},{\"name\":\"maintenanceMarginAmount\",\"type\":\"uint256\"},{\"name\":\"maxDurationUnixTimestampSec\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderParams\",\"type\":\"uint256[4]\"}],\"name\":\"initLeverage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setBZxVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLeverageList\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"leverageAmount\",\"type\":\"uint256\"}],\"name\":\"removeLeverage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rateMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_baseRate\",\"type\":\"uint256\"},{\"name\":\"_rateMultiplier\",\"type\":\"uint256\"}],\"name\":\"setDemandCurve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wethContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"donateAsset\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"borrower\",\"type\":\"address\"},{\"name\":\"leverageAmount\",\"type\":\"uint256\"},{\"name\":\"escrowAmount\",\"type\":\"uint256\"},{\"name\":\"tradeTokenToFillAddress\",\"type\":\"address\"}],\"name\":\"rolloverPosition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketLiquidity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"levergeAmount\",\"type\":\"uint256\"}],\"name\":\"getLoanData\",\"outputs\":[{\"components\":[{\"name\":\"loanOrderHash\",\"type\":\"bytes32\"},{\"name\":\"leverageAmount\",\"type\":\"uint256\"},{\"name\":\"initialMarginAmount\",\"type\":\"uint256\"},{\"name\":\"maintenanceMarginAmount\",\"type\":\"uint256\"},{\"name\":\"maxDurationUnixTimestampSec\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalReservedSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interestReceived\",\"outputs\":[{\"name\":\"interestTotalAccrued\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"wrapEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenizedRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"burntTokenReserveList\",\"outputs\":[{\"name\":\"lender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loanTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"name\":\"burnToEther\",\"outputs\":[{\"name\":\"loanAmountPaid\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"leverageAmount\",\"type\":\"uint256\"}],\"name\":\"getMaxEscrowAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowInterestRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bZxVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"escrowAmount\",\"type\":\"uint256\"},{\"name\":\"leverageAmount\",\"type\":\"uint256\"},{\"name\":\"withdrawOnOpen\",\"type\":\"bool\"}],\"name\":\"getBorrowAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRate\",\"type\":\"uint256\"}],\"name\":\"setInterestFeePercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"mintWithEther\",\"outputs\":[{\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAssetSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bZxOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bZxContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"leverageList\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"loanAmountPaid\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setInitialPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setBZxOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"nextLoanInterestRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"loanTokenAddress\",\"type\":\"address\"},{\"name\":\"interestTokenAddress\",\"type\":\"address\"},{\"name\":\"collateralTokenAddress\",\"type\":\"address\"},{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"loanTokenAmount\",\"type\":\"uint256\"},{\"name\":\"interestAmount\",\"type\":\"uint256\"},{\"name\":\"initialMarginAmount\",\"type\":\"uint256\"},{\"name\":\"maintenanceMarginAmount\",\"type\":\"uint256\"},{\"name\":\"maxDurationUnixTimestampSec\",\"type\":\"uint256\"},{\"name\":\"loanOrderHash\",\"type\":\"bytes32\"}],\"name\":\"loanOrder\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"collateralTokenAddressFilled\",\"type\":\"address\"},{\"name\":\"positionTokenAddressFilled\",\"type\":\"address\"},{\"name\":\"loanTokenAmountFilled\",\"type\":\"uint256\"},{\"name\":\"loanTokenAmountUsed\",\"type\":\"uint256\"},{\"name\":\"collateralTokenAmountFilled\",\"type\":\"uint256\"},{\"name\":\"positionTokenAmountFilled\",\"type\":\"uint256\"},{\"name\":\"loanStartUnixTimestampSec\",\"type\":\"uint256\"},{\"name\":\"loanEndUnixTimestampSec\",\"type\":\"uint256\"},{\"name\":\"active\",\"type\":\"bool\"},{\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"loanPosition\",\"type\":\"tuple\"},{\"name\":\"loanCloser\",\"type\":\"address\"},{\"name\":\"closeAmount\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"name\":\"closeLoanNotifier\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"spreadMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setBZxContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"checkpointPrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bZxContract\",\"type\":\"address\"},{\"name\":\"_bZxVault\",\"type\":\"address\"},{\"name\":\"_bZxOracle\",\"type\":\"address\"},{\"name\":\"_wethContract\",\"type\":\"address\"},{\"name\":\"_loanTokenAddress\",\"type\":\"address\"},{\"name\":\"_tokenizedRegistry\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"burntTokenReserveListIndex\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"isSet\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"loanOrderHashes\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"settleInterest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"assetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"assetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"interestRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"collateralTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tradeTokenToFillAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withdrawOnOpen\",\"type\":\"bool\"}],\"name\":\"Borrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"assetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"remainingTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"LoanTokenLogic","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f5dd688913ab04b8a6a86c7f5aec691defb52654a28cd0b8265c2a7d5461c451"}]}