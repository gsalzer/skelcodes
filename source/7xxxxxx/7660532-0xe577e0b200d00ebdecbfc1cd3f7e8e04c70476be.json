{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.7;\r\n\r\n/*\r\n*  xEuro.sol\r\n*  xEUR tokens smart contract\r\n*  implements [ERC-20 Token Standard](https://eips.ethereum.org/EIPS/eip-20)\r\n*  ver. 1.0.7\r\n*  2019-04-29\r\n*  https://xeuro.online\r\n*  address: https://etherscan.io/address/0xe577e0B200d00eBdecbFc1cd3F7E8E04C70476BE \r\n*  deployed on block: 7660532\r\n*  solc version : 0.5.7+commit.6da8b019\r\n**/\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n* ERC-677\r\n* see: https://github.com/ethereum/EIPs/issues/677\r\n* Allow tokens to be transferred to contracts and have the contract trigger logic for how to respond to receiving\r\n* the tokens within a single transaction.\r\n*/\r\ncontract TokenRecipient {\r\n\r\n    function onTokenTransfer(address _from, uint256 _value, bytes calldata _extraData) external returns (bool);\r\n    // function tokenFallback(address _from, uint256 _value, bytes calldata _extraData) external returns (bool);\r\n\r\n}\r\n\r\n/**\r\n* see: https://www.cryptonomica.net/#!/verifyEthAddress/\r\n* in our smart contract every new admin should have a verified identity on cryptonomica.net\r\n*/\r\ncontract CryptonomicaVerification {\r\n\r\n    // returns 0 if verification is not revoked\r\n    function revokedOn(address _address) external view returns (uint unixTime);\r\n\r\n    function keyCertificateValidUntil(address _address) external view returns (uint unixTime);\r\n\r\n}\r\n\r\ncontract xEuro {\r\n\r\n    /**\r\n    * see: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC20/BasicToken.sol\r\n    */\r\n    using SafeMath for uint256;\r\n\r\n    CryptonomicaVerification public cryptonomicaVerification;\r\n\r\n    /* --- ERC-20 variables ----- */\r\n\r\n    /**\r\n    * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#name\r\n    * function name() constant returns (string name)\r\n    */\r\n    string public constant name = \"xEuro\";\r\n\r\n    /**\r\n    * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#symbol\r\n    * function symbol() constant returns (string symbol)\r\n    */\r\n    string public constant symbol = \"xEUR\";\r\n\r\n    /**\r\n    * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#decimals\r\n    * function decimals() constant returns (uint8 decimals)\r\n    */\r\n    uint8 public constant decimals = 0; // 1 token = €1, no smaller unit\r\n\r\n    /**\r\n    * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#totalsupply\r\n    * function totalSupply() constant returns (uint256 totalSupply)\r\n    * we start with zero\r\n    */\r\n    uint256 public totalSupply = 0;\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#balanceof\r\n    // function balanceOf(address _owner) constant returns (uint256 balance)\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    /**\r\n    * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#allowance\r\n    * function allowance(address _owner, address _spender) constant returns (uint256 remaining)\r\n    */\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /* --- administrative variables */\r\n\r\n    /**\r\n    * addresses that are admins in this smart contracts\r\n    * admin can assign and revoke authority to perform functions (mint, burn, transfer) in this contract\r\n    * for other addresses and for himself\r\n    */\r\n    mapping(address => bool) public isAdmin;\r\n\r\n    /**\r\n    * addresses that can mint tokens\r\n    */\r\n    mapping(address => bool) public canMint;\r\n\r\n    /**\r\n    * addresses allowed to transfer tokens from contract's own address to another address\r\n    * for example after tokens were minted, they can be transferred to user\r\n    * (tokenholder of new (fresh minted) tokens is always this smart contract itself)\r\n    */\r\n    mapping(address => bool) public canTransferFromContract;\r\n\r\n    /**\r\n    * addresses allowed to burn tokens\r\n    * tokens can burned only if their tokenholder is smart contract itself\r\n    * nobody can burn tokens owned by user\r\n    */\r\n    mapping(address => bool) public canBurn;\r\n\r\n    /* --- ERC-20 events */\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#events\r\n\r\n    /**\r\n    * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer-1\r\n    */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    /**\r\n    * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#approval\r\n    */\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    /**\r\n    * event we fire when data are sent from this smart contract to other smart contract\r\n    * @param _from will be msg.sender\r\n    * @param _toContract address of smart contract information is sent to\r\n    * @param _extraData any data that msg.sender sends to another smart contract\r\n    */\r\n    event DataSentToAnotherContract(address indexed _from, address indexed _toContract, bytes _extraData);\r\n\r\n    /* --- ERC-20 Functions */\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#methods\r\n\r\n    /*\r\n    *  https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#approve\r\n    * there is and attack:\r\n    * https://github.com/CORIONplatform/solidity/issues/6,\r\n    * https://drive.google.com/file/d/0ByMtMw2hul0EN3NCaVFHSFdxRzA/view\r\n    * but this function is required by ERC-20:\r\n    * To prevent attack vectors like the one described on https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/\r\n    * and discussed on https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 ,\r\n    * clients SHOULD make sure to create user interfaces in such a way that they set the allowance first to 0 before\r\n    * setting it to another value for the same spender.\r\n    * THOUGH The contract itself shouldn’t enforce it, to allow backwards compatibility with contracts deployed before\r\n    *\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint256 _value) public returns (bool success){\r\n\r\n        allowance[msg.sender][_spender] = _value;\r\n\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Overloaded (see https://solidity.readthedocs.io/en/v0.5.7/contracts.html#function-overloading) approve function\r\n    * see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/\r\n    */\r\n    function approve(address _spender, uint256 _currentValue, uint256 _value) external returns (bool success){\r\n\r\n        require(allowance[msg.sender][_spender] == _currentValue);\r\n\r\n        return approve(_spender, _value);\r\n    }\r\n\r\n    /**\r\n    * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool success){\r\n        return transferFrom(msg.sender, _to, _value);\r\n    }\r\n\r\n    /**\r\n    * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transferfrom\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){\r\n\r\n        // Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event (ERC-20)\r\n        // Variables of uint type cannot be negative. Thus, comparing uint variable with zero (greater than or equal) is redundant\r\n        // require(_value >= 0);\r\n\r\n        require(_to != address(0));\r\n\r\n        // The function SHOULD throw unless the _from account has deliberately authorized the sender of the message via some mechanism\r\n        require(\r\n            msg.sender == _from\r\n        || _value <= allowance[_from][msg.sender]\r\n        || (_from == address(this) && canTransferFromContract[msg.sender]),\r\n            \"Sender not authorized\");\r\n\r\n        // check if _from account have required amount\r\n        require(_value <= balanceOf[_from], \"Account doesn't have required amount\");\r\n\r\n        if (_to == address(this)) {// tokens sent to smart contract itself (for exchange to fiat)\r\n\r\n            // (!) only token holder can send tokens to smart contract address to get fiat, not using allowance\r\n            require(_from == msg.sender, \"Only token holder can do this\");\r\n\r\n            require(_value >= minExchangeAmount, \"Value is less than min. exchange amount\");\r\n\r\n            // this event used by our bot to monitor tokens that have to be burned and to make a fiat payment\r\n            // bot also verifies this information checking 'tokensInTransfer' mapping, which contains the same data\r\n            tokensInEventsCounter++;\r\n            emit TokensIn(\r\n                _from,\r\n                _value,\r\n                tokensInEventsCounter\r\n            );\r\n\r\n            // here we write information about this transfer\r\n            // (the same as in event, but stored in contract variable and with timestamp)\r\n            tokensInTransfer[tokensInEventsCounter].from = _from;\r\n            tokensInTransfer[tokensInEventsCounter].value = _value;\r\n            // timestamp:\r\n            tokensInTransfer[tokensInEventsCounter].receivedOn = now;\r\n\r\n        }\r\n\r\n        balanceOf[_from] = balanceOf[_from].sub(_value);\r\n        balanceOf[_to] = balanceOf[_to].add(_value);\r\n\r\n        // If allowance used, change allowances correspondingly\r\n        if (_from != msg.sender && _from != address(this)) {\r\n            allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\r\n        }\r\n\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*  ---------- Interaction with other contracts  */\r\n\r\n    /**\r\n    * ERC-677\r\n    * https://github.com/ethereum/EIPs/issues/677\r\n    * transfer tokens with additional info to another smart contract, and calls its correspondent function\r\n    * @param _to - another smart contract address\r\n    * @param _value - number of tokens\r\n    * @param _extraData - data to send to another contract\r\n    * this is a recommended method to send tokens to smart contracts\r\n    */\r\n    function transferAndCall(address _to, uint256 _value, bytes memory _extraData) public returns (bool success){\r\n\r\n        TokenRecipient receiver = TokenRecipient(_to);\r\n\r\n        if (transferFrom(msg.sender, _to, _value)) {\r\n\r\n            // if (receiver.tokenFallback(msg.sender, _value, _extraData)) {\r\n            if (receiver.onTokenTransfer(msg.sender, _value, _extraData)) {\r\n                emit DataSentToAnotherContract(msg.sender, _to, _extraData);\r\n                return true;\r\n            }\r\n\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * the same as above ('transferAndCall'), but for all tokens on user account\r\n    * for example for converting ALL tokens of user account to another tokens\r\n    */\r\n    function transferAllAndCall(address _to, bytes calldata _extraData) external returns (bool){\r\n        return transferAndCall(_to, balanceOf[msg.sender], _extraData);\r\n    }\r\n\r\n    /* --- Administrative functions */\r\n\r\n    /**\r\n    * @param from old address\r\n    * @param to new address\r\n    * @param by who made a change\r\n    */\r\n    event CryptonomicaArbitrationContractAddressChanged(address from, address to, address indexed by);\r\n\r\n    /*\r\n    * @param _newAddress address of new contract to be used to verify identity of new admins\r\n    */\r\n    function changeCryptonomicaVerificationContractAddress(address _newAddress) public returns (bool success) {\r\n\r\n        require(isAdmin[msg.sender], \"Only admin can do that\");\r\n\r\n        emit CryptonomicaArbitrationContractAddressChanged(address(cryptonomicaVerification), _newAddress, msg.sender);\r\n\r\n        cryptonomicaVerification = CryptonomicaVerification(_newAddress);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n   * @param by who added new admin\r\n   * @param newAdmin address of new admin\r\n   */\r\n    event AdminAdded(address indexed by, address indexed newAdmin);\r\n\r\n    function addAdmin(address _newAdmin) public returns (bool success){\r\n\r\n        require(isAdmin[msg.sender], \"Only admin can do that\");\r\n        require(_newAdmin != address(0), \"Address can not be zero-address\");\r\n\r\n        require(cryptonomicaVerification.keyCertificateValidUntil(_newAdmin) > now, \"New admin has to be verified on Cryptonomica.net\");\r\n\r\n        // revokedOn returns uint256 (unix time), it's 0 if verification is not revoked\r\n        require(cryptonomicaVerification.revokedOn(_newAdmin) == 0, \"Verification for this address was revoked, can not add\");\r\n\r\n        isAdmin[_newAdmin] = true;\r\n\r\n        emit AdminAdded(msg.sender, _newAdmin);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @param by an address who removed admin\r\n    * @param _oldAdmin address of the admin removed\r\n    */\r\n    event AdminRemoved(address indexed by, address indexed _oldAdmin);\r\n\r\n    /**\r\n    * @param _oldAdmin address to be removed from admins\r\n    */\r\n    function removeAdmin(address _oldAdmin) external returns (bool success){\r\n\r\n        require(isAdmin[msg.sender], \"Only admin can do that\");\r\n\r\n        // prevents from deleting the last admin (can be multisig smart contract) by itself:\r\n        require(msg.sender != _oldAdmin, \"Admin can't remove himself\");\r\n\r\n        isAdmin[_oldAdmin] = false;\r\n\r\n        emit AdminRemoved(msg.sender, _oldAdmin);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * minimum amount of tokens than can be exchanged to fiat\r\n    * can be changed by admin\r\n    */\r\n    uint256 public minExchangeAmount;\r\n\r\n    /**\r\n    * @param by address who made a change\r\n    * @param from value before the change\r\n    * @param to value after the change\r\n    */\r\n    event MinExchangeAmountChanged (address indexed by, uint256 from, uint256 to);\r\n\r\n    /**\r\n    * @param _minExchangeAmount new value of minimum amount of tokens that can be exchanged to fiat\r\n    * only admin can make this change\r\n    */\r\n    function changeMinExchangeAmount(uint256 _minExchangeAmount) public returns (bool success){\r\n\r\n        require(isAdmin[msg.sender], \"Only admin can do that\");\r\n\r\n        uint256 from = minExchangeAmount;\r\n\r\n        minExchangeAmount = _minExchangeAmount;\r\n\r\n        emit MinExchangeAmountChanged(msg.sender, from, minExchangeAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @param by who add permission to mint (only admin can do this)\r\n    * @param newAddress address that was authorized to mint new tokens\r\n    */\r\n    event AddressAddedToCanMint(address indexed by, address indexed newAddress);\r\n\r\n    /**\r\n    * Add permission to mint new tokens to address _newAddress\r\n    */\r\n    function addToCanMint(address _newAddress) public returns (bool success){\r\n\r\n        require(isAdmin[msg.sender], \"Only admin can do that\");\r\n        require(_newAddress != address(0), \"Address can not be zero-address\");\r\n\r\n        canMint[_newAddress] = true;\r\n\r\n        emit AddressAddedToCanMint(msg.sender, _newAddress);\r\n\r\n        return true;\r\n    }\r\n\r\n    event AddressRemovedFromCanMint(address indexed by, address indexed removedAddress);\r\n\r\n    function removeFromCanMint(address _addressToRemove) external returns (bool success){\r\n\r\n        require(isAdmin[msg.sender], \"Only admin can do that\");\r\n\r\n        canMint[_addressToRemove] = false;\r\n\r\n        emit AddressRemovedFromCanMint(msg.sender, _addressToRemove);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @param by who add permission (should be admin)\r\n    * @param newAddress address that got permission\r\n    */\r\n    event AddressAddedToCanTransferFromContract(address indexed by, address indexed newAddress);\r\n\r\n    function addToCanTransferFromContract(address _newAddress) public returns (bool success){\r\n\r\n        require(isAdmin[msg.sender], \"Only admin can do that\");\r\n        require(_newAddress != address(0), \"Address can not be zero-address\");\r\n\r\n        canTransferFromContract[_newAddress] = true;\r\n\r\n        emit AddressAddedToCanTransferFromContract(msg.sender, _newAddress);\r\n\r\n        return true;\r\n    }\r\n\r\n    event AddressRemovedFromCanTransferFromContract(address indexed by, address indexed removedAddress);\r\n\r\n    function removeFromCanTransferFromContract(address _addressToRemove) external returns (bool success){\r\n\r\n        require(isAdmin[msg.sender], \"Only admin can do that\");\r\n\r\n        canTransferFromContract[_addressToRemove] = false;\r\n\r\n        emit AddressRemovedFromCanTransferFromContract(msg.sender, _addressToRemove);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @param by who add permission (should be admin)\r\n    * @param newAddress address that got permission\r\n    */\r\n    event AddressAddedToCanBurn(address indexed by, address indexed newAddress);\r\n\r\n    function addToCanBurn(address _newAddress) public returns (bool success){\r\n\r\n        require(isAdmin[msg.sender], \"Only admin can do that\");\r\n        require(_newAddress != address(0), \"Address can not be zero-address\");\r\n\r\n        canBurn[_newAddress] = true;\r\n\r\n        emit AddressAddedToCanBurn(msg.sender, _newAddress);\r\n\r\n        return true;\r\n    }\r\n\r\n    event AddressRemovedFromCanBurn(address indexed by, address indexed removedAddress);\r\n\r\n    function removeFromCanBurn(address _addressToRemove) external returns (bool success){\r\n\r\n        require(isAdmin[msg.sender], \"Only admin can do that\");\r\n\r\n        canBurn[_addressToRemove] = false;\r\n\r\n        emit AddressRemovedFromCanBurn(msg.sender, _addressToRemove);\r\n\r\n        return true;\r\n    }\r\n\r\n    /* ---------- Create and burn tokens  */\r\n\r\n    /**\r\n    * number (id) for MintTokensEvent\r\n    */\r\n    uint public mintTokensEventsCounter = 0;\r\n\r\n    /**\r\n    * struct used to write information about every transaction that mint new tokens (we call it 'MintTokensEvent')\r\n    * every 'MintTokensEvent' has its number/id (mintTokensEventsCounter)\r\n    */\r\n    struct MintTokensEvent {\r\n        address mintedBy; // address that minted tokens (msg.sender)\r\n        uint256 fiatInPaymentId; // reference to fiat transfer (deposit)\r\n        uint value;  // number of new tokens minted\r\n        uint on;    // UnixTime\r\n        uint currentTotalSupply; // new value of totalSupply\r\n    }\r\n\r\n    /**\r\n    * keep all fiat tx ids, to prevent minting tokens twice (or more times) for the same fiat deposit\r\n    * @param uint256 reference (id) of fiat deposit\r\n    * @param bool if true tokens already were minted for this fiat deposit\r\n    * (see: require(!fiatInPaymentIds[fiatInPaymentId]); in function mintTokens\r\n    */\r\n    mapping(uint256 => bool) public fiatInPaymentIds;\r\n\r\n    /**\r\n    * here we can find a MintTokensEvent by fiatInPaymentId (id of fiat deposit),\r\n    * so we now if tokens were minted for given incoming fiat payment (deposit), and if yes when and how many\r\n    * @param uint256 reference (id) of fiat deposit\r\n    */\r\n    mapping(uint256 => MintTokensEvent) public fiatInPaymentsToMintTokensEvent;\r\n\r\n    /**\r\n    * here we store MintTokensEvent with its ordinal numbers/ids (mintTokensEventsCounter)\r\n    * @param uint256 > mintTokensEventsCounter\r\n    */\r\n    mapping(uint256 => MintTokensEvent) public mintTokensEvent;\r\n\r\n    /**\r\n    * an event with the same information as in struct MintTokensEvent\r\n    */\r\n    event TokensMinted(\r\n        address indexed by, // who minted new tokens\r\n        uint256 indexed fiatInPaymentId, // reference to fiat payment (deposit)\r\n        uint value, // number of new minted tokens\r\n        uint currentTotalSupply, // totalSupply value after new tokens were minted\r\n        uint indexed mintTokensEventsCounter //\r\n    );\r\n\r\n    /**\r\n    * tokens should be minted to contract own address, (!) after that tokens should be transferred using transferFrom\r\n    * @param value number of tokens to create\r\n    * @param fiatInPaymentId fiat payment (deposit) id\r\n    */\r\n    function mintTokens(uint256 value, uint256 fiatInPaymentId) public returns (bool success){\r\n\r\n        require(canMint[msg.sender], \"Sender not authorized\");\r\n\r\n        // require that this fiatInPaymentId was not used before:\r\n        require(!fiatInPaymentIds[fiatInPaymentId], \"This fiat payment id is already used\");\r\n\r\n        // Variables of uint type cannot be negative. Thus, comparing uint variable with zero (greater than or equal) is redundant\r\n        // require(value >= 0);\r\n\r\n        // this is the moment when new tokens appear in the system\r\n        totalSupply = totalSupply.add(value);\r\n\r\n        // first token holder of fresh minted tokens always is the contract itself\r\n        // (than tokens have to be transferred from contract address to user address)\r\n        balanceOf[address(this)] = balanceOf[address(this)].add(value);\r\n\r\n        mintTokensEventsCounter++;\r\n        mintTokensEvent[mintTokensEventsCounter].mintedBy = msg.sender;\r\n        mintTokensEvent[mintTokensEventsCounter].fiatInPaymentId = fiatInPaymentId;\r\n        mintTokensEvent[mintTokensEventsCounter].value = value;\r\n        mintTokensEvent[mintTokensEventsCounter].on = block.timestamp;\r\n        mintTokensEvent[mintTokensEventsCounter].currentTotalSupply = totalSupply;\r\n\r\n        // fiatInPaymentId => struct mintTokensEvent\r\n        fiatInPaymentsToMintTokensEvent[fiatInPaymentId] = mintTokensEvent[mintTokensEventsCounter];\r\n\r\n        emit TokensMinted(msg.sender, fiatInPaymentId, value, totalSupply, mintTokensEventsCounter);\r\n\r\n        // mark fiatInPaymentId as used to mint tokens\r\n        fiatInPaymentIds[fiatInPaymentId] = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * mint and transfer new tokens to user in one tx\r\n    * requires msg.sender to have both 'canMint' and 'canTransferFromContract' permissions\r\n    * @param _value number of new tokens to create (to mint)\r\n    * @param fiatInPaymentId id of fiat payment (deposit) received for new tokens\r\n    * @param _to receiver of new tokens\r\n    */\r\n    function mintAndTransfer(uint256 _value, uint256 fiatInPaymentId, address _to) public returns (bool success){\r\n\r\n        if (mintTokens(_value, fiatInPaymentId) && transferFrom(address(this), _to, _value)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /* -- Exchange tokens to fiat (tokens sent to contract owns address > fiat payment) */\r\n\r\n    /**\r\n    * number for every 'event' when we receive tokens to contract own address for exchange to fiat\r\n    */\r\n    uint public tokensInEventsCounter = 0;\r\n\r\n    /**\r\n    * @param from who sent tokens for exchange\r\n    * @param value number of tokens received for exchange\r\n    * @param receivedOn timestamp (UnixTime)\r\n    */\r\n    struct TokensInTransfer {// <<< used in 'transfer'\r\n        address from; //\r\n        uint value;   //\r\n        uint receivedOn; // unix time\r\n    }\r\n\r\n    /**\r\n    * @param uint256 < tokensInEventsCounter\r\n    */\r\n    mapping(uint256 => TokensInTransfer) public tokensInTransfer;\r\n\r\n    /**\r\n    * @param from address that sent tokens for exchange to fiat\r\n    * @param value number of tokens received\r\n    * @param tokensInEventsCounter number of event\r\n    */\r\n    event TokensIn(\r\n        address indexed from,\r\n        uint256 value,\r\n        uint256 indexed tokensInEventsCounter\r\n    );\r\n\r\n    /**\r\n    * we also count every every token burning\r\n    */\r\n    uint public burnTokensEventsCounter = 0;//\r\n\r\n    /**\r\n    * @param by who burned tokens\r\n    * @param value number of tokens burned\r\n    * @param tokensInEventId corresponding id on tokensInEvent, after witch tokens were burned\r\n    * @param fiatOutPaymentId id of outgoing fiat payment to user\r\n    * @param burnedOn timestamp (unix time)\r\n    * @param currentTotalSupply totalSupply after tokens were burned\r\n    */\r\n    struct burnTokensEvent {\r\n        address by; //\r\n        uint256 value;   //\r\n        uint256 tokensInEventId;\r\n        uint256 fiatOutPaymentId;\r\n        uint256 burnedOn; // UnixTime\r\n        uint256 currentTotalSupply;\r\n    }\r\n\r\n    /**\r\n    * @param uint256 < burnTokensEventsCounter\r\n    */\r\n    mapping(uint256 => burnTokensEvent) public burnTokensEvents;\r\n\r\n    /**\r\n    *  we count every fiat payment id used when burn tokens to prevent using it twice\r\n    */\r\n    mapping(uint256 => bool) public fiatOutPaymentIdsUsed; //\r\n\r\n    /**\r\n    * smart contract event with the same data as in struct burnTokensEvent\r\n    */\r\n    event TokensBurned(\r\n        address indexed by,\r\n        uint256 value,\r\n        uint256 indexed tokensInEventId, // this is the same as uint256 indexed tokensInEventsCounter in event TokensIn\r\n        uint256 indexed fiatOutPaymentId,\r\n        uint burnedOn, // UnixTime\r\n        uint currentTotalSupply\r\n    );\r\n\r\n    /**\r\n    * (!) only contract's own tokens (balanceOf[this]) can be burned\r\n    * @param value number of tokens to burn\r\n    * @param tokensInEventId reference to tokensInEventsCounter value for incoming tokens event (tokensInEvent)\r\n    * @param fiatOutPaymentId id of outgoing fiat payment (from the bank)\r\n    */\r\n    function burnTokens(\r\n        uint256 value,\r\n        uint256 tokensInEventId, // this is the same as uint256 indexed tokensInEventsCounter in event TokensIn\r\n        uint256 fiatOutPaymentId\r\n    ) public returns (bool success){\r\n\r\n        // Variables of uint type cannot be negative. Thus, comparing uint variable with zero (greater than or equal) is redundant\r\n        // require(value >= 0);\r\n\r\n        require(canBurn[msg.sender], \"Sender not authorized\");\r\n        require(balanceOf[address(this)] >= value, \"Account does not have required amount\");\r\n\r\n        // require(!tokensInEventIdsUsed[tokensInEventId]);\r\n        require(!fiatOutPaymentIdsUsed[fiatOutPaymentId], \"This fiat payment id is already used\");\r\n\r\n        balanceOf[address(this)] = balanceOf[address(this)].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n\r\n        burnTokensEventsCounter++;\r\n        burnTokensEvents[burnTokensEventsCounter].by = msg.sender;\r\n        burnTokensEvents[burnTokensEventsCounter].value = value;\r\n        burnTokensEvents[burnTokensEventsCounter].tokensInEventId = tokensInEventId;\r\n        burnTokensEvents[burnTokensEventsCounter].fiatOutPaymentId = fiatOutPaymentId;\r\n        burnTokensEvents[burnTokensEventsCounter].burnedOn = block.timestamp;\r\n        burnTokensEvents[burnTokensEventsCounter].currentTotalSupply = totalSupply;\r\n\r\n        emit TokensBurned(msg.sender, value, tokensInEventId, fiatOutPaymentId, block.timestamp, totalSupply);\r\n\r\n        fiatOutPaymentIdsUsed[fiatOutPaymentId] = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /* ---------- Constructor */\r\n    constructor() public {// Constructor must be public or internal\r\n\r\n        // initial admin:\r\n        isAdmin[msg.sender] = true;\r\n\r\n        addToCanMint(msg.sender);\r\n        addToCanTransferFromContract(msg.sender);\r\n        addToCanBurn(msg.sender);\r\n\r\n        changeCryptonomicaVerificationContractAddress(0x846942953c3b2A898F10DF1e32763A823bf6b27f);\r\n        addAdmin(0xD851d045d8Aee53EF24890afBa3d701163AcbC8B);\r\n\r\n        // to test main functions and events (can be removed in production, or can be not):\r\n        changeMinExchangeAmount(12);\r\n        mintAndTransfer(12, 0, msg.sender);\r\n        transfer(msg.sender, 12);\r\n        transfer(address(this), 12);\r\n        burnTokens(12, 1, 0);\r\n\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_addressToRemove\",\"type\":\"address\"}],\"name\":\"removeFromCanTransferFromContract\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"tokensInEventId\",\"type\":\"uint256\"},{\"name\":\"fiatOutPaymentId\",\"type\":\"uint256\"}],\"name\":\"burnTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minExchangeAmount\",\"type\":\"uint256\"}],\"name\":\"changeMinExchangeAmount\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"canTransferFromContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnTokensEventsCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oldAdmin\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"addToCanTransferFromContract\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"fiatInPaymentId\",\"type\":\"uint256\"}],\"name\":\"mintTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressToRemove\",\"type\":\"address\"}],\"name\":\"removeFromCanBurn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cryptonomicaVerification\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"canBurn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mintTokensEvent\",\"outputs\":[{\"name\":\"mintedBy\",\"type\":\"address\"},{\"name\":\"fiatInPaymentId\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"on\",\"type\":\"uint256\"},{\"name\":\"currentTotalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"transferAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_currentValue\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokensInTransfer\",\"outputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"receivedOn\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minExchangeAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"fiatInPaymentId\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"mintAndTransfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressToRemove\",\"type\":\"address\"}],\"name\":\"removeFromCanMint\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"changeCryptonomicaVerificationContractAddress\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"addToCanMint\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintTokensEventsCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"addToCanBurn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"burnTokensEvents\",\"outputs\":[{\"name\":\"by\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"tokensInEventId\",\"type\":\"uint256\"},{\"name\":\"fiatOutPaymentId\",\"type\":\"uint256\"},{\"name\":\"burnedOn\",\"type\":\"uint256\"},{\"name\":\"currentTotalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensInEventsCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"canMint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fiatOutPaymentIdsUsed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fiatInPaymentIds\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"transferAllAndCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fiatInPaymentsToMintTokensEvent\",\"outputs\":[{\"name\":\"mintedBy\",\"type\":\"address\"},{\"name\":\"fiatInPaymentId\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"on\",\"type\":\"uint256\"},{\"name\":\"currentTotalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_toContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"DataSentToAnotherContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"}],\"name\":\"CryptonomicaArbitrationContractAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_oldAdmin\",\"type\":\"address\"}],\"name\":\"AdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"MinExchangeAmountChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"AddressAddedToCanMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"removedAddress\",\"type\":\"address\"}],\"name\":\"AddressRemovedFromCanMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"AddressAddedToCanTransferFromContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"removedAddress\",\"type\":\"address\"}],\"name\":\"AddressRemovedFromCanTransferFromContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"AddressAddedToCanBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"removedAddress\",\"type\":\"address\"}],\"name\":\"AddressRemovedFromCanBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"fiatInPaymentId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currentTotalSupply\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"mintTokensEventsCounter\",\"type\":\"uint256\"}],\"name\":\"TokensMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tokensInEventsCounter\",\"type\":\"uint256\"}],\"name\":\"TokensIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tokensInEventId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"fiatOutPaymentId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"burnedOn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currentTotalSupply\",\"type\":\"uint256\"}],\"name\":\"TokensBurned\",\"type\":\"event\"}]","ContractName":"xEuro","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b8b84e4364cf3182798956bb634089593885af05d1b7002241a82fdf40a8b36f"}]}