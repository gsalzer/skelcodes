{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5;\r\n\r\ncontract ERC20 {\r\n    mapping(address => mapping(address => uint)) public allowed;\r\n    function transferFrom(address from, address to, uint amount) public returns (bool);\r\n    function transfer(address to, uint amount) public returns (bool);\r\n    function approve(address spender, uint amount) public returns (bool);\r\n    function balanceOf(address a) public view returns (uint);\r\n}\r\n\r\ncontract ProtocolTypes {\r\n    struct OptionSeries {\r\n        uint expiration;\r\n        Flavor flavor;\r\n        uint strike;\r\n    }\r\n    \r\n    enum Flavor {\r\n        Call,\r\n        Put\r\n    }\r\n}\r\n\r\ncontract Protocol is ProtocolTypes {\r\n    ERC20 public usdERC20;\r\n    mapping(address => OptionSeries) public seriesInfo;\r\n    mapping(address => mapping(address => uint)) public writers;\r\n\r\n    function open(address _series, uint amount) public payable;\r\n    function redeem(address _series) public;\r\n    function settle(address _series) public;\r\n    function close(address _series, uint amount) public;\r\n}\r\n\r\ncontract Trading is ProtocolTypes {\r\n    \r\n    address payable public owner;\r\n    address public signer = 0x47e3ea40D4F39A8C3a819B90F03FcE162e2fdbe4;\r\n    \r\n    Protocol public protocol;\r\n    ERC20 public usd;\r\n    \r\n    enum Action {\r\n        Buy,\r\n        Sell\r\n    }\r\n    \r\n    constructor(address _protocol) public {\r\n        owner = msg.sender;\r\n        require(_protocol != address(0));\r\n        protocol = Protocol(_protocol);\r\n        usd = ERC20(address(protocol.usdERC20()));\r\n        usd.approve(address(protocol), uint256(0) - 1);\r\n    }\r\n    \r\n    function() external payable {}\r\n    \r\n    function trade(Action action, uint expiration, uint getting, uint giving, address token, uint8 v, bytes32 r, bytes32 s) public payable {\r\n        require(msg.sender == tx.origin);\r\n        require(expiration > now);\r\n        require(ecrecover(keccak256(abi.encodePacked(uint8(action), expiration, getting, giving, token)), v, r, s) == signer);\r\n        \r\n        Flavor flavor;\r\n        uint strike;\r\n\r\n        (expiration, flavor, strike) = protocol.seriesInfo(token);\r\n        if (action == Action.Buy) {\r\n            require(msg.value == giving);\r\n            uint owned = ERC20(token).balanceOf(address(this));\r\n            uint needed = owned < getting ? getting - owned : 0;\r\n            \r\n            if (needed > 0) {\r\n                // open value in protocol and send to buyer\r\n                if (flavor == Flavor.Call) {\r\n                    protocol.open.value(needed)(token, needed);\r\n                } else {\r\n                    protocol.open(token, needed);\r\n                }\r\n            }\r\n            \r\n            ERC20(token).transfer(msg.sender, getting);\r\n            // require(token.call(bytes4(keccak256(\"transfer(address,uint256)\")), msg.sender, getting));\r\n        } else {\r\n            require(msg.value == 0);\r\n            // require(token.call(bytes4(keccak256(\"transferFrom(address,address,uint256)\")), msg.sender, address(this), giving));\r\n            ERC20(token).transferFrom(msg.sender, address(this), giving);\r\n            // close value in protocol and send to seller\r\n            uint written = protocol.writers(token, address(this));\r\n            uint closeable = written < giving ? written : giving;\r\n            \r\n            if (closeable > 0) {\r\n                protocol.close(token, closeable); \r\n            }\r\n\r\n            msg.sender.transfer(getting);\r\n        }\r\n    }\r\n    \r\n    function settleWritten(address token) public {\r\n        protocol.redeem(token);\r\n    }\r\n    \r\n    function settle(address token) public {\r\n        protocol.settle(token);\r\n    }\r\n    \r\n    // these functions allow the contract owner to remove liquidity from the contract\r\n    // they have no impact on users funds since this contract never holds users funds\r\n    function withdraw(uint amount) public {\r\n        require(msg.sender == owner);\r\n        owner.transfer(amount);\r\n    }\r\n    \r\n    function withdrawUSD(uint amount) public {\r\n        require(msg.sender == owner);\r\n        usd.transfer(owner, amount);\r\n    }\r\n    \r\n    function withdrawMaxETH() public {\r\n        withdraw(address(this).balance);\r\n    }\r\n    \r\n    function withdrawToken(address token, uint amount) public {\r\n        require(msg.sender == owner);\r\n        ERC20(token).transfer(owner, amount);\r\n    }\r\n    \r\n    function setSigner(address next) public {\r\n        require(msg.sender == owner);\r\n        signer = next;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawUSD\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"settle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"next\",\"type\":\"address\"}],\"name\":\"setSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"action\",\"type\":\"uint8\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"getting\",\"type\":\"uint256\"},{\"name\":\"giving\",\"type\":\"uint256\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"trade\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"protocol\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usd\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawMaxETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"settleWritten\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_protocol\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Trading","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000bd2082ce6f9bf88564b50d59299a81864155cc39","Library":"","SwarmSource":"bzzr://c818b457192223d531c2f973ad1ac27ecb8a5bcd32047f16777bf88a73785de0"}]}