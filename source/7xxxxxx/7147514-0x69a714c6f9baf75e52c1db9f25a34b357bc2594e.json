{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\ncontract Pass {\r\n    constructor(address payable targetAddress) public payable {\r\n        selfdestruct(targetAddress);\r\n    }\r\n}\r\n\r\ninterface TargetInterface {\r\n    function checkBalance() external view returns (uint256);\r\n    function withdraw() external returns (bool);\r\n    function stock() external view returns (uint256);\r\n    function withdrawStock() external;\r\n}\r\n\r\ncontract Proxy_toff {\r\n    \r\n    address payable private constant targetAddress = 0x5799D73e4C60203CA6C7dDCB083b0c74ACb4b4C3;\r\n    address payable private owner;\r\n    \r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    constructor() public payable {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    function investTargetMsgValue(bool keepBalance, bool leaveStock) public payable {\r\n        investTargetAmount(msg.value, keepBalance, leaveStock);\r\n    }\r\n\r\n    function investTargetAmount(uint256 amount, bool keepBalance, bool leaveStock) public payable onlyOwner {\r\n        (bool success,) = targetAddress.call.value(amount)(\"\");\r\n        require(success);\r\n        \r\n        if (!leaveStock) {\r\n            TargetInterface target = TargetInterface(targetAddress);\r\n            target.withdrawStock();\r\n        }\r\n\r\n        if (!keepBalance) {\r\n            owner.transfer(address(this).balance);\r\n        }\r\n    }\r\n\r\n    function withdrawTarget(bool keepBalance) public payable onlyOwner {\r\n        TargetInterface target = TargetInterface(targetAddress);\r\n        uint256 targetStock = target.stock();\r\n        uint256 targetBalanceAvailable = targetAddress.balance - targetStock;\r\n        uint256 targetBalanceRequired = target.checkBalance();\r\n        \r\n        if (targetStock == 0) {\r\n            targetBalanceRequired++;\r\n        }\r\n\r\n        if (targetBalanceRequired > targetBalanceAvailable) {\r\n            uint256 needAdd = targetBalanceRequired - targetBalanceAvailable;\r\n            \r\n            require(address(this).balance >= needAdd);\r\n            (new Pass).value(needAdd)(targetAddress);\r\n        }\r\n\r\n        target.withdraw();\r\n        \r\n        if (!keepBalance) {\r\n            owner.transfer(address(this).balance);\r\n        }\r\n    }\r\n    \r\n    function withdraw() public onlyOwner {\r\n        owner.transfer(address(this).balance);\r\n    }\r\n\r\n    function kill() public onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function () external payable {\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"keepBalance\",\"type\":\"bool\"}],\"name\":\"withdrawTarget\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"keepBalance\",\"type\":\"bool\"},{\"name\":\"leaveStock\",\"type\":\"bool\"}],\"name\":\"investTargetAmount\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"keepBalance\",\"type\":\"bool\"},{\"name\":\"leaveStock\",\"type\":\"bool\"}],\"name\":\"investTargetMsgValue\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Proxy_toff","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3abe37632e9dba9a6134dd4ccbc0972683c8de564ca77d5204bf2af15a556406"}]}