{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\n// File: openzeppelin-solidity/contracts/access/Roles.sol\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/roles/PauserRole.sol\r\n\r\ncontract PauserRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event PauserAdded(address indexed account);\r\n    event PauserRemoved(address indexed account);\r\n\r\n    Roles.Role private _pausers;\r\n\r\n    constructor () internal {\r\n        _addPauser(msg.sender);\r\n    }\r\n\r\n    modifier onlyPauser() {\r\n        require(isPauser(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isPauser(address account) public view returns (bool) {\r\n        return _pausers.has(account);\r\n    }\r\n\r\n    function addPauser(address account) public onlyPauser {\r\n        _addPauser(account);\r\n    }\r\n\r\n    function renouncePauser() public {\r\n        _removePauser(msg.sender);\r\n    }\r\n\r\n    function _addPauser(address account) internal {\r\n        _pausers.add(account);\r\n        emit PauserAdded(account);\r\n    }\r\n\r\n    function _removePauser(address account) internal {\r\n        _pausers.remove(account);\r\n        emit PauserRemoved(account);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is PauserRole {\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    constructor () internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @return true if the contract is paused, false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() public onlyPauser whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() public onlyPauser whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\n// File: contracts/FoundationOwnable.sol\r\n\r\ncontract FoundationOwnable is Pausable {\r\n\r\n\taddress public foundation;\r\n\r\n\tevent FoundationTransferred(address oldAddr, address newAddr);\r\n\r\n\tconstructor() public {\r\n\t\tfoundation = msg.sender;\r\n\t}\r\n\r\n\tmodifier onlyFoundation() {\r\n\t\trequire(msg.sender == foundation, 'foundation required');\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction transferFoundation(address f) public onlyFoundation {\r\n\t\trequire(f != address(0), 'empty address');\r\n\t\temit FoundationTransferred(foundation, f);\r\n\t\t_removePauser(foundation);\r\n\t\t_addPauser(f);\r\n\t\tfoundation = f;\r\n\t}\r\n}\r\n\r\n// File: contracts/TeleportOwnable.sol\r\n\r\ncontract TeleportOwnable {\r\n\r\n\taddress public teleport;\r\n\r\n\tevent TeleportTransferred(address oldAddr, address newAddr);\r\n\r\n\tconstructor() public {\r\n\t\tteleport = msg.sender;\r\n\t}\r\n\r\n\tmodifier onlyTeleport() {\r\n\t\trequire(msg.sender == teleport, 'caller not teleport');\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction transferTeleport(address f) public onlyTeleport {\r\n\t\trequire(f != address(0));\r\n\t\temit TeleportTransferred(teleport, f);\r\n\t\tteleport = f;\r\n\t}\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n * Originally based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n *\r\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\r\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\r\n * compliant implementations may not do it.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param owner The address to query the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n        _transfer(from, to, value);\r\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed_[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed_[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified addresses\r\n    * @param from The address to transfer from.\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0));\r\n\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that mints an amount of the token and assigns it to\r\n     * an account. This encapsulates the modification of balances such that the\r\n     * proper events are emitted.\r\n     * @param account The account that will receive the created tokens.\r\n     * @param value The amount that will be created.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.add(value);\r\n        _balances[account] = _balances[account].add(value);\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account.\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account, deducting from the sender's allowance for said account. Uses the\r\n     * internal burn function.\r\n     * Emits an Approval event (reflecting the reduced allowance).\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burnFrom(address account, uint256 value) internal {\r\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\r\n        _burn(account, value);\r\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\r\n\r\n/**\r\n * @title ERC20Detailed token\r\n * @dev The decimals are only for visualization purposes.\r\n * All the operations are done using the smallest and indivisible token unit,\r\n * just as on Ethereum all the operations are done in wei.\r\n */\r\ncontract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    /**\r\n     * @return the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @return the symbol of the token.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @return the number of decimals of the token.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n// File: contracts/PortedToken.sol\r\n\r\ncontract PortedToken is TeleportOwnable, ERC20, ERC20Detailed{\r\n\r\n\tconstructor(string memory name, string memory symbol, uint8 decimals)\r\n\t\tpublic ERC20Detailed(name, symbol, decimals) {}\r\n\r\n\tfunction mint(address to, uint256 value) public onlyTeleport {\r\n\t\tsuper._mint(to, value);\r\n\t}\r\n\r\n\tfunction burn(address from, uint256 value) public onlyTeleport {\r\n\t\tsuper._burn(from, value);\r\n\t}\r\n}\r\n\r\n// File: contracts/Port.sol\r\n\r\n// Port is a contract that sends and recieves tokens to implement token\r\n// teleportation between chains.\r\n//\r\n// Naming convention:\r\n// - token: \"main\" is the original token and \"cloned\" is the ported one on\r\n//          this/another chain.\r\n// - address: \"addr\" is the address on this chain and \"alt\" is the one on\r\n//            another chain.\r\ncontract Port is FoundationOwnable {\r\n\t// Library\r\n\tusing SafeMath for uint256;\r\n\r\n\t// States\r\n\r\n\t// Beneficiary address is the address that the remaining tokens will be\r\n\t// transferred to for selfdestruct.\r\n\taddress payable public beneficiary;\r\n\r\n\t// registeredMainTokens stores the tokens that are ported on this chain.\r\n\taddress[] public registeredMainTokens;\r\n\r\n\t// registeredClonedTokens stores the ported tokens created by the foundation.\r\n\taddress[] public registeredClonedTokens;\r\n\r\n\t// breakoutTokens is an address to address mapping that maps the currencies\r\n\t// to break out to the destination contract address on the destination chain.\r\n\t// Note that the zero address 0x0 represents the native token in this mapping.\r\n\t//\r\n\t// mapping structure\r\n\t//    main currency address                [this chain]\r\n\t// -> alt chain id of cloned token address\r\n\t// -> cloned token address                  [alt chain]\r\n\tmapping (address => mapping (uint256 => bytes)) public breakoutTokens;\r\n\r\n\t// breakinTokens is an address to address mapping that maps the ported token\r\n\t// contracts on this chain to the currencies on the source chain.\r\n\t//\r\n\t// mapping structure\r\n\t//    cloned token address                   [this chain]\r\n\t// -> alt chain id of main currency address\r\n\t// -> main currency address                   [alt chain]\r\n\tmapping (address => mapping (uint256 => bytes)) public breakinTokens;\r\n\r\n\t// proofs is an bytes to bool mapping that labels a proof is used, including\r\n\t// for withdrawal and mint.\r\n\tmapping (bytes => bool) proofs;\r\n\r\n\t// minPortValue records the minimum allowed porting value for each currency.\r\n\t//\r\n\t// mapping structure\r\n\t//    main/cloned currency address [this chain]\r\n\t// -> chain id of main/cloned currency address\r\n\t// -> minimum breakout value\r\n\tmapping (address => mapping (uint256 => uint256)) public minPortValue;\r\n\r\n\r\n\t// Events\r\n\r\n\t// A Deposit event is emitted when a user deposits native currency or tokens\r\n\t// with value into the Port contract to break out to the dest_addr as ported\r\n\t// token with cloned_token as address on the chain with chain_id\r\n\tevent Deposit(\r\n\t\tuint256 indexed chain_id,        // id of the destination chain.\r\n\t\tbytes indexed cloned_token_hash,\r\n\t\tbytes indexed alt_addr_hash,\r\n\t\taddress main_token,              // the source token address\r\n\t\tbytes cloned_token,              // alt token address on the destination chain.\r\n\t\tbytes alt_addr,                  // address of receiving alt token on the dest chain.\r\n\t\tuint256 value                    // value to deposit.\r\n\t);\r\n\r\n\t// A Withdraw event is emitted when a user sends withdrawal transaction\r\n\t// with proof to the Port on the destination chain to withdraw native\r\n\t// currency or token with value to the dest_addr.\r\n\tevent Withdraw(\r\n\t\tuint256 indexed chain_id,   // id of the destination chain.\r\n\t\taddress indexed main_token, // the source token address on this chain.\r\n\t\taddress indexed addr,       // address to withdraw to on this chain.\r\n\t\tbytes proof,                // proof on the destination chain.\r\n\t\tbytes cloned_token,         // the dest token address on alt chain.\r\n\t\tuint256 value               // value to withdraw.\r\n\t);\r\n\r\n\t// A RegisterBreakout event is emitted when the foundation registers a pair\r\n\t// of currencies to break out to a destination chain.\r\n\t// Note that\r\n\t//   - the zero address 0x0 of main_token represents the native currency\r\n\t//   - cloned_token must be a PortedToken\r\n\tevent RegisterBreakout(\r\n\t\tuint256 indexed chain_id,        // id of the destination chain.\r\n\t\taddress indexed main_token,      // source token address on this chain.\r\n\t\tbytes indexed cloned_token_hash,\r\n\t\tbytes cloned_token,              // new destination address on the destination chain.\r\n\t\tbytes old_cloned_token,          // old destination address on the destination chain.\r\n\t\tuint256 minValue                 // minimum value to deposit and withdraw.\r\n\t);\r\n\r\n\t// A RegisterBreakin event is emitted when the foundation registers a pair\r\n\t// of currencies to break in from a source chain.\r\n\t// Note that\r\n\t//   - the zero address 0x0 of main_token represents the native currency\r\n\t//   - cloned_token must be a PortedToken\r\n\tevent RegisterBreakin(\r\n\t\tuint256 indexed chain_id,      // id of the source chain.\r\n\t\taddress indexed cloned_token,  // destination token address on this chain.\r\n\t\tbytes indexed main_token_hash,\r\n\t\tbytes main_token,              // new source address on the source chain.\r\n\t\tbytes old_main_token,          // old source address on the source chain.\r\n\t\tuint256 minValue               // minimum value to mint and burn.\r\n\t);\r\n\r\n\t// A Mint event is emitted when the foundation mints token with value to the\r\n\t// dest_addr as a user sends the transaction with proof on the source chain.\r\n\tevent Mint(\r\n\t\tuint256 indexed chain_id,     // id of the source chain.\r\n\t\taddress indexed cloned_token, // destination token address on this chain.\r\n\t\taddress indexed addr,         // destination address to mint to.\r\n\t\tbytes proof,                  // proof of the deposit on the source chain.\r\n\t\tbytes main_token,             // the source token on alt chain.\r\n\t\tuint256 value                 // value to mint.\r\n\t);\r\n\r\n\t// A Burn event is emitted when a user burns broken-in tokens to withdraw to\r\n\t// dest_addr on the source chain.\r\n\tevent Burn(\r\n\t\tuint256 indexed chain_id,      // id of the source chain to burn to.\r\n\t\tbytes indexed main_token_hash,\r\n\t\tbytes indexed alt_addr_hash,\r\n\t\taddress cloned_token,          // destination token on this chain.\r\n\t\tbytes main_token,              // source token on the source chain.\r\n\t\tbytes alt_addr,                // destination address on the source chain.\r\n\t\tuint256 value                  // value to burn\r\n\t);\r\n\r\n\tconstructor(address payable foundation_beneficiary) public {\r\n\t\tbeneficiary = foundation_beneficiary;\r\n\t}\r\n\r\n\tfunction destruct() public onlyFoundation {\r\n\t\t// transfer all tokens to beneficiary.\r\n\t\tfor (uint i=0; i<registeredMainTokens.length; i++) {\r\n\t\t\tIERC20 token = IERC20(registeredMainTokens[i]);\r\n\t\t\tuint256 balance = token.balanceOf(address(this));\r\n\t\t\ttoken.transfer(beneficiary, balance);\r\n\t\t}\r\n\r\n\t\t// transfer the ported tokens' control to the beneficiary\r\n\t\tfor (uint i=0; i<registeredClonedTokens.length; i++) {\r\n\t\t\tPortedToken token = PortedToken(registeredClonedTokens[i]);\r\n\t\t\ttoken.transferTeleport(beneficiary);\r\n\t\t}\r\n\r\n\t\tselfdestruct(beneficiary);\r\n\t}\r\n\r\n\tmodifier breakoutRegistered(uint256 chain_id, address token) {\r\n\t\trequire(breakoutTokens[token][chain_id].length != 0, 'unregistered token');\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier breakinRegistered(uint256 chain_id, address token) {\r\n\t\trequire(breakinTokens[token][chain_id].length != 0, 'unregistered token');\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier validAmount(uint256 chain_id, address token, uint256 value) {\r\n\t\trequire(value >= minPortValue[token][chain_id], \"value less than min amount\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier validProof(bytes memory proof) {\r\n\t\trequire(!proofs[proof], 'duplicate proof');\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction isProofUsed(bytes memory proof) view public returns (bool) {\r\n\t\treturn proofs[proof];\r\n\t}\r\n\r\n\t// Caller needs to send at least min value native token when called (payable).\r\n\t// A Deposit event will be emitted for the foundation server to mint the\r\n\t// corresponding wrapped tokens to the dest_addr on the destination chain.\r\n\t//\r\n\t// chain_id: The id of destination chain.\r\n\t// alt_addr: The address to mint to on the destination chain.\r\n\t// value: The value to mint.\r\n\tfunction depositNative(\r\n\t\tuint256 chain_id,\r\n\t\tbytes memory alt_addr\r\n\t)\r\n\t\tpayable\r\n\t\tpublic\r\n\t\twhenNotPaused\r\n\t\tbreakoutRegistered(chain_id, address(0))\r\n\t\tvalidAmount(chain_id, address(0), msg.value)\r\n\t{\r\n\t\tbytes memory cloned_token = breakoutTokens[address(0)][chain_id];\r\n\t\temit Deposit(chain_id,\r\n\t\t\tcloned_token, alt_addr, // indexed bytes value hashed automatically\r\n\t\t\taddress(0), cloned_token, alt_addr, msg.value);\r\n\t}\r\n\r\n\tfunction () payable external {\r\n\t\trevert('not allowed to send value');\r\n\t}\r\n\r\n\t// Caller needs to provide a proof of the transfer (proof).\r\n\t// A Deposit event will be emitted for the foundation server to mint the\r\n\t// corresponding wrapped tokens to the dest_addr on the destination chain.\r\n\t//\r\n\t// main_token: The token to deposit with.\r\n\t// chain_id: The id of destination chain.\r\n\t// alt_addr: The address to mint to on the destination chain.\r\n\t// value: The value to mint.\r\n\tfunction depositToken(\r\n\t\taddress main_token,\r\n\t\tuint256 chain_id,\r\n\t\tbytes memory alt_addr,\r\n\t\tuint256 value\r\n\t)\r\n\t\tpublic\r\n\t\twhenNotPaused\r\n\t\tbreakoutRegistered(chain_id, main_token)\r\n\t\tvalidAmount(chain_id, main_token, value)\r\n\t{\r\n\t\tbytes memory cloned_token = breakoutTokens[main_token][chain_id];\r\n\t\temit Deposit(chain_id,\r\n\t\t\tcloned_token, alt_addr, // indexed bytes value hashed automatically\r\n\t\t\tmain_token, cloned_token, alt_addr, value);\r\n\r\n\t\tIERC20 token = IERC20(main_token);\r\n\t\trequire(token.transferFrom(msg.sender, address(this), value));\r\n\t}\r\n\r\n\t// Caller needs to provide a proof of the transfer (proof).\r\n\t//\r\n\t// chain_id: The alt chain where the burn proof is.\r\n\t// proof: The proof of the corresponding transaction on the source chain.\r\n\t// addr: The address to withdraw to on this chain.\r\n\t// value: The value to withdraw.\r\n\tfunction withdrawNative(\r\n\t\tuint256 chain_id,\r\n\t\tbytes memory proof,\r\n\t\taddress payable addr,\r\n\t\tuint256 value\r\n\t)\r\n\t\tpublic\r\n\t\twhenNotPaused\r\n\t\tonlyFoundation\r\n\t\tbreakoutRegistered(chain_id, address(0))\r\n\t\tvalidProof(proof)\r\n\t\tvalidAmount(chain_id, address(0), value)\r\n\t{\r\n\t\tbytes memory cloned_token = breakoutTokens[address(0)][chain_id];\r\n\t\temit Withdraw(chain_id, address(0), addr, proof, cloned_token, value);\r\n\r\n\t\tproofs[proof] = true;\r\n\r\n\t\taddr.transfer(value);\r\n\t}\r\n\r\n\t// Caller needs to provide a proof of the transfer (proof).\r\n\t//\r\n\t// chain_id: The alt chain where the burn proof is.\r\n\t// proof: The proof of the corresponding transaction on the destination chain.\r\n\t// main_token: The address of the token to mint on this chain.\r\n\t// addr: The address to withdraw to on this chain.\r\n\t// value: The value to withdraw.\r\n\tfunction withdrawToken(\r\n\t\tuint256 chain_id,\r\n\t\tbytes memory proof,\r\n\t\taddress main_token,\r\n\t\taddress addr,\r\n\t\tuint256 value\r\n\t)\r\n\t\tpublic\r\n\t\twhenNotPaused\r\n\t\tonlyFoundation\r\n\t\tbreakoutRegistered(chain_id, main_token)\r\n\t\tvalidAmount(chain_id, main_token, value)\r\n\t\tvalidProof(proof)\r\n\t{\r\n\t\tbytes memory cloned_token = breakoutTokens[main_token][chain_id];\r\n\t\temit Withdraw(chain_id, main_token, addr, proof, cloned_token, value);\r\n\r\n\t\tproofs[proof] = true;\r\n\r\n\t\tIERC20 token = IERC20(main_token);\r\n\t\trequire(token.transfer(addr, value));\r\n\t}\r\n\r\n\r\n\t// Caller needs to provide the source and the destination of the mapped\r\n\t// token contract. The mapping will be updated if the register function is\r\n\t// called with a registered source address. The token is revoked if the dest\r\n\t// address is set to zero-length bytes.\r\n\t//\r\n\t// main_token: The address of the token on this chain.\r\n\t// chain_id: The id of the chain the cloned token is in.\r\n\t// cloned_token: The address of the token on the alt chain (dest chain).\r\n\t// old_cloned_token: The original address of the cloned token.\r\n\t// minValue: The minimum amount of each deposit/burn can transfer with.\r\n\tfunction registerBreakout(\r\n\t\taddress main_token,\r\n\t\tuint256 chain_id,\r\n\t\tbytes memory old_cloned_token,\r\n\t\tbytes memory cloned_token,\r\n\t\tuint256 minValue\r\n\t)\r\n\t\tpublic\r\n\t\twhenNotPaused\r\n\t\tonlyFoundation\r\n\t{\r\n\t\trequire(keccak256(breakoutTokens[main_token][chain_id]) == keccak256(old_cloned_token), 'wrong old dest');\r\n\r\n\t\temit RegisterBreakout(chain_id, main_token,\r\n\t\t\tcloned_token, // indexed bytes value is hashed automatically\r\n\t\t\tcloned_token, old_cloned_token, minValue);\r\n\r\n\t\tbreakoutTokens[main_token][chain_id] = cloned_token;\r\n\t\tminPortValue[main_token][chain_id] = minValue;\r\n\r\n\t\tbool firstTimeRegistration = old_cloned_token.length == 0;\r\n\t\tif (main_token != address(0) && firstTimeRegistration) {\r\n\t\t\tregisteredMainTokens.push(main_token);\r\n\t\t}\r\n\t}\r\n\r\n\t// Caller needs to provide the source and the destination of the mapped\r\n\t// token contract. The mapping will be updated if the register function is\r\n\t// called with a registered source address. The token is revoked if the dest\r\n\t// address is set to zero-length bytes.\r\n\t//\r\n\t// cloned_token: The address of the token on this chain.\r\n\t// chain_id: The id of the chain the main token is in.\r\n\t// main_token: The address of the token on the alt chain (source chain).\r\n\t// old_main_token: The original address of the main token.\r\n\t// minValue: The minimum amount of each deposit/burn can transfer with.\r\n\tfunction registerBreakin(\r\n\t\taddress cloned_token,\r\n\t\tuint256 chain_id,\r\n\t\tbytes memory old_main_token,\r\n\t\tbytes memory main_token,\r\n\t\tuint256 minValue\r\n\t)\r\n\t\tpublic\r\n\t\twhenNotPaused\r\n\t\tonlyFoundation\r\n\t{\r\n\t\trequire(keccak256(breakinTokens[cloned_token][chain_id]) == keccak256(old_main_token), 'wrong old src');\r\n\r\n\t\temit RegisterBreakin(chain_id, cloned_token,\r\n\t\t\tmain_token, // indexed bytes value is hashed automatically\r\n\t\t\tmain_token, old_main_token, minValue);\r\n\r\n\t\tbreakinTokens[cloned_token][chain_id] = main_token;\r\n\t\tminPortValue[cloned_token][chain_id] = minValue;\r\n\r\n\t\tbool firstTimeRegistration = old_main_token.length == 0;\r\n\t\tif (firstTimeRegistration) {\r\n\t\t\tregisteredClonedTokens.push(cloned_token);\r\n\t\t}\r\n\t}\r\n\r\n\t// Caller needs to provide the proof of the Deposit (proof), which\r\n\t// can be verified on the source chain with corresponding transaction.\r\n\t//\r\n\t// chain_id: The id of the chain the main token is in.\r\n\t// proof: The proof of the corresponding transaction on alt chain.\r\n\t// cloned_token: The address of the token to mint on this chain.\r\n\t// addr: The address to mint to on this chain.\r\n\t// value: The value to mint.\r\n\tfunction mint(\r\n\t\tuint256 chain_id,\r\n\t\tbytes memory proof,\r\n\t\taddress cloned_token,\r\n\t\taddress addr,\r\n\t\tuint256 value\r\n\t)\r\n\t\tpublic\r\n\t\twhenNotPaused\r\n\t\tonlyFoundation\r\n\t\tbreakinRegistered(chain_id, cloned_token)\r\n\t\tvalidAmount(chain_id, cloned_token, value)\r\n\t\tvalidProof(proof)\r\n\t{\r\n\t\tbytes memory main_token = breakinTokens[cloned_token][chain_id];\r\n\t\temit Mint(chain_id, cloned_token, addr, proof, main_token, value);\r\n\r\n\t\tproofs[proof] = true;\r\n\r\n\t\tPortedToken token = PortedToken(cloned_token);\r\n\t\ttoken.mint(addr, value);\r\n\t}\r\n\r\n\t// Caller needs to provide the proof of the Burn (proof), which contains\r\n\t// proof matching the destination and value.\r\n\t//\r\n\t// chain_id: The id of the chain the main token is in.\r\n\t// cloned_token: The address of the ported token on this chain.\r\n\t// alt_addr: The address to withdraw to on altchain.\r\n\t// value: The value to withdraw.\r\n\tfunction burn(\r\n\t\tuint256 chain_id,\r\n\t\taddress cloned_token,\r\n\t\tbytes memory alt_addr,\r\n\t\tuint256 value\r\n\t)\r\n\t\tpublic\r\n\t\twhenNotPaused\r\n\t\tbreakinRegistered(chain_id, cloned_token)\r\n\t\tvalidAmount(chain_id, cloned_token, value)\r\n\t{\r\n\t\tbytes memory main_token = breakinTokens[cloned_token][chain_id];\r\n\t\temit Burn(chain_id,\r\n\t\t\tmain_token, alt_addr, // indexed value are hashed automatically\r\n\t\t\tcloned_token, main_token, alt_addr, value);\r\n\r\n\t\tPortedToken token = PortedToken(cloned_token);\r\n\t\ttoken.burn(msg.sender, value);\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"cloned_token\",\"type\":\"address\"},{\"name\":\"chain_id\",\"type\":\"uint256\"},{\"name\":\"old_main_token\",\"type\":\"bytes\"},{\"name\":\"main_token\",\"type\":\"bytes\"},{\"name\":\"minValue\",\"type\":\"uint256\"}],\"name\":\"registerBreakin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registeredClonedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"f\",\"type\":\"address\"}],\"name\":\"transferFoundation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foundation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registeredMainTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"minPortValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"main_token\",\"type\":\"address\"},{\"name\":\"chain_id\",\"type\":\"uint256\"},{\"name\":\"old_cloned_token\",\"type\":\"bytes\"},{\"name\":\"cloned_token\",\"type\":\"bytes\"},{\"name\":\"minValue\",\"type\":\"uint256\"}],\"name\":\"registerBreakout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"chain_id\",\"type\":\"uint256\"},{\"name\":\"proof\",\"type\":\"bytes\"},{\"name\":\"main_token\",\"type\":\"address\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"breakinTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"chain_id\",\"type\":\"uint256\"},{\"name\":\"proof\",\"type\":\"bytes\"},{\"name\":\"cloned_token\",\"type\":\"address\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proof\",\"type\":\"bytes\"}],\"name\":\"isProofUsed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"breakoutTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"main_token\",\"type\":\"address\"},{\"name\":\"chain_id\",\"type\":\"uint256\"},{\"name\":\"alt_addr\",\"type\":\"bytes\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"chain_id\",\"type\":\"uint256\"},{\"name\":\"cloned_token\",\"type\":\"address\"},{\"name\":\"alt_addr\",\"type\":\"bytes\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"chain_id\",\"type\":\"uint256\"},{\"name\":\"proof\",\"type\":\"bytes\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdrawNative\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"chain_id\",\"type\":\"uint256\"},{\"name\":\"alt_addr\",\"type\":\"bytes\"}],\"name\":\"depositNative\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"foundation_beneficiary\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"chain_id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"cloned_token_hash\",\"type\":\"bytes\"},{\"indexed\":true,\"name\":\"alt_addr_hash\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"main_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cloned_token\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"alt_addr\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"chain_id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"main_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"proof\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"cloned_token\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"chain_id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"main_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"cloned_token_hash\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"cloned_token\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"old_cloned_token\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"minValue\",\"type\":\"uint256\"}],\"name\":\"RegisterBreakout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"chain_id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"cloned_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"main_token_hash\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"main_token\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"old_main_token\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"minValue\",\"type\":\"uint256\"}],\"name\":\"RegisterBreakin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"chain_id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"cloned_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"proof\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"main_token\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"chain_id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"main_token_hash\",\"type\":\"bytes\"},{\"indexed\":true,\"name\":\"alt_addr_hash\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"cloned_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"main_token\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"alt_addr\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newAddr\",\"type\":\"address\"}],\"name\":\"FoundationTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"}]","ContractName":"Port","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"000000000000000000000000da3517c5d6c0c7ae9a416310e7f8a16635d00d85","Library":"","SwarmSource":"bzzr://c21a1941d81363302ac34619103a8f5b2b1d3e000f546c6212a4445a8f32fab3"}]}