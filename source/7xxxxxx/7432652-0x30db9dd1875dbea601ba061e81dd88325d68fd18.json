{"status":"1","message":"OK","result":[{"SourceCode":"// File: ../../mosaic-contracts/contracts/lib/RLP.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n* @title RLPReader\r\n*\r\n* RLPReader is used to read and parse RLP encoded data in memory.\r\n*\r\n* @author Andreas Olofsson (androlo1980@gmail.com)\r\n*/\r\nlibrary RLP {\r\n\r\n    /** Constants */\r\n    uint constant DATA_SHORT_START = 0x80;\r\n    uint constant DATA_LONG_START = 0xB8;\r\n    uint constant LIST_SHORT_START = 0xC0;\r\n    uint constant LIST_LONG_START = 0xF8;\r\n\r\n    uint constant DATA_LONG_OFFSET = 0xB7;\r\n    uint constant LIST_LONG_OFFSET = 0xF7;\r\n\r\n    /** Storage */\r\n    struct RLPItem {\r\n        uint _unsafe_memPtr;    // Pointer to the RLP-encoded bytes.\r\n        uint _unsafe_length;    // Number of bytes. This is the full length of the string.\r\n    }\r\n\r\n    struct Iterator {\r\n        RLPItem _unsafe_item;   // Item that's being iterated over.\r\n        uint _unsafe_nextPtr;   // Position of the next item in the list.\r\n    }\r\n\r\n    /* Internal Functions */\r\n\r\n    /** Iterator */\r\n\r\n    function next(\r\n        Iterator memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (RLPItem memory subItem_)\r\n    {\r\n        require(hasNext(self));\r\n        uint ptr = self._unsafe_nextPtr;\r\n        uint itemLength = _itemLength(ptr);\r\n        subItem_._unsafe_memPtr = ptr;\r\n        subItem_._unsafe_length = itemLength;\r\n        self._unsafe_nextPtr = ptr + itemLength;\r\n    }\r\n\r\n    function next(\r\n        Iterator memory self,\r\n        bool strict\r\n    )\r\n        internal\r\n        pure\r\n        returns (RLPItem memory subItem_)\r\n    {\r\n        subItem_ = next(self);\r\n        require(!(strict && !_validate(subItem_)));\r\n    }\r\n\r\n    function hasNext(Iterator memory self) internal pure returns (bool) {\r\n        RLPItem memory item = self._unsafe_item;\r\n        return self._unsafe_nextPtr < item._unsafe_memPtr + item._unsafe_length;\r\n    }\r\n\r\n    /** RLPItem */\r\n\r\n    /**\r\n    *  @dev Creates an RLPItem from an array of RLP encoded bytes.\r\n    *\r\n    *  @param self The RLP encoded bytes.\r\n    *\r\n    *  @return An RLPItem.\r\n    */\r\n    function toRLPItem(\r\n        bytes memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (RLPItem memory)\r\n    {\r\n        uint len = self.length;\r\n        if (len == 0) {\r\n            return RLPItem(0, 0);\r\n        }\r\n        uint memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            memPtr := add(self, 0x20)\r\n        }\r\n\r\n        return RLPItem(memPtr, len);\r\n    }\r\n\r\n    /**\r\n    *  @dev Creates an RLPItem from an array of RLP encoded bytes.\r\n    *\r\n    *  @param self The RLP encoded bytes.\r\n    *  @param strict Will throw if the data is not RLP encoded.\r\n    *\r\n    *  @return An RLPItem.\r\n    */\r\n    function toRLPItem(\r\n        bytes memory self,\r\n        bool strict\r\n    )\r\n        internal\r\n        pure\r\n        returns (RLPItem memory)\r\n    {\r\n        RLPItem memory item = toRLPItem(self);\r\n        if(strict) {\r\n            uint len = self.length;\r\n            require(_payloadOffset(item) <= len);\r\n            require(_itemLength(item._unsafe_memPtr) == len);\r\n            require(_validate(item));\r\n        }\r\n        return item;\r\n    }\r\n\r\n    /**\r\n    *  @dev Check if the RLP item is null.\r\n    *\r\n    *  @param self The RLP item.\r\n    *\r\n    *  @return 'true' if the item is null.\r\n    */\r\n    function isNull(RLPItem memory self) internal pure returns (bool ret) {\r\n        return self._unsafe_length == 0;\r\n    }\r\n\r\n    /**\r\n    *  @dev Check if the RLP item is a list.\r\n    *\r\n    *  @param self The RLP item.\r\n    *\r\n    *  @return 'true' if the item is a list.\r\n    */\r\n    function isList(RLPItem memory self) internal pure returns (bool ret) {\r\n        if (self._unsafe_length == 0) {\r\n            return false;\r\n        }\r\n        uint memPtr = self._unsafe_memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            ret := iszero(lt(byte(0, mload(memPtr)), 0xC0))\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Check if the RLP item is data.\r\n    *\r\n    *  @param self The RLP item.\r\n    *\r\n    *  @return 'true' if the item is data.\r\n    */\r\n    function isData(RLPItem memory self) internal pure returns (bool ret) {\r\n        if (self._unsafe_length == 0) {\r\n            return false;\r\n        }\r\n        uint memPtr = self._unsafe_memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            ret := lt(byte(0, mload(memPtr)), 0xC0)\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Check if the RLP item is empty (string or list).\r\n    *\r\n    *  @param self The RLP item.\r\n    *\r\n    *  @return 'true' if the item is null.\r\n    */\r\n    function isEmpty(RLPItem memory self) internal pure returns (bool ret) {\r\n        if(isNull(self)) {\r\n            return false;\r\n        }\r\n        uint b0;\r\n        uint memPtr = self._unsafe_memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n        }\r\n        return (b0 == DATA_SHORT_START || b0 == LIST_SHORT_START);\r\n    }\r\n\r\n    /**\r\n    *  @dev Get the number of items in an RLP encoded list.\r\n    *\r\n    *  @param self The RLP item.\r\n    *\r\n    *  @return The number of items.\r\n    */\r\n    function items(RLPItem memory self) internal pure returns (uint) {\r\n        if (!isList(self)) {\r\n            return 0;\r\n        }\r\n        uint b0;\r\n        uint memPtr = self._unsafe_memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n        }\r\n        uint pos = memPtr + _payloadOffset(self);\r\n        uint last = memPtr + self._unsafe_length - 1;\r\n        uint itms;\r\n        while(pos <= last) {\r\n            pos += _itemLength(pos);\r\n            itms++;\r\n        }\r\n        return itms;\r\n    }\r\n\r\n    /**\r\n    *  @dev Create an iterator.\r\n    *\r\n    *  @param self The RLP item.\r\n    *\r\n    *  @return An 'Iterator' over the item.\r\n    */\r\n    function iterator(\r\n        RLPItem memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (Iterator memory it_)\r\n    {\r\n        require (isList(self));\r\n        uint ptr = self._unsafe_memPtr + _payloadOffset(self);\r\n        it_._unsafe_item = self;\r\n        it_._unsafe_nextPtr = ptr;\r\n    }\r\n\r\n    /**\r\n    *  @dev Return the RLP encoded bytes.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The bytes.\r\n    */\r\n    function toBytes(\r\n        RLPItem memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory bts_)\r\n    {\r\n        uint len = self._unsafe_length;\r\n        if (len == 0) {\r\n            return bts_;\r\n        }\r\n        bts_ = new bytes(len);\r\n        _copyToBytes(self._unsafe_memPtr, bts_, len);\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into bytes. This will not work if the RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toData(\r\n        RLPItem memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory bts_)\r\n    {\r\n        require(isData(self));\r\n        uint rStartPos;\r\n        uint len;\r\n        (rStartPos, len) = _decode(self);\r\n        bts_ = new bytes(len);\r\n        _copyToBytes(rStartPos, bts_, len);\r\n    }\r\n\r\n    /**\r\n    *  @dev Get the list of sub-items from an RLP encoded list.\r\n    *       Warning: This is inefficient, as it requires that the list is read twice.\r\n    *\r\n    *  @param self The RLP item.\r\n    *\r\n    *  @return Array of RLPItems.\r\n    */\r\n    function toList(\r\n        RLPItem memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (RLPItem[] memory list_)\r\n    {\r\n        require(isList(self));\r\n        uint numItems = items(self);\r\n        list_ = new RLPItem[](numItems);\r\n        Iterator memory it = iterator(self);\r\n        uint idx = 0;\r\n        while(hasNext(it)) {\r\n            list_[idx] = next(it);\r\n            idx++;\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into an ascii string. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toAscii(\r\n        RLPItem memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (string memory str_)\r\n    {\r\n        require(isData(self));\r\n        uint rStartPos;\r\n        uint len;\r\n        (rStartPos, len) = _decode(self);\r\n        bytes memory bts = new bytes(len);\r\n        _copyToBytes(rStartPos, bts, len);\r\n        str_ = string(bts);\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into a uint. This will not work if the\r\n    *  RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toUint(RLPItem memory self) internal pure returns (uint data_) {\r\n        require(isData(self));\r\n        uint rStartPos;\r\n        uint len;\r\n        (rStartPos, len) = _decode(self);\r\n        if (len > 32 || len == 0) {\r\n            revert();\r\n        }\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            data_ := div(mload(rStartPos), exp(256, sub(32, len)))\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into a boolean. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toBool(RLPItem memory self) internal pure returns (bool data) {\r\n        require(isData(self));\r\n        uint rStartPos;\r\n        uint len;\r\n        (rStartPos, len) = _decode(self);\r\n        require(len == 1);\r\n        uint temp;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            temp := byte(0, mload(rStartPos))\r\n        }\r\n        require (temp <= 1);\r\n\r\n        return temp == 1 ? true : false;\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into a byte. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toByte(RLPItem memory self) internal pure returns (byte data) {\r\n        require(isData(self));\r\n        uint rStartPos;\r\n        uint len;\r\n        (rStartPos, len) = _decode(self);\r\n        require(len == 1);\r\n        uint temp;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            temp := byte(0, mload(rStartPos))\r\n        }\r\n\r\n        return byte(uint8(temp));\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into an int. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toInt(RLPItem memory self) internal pure returns (int data) {\r\n        return int(toUint(self));\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into a bytes32. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toBytes32(\r\n        RLPItem memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes32 data)\r\n    {\r\n        return bytes32(toUint(self));\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into an address. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toAddress(\r\n        RLPItem memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (address data)\r\n    {\r\n        require(isData(self));\r\n        uint rStartPos;\r\n        uint len;\r\n        (rStartPos, len) = _decode(self);\r\n        require (len == 20);\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            data := div(mload(rStartPos), exp(256, 12))\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into an address. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return Get the payload offset.\r\n    */\r\n    function _payloadOffset(RLPItem memory self) private pure returns (uint) {\r\n        if(self._unsafe_length == 0)\r\n            return 0;\r\n        uint b0;\r\n        uint memPtr = self._unsafe_memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n        }\r\n        if(b0 < DATA_SHORT_START)\r\n            return 0;\r\n        if(b0 < DATA_LONG_START || (b0 >= LIST_SHORT_START && b0 < LIST_LONG_START))\r\n            return 1;\r\n        if(b0 < LIST_SHORT_START)\r\n            return b0 - DATA_LONG_OFFSET + 1;\r\n        return b0 - LIST_LONG_OFFSET + 1;\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into an address. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param memPtr Memory pointer.\r\n    *\r\n    *  @return Get the full length of an RLP item.\r\n    */\r\n    function _itemLength(uint memPtr) private pure returns (uint len) {\r\n        uint b0;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n        }\r\n        if (b0 < DATA_SHORT_START) {\r\n            len = 1;\r\n        } else if (b0 < DATA_LONG_START) {\r\n            len = b0 - DATA_SHORT_START + 1;\r\n        } else if (b0 < LIST_SHORT_START) {\r\n            /* solium-disable-next-line */\r\n            assembly {\r\n                let bLen := sub(b0, 0xB7) // bytes length (DATA_LONG_OFFSET)\r\n                let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\r\n                len := add(1, add(bLen, dLen)) // total length\r\n            }\r\n        } else if (b0 < LIST_LONG_START) {\r\n            len = b0 - LIST_SHORT_START + 1;\r\n        } else {\r\n            /* solium-disable-next-line */\r\n            assembly {\r\n                let bLen := sub(b0, 0xF7) // bytes length (LIST_LONG_OFFSET)\r\n                let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\r\n                len := add(1, add(bLen, dLen)) // total length\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into an address. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return Get the full length of an RLP item.\r\n    */\r\n    function _decode(\r\n        RLPItem memory self\r\n    )\r\n        private\r\n        pure\r\n        returns (uint memPtr_, uint len_)\r\n    {\r\n        require(isData(self));\r\n        uint b0;\r\n        uint start = self._unsafe_memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            b0 := byte(0, mload(start))\r\n        }\r\n        if (b0 < DATA_SHORT_START) {\r\n            memPtr_ = start;\r\n            len_ = 1;\r\n\r\n            return (memPtr_, len_);\r\n        }\r\n        if (b0 < DATA_LONG_START) {\r\n            len_ = self._unsafe_length - 1;\r\n            memPtr_ = start + 1;\r\n        } else {\r\n            uint bLen;\r\n\r\n            /* solium-disable-next-line */\r\n            assembly {\r\n                bLen := sub(b0, 0xB7) // DATA_LONG_OFFSET\r\n            }\r\n            len_ = self._unsafe_length - 1 - bLen;\r\n            memPtr_ = start + bLen + 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Assumes that enough memory has been allocated to store in target.\r\n    *       Gets the full length of an RLP item.\r\n    *\r\n    *  @param btsPtr Bytes pointer.\r\n    *  @param tgt Last item to be allocated.\r\n    *  @param btsLen Bytes length.\r\n    */\r\n    function _copyToBytes(\r\n        uint btsPtr,\r\n        bytes memory tgt,\r\n        uint btsLen\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        // Exploiting the fact that 'tgt' was the last thing to be allocated,\r\n        // we can write entire words, and just overwrite any excess.\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n                let i := 0 // Start at arr + 0x20\r\n                let stopOffset := add(btsLen, 31)\r\n                let rOffset := btsPtr\r\n                let wOffset := add(tgt, 32)\r\n                for {} lt(i, stopOffset) { i := add(i, 32) }\r\n                {\r\n                    mstore(add(wOffset, i), mload(add(rOffset, i)))\r\n                }\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Check that an RLP item is valid.\r\n    *\r\n    *  @param self The RLPItem.\r\n    */\r\n    function _validate(RLPItem memory self) private pure returns (bool ret) {\r\n        // Check that RLP is well-formed.\r\n        uint b0;\r\n        uint b1;\r\n        uint memPtr = self._unsafe_memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n            b1 := byte(1, mload(memPtr))\r\n        }\r\n        if(b0 == DATA_SHORT_START + 1 && b1 < DATA_SHORT_START)\r\n            return false;\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: ../../mosaic-contracts/contracts/lib/MerklePatriciaProof.sol\r\n\r\npragma solidity ^0.5.0;\r\n/**\r\n * @title MerklePatriciaVerifier\r\n * @author Sam Mayo (sammayo888@gmail.com)\r\n *\r\n * @dev Library for verifing merkle patricia proofs.\r\n */\r\n\r\n\r\nlibrary MerklePatriciaProof {\r\n    /**\r\n     * @dev Verifies a merkle patricia proof.\r\n     * @param value The terminating value in the trie.\r\n     * @param encodedPath The path in the trie leading to value.\r\n     * @param rlpParentNodes The rlp encoded stack of nodes.\r\n     * @param root The root hash of the trie.\r\n     * @return The boolean validity of the proof.\r\n     */\r\n    function verify(\r\n        bytes32 value,\r\n        bytes calldata encodedPath,\r\n        bytes calldata rlpParentNodes,\r\n        bytes32 root\r\n    )\r\n        external\r\n        pure\r\n        returns (bool)\r\n    {\r\n        RLP.RLPItem memory item = RLP.toRLPItem(rlpParentNodes);\r\n        RLP.RLPItem[] memory parentNodes = RLP.toList(item);\r\n\r\n        bytes memory currentNode;\r\n        RLP.RLPItem[] memory currentNodeList;\r\n\r\n        bytes32 nodeKey = root;\r\n        uint pathPtr = 0;\r\n\r\n        bytes memory path = _getNibbleArray2(encodedPath);\r\n        if(path.length == 0) {return false;}\r\n\r\n        for (uint i=0; i<parentNodes.length; i++) {\r\n            if(pathPtr > path.length) {return false;}\r\n\r\n            currentNode = RLP.toBytes(parentNodes[i]);\r\n            if(nodeKey != keccak256(abi.encodePacked(currentNode))) {return false;}\r\n            currentNodeList = RLP.toList(parentNodes[i]);\r\n\r\n            if(currentNodeList.length == 17) {\r\n                if(pathPtr == path.length) {\r\n                    if(keccak256(abi.encodePacked(RLP.toBytes(currentNodeList[16]))) == value) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                uint8 nextPathNibble = uint8(path[pathPtr]);\r\n                if(nextPathNibble > 16) {return false;}\r\n                nodeKey = RLP.toBytes32(currentNodeList[nextPathNibble]);\r\n                pathPtr += 1;\r\n            } else if(currentNodeList.length == 2) {\r\n\r\n                // Count of matching node key nibbles in path starting from pathPtr.\r\n                uint traverseLength = _nibblesToTraverse(RLP.toData(currentNodeList[0]), path, pathPtr);\r\n\r\n                if(pathPtr + traverseLength == path.length) { //leaf node\r\n                    if(keccak256(abi.encodePacked(RLP.toData(currentNodeList[1]))) == value) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                } else if (traverseLength == 0) { // error: couldn't traverse path\r\n                    return false;\r\n                } else { // extension node\r\n                    pathPtr += traverseLength;\r\n                    nodeKey = RLP.toBytes32(currentNodeList[1]);\r\n                }\r\n\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function verifyDebug(\r\n        bytes32 value,\r\n        bytes memory not_encodedPath,\r\n        bytes memory rlpParentNodes,\r\n        bytes32 root\r\n    )\r\n        public\r\n        pure\r\n        returns (bool res_, uint loc_, bytes memory path_debug_)\r\n    {\r\n        RLP.RLPItem memory item = RLP.toRLPItem(rlpParentNodes);\r\n        RLP.RLPItem[] memory parentNodes = RLP.toList(item);\r\n\r\n        bytes memory currentNode;\r\n        RLP.RLPItem[] memory currentNodeList;\r\n\r\n        bytes32 nodeKey = root;\r\n        uint pathPtr = 0;\r\n\r\n        bytes memory path = _getNibbleArray2(not_encodedPath);\r\n        path_debug_ = path;\r\n        if(path.length == 0) {\r\n            loc_ = 0;\r\n            res_ = false;\r\n            return (res_, loc_, path_debug_);\r\n        }\r\n\r\n        for (uint i=0; i<parentNodes.length; i++) {\r\n            if(pathPtr > path.length) {\r\n                loc_ = 1;\r\n                res_ = false;\r\n                return (res_, loc_, path_debug_);\r\n            }\r\n\r\n            currentNode = RLP.toBytes(parentNodes[i]);\r\n            if(nodeKey != keccak256(abi.encodePacked(currentNode))) {\r\n                res_ = false;\r\n                loc_ = 100 + i;\r\n                return (res_, loc_, path_debug_);\r\n            }\r\n            currentNodeList = RLP.toList(parentNodes[i]);\r\n\r\n            loc_ = currentNodeList.length;\r\n\r\n            if(currentNodeList.length == 17) {\r\n                if(pathPtr == path.length) {\r\n                    if(keccak256(abi.encodePacked(RLP.toBytes(currentNodeList[16]))) == value) {\r\n                        res_ = true;\r\n                        return (res_, loc_, path_debug_);\r\n                    } else {\r\n                        loc_ = 3;\r\n                        return (res_, loc_, path_debug_);\r\n                    }\r\n                }\r\n\r\n                uint8 nextPathNibble = uint8(path[pathPtr]);\r\n                if(nextPathNibble > 16) {\r\n                    loc_ = 4;\r\n                    return (res_, loc_, path_debug_);\r\n                }\r\n                nodeKey = RLP.toBytes32(currentNodeList[nextPathNibble]);\r\n                pathPtr += 1;\r\n            } else if(currentNodeList.length == 2) {\r\n                pathPtr += _nibblesToTraverse(RLP.toData(currentNodeList[0]), path, pathPtr);\r\n\r\n                if(pathPtr == path.length) {//leaf node\r\n                    if(keccak256(abi.encodePacked(RLP.toData(currentNodeList[1]))) == value) {\r\n                        res_ = true;\r\n                        return (res_, loc_, path_debug_);\r\n                    } else {\r\n                        loc_ = 5;\r\n                        return (res_, loc_, path_debug_);\r\n                    }\r\n                }\r\n                //extension node\r\n                if(_nibblesToTraverse(RLP.toData(currentNodeList[0]), path, pathPtr) == 0) {\r\n                    loc_ = 6;\r\n                    res_ = (keccak256(abi.encodePacked()) == value);\r\n                    return (res_, loc_, path_debug_);\r\n                }\r\n\r\n                nodeKey = RLP.toBytes32(currentNodeList[1]);\r\n            } else {\r\n                loc_ = 7;\r\n                return (res_, loc_, path_debug_);\r\n            }\r\n        }\r\n\r\n        loc_ = 8;\r\n    }\r\n\r\n    function _nibblesToTraverse(\r\n        bytes memory encodedPartialPath,\r\n        bytes memory path,\r\n        uint pathPtr\r\n    )\r\n        private\r\n        pure\r\n        returns (uint len_)\r\n    {\r\n        // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath\r\n        // and slicedPath have elements that are each one hex character (1 nibble)\r\n        bytes memory partialPath = _getNibbleArray(encodedPartialPath);\r\n        bytes memory slicedPath = new bytes(partialPath.length);\r\n\r\n        // pathPtr counts nibbles in path\r\n        // partialPath.length is a number of nibbles\r\n        for(uint i=pathPtr; i<pathPtr+partialPath.length; i++) {\r\n            byte pathNibble = path[i];\r\n            slicedPath[i-pathPtr] = pathNibble;\r\n        }\r\n\r\n        if(keccak256(abi.encodePacked(partialPath)) == keccak256(abi.encodePacked(slicedPath))) {\r\n            len_ = partialPath.length;\r\n        } else {\r\n            len_ = 0;\r\n        }\r\n    }\r\n\r\n    // bytes b must be hp encoded\r\n    function _getNibbleArray(\r\n        bytes memory b\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory nibbles_)\r\n    {\r\n        if(b.length>0) {\r\n            uint8 offset;\r\n            uint8 hpNibble = uint8(_getNthNibbleOfBytes(0,b));\r\n            if(hpNibble == 1 || hpNibble == 3) {\r\n                nibbles_ = new bytes(b.length*2-1);\r\n                byte oddNibble = _getNthNibbleOfBytes(1,b);\r\n                nibbles_[0] = oddNibble;\r\n                offset = 1;\r\n            } else {\r\n                nibbles_ = new bytes(b.length*2-2);\r\n                offset = 0;\r\n            }\r\n\r\n            for(uint i=offset; i<nibbles_.length; i++) {\r\n                nibbles_[i] = _getNthNibbleOfBytes(i-offset+2,b);\r\n            }\r\n        }\r\n    }\r\n\r\n    // normal byte array, no encoding used\r\n    function _getNibbleArray2(\r\n        bytes memory b\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory nibbles_)\r\n    {\r\n        nibbles_ = new bytes(b.length*2);\r\n        for (uint i = 0; i < nibbles_.length; i++) {\r\n            nibbles_[i] = _getNthNibbleOfBytes(i, b);\r\n        }\r\n    }\r\n\r\n    function _getNthNibbleOfBytes(\r\n        uint n,\r\n        bytes memory str\r\n    )\r\n        private\r\n        pure returns (byte)\r\n    {\r\n        return byte(n%2==0 ? uint8(str[n/2])/0x10 : uint8(str[n/2])%0x10);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"bytes32\"},{\"name\":\"not_encodedPath\",\"type\":\"bytes\"},{\"name\":\"rlpParentNodes\",\"type\":\"bytes\"},{\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"verifyDebug\",\"outputs\":[{\"name\":\"res_\",\"type\":\"bool\"},{\"name\":\"loc_\",\"type\":\"uint256\"},{\"name\":\"path_debug_\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"bytes32\"},{\"name\":\"encodedPath\",\"type\":\"bytes\"},{\"name\":\"rlpParentNodes\",\"type\":\"bytes\"},{\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"verify\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"MerklePatriciaProof","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"Apache-2.0","SwarmSource":"bzzr://f6c5234328eb209974762e16bf20c98fda2d376e526f056e3ff5e23771b010ad"}]}