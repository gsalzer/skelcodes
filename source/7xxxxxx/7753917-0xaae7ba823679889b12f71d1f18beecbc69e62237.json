{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint supply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract KyberNetworkProxyInterface {\r\n    function maxGasPrice() external view returns(uint);\r\n    function getUserCapInWei(address user) external view returns(uint);\r\n    function getUserCapInTokenWei(address user, ERC20 token) external view returns(uint);\r\n    function enabled() external view returns(bool);\r\n    function info(bytes32 id) external view returns(uint);\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) public\r\n        returns (uint expectedRate, uint slippageRate);\r\n\r\n    function tradeWithHint(ERC20 src, uint srcAmount, ERC20 dest, address destAddress, uint maxDestAmount,\r\n        uint minConversionRate, address walletId, bytes memory hint) public payable returns(uint);\r\n\r\n    function trade(ERC20 src, uint srcAmount, ERC20 dest, address destAddress, uint maxDestAmount,\r\n        uint minConversionRate, address walletId) public payable returns(uint);\r\n\r\n    function swapEtherToToken(ERC20 token, uint minConversionRate) external payable returns(uint);\r\n    function swapTokenToEther(ERC20 token, uint tokenQty, uint minRate) external payable returns(uint);\r\n    function swapTokenToToken(ERC20 src, uint srcAmount, ERC20 dest, uint minConversionRate) public returns(uint);\r\n}\r\n\r\ninterface ExchangeInterface {\r\n    function swapEtherToToken (uint _ethAmount, address _tokenAddress, uint _maxAmount) payable external returns(uint, uint);\r\n    function swapTokenToEther (address _tokenAddress, uint _amount, uint _maxAmount) external returns(uint);\r\n\r\n    function getExpectedRate(address src, address dest, uint srcQty) external\r\n        returns (uint expectedRate, uint slippageRate);\r\n}\r\n\r\ncontract KyberWrapper is ExchangeInterface {\r\n\r\n    // Kovan\r\n    // address constant KYBER_INTERFACE = 0x692f391bCc85cefCe8C237C01e1f636BbD70EA4D;\r\n    // address constant ETHER_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    \r\n    // Mainnet\r\n    address constant KYBER_INTERFACE = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;\r\n    address constant ETHER_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    address constant WALLET_ID = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;\r\n\r\n    function swapEtherToToken (uint _ethAmount, address _tokenAddress, uint _maxAmount) external payable returns(uint, uint) {\r\n        uint minRate;\r\n        ERC20 ETH_TOKEN_ADDRESS = ERC20(ETHER_ADDRESS);\r\n        ERC20 token = ERC20(_tokenAddress);\r\n\r\n        KyberNetworkProxyInterface _kyberNetworkProxy = KyberNetworkProxyInterface(KYBER_INTERFACE);\r\n\r\n        (, minRate) = _kyberNetworkProxy.getExpectedRate(ETH_TOKEN_ADDRESS, token, _ethAmount);\r\n\r\n        uint destAmount = _kyberNetworkProxy.trade.value(_ethAmount)(\r\n            ETH_TOKEN_ADDRESS,\r\n            _ethAmount,\r\n            token,\r\n            msg.sender,\r\n            _maxAmount,\r\n            minRate,\r\n            WALLET_ID\r\n        );\r\n\r\n        uint balance = address(this).balance;\r\n\r\n        msg.sender.transfer(balance);\r\n\r\n        return (destAmount, balance);\r\n    }\r\n    \r\n    function swapTokenToEther (address _tokenAddress, uint _amount, uint _maxAmount) external returns(uint) {\r\n        uint minRate;\r\n        ERC20 ETH_TOKEN_ADDRESS = ERC20(ETHER_ADDRESS);\r\n        ERC20 token = ERC20(_tokenAddress);\r\n        \r\n        KyberNetworkProxyInterface _kyberNetworkProxy = KyberNetworkProxyInterface(KYBER_INTERFACE);\r\n        \r\n        (, minRate) = _kyberNetworkProxy.getExpectedRate(token, ETH_TOKEN_ADDRESS, _amount);\r\n\r\n        // Mitigate ERC20 Approve front-running attack, by initially setting, allowance to 0\r\n        require(token.approve(address(_kyberNetworkProxy), 0));\r\n\r\n        // Approve tokens so network can take them during the swap\r\n        token.approve(address(_kyberNetworkProxy), _amount);\r\n\r\n        uint destAmount = _kyberNetworkProxy.trade(\r\n            token,\r\n            _amount,\r\n            ETH_TOKEN_ADDRESS,\r\n            msg.sender,\r\n            _maxAmount,\r\n            minRate,\r\n            WALLET_ID\r\n        );\r\n\r\n        return destAmount;\r\n    }\r\n\r\n    function getExpectedRate(address _src, address _dest, uint _srcQty) public returns (uint, uint) {\r\n        return KyberNetworkProxyInterface(KYBER_INTERFACE).getExpectedRate(ERC20(_src), ERC20(_dest), _srcQty);\r\n    }\r\n\r\n    function() payable external {\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_maxAmount\",\"type\":\"uint256\"}],\"name\":\"swapTokenToEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ethAmount\",\"type\":\"uint256\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_maxAmount\",\"type\":\"uint256\"}],\"name\":\"swapEtherToToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_src\",\"type\":\"address\"},{\"name\":\"_dest\",\"type\":\"address\"},{\"name\":\"_srcQty\",\"type\":\"uint256\"}],\"name\":\"getExpectedRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"KyberWrapper","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://71f4db19fc9c613755502c504b9b32c36487990b6d89ba676c124554bb75c38e"}]}