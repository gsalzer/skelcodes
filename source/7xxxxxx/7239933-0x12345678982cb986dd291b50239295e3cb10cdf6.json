{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.3;\r\n\r\n// counter.market smart contracts:\r\n//  1) Proxy - delegatecalls into current exchange code, maintains storage of exchange state\r\n//  2) Registry (this one) - stores information on the latest exchange contract version and user approvals\r\n//  3) Treasury - takes custody of funds, moves them between token accounts, authorizing exchange code via\r\n\r\n// Counter contracts are deployed at predefined addresses which can be hardcoded.\r\ncontract FixedAddress {\r\n    address constant ProxyAddress = 0x1234567896326230a28ee368825D11fE6571Be4a;\r\n    address constant TreasuryAddress = 0x12345678979f29eBc99E00bdc5693ddEa564cA80;\r\n    address constant RegistryAddress = 0x12345678982cB986Dd291B50239295E3Cb10Cdf6;\r\n}\r\n\r\n// External contracts access Registry via one of these methods\r\ninterface RegistryInterface {\r\n    function getOwner() external view returns (address);\r\n    function getExchangeContract() external view returns (address);\r\n    function contractApproved(address traderAddr) external view returns (bool);\r\n    function contractApprovedBoth(address traderAddr1, address traderAddr2) external view returns (bool);\r\n    function acceptNextExchangeContract() external;\r\n}\r\n\r\n// Standard ownership semantics\r\ncontract Ownable {\r\n    address public owner;\r\n    address private nextOwner;\r\n\r\n    event OwnershipTransfer(address newOwner, address previousOwner);\r\n\r\n    modifier onlyOwner {\r\n        require (msg.sender == owner, \"onlyOwner methods called by non-owner.\");\r\n        _;\r\n    }\r\n\r\n    function approveNextOwner(address _nextOwner) external onlyOwner {\r\n        require (_nextOwner != owner, \"Cannot approve current owner.\");\r\n        nextOwner = _nextOwner;\r\n    }\r\n\r\n    function acceptNextOwner() external {\r\n        require (msg.sender == nextOwner, \"Can only accept preapproved new owner.\");\r\n        emit OwnershipTransfer(nextOwner, owner);\r\n        owner = nextOwner;\r\n    }\r\n}\r\n\r\ncontract Registry is FixedAddress, RegistryInterface, Ownable {\r\n\r\n    // *** Variables\r\n\r\n    // Current exchange contract and its version.\r\n    // Version 0 means uninitialized Registry, first ever Exchange contract is\r\n    // version 1 and the number increments from there.\r\n    address public exchangeContract;\r\n    uint private exchangeContractVersion;\r\n\r\n    // Contract upgrades are preapproved by the Registry owner, and the new version\r\n    // should accept the ownership transfer from its address. This means that Exchange\r\n    // contracts should use deterministic addresses which can be determined beforehand.\r\n    address private nextExchangeContract;\r\n\r\n    // Previously used Exchange contracts cannot be used again - this prevents some\r\n    // scenarios where Counter operator may use old digital signatures of traders\r\n    // maliciously.\r\n    mapping (address => bool) private prevExchangeContracts;\r\n\r\n    // The very first Exchange contract (version 1) is unconditionally trusted, because\r\n    // users can study it before depositing funds. Exchange contract upgrades, however, may\r\n    // invalidate many assumptions, so we require that each trader explicitly approves the upgrade.\r\n    // These approvals are checked by the (immutable) Treasury contract before moving funds, so\r\n    // that it's impossible to compromise user funds by substituting Exchange contract with malicious\r\n    // code.\r\n    mapping (address => uint) private traderApprovals;\r\n\r\n    // *** Events\r\n\r\n    event UpgradeExchangeContract(address exchangeContract, uint exchangeContractVersion);\r\n    event TraderApproveContract(address traderAddr, uint exchangeContractVersion);\r\n\r\n    // *** Constructor\r\n\r\n    constructor () public {\r\n        owner = msg.sender;\r\n        // exchangeContract, exchangeContractVersion are zero upon initialization\r\n    }\r\n\r\n    // *** Public getters\r\n\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n\r\n    function getExchangeContract() external view returns (address) {\r\n        return exchangeContract;\r\n    }\r\n\r\n    // *** Exchange contract upgrade (approve/accept pattern)\r\n\r\n    function approveNextExchangeContract(address _nextExchangeContract) external onlyOwner {\r\n        require (_nextExchangeContract != exchangeContract, \"Cannot approve current exchange contract.\");\r\n        require (!prevExchangeContracts[_nextExchangeContract], \"Cannot approve previously used contract.\");\r\n        nextExchangeContract = _nextExchangeContract;\r\n    }\r\n\r\n    function acceptNextExchangeContract() external {\r\n        require (msg.sender == nextExchangeContract, \"Can only accept preapproved exchange contract.\");\r\n        exchangeContract = nextExchangeContract;\r\n        prevExchangeContracts[nextExchangeContract] = true;\r\n        exchangeContractVersion++;\r\n\r\n        emit UpgradeExchangeContract(exchangeContract, exchangeContractVersion);\r\n    }\r\n\r\n    // *** Trader approval for the new contract version.\r\n\r\n    function traderApproveCurrentExchangeContract(uint _exchangeContractVersion) external {\r\n        require (_exchangeContractVersion > 1, \"First version doesn't need approval.\");\r\n        require (_exchangeContractVersion == exchangeContractVersion, \"Can only approve the latest version.\");\r\n        traderApprovals[msg.sender] = _exchangeContractVersion;\r\n\r\n        emit TraderApproveContract(msg.sender, _exchangeContractVersion);\r\n    }\r\n\r\n    // *** Methods to check approval of the contract upgrade (invoked by the Treasury)\r\n\r\n    function contractApproved(address traderAddr) external view returns (bool) {\r\n        if (exchangeContractVersion > 1) {\r\n            return exchangeContractVersion == traderApprovals[traderAddr];\r\n\r\n        } else {\r\n            return exchangeContractVersion == 1;\r\n        }\r\n    }\r\n\r\n    function contractApprovedBoth(address traderAddr1, address traderAddr2) external view returns (bool) {\r\n        // This method is an optimization - it checks approval of two traders simultaneously to\r\n        // save gas on an extra cross-contract method call.\r\n        if (exchangeContractVersion > 1) {\r\n            return\r\n              exchangeContractVersion == traderApprovals[traderAddr1] &&\r\n              exchangeContractVersion == traderApprovals[traderAddr2];\r\n\r\n        } else {\r\n            return exchangeContractVersion == 1;\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"traderAddr1\",\"type\":\"address\"},{\"name\":\"traderAddr2\",\"type\":\"address\"}],\"name\":\"contractApprovedBoth\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeContractVersion\",\"type\":\"uint256\"}],\"name\":\"traderApproveCurrentExchangeContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExchangeContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptNextExchangeContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nextOwner\",\"type\":\"address\"}],\"name\":\"approveNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nextExchangeContract\",\"type\":\"address\"}],\"name\":\"approveNextExchangeContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"traderAddr\",\"type\":\"address\"}],\"name\":\"contractApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"exchangeContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"exchangeContractVersion\",\"type\":\"uint256\"}],\"name\":\"UpgradeExchangeContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"traderAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"exchangeContractVersion\",\"type\":\"uint256\"}],\"name\":\"TraderApproveContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransfer\",\"type\":\"event\"}]","ContractName":"Registry","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2b03400ad89c7240d9460cacfa30ba1d123c80aa2d053fdb466774738482de5a"}]}