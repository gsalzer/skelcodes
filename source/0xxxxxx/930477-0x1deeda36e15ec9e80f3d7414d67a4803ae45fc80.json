{"status":"1","message":"OK","result":[{"SourceCode":"// Accounting v0.1 (not the same as the 0.1 release of this library)\r\n\r\n/// @title Accounting Lib - Accounting utilities\r\n/// @author Piper Merriam - <pipermerriam@gmail.com>\r\nlibrary AccountingLib {\r\n        /*\r\n         *  Address: 0x89efe605e9ecbe22849cd85d5449cc946c26f8f3\r\n         */\r\n        struct Bank {\r\n            mapping (address => uint) accountBalances;\r\n        }\r\n\r\n        /// @dev Low level method for adding funds to an account.  Protects against overflow.\r\n        /// @param self The Bank instance to operate on.\r\n        /// @param accountAddress The address of the account the funds should be added to.\r\n        /// @param value The amount that should be added to the account.\r\n        function addFunds(Bank storage self, address accountAddress, uint value) public {\r\n                if (self.accountBalances[accountAddress] + value < self.accountBalances[accountAddress]) {\r\n                        // Prevent Overflow.\r\n                        throw;\r\n                }\r\n                self.accountBalances[accountAddress] += value;\r\n        }\r\n\r\n        event _Deposit(address indexed _from, address indexed accountAddress, uint value);\r\n        /// @dev Function wrapper around the _Deposit event so that it can be used by contracts.  Can be used to log a deposit to an account.\r\n        /// @param _from The address that deposited the funds.\r\n        /// @param accountAddress The address of the account the funds were added to.\r\n        /// @param value The amount that was added to the account.\r\n        function Deposit(address _from, address accountAddress, uint value) public {\r\n            _Deposit(_from, accountAddress, value);\r\n        }\r\n\r\n\r\n        /// @dev Safe function for depositing funds.  Returns boolean for whether the deposit was successful\r\n        /// @param self The Bank instance to operate on.\r\n        /// @param accountAddress The address of the account the funds should be added to.\r\n        /// @param value The amount that should be added to the account.\r\n        function deposit(Bank storage self, address accountAddress, uint value) public returns (bool) {\r\n                addFunds(self, accountAddress, value);\r\n                return true;\r\n        }\r\n\r\n        event _Withdrawal(address indexed accountAddress, uint value);\r\n\r\n        /// @dev Function wrapper around the _Withdrawal event so that it can be used by contracts.  Can be used to log a withdrawl from an account.\r\n        /// @param accountAddress The address of the account the funds were withdrawn from.\r\n        /// @param value The amount that was withdrawn to the account.\r\n        function Withdrawal(address accountAddress, uint value) public {\r\n            _Withdrawal(accountAddress, value);\r\n        }\r\n\r\n        event _InsufficientFunds(address indexed accountAddress, uint value, uint balance);\r\n\r\n        /// @dev Function wrapper around the _InsufficientFunds event so that it can be used by contracts.  Can be used to log a failed withdrawl from an account.\r\n        /// @param accountAddress The address of the account the funds were to be withdrawn from.\r\n        /// @param value The amount that was attempted to be withdrawn from the account.\r\n        /// @param balance The current balance of the account.\r\n        function InsufficientFunds(address accountAddress, uint value, uint balance) public {\r\n            _InsufficientFunds(accountAddress, value, balance);\r\n        }\r\n\r\n        /// @dev Low level method for removing funds from an account.  Protects against underflow.\r\n        /// @param self The Bank instance to operate on.\r\n        /// @param accountAddress The address of the account the funds should be deducted from.\r\n        /// @param value The amount that should be deducted from the account.\r\n        function deductFunds(Bank storage self, address accountAddress, uint value) public {\r\n                /*\r\n                 *  Helper function that should be used for any reduction of\r\n                 *  account funds.  It has error checking to prevent\r\n                 *  underflowing the account balance which would be REALLY bad.\r\n                 */\r\n                if (value > self.accountBalances[accountAddress]) {\r\n                        // Prevent Underflow.\r\n                        throw;\r\n                }\r\n                self.accountBalances[accountAddress] -= value;\r\n        }\r\n\r\n        /// @dev Safe function for withdrawing funds.  Returns boolean for whether the deposit was successful as well as sending the amount in ether to the account address.\r\n        /// @param self The Bank instance to operate on.\r\n        /// @param accountAddress The address of the account the funds should be withdrawn from.\r\n        /// @param value The amount that should be withdrawn from the account.\r\n        function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {\r\n                /*\r\n                 *  Public API for withdrawing funds.\r\n                 */\r\n                if (self.accountBalances[accountAddress] >= value) {\r\n                        deductFunds(self, accountAddress, value);\r\n                        if (!accountAddress.send(value)) {\r\n                                // Potentially sending money to a contract that\r\n                                // has a fallback function.  So instead, try\r\n                                // tranferring the funds with the call api.\r\n                                if (!accountAddress.call.value(value)()) {\r\n                                        // Revert the entire transaction.  No\r\n                                        // need to destroy the funds.\r\n                                        throw;\r\n                                }\r\n                        }\r\n                        return true;\r\n                }\r\n                return false;\r\n        }\r\n\r\n        uint constant DEFAULT_SEND_GAS = 100000;\r\n\r\n        function sendRobust(address toAddress, uint value) public returns (bool) {\r\n                if (msg.gas < DEFAULT_SEND_GAS) {\r\n                    return sendRobust(toAddress, value, msg.gas);\r\n                }\r\n                return sendRobust(toAddress, value, DEFAULT_SEND_GAS);\r\n        }\r\n\r\n        function sendRobust(address toAddress, uint value, uint maxGas) public returns (bool) {\r\n                if (value > 0 && !toAddress.send(value)) {\r\n                        // Potentially sending money to a contract that\r\n                        // has a fallback function.  So instead, try\r\n                        // tranferring the funds with the call api.\r\n                        if (!toAddress.call.gas(maxGas).value(value)()) {\r\n                                return false;\r\n                        }\r\n                }\r\n                return true;\r\n        }\r\n}\r\n\r\n\r\nlibrary CallLib {\r\n    /*\r\n     *  Address: 0x1deeda36e15ec9e80f3d7414d67a4803ae45fc80\r\n     */\r\n    struct Call {\r\n        address contractAddress;\r\n        bytes4 abiSignature;\r\n        bytes callData;\r\n        uint callValue;\r\n        uint anchorGasPrice;\r\n        uint requiredGas;\r\n        uint16 requiredStackDepth;\r\n\r\n        address claimer;\r\n        uint claimAmount;\r\n        uint claimerDeposit;\r\n\r\n        bool wasSuccessful;\r\n        bool wasCalled;\r\n        bool isCancelled;\r\n    }\r\n\r\n    enum State {\r\n        Pending,\r\n        Unclaimed,\r\n        Claimed,\r\n        Frozen,\r\n        Callable,\r\n        Executed,\r\n        Cancelled,\r\n        Missed\r\n    }\r\n\r\n    function state(Call storage self) constant returns (State) {\r\n        if (self.isCancelled) return State.Cancelled;\r\n        if (self.wasCalled) return State.Executed;\r\n\r\n        var call = FutureBlockCall(this);\r\n\r\n        if (block.number + CLAIM_GROWTH_WINDOW + MAXIMUM_CLAIM_WINDOW + BEFORE_CALL_FREEZE_WINDOW < call.targetBlock()) return State.Pending;\r\n        if (block.number + BEFORE_CALL_FREEZE_WINDOW < call.targetBlock()) {\r\n            if (self.claimer == 0x0) {\r\n                return State.Unclaimed;\r\n            }\r\n            else {\r\n                return State.Claimed;\r\n            }\r\n        }\r\n        if (block.number < call.targetBlock()) return State.Frozen;\r\n        if (block.number < call.targetBlock() + call.gracePeriod()) return State.Callable;\r\n        return State.Missed;\r\n    }\r\n\r\n    // The number of blocks that each caller in the pool has to complete their\r\n    // call.\r\n    uint constant CALL_WINDOW_SIZE = 16;\r\n\r\n    address constant creator = 0xd3cda913deb6f67967b99d67acdfa1712c293601;\r\n\r\n    function extractCallData(Call storage call, bytes data) public {\r\n        call.callData.length = data.length - 4;\r\n        if (data.length > 4) {\r\n                for (uint i = 0; i < call.callData.length; i++) {\r\n                        call.callData[i] = data[i + 4];\r\n                }\r\n        }\r\n    }\r\n\r\n    uint constant GAS_PER_DEPTH = 700;\r\n\r\n    function checkDepth(uint n) constant returns (bool) {\r\n        if (n == 0) return true;\r\n        return address(this).call.gas(GAS_PER_DEPTH * n)(bytes4(sha3(\"__dig(uint256)\")), n - 1);\r\n    }\r\n\r\n    function sendSafe(address to_address, uint value) public returns (uint) {\r\n        if (value > address(this).balance) {\r\n            value = address(this).balance;\r\n        }\r\n        if (value > 0) {\r\n            AccountingLib.sendRobust(to_address, value);\r\n            return value;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getGasScalar(uint base_gas_price, uint gas_price) constant returns (uint) {\r\n        /*\r\n        *  Return a number between 0 - 200 to scale the donation based on the\r\n        *  gas price set for the calling transaction as compared to the gas\r\n        *  price of the scheduling transaction.\r\n        *\r\n        *  - number approaches zero as the transaction gas price goes\r\n        *  above the gas price recorded when the call was scheduled.\r\n        *\r\n        *  - the number approaches 200 as the transaction gas price\r\n        *  drops under the price recorded when the call was scheduled.\r\n        *\r\n        *  This encourages lower gas costs as the lower the gas price\r\n        *  for the executing transaction, the higher the payout to the\r\n        *  caller.\r\n        */\r\n        if (gas_price > base_gas_price) {\r\n            return 100 * base_gas_price / gas_price;\r\n        }\r\n        else {\r\n            return 200 - 100 * base_gas_price / (2 * base_gas_price - gas_price);\r\n        }\r\n    }\r\n\r\n    event CallExecuted(address indexed executor, uint gasCost, uint payment, uint donation, bool success);\r\n\r\n    bytes4 constant EMPTY_SIGNATURE = 0x0000;\r\n\r\n    event CallAborted(address executor, bytes32 reason);\r\n\r\n    function execute(Call storage self,\r\n                     uint start_gas,\r\n                     address executor,\r\n                     uint overhead,\r\n                     uint extraGas) public {\r\n        FutureCall call = FutureCall(this);\r\n        \r\n        // Mark the call has having been executed.\r\n        self.wasCalled = true;\r\n\r\n        // Make the call\r\n        if (self.abiSignature == EMPTY_SIGNATURE && self.callData.length == 0) {\r\n            self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)();\r\n        }\r\n        else if (self.abiSignature == EMPTY_SIGNATURE) {\r\n            self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.callData);\r\n        }\r\n        else if (self.callData.length == 0) {\r\n            self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature);\r\n        }\r\n        else {\r\n            self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature, self.callData);\r\n        }\r\n\r\n        call.origin().call(bytes4(sha3(\"updateDefaultPayment()\")));\r\n\r\n        // Compute the scalar (0 - 200) for the donation.\r\n        uint gasScalar = getGasScalar(self.anchorGasPrice, tx.gasprice);\r\n\r\n        uint basePayment;\r\n        if (self.claimer == executor) {\r\n            basePayment = self.claimAmount;\r\n        }\r\n        else {\r\n            basePayment = call.basePayment();\r\n        }\r\n        uint payment = self.claimerDeposit + basePayment * gasScalar / 100; \r\n        uint donation = call.baseDonation() * gasScalar / 100;\r\n\r\n        // zero out the deposit\r\n        self.claimerDeposit = 0;\r\n\r\n        // Log how much gas this call used.  EXTRA_CALL_GAS is a fixed\r\n        // amount that represents the gas usage of the commands that\r\n        // happen after this line.\r\n        uint gasCost = tx.gasprice * (start_gas - msg.gas + extraGas);\r\n\r\n        // Now we need to pay the executor as well as keep donation.\r\n        payment = sendSafe(executor, payment + gasCost);\r\n        donation = sendSafe(creator, donation);\r\n\r\n        // Log execution\r\n        CallExecuted(executor, gasCost, payment, donation, self.wasSuccessful);\r\n    }\r\n\r\n    event Cancelled(address indexed cancelled_by);\r\n\r\n    function cancel(Call storage self, address sender) public {\r\n        Cancelled(sender);\r\n        if (self.claimerDeposit >= 0) {\r\n            sendSafe(self.claimer, self.claimerDeposit);\r\n        }\r\n        var call = FutureCall(this);\r\n        sendSafe(call.schedulerAddress(), address(this).balance);\r\n        self.isCancelled = true;\r\n    }\r\n\r\n    /*\r\n     *  Bid API\r\n     *  - Gas costs for this transaction are not covered so it\r\n     *    must be up to the call executors to ensure that their actions\r\n     *    remain profitable.  Any form of bidding war is likely to eat into\r\n     *    profits.\r\n     */\r\n    event Claimed(address executor, uint claimAmount);\r\n\r\n    // The duration (in blocks) during which the maximum claim will slowly rise\r\n    // towards the basePayment amount.\r\n    uint constant CLAIM_GROWTH_WINDOW = 240;\r\n\r\n    // The duration (in blocks) after the CLAIM_WINDOW that claiming will\r\n    // remain open.\r\n    uint constant MAXIMUM_CLAIM_WINDOW = 15;\r\n\r\n    // The duration (in blocks) before the call's target block during which\r\n    // all actions are frozen.  This includes claiming, cancellation,\r\n    // registering call data.\r\n    uint constant BEFORE_CALL_FREEZE_WINDOW = 10;\r\n\r\n    /*\r\n     *  The maximum allowed claim amount slowly rises across a window of\r\n     *  blocks CLAIM_GROWTH_WINDOW prior to the call.  No claimer is\r\n     *  allowed to claim above this value.  This is intended to prevent\r\n     *  bidding wars in that each caller should know how much they are\r\n     *  willing to execute a call for.\r\n     */\r\n    function getClaimAmountForBlock(uint block_number) constant returns (uint) {\r\n        /*\r\n         *   [--growth-window--][--max-window--][--freeze-window--]\r\n         *\r\n         *\r\n         */\r\n        var call = FutureBlockCall(this);\r\n\r\n        uint cutoff = call.targetBlock() - BEFORE_CALL_FREEZE_WINDOW;\r\n        \r\n        // claim window has closed\r\n        if (block_number > cutoff) return call.basePayment();\r\n\r\n        cutoff -= MAXIMUM_CLAIM_WINDOW;\r\n\r\n        // in the maximum claim window.\r\n        if (block_number > cutoff) return call.basePayment();\r\n\r\n        cutoff -= CLAIM_GROWTH_WINDOW;\r\n\r\n        if (block_number > cutoff) {\r\n            uint x = block_number - cutoff;\r\n\r\n            return call.basePayment() * x / CLAIM_GROWTH_WINDOW;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function lastClaimBlock() constant returns (uint) {\r\n        var call = FutureBlockCall(this);\r\n        return call.targetBlock() - BEFORE_CALL_FREEZE_WINDOW;\r\n    }\r\n\r\n    function maxClaimBlock() constant returns (uint) {\r\n        return lastClaimBlock() - MAXIMUM_CLAIM_WINDOW;\r\n    }\r\n\r\n    function firstClaimBlock() constant returns (uint) {\r\n        return maxClaimBlock() - CLAIM_GROWTH_WINDOW;\r\n    }\r\n\r\n    function claim(Call storage self, address executor, uint deposit_amount, uint basePayment) public returns (bool) {\r\n        /*\r\n         *  Warning! this does not check whether the function is already\r\n         *  claimed or whether we are within the claim window.  This must be\r\n         *  done at the contract level.\r\n         */\r\n        // Insufficient Deposit\r\n        if (deposit_amount < 2 * basePayment) return false;\r\n\r\n        self.claimAmount = getClaimAmountForBlock(block.number);\r\n        self.claimer = executor;\r\n        self.claimerDeposit = deposit_amount;\r\n\r\n        // Log the claim.\r\n        Claimed(executor, self.claimAmount);\r\n    }\r\n\r\n    function checkExecutionAuthorization(Call storage self, address executor, uint block_number) returns (bool) {\r\n        /*\r\n        *  Check whether the given `executor` is authorized.\r\n        */\r\n        var call = FutureBlockCall(this);\r\n\r\n        uint targetBlock = call.targetBlock();\r\n\r\n        // Invalid, not in call window.\r\n        if (block_number < targetBlock || block_number > targetBlock + call.gracePeriod()) throw;\r\n\r\n        // Within the reserved call window so if there is a claimer, the\r\n        // executor must be the claimdor.\r\n        if (block_number - targetBlock < CALL_WINDOW_SIZE) {\r\n        return (self.claimer == 0x0 || self.claimer == executor);\r\n        }\r\n\r\n        // Must be in the free-for-all period.\r\n        return true;\r\n    }\r\n\r\n    function isCancellable(Call storage self, address caller) returns (bool) {\r\n        var _state = state(self);\r\n        var call = FutureBlockCall(this);\r\n\r\n        if (_state == State.Pending && caller == call.schedulerAddress()) {\r\n            return true;\r\n        }\r\n\r\n        if (_state == State.Missed) return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    function beforeExecuteForFutureBlockCall(Call storage self, address executor, uint startGas) returns (bool) {\r\n        bytes32 reason;\r\n\r\n        var call = FutureBlockCall(this);\r\n\r\n        if (startGas < self.requiredGas) {\r\n            // The executor has not provided sufficient gas\r\n            reason = \"NOT_ENOUGH_GAS\";\r\n        }\r\n        else if (self.wasCalled) {\r\n            // Not being called within call window.\r\n            reason = \"ALREADY_CALLED\";\r\n        }\r\n        else if (block.number < call.targetBlock() || block.number > call.targetBlock() + call.gracePeriod()) {\r\n            // Not being called within call window.\r\n            reason = \"NOT_IN_CALL_WINDOW\";\r\n        }\r\n        else if (!checkExecutionAuthorization(self, executor, block.number)) {\r\n            // Someone has claimed this call and they currently have exclusive\r\n            // rights to execute it.\r\n            reason = \"NOT_AUTHORIZED\";\r\n        }\r\n        else if (self.requiredStackDepth > 0 && executor != tx.origin && !checkDepth(self.requiredStackDepth)) {\r\n            reason = \"STACK_TOO_DEEP\";\r\n        }\r\n\r\n        if (reason != 0x0) {\r\n            CallAborted(executor, reason);\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\ncontract FutureCall {\r\n    // The author (Piper Merriam) address.\r\n    address constant creator = 0xd3cda913deb6f67967b99d67acdfa1712c293601;\r\n\r\n    address public schedulerAddress;\r\n\r\n    uint public basePayment;\r\n    uint public baseDonation;\r\n\r\n    CallLib.Call call;\r\n\r\n    address public origin;\r\n\r\n    function FutureCall(address _schedulerAddress,\r\n                        uint _requiredGas,\r\n                        uint16 _requiredStackDepth,\r\n                        address _contractAddress,\r\n                        bytes4 _abiSignature,\r\n                        bytes _callData,\r\n                        uint _callValue,\r\n                        uint _basePayment,\r\n                        uint _baseDonation)\r\n    {\r\n        origin = msg.sender;\r\n        schedulerAddress = _schedulerAddress;\r\n\r\n        basePayment = _basePayment;\r\n        baseDonation = _baseDonation;\r\n\r\n        call.requiredGas = _requiredGas;\r\n        call.requiredStackDepth = _requiredStackDepth;\r\n        call.anchorGasPrice = tx.gasprice;\r\n        call.contractAddress = _contractAddress;\r\n        call.abiSignature = _abiSignature;\r\n        call.callData = _callData;\r\n        call.callValue = _callValue;\r\n    }\r\n\r\n    enum State {\r\n        Pending,\r\n        Unclaimed,\r\n        Claimed,\r\n        Frozen,\r\n        Callable,\r\n        Executed,\r\n        Cancelled,\r\n        Missed\r\n    }\r\n\r\n    modifier in_state(State _state) { if (state() == _state) _ }\r\n\r\n    function state() constant returns (State) {\r\n        return State(CallLib.state(call));\r\n    }\r\n\r\n    /*\r\n     *  API for FutureXXXXCalls to implement.\r\n     */\r\n    function beforeExecute(address executor, uint startGas) public returns (bool);\r\n    function afterExecute(address executor) internal;\r\n    function getOverhead() constant returns (uint);\r\n    function getExtraGas() constant returns (uint);\r\n\r\n    /*\r\n     *  Data accessor functions.\r\n     */\r\n    function contractAddress() constant returns (address) {\r\n        return call.contractAddress;\r\n    }\r\n\r\n    function abiSignature() constant returns (bytes4) {\r\n        return call.abiSignature;\r\n    }\r\n\r\n    function callData() constant returns (bytes) {\r\n        return call.callData;\r\n    }\r\n\r\n    function callValue() constant returns (uint) {\r\n        return call.callValue;\r\n    }\r\n\r\n    function anchorGasPrice() constant returns (uint) {\r\n        return call.anchorGasPrice;\r\n    }\r\n\r\n    function requiredGas() constant returns (uint) {\r\n        return call.requiredGas;\r\n    }\r\n\r\n    function requiredStackDepth() constant returns (uint16) {\r\n        return call.requiredStackDepth;\r\n    }\r\n\r\n    function claimer() constant returns (address) {\r\n        return call.claimer;\r\n    }\r\n\r\n    function claimAmount() constant returns (uint) {\r\n        return call.claimAmount;\r\n    }\r\n\r\n    function claimerDeposit() constant returns (uint) {\r\n        return call.claimerDeposit;\r\n    }\r\n\r\n    function wasSuccessful() constant returns (bool) {\r\n        return call.wasSuccessful;\r\n    }\r\n\r\n    function wasCalled() constant returns (bool) {\r\n        return call.wasCalled;\r\n    }\r\n\r\n    function isCancelled() constant returns (bool) {\r\n        return call.isCancelled;\r\n    }\r\n\r\n    /*\r\n     *  Claim API helpers\r\n     */\r\n    function getClaimAmountForBlock() constant returns (uint) {\r\n        return CallLib.getClaimAmountForBlock(block.number);\r\n    }\r\n\r\n    function getClaimAmountForBlock(uint block_number) constant returns (uint) {\r\n        return CallLib.getClaimAmountForBlock(block_number);\r\n    }\r\n\r\n    /*\r\n     *  Call Data registration\r\n     */\r\n    function () returns (bool) {\r\n        /*\r\n         * Fallback to allow sending funds to this contract.\r\n         * (also allows registering raw call data)\r\n         */\r\n        // only scheduler can register call data.\r\n        if (msg.sender != schedulerAddress) return false;\r\n        // cannot write over call data\r\n        if (call.callData.length > 0) return false;\r\n\r\n        var _state = state();\r\n        if (_state != State.Pending && _state != State.Unclaimed && _state != State.Claimed) return false;\r\n\r\n        call.callData = msg.data;\r\n        return true;\r\n    }\r\n\r\n    function registerData() public returns (bool) {\r\n        // only scheduler can register call data.\r\n        if (msg.sender != schedulerAddress) return false;\r\n        // cannot write over call data\r\n        if (call.callData.length > 0) return false;\r\n\r\n        var _state = state();\r\n        if (_state != State.Pending && _state != State.Unclaimed && _state != State.Claimed) return false;\r\n\r\n        CallLib.extractCallData(call, msg.data);\r\n    }\r\n\r\n    function firstClaimBlock() constant returns (uint) {\r\n        return CallLib.firstClaimBlock();\r\n    }\r\n\r\n    function maxClaimBlock() constant returns (uint) {\r\n        return CallLib.maxClaimBlock();\r\n    }\r\n\r\n    function lastClaimBlock() constant returns (uint) {\r\n        return CallLib.lastClaimBlock();\r\n    }\r\n\r\n    function claim() public in_state(State.Unclaimed) returns (bool) {\r\n        bool success = CallLib.claim(call, msg.sender, msg.value, basePayment);\r\n        if (!success) {\r\n            if (!AccountingLib.sendRobust(msg.sender, msg.value)) throw;\r\n        }\r\n        return success;\r\n    }\r\n\r\n    function checkExecutionAuthorization(address executor, uint block_number) constant returns (bool) {\r\n        return CallLib.checkExecutionAuthorization(call, executor, block_number);\r\n    }\r\n\r\n    function sendSafe(address to_address, uint value) internal {\r\n        CallLib.sendSafe(to_address, value);\r\n    }\r\n\r\n    function execute() public in_state(State.Callable) {\r\n        uint start_gas = msg.gas;\r\n\r\n        // Check that the call should be executed now.\r\n        if (!beforeExecute(msg.sender, start_gas)) return;\r\n\r\n        // Execute the call\r\n        CallLib.execute(call, start_gas, msg.sender, getOverhead(), getExtraGas());\r\n\r\n        // Any logic that needs to occur after the call has executed should\r\n        // go in afterExecute\r\n        afterExecute(msg.sender);\r\n    }\r\n}\r\n\r\n\r\ncontract FutureBlockCall is FutureCall {\r\n    uint public targetBlock;\r\n    uint8 public gracePeriod;\r\n\r\n    uint constant CALL_API_VERSION = 2;\r\n\r\n    function callAPIVersion() constant returns (uint) {\r\n        return CALL_API_VERSION;\r\n    }\r\n\r\n    function FutureBlockCall(address _schedulerAddress,\r\n                             uint _targetBlock,\r\n                             uint8 _gracePeriod,\r\n                             address _contractAddress,\r\n                             bytes4 _abiSignature,\r\n                             bytes _callData,\r\n                             uint _callValue,\r\n                             uint _requiredGas,\r\n                             uint16 _requiredStackDepth,\r\n                             uint _basePayment,\r\n                             uint _baseDonation)\r\n        FutureCall(_schedulerAddress, _requiredGas, _requiredStackDepth, _contractAddress, _abiSignature, _callData, _callValue, _basePayment, _baseDonation)\r\n    {\r\n        // parent contract FutureCall\r\n        schedulerAddress = _schedulerAddress;\r\n\r\n        targetBlock = _targetBlock;\r\n        gracePeriod = _gracePeriod;\r\n    }\r\n\r\n    uint constant GAS_PER_DEPTH = 700;\r\n\r\n    function __dig(uint n) constant returns (bool) {\r\n        if (n == 0) return true;\r\n        if (!address(this).callcode(bytes4(sha3(\"__dig(uint256)\")), n - 1)) throw;\r\n    }\r\n\r\n\r\n    function beforeExecute(address executor, uint startGas) public returns (bool) {\r\n        return CallLib.beforeExecuteForFutureBlockCall(call, executor, startGas);\r\n    }\r\n\r\n    function afterExecute(address executor) internal {\r\n        // Refund any leftover funds.\r\n        CallLib.sendSafe(schedulerAddress, address(this).balance);\r\n    }\r\n\r\n    uint constant GAS_OVERHEAD = 100000;\r\n\r\n    function getOverhead() constant returns (uint) {\r\n            return GAS_OVERHEAD;\r\n    }\r\n\r\n    uint constant EXTRA_GAS = 77000;\r\n\r\n    function getExtraGas() constant returns (uint) {\r\n            return EXTRA_GAS;\r\n    }\r\n\r\n    uint constant CLAIM_GROWTH_WINDOW = 240;\r\n    uint constant MAXIMUM_CLAIM_WINDOW = 15;\r\n    uint constant BEFORE_CALL_FREEZE_WINDOW = 10;\r\n\r\n    function isCancellable() constant public returns (bool) {\r\n        return CallLib.isCancellable(call, msg.sender);\r\n    }\r\n\r\n    function cancel() public {\r\n        if (CallLib.isCancellable(call, msg.sender)) {\r\n            CallLib.cancel(call, msg.sender);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"CallLib.Call storage\"},{\"name\":\"executor\",\"type\":\"address\"},{\"name\":\"block_number\",\"type\":\"uint256\"}],\"name\":\"checkExecutionAuthorization\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstClaimBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"CallLib.Call storage\"},{\"name\":\"executor\",\"type\":\"address\"},{\"name\":\"deposit_amount\",\"type\":\"uint256\"},{\"name\":\"basePayment\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"checkDepth\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"CallLib.Call storage\"}],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"CallLib.State\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"call\",\"type\":\"CallLib.Call storage\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"extractCallData\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"CallLib.Call storage\"},{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"cancel\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"CallLib.Call storage\"},{\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"isCancellable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"CallLib.Call storage\"},{\"name\":\"executor\",\"type\":\"address\"},{\"name\":\"startGas\",\"type\":\"uint256\"}],\"name\":\"beforeExecuteForFutureBlockCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastClaimBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"base_gas_price\",\"type\":\"uint256\"},{\"name\":\"gas_price\",\"type\":\"uint256\"}],\"name\":\"getGasScalar\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to_address\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"sendSafe\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxClaimBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"CallLib.Call storage\"},{\"name\":\"start_gas\",\"type\":\"uint256\"},{\"name\":\"executor\",\"type\":\"address\"},{\"name\":\"overhead\",\"type\":\"uint256\"},{\"name\":\"extraGas\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"block_number\",\"type\":\"uint256\"}],\"name\":\"getClaimAmountForBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"gasCost\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"donation\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"CallExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reason\",\"type\":\"bytes32\"}],\"name\":\"CallAborted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"cancelled_by\",\"type\":\"address\"}],\"name\":\"Cancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"claimAmount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"}]","ContractName":"CallLib","CompilerVersion":"v0.2.0-nightly.2016.1.13+commit.d2f18c7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"AccountingLib:89efe605e9ecbe22849cd85d5449cc946c26f8f3","SwarmSource":""}]}