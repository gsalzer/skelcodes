{"status":"1","message":"OK","result":[{"SourceCode":"contract Owned {\r\n\r\n    // The address of the account that is the current owner \r\n    address public owner;\r\n\r\n    // The publiser is the inital owner\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Access is restricted to the current owner\r\n     */\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Transfer ownership to `_newOwner`\r\n     *\r\n     * @param _newOwner The address of the account that will become the new owner \r\n     */\r\n    function transferOwnership(address _newOwner) onlyOwner {\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n// Abstract contract for the full ERC 20 Token standard\r\n// https://github.com/ethereum/EIPs/issues/20\r\ncontract Token {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n/**\r\n * Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20\r\n *\r\n * Modified version of https://github.com/ConsenSys/Tokens that implements the \r\n * original Token contract, an abstract contract for the full ERC 20 Token standard\r\n */\r\ncontract StandardToken is Token {\r\n\r\n    // Token starts if the locked state restricting transfers\r\n    bool public locked;\r\n\r\n    // DCORP token balances\r\n    mapping (address => uint256) balances;\r\n\r\n    // DCORP token allowances\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n\r\n    /** \r\n     * Get balance of `_owner` \r\n     * \r\n     * @param _owner The address from which the balance will be retrieved\r\n     * @return The balance\r\n     */\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n\r\n    /** \r\n     * Send `_value` token to `_to` from `msg.sender`\r\n     * \r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n\r\n        // Unable to transfer while still locked\r\n        if (locked) {\r\n            throw;\r\n        }\r\n\r\n        // Check if the sender has enough tokens\r\n        if (balances[msg.sender] < _value) { \r\n            throw;\r\n        }        \r\n\r\n        // Check for overflows\r\n        if (balances[_to] + _value < balances[_to])  { \r\n            throw;\r\n        }\r\n\r\n        // Transfer tokens\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n\r\n        // Notify listners\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    /** \r\n     * Send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n     * \r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n\r\n         // Unable to transfer while still locked\r\n        if (locked) {\r\n            throw;\r\n        }\r\n\r\n        // Check if the sender has enough\r\n        if (balances[_from] < _value) { \r\n            throw;\r\n        }\r\n\r\n        // Check for overflows\r\n        if (balances[_to] + _value < balances[_to]) { \r\n            throw;\r\n        }\r\n\r\n        // Check allowance\r\n        if (_value > allowed[_from][msg.sender]) { \r\n            throw;\r\n        }\r\n\r\n        // Transfer tokens\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n\r\n        // Update allowance\r\n        allowed[_from][msg.sender] -= _value;\r\n\r\n        // Notify listners\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    /** \r\n     * `msg.sender` approves `_spender` to spend `_value` tokens\r\n     * \r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @param _value The amount of tokens to be approved for transfer\r\n     * @return Whether the approval was successful or not\r\n     */\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n\r\n        // Unable to approve while still locked\r\n        if (locked) {\r\n            throw;\r\n        }\r\n\r\n        // Update allowance\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        // Notify listners\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    /** \r\n     * Get the amount of remaining tokens that `_spender` is allowed to spend from `_owner`\r\n     * \r\n     * @param _owner The address of the account owning tokens\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @return Amount of remaining tokens allowed to spent\r\n     */\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\n/**\r\n * @title DRP (DCorp) token\r\n *\r\n * Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20 with the addition \r\n * of ownership, a lock and issuing.\r\n *\r\n * #created 05/03/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract DRPToken is Owned, StandardToken {\r\n\r\n    // Ethereum token standaard\r\n    string public standard = \"Token 0.1\";\r\n\r\n    // Full name\r\n    string public name = \"DCORP\";        \r\n    \r\n    // Symbol\r\n    string public symbol = \"DRP\";\r\n\r\n    // No decimal points\r\n    uint8 public decimals = 2;\r\n\r\n    // Core team insentive distribution\r\n    bool public incentiveDistributionStarted = false;\r\n    uint256 public incentiveDistributionDate = 0;\r\n    uint256 public incentiveDistributionRound = 1;\r\n    uint256 public incentiveDistributionMaxRounds = 3;\r\n    uint256 public incentiveDistributionInterval = 1 years;\r\n    uint256 public incentiveDistributionRoundDenominator = 2;\r\n    \r\n    // Core team incentives\r\n    struct Incentive {\r\n        address recipient;\r\n        uint8 percentage;\r\n    }\r\n\r\n    Incentive[] public incentives;\r\n    \r\n\r\n    /**\r\n     * Starts with a total supply of zero and the creator starts with \r\n     * zero tokens (just like everyone else)\r\n     */\r\n    function DRPToken() {  \r\n        balances[msg.sender] = 0;\r\n        totalSupply = 0;\r\n        locked = true;\r\n\r\n        incentives.push(Incentive(0x3cAf983aCCccc2551195e0809B7824DA6FDe4EC8, 49)); // 0.049 * 10^3 founder\r\n        incentives.push(Incentive(0x11666F3492F03c930682D0a11c93BF708d916ad7, 19)); // 0.019 * 10^3 core angel\r\n        incentives.push(Incentive(0x6c31dE34b5df94F681AFeF9757eC3ed1594F7D9e, 19)); // 0.019 * 10^3 core angel\r\n        incentives.push(Incentive(0x5becE8B6Cb3fB8FAC39a09671a9c32872ACBF267, 9));  // 0.009 * 10^3 core early\r\n        incentives.push(Incentive(0x00DdD4BB955e0C93beF9b9986b5F5F330Fd016c6, 5));  // 0.005 * 10^3 misc\r\n    }\r\n\r\n\r\n    /**\r\n     * Starts incentive distribution \r\n     *\r\n     * Called by the crowdsale contract when tokenholders voted \r\n     * for the transfer of ownership of the token contract to DCorp\r\n     * \r\n     * @return Whether the incentive distribution was started\r\n     */\r\n    function startIncentiveDistribution() onlyOwner returns (bool success) {\r\n        if (!incentiveDistributionStarted) {\r\n            incentiveDistributionDate = now + incentiveDistributionInterval;\r\n            incentiveDistributionStarted = true;\r\n        }\r\n\r\n        return incentiveDistributionStarted;\r\n    }\r\n\r\n\r\n    /**\r\n     * Distributes incentives over the core team members as \r\n     * described in the whitepaper\r\n     */\r\n    function withdrawIncentives() {\r\n\r\n        // Crowdsale triggers incentive distribution\r\n        if (!incentiveDistributionStarted) {\r\n            throw;\r\n        }\r\n\r\n        // Enforce max distribution rounds\r\n        if (incentiveDistributionRound > incentiveDistributionMaxRounds) {\r\n            throw;\r\n        }\r\n\r\n        // Enforce time interval\r\n        if (now < incentiveDistributionDate) {\r\n            throw;\r\n        }\r\n\r\n        uint256 totalSupplyToDate = totalSupply;\r\n        uint256 denominator = 1;\r\n\r\n        // Incentive decreased each round\r\n        if (incentiveDistributionRound > 1) {\r\n            denominator = incentiveDistributionRoundDenominator**(incentiveDistributionRound - 1);\r\n        }\r\n\r\n        for (uint256 i = 0; i < incentives.length; i++) {\r\n\r\n            // totalSupplyToDate * (percentage * 10^3) / 10^3 / denominator\r\n            uint256 amount = totalSupplyToDate * incentives[i].percentage / 10**3 / denominator; \r\n            address recipient =  incentives[i].recipient;\r\n\r\n            // Create tokens\r\n            balances[recipient] += amount;\r\n            totalSupply += amount;\r\n\r\n            // Notify listners\r\n            Transfer(0, this, amount);\r\n            Transfer(this, recipient, amount);\r\n        }\r\n\r\n        // Next round\r\n        incentiveDistributionDate = now + incentiveDistributionInterval;\r\n        incentiveDistributionRound++;\r\n    }\r\n\r\n\r\n    /**\r\n     * Unlocks the token irreversibly so that the transfering of value is enabled \r\n     *\r\n     * @return Whether the unlocking was successful or not\r\n     */\r\n    function unlock() onlyOwner returns (bool success)  {\r\n        locked = false;\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Issues `_value` new tokens to `_recipient` (_value < 0 guarantees that tokens are never removed)\r\n     *\r\n     * @param _recipient The address to which the tokens will be issued\r\n     * @param _value The amount of new tokens to issue\r\n     * @return Whether the approval was successful or not\r\n     */\r\n    function issue(address _recipient, uint256 _value) onlyOwner returns (bool success) {\r\n\r\n        // Guarantee positive \r\n        if (_value < 0) {\r\n            throw;\r\n        }\r\n\r\n        // Create tokens\r\n        balances[_recipient] += _value;\r\n        totalSupply += _value;\r\n\r\n        // Notify listners\r\n        Transfer(0, owner, _value);\r\n        Transfer(owner, _recipient, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Prevents accidental sending of ether\r\n     */\r\n    function () {\r\n        throw;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"incentiveDistributionStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"incentiveDistributionRoundDenominator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startIncentiveDistribution\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"incentiveDistributionRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"incentiveDistributionInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"issue\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"incentiveDistributionMaxRounds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawIncentives\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"incentives\",\"outputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"percentage\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"incentiveDistributionDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"DRPToken","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://fafcb99e0596804b96d5d31e2acdc576a21fac7b0a0d5f4d3d00d31921fcacfd"}]}