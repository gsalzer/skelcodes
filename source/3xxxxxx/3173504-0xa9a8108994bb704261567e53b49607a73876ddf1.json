{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.2;\r\n\r\n/*\r\n*  @notice the token contract used as reward \r\n*/\r\ncontract token {\r\n\r\n    /*\r\n    *  @notice exposes the transfer method of the token contract\r\n    *  @param _receiver address receiving tokens\r\n    *  @param _amount number of tokens being transferred       \r\n    */    \r\n    function transfer(address _receiver, uint _amount) returns (bool success) { }\r\n\r\n    /*\r\n    *  @notice exposes the priviledgedAddressBurnUnsoldCoins method of the token contract\r\n    *  burns all unsold coins  \r\n    */     \r\n    function priviledgedAddressBurnUnsoldCoins(){ }\r\n\r\n}\r\n\r\n/*\r\n`* is owned\r\n*/\r\ncontract owned {\r\n\r\n    address public owner;\r\n\r\n    function owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n\r\n    function ownerTransferOwnership(address newOwner)\r\n        onlyOwner\r\n    {\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n/*\r\n* safe math\r\n*/\r\ncontract DSSafeAddSub {\r\n\r\n    function safeToAdd(uint a, uint b) internal returns (bool) {\r\n        return (a + b >= a);\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal returns (uint) {\r\n        if (!safeToAdd(a, b)) throw;\r\n        return a + b;\r\n    }\r\n\r\n    function safeToSubtract(uint a, uint b) internal returns (bool) {\r\n        return (b <= a);\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal returns (uint) {\r\n        if (!safeToSubtract(a, b)) throw;\r\n        return a - b;\r\n    } \r\n\r\n}\r\n\r\n/* \r\n*  EtherollCrowdfund contract\r\n*  Funds sent to this address transfer a customized ERC20 token to msg.sender for the duration of the crowdfund\r\n*  Deployment order:\r\n*  EtherollToken, EtherollCrowdfund\r\n*  1) Send tokens to this\r\n*  2) Assign this as priviledgedAddress in EtherollToken\r\n*  3) Call updateTokenStatus in EtherollToken \r\n*  -- crowdfund is open --\r\n*  4) safeWithdraw onlyAfterDeadline in this\r\n*  5) ownerBurnUnsoldTokens onlyAfterDeadline in this\r\n*  6) updateTokenStatus in EtherollToken freezes/thaws tokens\r\n*/\r\ncontract EtherollCrowdfund is owned, DSSafeAddSub {\r\n\r\n    /*\r\n    *  checks only after crowdfund deadline\r\n    */    \r\n    modifier onlyAfterDeadline() { \r\n        if (now < deadline) throw;\r\n        _; \r\n    }\r\n\r\n    /*\r\n    *  checks only in emergency\r\n    */    \r\n    modifier isEmergency() { \r\n        if (!emergency) throw;\r\n        _; \r\n    } \r\n\r\n    /* the crowdfund goal */\r\n    uint public fundingGoal;\r\n    /* 1 week countdown to price increase */\r\n    uint public weekTwoPriceRiseBegin = now + 10080 * 1 minutes;    \r\n    /* 80% to standard multi-sig wallet contract is house bankroll  */\r\n    address public bankRollBeneficiary;      \r\n    /* 20% to etheroll wallet*/\r\n    address public etherollBeneficiary;         \r\n    /* total amount of ether raised */\r\n    uint public amountRaised;\r\n    /* two weeks */\r\n    uint public deadline;\r\n    /* 0.01 ETH per token base price */\r\n    uint public price = 10000000000000000;\r\n    /* address of token used as reward */\r\n    token public tokenReward;\r\n    /* crowdsale is open */\r\n    bool public crowdsaleClosed = false;  \r\n    /* 80% of funds raised */\r\n    uint public bankrollBeneficiaryAmount;\r\n    /* 20% of funds raised */    \r\n    uint public etherollBeneficiaryAmount;\r\n    /* map balance of address */\r\n    mapping (address => uint) public balanceOf; \r\n    /* funding goal has not been reached */ \r\n    bool public fundingGoalReached = false;   \r\n    /* escape hatch for all in emergency */\r\n    bool public emergency = false; \r\n\r\n    /* log events */\r\n    event LogFundTransfer(address indexed Backer, uint indexed Amount, bool indexed IsContribution);  \r\n    event LogGoalReached(address indexed Beneficiary, uint indexed AmountRaised);       \r\n\r\n    /*\r\n    *  @param _ifSuccessfulSendToBeneficiary receives 80% of ether raised end of crowdfund\r\n    *  @param _ifSuccessfulSendToEtheroll receives 20% of ether raised end of crowdfund\r\n    *  @param _fundingGoalInEthers the funding goal of the crowdfund\r\n    *  @param _durationInMinutes the length of the crowdfund in minutes\r\n    *  @param _addressOfTokenUsedAsReward the token address   \r\n    */  \r\n    function EtherollCrowdfund(\r\n        /* multi-sig address to send 80% */        \r\n        address _ifSuccessfulSendToBeneficiary,\r\n        /* address to send 20% */\r\n        address _ifSuccessfulSendToEtheroll,\r\n        /* funding goal */\r\n        uint _fundingGoalInEthers,\r\n        /* two weeks: 20160 minutes*/\r\n        uint _durationInMinutes,\r\n        /* token */\r\n        token _addressOfTokenUsedAsReward\r\n    ) {\r\n        bankRollBeneficiary = _ifSuccessfulSendToBeneficiary;\r\n        etherollBeneficiary = _ifSuccessfulSendToEtheroll;\r\n        fundingGoal = _fundingGoalInEthers * 1 ether;\r\n        deadline = now + _durationInMinutes * 1 minutes;\r\n        tokenReward = token(_addressOfTokenUsedAsReward);\r\n    }\r\n  \r\n    /*\r\n    *  @notice public function\r\n    *  default function is payable\r\n    *  responsible for transfer of tokens based on price, msg.sender and msg.value\r\n    *  tracks investment total of msg.sender \r\n    *  refunds any spare change\r\n    */      \r\n    function ()\r\n        payable\r\n    {\r\n\r\n        /* crowdfund period is over */\r\n        if(now > deadline) crowdsaleClosed = true;  \r\n\r\n        /* crowdsale is closed */\r\n        if (crowdsaleClosed) throw;\r\n\r\n        /* do not allow creating 0 */        \r\n        if (msg.value == 0) throw;      \r\n\r\n        /* \r\n        *  transfer tokens\r\n        *  check/set week two price rise\r\n        */\r\n        if(now < weekTwoPriceRiseBegin) {\r\n                      \r\n            /* week 1 power token conversion * 2: 1 ETH = 200 tokens */\r\n            if(tokenReward.transfer(msg.sender, ((msg.value*price)/price)*2)) {\r\n                LogFundTransfer(msg.sender, msg.value, true); \r\n            } else {\r\n                throw;\r\n            }\r\n\r\n        }else{\r\n            /* week 2 conversion: 1 ETH = 100 tokens */\r\n            if(tokenReward.transfer(msg.sender, (msg.value*price)/price)) {\r\n                LogFundTransfer(msg.sender, msg.value, true); \r\n            } else {\r\n                throw;\r\n            }            \r\n\r\n        } \r\n\r\n        /* add to amountRaised */\r\n        amountRaised = safeAdd(amountRaised, msg.value);          \r\n\r\n        /* track ETH balanceOf address in case emergency refund is required */  \r\n        balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender], msg.value);\r\n\r\n    }    \r\n\r\n    /*\r\n    *  @notice public function\r\n    *  onlyAfterDeadline\r\n    *  moves ether to beneficiary contracts if goal reached\r\n    *  if goal not reached msg.sender can withdraw their deposit\r\n    */     \r\n    function safeWithdraw() public\r\n        onlyAfterDeadline\r\n    {\r\n\r\n        if (amountRaised >= fundingGoal){\r\n            /* allows funds to be moved to beneficiary */\r\n            fundingGoalReached = true;\r\n            /* log event */            \r\n            LogGoalReached(bankRollBeneficiary, amountRaised);           \r\n        }    \r\n            \r\n        /* close crowdsale */\r\n        crowdsaleClosed = true;  \r\n                        \r\n        /* \r\n        *  public \r\n        *  funding goal not reached \r\n        *  manual refunds\r\n        */\r\n        if (!fundingGoalReached) {\r\n            calcRefund(msg.sender);\r\n        }\r\n        \r\n        /* \r\n        *  onlyOwner can call\r\n        *  funding goal reached \r\n        *  move funds to beneficiary addresses\r\n        */        \r\n        if (msg.sender == owner && fundingGoalReached) {\r\n\r\n            /* multi-sig bankrollBeneficiary receives 80% */\r\n            bankrollBeneficiaryAmount = (this.balance*80)/100;   \r\n\r\n            /* send to trusted address bankRollBeneficiary 80% */      \r\n            if (bankRollBeneficiary.send(bankrollBeneficiaryAmount)) {  \r\n\r\n                /* log event */              \r\n                LogFundTransfer(bankRollBeneficiary, bankrollBeneficiaryAmount, false);\r\n            \r\n                /* etherollBeneficiary receives remainder */\r\n                etherollBeneficiaryAmount = this.balance;                  \r\n\r\n                /* send to trusted address etherollBeneficiary the remainder */\r\n                if(!etherollBeneficiary.send(etherollBeneficiaryAmount)) throw;\r\n\r\n                /* log event */        \r\n                LogFundTransfer(etherollBeneficiary, etherollBeneficiaryAmount, false);                 \r\n\r\n            } else {\r\n\r\n                /* allow manual refunds via safeWithdrawal */\r\n                fundingGoalReached = false;\r\n\r\n            }\r\n        }\r\n    }  \r\n\r\n    /*\r\n    *  @notice internal function\r\n    *  @param _addressToRefund the address being refunded\r\n    *  accessed via public functions emergencyWithdraw and safeWithdraw\r\n    *  calculates refund amount available for an address  \r\n    */     \r\n    function calcRefund(address _addressToRefund) internal\r\n    {\r\n        /* assigns var amount to balance of _addressToRefund */\r\n        uint amount = balanceOf[_addressToRefund];\r\n        /* sets balance to 0 */\r\n        balanceOf[_addressToRefund] = 0;\r\n        /* is there any balance? */\r\n        if (amount > 0) {\r\n            /* call to untrusted address */\r\n            if (_addressToRefund.call.value(amount)()) {\r\n                /* log event */\r\n                LogFundTransfer(_addressToRefund, amount, false);\r\n            } else {\r\n                /* unsuccessful send so reset the balance */\r\n                balanceOf[_addressToRefund] = amount;\r\n            }\r\n        } \r\n    }     \r\n   \r\n\r\n    /*\r\n    *  @notice public function\r\n    *  emergency manual refunds\r\n    */     \r\n    function emergencyWithdraw() public\r\n        isEmergency    \r\n    {\r\n        /* manual refunds */\r\n        calcRefund(msg.sender);\r\n    }        \r\n\r\n    /*\r\n    *  @notice owner restricted function   \r\n    *  @param _newEmergencyStatus boolean\r\n    *  sets contract mode to emergency status to allow individual withdraw via emergencyWithdraw()\r\n    */    \r\n    function ownerSetEmergencyStatus(bool _newEmergencyStatus) public\r\n        onlyOwner \r\n    {        \r\n        /* close crowdsale */\r\n        crowdsaleClosed = _newEmergencyStatus;\r\n        /* allow manual refunds via emergencyWithdraw */\r\n        emergency = _newEmergencyStatus;        \r\n    } \r\n\r\n    /*\r\n    *  @notice  owner restricted function \r\n    *  burns any unsold tokens at end of crowdfund\r\n    */      \r\n    function ownerBurnUnsoldTokens()\r\n        onlyOwner\r\n        onlyAfterDeadline\r\n    {\r\n        tokenReward.priviledgedAddressBurnUnsoldCoins();\r\n    }         \r\n\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"ownerBurnUnsoldTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherollBeneficiaryAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenReward\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"safeWithdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bankRollBeneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newEmergencyStatus\",\"type\":\"bool\"}],\"name\":\"ownerSetEmergencyStatus\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ownerTransferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weekTwoPriceRiseBegin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"emergency\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bankrollBeneficiaryAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingGoalReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherollBeneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ifSuccessfulSendToBeneficiary\",\"type\":\"address\"},{\"name\":\"_ifSuccessfulSendToEtheroll\",\"type\":\"address\"},{\"name\":\"_fundingGoalInEthers\",\"type\":\"uint256\"},{\"name\":\"_durationInMinutes\",\"type\":\"uint256\"},{\"name\":\"_addressOfTokenUsedAsReward\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"Backer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"Amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"IsContribution\",\"type\":\"bool\"}],\"name\":\"LogFundTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"Beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"AmountRaised\",\"type\":\"uint256\"}],\"name\":\"LogGoalReached\",\"type\":\"event\"}]","ContractName":"EtherollCrowdfund","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000024c3235558572cff8054b5a419251d3b0d43e91b000000000000000000000000a86a60d53e6f474e049be54824551bb99f05adee0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000c5a1443d41ea9a694a8ebd999b9bced08cf4ca90","Library":"","SwarmSource":"bzzr://840db9a355204fd8e6b3a2d0eb20d46031e2bf0e99f97799478d259bee688221"}]}