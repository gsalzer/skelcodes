{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n// version (LAVA-Q)\r\ncontract E4RowEscrow {\r\n\r\nevent StatEvent(string msg);\r\nevent StatEventI(string msg, uint val);\r\nevent StatEventA(string msg, address addr);\r\n\r\n        uint constant MAX_PLAYERS = 5;\r\n\r\n        enum EndReason  {erWinner, erTimeOut, erCancel}\r\n        enum SettingStateValue  {debug, release, lockedRelease}\r\n\r\n        struct gameInstance {\r\n                bool active;           // active\r\n                bool allocd;           // allocated already. \r\n                EndReason reasonEnded; // enum reason of ended\r\n                uint8 numPlayers;\r\n                uint128 totalPot;      // total of all bets\r\n                uint128[5] playerPots; // individual deposits\r\n                address[5] players;    // player addrs\r\n                uint lastMoved;        // time game last moved\r\n        }\r\n\r\n        struct arbiter {\r\n                mapping (uint => uint)  gameIndexes; // game handles\r\n                bool registered; \r\n                bool locked;\r\n                uint8 numPlayers;\r\n                uint16 arbToken;         // 2 bytes\r\n                uint16 escFeePctX10;     // escrow fee -- frac of 1000\r\n                uint16 arbFeePctX10;     // arbiter fee -- frac of 1000\r\n                uint32 gameSlots;        // a counter of alloc'd game structs (they can be reused)\r\n                uint128 feeCap;          // max fee (escrow + arb) in wei\r\n                uint128 arbHoldover;     // hold accumulated gas credits and arbiter fees\r\n        }\r\n\r\n\r\n        address public  owner;  // owner is address that deployed contract\r\n        address public  tokenPartner;   // the address of partner that receives rake fees\r\n        uint public numArbiters;        // number of arbiters\r\n\r\n        int numGamesStarted;    // total stats from all arbiters\r\n\r\n        uint public numGamesCompleted; // ...\r\n        uint public numGamesCanceled;   // tied and canceled\r\n        uint public numGamesTimedOut;   // ...\r\n        uint public houseFeeHoldover;   // hold fee till threshold\r\n        uint public lastPayoutTime;     // timestamp of last payout time\r\n\r\n        // configurables\r\n        uint public gameTimeOut;\r\n        uint public registrationFee;\r\n        uint public houseFeeThreshold;\r\n        uint public payoutInterval;\r\n\r\n        uint acctCallGas;  // for payments to simple accts\r\n        uint tokCallGas;   // for calling token contract. eg fee payout\r\n        uint public startGameGas; // gas consumed by startGame\r\n        uint public winnerDecidedGas; // gas consumed by winnerDecided\r\n\r\n        SettingStateValue public settingsState = SettingStateValue.debug; \r\n\r\n\r\n        mapping (address => arbiter)  arbiters;\r\n        mapping (uint => address)  arbiterTokens;\r\n        mapping (uint => address)  arbiterIndexes;\r\n        mapping (uint => gameInstance)  games;\r\n\r\n\r\n        function E4RowEscrow() public\r\n        {\r\n                owner = msg.sender;\r\n        }\r\n\r\n\r\n        function applySettings(SettingStateValue _state, uint _fee, uint _threshold, uint _timeout, uint _interval, uint _startGameGas, uint _winnerDecidedGas)\r\n        {\r\n                if (msg.sender != owner) \r\n                        throw;\r\n\r\n                // ----------------------------------------------\r\n                // these items are tweakable for game optimization\r\n                // ----------------------------------------------\r\n                houseFeeThreshold = _threshold;\r\n                gameTimeOut = _timeout;\r\n                payoutInterval = _interval;\r\n\r\n                if (settingsState == SettingStateValue.lockedRelease) {\r\n                        StatEvent(\"Settings Tweaked\");\r\n                        return;\r\n                }\r\n\r\n                settingsState = _state;\r\n                registrationFee = _fee;\r\n\r\n                // set default op gas -  any futher settings done in set up gas\r\n                acctCallGas = 21000; \r\n                tokCallGas = 360000;\r\n\r\n                // set gas consumption - these should never change (except gas price)\r\n                startGameGas = _startGameGas;\r\n                winnerDecidedGas = _winnerDecidedGas;\r\n                StatEvent(\"Settings Changed\");\r\n\r\n        }\r\n\r\n\r\n        //-----------------------------\r\n        // return an arbiter token from an hGame\r\n        //-----------------------------\r\n        function ArbTokFromHGame(uint _hGame) returns (uint _tok)\r\n        { \r\n                _tok =  (_hGame / (2 ** 48)) & 0xffff;\r\n        }\r\n\r\n\r\n        //-----------------------------\r\n        // suicide the contract, not called for release\r\n        //-----------------------------\r\n        function HaraKiri()\r\n        {\r\n                if ((msg.sender == owner) && (settingsState != SettingStateValue.lockedRelease))\r\n                          suicide(tokenPartner);\r\n                else\r\n                        StatEvent(\"Kill attempt failed\");\r\n        }\r\n\r\n\r\n        //-----------------------------\r\n        // default function\r\n        // who are we to look a gift-horse in the mouth?\r\n        //-----------------------------\r\n        function() payable  {\r\n                StatEvent(\"thanks!\");\r\n                houseFeeHoldover += msg.value;\r\n        }\r\n        function blackHole() payable  {\r\n                StatEvent(\"thanks!#2\");\r\n        }\r\n\r\n        //------------------------------------------------------\r\n        // check active game and valid player, return player index\r\n        //-------------------------------------------------------\r\n        function validPlayer(uint _hGame, address _addr)  internal returns( bool _valid, uint _pidx)\r\n        {\r\n                _valid = false;\r\n\r\n                if (activeGame(_hGame)) {\r\n                        for (uint i = 0; i < games[_hGame].numPlayers; i++) {\r\n                                if (games[_hGame].players[i] == _addr) {\r\n                                        _valid=true;\r\n                                        _pidx = i;\r\n                                        break;\r\n                                }\r\n                        }\r\n                }\r\n        }\r\n\r\n\r\n        //------------------------------------------------------\r\n        // check the arbiter is valid by comparing token\r\n        //------------------------------------------------------\r\n        function validArb(address _addr, uint _tok) internal  returns( bool _valid)\r\n        {\r\n                _valid = false;\r\n\r\n                if ((arbiters[_addr].registered)\r\n                        && (arbiters[_addr].arbToken == _tok)) \r\n                        _valid = true;\r\n        }\r\n\r\n        //------------------------------------------------------\r\n        // check the arbiter is valid without comparing token\r\n        //------------------------------------------------------\r\n        function validArb2(address _addr) internal  returns( bool _valid)\r\n        {\r\n                _valid = false;\r\n                if (arbiters[_addr].registered)\r\n                        _valid = true;\r\n        }\r\n\r\n        //------------------------------------------------------\r\n        // check if arbiter is locked out\r\n        //------------------------------------------------------\r\n        function arbLocked(address _addr) internal  returns( bool _locked)\r\n        {\r\n                _locked = false;\r\n                if (validArb2(_addr)) \r\n                        _locked = arbiters[_addr].locked;\r\n        }\r\n\r\n        //------------------------------------------------------\r\n        // return if game is active\r\n        //------------------------------------------------------\r\n        function activeGame(uint _hGame) internal  returns( bool _valid)\r\n        {\r\n                _valid = false;\r\n                if ((_hGame > 0)\r\n                        && (games[_hGame].active))\r\n                        _valid = true;\r\n        }\r\n\r\n\r\n        //------------------------------------------------------\r\n        // register game arbiter, max players of 5, pass in exact registration fee\r\n        //------------------------------------------------------\r\n        function registerArbiter(uint _numPlayers, uint _arbToken, uint _escFeePctX10, uint _arbFeePctX10, uint _feeCap) public payable \r\n        {\r\n\r\n                if (msg.value != registrationFee) {\r\n                        throw;  //Insufficient Fee\r\n                }\r\n\r\n                if (_arbToken == 0) {\r\n                        throw; // invalid token\r\n                }\r\n\r\n                if (arbTokenExists(_arbToken & 0xffff)) {\r\n                        throw; // Token Already Exists\r\n                }\r\n\r\n                if (arbiters[msg.sender].registered) {\r\n                        throw; // Arb Already Registered\r\n                }\r\n\r\n                if (_numPlayers > MAX_PLAYERS) {\r\n                        throw; // Exceeds Max Players\r\n                }\r\n\r\n                if (_escFeePctX10 < 20) {\r\n                        throw; // less than 2% min escrow fee\r\n                }\r\n\r\n                if (_arbFeePctX10 > 10) {\r\n                        throw; // more than than 1% max arbiter fee\r\n                }\r\n\r\n                arbiters[msg.sender].locked = false;\r\n                arbiters[msg.sender].numPlayers = uint8(_numPlayers);\r\n                arbiters[msg.sender].escFeePctX10 = uint8(_escFeePctX10);\r\n                arbiters[msg.sender].arbFeePctX10 = uint8(_arbFeePctX10);\r\n                arbiters[msg.sender].arbToken = uint16(_arbToken & 0xffff);\r\n                arbiters[msg.sender].feeCap = uint128(_feeCap);\r\n                arbiters[msg.sender].registered = true;\r\n\r\n                arbiterTokens[(_arbToken & 0xffff)] = msg.sender;\r\n                arbiterIndexes[numArbiters++] = msg.sender;\r\n\r\n                if (tokenPartner != address(0)) {\r\n                        if (!tokenPartner.call.gas(tokCallGas).value(msg.value)()) {\r\n                                //Statvent(\"Send Error\"); // event never registers\r\n                                throw;\r\n                        }\r\n                } else {\r\n                        houseFeeHoldover += msg.value;\r\n                }\r\n                StatEventI(\"Arb Added\", _arbToken);\r\n        }\r\n\r\n\r\n        //------------------------------------------------------\r\n        // start game.  pass in valid hGame containing token in top two bytes\r\n        //------------------------------------------------------\r\n        function startGame(uint _hGame, int _hkMax, address[] _players) public \r\n\r\n        {\r\n                uint ntok = ArbTokFromHGame(_hGame);\r\n                if (!validArb(msg.sender, ntok )) {\r\n                        StatEvent(\"Invalid Arb\");\r\n                        return;\r\n                }\r\n\r\n\r\n                if (arbLocked(msg.sender)) {\r\n                        StatEvent(\"Arb Locked\");\r\n                        return; \r\n                }\r\n\r\n                arbiter xarb = arbiters[msg.sender];\r\n                if (_players.length != xarb.numPlayers) { \r\n                        StatEvent(\"Incorrect num players\");\r\n                        return; \r\n                }\r\n\r\n                gameInstance xgame = games[_hGame];\r\n                if (xgame.active) {\r\n                        // guard-rail. just in case to return funds\r\n                        abortGame(_hGame, EndReason.erCancel);\r\n\r\n                } else if (_hkMax > 0) {\r\n                        houseKeep(_hkMax, ntok); \r\n                }\r\n\r\n                if (!xgame.allocd) {\r\n                        xgame.allocd = true;\r\n                        xarb.gameIndexes[xarb.gameSlots++] = _hGame;\r\n                } \r\n                numGamesStarted++; // always inc this one\r\n\r\n                xgame.active = true;\r\n                xgame.lastMoved = now;\r\n                xgame.totalPot = 0;\r\n                xgame.numPlayers = xarb.numPlayers;\r\n                for (uint i = 0; i < _players.length; i++) {\r\n                        xgame.players[i] = _players[i];\r\n                        xgame.playerPots[i] = 0;\r\n                }\r\n                //StatEventI(\"Game Added\", _hGame);\r\n        }\r\n\r\n        //------------------------------------------------------\r\n        // clean up game, set to inactive, refund any balances\r\n        // called by housekeep ONLY\r\n        //------------------------------------------------------\r\n        function abortGame(uint  _hGame, EndReason _reason) private returns(bool _success)\r\n        {\r\n                gameInstance xgame = games[_hGame];\r\n             \r\n                // find game in game id, \r\n                if (xgame.active) {\r\n                        _success = true;\r\n                        for (uint i = 0; i < xgame.numPlayers; i++) {\r\n                                if (xgame.playerPots[i] > 0) {\r\n                                        address a = xgame.players[i];\r\n                                        uint nsend = xgame.playerPots[i];\r\n                                        xgame.playerPots[i] = 0;\r\n                                        if (!a.call.gas(acctCallGas).value(nsend)()) {\r\n                                                houseFeeHoldover += nsend; // cannot refund due to error, give to the house\r\n                                                StatEventA(\"Cannot Refund Address\", a);\r\n                                        }\r\n                                }\r\n                        }\r\n                        xgame.active = false;\r\n                        xgame.reasonEnded = _reason;\r\n                        if (_reason == EndReason.erCancel) {\r\n                                numGamesCanceled++;\r\n                                StatEvent(\"Game canceled\");\r\n                        } else if (_reason == EndReason.erTimeOut) {\r\n                                numGamesTimedOut++;\r\n                                StatEvent(\"Game timed out\");\r\n                        } else \r\n                                StatEvent(\"Game aborted\");\r\n                }\r\n        }\r\n\r\n\r\n        //------------------------------------------------------\r\n        // called by arbiter when winner is decided\r\n        // *pass in high num for winnerbal for tie games\r\n        //------------------------------------------------------\r\n        function winnerDecided(uint _hGame, address _winner, uint _winnerBal) public\r\n        {\r\n                if (!validArb(msg.sender, ArbTokFromHGame(_hGame))) {\r\n                        StatEvent(\"Invalid Arb\");\r\n                        return; // no throw no change made\r\n                }\r\n\r\n                var (valid, pidx) = validPlayer(_hGame, _winner);\r\n                if (!valid) {\r\n                        StatEvent(\"Invalid Player\");\r\n                        return;\r\n                }\r\n\r\n                arbiter xarb = arbiters[msg.sender];\r\n                gameInstance xgame = games[_hGame];\r\n\r\n                if (xgame.playerPots[pidx] < _winnerBal) {\r\n                    abortGame(_hGame, EndReason.erCancel);\r\n                    return;\r\n                }\r\n\r\n                xgame.active = false;\r\n                xgame.reasonEnded = EndReason.erWinner;\r\n                numGamesCompleted++;\r\n\r\n                if (xgame.totalPot > 0) {\r\n                        // calc payouts: escrowFee, arbiterFee, gasCost, winner payout\r\n                        uint _escrowFee = (xgame.totalPot * xarb.escFeePctX10) / 1000;\r\n                        uint _arbiterFee = (xgame.totalPot * xarb.arbFeePctX10) / 1000;\r\n                        if ((_escrowFee + _arbiterFee) > xarb.feeCap) {\r\n                                _escrowFee = xarb.feeCap * xarb.escFeePctX10 / (xarb.escFeePctX10 + xarb.arbFeePctX10);\r\n                                _arbiterFee = xarb.feeCap * xarb.arbFeePctX10 / (xarb.escFeePctX10 + xarb.arbFeePctX10);\r\n                        }\r\n                        uint _payout = xgame.totalPot - (_escrowFee + _arbiterFee);\r\n                        uint _gasCost = tx.gasprice * (startGameGas + winnerDecidedGas);\r\n                        if (_gasCost > _payout)\r\n                                _gasCost = _payout;\r\n                        _payout -= _gasCost;\r\n\r\n                        // do payouts\r\n                        xarb.arbHoldover += uint128(_arbiterFee + _gasCost);\r\n                        houseFeeHoldover += _escrowFee;\r\n\r\n                        if ((houseFeeHoldover > houseFeeThreshold)\r\n                            && (now > (lastPayoutTime + payoutInterval))) {\r\n                                uint ntmpho = houseFeeHoldover;\r\n                                houseFeeHoldover = 0;\r\n                                lastPayoutTime = now; // reset regardless of succeed/fail\r\n                                if (!tokenPartner.call.gas(tokCallGas).value(ntmpho)()) {\r\n                                        houseFeeHoldover = ntmpho; // put it back\r\n                                        StatEvent(\"House-Fee Error1\");\r\n                                } \r\n                        }\r\n\r\n                        if (_payout > 0) {\r\n                                if (!_winner.call.gas(acctCallGas).value(uint(_payout))()) {\r\n                                        // if you cant pay the winner - very bad\r\n                                        // StatEvent(\"Send Error\");\r\n                                        // add funds to houseFeeHoldover to avoid acounting errs\r\n                                        //throw;\r\n                                        houseFeeHoldover += _payout;\r\n                                        StatEventI(\"Payout Error!\", _hGame);\r\n                                } else {\r\n                                        //StatEventI(\"Winner Paid\", _hGame);\r\n                                }\r\n                        }\r\n                }\r\n        }\r\n\r\n\r\n        //------------------------------------------------------\r\n        // handle a bet made by a player, validate the player and game\r\n        // add to players balance\r\n        //------------------------------------------------------\r\n        function handleBet(uint _hGame) public payable \r\n        {\r\n                address _arbAddr = arbiterTokens[ArbTokFromHGame(_hGame)];\r\n                if (_arbAddr == address(0)) {\r\n                        throw; // \"Invalid hGame\"\r\n                }\r\n\r\n                var (valid, pidx) = validPlayer(_hGame, msg.sender);\r\n                if (!valid) {\r\n                        throw; // \"Invalid Player\"\r\n                }\r\n\r\n                gameInstance xgame = games[_hGame];\r\n                xgame.playerPots[pidx] += uint128(msg.value);\r\n                xgame.totalPot += uint128(msg.value);\r\n                //StatEventI(\"Bet Added\", _hGame);\r\n        }\r\n\r\n\r\n        //------------------------------------------------------\r\n        // return if arb token exists\r\n        //------------------------------------------------------\r\n        function arbTokenExists(uint _tok) constant returns (bool _exists)\r\n        {\r\n                _exists = false;\r\n                if ((_tok > 0)\r\n                        && (arbiterTokens[_tok] != address(0))\r\n                        && arbiters[arbiterTokens[_tok]].registered)\r\n                        _exists = true;\r\n\r\n        }\r\n\r\n\r\n        //------------------------------------------------------\r\n        // return arbiter game stats\r\n        //------------------------------------------------------\r\n        function getArbInfo(uint _tok) constant  returns (address _addr, uint _escFeePctX10, uint _arbFeePctX10, uint _feeCap, uint _holdOver) \r\n        {\r\n                // if (arbiterTokens[_tok] != address(0)) {\r\n                        _addr = arbiterTokens[_tok]; \r\n                         arbiter xarb = arbiters[arbiterTokens[_tok]];\r\n                        _escFeePctX10 = xarb.escFeePctX10;\r\n                        _arbFeePctX10 = xarb.arbFeePctX10;\r\n                        _feeCap = xarb.feeCap;\r\n                        _holdOver = xarb.arbHoldover; \r\n                // }\r\n        }\r\n\r\n        //------------------------------------------------------\r\n        // scan for a game 10 minutes old\r\n        // if found abort the game, causing funds to be returned\r\n        //------------------------------------------------------\r\n        function houseKeep(int _max, uint _arbToken) public\r\n        {\r\n                uint gi;\r\n                address a;\r\n                int aborted = 0;\r\n\r\n                arbiter xarb = arbiters[msg.sender];// have to set it to something\r\n                \r\n         \r\n                if (msg.sender == owner) {\r\n                        for (uint ar = 0; (ar < numArbiters) && (aborted < _max) ; ar++) {\r\n                            a = arbiterIndexes[ar];\r\n                            xarb = arbiters[a];    \r\n\r\n                            for ( gi = 0; (gi < xarb.gameSlots) && (aborted < _max); gi++) {\r\n                                gameInstance ngame0 = games[xarb.gameIndexes[gi]];\r\n                                if ((ngame0.active)\r\n                                    && ((now - ngame0.lastMoved) > gameTimeOut)) {\r\n                                        abortGame(xarb.gameIndexes[gi], EndReason.erTimeOut);\r\n                                        ++aborted;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                } else {\r\n                        if (!validArb(msg.sender, _arbToken))\r\n                                StatEvent(\"Housekeep invalid arbiter\");\r\n                        else {\r\n                            a = msg.sender;\r\n                            xarb = arbiters[a];    \r\n                            for (gi = 0; (gi < xarb.gameSlots) && (aborted < _max); gi++) {\r\n                                gameInstance ngame1 = games[xarb.gameIndexes[gi]];\r\n                                if ((ngame1.active)\r\n                                    && ((now - ngame1.lastMoved) > gameTimeOut)) {\r\n                                        abortGame(xarb.gameIndexes[gi], EndReason.erTimeOut);\r\n                                        ++aborted;\r\n                                }\r\n                            }\r\n\r\n                        }\r\n                }\r\n        }\r\n\r\n\r\n        //------------------------------------------------------\r\n        // return game info\r\n        //------------------------------------------------------\r\n        function getGameInfo(uint _hGame)  constant  returns (EndReason _reason, uint _players, uint _totalPot, bool _active)\r\n        {\r\n                gameInstance xgame = games[_hGame];\r\n                _active = xgame.active;\r\n                _players = xgame.numPlayers;\r\n                _totalPot = xgame.totalPot;\r\n                _reason = xgame.reasonEnded;\r\n\r\n        }\r\n\r\n        //------------------------------------------------------\r\n        // return arbToken and low bytes from an HGame\r\n        //------------------------------------------------------\r\n        function checkHGame(uint _hGame) constant returns(uint _arbTok, uint _lowWords)\r\n        {\r\n                _arbTok = ArbTokFromHGame(_hGame);\r\n                _lowWords = _hGame & 0xffffffffffff;\r\n\r\n        }\r\n\r\n        //------------------------------------------------------\r\n        // get operation gas amounts\r\n        //------------------------------------------------------\r\n        function getOpGas() constant returns (uint _ag, uint _tg) \r\n        {\r\n                _ag = acctCallGas; // winner paid\r\n                _tg = tokCallGas;     // token contract call gas\r\n        }\r\n\r\n\r\n        //------------------------------------------------------\r\n        // set operation gas amounts for forwading operations\r\n        //------------------------------------------------------\r\n        function setOpGas(uint _ag, uint _tg) \r\n        {\r\n                if (msg.sender != owner)\r\n                        throw;\r\n\r\n                acctCallGas = _ag;\r\n                tokCallGas = _tg;\r\n        }\r\n\r\n\r\n        //------------------------------------------------------\r\n        // set a micheivous arbiter to locked\r\n        //------------------------------------------------------\r\n        function setArbiterLocked(address _addr, bool _lock)  public \r\n        {\r\n                if (owner != msg.sender)  {\r\n                        throw; \r\n                } else if (!validArb2(_addr)) {\r\n                        StatEvent(\"invalid arb\");\r\n                } else {\r\n                        arbiters[_addr].locked = _lock;\r\n                }\r\n\r\n        }\r\n\r\n        //------------------------------------------------------\r\n        // flush the house fees whenever commanded to.\r\n        // ignore the threshold and the last payout time\r\n        // but this time only reset lastpayouttime upon success\r\n        //------------------------------------------------------\r\n        function flushHouseFees()\r\n        {\r\n                if (msg.sender != owner) {\r\n                        StatEvent(\"only owner calls this function\");\r\n                } else if (houseFeeHoldover > 0) {\r\n                        uint ntmpho = houseFeeHoldover;\r\n                        houseFeeHoldover = 0;\r\n                        if (!tokenPartner.call.gas(tokCallGas).value(ntmpho)()) {\r\n                                houseFeeHoldover = ntmpho; // put it back\r\n                                StatEvent(\"House-Fee Error2\"); \r\n                        } else {\r\n                                lastPayoutTime = now;\r\n                                StatEvent(\"House-Fee Paid\");\r\n                        }\r\n                }\r\n        }\r\n\r\n\r\n        // ----------------------------\r\n        // withdraw expense funds to arbiter\r\n        // ----------------------------\r\n        function withdrawArbFunds() public\r\n        {\r\n                if (!validArb2(msg.sender)) {\r\n                        StatEvent(\"invalid arbiter\");\r\n                } else {\r\n                        arbiter xarb = arbiters[msg.sender];\r\n                        if (xarb.arbHoldover == 0) { \r\n                                StatEvent(\"0 Balance\");\r\n                                return;\r\n                        } else {\r\n                                uint _amount = xarb.arbHoldover; \r\n                                xarb.arbHoldover = 0; \r\n                                if (!msg.sender.call.gas(acctCallGas).value(_amount)())\r\n                                        throw;\r\n                        }\r\n                }\r\n        }\r\n\r\n\r\n        //------------------------------------------------------\r\n        // set the token partner\r\n        //------------------------------------------------------\r\n        function setTokenPartner(address _addr) public\r\n        {\r\n                if (msg.sender != owner) {\r\n                        throw;\r\n                } \r\n\r\n                if ((settingsState == SettingStateValue.lockedRelease) \r\n                        && (tokenPartner == address(0))) {\r\n                        tokenPartner = _addr;\r\n                        StatEvent(\"Token Partner Final!\");\r\n                } else if (settingsState != SettingStateValue.lockedRelease) {\r\n                        tokenPartner = _addr;\r\n                        StatEvent(\"Token Partner Assigned!\");\r\n                }\r\n\r\n        }\r\n\r\n        // ----------------------------\r\n        // swap executor\r\n        // ----------------------------\r\n        function changeOwner(address _addr) \r\n        {\r\n                if (msg.sender != owner\r\n                        || settingsState == SettingStateValue.lockedRelease)\r\n                         throw;\r\n\r\n                owner = _addr;\r\n        }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"payoutInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registrationFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numArbiters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseFeeThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hGame\",\"type\":\"uint256\"}],\"name\":\"ArbTokFromHGame\",\"outputs\":[{\"name\":\"_tok\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hGame\",\"type\":\"uint256\"}],\"name\":\"getGameInfo\",\"outputs\":[{\"name\":\"_reason\",\"type\":\"uint8\"},{\"name\":\"_players\",\"type\":\"uint256\"},{\"name\":\"_totalPot\",\"type\":\"uint256\"},{\"name\":\"_active\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawArbFunds\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hGame\",\"type\":\"uint256\"}],\"name\":\"handleBet\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameTimeOut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tok\",\"type\":\"uint256\"}],\"name\":\"getArbInfo\",\"outputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_escFeePctX10\",\"type\":\"uint256\"},{\"name\":\"_arbFeePctX10\",\"type\":\"uint256\"},{\"name\":\"_feeCap\",\"type\":\"uint256\"},{\"name\":\"_holdOver\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPayoutTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settingsState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hGame\",\"type\":\"uint256\"},{\"name\":\"_winner\",\"type\":\"address\"},{\"name\":\"_winnerBal\",\"type\":\"uint256\"}],\"name\":\"winnerDecided\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numPlayers\",\"type\":\"uint256\"},{\"name\":\"_arbToken\",\"type\":\"uint256\"},{\"name\":\"_escFeePctX10\",\"type\":\"uint256\"},{\"name\":\"_arbFeePctX10\",\"type\":\"uint256\"},{\"name\":\"_feeCap\",\"type\":\"uint256\"}],\"name\":\"registerArbiter\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setTokenPartner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numGamesTimedOut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startGameGas\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ag\",\"type\":\"uint256\"},{\"name\":\"_tg\",\"type\":\"uint256\"}],\"name\":\"setOpGas\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_lock\",\"type\":\"bool\"}],\"name\":\"setArbiterLocked\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_max\",\"type\":\"int256\"},{\"name\":\"_arbToken\",\"type\":\"uint256\"}],\"name\":\"houseKeep\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winnerDecidedGas\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_state\",\"type\":\"uint8\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_threshold\",\"type\":\"uint256\"},{\"name\":\"_timeout\",\"type\":\"uint256\"},{\"name\":\"_interval\",\"type\":\"uint256\"},{\"name\":\"_startGameGas\",\"type\":\"uint256\"},{\"name\":\"_winnerDecidedGas\",\"type\":\"uint256\"}],\"name\":\"applySettings\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOpGas\",\"outputs\":[{\"name\":\"_ag\",\"type\":\"uint256\"},{\"name\":\"_tg\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hGame\",\"type\":\"uint256\"}],\"name\":\"checkHGame\",\"outputs\":[{\"name\":\"_arbTok\",\"type\":\"uint256\"},{\"name\":\"_lowWords\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"blackHole\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numGamesCompleted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hGame\",\"type\":\"uint256\"},{\"name\":\"_hkMax\",\"type\":\"int256\"},{\"name\":\"_players\",\"type\":\"address[]\"}],\"name\":\"startGame\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseFeeHoldover\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"flushHouseFees\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numGamesCanceled\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPartner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tok\",\"type\":\"uint256\"}],\"name\":\"arbTokenExists\",\"outputs\":[{\"name\":\"_exists\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"HaraKiri\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"StatEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"StatEventI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"StatEventA\",\"type\":\"event\"}]","ContractName":"E4RowEscrow","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://87df313975bae77ed69601e31abae6ab8fb4ab9347a25cd1ee6f1fb83637046c"}]}