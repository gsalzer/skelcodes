{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.6;\r\n\r\n// Presale Smart Contract\r\n//\r\n// **** START:  WORK IN PROGRESS DISCLAIMER ****\r\n// This is a work in progress and not intended for reuse.\r\n// So don't reuse unless you know exactly what are you doing! \r\n// **** END:  WORK IN PROGRESS DISCLAIMER ****\r\n//\r\n// **** START:  PARANOIA DISCLAIMER ****\r\n// A careful reader will find here some unnecessary checks and excessive code consuming some extra valuable gas. It is intentionally. \r\n// Even contract will works without these parts, they make the code more secure in production as well for future refactoring.\r\n// Additionally it shows more clearly what we have took care of.\r\n// You are welcome to discuss that places.\r\n// **** END OF: PARANOIA DISCLAIMER *****\r\n//\r\n//\r\n// @author ethernian\r\n//\r\n\r\ncontract BalanceReader {\r\n    Presale public presale;\r\n\r\n\tfunction BalanceReader(){\r\n\t    presale = Presale(0xe3c61a3bff7cb03ddd422258006fddd5ba1ed0fe);\r\n\t}\r\n\t\r\n\tfunction attach(Presale _presale){\r\n\t    presale = _presale;\r\n\t}\r\n\t\r\n\tfunction balance(address addr) public returns (uint) {\r\n\t\treturn presale.balances(addr);\r\n\t}\r\n}\r\n\r\ncontract Presale {\r\n\r\n    string public constant VERSION = \"0.1.3-beta\";\r\n\r\n\t/* ====== configuration START ====== */\r\n\r\n\tuint public constant PRESALE_START  = 3116646; //\tapprox. \t03.02.2017 18:50\r\n\tuint public constant PRESALE_END    = 3116686; //\tapprox. \t03.02.2017 19:00\r\n\tuint public constant WITHDRAWAL_END = 3116726; //\tapprox. \t03.02.2017 19:10\r\n\r\n\r\n\taddress public constant OWNER = 0xA4769870EB607A4fDaBFfbcC3AD066c8213bD87D;\r\n\t\r\n    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;\r\n    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;\r\n    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;\r\n\r\n    /* ====== configuration END ====== */\r\n\t\r\n    string[5] private stateNames = [\"BEFORE_START\",  \"PRESALE_RUNNING\", \"WITHDRAWAL_RUNNING\", \"REFUND_RUNNING\", \"CLOSED\" ];\r\n    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }\r\n\r\n    uint public total_received_amount;\r\n\tmapping (address => uint) public balances;\r\n\t\r\n    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;\r\n    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;\r\n    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;\r\n\t\r\n\r\n    //constructor\r\n    function Presale () validSetupOnly() { }\r\n\r\n    //\r\n    // ======= interface methods =======\r\n    //\r\n\r\n    //accept payments here\r\n    function ()\r\n    payable\r\n    noReentrancy\r\n    {\r\n        State state = currentState();\r\n        if (state == State.PRESALE_RUNNING) {\r\n            receiveFunds();\r\n        } else if (state == State.REFUND_RUNNING) {\r\n            // any entring call in Refund Phase will cause full refund\r\n            sendRefund();\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function refund() external\r\n    inState(State.REFUND_RUNNING)\r\n    noReentrancy\r\n    {\r\n        sendRefund();\r\n    }\r\n\r\n\r\n    function withdrawFunds() external\r\n    inState(State.WITHDRAWAL_RUNNING)\r\n    onlyOwner\r\n    noReentrancy\r\n    {\r\n        // transfer funds to owner if any\r\n        if (this.balance > 0) {\r\n            if (!OWNER.send(this.balance)) throw;\r\n        }\r\n    }\r\n\r\n\r\n    //displays current contract state in human readable form\r\n    function state()  external constant\r\n    returns (string)\r\n    {\r\n        return stateNames[ uint(currentState()) ];\r\n    }\r\n\r\n\r\n    //\r\n    // ======= implementation methods =======\r\n    //\r\n\r\n    function sendRefund() private tokenHoldersOnly {\r\n        // load balance to refund plus amount currently sent\r\n        var amount_to_refund = balances[msg.sender] + msg.value;\r\n        // reset balance\r\n        balances[msg.sender] = 0;\r\n        // send refund back to sender\r\n        if (!msg.sender.send(amount_to_refund)) throw;\r\n    }\r\n\r\n\r\n    function receiveFunds() private notTooSmallAmountOnly {\r\n      // no overflow is possible here: nobody have soo much money to spend.\r\n      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {\r\n          // accept amount only and return change\r\n          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;\r\n          if (!msg.sender.send(change_to_return)) throw;\r\n\r\n          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;\r\n          balances[msg.sender] += acceptable_remainder;\r\n          total_received_amount += acceptable_remainder;\r\n      } else {\r\n          // accept full amount\r\n          balances[msg.sender] += msg.value;\r\n          total_received_amount += msg.value;\r\n      }\r\n    }\r\n\r\n\r\n    function currentState() private constant returns (State) {\r\n        if (block.number < PRESALE_START) {\r\n            return State.BEFORE_START;\r\n        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {\r\n            return State.PRESALE_RUNNING;\r\n        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {\r\n            return State.WITHDRAWAL_RUNNING;\r\n        } else if (this.balance > 0){\r\n            return State.REFUND_RUNNING;\r\n        } else {\r\n            return State.CLOSED;\t\t\r\n\t\t} \r\n    }\r\n\r\n    //\r\n    // ============ modifiers ============\r\n    //\r\n\r\n    //fails if state dosn't match\r\n    modifier inState(State state) {\r\n        if (state != currentState()) throw;\r\n        _;\r\n    }\r\n\r\n\r\n    //fails if something in setup is looking weird\r\n    modifier validSetupOnly() {\r\n        if ( OWNER == 0x0 \r\n            || PRESALE_START == 0 \r\n            || PRESALE_END == 0 \r\n            || WITHDRAWAL_END ==0\r\n            || PRESALE_START <= block.number\r\n            || PRESALE_START >= PRESALE_END\r\n            || PRESALE_END   >= WITHDRAWAL_END\r\n            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )\r\n\t\t\t\tthrow;\r\n        _;\r\n    }\r\n\r\n\r\n    //accepts calls from owner only\r\n    modifier onlyOwner(){\r\n    \tif (msg.sender != OWNER)  throw;\r\n    \t_;\r\n    }\r\n\r\n\r\n    //accepts calls from token holders only\r\n    modifier tokenHoldersOnly(){\r\n        if (balances[msg.sender] == 0) throw;\r\n        _;\r\n    }\r\n\r\n\r\n    // don`t accept transactions with value less than allowed minimum\r\n    modifier notTooSmallAmountOnly(){\t\r\n        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;\r\n        _;\r\n    }\r\n\r\n\r\n    //prevents reentrancy attacs\r\n    bool private locked = false;\r\n    modifier noReentrancy() {\r\n        if (locked) throw;\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n}//contract","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_presale\",\"type\":\"address\"}],\"name\":\"attach\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"}]","ContractName":"BalanceReader","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c35dd748e3e203753fe385418dbcb51100ae826a2ae9f8b019f97af9e48e90f1"}]}