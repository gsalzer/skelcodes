{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\ncontract OldSmartRouletteToken\r\n{\r\n\tfunction balanceOf( address who ) external constant returns (uint256);\r\n\tfunction totalSupply() constant returns (uint supply);\r\n\tfunction tempTokensBalanceOf( address who ) external constant returns (uint256);\r\n\tfunction tempTokensPeriodOf( address who ) external constant returns (uint256);\r\n\tfunction getCountHolders() external constant returns(uint256);\r\n\tfunction getCountTempHolders() external constant returns(uint256);\r\n\tfunction getItemHolders(uint256 index) external constant returns(address);\r\n\tfunction getItemTempHolders(uint256 index) external constant returns(address);\r\n\tfunction isOperationBlocked() external constant returns (bool);\r\n}\r\n\r\ncontract SmartRouletteToken {\r\n\tstring public standard = 'ERC20';\r\n    string public name; // token name\r\n    string public symbol; // token symbol\r\n    uint8 public decimals; // a number of symbols after comma\r\n\r\n\tstruct holderData {\r\n\t\t/**\r\n\t\t*\tToken holders details\r\n\t\t*/\r\n\t\tuint256 tokens_count;\r\n\t\tbool init;\r\n\t}\r\n\r\n\tstruct tempHolderData {\r\n\t\t/**\r\n\t\t*\tTemporary token holders details\r\n\t\t*/\r\n\t\tuint256 tokens_count;\r\n\t\tuint256 start_date;\r\n\t\tuint256 end_date;\r\n\t\tbool init;\r\n\t}\r\n\r\n\taddress[] listAddrHolders; // permanent token holders list\r\n\r\n\tmapping( address => holderData ) _balances; // token ownership\r\n\tmapping( address => tempHolderData ) _temp_balance; // temporary token ownership\r\n\tmapping( address => mapping( address => uint256 ) ) _approvals; // token transfer right\r\n\r\n\tbool stop_operation; // transaction stop\r\n\t\r\n\tuint256 _supply; // total amount of tokens\r\n\tuint256 _init_count_tokens; // initial amount of tokens\r\n\tuint256 public costOfOneToken; // token price equivalent to wei\r\n\t\r\n\taddress wallet_ICO;\r\n\tbool enableICO; // ico status (launched or not)\r\n\tuint256 min_value_buyToken; //in wei\r\n\tuint256 max_value_buyToken; //in wei\r\n\r\n\taddress fond_wallet;\r\n\taddress developer_wallet;\r\n\r\n\taddress divident_contract = address(0x0);\r\n\t\r\n\tevent TokenBuy(address buyer, uint256 amountOfTokens);\r\n\r\n\t// emission limits\r\n\tuint256 max_value_bet; // maximum size of bet for emission\r\n\tuint256 max_coef_player; // maximum size of emission coefficient for a player\r\n\tuint256 max_coef_partner; // maximum size of emission coefficient for an affiliate\r\n\r\n\r\n\taddress developer; // developer's address\r\n\taddress manager; // contract managing address (management can be made from the smart contract)\r\n\r\n\tstruct gamesData {\r\n\t\tbool init;\r\n\t}\r\n\r\n\tmapping( address => gamesData) listGames; // List of allowed games\r\n\taddress[] addrGames;\r\n\r\n\t//old token contract for data restorage\r\n\tOldSmartRouletteToken oldSmartToken;\r\n\r\n\tuint256 countHoldersTransferredFromOldContract; //amount of permanent token holders whose balance has been restored\r\n\tuint256 countHoldersTempTransferredFromOldContract; //amount of temporary token holders whose balance has been restored\r\n\r\n\tfunction SmartRouletteToken()\r\n\t{\r\n\t\t_init_count_tokens = 100000000000000000;\r\n\t\tdeveloper_wallet = address(0x8521E1f9220A251dE0ab78f6a2E8754Ca9E75242);\r\n\t\twallet_ICO = address(0x2dff87f8892d65f7a97b1287e795405098ae7b7f);\r\n\t\tfond_wallet = address(0x3501DD2B515EDC1920f9007782Da5ac018922502);\r\n\r\n        name = 'Roulette Token';                                   \r\n        symbol = 'RLT';                               \r\n        decimals = 10;\r\n        costOfOneToken = 1500000000000000;\r\n\r\n\t\tmax_value_bet = 2560000000000000000;\r\n\t\tmax_coef_player = 300;\r\n\t\tmax_coef_partner = 50;\r\n\r\n\t\tdeveloper = msg.sender;\r\n\t\tmanager = msg.sender;\t\t\r\n\t\t\r\n\t\tenableICO = false;\r\n\t\tmin_value_buyToken = 150000000000000000;\r\n\t\tmax_value_buyToken = 500000000000000000000;\r\n\r\n\t\tstop_operation = false;\r\n\r\n\t\toldSmartToken = OldSmartRouletteToken(0x2a650356bd894370cc1d6aba71b36c0ad6b3dc18);\r\n\t\tcountHoldersTransferredFromOldContract= 0;\r\n\t\tcountHoldersTempTransferredFromOldContract = 0;\r\n\t}\r\n\r\n\tmodifier isDeveloper(){\r\n\t\tif (msg.sender!=developer) throw;\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier isManager(){\r\n\t\tif (msg.sender!=manager) throw;\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier isAccessStopOperation(){\r\n\t\tif (msg.sender!=manager && msg.sender!=developer && (msg.sender!=divident_contract || divident_contract==address(0x0))) throw;\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction IsTransferFromOldContractDone() constant returns(bool)\r\n\t{\r\n\t\treturn countHoldersTransferredFromOldContract == oldSmartToken.getCountHolders();\r\n\t}\r\n\r\n\t/**\r\n    *\trestoreAllPersistentTokens() - function of restoring the balance of permanent token holders. Once the function has been completed,\r\n    *\tblockchain saves the index with which token holders addresses will start being received during the following function operation.\r\n    *\r\n    *\t@param limit - amount of token holders addresses requiring the balance restorage.\r\n    *\r\n    **/\r\n\tfunction restoreAllPersistentTokens(uint256 limit)\r\n\t{\r\n\t\tif(oldSmartToken.isOperationBlocked() && this.isOperationBlocked())\r\n\t\t{\r\n\t\t\tuint256 len = oldSmartToken.getCountHolders();\r\n\t\t\tuint256 i = countHoldersTransferredFromOldContract;\r\n\t\t\tfor(; i < len; i++)\r\n\t\t\t{\r\n\t\t\t\taddress holder = oldSmartToken.getItemHolders(i);\r\n\t\t\t\tuint256 count_tokens = oldSmartToken.balanceOf(holder);\r\n\t\t\t\tif(holder == address(0x2a650356bd894370cc1d6aba71b36c0ad6b3dc18)) {\r\n\t\t\t\t\tif(!_balances[fond_wallet].init){\r\n\t\t\t\t\t\taddUserToList(fond_wallet);\r\n\t\t\t\t\t\t_balances[fond_wallet] = holderData(count_tokens, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\t_balances[fond_wallet].tokens_count += count_tokens;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\taddUserToList(holder);\r\n\t\t\t\t\t_balances[holder] = holderData(count_tokens, true);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_supply += count_tokens;\r\n\r\n\t\t\t\tif (limit - 1 == 0) break;\r\n\t\t\t\tlimit--;\r\n\t\t\t}\r\n\t\t\tcountHoldersTransferredFromOldContract = i;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction IsTransferTempFromOldContractDone() constant returns(bool)\r\n\t{\r\n\t\treturn countHoldersTempTransferredFromOldContract == oldSmartToken.getCountTempHolders();\r\n\t}\r\n\r\n\t/**\r\n    *\trestoreAllTempTokens() - function of temnporary token balance restorage. Once the function has been completed,\r\n    *\tblockchain saves the index with which temporary token holders addresses will start being received during the following function operation.\r\n    *\r\n    *\t@param limit - amount of token holders addresses requiring the balance restorage.\r\n    *\r\n    **/\r\n\tfunction restoreAllTempTokens(uint256 limit)\r\n\t{\r\n\t\tif(oldSmartToken.isOperationBlocked() && this.isOperationBlocked())\r\n\t\t{\r\n\t\t\tuint256 len = oldSmartToken.getCountTempHolders();\r\n\t\t\tuint256 i = countHoldersTempTransferredFromOldContract;\r\n\t\t\tfor(; i < len; i++)\r\n\t\t\t{\r\n\t\t\t\taddress holder = oldSmartToken.getItemTempHolders(i);\r\n\t\t\t\tuint256 count_tokens = oldSmartToken.tempTokensBalanceOf(holder);\r\n\r\n\t\t\t\tif(holder == address(0x2a650356bd894370cc1d6aba71b36c0ad6b3dc18)) {\r\n\t\t\t\t\tif(!_balances[fond_wallet].init){\r\n\t\t\t\t\t\t_balances[fond_wallet] = holderData(count_tokens, true);\r\n\t\t\t\t\t\taddUserToList(fond_wallet);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\t_balances[fond_wallet].tokens_count += count_tokens;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tlistAddrTempHolders.push(holder);\r\n\t\t\t\t\tuint256 end_date = oldSmartToken.tempTokensPeriodOf(holder);\r\n\t\t\t\t\t_temp_balance[holder] = tempHolderData(count_tokens, now, end_date, true);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_supply += count_tokens;\r\n\r\n\t\t\t\tif (limit - 1 == 0) break;\r\n\t\t\t\tlimit--;\r\n\t\t\t}\r\n\t\t\tcountHoldersTempTransferredFromOldContract = i;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction changeDeveloper(address new_developer) isDeveloper\r\n\t{\r\n\t\tif(new_developer == address(0x0)) throw;\r\n\t\tdeveloper = new_developer;\r\n\t}\r\n\r\n\tfunction changeManager(address new_manager) isManager external\r\n\t{\r\n\t\tif(new_manager == address(0x0)) throw;\r\n\t\tmanager = new_manager;\r\n\t}\r\n\r\n\tfunction changeMaxValueBetForEmission(uint256 new_value) isManager external\r\n\t{\r\n\t\tif(new_value == 0) throw;\r\n\t\tmax_value_bet = new_value;\r\n\t}\r\n\r\n\tfunction changeMaxCoefPlayerForEmission(uint256 new_value) isManager external\r\n\t{\r\n\t\tif(new_value > 1000) throw;\r\n\t\tmax_coef_player = new_value;\r\n\t}\r\n\r\n\tfunction changeMaxCoefPartnerForEmission(uint256 new_value) isManager external\r\n\t{\r\n\t\tif(new_value > 1000) throw;\r\n\t\tmax_coef_partner = new_value;\r\n\t}\r\n\r\n\tfunction changeDividentContract(address new_contract) isManager external\r\n\t{\r\n\t\tif(new_contract!=address(0x0)) throw;\r\n\t\tdivident_contract = new_contract;\r\n\t}\r\n\r\n\tfunction newCostToken(uint256 new_cost)\tisManager external\r\n\t{\r\n\t\tif(new_cost == 0) throw;\r\n\t\tcostOfOneToken = new_cost;\r\n\t}\r\n\r\n\tfunction getCostToken() external constant returns(uint256)\r\n\t{\r\n\t\treturn costOfOneToken;\r\n\t}\r\n\r\n\tfunction addNewGame(address new_game) isManager external\r\n\t{\r\n\t\tif(new_game == address(0x0)) throw;\r\n\t\tlistGames[new_game] = gamesData(true);\r\n\t\taddrGames.push(new_game);\r\n\t}\r\n\r\n\tfunction deleteGame(address game) isManager external\r\n\t{\r\n\t\tif(game == address(0x0)) throw;\r\n\t\tif(listGames[game].init){\r\n\t\t\tlistGames[game].init = false;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction addUserToList(address user) internal {\r\n\t\tif(!_balances[user].init){\r\n\t\t\tlistAddrHolders.push(user);\r\n\t\t}\r\n\t}\r\n\r\n    function getListAddressHolders() constant returns(address[]){\r\n        return listAddrHolders;\r\n    }\r\n\r\n    function getCountHolders() external constant returns(uint256){\r\n        return listAddrHolders.length;\r\n    }\r\n\r\n    function getItemHolders(uint256 index) external constant returns(address){\r\n        if(index >= listAddrHolders.length) return address(0x0);\r\n        else return listAddrHolders[index];\r\n    }\r\n\r\n\tfunction gameListOf( address who ) external constant returns (bool value) {\r\n\t\tgamesData game_data = listGames[who];\r\n\t\treturn game_data.init;\r\n\t}\r\n\r\n\t//------------------------------------\r\n\t// Tokens Functions\r\n\t//------------------------------------\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function stopOperation() isManager external {\r\n\t\tstop_operation = true;\r\n\t}\r\n\r\n\tfunction startOperation() isManager external {\r\n\t\tstop_operation = false;\r\n\t}\r\n\r\n\tfunction isOperationBlocked() external constant returns (bool){\r\n\t\treturn stop_operation;\r\n\t}\r\n\r\n\tfunction isOperationAllowed() external constant returns (bool){\r\n\t\treturn !stop_operation;\r\n\t}\r\n\r\n\tfunction runICO() isManager external {\r\n\t\tenableICO = true;\r\n\t\tstop_operation = true;\r\n\t}\r\n\r\n\tfunction stopICO() isManager external {\r\n\t\tenableICO = false;\r\n\t\tstop_operation = false;\r\n\t}\r\n\r\n\tfunction infoICO() constant returns (bool){\r\n\t\treturn enableICO;\r\n\t}\r\n\r\n\tfunction totalSupply() external constant returns (uint256 supply) {\r\n\t\treturn _supply;\r\n\t}\r\n\r\n\tfunction initCountTokens() external constant returns (uint256 init_count) {\r\n\t\treturn _init_count_tokens;\r\n\t}\r\n\r\n\t/**\r\n    *  balanceOf() - constant function check concrete tokens balance\r\n    *\r\n    *  @param who - account owner\r\n    *\r\n    *  @return the value of balance\r\n    */\r\n\tfunction balanceOf( address who ) external constant returns (uint256 value) {\r\n\t\treturn _balances[who].tokens_count;\r\n\t}\r\n\r\n\t/**\r\n    *\r\n    * allowance() - constant function to check how much is\r\n    *               permitted to spend to 3rd person from owner balance\r\n    *\r\n    *  @param owner   - owner of the balance\r\n    *  @param spender - permitted to spend from this balance person\r\n    *\r\n    *  @return - remaining right to spend\r\n    *\r\n    */\r\n\tfunction allowance(address owner, address spender) constant returns (uint256 _allowance) {\r\n\t\treturn _approvals[owner][spender];\r\n\t}\r\n\r\n\r\n\tfunction safeToAdd(uint256 a, uint256 b) internal returns (bool) {\r\n\t\t// overflow check\r\n\t\treturn (a + b >= a && a + b >= b);\r\n\t}\r\n\r\n\t/**\r\n    * transfer() - transfer tokens from msg.sender balance\r\n    *              to requested account\r\n    *\r\n    *  @param to    - target address to transfer tokens\r\n    *  @param value - ammount of tokens to transfer\r\n    *\r\n    *  @return - success / failure of the transaction\r\n    */\r\n\tfunction transfer( address to, uint256 value) returns (bool ok) {\r\n\t\tif(this.isOperationBlocked()) throw;\r\n\r\n\t\tif( _balances[msg.sender].tokens_count < value ) {\r\n\t\t    throw;\r\n\t\t}\r\n\t\tif( !safeToAdd(_balances[to].tokens_count, value) ) {\r\n\t\t    throw;\r\n\t\t}\r\n\r\n\t\t_balances[msg.sender].tokens_count -= value;\r\n\t\tif(_balances[to].init){\r\n\t\t\t_balances[to].tokens_count += value;\r\n\t\t}\r\n\t\telse{\r\n\t\t\taddUserToList(to);\r\n\t\t\t_balances[to] = holderData(value, true);\r\n\t\t}\r\n\r\n\t\tTransfer( msg.sender, to, value );\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n    * transferFrom() - used to move allowed funds from other owner\r\n    *                  account\r\n    *\r\n    *  @param from  - move funds from account\r\n    *  @param to    - move funds to account\r\n    *  @param value - move the value\r\n    *\r\n    *  @return - return true on success false otherwise\r\n    */\r\n\tfunction transferFrom( address from, address to, uint256 value) returns (bool ok) \r\n\t{\r\n\t\tif(this.isOperationBlocked()) throw;\r\n\r\n\t\tif( _balances[from].tokens_count < value ) {\r\n\t\t    throw;\r\n\t\t}\r\n\t\t\r\n\t\tif( _approvals[from][msg.sender] < value ) {\r\n\t\t    throw;\r\n\t\t}\r\n\t\tif( !safeToAdd(_balances[to].tokens_count, value) ) {\r\n\t\t    throw;\r\n\t\t}\r\n\t\t// transfer and return true\r\n\t\t_approvals[from][msg.sender] -= value;\r\n\t\t_balances[from].tokens_count -= value;\r\n\t\tif(_balances[to].init){\r\n\t\t\t_balances[to].tokens_count += value;\r\n\t\t}\r\n\t\telse{\r\n\t\t\taddUserToList(to);\r\n\t\t\t_balances[to] = holderData(value, true);\r\n\t\t}\t\t\r\n\t\t\r\n\t\tTransfer( from, to, value );\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n     *\r\n     * approve() - function approves to a person to spend some tokens from\r\n     *           owner balance.\r\n     *\r\n     *  @param spender - person whom this right been granted.\r\n     *  @param value   - value to spend.\r\n     *\r\n     *  @return true in case of success, otherwise failure\r\n     *\r\n     */\r\n\tfunction approve(address spender, uint256 value) returns (bool ok) \r\n\t{\r\n\t\tif(this.isOperationBlocked()) throw;\r\n\r\n\t\t_approvals[msg.sender][spender] = value;\r\n\t\tApproval( msg.sender, spender, value );\r\n\t\treturn true;\r\n\t}\r\n\r\n\tevent Emission(address indexed to, uint256 value, uint256 bet, uint256 coef, uint256 decimals, uint256 cost_token);\r\n\r\n\t/**\r\n    *\r\n    *  emission() - emission of tokens initiated by the game contract.\r\n    *\r\n    *  @param player       - player's address.\r\n    *  @param partner      - affiliate's address.\r\n    *  @param value_bet    - player's bet value.\r\n    *  @param coef_player  - player's coefficient emission.\r\n    *  @param coef_partner - affiliate's coefficient emission.\r\n    *\r\n    *  @return (true, 0) in case of success, otherwise (False, error_code)\r\n    *\r\n    *\r\n    *  Error code 1 - operation stoped\r\n    *  Error code 2 - sender address is not in games list\r\n    *  Error code 3 - incorrect player's address\r\n    *  Error code 4 - incorrect value bet\r\n    *  Error code 5 - incorrect emission coefficient\r\n    */\r\n\tfunction emission(address player, address partner, uint256 value_bet, uint256 coef_player, uint256 coef_partner) external returns(uint256, uint8) {\r\n        if(this.isOperationBlocked()) return (0, 1);\r\n\r\n        if(listGames[msg.sender].init == false) return (0, 2);\r\n        if(player == address(0x0)) return (0, 3);\r\n        if(value_bet == 0 || value_bet > max_value_bet) return (0, 4);\r\n        if(coef_player > max_coef_player || coef_partner > max_coef_partner) return (0, 5);\r\n\r\n\t\tuint256 decimals_token = 10**uint256(decimals);\r\n\r\n\t\tuint256 player_token = ((value_bet*coef_player*decimals_token)/10000)/costOfOneToken;\r\n\t\tif(_balances[player].init){\r\n\t\t\t_balances[player].tokens_count += player_token;\r\n\t\t}\r\n\t\telse{\r\n\t\t\taddUserToList(player);\r\n\t\t\t_balances[player] = holderData(player_token, true);\r\n\t\t}\r\n\t\tEmission(player, player_token, value_bet, coef_player, decimals_token, costOfOneToken);\r\n\r\n\t\tuint256 partner_token = 0;\r\n\t\tif(partner != address(0x0)){\r\n\t\t\tpartner_token = ((value_bet*coef_partner*decimals_token)/10000)/costOfOneToken;\r\n\t\t\tif(_balances[partner].init){\r\n\t\t\t\t_balances[partner].tokens_count += partner_token;\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\taddUserToList(partner);\r\n\t\t\t\t_balances[partner] = holderData(partner_token, true);\r\n\t\t\t}\r\n\t\t\tEmission(partner, partner_token, value_bet, coef_partner, decimals_token, costOfOneToken);\r\n\t\t}\r\n\r\n\t\t_supply += (player_token+partner_token);\r\n\r\n\t\treturn (player_token, 0);\r\n\t}\r\n\r\n\t//------------------------------------\r\n\t// Temporary Tokens\r\n\t//------------------------------------\r\n\taddress[] listAddrTempHolders;\r\n\tevent TempTokensSend(address indexed recipient, uint256 count, uint256 start, uint256 end);\r\n\r\n\t/**\r\n     *\r\n     *  sendTempTokens() - sending temporary tokens to address.\r\n     *\r\n     *  @param recipient - recipient's address.\r\n     *  @param count     - temporary tokens amount.\r\n     *  @param period    - period of possession of the tokens in seconds.\r\n     *\r\n     */\r\n\tfunction sendTempTokens(address recipient, uint256 count, uint256 period) isDeveloper {\r\n\t\tif(this.isOperationBlocked()) throw;\r\n\r\n\t\tif(count==0 || period==0) throw;\r\n\t\t\r\n\t\tuint256 decimals_token = 10**uint256(decimals);\r\n\t\tcount = count*decimals_token;\r\n\r\n\t\tif(_balances[fond_wallet].tokens_count < count) throw;\r\n\t\tif(_temp_balance[recipient].tokens_count > 0) throw;\r\n\r\n\t\tif(!_temp_balance[recipient].init){\r\n\t\t\t_temp_balance[recipient] = tempHolderData(count, now, now + period, true);\r\n\t\t\tlistAddrTempHolders.push(recipient);\r\n\t\t}\r\n\t\telse{\r\n\t\t\t_temp_balance[recipient].tokens_count = count;\r\n\t\t\t_temp_balance[recipient].start_date = now;\r\n\t\t\t_temp_balance[recipient].end_date = now + period;\r\n\t\t}\r\n\t\t_balances[fond_wallet].tokens_count -= count;\r\n\t\tTempTokensSend(recipient, count, _temp_balance[recipient].start_date, _temp_balance[recipient].end_date);\r\n\t}\r\n\r\n\tfunction tempTokensBalanceOf( address who ) external constant returns (uint256) {\r\n\t\tif(_temp_balance[who].end_date < now) return 0;\r\n\t\telse return _temp_balance[who].tokens_count;\r\n\t}\r\n\r\n\tfunction tempTokensPeriodOf( address who ) external constant returns (uint256) {\r\n\t\tif(_temp_balance[who].end_date < now) return 0;\r\n\t\telse return _temp_balance[who].end_date;\r\n\t}\r\n\r\n\t/**\r\n     *\r\n     *  returnTempTokens() - return of temporary tokens after the expiration of possession time.\r\n     *\r\n     *  @param recipient - temporary token holder address.\r\n     *\r\n     */\r\n\tfunction returnTempTokens(address recipient) isDeveloper {\r\n\t\tif(this.isOperationBlocked()) throw;\r\n\t\t\r\n\t\tif(_temp_balance[recipient].tokens_count == 0) throw;\r\n\r\n\t\t_balances[fond_wallet].tokens_count += _temp_balance[recipient].tokens_count;\r\n\t\t_temp_balance[recipient].tokens_count = 0;\r\n\t\t_temp_balance[recipient].start_date = 0;\r\n\t\t_temp_balance[recipient].end_date = 0;\r\n\t}\r\n\r\n\tfunction getListTempHolders() constant returns(address[]){\r\n\t\treturn listAddrTempHolders;\r\n\t}\r\n\r\n\tfunction getCountTempHolders() external constant returns(uint256){\r\n\t\treturn listAddrTempHolders.length;\r\n\t}\r\n\r\n\tfunction getItemTempHolders(uint256 index) external constant returns(address){\r\n\t\tif(index >= listAddrTempHolders.length) return address(0x0);\r\n\t\telse return listAddrTempHolders[index];\r\n\t}\r\n\r\n\t//------------------------------------\r\n\t// Invest Functions\r\n\t//------------------------------------\r\n\r\n\tfunction() payable\r\n\t{\t\r\n\t\tif(this.isOperationBlocked()) throw;\r\n\t\tif(msg.sender == developer) throw;\r\n\t\tif(msg.sender == manager) throw;\r\n\t\tif(msg.sender == developer_wallet) throw;\r\n\t\tif(msg.sender == wallet_ICO) throw;\r\n\t\tif(msg.sender == fond_wallet) throw;\r\n\r\n\t\tif(listGames[msg.sender].init) throw;\r\n\r\n\t\tif(enableICO == false) throw;\r\n\t\t\t\r\n\t\tif(msg.value < min_value_buyToken) throw;\r\n\t\t\r\n\t\tuint256 value_send = msg.value;\r\n\t\tif(value_send > max_value_buyToken){\r\n\t\t\tvalue_send = max_value_buyToken;\r\n\t\t\tif(msg.sender.send(msg.value-max_value_buyToken)==false) throw;\r\n\t\t}\r\n\r\n\t\tuint256 decimals_token = 10**uint256(decimals);\r\n\t\t\r\n\t\tuint256 count_tokens = (value_send*decimals_token)/costOfOneToken;\r\n\t\t\r\n\t\tif(count_tokens >_balances[wallet_ICO].tokens_count ){\r\n\t\t\tcount_tokens = _balances[wallet_ICO].tokens_count;\r\n\t\t}\r\n\t\tif(value_send > (count_tokens*costOfOneToken)/decimals_token){\t\t\t\t\r\n\t\t\tif(msg.sender.send(value_send-((count_tokens*costOfOneToken)/decimals_token))==false) throw;\r\n\t\t\tvalue_send = (count_tokens*costOfOneToken)/decimals_token;\r\n\t\t}\r\n\r\n\t\tif(!_balances[msg.sender].init){\r\n\t\t\tif (_balances[wallet_ICO].tokens_count < count_tokens) throw;\r\n\t\t\taddUserToList(msg.sender);\r\n\t\t\t_balances[wallet_ICO].tokens_count -= count_tokens;\r\n\t\t\t_balances[msg.sender] = holderData(count_tokens, true);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tif(((_balances[msg.sender].tokens_count*costOfOneToken)/decimals_token)+((count_tokens*costOfOneToken)/decimals_token)>max_value_buyToken) {\r\n\t\t\t\tcount_tokens = ((max_value_buyToken*decimals_token)/costOfOneToken)-_balances[msg.sender].tokens_count;\t\t\t\t\t\r\n\t\t\t\tif(msg.sender.send(value_send-((count_tokens*costOfOneToken)/decimals_token))==false) throw;\r\n\t\t\t\tvalue_send = (count_tokens*costOfOneToken)/decimals_token;\r\n\t\t\t}\r\n\r\n\t\t\tif (_balances[wallet_ICO].tokens_count < count_tokens) throw;\r\n\t\t\t_balances[wallet_ICO].tokens_count -= count_tokens;\r\n\t\t\t_balances[msg.sender].tokens_count += count_tokens;\r\n\t\t}\r\n\r\n\t\tif(value_send>0){\r\n\t\t\tif(wallet_ICO.send(value_send)==false) throw;\r\n\t\t}\r\n\r\n\t\tif(count_tokens>0){\r\n\t\t\tTokenBuy(msg.sender, count_tokens);\r\n\t\t}\r\n\r\n\t\tif(_balances[wallet_ICO].tokens_count == 0){\r\n\t\t\tenableICO = false;\r\n\t\t}\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"tempTokensBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getListAddressHolders\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"partner\",\"type\":\"address\"},{\"name\":\"value_bet\",\"type\":\"uint256\"},{\"name\":\"coef_player\",\"type\":\"uint256\"},{\"name\":\"coef_partner\",\"type\":\"uint256\"}],\"name\":\"emission\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"sendTempTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOperationBlocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"supply\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"tempTokensPeriodOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"IsTransferFromOldContractDone\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_developer\",\"type\":\"address\"}],\"name\":\"changeDeveloper\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCountHolders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_value\",\"type\":\"uint256\"}],\"name\":\"changeMaxValueBetForEmission\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"infoICO\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"IsTransferTempFromOldContractDone\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_cost\",\"type\":\"uint256\"}],\"name\":\"newCostToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_contract\",\"type\":\"address\"}],\"name\":\"changeDividentContract\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"game\",\"type\":\"address\"}],\"name\":\"deleteGame\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getItemTempHolders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"costOfOneToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"returnTempTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_manager\",\"type\":\"address\"}],\"name\":\"changeManager\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOperationAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopOperation\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"restoreAllPersistentTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_value\",\"type\":\"uint256\"}],\"name\":\"changeMaxCoefPlayerForEmission\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"runICO\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopICO\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getItemHolders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startOperation\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"restoreAllTempTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCountTempHolders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"_allowance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCostToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_value\",\"type\":\"uint256\"}],\"name\":\"changeMaxCoefPartnerForEmission\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"gameListOf\",\"outputs\":[{\"name\":\"value\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initCountTokens\",\"outputs\":[{\"name\":\"init_count\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getListTempHolders\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_game\",\"type\":\"address\"}],\"name\":\"addNewGame\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"TokenBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"coef\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"decimals\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cost_token\",\"type\":\"uint256\"}],\"name\":\"Emission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"TempTokensSend\",\"type\":\"event\"}]","ContractName":"SmartRouletteToken","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f447564ef5a20e883bf5c5519d2567087097c1daab1c4ecd501e250a6889ea64"}]}