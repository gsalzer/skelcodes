{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\n/**\r\n * Very basic owned/mortal boilerplate.  Used for basically everything, for\r\n * security/access control purposes.\r\n */\r\ncontract Owned {\r\n  address owner;\r\n\r\n  modifier onlyOwner {\r\n    if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Basic constructor.  The sender is the owner.\r\n   */\r\n  function Owned() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * Transfers ownership of the contract to a new owner.\r\n   * @param newOwner  Who gets to inherit this thing.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    owner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * Shuts down the contract and removes it from the blockchain state.\r\n   * Only available to the owner.\r\n   */\r\n  function shutdown() onlyOwner {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  /**\r\n   * Withdraw all the funds from this contract.\r\n   * Only available to the owner.\r\n   */\r\n  function withdraw() onlyOwner {\r\n    if (!owner.send(this.balance)) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * The base interface is what the parent contract expects to be able to use.\r\n * If rules change in the future, and new logic is introduced, it only has to\r\n * implement these methods, wtih the role of the curator being used\r\n * to execute the additional functionality (if any).\r\n */\r\ncontract LotteryGameLogicInterface {\r\n  address public currentRound;\r\n  function finalizeRound() returns(address);\r\n  function isUpgradeAllowed() constant returns(bool);\r\n  function transferOwnership(address newOwner);\r\n}\r\n\r\n/**\r\n * This contract is pretty generic, as it really only serves to maintain a constant\r\n * address on the blockchain (through upgrades to the game logic), and to maintain\r\n * a history of previous rounds.  Note that the rounds will have had ownership\r\n * transferred to the curator (most likely), so there's mostly just here for\r\n * accounting purposes.\r\n *\r\n * A side effect of this is that finalizing a round has to happen from here.\r\n */\r\ncontract Lotto is Owned {\r\n\r\n  address[] public previousRounds;\r\n\r\n  LotteryGameLogicInterface public gameLogic;\r\n\r\n  modifier onlyWhenUpgradeable {\r\n    if (!gameLogic.isUpgradeAllowed()) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  modifier onlyGameLogic {\r\n    if (msg.sender != address(gameLogic)) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Creates a new lottery contract.\r\n   * @param initialGameLogic   The starting game logic.\r\n   */\r\n  function Lotto(address initialGameLogic) {\r\n    gameLogic = LotteryGameLogicInterface(initialGameLogic);\r\n  }\r\n\r\n  /**\r\n   * Upgrade the game logic.  Only possible to do when the game logic\r\n   * has deemed it clear to do so.  Hands the old one over to the owner\r\n   * for cleanup.  Expects the new logic to already be configured.\r\n   * @param newLogic   New, already-configured game logic.\r\n   */\r\n  function setNewGameLogic(address newLogic) onlyOwner onlyWhenUpgradeable {\r\n    gameLogic.transferOwnership(owner);\r\n    gameLogic = LotteryGameLogicInterface(newLogic);\r\n  }\r\n\r\n  /**\r\n   * Returns the current round.\r\n   * @return address The current round (when applicable)\r\n   */\r\n  function currentRound() constant returns(address) {\r\n    return gameLogic.currentRound();\r\n  }\r\n\r\n  /**\r\n   * Used to finalize (e.g. pay winners) the current round, then log\r\n   * it in the history.\r\n   */\r\n  function finalizeRound() onlyOwner {\r\n    address roundAddress = gameLogic.finalizeRound();\r\n    previousRounds.push(roundAddress);\r\n  }\r\n\r\n  /**\r\n   * Tells how many previous rounds exist.\r\n   */\r\n  function previousRoundsCount() constant returns(uint) {\r\n    return previousRounds.length;\r\n  }\r\n\r\n  // You must think I'm a joke\r\n  // I ain't gonna be part of your system\r\n  // Man! Pump that garbage in another man's veins\r\n  function () {\r\n    throw;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"gameLogic\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeRound\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newLogic\",\"type\":\"address\"}],\"name\":\"setNewGameLogic\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"previousRounds\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"previousRoundsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"shutdown\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"initialGameLogic\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"}]","ContractName":"Lotto","CompilerVersion":"v0.4.9+commit.364da425","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000072bf3030e276a96539143551bd8f91aff699bf7c","Library":"","SwarmSource":"bzzr://d01f4cb494882a33f4acdda609ac297ac4688b4d7caebeaf531aed06a1934e90"}]}