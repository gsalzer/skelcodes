{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Ownable\r\n *\r\n * Base contract with an owner.\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * ERC20Basic\r\n * Simpler version of ERC20 interface\r\n * see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20Basic {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function transfer(address to, uint value);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\n\r\n/*\r\n * Basic token\r\n * Basic version of StandardToken, with no allowances\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint;\r\n\r\n  mapping(address => uint) balances;\r\n\r\n  /*\r\n   * Fix for the ERC20 short address attack  \r\n   */\r\n  modifier onlyPayloadSize(uint size) {\r\n     if(msg.data.length < size + 4) {\r\n       throw;\r\n     }\r\n     _;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title FundableToken - accounts for funds to stand behind it\r\n * @author Dmitry Kochin <k@ubermensch.store>\r\n * We need to store this data to be able to know how much funds are standing behind the tokens\r\n * It may come handy in token transformation. For example if prefund would not be successful we\r\n * will be able to refund all the invested money\r\n */\r\ncontract FundableToken is BasicToken {\r\n    ///Invested funds\r\n    mapping(address => uint) public funds;\r\n\r\n    ///Total funds behind the tokens\r\n    uint public totalFunds;\r\n\r\n    function FundableToken() {}\r\n}\r\n\r\n\r\n/**\r\n * Transform agent transfers tokens to a new contract. It may transform them to another tokens or refund\r\n * Transform agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\r\n */\r\ncontract TransformAgent {\r\n    ///The original supply of tokens to be transformed\r\n    uint256 public originalSupply;\r\n    ///The original funds behind the tokens to be transformed\r\n    uint256 public originalFunds;\r\n\r\n    /** Interface marker */\r\n    function isTransformAgent() public constant returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    function transformFrom(address _from, uint256 _tokens, uint256 _funds) public;\r\n\r\n}\r\n\r\n\r\n/**\r\n * A token transform mechanism where users can opt-in amount of tokens to the next smart contract revision.\r\n *\r\n * First envisioned by Golem and Lunyr projects.\r\n */\r\ncontract TransformableToken is FundableToken, Ownable {\r\n\r\n    /** The next contract where the tokens will be migrated. */\r\n    TransformAgent public transformAgent;\r\n\r\n    /** How many tokens we have transformed by now. */\r\n    uint256 public totalTransformedTokens;\r\n\r\n    /**\r\n     * Transform states.\r\n     *\r\n     * - NotAllowed: The child contract has not reached a condition where the transform can bgun\r\n     * - WaitingForAgent: Token allows transform, but we don't have a new agent yet\r\n     * - ReadyToTransform: The agent is set, but not a single token has been transformed yet, so we\r\n            still have a chance to reset agent to another value\r\n     * - Transforming: Transform agent is set and the balance holders can transform their tokens\r\n     *\r\n     */\r\n    enum TransformState {Unknown, NotAllowed, WaitingForAgent, ReadyToTransform, Transforming}\r\n\r\n    /**\r\n     * Somebody has transformd some of his tokens.\r\n     */\r\n    event Transform(address indexed _from, address indexed _to, uint256 _tokens, uint256 _funds);\r\n\r\n    /**\r\n     * New transform agent available.\r\n     */\r\n    event TransformAgentSet(address agent);\r\n\r\n    /**\r\n     * Allow the token holder to transform all of their tokens to a new contract.\r\n     */\r\n    function transform() public {\r\n\r\n        TransformState state = getTransformState();\r\n        require(state == TransformState.ReadyToTransform || state == TransformState.Transforming);\r\n\r\n        uint tokens = balances[msg.sender];\r\n        uint investments = funds[msg.sender];\r\n        require(tokens > 0); // Validate input value.\r\n\r\n        balances[msg.sender] = 0;\r\n        funds[msg.sender] = 0;\r\n\r\n        // Take tokens out from circulation\r\n        totalSupply = totalSupply.sub(tokens);\r\n        totalFunds = totalFunds.sub(investments);\r\n\r\n        totalTransformedTokens = totalTransformedTokens.add(tokens);\r\n\r\n        // Transform agent reissues the tokens\r\n        transformAgent.transformFrom(msg.sender, tokens, investments);\r\n        Transform(msg.sender, transformAgent, tokens, investments);\r\n\r\n        //Once transformation is finished the contract is not needed anymore\r\n        if(totalSupply == 0)\r\n            selfdestruct(owner);\r\n    }\r\n\r\n    /**\r\n     * Set an transform agent that handles\r\n     */\r\n    function setTransformAgent(address agent) onlyOwner external {\r\n        require(agent != 0x0);\r\n        // Transform has already begun for an agent\r\n        require(getTransformState() != TransformState.Transforming);\r\n\r\n        transformAgent = TransformAgent(agent);\r\n\r\n        // Bad interface\r\n        require(transformAgent.isTransformAgent());\r\n        // Make sure that token supplies match in source and target\r\n        require(transformAgent.originalSupply() == totalSupply);\r\n        require(transformAgent.originalFunds() == totalFunds);\r\n\r\n        TransformAgentSet(transformAgent);\r\n    }\r\n\r\n    /**\r\n     * Get the state of the token transform.\r\n     */\r\n    function getTransformState() public constant returns(TransformState) {\r\n        if(address(transformAgent) == 0x00) return TransformState.WaitingForAgent;\r\n        else if(totalTransformedTokens == 0) return TransformState.ReadyToTransform;\r\n        else return TransformState.Transforming;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Mintable token\r\n *\r\n * Simple ERC20 Token example, with mintable token creation\r\n * Issue:\r\n * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\r\n * Based on code by TokenMarketNet:\r\n * https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\ncontract MintableToken is BasicToken {\r\n    /**\r\n      Crowdsale contract allowed to mint tokens\r\n    */\r\n\r\n    function mint(address _to, uint _amount) internal {\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        //Announce that we have minted some tokens\r\n        Transfer(0x0, _to, _amount);\r\n    }\r\n}\r\n\r\n\r\n/// @title Token contract - Implements Standard Token Interface with Ubermensch features.\r\n/// @author Dmitry Kochin - <k@ubermensch.store>\r\ncontract UbermenschPrefundToken is MintableToken, TransformableToken {\r\n    string constant public name = \"Ubermensch Prefund\";\r\n    string constant public symbol = \"UMP\";\r\n    uint constant public decimals = 8;\r\n\r\n    //The price of 1 token in Ether\r\n    uint constant public TOKEN_PRICE = 0.0025 * 1 ether;\r\n    //The maximum number of tokens to be sold in crowdsale\r\n    uint constant public TOKEN_CAP = 20000000 * (10 ** decimals);\r\n\r\n    uint public investorCount;\r\n    address public multisigWallet;\r\n    bool public stopped;\r\n\r\n    // A new investment was made\r\n    event Invested(address indexed investor, uint weiAmount, uint tokenAmount);\r\n\r\n    function UbermenschPrefundToken(address multisig){\r\n        //We require that the owner should be multisig wallet\r\n        //Because owner can make important decisions like stopping prefund\r\n        //and setting TransformAgent\r\n        //However this contract can be created by any account. After creation\r\n        //it automatically transfers ownership to multisig wallet\r\n        transferOwnership(multisig);\r\n        multisigWallet = multisig;\r\n    }\r\n\r\n    modifier onlyActive(){\r\n        require(!stopped);\r\n        //Setting the transfer agent effectively stops prefund\r\n        require(getTransformState() == TransformState.WaitingForAgent);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Returns bonuses based on the current totalSupply in percents\r\n     * An investor gets the bonus based on the current totalSupply value\r\n     * even if the resulting totalSupply after an investment corresponds to different bonus\r\n     */\r\n    function getCurrentBonus() public constant returns (uint){\r\n        if(totalSupply < 7000000 * (10 ** decimals))\r\n            return 180;\r\n        if(totalSupply < 14000000 * (10 ** decimals))\r\n            return 155;\r\n        return 140;\r\n    }\r\n\r\n    /// @dev main function to buy tokens to specified address\r\n    /// @param to The address of token recipient\r\n    function invest(address to) onlyActive public payable {\r\n        uint amount = msg.value;\r\n        //Bonuses are in percents so the final value must be divided by 100\r\n        uint tokenAmount = getCurrentBonus().mul(amount).mul(10 ** decimals / 100).div(TOKEN_PRICE);\r\n\r\n        require(tokenAmount >= 0);\r\n\r\n        if(funds[to] == 0) {\r\n            // A new investor\r\n            ++investorCount;\r\n        }\r\n\r\n        // Update investor\r\n        funds[to] = funds[to].add(amount);\r\n        totalFunds = totalFunds.add(amount);\r\n\r\n        //mint tokens\r\n        mint(to, tokenAmount);\r\n\r\n        //We also should not break the token cap\r\n        //This is exactly \"require' and not 'assert' because it depends on msg.value - a user supplied parameters\r\n        //While 'assert' should correspond to a broken business logic\r\n        require(totalSupply <= TOKEN_CAP);\r\n\r\n        // Pocket the money\r\n        multisigWallet.transfer(amount);\r\n\r\n        // Tell us invest was success\r\n        Invested(to, amount, tokenAmount);\r\n    }\r\n\r\n    function buy() public payable {\r\n        invest(msg.sender);\r\n    }\r\n\r\n    function transfer(address _to, uint _value){\r\n        throw; //This prefund token can not be transferred\r\n    }\r\n\r\n    //Stops the crowdsale forever\r\n    function stop() onlyOwner {\r\n        stopped = true;\r\n    }\r\n\r\n    //We'll try to accept sending ether on the contract address, hope the gas supplied would be enough\r\n    function () payable{\r\n        buy();\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transform\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transformAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"setTransformAgent\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTransformState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTransformedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"funds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"multisig\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Invested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_funds\",\"type\":\"uint256\"}],\"name\":\"Transform\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"TransformAgentSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"UbermenschPrefundToken","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000001db958a53b6b2defc268706b27d12503e6","Library":"","SwarmSource":"bzzr://af55aa9f2d5d079781cca2f47fd68407248a59a9c53f9cb607bf26a460460698"}]}