{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n /* Receiver must implement this function to receive tokens\r\n *  otherwise token transaction will fail\r\n */\r\n \r\n contract ContractReceiver {\r\n    function tokenFallback(address _from, uint256 _value, bytes _data){\r\n      _from = _from;\r\n      _value = _value;\r\n      _data = _data;\r\n      // Incoming transaction code here\r\n    }\r\n}\r\n \r\n /* New ERC23 contract interface */\r\n\r\ncontract ERC23 {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant returns (uint256);\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\n\r\n  function name() constant returns (string _name);\r\n  function symbol() constant returns (string _symbol);\r\n  function decimals() constant returns (uint8 _decimals);\r\n  function totalSupply() constant returns (uint256 _supply);\r\n\r\n  function transfer(address to, uint256 value) returns (bool ok);\r\n  function transfer(address to, uint256 value, bytes data) returns (bool ok);\r\n  function transferFrom(address from, address to, uint256 value) returns (bool ok);\r\n  function approve(address spender, uint256 value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n /**\r\n * ERC23 token by Dexaran\r\n *\r\n * https://github.com/Dexaran/ERC23-tokens\r\n */\r\n \r\ncontract ERC23Token is ERC23 {\r\n\r\n  mapping(address => uint256) balances;\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n  uint256 public totalSupply;\r\n\r\n  // Function to access name of token .\r\n  function name() constant returns (string _name) {\r\n      return name;\r\n  }\r\n  // Function to access symbol of token .\r\n  function symbol() constant returns (string _symbol) {\r\n      return symbol;\r\n  }\r\n  // Function to access decimals of token .\r\n  function decimals() constant returns (uint8 _decimals) {\r\n      return decimals;\r\n  }\r\n  // Function to access total supply of tokens .\r\n  function totalSupply() constant returns (uint256 _totalSupply) {\r\n      return totalSupply;\r\n  }\r\n\r\n  //function that is called when a user or another contract wants to transfer funds\r\n  function transfer(address _to, uint256 _value, bytes _data) returns (bool success) {\r\n  \r\n    //filtering if the target is a contract with bytecode inside it\r\n    if(isContract(_to)) {\r\n        transferToContract(_to, _value, _data);\r\n    }\r\n    else {\r\n        transferToAddress(_to, _value, _data);\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  function transfer(address _to, uint256 _value) returns (bool success) {\r\n      \r\n    //standard function transfer similar to ERC20 transfer with no _data\r\n    //added due to backwards compatibility reasons\r\n    bytes memory empty;\r\n    if(isContract(_to)) {\r\n        transferToContract(_to, _value, empty);\r\n    }\r\n    else {\r\n        transferToAddress(_to, _value, empty);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  //function that is called when transaction target is an address\r\n  function transferToAddress(address _to, uint256 _value, bytes _data) private returns (bool success) {\r\n    balances[msg.sender] -= _value;\r\n    balances[_to] += _value;\r\n    Transfer(msg.sender, _to, _value);\r\n    Transfer(msg.sender, _to, _value, _data);\r\n    return true;\r\n  }\r\n  \r\n  //function that is called when transaction target is a contract\r\n  function transferToContract(address _to, uint256 _value, bytes _data) private returns (bool success) {\r\n    balances[msg.sender] -= _value;\r\n    balances[_to] += _value;\r\n    ContractReceiver reciever = ContractReceiver(_to);\r\n    reciever.tokenFallback(msg.sender, _value, _data);\r\n    Transfer(msg.sender, _to, _value);\r\n    Transfer(msg.sender, _to, _value, _data);\r\n    return true;\r\n  }\r\n  \r\n  //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n  function isContract(address _addr) private returns (bool is_contract) {\r\n      _addr = _addr;\r\n      uint256 length;\r\n      assembly {\r\n            //retrieve the size of the code on target address, this needs assembly\r\n            length := extcodesize(_addr)\r\n        }\r\n        if(length>0) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n    \r\n    if(_value > _allowance) {\r\n        throw;\r\n    }\r\n\r\n    balances[_to] += _value;\r\n    balances[_from] -= _value;\r\n    allowed[_from][msg.sender] -= _value;\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n}\r\n\r\n\r\n// ERC223 token with the ability for the owner to block any account\r\ncontract DASToken is ERC23Token {\r\n    mapping (address => bool) blockedAccounts;\r\n    address public secretaryGeneral;\r\n\r\n\r\n    // Constructor\r\n    function DASToken(\r\n            string _name,\r\n            string _symbol,\r\n            uint8 _decimals,\r\n            uint256 _totalSupply,\r\n            address _initialTokensHolder) {\r\n        secretaryGeneral = msg.sender;\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        totalSupply = _totalSupply;\r\n        balances[_initialTokensHolder] = _totalSupply;\r\n    }\r\n\r\n\r\n    modifier onlySecretaryGeneral {\r\n        if (msg.sender != secretaryGeneral) throw;\r\n        _;\r\n    }\r\n\r\n\r\n    // block account\r\n    function blockAccount(address _account) onlySecretaryGeneral {\r\n        blockedAccounts[_account] = true;\r\n    }\r\n\r\n    // unblock account\r\n    function unblockAccount(address _account) onlySecretaryGeneral {\r\n        blockedAccounts[_account] = false;\r\n    }\r\n\r\n    // check is account blocked\r\n    function isAccountBlocked(address _account) returns (bool){\r\n        return blockedAccounts[_account];\r\n    }\r\n\r\n    // override transfer methods to throw on blocked accounts\r\n    function transfer(address _to, uint256 _value, bytes _data) returns (bool success) {\r\n        if (blockedAccounts[msg.sender]) {\r\n            throw;\r\n        }\r\n        return ERC23Token.transfer(_to, _value, _data);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (blockedAccounts[msg.sender]) {\r\n            throw;\r\n        }\r\n        bytes memory empty;\r\n        return ERC23Token.transfer(_to, _value, empty);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (blockedAccounts[_from]) {\r\n            throw;\r\n        }\r\n        return ERC23Token.transferFrom(_from, _to, _value);\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract ABCToken is ERC23Token {\r\n    // Constructor\r\n    function ABCToken(\r\n            string _name,\r\n            string _symbol,\r\n            uint8 _decimals,\r\n            uint256 _totalSupply,\r\n            address _initialTokensHolder) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        totalSupply = _totalSupply;\r\n        balances[_initialTokensHolder] = _totalSupply;\r\n    }\r\n}\r\n\r\n\r\n// Contract with voting on proposals and execution of passed proposals\r\ncontract DAS is ContractReceiver {\r\n\r\n    /* Contract Variables */\r\n\r\n    string name = \"Decentralized Autonomous State\";\r\n    // Source of democracy\r\n    DASToken public dasToken;\r\n    ABCToken public abcToken;\r\n    // Democracy rules\r\n    uint256 public congressMemberThreshold; // User must have more than this amount of tokens to be included into congress\r\n    uint256 public minimumQuorum;           // The minimum number of tokens that must participate in a vote to achieve a quorum\r\n    uint256 public debatingPeriod;          // Min time to vote for an proposal [sec]\r\n    uint256 public marginForMajority;       // Min superiority of votes \"for\" to pass the proposal [number of tokens]\r\n    // Proposals\r\n    Proposal[] public proposals;\r\n    uint256 public proposalsNumber = 0;\r\n    mapping (address => uint32) tokensLocks;         // congress member => number of locks (recursive mutex)\r\n\r\n    /* Contract Events */\r\n    event ProposalAddedEvent(uint256 proposalID, address beneficiary, uint256 etherAmount, string description);\r\n    event VotedEvent(uint256 proposalID, address voter, bool inSupport, uint256 voterTokens, string justificationText);\r\n    event ProposalTalliedEvent(uint256 proposalID, bool quorum, bool result);\r\n    event ProposalExecutedEvent(uint256 proposalID);\r\n    event RulesChangedEvent(uint256 congressMemberThreshold,\r\n                            uint256 minimumQuorum,\r\n                            uint256 debatingPeriod,\r\n                            uint256 marginForMajority);\r\n\r\n    /* Contract Structures */\r\n    enum ProposalState {Proposed, NoQuorum, Rejected, Passed, Executed}\r\n\r\n    struct Proposal {\r\n        /* Proposal content */\r\n        address beneficiary;\r\n        uint256 etherAmount;\r\n        string description;\r\n        bytes32 proposalHash;\r\n\r\n        /* Proposal state */\r\n        ProposalState state;\r\n\r\n        /* Voting state */\r\n        uint256 votingDeadline;\r\n        Vote[] votes;\r\n        uint256 votesNumber;\r\n        mapping (address => bool) voted;\r\n    }\r\n\r\n    struct Vote {\r\n        address voter;\r\n        bool inSupport;\r\n        uint256 voterTokens;\r\n        string justificationText;\r\n    }\r\n\r\n    /* modifier that allows only congress members to vote and create new proposals */\r\n    modifier onlyCongressMembers {\r\n        if (dasToken.balanceOf(msg.sender) < congressMemberThreshold) throw;\r\n        _;\r\n    }\r\n\r\n    /* Constructor */\r\n    function DAS(\r\n        uint256 _congressMemberThreshold,\r\n        uint256 _minimumQuorum,\r\n        uint256 _debatingPeriod,\r\n        uint256 _marginForMajority,\r\n        address _congressLeader\r\n    ) payable {\r\n        // create a source of democracy\r\n        dasToken = new DASToken('DA$', 'DA$', 18, 1000000000 * (10 ** 18), _congressLeader);\r\n        abcToken = new ABCToken('Alphabit', 'ABC', 18, 210000000 * (10 ** 18), _congressLeader);\r\n\r\n        // setup rules\r\n        congressMemberThreshold = _congressMemberThreshold;\r\n        minimumQuorum = _minimumQuorum;\r\n        debatingPeriod = _debatingPeriod;\r\n        marginForMajority = _marginForMajority;\r\n\r\n        RulesChangedEvent(congressMemberThreshold, minimumQuorum, debatingPeriod, marginForMajority);\r\n    }\r\n\r\n    // blank fallback to receive ETH\r\n    function() payable { }\r\n\r\n    /* Proposal-related functions */\r\n\r\n    // calculate hash of an proposal\r\n    function getProposalHash(\r\n        address _beneficiary,\r\n        uint256 _etherAmount,\r\n        bytes _transactionBytecode\r\n    )\r\n        constant\r\n        returns (bytes32)\r\n    {\r\n        return sha3(_beneficiary, _etherAmount, _transactionBytecode);\r\n    }\r\n\r\n    // block tokens of an voter\r\n    function blockTokens(address _voter) internal {\r\n        if (tokensLocks[_voter] + 1 < tokensLocks[_voter]) throw;\r\n\r\n        tokensLocks[_voter] += 1;\r\n        if (tokensLocks[_voter] == 1) {\r\n            dasToken.blockAccount(_voter);\r\n        }\r\n    }\r\n\r\n    // unblock tokens of an voter\r\n    function unblockTokens(address _voter) internal {\r\n        if (tokensLocks[_voter] <= 0) throw;\r\n\r\n        tokensLocks[_voter] -= 1;\r\n        if (tokensLocks[_voter] == 0) {\r\n            dasToken.unblockAccount(_voter);\r\n        }\r\n    }\r\n\r\n    // create new proposal\r\n    function createProposal(\r\n        address _beneficiary,\r\n        uint256 _etherAmount,\r\n        string _description,\r\n        bytes _transactionBytecode\r\n    )\r\n        onlyCongressMembers\r\n        returns (uint256 _proposalID)\r\n    {\r\n        _proposalID = proposals.length;\r\n        proposals.length += 1;\r\n        proposalsNumber = _proposalID + 1;\r\n\r\n        proposals[_proposalID].beneficiary = _beneficiary;\r\n        proposals[_proposalID].etherAmount = _etherAmount;\r\n        proposals[_proposalID].description = _description;\r\n        proposals[_proposalID].proposalHash = getProposalHash(_beneficiary, _etherAmount, _transactionBytecode);\r\n        proposals[_proposalID].state = ProposalState.Proposed;\r\n        proposals[_proposalID].votingDeadline = now + debatingPeriod * 1 seconds;\r\n        proposals[_proposalID].votesNumber = 0;\r\n\r\n        ProposalAddedEvent(_proposalID, _beneficiary, _etherAmount, _description);\r\n\r\n        return _proposalID;\r\n    }\r\n\r\n    // vote for an proposal\r\n    function vote(\r\n        uint256 _proposalID,\r\n        bool _inSupport,\r\n        string _justificationText\r\n    )\r\n        onlyCongressMembers\r\n    {\r\n        Proposal p = proposals[_proposalID];\r\n\r\n        if (p.state != ProposalState.Proposed) throw;\r\n        if (p.voted[msg.sender] == true) throw;\r\n\r\n        var voterTokens = dasToken.balanceOf(msg.sender);\r\n        blockTokens(msg.sender);\r\n\r\n        p.voted[msg.sender] = true;\r\n        p.votes.push(Vote(msg.sender, _inSupport, voterTokens, _justificationText));\r\n        p.votesNumber += 1;\r\n\r\n        VotedEvent(_proposalID, msg.sender, _inSupport, voterTokens, _justificationText);\r\n    }\r\n\r\n    // finish voting on an proposal\r\n    function finishProposalVoting(uint256 _proposalID) onlyCongressMembers {\r\n        Proposal p = proposals[_proposalID];\r\n\r\n        if (now < p.votingDeadline) throw;\r\n        if (p.state != ProposalState.Proposed) throw;\r\n\r\n        var _votesNumber = p.votes.length;\r\n        uint256 tokensFor = 0;\r\n        uint256 tokensAgainst = 0;\r\n        for (uint256 i = 0; i < _votesNumber; i++) {\r\n            if (p.votes[i].inSupport) {\r\n                tokensFor += p.votes[i].voterTokens;\r\n            }\r\n            else {\r\n                tokensAgainst += p.votes[i].voterTokens;\r\n            }\r\n\r\n            unblockTokens(p.votes[i].voter);\r\n        }\r\n\r\n        if ((tokensFor + tokensAgainst) < minimumQuorum) {\r\n            p.state = ProposalState.NoQuorum;\r\n            ProposalTalliedEvent(_proposalID, false, false);\r\n            return;\r\n        }\r\n        if ((tokensFor - tokensAgainst) < marginForMajority) {\r\n            p.state = ProposalState.Rejected;\r\n            ProposalTalliedEvent(_proposalID, true, false);\r\n            return;\r\n        }\r\n        p.state = ProposalState.Passed;\r\n        ProposalTalliedEvent(_proposalID, true, true);\r\n        return;\r\n    }\r\n\r\n    // execute passed proposal\r\n    function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {\r\n        Proposal p = proposals[_proposalID];\r\n\r\n        if (p.state != ProposalState.Passed) throw;\r\n\r\n        p.state = ProposalState.Executed;\r\n        if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) {\r\n            throw;\r\n        }\r\n\r\n        ProposalExecutedEvent(_proposalID);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"etherAmount\",\"type\":\"uint256\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"proposalHash\",\"type\":\"bytes32\"},{\"name\":\"state\",\"type\":\"uint8\"},{\"name\":\"votingDeadline\",\"type\":\"uint256\"},{\"name\":\"votesNumber\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"},{\"name\":\"_transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"executeProposal\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"debatingPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_etherAmount\",\"type\":\"uint256\"},{\"name\":\"_description\",\"type\":\"string\"},{\"name\":\"_transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"createProposal\",\"outputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dasToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marginForMajority\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumQuorum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"}],\"name\":\"finishProposalVoting\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"congressMemberThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"},{\"name\":\"_inSupport\",\"type\":\"bool\"},{\"name\":\"_justificationText\",\"type\":\"string\"}],\"name\":\"vote\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"abcToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_etherAmount\",\"type\":\"uint256\"},{\"name\":\"_transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"getProposalHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_congressMemberThreshold\",\"type\":\"uint256\"},{\"name\":\"_minimumQuorum\",\"type\":\"uint256\"},{\"name\":\"_debatingPeriod\",\"type\":\"uint256\"},{\"name\":\"_marginForMajority\",\"type\":\"uint256\"},{\"name\":\"_congressLeader\",\"type\":\"address\"}],\"payable\":true,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"}],\"name\":\"ProposalAddedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"inSupport\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"voterTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"justificationText\",\"type\":\"string\"}],\"name\":\"VotedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"quorum\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"bool\"}],\"name\":\"ProposalTalliedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalID\",\"type\":\"uint256\"}],\"name\":\"ProposalExecutedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"congressMemberThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"minimumQuorum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"debatingPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"marginForMajority\",\"type\":\"uint256\"}],\"name\":\"RulesChangedEvent\",\"type\":\"event\"}]","ContractName":"DAS","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000d3c21bcecceda100000000000000000000000000000000000000000000000052b7d2dcc80cd2e40000000000000000000000000000000000000000000000000000000000000000002710000000000000000000000000000000000000000000084595161401484a0000000000000000000000000000008e090955f93376bdd758464f80920f8567d0152a","Library":"","SwarmSource":"bzzr://31ab05cf84f0c2da9981a1e10baadc3bbf62105c99d7acef8c1c5df4719c7553"}]}