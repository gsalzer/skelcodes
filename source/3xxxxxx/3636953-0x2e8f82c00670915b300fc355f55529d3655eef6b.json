{"status":"1","message":"OK","result":[{"SourceCode":"contract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n}\r\n\r\n\r\n///This is the blockchain side of the notifier. Here so that payment, registering,etc is painless async and\r\n/// most importantly *trustless* since you can exit at any time taking your funds having lost nothing\r\n\r\n///@author kingcocomango@gmail.com\r\n///@title Price notifier\r\ncontract Tracker is Ownable{\r\n    // This represents a client in the simplest form\r\n    // Only tracks a single currency pair, hardcoded\r\n    struct SimpleClient{\r\n        uint8 ratio;// ratio trigger\r\n        uint dosh;// Clients dosh\r\n        string Hash;// phone number as a utf-8 string, or a hash of one from webservice\r\n        uint time;// last time client was debited. Starts as creation time\r\n    }\r\n    \r\n    // This is the mapping between eth addr and client structs\r\n    mapping(address => SimpleClient) public Clients;\r\n    // This is used to store the current total obligations to clients\r\n    uint public obligations;\r\n    \r\n    // Events for clients registering and leaving\r\n    // This means recognizing the set of current clients, for sending and debiting can be done off-chain\r\n    event ClientRegistered(address Client);\r\n    event ClientExited(address Client);\r\n    \r\n    // Constants used for configuration\r\n    uint constant Period = 1 days; // amount of time between debits ERROR set these values for release\r\n    uint constant Fee = 1 finney; // amount debited per period\r\n    uint8 constant MininumPercent = 5; // this is the minimum ratio allowed. TODO set to 5 for sms contract\r\n\r\n    \r\n    // This function registers a new client, and can be used to add funds or change ratio\r\n    function Register(uint8 ratio, string Hash) payable external {\r\n        var NewClient = SimpleClient(ratio>=MininumPercent?ratio:MininumPercent, msg.value, Hash, now); // create new client\r\n        // note that ratio is not allowed to be smaller than MininumPercent%\r\n        // In case someone registers over themselves, keep their money around\r\n        NewClient.dosh += Clients[msg.sender].dosh; // keep their old account running\r\n        Clients[msg.sender] = NewClient; // register them\r\n        // notify the listners\r\n        ClientRegistered(msg.sender);\r\n        // and increment current total obligations\r\n        obligations += msg.value;\r\n        \r\n    }\r\n    // This function is used to stop using the service\r\n    function Exit() external {\r\n        uint tosend = Clients[msg.sender].dosh;\r\n        // And remove the money they withdrew from our obligations\r\n        obligations -= tosend;\r\n        // if the sending fails, all of this unwinds.\r\n        Clients[msg.sender].dosh= 0; // we set it here to its safe to send money\r\n        // Notify listners client has left\r\n        ClientExited(msg.sender);\r\n        // send to the caller the money their structure says they have\r\n        msg.sender.transfer(tosend);\r\n        \r\n    }\r\n    // This function is used to change the phone number in the service\r\n    function ChangeNumber(string NewHash) external { // The way this modifies state is invisible to the contract,so no problemo\r\n        Clients[msg.sender].Hash = NewHash;\r\n        ClientExited(msg.sender);\r\n        ClientRegistered(msg.sender); // This cheap sequence of events changes the number, and notifies the backend service\r\n    }\r\n    // Used to charge a client\r\n    function DebitClient(address client) external{// since owner is provable an EOC, cant abuse reentrancy\r\n        uint TotalFee;\r\n        uint timedif = now-Clients[client].time; // how long since last call on this client\r\n        uint periodmulti = timedif/Period; // How many periods passed\r\n        if(periodmulti>0){ // timedif is >= Period\r\n          TotalFee = Fee*periodmulti; // 1 period fee per multiple of period\r\n        }else{// it was smaller than period. Wasted gas\r\n          throw;\r\n        }\r\n        if(Clients[client].dosh < TotalFee){ // not enough\r\n          throw;\r\n        }\r\n        Clients[client].dosh -= TotalFee;\r\n        obligations -= TotalFee;\r\n        Clients[client].time += Period*periodmulti; // client got charged for periodmulti periods, so add that to their time paid\r\n    }\r\n    // used to charge for a single time period, in case client doesnt have enough dosh to pay all fees \r\n    function DebitClientOnce(address client) external{// since owner is provable an EOC, cant abuse reentrancy\r\n        uint timedif = now-Clients[client].time; // how long since last call on this client\r\n        if(timedif<Period){ // too soon, wasted.\r\n          throw;\r\n        }\r\n        if(Clients[client].dosh < Fee){ // not enough\r\n          throw;\r\n        }\r\n        Clients[client].dosh -= Fee;\r\n        obligations -= Fee;\r\n        Clients[client].time += Period; // client got charged for 1 period, so add that to their time paid\r\n    }\r\n    \r\n    // This function is used to withdraw ether\r\n    function Withdraw(uint amount) onlyOwner external{ // since owner is provable an EOC, cant abuse reentrancy\r\n        if(this.balance <= obligations){ // this should probably be removed from production code. But theoretically it can never happen\r\n            throw; // Somehow, we cant even cover our obligations. This means something very wrong has happened\r\n            selfdestruct(owner);// This should be impossible, but it means I can manually reimburse if SHTF\r\n        }\r\n        if((this.balance - obligations) <= amount ){// available balance doesnt cover withdrawal\r\n            throw; // not allowed\r\n        }\r\n        owner.transfer(amount);// All checks passed, take the money\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"client\",\"type\":\"address\"}],\"name\":\"DebitClient\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ratio\",\"type\":\"uint8\"},{\"name\":\"Hash\",\"type\":\"string\"}],\"name\":\"Register\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"obligations\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"NewHash\",\"type\":\"string\"}],\"name\":\"ChangeNumber\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"Clients\",\"outputs\":[{\"name\":\"ratio\",\"type\":\"uint8\"},{\"name\":\"dosh\",\"type\":\"uint256\"},{\"name\":\"Hash\",\"type\":\"string\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"client\",\"type\":\"address\"}],\"name\":\"DebitClientOnce\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Exit\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"Client\",\"type\":\"address\"}],\"name\":\"ClientRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"Client\",\"type\":\"address\"}],\"name\":\"ClientExited\",\"type\":\"event\"}]","ContractName":"Tracker","CompilerVersion":"v0.4.10+commit.f0d539ae","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://889ee1156c330c95de6638caa051ab4b1e830f7a9b68f346da81e8d6fd0bae17"}]}