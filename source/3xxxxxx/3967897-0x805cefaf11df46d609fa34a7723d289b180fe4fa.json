{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *  NTRY Cointract contract, ERC20 compliant (see https://github.com/ethereum/EIPs/issues/20)\r\n *\r\n *  Code is based on multiple sources:\r\n *  https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts\r\n *  https://github.com/TokenMarketNet/ico/blob/master/contracts\r\n *  https://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts\r\n */\r\npragma solidity ^0.4.11;\r\n\r\n/**\r\n * Centrally issued Ethereum token.\r\n *\r\n * We mix in burnable and upgradeable traits.\r\n *\r\n * Token supply is created in the token contract creation and allocated to owner.\r\n * The owner can then transfer from its supply to crowdsale participants.\r\n * The owner, or anybody, can burn any excessive tokens they are holding.\r\n *\r\n */\r\n\r\n/**\r\n *  NTRY Cointract contract, ERC20 compliant (see https://github.com/ethereum/EIPs/issues/20)\r\n *\r\n *  Code is based on multiple sources:\r\n *  https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts\r\n *  https://github.com/TokenMarketNet/ico/blob/master/contracts\r\n *  https://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts\r\n */\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant returns (uint256);\r\n  function transfer(address to, uint256 value) returns (bool success);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n *  NTRY Cointract contract, ERC20 compliant (see https://github.com/ethereum/EIPs/issues/20)\r\n *\r\n *  Code is based on multiple sources:\r\n *  https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts\r\n *  https://github.com/TokenMarketNet/ico/blob/master/contracts\r\n *  https://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts\r\n */\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) returns (bool success);\r\n  function approve(address spender, uint256 value) returns (bool success);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n *  NTRY Cointract contract, ERC20 compliant (see https://github.com/ethereum/EIPs/issues/20)\r\n *\r\n *  Code is based on multiple sources:\r\n *  https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts\r\n *  https://github.com/TokenMarketNet/ico/blob/master/contracts\r\n *  https://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts\r\n */\r\n\r\ncontract ErrorHandler {\r\n    bool public isInTestMode = false;\r\n    event evRecord(address msg_sender, uint msg_value, string message);\r\n\r\n    function doThrow(string message) internal {\r\n        evRecord(msg.sender, msg.value, message);\r\n        if (!isInTestMode) {\r\n        \tthrow;\r\n\t\t}\r\n    }\r\n}\r\n\r\n/**\r\n *  NTRY Cointract contract, ERC20 compliant (see https://github.com/ethereum/EIPs/issues/20)\r\n *\r\n *  Code is based on multiple sources:\r\n *  https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts\r\n *  https://github.com/TokenMarketNet/ico/blob/master/contracts\r\n *  https://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts\r\n */\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n *  NTRY Cointract contract, ERC20 compliant (see https://github.com/ethereum/EIPs/issues/20)\r\n *\r\n *  Code is based on multiple sources:\r\n *  https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts\r\n *  https://github.com/TokenMarketNet/ico/blob/master/contracts\r\n *  https://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts\r\n */\r\n\r\n\r\n/**\r\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\r\n *\r\n * Based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract NTRYStandardToken is ERC20, ErrorHandler {\r\n  address public owner;\r\n\r\n  /* NTRY functional is paused if there is any emergency */\r\n  bool public emergency = false;\r\n\r\n  using SafeMath for uint;\r\n\r\n  /* Actual balances of token holders */\r\n  mapping(address => uint) balances;\r\n\r\n  /* approve() allowances */\r\n  mapping (address => mapping (address => uint)) allowed;\r\n  \r\n  /* freezeAccount() frozen() */\r\n  mapping (address => bool) frozenAccount;\r\n\r\n  /* Notify account frozen activity */\r\n  event FrozenFunds(address target, bool frozen);\r\n\r\n  /* Interface declaration */\r\n  function isToken() public constant returns (bool weAre) {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner. \r\n   */\r\n  modifier onlyOwner() {\r\n    if (msg.sender != owner) {\r\n      doThrow(\"Only Owner!\");\r\n    }\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Fix for the ERC20 short address attack\r\n   *\r\n   * http://vessenes.com/the-erc20-short-address-attack-explained/\r\n   */\r\n  modifier onlyPayloadSize(uint size) {\r\n     if(msg.data.length < size + 4) {\r\n       doThrow(\"Short address attack!\");\r\n     }\r\n     _;\r\n  }\r\n\r\n  modifier stopInEmergency {\r\n    if (emergency){\r\n        doThrow(\"Emergency state!\");\r\n    }\r\n    _;\r\n  }\r\n  \r\n  function transfer(address _to, uint _value) stopInEmergency onlyPayloadSize(2 * 32) returns (bool success) {\r\n    // Check if frozen //\r\n    if (frozenAccount[msg.sender]) doThrow(\"Account freezed!\");  \r\n                  \r\n    balances[msg.sender] = balances[msg.sender].sub( _value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) stopInEmergency returns (bool success) {\r\n    // Check if frozen //\r\n    if (frozenAccount[_from]) doThrow(\"Account freezed!\");\r\n\r\n    uint _allowance = allowed[_from][msg.sender];\r\n\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) stopInEmergency returns (bool success) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) doThrow(\"Allowance race condition!\");\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n\r\n  /**\r\n  * It is called Circuit Breakers (Pause contract functionality), it stop execution if certain conditions are met, \r\n  * and can be useful when new errors are discovered. For example, most actions may be suspended in a contract if a \r\n  * bug is discovered, so the most feasible option to stop and updated migration message about launching an updated version of contract. \r\n  * @param _stop Switch the circuite breaker on or off\r\n  */\r\n  function emergencyStop(bool _stop) onlyOwner {\r\n      emergency = _stop;\r\n  }\r\n\r\n  /**\r\n  * Owner can set any account into freeze state. It is helpful in case if account holder has \r\n  * lost his key and he want administrator to freeze account until account key is recovered\r\n  * @param target The account address\r\n  * @param freeze The state of account\r\n  */\r\n  function freezeAccount(address target, bool freeze) onlyOwner {\r\n      frozenAccount[target] = freeze;\r\n      FrozenFunds(target, freeze);\r\n  }\r\n\r\n  function frozen(address _target) constant returns (bool frozen) {\r\n    return frozenAccount[_target];\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to. \r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      balances[newOwner] = balances[owner];\r\n      balances[owner] = 0;\r\n      owner = newOwner;\r\n      Transfer(owner, newOwner,balances[newOwner]);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n *  NTRY Cointract contract, ERC20 compliant (see https://github.com/ethereum/EIPs/issues/20)\r\n *\r\n *  Code is based on multiple sources:\r\n *  https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts\r\n *  https://github.com/TokenMarketNet/ico/blob/master/contracts\r\n *  https://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts\r\n */\r\n\r\n/**\r\n * Upgrade agent interface inspired by Lunyr.\r\n *\r\n * Upgrade agent transfers tokens to a new contract.\r\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\r\n */\r\ncontract UpgradeAgent {\r\n\r\n  uint public originalSupply;\r\n\r\n  /** Interface marker */\r\n  function isUpgradeAgent() public constant returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  function upgradeFrom(address _from, uint256 _value) public;\r\n\r\n}\r\n\r\n\r\n/**\r\n *  NTRY Cointract contract, ERC20 compliant (see https://github.com/ethereum/EIPs/issues/20)\r\n *\r\n *  Code is based on multiple sources:\r\n *  https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts\r\n *  https://github.com/TokenMarketNet/ico/blob/master/contracts\r\n *  https://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts\r\n */\r\n\r\n\r\n/**\r\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\r\n *\r\n * First envisioned by Golem and Lunyr projects.\r\n */\r\ncontract UpgradeableToken is NTRYStandardToken {\r\n\r\n  /** Contract / person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */\r\n  address public upgradeMaster;\r\n\r\n  /** The next contract where the tokens will be migrated. */\r\n  UpgradeAgent public upgradeAgent;\r\n\r\n  /** How many tokens we have upgraded by now. */\r\n  uint256 public totalUpgraded;\r\n\r\n  /**\r\n   * Upgrade states.\r\n   *\r\n   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\r\n   * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet\r\n   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet\r\n   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\r\n   *\r\n   */\r\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\r\n\r\n  /**\r\n   * Somebody has upgraded some of his tokens.\r\n   */\r\n  event Upgrade(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n  /**\r\n   * New upgrade agent available.\r\n   */\r\n  event UpgradeAgentSet(address agent);\r\n\r\n  /**\r\n   * Do not allow construction without upgrade master set.\r\n   */\r\n  function UpgradeableToken(address _upgradeMaster) {\r\n    upgradeMaster = _upgradeMaster;\r\n  }\r\n\r\n  /**\r\n   * Allow the token holder to upgrade some of their tokens to a new contract.\r\n   */\r\n  function upgrade(uint256 value) public {\r\n\r\n      UpgradeState state = getUpgradeState();\r\n      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\r\n        doThrow(\"Called in a bad state!\");\r\n      }\r\n\r\n      // Validate input value.\r\n      if (value == 0) doThrow(\"Value to upgrade is zero!\");\r\n\r\n      balances[msg.sender] = balances[msg.sender].sub(value);\r\n\r\n      // Take tokens out from circulation\r\n      totalSupply = totalSupply.sub(value);\r\n      totalUpgraded = totalUpgraded.add(value);\r\n\r\n      // Upgrade agent reissues the tokens\r\n      upgradeAgent.upgradeFrom(msg.sender, value);\r\n      Upgrade(msg.sender, upgradeAgent, value);\r\n  }\r\n\r\n  /**\r\n   * Set an upgrade agent that handles\r\n   */\r\n  function setUpgradeAgent(address agent) external {\r\n\r\n      if(!canUpgrade()) {\r\n        // The token is not yet in a state that we could think upgrading\r\n        doThrow(\"Token state is not feasible for upgrading yet!\");\r\n      }\r\n\r\n      if (agent == 0x0) doThrow(\"Invalid address!\");\r\n      // Only a master can designate the next agent\r\n      if (msg.sender != upgradeMaster) doThrow(\"Only upgrade master!\");\r\n      // Upgrade has already begun for an agent\r\n      if (getUpgradeState() == UpgradeState.Upgrading) doThrow(\"Upgrade started already!\");\r\n\r\n      upgradeAgent = UpgradeAgent(agent);\r\n\r\n      // Bad interface\r\n      if(!upgradeAgent.isUpgradeAgent()) doThrow(\"Bad interface!\");\r\n      // Make sure that token supplies match in source and target\r\n      if (upgradeAgent.originalSupply() != totalSupply) doThrow(\"Total supply source is not equall to target!\");\r\n\r\n      UpgradeAgentSet(upgradeAgent);\r\n  }\r\n\r\n  /**\r\n   * Get the state of the token upgrade.\r\n   */\r\n  function getUpgradeState() public constant returns(UpgradeState) {\r\n    if(!canUpgrade()) return UpgradeState.NotAllowed;\r\n    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\r\n    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\r\n    else return UpgradeState.Upgrading;\r\n  }\r\n\r\n  /**\r\n   * Change the upgrade master.\r\n   *\r\n   * This allows us to set a new owner for the upgrade mechanism.\r\n   */\r\n  function setUpgradeMaster(address master) public {\r\n      if (master == 0x0) doThrow(\"Invalid address of upgrade master!\");\r\n      if (msg.sender != upgradeMaster) doThrow(\"Only upgrade master!\");\r\n      upgradeMaster = master;\r\n  }\r\n\r\n  /**\r\n   * Child contract can enable to provide the condition when the upgrade can begun.\r\n   */\r\n  function canUpgrade() public constant returns(bool) {\r\n     return true;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n *  NTRY Cointract contract, ERC20 compliant (see https://github.com/ethereum/EIPs/issues/20)\r\n *\r\n *  Code is based on multiple sources:\r\n *  https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts\r\n *  https://github.com/TokenMarketNet/ico/blob/master/contracts\r\n *  https://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts\r\n */\r\n\r\n\r\ncontract BurnableToken is NTRYStandardToken {\r\n\r\n  address public constant BURN_ADDRESS = 0;\r\n\r\n  /** How many tokens we burned */\r\n  event Burned(address burner, uint burnedAmount);\r\n\r\n  /**\r\n   * Burn extra tokens from a balance.\r\n   *\r\n   */\r\n  function burn(uint burnAmount) {\r\n    address burner = msg.sender;\r\n    balances[burner] = balances[burner].sub(burnAmount);\r\n    totalSupply = totalSupply.sub(burnAmount);\r\n    Burned(burner, burnAmount);\r\n  }\r\n}\r\n\r\n\r\ncontract CentrallyIssuedToken is BurnableToken, UpgradeableToken {\r\n\r\n  string public name;\r\n  string public symbol;\r\n  uint public decimals;\r\n\r\n  function CentrallyIssuedToken() UpgradeableToken(owner) {\r\n    name = \"Notary Platform Token\";\r\n    symbol = \"NTRY\";\r\n    decimals = 18;\r\n    owner = 0x1538EF80213cde339A333Ee420a85c21905b1b2D;\r\n\r\n    totalSupply = 150000000 * 1 ether;\r\n    \r\n    // Allocate initial balance to the owner //\r\n    balances[owner] = 150000000 * 1 ether;\r\n\r\n    // Freeze notary team funds for one year (One month with pre ico already passed)//\r\n    unlockedAt =  now + 330 * 1 days;\r\n  }\r\n\r\n  uint256 public constant teamAllocations = 15000000 * 1 ether;\r\n  uint256 public unlockedAt;\r\n  mapping (address => uint256) allocations;\r\n  function allocate() public {\r\n      allocations[0xab1cb1740344A9280dC502F3B8545248Dc3045eA] = 2500000 * 1 ether;\r\n      allocations[0x330709A59Ab2D1E1105683F92c1EE8143955a357] = 2500000 * 1 ether;\r\n      allocations[0xAa0887fc6e8896C4A80Ca3368CFd56D203dB39db] = 2500000 * 1 ether;\r\n      allocations[0x1fbA1d22435DD3E7Fa5ba4b449CC550a933E72b3] = 2500000 * 1 ether;\r\n      allocations[0xC9d5E2c7e40373ae576a38cD7e62E223C95aBFD4] = 500000 * 1 ether;\r\n      allocations[0xabc0B64a38DE4b767313268F0db54F4cf8816D9C] = 500000 * 1 ether;\r\n      allocations[0x5d85bCDe5060C5Bd00DBeDF5E07F43CE3Ccade6f] = 250000 * 1 ether;\r\n      allocations[0xecb1b0231CBC0B04015F9e5132C62465C128B578] = 250000 * 1 ether;\r\n      allocations[0xF9b1Cfc7fe3B63bEDc594AD20132CB06c18FD5F2] = 250000 * 1 ether;\r\n      allocations[0xDbb89a87d9f91EA3f0Ab035a67E3A951A05d0130] = 250000 * 1 ether;\r\n      allocations[0xC1530645E21D27AB4b567Bac348721eE3E244Cbd] = 200000 * 1 ether;\r\n      allocations[0xcfb44162030e6CBca88e65DffA21911e97ce8533] = 200000 * 1 ether;\r\n      allocations[0x64f748a5C5e504DbDf61d49282d6202Bc1311c3E] = 200000 * 1 ether;\r\n      allocations[0xFF22FA2B3e5E21817b02a45Ba693B7aC01485a9C] = 200000 * 1 ether;\r\n      allocations[0xC9856112DCb8eE449B83604438611EdCf61408AF] = 200000 * 1 ether;\r\n      allocations[0x689CCfEABD99081D061aE070b1DA5E1f6e4B9fB2] = 2000000 * 1 ether;\r\n  }\r\n\r\n  function withDraw() public {\r\n      if(now < unlockedAt){ \r\n          doThrow(\"Allocations are freezed!\");\r\n      }\r\n      if (allocations[msg.sender] == 0){\r\n          doThrow(\"No allocation found!\");\r\n      }\r\n      balances[owner] -= allocations[msg.sender];\r\n      balances[msg.sender] += allocations[msg.sender];\r\n      Transfer(owner, msg.sender, allocations[msg.sender]);\r\n      allocations[msg.sender] = 0;\r\n      \r\n  }\r\n  \r\n   function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n  \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stop\",\"type\":\"bool\"}],\"name\":\"emergencyStop\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withDraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeMaster\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUpgradeState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamAllocations\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockedAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canUpgrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allocate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInTestMode\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUpgraded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"emergency\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"frozen\",\"outputs\":[{\"name\":\"frozen\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"setUpgradeAgent\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isToken\",\"outputs\":[{\"name\":\"weAre\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BURN_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"master\",\"type\":\"address\"}],\"name\":\"setUpgradeMaster\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"UpgradeAgentSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"burnedAmount\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"msg_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"}],\"name\":\"evRecord\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"CentrallyIssuedToken","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://85eda844e97315bb44c6be34968c64ff5ca6b094685cc9a3ef802137497864ef"}]}