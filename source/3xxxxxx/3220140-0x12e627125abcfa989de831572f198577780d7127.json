{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.4;\r\n\r\nlibrary ArrayLib{\r\n  function findAddress(address a, address[] storage arry) returns (int){\r\n    for (uint i = 0 ; i < arry.length ; i++){\r\n      if(arry[i] == a){return int(i);}\r\n    }\r\n    return -1;\r\n  }\r\n  function removeAddress(uint i, address[] storage arry){\r\n    uint lengthMinusOne = arry.length - 1;\r\n    arry[i] = arry[lengthMinusOne];\r\n    delete arry[lengthMinusOne];\r\n    arry.length = lengthMinusOne;\r\n  }\r\n}\r\n\r\ncontract Owned {\r\n  address public owner;\r\n  modifier onlyOwner(){ if (isOwner(msg.sender)) _; }\r\n  modifier ifOwner(address sender) { if(isOwner(sender)) _; }\r\n\r\n  function Owned(){ owner = msg.sender; }\r\n\r\n  function isOwner(address addr) public returns(bool) { return addr == owner; }\r\n\r\n  function transfer(address _owner) onlyOwner { owner = _owner; }\r\n}\r\n\r\ncontract Proxy is Owned {\r\n  event Forwarded (address indexed destination, uint value, bytes data );\r\n  event Received (address indexed sender, uint value);\r\n\r\n  function () payable { Received(msg.sender, msg.value); }\r\n\r\n  function forward(address destination, uint value, bytes data) onlyOwner {\r\n    if (!destination.call.value(value)(data)) { throw; }\r\n    Forwarded(destination, value, data);\r\n  }\r\n}\r\n\r\ncontract RecoverableController {\r\n  uint    public version;\r\n  Proxy   public proxy;\r\n\r\n  address public userKey;\r\n  address public proposedUserKey;\r\n  uint    public proposedUserKeyPendingUntil;\r\n\r\n  address public recoveryKey;\r\n  address public proposedRecoveryKey;\r\n  uint    public proposedRecoveryKeyPendingUntil;\r\n\r\n  address public proposedController;\r\n  uint    public proposedControllerPendingUntil;\r\n\r\n  uint    public shortTimeLock;// use 900 for 15 minutes\r\n  uint    public longTimeLock; // use 259200 for 3 days\r\n\r\n  event RecoveryEvent(string action, address initiatedBy);\r\n\r\n  modifier onlyUserKey() { if (msg.sender == userKey) _; }\r\n  modifier onlyRecoveryKey() { if (msg.sender == recoveryKey) _; }\r\n\r\n  function RecoverableController(address proxyAddress, address _userKey, uint _longTimeLock, uint _shortTimeLock) {\r\n    version = 1;\r\n    proxy = Proxy(proxyAddress);\r\n    userKey = _userKey;\r\n    shortTimeLock = _shortTimeLock;\r\n    longTimeLock = _longTimeLock;\r\n    recoveryKey = msg.sender;\r\n  }\r\n\r\n  function forward(address destination, uint value, bytes data) onlyUserKey {\r\n    proxy.forward(destination, value, data);\r\n  }\r\n  //pass 0x0 to cancel \r\n  function signRecoveryChange(address _proposedRecoveryKey) onlyUserKey{\r\n    proposedRecoveryKeyPendingUntil = now + longTimeLock;\r\n    proposedRecoveryKey = _proposedRecoveryKey;\r\n    RecoveryEvent(\"signRecoveryChange\", msg.sender);\r\n  }\r\n  function changeRecovery() {\r\n    if(proposedRecoveryKeyPendingUntil < now && proposedRecoveryKey != 0x0){\r\n      recoveryKey = proposedRecoveryKey;\r\n      delete proposedRecoveryKey;\r\n    }\r\n  }\r\n  //pass 0x0 to cancel \r\n  function signControllerChange(address _proposedController) onlyUserKey{\r\n    proposedControllerPendingUntil = now + longTimeLock;\r\n    proposedController = _proposedController;\r\n    RecoveryEvent(\"signControllerChange\", msg.sender);\r\n  }\r\n  function changeController() {\r\n    if(proposedControllerPendingUntil < now && proposedController != 0x0){\r\n      proxy.transfer(proposedController);\r\n      suicide(proposedController);\r\n    }\r\n  }\r\n  //pass 0x0 to cancel \r\n  function signUserKeyChange(address _proposedUserKey) onlyUserKey{\r\n    proposedUserKeyPendingUntil = now + shortTimeLock;\r\n    proposedUserKey = _proposedUserKey;\r\n    RecoveryEvent(\"signUserKeyChange\", msg.sender);\r\n  }\r\n  function changeUserKey(){\r\n    if(proposedUserKeyPendingUntil < now && proposedUserKey != 0x0){\r\n      userKey = proposedUserKey;\r\n      delete proposedUserKey;\r\n      RecoveryEvent(\"changeUserKey\", msg.sender);\r\n    }\r\n  }\r\n  \r\n  function changeRecoveryFromRecovery(address _recoveryKey) onlyRecoveryKey{ recoveryKey = _recoveryKey; }\r\n  function changeUserKeyFromRecovery(address _userKey) onlyRecoveryKey{\r\n    delete proposedUserKey;\r\n    userKey = _userKey;\r\n  }\r\n}\r\n\r\ncontract RecoveryQuorum {\r\n  RecoverableController public controller;\r\n\r\n  address[] public delegateAddresses; // needed for iteration of mapping\r\n  mapping (address => Delegate) public delegates;\r\n  struct Delegate{\r\n    uint deletedAfter; // delegate exists if not 0\r\n    uint pendingUntil;\r\n    address proposedUserKey;\r\n  }\r\n\r\n  event RecoveryEvent(string action, address initiatedBy);\r\n\r\n  modifier onlyUserKey(){ if (msg.sender == controller.userKey()) _; }\r\n\r\n  function RecoveryQuorum(address _controller, address[] _delegates){\r\n    controller = RecoverableController(_controller);\r\n    for(uint i = 0; i < _delegates.length; i++){\r\n      delegateAddresses.push(_delegates[i]);\r\n      delegates[_delegates[i]] = Delegate({proposedUserKey: 0x0, pendingUntil: 0, deletedAfter: 31536000000000});\r\n    }\r\n  }\r\n  function signUserChange(address proposedUserKey) {\r\n    if(delegateRecordExists(delegates[msg.sender])) {\r\n      delegates[msg.sender].proposedUserKey = proposedUserKey;\r\n      changeUserKey(proposedUserKey);\r\n      RecoveryEvent(\"signUserChange\", msg.sender);\r\n    }\r\n  }\r\n  function changeUserKey(address newUserKey) {\r\n    if(collectedSignatures(newUserKey) >= neededSignatures()){\r\n      controller.changeUserKeyFromRecovery(newUserKey);\r\n      for(uint i = 0 ; i < delegateAddresses.length ; i++){\r\n        //remove any pending delegates after a recovery\r\n        if(delegates[delegateAddresses[i]].pendingUntil > now){ \r\n            delegates[delegateAddresses[i]].deletedAfter = now;\r\n        }\r\n        delete delegates[delegateAddresses[i]].proposedUserKey;\r\n      }\r\n    }\r\n  }\r\n\r\n  function replaceDelegates(address[] delegatesToRemove, address[] delegatesToAdd) onlyUserKey{\r\n    for(uint i = 0 ; i < delegatesToRemove.length ; i++){\r\n      removeDelegate(delegatesToRemove[i]);\r\n    }\r\n    garbageCollect();\r\n    for(uint j = 0 ; j < delegatesToAdd.length ; j++){\r\n      addDelegate(delegatesToAdd[j]);\r\n    }\r\n    RecoveryEvent(\"replaceDelegates\", msg.sender);\r\n  }\r\n  function collectedSignatures(address _proposedUserKey) returns (uint signatures){\r\n    for(uint i = 0 ; i < delegateAddresses.length ; i++){\r\n      if (delegateHasValidSignature(delegates[delegateAddresses[i]]) && delegates[delegateAddresses[i]].proposedUserKey == _proposedUserKey){\r\n        signatures++;\r\n      }\r\n    }\r\n  }\r\n\r\n  function getAddresses() constant returns (address[]){ return delegateAddresses; }\r\n\r\n  function neededSignatures() returns (uint){\r\n    uint currentDelegateCount; //always 0 at this point\r\n    for(uint i = 0 ; i < delegateAddresses.length ; i++){\r\n      if(delegateIsCurrent(delegates[delegateAddresses[i]])){ currentDelegateCount++; }\r\n    }\r\n    return currentDelegateCount/2 + 1;\r\n  }\r\n  function addDelegate(address delegate) private {\r\n    if(!delegateRecordExists(delegates[delegate]) && delegateAddresses.length < 15) {\r\n      delegates[delegate] = Delegate({proposedUserKey: 0x0, pendingUntil: now + controller.longTimeLock(), deletedAfter: 31536000000000});\r\n      delegateAddresses.push(delegate);\r\n    }\r\n  }\r\n  function removeDelegate(address delegate) private {\r\n    if(delegates[delegate].deletedAfter > controller.longTimeLock() + now){ \r\n      //remove right away if they are still pending\r\n      if(delegates[delegate].pendingUntil > now){ \r\n        delegates[delegate].deletedAfter = now;\r\n      } else{\r\n        delegates[delegate].deletedAfter = controller.longTimeLock() + now;\r\n      }\r\n    }\r\n  }\r\n  function garbageCollect() private{\r\n    uint i = 0;\r\n    while(i < delegateAddresses.length){\r\n      if(delegateIsDeleted(delegates[delegateAddresses[i]])){\r\n        delegates[delegateAddresses[i]].deletedAfter = 0;\r\n        delegates[delegateAddresses[i]].pendingUntil = 0;\r\n        delegates[delegateAddresses[i]].proposedUserKey = 0;\r\n        ArrayLib.removeAddress(i, delegateAddresses);\r\n      }else{i++;}\r\n    }\r\n  }\r\n  function delegateRecordExists(Delegate d) private returns (bool){\r\n      return d.deletedAfter != 0;\r\n  }\r\n  function delegateIsDeleted(Delegate d) private returns (bool){\r\n      return d.deletedAfter <= now; //doesnt check record existence\r\n  }\r\n  function delegateIsCurrent(Delegate d) private returns (bool){\r\n      return delegateRecordExists(d) && !delegateIsDeleted(d) && now > d.pendingUntil;\r\n  }\r\n  function delegateHasValidSignature(Delegate d) private returns (bool){\r\n      return delegateIsCurrent(d) && d.proposedUserKey != 0x0;\r\n  }\r\n}\r\n\r\ncontract IdentityFactory {\r\n    event IdentityCreated(\r\n        address indexed userKey,\r\n        address proxy,\r\n        address controller,\r\n        address recoveryQuorum);\r\n\r\n    mapping(address => address) public senderToProxy;\r\n\r\n    //cost ~2.4M gas\r\n    function CreateProxyWithControllerAndRecovery(address userKey, address[] delegates, uint longTimeLock, uint shortTimeLock) {\r\n        Proxy proxy = new Proxy();\r\n        RecoverableController controller = new RecoverableController(proxy, userKey, longTimeLock, shortTimeLock);\r\n        proxy.transfer(controller);\r\n        RecoveryQuorum recoveryQuorum = new RecoveryQuorum(controller, delegates);\r\n        controller.changeRecoveryFromRecovery(recoveryQuorum);\r\n\r\n        IdentityCreated(userKey, proxy, controller, recoveryQuorum);\r\n        senderToProxy[msg.sender] = proxy;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"userKey\",\"type\":\"address\"},{\"name\":\"delegates\",\"type\":\"address[]\"},{\"name\":\"longTimeLock\",\"type\":\"uint256\"},{\"name\":\"shortTimeLock\",\"type\":\"uint256\"}],\"name\":\"CreateProxyWithControllerAndRecovery\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"senderToProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"userKey\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"recoveryQuorum\",\"type\":\"address\"}],\"name\":\"IdentityCreated\",\"type\":\"event\"}]","ContractName":"IdentityFactory","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"ArrayLib:5BfA4582b0C48cb375B9E8322B57aC025965C148","SwarmSource":"bzzr://e1b71cf76459d7cfe06cb71b9eef4e63a0afb0310be59167efd0fa389ad1731c"}]}