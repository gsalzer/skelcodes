{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\ncontract OwnedByWinsome {\r\n\r\n  address public owner;\r\n  mapping (address => bool) allowedWorker;\r\n\r\n  function initOwnership(address _owner, address _worker) internal{\r\n    owner = _owner;\r\n    allowedWorker[_owner] = true;\r\n    allowedWorker[_worker] = true;\r\n  }\r\n\r\n  function allowWorker(address _new_worker) onlyOwner{\r\n    allowedWorker[_new_worker] = true;\r\n  }\r\n  function removeWorker(address _old_worker) onlyOwner{\r\n    allowedWorker[_old_worker] = false;\r\n  }\r\n  function changeOwner(address _new_owner) onlyOwner{\r\n    owner = _new_owner;\r\n  }\r\n\t\t\t\t\t\t    \r\n  modifier onlyAllowedWorker{\r\n    if (!allowedWorker[msg.sender]){\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  modifier onlyOwner{\r\n    if (msg.sender != owner){\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  \r\n}\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Basic token\r\n * Basic version of StandardToken, with no allowances\r\n */\r\ncontract BasicToken {\r\n  using SafeMath for uint;\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  mapping(address => uint) balances;\r\n  uint public     totalSupply =    0;    \t\t\t // Total supply of 500 million Tokens\r\n  \r\n  /*\r\n   * Fix for the ERC20 short address attack  \r\n   */\r\n  modifier onlyPayloadSize(uint size) {\r\n     if(msg.data.length < size + 4) {\r\n       throw;\r\n     }\r\n     _;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n  \r\n}\r\n\r\n\r\ncontract StandardToken is BasicToken{\r\n  \r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n  \r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  function transferFrom(address _from, address _to, uint _value) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // if (_value > _allowance) throw;\r\n\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n  }\r\n\r\n  function approve(address _spender, uint _value) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract WinToken is StandardToken, OwnedByWinsome{\r\n\r\n  string public   name =           \"Winsome.io Token\";\r\n  string public   symbol =         \"WIN\";\r\n  uint public     decimals =       18;\r\n  \r\n  mapping (address => bool) allowedMinter;\r\n\r\n  function WinToken(address _owner){\r\n    allowedMinter[_owner] = true;\r\n    initOwnership(_owner, _owner);\r\n  }\r\n\r\n  function allowMinter(address _new_minter) onlyOwner{\r\n    allowedMinter[_new_minter] = true;\r\n  }\r\n  function removeMinter(address _old_minter) onlyOwner{\r\n    allowedMinter[_old_minter] = false;\r\n  }\r\n\r\n  modifier onlyAllowedMinter{\r\n    if (!allowedMinter[msg.sender]){\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n  function mintTokens(address _for, uint _value_wei) onlyAllowedMinter {\r\n    balances[_for] = balances[_for].add(_value_wei);\r\n    totalSupply = totalSupply.add(_value_wei) ;\r\n    Transfer(address(0), _for, _value_wei);\r\n  }\r\n  function destroyTokens(address _for, uint _value_wei) onlyAllowedMinter {\r\n    balances[_for] = balances[_for].sub(_value_wei);\r\n    totalSupply = totalSupply.sub(_value_wei);\r\n    Transfer(_for, address(0), _value_wei);    \r\n  }\r\n  \r\n}\r\n\r\ncontract Rouleth\r\n{\r\n  //Game and Global Variables, Structure of gambles\r\n  address public developer;\r\n  uint8 public blockDelay; //nb of blocks to wait before spin\r\n  uint8 public blockExpiration; //nb of blocks before bet expiration (due to hash storage limits)\r\n  uint256 public maxGamble; //max gamble value manually set by config\r\n  uint256 public minGamble; //min gamble value manually set by config\r\n\r\n  mapping (address => uint) pendingTokens;\r\n  \r\n  address public WINTOKENADDRESS;\r\n  WinToken winTokenInstance;\r\n\r\n  uint public emissionRate;\r\n  \r\n  //Gambles\r\n  enum BetTypes{number, color, parity, dozen, column, lowhigh} \r\n  struct Gamble\r\n  {\r\n    address player;\r\n    bool spinned; //Was the rouleth spinned ?\r\n    bool win;\r\n    //Possible bet types\r\n    BetTypes betType;\r\n    uint input; //stores number, color, dozen or oddeven\r\n    uint256 wager;\r\n    uint256 blockNumber; //block of bet\r\n    uint256 blockSpinned; //block of spin\r\n    uint8 wheelResult;\r\n  }\r\n  Gamble[] private gambles;\r\n\r\n  //Tracking progress of players\r\n  mapping (address=>uint) gambleIndex; //current gamble index of the player\r\n  //records current status of player\r\n  enum Status {waitingForBet, waitingForSpin} mapping (address=>Status) playerStatus; \r\n\r\n\r\n  //**********************************************\r\n  //        Management & Config FUNCTIONS        //\r\n  //**********************************************\r\n\r\n  function  Rouleth(address _developer, address _winToken) //creation settings\r\n  {\r\n    WINTOKENADDRESS = _winToken;\r\n    winTokenInstance = WinToken(_winToken);\r\n    developer = _developer;\r\n    blockDelay=0; //indicates which block after bet will be used for RNG\r\n    blockExpiration=245; //delay after which gamble expires\r\n    minGamble=10 finney; //configurable min bet\r\n    maxGamble=1 ether; //configurable max bet\r\n    emissionRate = 5;\r\n  }\r\n    \r\n  modifier onlyDeveloper() \r\n  {\r\n    if (msg.sender!=developer) throw;\r\n    _;\r\n  }\r\n\r\n  function addBankroll()\r\n    onlyDeveloper\r\n    payable {\r\n  }\r\n\r\n  function removeBankroll(uint256 _amount_wei)\r\n    onlyDeveloper\r\n  {\r\n    if (!developer.send(_amount_wei)) throw;\r\n  }\r\n    \r\n  function changeDeveloper_only_Dev(address new_dev)\r\n    onlyDeveloper\r\n  {\r\n    developer=new_dev;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  //Change some settings within safety bounds\r\n  function changeSettings_only_Dev(uint256 newMinGamble, uint256 newMaxGamble, uint8 newBlockDelay, uint8 newBlockExpiration, uint newEmissionRate)\r\n    onlyDeveloper\r\n  {\r\n    emissionRate = newEmissionRate;\r\n    //MAX BET : limited by payroll/(casinoStatisticalLimit*35)\r\n    if (newMaxGamble<newMinGamble) throw;  \r\n    maxGamble=newMaxGamble; \r\n    minGamble=newMinGamble;\r\n    //Delay before spin :\r\n    blockDelay=newBlockDelay;\r\n    if (newBlockExpiration < blockDelay + 250) throw;\r\n    blockExpiration=newBlockExpiration;\r\n  }\r\n\r\n\r\n  //**********************************************\r\n  //                 BETTING FUNCTIONS                    //\r\n  //**********************************************\r\n\r\n  //***//basic betting without Mist or contract call\r\n  //activates when the player only sends eth to the contract\r\n  //without specifying any type of bet.\r\n  function ()\r\n    payable\r\n    {\r\n      //defaut bet : bet on red\r\n      betOnColor(false);\r\n    } \r\n\r\n  //***//Guarantees that gamble is under max bet and above min.\r\n  // returns bet value\r\n  function checkBetValue() private returns(uint256)\r\n  {\r\n    if (msg.value < minGamble) throw;\r\n    if (msg.value > maxGamble){\r\n      return maxGamble;\r\n    }\r\n    else{\r\n      return msg.value;\r\n    }\r\n  }\r\n\r\n\r\n\r\n  //Function record bet called by all others betting functions\r\n  function placeBet(BetTypes betType, uint input) private\r\n  {\r\n\r\n    if (playerStatus[msg.sender] != Status.waitingForBet) {\r\n      if (!SpinTheWheel(msg.sender)) throw;\r\n    }\r\n\r\n    //Once this is done, we can record the new bet\r\n    playerStatus[msg.sender] = Status.waitingForSpin;\r\n    gambleIndex[msg.sender] = gambles.length;\r\n    \r\n    //adapts wager to casino limits\r\n    uint256 betValue = checkBetValue();\r\n    pendingTokens[msg.sender] += betValue * emissionRate;\r\n\r\n    \r\n    gambles.push(Gamble(msg.sender, false, false, betType, input, betValue, block.number, 0, 37)); //37 indicates not spinned yet\r\n    \r\n    //refund excess bet (at last step vs re-entry)\r\n    if (betValue < msg.value) {\r\n      if (msg.sender.send(msg.value-betValue)==false) throw;\r\n    }\r\n  }\r\n\r\n  function getPendingTokens(address account) constant returns (uint){\r\n    return pendingTokens[account];\r\n  }\r\n  \r\n  function redeemTokens(){\r\n    uint totalTokens = pendingTokens[msg.sender];\r\n    if (totalTokens == 0) return;\r\n    pendingTokens[msg.sender] = 0;\r\n\r\n    //ADD POTENTIAL BONUS BASED ON How long waited!\r\n    \r\n    //mint WIN Tokens\r\n    winTokenInstance.mintTokens(msg.sender, totalTokens);\r\n  }\r\n\r\n  \r\n\r\n  //***//bet on Number\t\r\n  function betOnNumber(uint numberChosen)\r\n    payable\r\n  {\r\n    //check that number chosen is valid and records bet\r\n    if (numberChosen>36) throw;\r\n    placeBet(BetTypes.number, numberChosen);\r\n  }\r\n\r\n  //***// function betOnColor\r\n  //bet type : color\r\n  //input : 0 for red\r\n  //input : 1 for black\r\n  function betOnColor(bool Black)\r\n    payable\r\n  {\r\n    uint input;\r\n    if (!Black) \r\n      { \r\n\tinput=0;\r\n      }\r\n    else{\r\n      input=1;\r\n    }\r\n    placeBet(BetTypes.color, input);\r\n  }\r\n\r\n  //***// function betOnLow_High\r\n  //bet type : lowhigh\r\n  //input : 0 for low\r\n  //input : 1 for low\r\n  function betOnLowHigh(bool High)\r\n    payable\r\n  {\r\n    uint input;\r\n    if (!High) \r\n      { \r\n\tinput=0;\r\n      }\r\n    else \r\n      {\r\n\tinput=1;\r\n      }\r\n    placeBet(BetTypes.lowhigh, input);\r\n  }\r\n\r\n  //***// function betOnOddEven\r\n  //bet type : parity\r\n  //input : 0 for even\r\n  //input : 1 for odd\r\n  function betOnOddEven(bool Odd)\r\n    payable\r\n  {\r\n    uint input;\r\n    if (!Odd) \r\n      { \r\n\tinput=0;\r\n      }\r\n    else{\r\n      input=1;\r\n    }\r\n    placeBet(BetTypes.parity, input);\r\n  }\r\n\r\n  //***// function betOnDozen\r\n  //     //bet type : dozen\r\n  //     //input : 0 for first dozen\r\n  //     //input : 1 for second dozen\r\n  //     //input : 2 for third dozen\r\n  function betOnDozen(uint dozen_selected_0_1_2)\r\n    payable\r\n\r\n  {\r\n    if (dozen_selected_0_1_2 > 2) throw;\r\n    placeBet(BetTypes.dozen, dozen_selected_0_1_2);\r\n  }\r\n\r\n\r\n  // //***// function betOnColumn\r\n  //     //bet type : column\r\n  //     //input : 0 for first column\r\n  //     //input : 1 for second column\r\n  //     //input : 2 for third column\r\n  function betOnColumn(uint column_selected_0_1_2)\r\n    payable\r\n  {\r\n    if (column_selected_0_1_2 > 2) throw;\r\n    placeBet(BetTypes.column, column_selected_0_1_2);\r\n  }\r\n\r\n  //**********************************************\r\n  // Spin The Wheel & Check Result FUNCTIONS//\r\n  //**********************************************\r\n\r\n  event Win(address player, uint8 result, uint value_won, bytes32 bHash, bytes32 sha3Player, uint gambleId, uint bet);\r\n  event Loss(address player, uint8 result, uint value_loss, bytes32 bHash, bytes32 sha3Player, uint gambleId, uint bet);\r\n\r\n  //***//function to spin callable\r\n  // no eth allowed\r\n  function spinTheWheel(address spin_for_player)\r\n  {\r\n    SpinTheWheel(spin_for_player);\r\n  }\r\n\r\n\r\n  function SpinTheWheel(address playerSpinned) private returns(bool)\r\n  {\r\n    if (playerSpinned==0)\r\n      {\r\n\tplayerSpinned=msg.sender;         //if no index spins for the sender\r\n      }\r\n\r\n    //check that player has to spin\r\n    if (playerStatus[playerSpinned] != Status.waitingForSpin) return false;\r\n\r\n    //redundent double check : check that gamble has not been spinned already\r\n    if (gambles[gambleIndex[playerSpinned]].spinned == true) throw;\r\n\r\n    \r\n    //check that the player waited for the delay before spin\r\n    //and also that the bet is not expired\r\n    uint playerblock = gambles[gambleIndex[playerSpinned]].blockNumber;\r\n    //too early to spin\r\n    if (block.number <= playerblock+blockDelay) throw;\r\n    //too late, bet expired, player lost\r\n    else if (block.number > playerblock+blockExpiration) solveBet(playerSpinned, 255, false, 1, 0, 0) ;\r\n    //spin !\r\n    else\r\n      {\r\n\tuint8 wheelResult;\r\n\t//Spin the wheel, \r\n\tbytes32 blockHash= block.blockhash(playerblock+blockDelay);\r\n\t//security check that the Hash is not empty\r\n\tif (blockHash==0) throw;\r\n\t// generate the hash for RNG from the blockHash and the player's address\r\n\tbytes32 shaPlayer = sha3(playerSpinned, blockHash, this);\r\n\t// get the final wheel result\r\n\twheelResult = uint8(uint256(shaPlayer)%37);\r\n\t//check result against bet and pay if win\r\n\tcheckBetResult(wheelResult, playerSpinned, blockHash, shaPlayer);\r\n      }\r\n    return true;\r\n  }\r\n    \r\n\r\n  //CHECK BETS FUNCTIONS private\r\n  function checkBetResult(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n  {\r\n    BetTypes betType=gambles[gambleIndex[player]].betType;\r\n    //bet on Number\r\n    if (betType==BetTypes.number) checkBetNumber(result, player, blockHash, shaPlayer);\r\n    else if (betType==BetTypes.parity) checkBetParity(result, player, blockHash, shaPlayer);\r\n    else if (betType==BetTypes.color) checkBetColor(result, player, blockHash, shaPlayer);\r\n    else if (betType==BetTypes.lowhigh) checkBetLowhigh(result, player, blockHash, shaPlayer);\r\n    else if (betType==BetTypes.dozen) checkBetDozen(result, player, blockHash, shaPlayer);\r\n    else if (betType==BetTypes.column) checkBetColumn(result, player, blockHash, shaPlayer);\r\n  }\r\n\r\n  // function solve Bet once result is determined : sends to winner, adds loss to profit\r\n  function solveBet(address player, uint8 result, bool win, uint8 multiplier, bytes32 blockHash, bytes32 shaPlayer) private\r\n  {\r\n    //Update status and record spinned\r\n    playerStatus[player]=Status.waitingForBet;\r\n    gambles[gambleIndex[player]].wheelResult=result;\r\n    gambles[gambleIndex[player]].spinned=true;\r\n    gambles[gambleIndex[player]].blockSpinned=block.number;\r\n    uint bet_v = gambles[gambleIndex[player]].wager;\r\n\t\r\n    if (win)\r\n      {\r\n\tgambles[gambleIndex[player]].win=true;\r\n\tuint win_v = (multiplier-1)*bet_v;\r\n\tWin(player, result, win_v, blockHash, shaPlayer, gambleIndex[player], bet_v);\r\n\t//send win!\r\n\t//safe send vs potential callstack overflowed spins\r\n\tif (player.send(win_v+bet_v)==false) throw;\r\n      }\r\n    else\r\n      {\r\n\tLoss(player, result, bet_v-1, blockHash, shaPlayer, gambleIndex[player], bet_v);\r\n\t//send 1 wei to confirm spin if loss\r\n\tif (player.send(1)==false) throw;\r\n      }\r\n\r\n  }\r\n\r\n  // checkbeton number(input)\r\n  // bet type : number\r\n  // input : chosen number\r\n  function checkBetNumber(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n  {\r\n    bool win;\r\n    //win\r\n    if (result==gambles[gambleIndex[player]].input)\r\n      {\r\n\twin=true;  \r\n      }\r\n    solveBet(player, result,win,36, blockHash, shaPlayer);\r\n  }\r\n\r\n\r\n  // checkbet on oddeven\r\n  // bet type : parity\r\n  // input : 0 for even, 1 for odd\r\n  function checkBetParity(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n  {\r\n    bool win;\r\n    //win\r\n    if (result%2==gambles[gambleIndex[player]].input && result!=0)\r\n      {\r\n\twin=true;                \r\n      }\r\n    solveBet(player,result,win,2, blockHash, shaPlayer);\r\n  }\r\n    \r\n  // checkbet on lowhigh\r\n  // bet type : lowhigh\r\n  // input : 0 low, 1 high\r\n  function checkBetLowhigh(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n  {\r\n    bool win;\r\n    //win\r\n    if (result!=0 && ( (result<19 && gambles[gambleIndex[player]].input==0)\r\n\t\t       || (result>18 && gambles[gambleIndex[player]].input==1)\r\n\t\t       ) )\r\n      {\r\n\twin=true;\r\n      }\r\n    solveBet(player,result,win,2, blockHash, shaPlayer);\r\n  }\r\n\r\n  // checkbet on color\r\n  // bet type : color\r\n  // input : 0 red, 1 black\r\n  uint[18] red_list=[1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];\r\n  function checkBetColor(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n  {\r\n    bool red;\r\n    //check if red\r\n    for (uint8 k; k<18; k++)\r\n      { \r\n\tif (red_list[k]==result) \r\n\t  { \r\n\t    red=true; \r\n\t    break;\r\n\t  }\r\n      }\r\n    bool win;\r\n    //win\r\n    if ( result!=0\r\n\t && ( (gambles[gambleIndex[player]].input==0 && red)  \r\n\t      || ( gambles[gambleIndex[player]].input==1 && !red)  ) )\r\n      {\r\n\twin=true;\r\n      }\r\n    solveBet(player,result,win,2, blockHash, shaPlayer);\r\n  }\r\n\r\n  // checkbet on dozen\r\n  // bet type : dozen\r\n  // input : 0 first, 1 second, 2 third\r\n  function checkBetDozen(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n  { \r\n    bool win;\r\n    //win on first dozen\r\n    if ( result!=0 &&\r\n\t ( (result<13 && gambles[gambleIndex[player]].input==0)\r\n\t   ||\r\n\t   (result>12 && result<25 && gambles[gambleIndex[player]].input==1)\r\n\t   ||\r\n\t   (result>24 && gambles[gambleIndex[player]].input==2) ) )\r\n      {\r\n\twin=true;                \r\n      }\r\n    solveBet(player,result,win,3, blockHash, shaPlayer);\r\n  }\r\n\r\n  // checkbet on column\r\n  // bet type : column\r\n  // input : 0 first, 1 second, 2 third\r\n  function checkBetColumn(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n  {\r\n    bool win;\r\n    //win\r\n    if ( result!=0\r\n\t && ( (gambles[gambleIndex[player]].input==0 && result%3==1)  \r\n\t      || ( gambles[gambleIndex[player]].input==1 && result%3==2)\r\n\t      || ( gambles[gambleIndex[player]].input==2 && result%3==0)  ) )\r\n      {\r\n\twin=true;\r\n      }\r\n    solveBet(player,result,win,3, blockHash, shaPlayer);\r\n  }\r\n\r\n\r\n  function checkMyBet(address player) constant returns(Status player_status, BetTypes bettype, uint input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb, uint blockSpin, uint gambleID)\r\n  {\r\n    player_status=playerStatus[player];\r\n    bettype=gambles[gambleIndex[player]].betType;\r\n    input=gambles[gambleIndex[player]].input;\r\n    value=gambles[gambleIndex[player]].wager;\r\n    result=gambles[gambleIndex[player]].wheelResult;\r\n    wheelspinned=gambles[gambleIndex[player]].spinned;\r\n    win=gambles[gambleIndex[player]].win;\r\n    blockNb=gambles[gambleIndex[player]].blockNumber;\r\n    blockSpin=gambles[gambleIndex[player]].blockSpinned;\r\n    gambleID=gambleIndex[player];\r\n    return;\r\n  }\r\n\r\n  function getTotalGambles() constant returns(uint){\r\n    return gambles.length;\r\n  }\r\n\r\n  \r\n  function getGamblesList(uint256 index) constant returns(address player, BetTypes bettype, uint input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb, uint blockSpin)\r\n  {\r\n    player=gambles[index].player;\r\n    bettype=gambles[index].betType;\r\n    input=gambles[index].input;\r\n    value=gambles[index].wager;\r\n    result=gambles[index].wheelResult;\r\n    wheelspinned=gambles[index].spinned;\r\n    win=gambles[index].win;\r\n    blockNb=gambles[index].blockNumber;\r\n    blockSpin=gambles[index].blockSpinned;\r\n    return;\r\n  }\r\n\r\n} //end of contract","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"addBankroll\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount_wei\",\"type\":\"uint256\"}],\"name\":\"removeBankroll\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMinGamble\",\"type\":\"uint256\"},{\"name\":\"newMaxGamble\",\"type\":\"uint256\"},{\"name\":\"newBlockDelay\",\"type\":\"uint8\"},{\"name\":\"newBlockExpiration\",\"type\":\"uint8\"},{\"name\":\"newEmissionRate\",\"type\":\"uint256\"}],\"name\":\"changeSettings_only_Dev\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalGambles\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"Black\",\"type\":\"bool\"}],\"name\":\"betOnColor\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"numberChosen\",\"type\":\"uint256\"}],\"name\":\"betOnNumber\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minGamble\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"column_selected_0_1_2\",\"type\":\"uint256\"}],\"name\":\"betOnColumn\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"checkMyBet\",\"outputs\":[{\"name\":\"player_status\",\"type\":\"uint8\"},{\"name\":\"bettype\",\"type\":\"uint8\"},{\"name\":\"input\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint8\"},{\"name\":\"wheelspinned\",\"type\":\"bool\"},{\"name\":\"win\",\"type\":\"bool\"},{\"name\":\"blockNb\",\"type\":\"uint256\"},{\"name\":\"blockSpin\",\"type\":\"uint256\"},{\"name\":\"gambleID\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_dev\",\"type\":\"address\"}],\"name\":\"changeDeveloper_only_Dev\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxGamble\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"emissionRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"Odd\",\"type\":\"bool\"}],\"name\":\"betOnOddEven\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"High\",\"type\":\"bool\"}],\"name\":\"betOnLowHigh\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getGamblesList\",\"outputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"bettype\",\"type\":\"uint8\"},{\"name\":\"input\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint8\"},{\"name\":\"wheelspinned\",\"type\":\"bool\"},{\"name\":\"win\",\"type\":\"bool\"},{\"name\":\"blockNb\",\"type\":\"uint256\"},{\"name\":\"blockSpin\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"developer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockExpiration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockDelay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WINTOKENADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spin_for_player\",\"type\":\"address\"}],\"name\":\"spinTheWheel\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dozen_selected_0_1_2\",\"type\":\"uint256\"}],\"name\":\"betOnDozen\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"redeemTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getPendingTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_developer\",\"type\":\"address\"},{\"name\":\"_winToken\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"value_won\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"sha3Player\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"gambleId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bet\",\"type\":\"uint256\"}],\"name\":\"Win\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"value_loss\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"sha3Player\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"gambleId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bet\",\"type\":\"uint256\"}],\"name\":\"Loss\",\"type\":\"event\"}]","ContractName":"Rouleth","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000c26a6dbf6b285145ca4f64397a521f8b5e49a790000000000000000000000009e3f0fc2a9ea1ec8d9e51a7a34c20b777021b030","Library":"","SwarmSource":"bzzr://cc53c7cb3c8596830a60ee3fb03a406a3363fadeef58def7670e2d55ae21050f"}]}