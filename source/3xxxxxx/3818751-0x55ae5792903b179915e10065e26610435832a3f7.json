{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\ncontract owned {\r\n\r\n\taddress public owner;\r\n\r\n\tfunction owned() {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\tmodifier onlyOwner {\r\n\t\tif (msg.sender != owner) throw;\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction transferOwnership(address newOwner) onlyOwner {\r\n\t\towner = newOwner;\r\n\t}\r\n}\r\n\r\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\r\n\r\ncontract ICofounditToken {\r\n\tfunction mintTokens(address _to, uint256 _amount, string _reason);\r\n\tfunction totalSupply() constant returns (uint256 totalSupply);\r\n}\r\n\r\ncontract CofounditICO is owned{\r\n\r\n\tuint256 public startBlock;\r\n\tuint256 public endBlock;\r\n\tuint256 public minEthToRaise;\r\n\tuint256 public maxEthToRaise;\r\n\tuint256 public totalEthRaised;\r\n\taddress public multisigAddress;\r\n\r\n\tuint256 public icoSupply;\r\n\tuint256 public strategicReserveSupply;\r\n\tuint256 public cashilaTokenSupply;\r\n\tuint256 public iconomiTokenSupply;\r\n\tuint256 public coreTeamTokenSupply;\r\n\r\n\tICofounditToken cofounditTokenContract;\t\r\n\tmapping (address => bool) presaleContributorAllowance;\r\n\tuint256 nextFreeParticipantIndex;\r\n\tmapping (uint => address) participantIndex;\r\n\tmapping (address => uint256) participantContribution;\r\n\r\n\tuint256 usedIcoSupply;\r\n\tuint256 usedStrategicReserveSupply;\r\n\tuint256 usedCashilaTokenSupply;\r\n\tuint256 usedIconomiTokenSupply;\r\n\tuint256 usedCoreTeamTokenSupply;\r\n\r\n\tbool icoHasStarted;\r\n\tbool minTresholdReached;\r\n\tbool icoHasSucessfulyEnded;\r\n\r\n\tuint256 lastEthReturnIndex;\r\n\tmapping (address => bool) hasClaimedEthWhenFail;\r\n\tuint256 lastCfiIssuanceIndex;\r\n\r\n\tstring icoStartedMessage = \"Cofoundit is launching!\";\r\n\tstring icoMinTresholdReachedMessage = \"Firing Stage 2!\";\r\n\tstring icoEndedSuccessfulyMessage = \"Orbit achieved!\";\r\n\tstring icoEndedSuccessfulyWithCapMessage = \"Leaving Earth orbit!\";\r\n\tstring icoFailedMessage = \"Rocket crashed.\";\r\n\r\n\tevent ICOStarted(uint256 _blockNumber, string _message);\r\n\tevent ICOMinTresholdReached(uint256 _blockNumber, string _message);\r\n\tevent ICOEndedSuccessfuly(uint256 _blockNumber, uint256 _amountRaised, string _message);\r\n\tevent ICOFailed(uint256 _blockNumber, uint256 _ammountRaised, string _message);\r\n\tevent ErrorSendingETH(address _from, uint256 _amount);\r\n\r\n\tfunction CofounditICO(uint256 _startBlock, uint256 _endBlock, address _multisigAddress) {\r\n\t\tstartBlock = _startBlock;\r\n\t\tendBlock = _endBlock;\r\n\t\tminEthToRaise = 4525 * 10**18;\r\n\t\tmaxEthToRaise = 56565 * 10**18;\r\n\t\tmultisigAddress = _multisigAddress;\r\n\r\n\t\ticoSupply =\t \t\t\t\t125000000 * 10**18;\r\n\t\tstrategicReserveSupply = \t125000000 * 10**18;\r\n\t\tcashilaTokenSupply = \t\t100000000 * 10**18;\r\n\t\ticonomiTokenSupply = \t\t50000000 * 10**18;\r\n\t\tcoreTeamTokenSupply =\t\t100000000 * 10**18;\r\n\t}\r\n\r\n\t// \t\r\n\t/* User accessible methods */ \t\r\n\t// \t\r\n\r\n\t/* Users send ETH and enter the crowdsale*/ \t\r\n\tfunction () payable { \t\t\r\n\t\tif (msg.value == 0) throw;  \t\t\t\t\t\t\t\t\t\t\t\t// Check if balance is not 0 \t\t\r\n\t\tif (icoHasSucessfulyEnded || block.number > endBlock) throw;\t\t\t\t// Throw if ico has already ended \t\t\r\n\t\tif (!icoHasStarted){\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if this is the first transaction of ico \t\t\t\r\n\t\t\tif (block.number < startBlock){\t\t\t\t\t\t\t\t\t\t\t// Check if ico should start \t\t\t\t\r\n\t\t\t\tif (!presaleContributorAllowance[msg.sender]) throw;\t\t\t\t// Check if this address is part of presale contributors \t\t\t\r\n\t\t\t} \t\t\t\r\n\t\t\telse{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// If ICO should start \t\t\t\t\r\n\t\t\t\ticoHasStarted = true;\t\t\t\t\t\t\t\t\t\t\t\t// Set that ico has started \t\t\t\t\r\n\t\t\t\tICOStarted(block.number, icoStartedMessage);\t\t\t\t\t\t// Raise event \t\t\t\r\n\t\t\t} \t\t\r\n\t\t} \t\t\r\n\t\tif (participantContribution[msg.sender] == 0){ \t\t\t\t\t\t\t\t// Check if sender is a new user \t\t\t\r\n\t\t\tparticipantIndex[nextFreeParticipantIndex] = msg.sender;\t\t\t\t// Add new user to participant data structure \t\t\t\r\n\t\t\tnextFreeParticipantIndex += 1; \t\t\r\n\t\t} \t\t\r\n\t\tif (maxEthToRaise > (totalEthRaised + msg.value)){\t\t\t\t\t\t\t// Check if user sent to much eth \t\t\t\r\n\t\t\tparticipantContribution[msg.sender] += msg.value;\t\t\t\t\t\t// Add accounts contribution \t\t\t\r\n\t\t\ttotalEthRaised += msg.value;\t\t\t\t\t\t\t\t\t\t\t// Add to total eth Raised \t\t\t\r\n\t\t\tif (!minTresholdReached && totalEthRaised >= minEthToRaise){\t\t\t// Check if min treshold has been reached(Do that one time) \t\t\t\t\r\n\t\t\t\tICOMinTresholdReached(block.number, icoMinTresholdReachedMessage);\t// Raise event \t\t\t\t\r\n\t\t\t\tminTresholdReached = true;\t\t\t\t\t\t\t\t\t\t\t// Set that treshold has been reached \t\t\t\r\n\t\t\t} \t\t\r\n\t\t}else{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// If user sent to much eth \t\t\t\r\n\t\t\tuint maxContribution = maxEthToRaise - totalEthRaised; \t\t\t\t\t// Calculate max contribution \t\t\t\r\n\t\t\tparticipantContribution[msg.sender] += maxContribution;\t\t\t\t\t// Add max contribution to account \t\t\t\r\n\t\t\ttotalEthRaised += maxContribution;\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\tuint toReturn = msg.value - maxContribution;\t\t\t\t\t\t\t// Calculate how much user should get back \t\t\t\r\n\t\t\ticoHasSucessfulyEnded = true;\t\t\t\t\t\t\t\t\t\t\t// Set that ico has successfullyEnded \t\t\t\r\n\t\t\tICOEndedSuccessfuly(block.number, totalEthRaised, icoEndedSuccessfulyWithCapMessage); \t\t\t\r\n\t\t\tif(!msg.sender.send(toReturn)){\t\t\t\t\t\t\t\t\t\t\t// Refound balance that is over the cap \t\t\t\t\r\n\t\t\t\tErrorSendingETH(msg.sender, toReturn);\t\t\t\t\t\t\t\t// Raise event for manual return if transaction throws \t\t\t\r\n\t\t\t} \t\t\r\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Feel good about achiving the cap \t\r\n\t} \t\r\n\r\n\t/* Users can claim eth by themself if they want to in instance of eth faliure*/ \t\r\n\tfunction claimEthIfFailed(){ \t\t\r\n\t\tif (block.number <= endBlock || totalEthRaised >= minEthToRaise) throw;\t// Check that ico has failed :( \t\t\r\n\t\tif (participantContribution[msg.sender] == 0) throw;\t\t\t\t\t// Check if user has even been at crowdsale \t\t\r\n\t\tif (hasClaimedEthWhenFail[msg.sender]) throw;\t\t\t\t\t\t\t// Check if this account has already claimed its eth \t\t\r\n\t\tuint256 ethContributed = participantContribution[msg.sender];\t\t\t// Get participant eth Contribution \t\t\r\n\t\thasClaimedEthWhenFail[msg.sender] = true; \t\t\r\n\t\tif (!msg.sender.send(ethContributed)){ \t\t\t\r\n\t\t\tErrorSendingETH(msg.sender, ethContributed);\t\t\t\t\t\t// Raise event if send failed and resolve manually \t\t\r\n\t\t} \t\r\n\t} \t\r\n\r\n\t// \t\r\n\t/* Only owner methods */ \t\r\n\t// \t\r\n\r\n\t/* Adds addresses that are allowed to take part in presale */ \t\r\n\tfunction addPresaleContributors(address[] _presaleContributors) onlyOwner { \t\t\r\n\t\tfor (uint cnt = 0; cnt < _presaleContributors.length; cnt++){ \t\t\t\r\n\t\t\tpresaleContributorAllowance[_presaleContributors[cnt]] = true; \t\t\r\n\t\t} \t\r\n\t} \t\r\n\r\n\t/* Owner can issue new tokens in token contract */ \t\r\n\tfunction batchIssueTokens(uint256 _numberOfIssuances) onlyOwner{ \t\t\r\n\t\tif (!icoHasSucessfulyEnded) throw;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if ico has ended \t\t\r\n\t\taddress currentParticipantAddress; \t\t\r\n\t\tuint256 tokensToBeIssued; \t\t\r\n\t\tfor (uint cnt = 0; cnt < _numberOfIssuances; cnt++){ \t\t\t\r\n\t\t\tcurrentParticipantAddress = participantIndex[lastCfiIssuanceIndex];\t// Get next participant address\r\n\t\t\tif (currentParticipantAddress == 0x0) continue; \t\t\t\r\n\t\t\ttokensToBeIssued = icoSupply * participantContribution[currentParticipantAddress] / totalEthRaised;\t\t// Calculate how much tokens will address get \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(currentParticipantAddress, tokensToBeIssued, \"Ico participation mint\");\t// Mint tokens @ CofounditToken \t\t\t\r\n\t\t\tlastCfiIssuanceIndex += 1;\t\r\n\t\t} \r\n\r\n\t\tif (participantIndex[lastCfiIssuanceIndex] == 0x0 && cofounditTokenContract.totalSupply() < icoSupply){\r\n\t\t\tuint divisionDifference = icoSupply - cofounditTokenContract.totalSupply();\r\n\t\t\tcofounditTokenContract.mintTokens(multisigAddress, divisionDifference, \"Mint division error\");\t// Mint divison difference @ CofounditToken so that total supply is whole number\t\t\t\r\n\t\t}\r\n\t} \t\r\n\r\n\t/* Owner can return eth for multiple users in one call*/ \t\r\n\tfunction batchReturnEthIfFailed(uint256 _numberOfReturns) onlyOwner{ \t\t\r\n\t\tif (block.number < endBlock || totalEthRaised >= minEthToRaise) throw;\t\t// Check that ico has failed :( \t\t\r\n\t\taddress currentParticipantAddress; \t\t\r\n\t\tuint256 contribution;\r\n\t\tfor (uint cnt = 0; cnt < _numberOfReturns; cnt++){ \t\t\t\r\n\t\t\tcurrentParticipantAddress = participantIndex[lastEthReturnIndex];\t\t// Get next account \t\t\t\r\n\t\t\tif (currentParticipantAddress == 0x0) return;\t\t\t\t\t\t\t// If all the participants were reinbursed return \t\t\t\r\n\t\t\tif (!hasClaimedEthWhenFail[currentParticipantAddress]) {\t\t\t\t// Check if user has manually recovered eth \t\t\t\t\r\n\t\t\t\tcontribution = participantContribution[currentParticipantAddress];\t// Get accounts contribution \t\t\t\t\r\n\t\t\t\thasClaimedEthWhenFail[msg.sender] = true;\t\t\t\t\t\t\t// Set that user got his eth back \t\t\t\t\r\n\t\t\t\tif (!currentParticipantAddress.send(contribution)){\t\t\t\t\t// Send fund back to account \t\t\t\t\t\r\n\t\t\t\t\tErrorSendingETH(currentParticipantAddress, contribution);\t\t// Raise event if send failed and resolve manually \t\t\t\t\r\n\t\t\t\t} \t\t\t\r\n\t\t\t} \t\t\t\r\n\t\t\tlastEthReturnIndex += 1; \t\t\r\n\t\t} \t\r\n\t} \t\r\n\r\n\t/* Owner sets new address of CofounditToken */\r\n\tfunction changeMultisigAddress(address _newAddress) onlyOwner { \t\t\r\n\t\tmultisigAddress = _newAddress;\r\n\t} \t\r\n\r\n\t/* Owner can claim reserved tokens on the end of crowsale */ \t\r\n\tfunction claimReservedTokens(string _which, address _to, uint256 _amount, string _reason) onlyOwner{ \t\t\r\n\t\tif (!icoHasSucessfulyEnded) throw;                 \r\n\t\tbytes32 hashedStr = sha3(_which);\t\t\t\t\r\n\t\tif (hashedStr == sha3(\"Reserve\")){ \t\t\t\r\n\t\t\tif (_amount > strategicReserveSupply - usedStrategicReserveSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, _reason); \t\t\t\r\n\t\t\tusedStrategicReserveSupply += _amount; \t\t\r\n\t\t} \t\t\r\n\t\telse if (hashedStr == sha3(\"Cashila\")){ \t\t\t\r\n\t\t\tif (_amount > cashilaTokenSupply - usedCashilaTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for cashila\"); \t\t\t\r\n\t\t\tusedCashilaTokenSupply += _amount; \t\t} \t\t\r\n\t\telse if (hashedStr == sha3(\"Iconomi\")){ \t\t\t\r\n\t\t\tif (_amount > iconomiTokenSupply - usedIconomiTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for iconomi\"); \t\t\t\r\n\t\t\tusedIconomiTokenSupply += _amount; \t\t\r\n\t\t}\r\n\t\telse if (hashedStr == sha3(\"Core\")){ \t\t\t\r\n\t\t\tif (_amount > coreTeamTokenSupply - usedCoreTeamTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for cofoundit team\"); \t\t\t\r\n\t\t\tusedCoreTeamTokenSupply += _amount; \t\t\r\n\t\t} \t\t\r\n\t\telse throw; \t\r\n\t} \t\r\n\r\n\t/* Owner can remove allowance of designated presale contributor */ \t\r\n\tfunction removePresaleContributor(address _presaleContributor) onlyOwner { \t\t\r\n\t\tpresaleContributorAllowance[_presaleContributor] = false; \t\r\n\t} \t\r\n\r\n\t/* Set token contract where mints will be done (tokens will be issued)*/ \t\r\n\tfunction setTokenContract(address _cofounditContractAddress) onlyOwner { \t\t\r\n\t\tcofounditTokenContract = ICofounditToken(_cofounditContractAddress); \t\r\n\t} \t\r\n\r\n\t/* Withdraw funds from contract */ \t\r\n\tfunction withdrawEth() onlyOwner{ \t\t\r\n\t\tif (this.balance == 0) throw;\t\t\t\t// Check if there is something on the contract \t\t\r\n\t\tif (totalEthRaised < minEthToRaise) throw;\t// Check if minEth treshold is surpassed \t\t\r\n\t\tif (block.number > endBlock){\t\t\t\t// Check if ico has ended withouth reaching the maxCap \t\t\t\r\n\t\t\ticoHasSucessfulyEnded = true; \t\t\t\r\n\t\t\tICOEndedSuccessfuly(block.number, totalEthRaised, icoEndedSuccessfulyMessage); \t\t\r\n\t\t} \t\t\r\n\t\tif(multisigAddress.send(this.balance)){}\t\t// Send contracts whole balance to multisig address \t\r\n\t} \t\r\n\r\n\t/* Withdraw remaining balance to manually return where contracts send has failed */ \t\r\n\tfunction withdrawRemainingBalanceForManualRecovery() onlyOwner{ \t\t\r\n\t\tif (this.balance == 0) throw;\t\t\t\t\t\t\t\t\t\t\t// Check if there is something on the contract \t\t\r\n\t\tif (block.number < endBlock || totalEthRaised >= minEthToRaise) throw;\t// Check if ico has failed :( \t\t\r\n\t\tif (participantIndex[lastEthReturnIndex] != 0x0) throw;\t\t\t\t\t// Check if all the participants has been reinbursed \t\t\r\n\t\tif(multisigAddress.send(this.balance)){}\t\t\t\t\t\t\t\t// Send remainder so it can be manually processed \t\r\n\t} \t\r\n\r\n\t// \t\r\n\t/* Getters */ \t\r\n\t// \t\r\n\r\n\tfunction getCfiEstimation(address _querryAddress) constant returns (uint256 answer){ \t\t\r\n\t\treturn icoSupply * participantContribution[_querryAddress] / totalEthRaised; \t\r\n\t} \t\r\n\r\n\tfunction getCofounditTokenAddress() constant returns(address _tokenAddress){ \t\t\r\n\t\treturn address(cofounditTokenContract); \t\r\n\t} \t\r\n\r\n\tfunction icoInProgress() constant returns (bool answer){ \t\t\r\n\t\treturn icoHasStarted && !icoHasSucessfulyEnded; \t\r\n\t} \t\r\n\r\n\tfunction isAddressAllowedInPresale(address _querryAddress) constant returns (bool answer){ \t\t\r\n\t\treturn presaleContributorAllowance[_querryAddress]; \t\r\n\t} \t\r\n\r\n\tfunction participantContributionInEth(address _querryAddress) constant returns (uint256 answer){ \t\t\r\n\t\treturn participantContribution[_querryAddress]; \t\r\n\t}\r\n\r\n\t//\r\n\t/* This part is here only for testing and will not be included into final version */\r\n\t//\r\n\t//function killContract() onlyOwner{\r\n\t//\tselfdestruct(msg.sender);\r\n\t//}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"changeMultisigAddress\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_querryAddress\",\"type\":\"address\"}],\"name\":\"getCfiEstimation\",\"outputs\":[{\"name\":\"answer\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minEthToRaise\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawRemainingBalanceForManualRecovery\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_querryAddress\",\"type\":\"address\"}],\"name\":\"participantContributionInEth\",\"outputs\":[{\"name\":\"answer\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_which\",\"type\":\"string\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"claimReservedTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_querryAddress\",\"type\":\"address\"}],\"name\":\"isAddressAllowedInPresale\",\"outputs\":[{\"name\":\"answer\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_presaleContributors\",\"type\":\"address[]\"}],\"name\":\"addPresaleContributors\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"iconomiTokenSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoInProgress\",\"outputs\":[{\"name\":\"answer\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimEthIfFailed\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numberOfReturns\",\"type\":\"uint256\"}],\"name\":\"batchReturnEthIfFailed\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_presaleContributor\",\"type\":\"address\"}],\"name\":\"removePresaleContributor\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coreTeamTokenSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCofounditTokenAddress\",\"outputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numberOfIssuances\",\"type\":\"uint256\"}],\"name\":\"batchIssueTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"strategicReserveSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cashilaTokenSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cofounditContractAddress\",\"type\":\"address\"}],\"name\":\"setTokenContract\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxEthToRaise\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"name\":\"_endBlock\",\"type\":\"uint256\"},{\"name\":\"_multisigAddress\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"ICOStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"ICOMinTresholdReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amountRaised\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"ICOEndedSuccessfuly\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_ammountRaised\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"ICOFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ErrorSendingETH\",\"type\":\"event\"}]","ContractName":"CofounditICO","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000003a87ca00000000000000000000000000000000000000000000000000000000003cd66a0000000000000000000000003fec3c6e014e28566000a1be3cfcb43327d4b743","Library":"","SwarmSource":"bzzr://581f94d90b5dbd739c21bd0bc9f9b9db8b3785093fb2b0f6fa05deeb03608d46"}]}