{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\ncontract IElectricCharger {\r\n   \r\n   \r\n    function setInvestors(uint[] ids,address[] addresses,uint[] balances,uint investmentsCount);\r\n   function getPrice() constant external returns (uint price);\r\n \r\n}\r\n//contract\r\ncontract ElectricQueue  {\r\n       address public Owner;\r\n       uint public syncDate;\r\n       uint public InvestmentsCount;\r\n       uint public ChargersCount;\r\n       Investment[] Investments;\r\n       uint[]  ChargersIds ; \r\n       mapping (uint=>Charger) Chargers;\r\n       address public Proxy;\r\n       address public Manager;\r\n       //contract of electrochargers , which state\r\n       struct Charger{\r\n          IElectricCharger Address;\r\n          bool IsActive;\r\n       }\r\n  //    'Investment' describes investment from uniq address to uniq charger.\r\n      struct Investment {\r\n           uint InvestmentId;\r\n           address Address;\r\n           uint ChargerId;\r\n           uint Balance;\r\n           uint TotalSum;\r\n           bool IsTransfered;\r\n           uint LastUpdateDate;\r\n           bool IsReturned;\r\n       }\r\n           \r\n        function ElectricQueue(address proxy){\r\n             Owner = msg.sender;\r\n             syncDate = now;\r\n             Proxy = proxy;\r\n        }\r\n        function setManager(address manager) external{\r\n             if (msg.sender != Owner) return ;\r\n             Manager = manager;\r\n        }\r\n        //return the information about each charger in queue contract\r\n       function getChargers() external constant returns (uint [] chargers ,address[] addresses ,bool [] states) {\r\n        uint length = ChargersIds.length;\r\n        address []  memory _addresses = new address[](length);\r\n        bool []  memory _states = new bool[](length);\r\n          for(uint i = 0 ; i < ChargersIds.length;i++){\r\n              _addresses[i] = Chargers[ChargersIds[i]].Address;\r\n              _states[i] = Chargers[ChargersIds[i]].IsActive;\r\n          }\r\n           return (ChargersIds,_addresses,_states);\r\n       }\r\n       //create new investment  and push it to array 'Investments' \r\n       function createInvestment(address _address,uint _chargerId) internal returns (Investment investor) {\r\n        checkCharger(_chargerId);\r\n        InvestmentsCount++;\r\n        Investment memory _newInvestment;\r\n        _newInvestment.Address = _address;\r\n        _newInvestment.ChargerId = _chargerId;\r\n        _newInvestment.InvestmentId = InvestmentsCount;\r\n        Investments.push(_newInvestment);\r\n        return _newInvestment;\r\n      }\r\n      //external function that gives possibility to invest in queue or concret charger\r\n      function  investInQueue(address _from , uint _charger) payable returns(bool success) {\r\n          var investmentId = getInvestment(_from,_charger);\r\n          Investments[investmentId-1].Balance+=msg.value;\r\n          Investments[investmentId-1].TotalSum+=msg.value;\r\n          Investments[investmentId-1].IsTransfered=false;\r\n          Investments[investmentId-1].IsReturned=false;\r\n          Investments[investmentId-1].LastUpdateDate =now;\r\n          syncDate = now;\r\n          return true;\r\n      }\r\n      //check for exting charger and create new if , mapping hasn't it\r\n      function checkCharger(uint _chargerId) internal{\r\n          if(!Chargers[_chargerId].IsActive ){\r\n              Chargers[_chargerId].IsActive = true;\r\n              ChargersIds.push(_chargerId);\r\n              ChargersCount++;\r\n          }\r\n      }\r\n      //get investment by two key (address and charger)\r\n      function  getInvestment(address _address,uint _charger) internal returns (uint investmentId ) {\r\n          for(uint i =0 ; i < InvestmentsCount ; i++){\r\n                if(Investments[i].Address ==_address && Investments[i].ChargerId == _charger){\r\n                    return Investments[i].InvestmentId;\r\n                }\r\n          }\r\n          var _investment = createInvestment(_address,_charger);\r\n          return _investment.InvestmentId;\r\n      }\r\n      //return information about all investments in queue contract\r\n      function getAllInvestments() external constant returns( uint [] ids , address[] addresses, uint[] chargerIds, uint [] balances , bool [] states , uint[] lastUpdateDates,uint[] totalSum) {\r\n               uint length = InvestmentsCount;\r\n               uint []  memory _ids  = new uint[](length);\r\n               address []  memory _addresses = new address[](length);\r\n               uint []  memory _chargerIds = new uint[](length);\r\n               uint []  memory _balances= new uint[](length);\r\n               bool []  memory _states = new bool[](length);\r\n               uint []  memory _lastUpdateDates= new uint[](length);\r\n               uint []  memory _totalSums= new uint[](length);\r\n               for(uint i =0 ; i < InvestmentsCount ; i++){\r\n                 _ids[i]= Investments[i].InvestmentId;\r\n                 _addresses[i]= Investments[i].Address;\r\n                 _chargerIds[i]=Investments[i].ChargerId;\r\n                 _balances[i]=Investments[i].Balance;\r\n                 _states[i]=Investments[i].IsTransfered;\r\n                 _totalSums[i]=Investments[i].TotalSum;\r\n                 _lastUpdateDates[i]=Investments[i].LastUpdateDate;\r\n                }\r\n                return(_ids,_addresses,_chargerIds,_balances,_states,_lastUpdateDates,_totalSums);\r\n          }   \r\n     \r\n      //setting charger address\r\n      function setChargerAddress(uint id , address chargerAddress) {\r\n         if (msg.sender != Owner && msg.sender != Manager) return ;\r\n          Chargers[id].Address = IElectricCharger(chargerAddress);\r\n      }\r\n      //transer money to cherger\r\n      function sendToCharger(uint id){\r\n                 if (msg.sender != Owner && msg.sender != Manager) return ;\r\n                 var _amountForCharger = getAmountForCharger(id);\r\n\r\n                uint _priceOfCharger = Chargers[id].Address.getPrice() ;\r\n                 if(_priceOfCharger> _amountForCharger){\r\n                        uint difference  = _priceOfCharger - _amountForCharger;\r\n                       calculateCountOfInvestmetnsInQueue(difference,id);\r\n                 }            \r\n                 if(!Chargers[id].Address.call.value(_priceOfCharger)())\r\n                       throw;\r\n      }\r\n  \r\n      function calculateCountOfInvestmetnsInQueue(uint difference ,uint id) internal{\r\n             uint queueInvestments=0;\r\n             uint i =0;  uint investmantBalance=0;\r\n            uint length = InvestmentsCount;\r\n            uint []  memory _ids  = new uint[](length);\r\n            address []  memory _addresses = new address[](length);\r\n            uint []  memory _balances= new uint[](length);\r\n\r\n             while(i <InvestmentsCount && difference > 0){\r\n                     if(Investments[i].ChargerId == 0 && Investments[i].Balance >= 1 ether){\r\n                         if(difference>Investments[i].Balance){\r\n                            investmantBalance=Investments[i].Balance;\r\n                            Investments[i].Balance=0;\r\n                           Investments[i].IsTransfered =true;\r\n                         }\r\n                         else{\r\n                               investmantBalance=difference ;\r\n                              Investments[i].Balance-=difference;\r\n                         }\r\n                        _ids[queueInvestments]=Investments[i].InvestmentId;\r\n                        _addresses[queueInvestments]=Investments[i].Address;\r\n                        _balances[queueInvestments]=investmantBalance;\r\n                         queueInvestments++;\r\n                     }\r\n                    i++;\r\n             }\r\n             Chargers[id].Address.setInvestors(_ids,_addresses,_balances,queueInvestments);\r\n               \r\n      }\r\n      //calculate amount for charger\r\n      function getAmountForCharger(uint id) internal returns (uint sumBalance) {\r\n            sumBalance = 0;\r\n            uint chargerInvestments=0;\r\n            uint length = InvestmentsCount;\r\n            uint []  memory _ids  = new uint[](length);\r\n            address []  memory _addresses = new address[](length);\r\n            uint []  memory _balances= new uint[](length);\r\n\r\n             for(uint i =0 ; i < InvestmentsCount ; i++){\r\n                if(Investments[i].ChargerId == id && Investments[i].Balance >= 1 ether){\r\n                    _ids[chargerInvestments]=Investments[i].InvestmentId;\r\n                    _addresses[chargerInvestments]=Investments[i].Address;\r\n                    _balances[chargerInvestments]=Investments[i].Balance;\r\n                  \r\n                   sumBalance +=Investments[i].Balance;\r\n                   Investments[i].Balance=0;\r\n                   Investments[i].IsTransfered = true;\r\n                   \r\n                   chargerInvestments++;\r\n                }\r\n            }\r\n         Chargers[id].Address.setInvestors(_ids,_addresses,_balances,chargerInvestments);\r\n   \r\n      }\r\n       function  returnMoney(address _to) payable returns(bool success) {\r\n        if(msg.sender != Proxy) return false;\r\n         for(uint i =0 ; i < InvestmentsCount ; i++){\r\n                if(Investments[i].Address ==_to){\r\n                        if(!_to.send(Investments[i].Balance)){\r\n                            return false;\r\n                        }\r\n                        Investments[i].Balance = 0;\r\n                        Investments[i].IsReturned= true;\r\n\r\n                }\r\n          }\r\n          \r\n          return true;\r\n       }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"syncDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"chargerAddress\",\"type\":\"address\"}],\"name\":\"setChargerAddress\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"InvestmentsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"sendToCharger\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ChargersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllInvestments\",\"outputs\":[{\"name\":\"ids\",\"type\":\"uint256[]\"},{\"name\":\"addresses\",\"type\":\"address[]\"},{\"name\":\"chargerIds\",\"type\":\"uint256[]\"},{\"name\":\"balances\",\"type\":\"uint256[]\"},{\"name\":\"states\",\"type\":\"bool[]\"},{\"name\":\"lastUpdateDates\",\"type\":\"uint256[]\"},{\"name\":\"totalSum\",\"type\":\"uint256[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_charger\",\"type\":\"uint256\"}],\"name\":\"investInQueue\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"returnMoney\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getChargers\",\"outputs\":[{\"name\":\"chargers\",\"type\":\"uint256[]\"},{\"name\":\"addresses\",\"type\":\"address[]\"},{\"name\":\"states\",\"type\":\"bool[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Proxy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"proxy\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"}]","ContractName":"ElectricQueue","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e7c8635bc387994069f7b7f25b89534c67727a01","Library":"","SwarmSource":"bzzr://4bf6ec1a305db60c9a4a4c1c851f2479e008ca48a0bb539b52e5bcfb4d0bedd3"}]}