{"status":"1","message":"OK","result":[{"SourceCode":"// File: solidity/solidity/Owned.sol\n\npragma solidity ^0.4.10;\r\n\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /*\r\n        allows transferring the contract ownership\r\n        can only be called by the contract owner\r\n    */\r\n    function setOwner(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner);\r\n        address prevOwner = owner;\r\n        owner = _newOwner;\r\n        OwnerUpdate(prevOwner, owner);\r\n    }\r\n}\n\n// File: solidity/solidity/ERC20TokenInterface.sol\n\npragma solidity ^0.4.10;\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ncontract ERC20TokenInterface {\r\n    // these functions aren't abstract since the compiler doesn't recognize automatically generated getter functions as functions\r\n    function totalSupply() public constant returns (uint256 totalSupply) {}\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {}\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {}\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\n\n// File: solidity/solidity/ERC20Token.sol\n\npragma solidity ^0.4.10;\r\r\n\r\n/*\r\n    ERC20 Standard Token implementation\r\n*/\r\ncontract ERC20Token is ERC20TokenInterface {\r\n    string public standard = 'Token 0.1';\r\n    string public name = '';\r\n    string public symbol = '';\r\n    uint256 public totalSupply = 0;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function ERC20Token(string _name, string _symbol) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        assert(_address != 0x0);\r\n        _;\r\n    }\r\n\r\n    /*\r\n        send coins\r\n        note that the function slightly deviates from the ERC20 standard and will throw on any error rather then return a boolean return value to minimize user errors\r\n    */\r\n    function transfer(address _to, uint256 _value)\r\n        public\r\n        validAddress(_to)\r\n        returns (bool success)\r\n    {\r\n        require(_value <= balanceOf[msg.sender]); // balance check\r\n        assert(balanceOf[_to] + _value >= balanceOf[_to]); // overflow protection\r\n\r\n        balanceOf[msg.sender] -= _value;\r\n        balanceOf[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n        an account/contract attempts to get the coins\r\n        note that the function slightly deviates from the ERC20 standard and will throw on any error rather then return a boolean return value to minimize user errors\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public\r\n        validAddress(_from)\r\n        validAddress(_to)\r\n        returns (bool success)\r\n    {\r\n        require(_value <= balanceOf[_from]); // balance check\r\n        require(_value <= allowance[_from][msg.sender]); // allowance check\r\n        assert(balanceOf[_to] + _value >= balanceOf[_to]); // overflow protection\r\n\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        allowance[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n        allow another account/contract to spend some tokens on your behalf\r\n        note that the function slightly deviates from the ERC20 standard and will throw on any error rather then return a boolean return value to minimize user errors\r\n\r\n        also, to minimize the risk of the approve/transferFrom attack vector\r\n        (see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/), approve has to be called twice\r\n        in 2 separate transactions - once to change the allowance to 0 and secondly to change it to the new allowance value\r\n    */\r\n    function approve(address _spender, uint256 _value)\r\n        public\r\n        validAddress(_spender)\r\n        returns (bool success)\r\n    {\r\n        // if the allowance isn't 0, it can only be updated to 0 to prevent an allowance change immediately after withdrawal\r\n        require(_value == 0 || allowance[msg.sender][_spender] == 0);\r\n\r\n        allowance[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n}\n\n// File: solidity/solidity/BancorEventsInterface.sol\n\npragma solidity ^0.4.10;\r\n\r\n/*\r\n    Bancor events interface\r\n*/\r\ncontract BancorEventsInterface {\r\n    event NewToken(address _token);\r\n    event TokenOwnerUpdate(address indexed _token, address _prevOwner, address _newOwner);\r\n    event TokenChangerUpdate(address indexed _token, address _prevChanger, address _newChanger);\r\n    event TokenTransfer(address indexed _token, address indexed _from, address indexed _to, uint256 _value);\r\n    event TokenApproval(address indexed _token, address indexed _owner, address indexed _spender, uint256 _value);\r\n    event TokenChange(address indexed _sender, address indexed _fromToken, address indexed _toToken, address _changer, uint256 _amount, uint256 _return);\r\n\r\n    function newToken() public;\r\n    function tokenOwnerUpdate(address _prevOwner, address _newOwner) public;\r\n    function tokenChangerUpdate(address _prevChanger, address _newChanger) public;\r\n    function tokenTransfer(address _from, address _to, uint256 _value) public;\r\n    function tokenApproval(address _owner, address _spender, uint256 _value) public;\r\n    function tokenChange(address _fromToken, address _toToken, address _changer, uint256 _amount, uint256 _return) public;\r\n}\n\n// File: solidity/solidity/SmartToken.sol\n\npragma solidity ^0.4.10;\r\r\r\r\r\n\r\n/*\r\n    Smart Token v0.1\r\n*/\r\ncontract SmartToken is Owned, ERC20Token {\r\n    string public version = '0.1';\r\n    uint8 public numDecimalUnits = 0;   // for display purposes only\r\n    address public events = 0x0;        // bancor events contract address\r\n    address public changer = 0x0;       // changer contract address\r\n    bool public transfersEnabled = true;\r\n\r\n    // events, can be used to listen to the contract directly, as opposed to through the events contract\r\n    event ChangerUpdate(address _prevChanger, address _newChanger);\r\n\r\n    /*\r\n        _name               token name\r\n        _symbol             token short symbol, 1-6 characters\r\n        _numDecimalUnits    for display purposes only\r\n        _formula            address of a bancor formula contract\r\n        _events             optional, address of a bancor events contract\r\n    */\r\n    function SmartToken(string _name, string _symbol, uint8 _numDecimalUnits, address _events)\r\n        ERC20Token(_name, _symbol)\r\n    {\r\n        require(bytes(_name).length != 0 && bytes(_symbol).length >= 1 && bytes(_symbol).length <= 6); // validate input\r\n\r\n        numDecimalUnits = _numDecimalUnits;\r\n        events = _events;\r\n        if (events == 0x0)\r\n            return;\r\n\r\n        BancorEventsInterface eventsContract = BancorEventsInterface(events);\r\n        eventsContract.newToken();\r\n    }\r\n\r\n    // allows execution only when transfers aren't disabled\r\n    modifier transfersAllowed {\r\n        assert(transfersEnabled);\r\n        _;\r\n    }\r\n\r\n    // allows execution by the owner if there's no changer defined or by the changer contract if a changer is defined\r\n    modifier managerOnly {\r\n        assert((changer == 0x0 && msg.sender == owner) ||\r\n               (changer != 0x0 && msg.sender == changer)); // validate state & permissions\r\n        _;\r\n    }\r\n\r\n    function setOwner(address _newOwner)\r\n        public\r\n        ownerOnly\r\n        validAddress(_newOwner)\r\n    {\r\n        address prevOwner = owner;\r\n        super.setOwner(_newOwner);\r\n        if (events == 0x0)\r\n            return;\r\n\r\n        BancorEventsInterface eventsContract = BancorEventsInterface(events);\r\n        eventsContract.tokenOwnerUpdate(prevOwner, owner);\r\n    }\r\n\r\n    /*\r\n        sets the number of display decimal units\r\n        can only be called by the token owner\r\n\r\n        _numDecimalUnits    new number of decimal units\r\n    */\r\n    function setNumDecimalUnits(uint8 _numDecimalUnits) public ownerOnly {\r\n        numDecimalUnits = _numDecimalUnits;\r\n    }\r\n\r\n    /*\r\n        disables/enables transfers\r\n        can only be called by the token owner (if no changer is defined) or the changer contract (if a changer is defined)\r\n\r\n        _disable    true to disable transfers, false to enable them\r\n    */\r\n    function disableTransfers(bool _disable) public managerOnly {\r\n        transfersEnabled = !_disable;\r\n    }\r\n\r\n    /*\r\n        increases the token supply and sends the new tokens to an account\r\n        can only be called by the token owner (if no changer is defined) or the changer contract (if a changer is defined)\r\n\r\n        _to         account to receive the new amount\r\n        _amount     amount to increase the supply by\r\n    */\r\n    function issue(address _to, uint256 _amount)\r\n        public\r\n        managerOnly\r\n        validAddress(_to)\r\n        returns (bool success)\r\n    {\r\n         // validate input\r\n        require(_to != address(this) && _amount != 0);\r\n         // supply overflow protection\r\n        assert(totalSupply + _amount >= totalSupply);\r\n        // target account balance overflow protection\r\n        assert(balanceOf[_to] + _amount >= balanceOf[_to]);\r\n\r\n        totalSupply += _amount;\r\n        balanceOf[_to] += _amount;\r\n        dispatchTransfer(this, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n        removes tokens from an account and decreases the token supply\r\n        can only be called by the token owner (if no changer is defined) or the changer contract (if a changer is defined)\r\n\r\n        _from       account to remove the new amount from\r\n        _amount     amount to decrease the supply by\r\n    */\r\n    function destroy(address _from, uint256 _amount)\r\n        public\r\n        managerOnly\r\n        validAddress(_from)\r\n        returns (bool success)\r\n    {\r\n        require(_from != address(this) && _amount != 0 && _amount <= balanceOf[_from]); // validate input\r\n\r\n        totalSupply -= _amount;\r\n        balanceOf[_from] -= _amount;\r\n        dispatchTransfer(_from, this, _amount);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n        sets a changer contract address\r\n        can only be called by the token owner (if no changer is defined) or the changer contract (if a changer is defined)\r\n        the changer can be set to null to transfer ownership from the changer to the owner\r\n\r\n        _changer            new changer contract address (can also be set to 0x0 to remove the current changer)\r\n    */\r\n    function setChanger(address _changer) public managerOnly returns (bool success) {\r\n        require(_changer != changer);\r\n        address prevChanger = changer;\r\n        changer = _changer;\r\n        dispatchChangerUpdate(prevChanger, changer);\r\n        return true;\r\n    }\r\n\r\n    // ERC20 standard method overrides with some extra functionality\r\n\r\n    // send coins\r\n    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool success) {\r\n        assert(super.transfer(_to, _value));\r\n\r\n        // transferring to the contract address destroys tokens\r\n        if (_to == address(this)) {\r\n            balanceOf[_to] -= _value;\r\n            totalSupply -= _value;\r\n        }\r\n\r\n        if (events == 0x0)\r\n            return;\r\n\r\n        BancorEventsInterface eventsContract = BancorEventsInterface(events);\r\n        eventsContract.tokenTransfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // an account/contract attempts to get the coins\r\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool success) {\r\n        assert(super.transferFrom(_from, _to, _value));\r\n\r\n        // transferring to the contract address destroys tokens\r\n        if (_to == address(this)) {\r\n            balanceOf[_to] -= _value;\r\n            totalSupply -= _value;\r\n        }\r\n\r\n        if (events == 0x0)\r\n            return;\r\n\r\n        BancorEventsInterface eventsContract = BancorEventsInterface(events);\r\n        eventsContract.tokenTransfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // allow another account/contract to spend some tokens on your behalf\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        assert(super.approve(_spender, _value));\r\n        if (events == 0x0)\r\n            return true;\r\n\r\n        BancorEventsInterface eventsContract = BancorEventsInterface(events);\r\n        eventsContract.tokenApproval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    // utility\r\n\r\n    function dispatchChangerUpdate(address _prevChanger, address _newChanger) private {\r\n        ChangerUpdate(_prevChanger, _newChanger);\r\n        if (events == 0x0)\r\n            return;\r\n\r\n        BancorEventsInterface eventsContract = BancorEventsInterface(events);\r\n        eventsContract.tokenChangerUpdate(_prevChanger, _newChanger);\r\n    }\r\n\r\n    function dispatchTransfer(address _from, address _to, uint256 _value) private {\r\n        Transfer(_from, _to, _value);\r\n        if (events == 0x0)\r\n            return;\r\n\r\n        BancorEventsInterface eventsContract = BancorEventsInterface(events);\r\n        eventsContract.tokenTransfer(_from, _to, _value);\r\n    }\r\n\r\n    // fallback\r\n    function() {\r\n        assert(false);\r\n    }\r\n}\n","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"changer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_disable\",\"type\":\"bool\"}],\"name\":\"disableTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numDecimalUnits\",\"type\":\"uint8\"}],\"name\":\"setNumDecimalUnits\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"issue\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numDecimalUnits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"destroy\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"events\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transfersEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_changer\",\"type\":\"address\"}],\"name\":\"setChanger\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_numDecimalUnits\",\"type\":\"uint8\"},{\"name\":\"_events\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevChanger\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newChanger\",\"type\":\"address\"}],\"name\":\"ChangerUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"SmartToken","CompilerVersion":"v0.4.10+commit.f0d539ae","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000cfe6685dffffb7e4bd0149417262aa1d974ff1ac000000000000000000000000000000000000000000000000000000000000000565636f696e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006424e4345434f0000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}