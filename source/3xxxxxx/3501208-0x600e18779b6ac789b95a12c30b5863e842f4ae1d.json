{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\ncontract SmartRouletteToken \r\n{\r\n   uint8 public decimals;\r\n   function balanceOf( address who ) external constant returns (uint256);\r\n   function gameListOf( address who ) external constant returns (bool);\r\n   function getItemHolders(uint256 index) external constant returns(address);\r\n   function getCountHolders() external constant returns (uint256);\r\n   function getCountTempHolders() external constant returns(uint256);\r\n   function getItemTempHolders(uint256 index) external constant returns(address);\r\n   function tempTokensBalanceOf( address who ) external constant returns (uint256);\r\n}\r\n\r\ncontract SmartRouletteDividend {\r\n\r\n\taddress developer;\r\n\taddress manager;\r\n\r\n\tSmartRouletteToken smartToken;\r\n\tuint256 decimal;\r\n\r\n\tstruct DividendInfo\r\n\t{\r\n\t   uint256 amountDividend;\r\n\t   uint256 blockDividend;\r\n\t   bool AllPaymentsSent;\r\n\t}\r\n\r\n\tDividendInfo[] dividendHistory;\r\n\r\n\taddress public gameAddress;\r\n\r\n\tuint256 public tokensNeededToGetPayment = 1000;\r\n\r\n\r\n\tfunction SmartRouletteDividend() {\r\n\t\tdeveloper = msg.sender;\r\n\t\tmanager = msg.sender;\r\n\r\n\t\tsmartToken = SmartRouletteToken(0xcced5b8288086be8c38e23567e684c3740be4d48); //test 0xc46ed6ba652bd552671a46045b495748cd10fa04 main 0x2a650356bd894370cc1d6aba71b36c0ad6b3dc18\r\n\t\tdecimal = 10**uint256(smartToken.decimals());\t\t\r\n\t}\r\n\t\r\n\r\n\tmodifier isDeveloper(){\r\n\t\tif (msg.sender!=developer) throw;\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier isManager(){\r\n\t\tif (msg.sender!=manager && msg.sender!=developer) throw;\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction changeTokensLimit(uint256 newTokensLimit) isDeveloper\r\n\t{\r\n\t\ttokensNeededToGetPayment = newTokensLimit;\r\n\t}\r\n\tfunction dividendCount() constant returns(uint256)\r\n\t{\r\n\t\treturn dividendHistory.length;\r\n\t}\r\n\r\n\tfunction SetAllPaymentsSent(uint256 DividendNo) isManager\r\n\t{\r\n\t\tdividendHistory[DividendNo].AllPaymentsSent = true;\r\n\t\t// all fees (30000 gas * tx.gasprice for each transaction)\r\n\t\tif (manager.send(this.balance) == false) throw;\r\n\t}\r\n\r\n\tfunction changeDeveloper(address new_developer)\r\n\tisDeveloper\r\n\t{\r\n\t\tif(new_developer == address(0x0)) throw;\r\n\t\tdeveloper = new_developer;\r\n\t}\r\n\r\n\tfunction changeManager(address new_manager)\r\n\tisDeveloper\r\n\t{\r\n\t\tif(new_manager == address(0x0)) throw;\r\n\t\tmanager = new_manager;\r\n\t}\r\n\r\n\tfunction kill() isDeveloper {\r\n\t\tsuicide(developer);\r\n\t}\r\n\r\n\tfunction getDividendInfo(uint256 index) constant returns(uint256 amountDividend, uint256 blockDividend, bool AllPaymentsSent)\r\n\t{\r\n\t\tamountDividend  = dividendHistory[index].amountDividend;\r\n\t\tblockDividend   = dividendHistory[index].blockDividend;\r\n\t\tAllPaymentsSent = dividendHistory[index].AllPaymentsSent;\r\n\t}\r\n\r\n\r\n\t//  get total count tokens (to calculate profit for one token)\r\n\tfunction get_CountProfitsToken() constant returns(uint256){\r\n\t\tuint256 countProfitsTokens = 0;\r\n\r\n\t\tmapping(address => bool) uniqueHolders;\r\n\r\n\t\tuint256 countHolders = smartToken.getCountHolders();\r\n\t\tfor(uint256 i=0; i<countHolders; i++)\r\n\t\t{\r\n\t\t\taddress holder = smartToken.getItemHolders(i);\r\n\t\t\tif(holder!=address(0x0) && !uniqueHolders[holder])\r\n\t\t\t{\r\n\t\t\t\tuint256 holdersTokens = smartToken.balanceOf(holder);\r\n\t\t\t\tif(holdersTokens>0)\r\n\t\t\t\t{\r\n\t\t\t\t\tuint256 tempTokens = smartToken.tempTokensBalanceOf(holder);\r\n\t\t\t\t\tif((holdersTokens+tempTokens)/decimal >= tokensNeededToGetPayment)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tuniqueHolders[holder]=true;\r\n\t\t\t\t\t\tcountProfitsTokens += (holdersTokens+tempTokens);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tuint256 countTempHolders = smartToken.getCountTempHolders();\r\n\t\tfor(uint256 j=0; j<countTempHolders; j++)\r\n\t\t{\r\n\t\t\taddress temp_holder = smartToken.getItemTempHolders(j);\r\n\t\t\tif(temp_holder!=address(0x0) && !uniqueHolders[temp_holder])\r\n\t\t\t{\r\n\t\t\t\tuint256 token_balance = smartToken.balanceOf(temp_holder);\r\n\t\t\t\tif(token_balance==0)\r\n\t\t\t\t{\r\n\t\t\t\t\tuint256 count_tempTokens = smartToken.tempTokensBalanceOf(temp_holder);\r\n\t\t\t\t\tif(count_tempTokens>0 && count_tempTokens/decimal >= tokensNeededToGetPayment)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tuniqueHolders[temp_holder]=true;\r\n\t\t\t\t\t\tcountProfitsTokens += count_tempTokens;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn countProfitsTokens;\r\n\t}\r\n\r\n\tfunction get_CountAllHolderForProfit() constant returns(uint256){\r\n\t\tuint256 countAllHolders = 0;\r\n\r\n\t\tmapping(address => bool) uniqueHolders;\r\n\r\n\t\tuint256 countHolders = smartToken.getCountHolders();\r\n\t\tfor(uint256 i=0; i<countHolders; i++)\r\n\t\t{\r\n\t\t\taddress holder = smartToken.getItemHolders(i);\r\n\t\t\tif(holder!=address(0x0) && !uniqueHolders[holder])\r\n\t\t\t{\r\n\t\t\t\tuint256 holdersTokens = smartToken.balanceOf(holder);\r\n\t\t\t\tif(holdersTokens>0)\r\n\t\t\t\t{\r\n\t\t\t\t\tuint256 tempTokens = smartToken.tempTokensBalanceOf(holder);\r\n\t\t\t\t\tif((holdersTokens+tempTokens)/decimal >= tokensNeededToGetPayment)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tuniqueHolders[holder] = true;\r\n\t\t\t\t\t\tcountAllHolders += 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tuint256 countTempHolders = smartToken.getCountTempHolders();\r\n\t\tfor(uint256 j=0; j<countTempHolders; j++)\r\n\t\t{\r\n\t\t\taddress temp_holder = smartToken.getItemTempHolders(j);\r\n\t\t\tif(temp_holder!=address(0x0) && !uniqueHolders[temp_holder])\r\n\t\t\t{\r\n\t\t\t\tuint256 token_balance = smartToken.balanceOf(temp_holder);\r\n\t\t\t\tif(token_balance==0)\r\n\t\t\t\t{\r\n\t\t\t\t\tuint256 coun_tempTokens = smartToken.tempTokensBalanceOf(temp_holder);\r\n\t\t\t\t\tif(coun_tempTokens>0 && coun_tempTokens/decimal >= tokensNeededToGetPayment)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tuniqueHolders[temp_holder] = true;\r\n\t\t\t\t\t\tcountAllHolders += 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn countAllHolders;\r\n\t}\r\n\r\n\t// get holders addresses to make payment each of them\r\n\tfunction get_Holders(uint256 position) constant returns(address[64] listHolders, uint256 nextPosition) \r\n\t{\r\n\t\tuint8 n = 0;\t\t\r\n\t\tuint256 countHolders = smartToken.getCountHolders();\r\n\t\tfor(; position < countHolders; position++){\t\t\t\r\n\t\t\taddress holder = smartToken.getItemHolders(position);\r\n\t\t\tif(holder!=address(0x0)){\r\n\t\t\t\tuint256 holdersTokens = smartToken.balanceOf(holder);\r\n\t\t\t\tif(holdersTokens>0){\r\n\t\t\t\t\tuint256 tempTokens = smartToken.tempTokensBalanceOf(holder);\r\n\t\t\t\t\tif((holdersTokens+tempTokens)/decimal >= tokensNeededToGetPayment){\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tlistHolders[n++] = holder;\r\n\t\t\t\t\t\tif (n == 64) \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tnextPosition = position + 1;\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t\r\n\t\tif (position >= countHolders)\r\n\t\t{\t\t\t\r\n\t\t\tuint256 countTempHolders = smartToken.getCountTempHolders();\t\t\t\r\n\t\t\tfor(uint256 j=position-countHolders; j<countTempHolders; j++) \r\n\t\t\t{\t\t\t\t\t\t\t\r\n\t\t\t\taddress temp_holder = smartToken.getItemTempHolders(j);\r\n\t\t\t\tif(temp_holder!=address(0x0)){\r\n\t\t\t\t\tuint256 token_balance = smartToken.balanceOf(temp_holder);\r\n\t\t\t\t\tif(token_balance==0){\r\n\t\t\t\t\t\tuint256 count_tempTokens = smartToken.tempTokensBalanceOf(temp_holder);\r\n\t\t\t\t\t\tif(count_tempTokens>0 && count_tempTokens/decimal >= tokensNeededToGetPayment){\r\n\t\t\t\t\t\t\tlistHolders[n++] = temp_holder;\r\n\t\t\t\t\t\t\tif (n == 64) \r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tnextPosition = position + 1;\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tposition = position + 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tnextPosition = 0;\r\n\t}\r\n\t// Get profit for specified token holder\r\n\t// Function should be executed in blockDividend ! (see struct DividendInfo)\r\n\t// Don't call this function via etherescan.io\r\n\t// Example how to call via JavaScript and web3\r\n\t// var abiDividend = [...];\r\n\t// var holderAddress = \"0xdd94ddf50485f41491c415e7133100e670cd4ef3\";\r\n\t// var dividendIndex = 1;       // starts from zero\r\n\t// var blockDividend = 3527958; // see function getDividendInfo\r\n\t// web3.eth.contract(abiDividend).at(\"0x600e18779b6aC789b95a12C30b5863E842F4ae1d\").get_HoldersProfit(dividendIndex, holderAddress, blockDividend, function(err, profit){\r\n\t//    alert(\"Your profit \" + web3.fromWei(profit).toString(10) + \"ETH\");\r\n\t// });\r\n\tfunction get_HoldersProfit(uint256 dividendPaymentNum, address holder) constant returns(uint256){\r\n\t\tuint256 profit = 0;\r\n\t\tif(holder != address(0x0) && dividendHistory.length > 0 && dividendPaymentNum < dividendHistory.length){\r\n\t\t\tuint256 count_tokens = smartToken.balanceOf(holder) + smartToken.tempTokensBalanceOf(holder);\r\n\t\t\tif(count_tokens/decimal >= tokensNeededToGetPayment){\r\n\t\t\t\tprofit = (count_tokens*dividendHistory[dividendPaymentNum].amountDividend)/get_CountProfitsToken();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn profit;\r\n\t}\r\n\r\n\t// Since the full cycle of calculations in a smart contract costs a big amount of gas and the smart contract is not able to calculate the exact block\r\n\t// the major part of calculations is transferred to the server out of the smart contract (though using functions of reading the smart contract)\r\n\t// In order to confirm fairness of dividends distribution the validating interface with open source code is used (the open version is available at https://smartroulette.io/dividends)\r\n\t// The source code is available at the address https://github.com/Smartroulette/SmartRouletteDividends\r\n\tfunction send_DividendToAddress(address holder, uint256 amount) isManager \r\n\t{\r\n\t\tuint256 avgGasValue = 30000;\r\n\t\tif (amount < avgGasValue * tx.gasprice) throw;\r\n\t\tif(holder.send(amount - avgGasValue * tx.gasprice) == false) throw;\t\r\n\t}\r\n\r\n\tfunction () payable\r\n\t{\r\n\t\tif(smartToken.gameListOf(msg.sender))\r\n\t\t{\r\n\t\t\t// only the one game can be attached to this contract\r\n\t\t\tif (gameAddress == 0) \r\n\t\t\t\tgameAddress = msg.sender;\r\n\t\t\telse if (gameAddress != msg.sender)\r\n\t\t\t\tthrow;\r\n\r\n\t\t\t// do not send new payment until previous is done\r\n\t\t\tif (dividendHistory.length > 0 && dividendHistory[dividendHistory.length - 1].AllPaymentsSent == false) throw;\r\n\r\n\t\t\tdividendHistory.push(DividendInfo(msg.value, block.number, false));\t\t\t\r\n\t\t}\r\n\t\telse \r\n\t\t{\r\n\t\t\tthrow;\r\n\t\t}\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"tokensNeededToGetPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getDividendInfo\",\"outputs\":[{\"name\":\"amountDividend\",\"type\":\"uint256\"},{\"name\":\"blockDividend\",\"type\":\"uint256\"},{\"name\":\"AllPaymentsSent\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_CountProfitsToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"holder\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"send_DividendToAddress\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"DividendNo\",\"type\":\"uint256\"}],\"name\":\"SetAllPaymentsSent\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_developer\",\"type\":\"address\"}],\"name\":\"changeDeveloper\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTokensLimit\",\"type\":\"uint256\"}],\"name\":\"changeTokensLimit\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"dividendPaymentNum\",\"type\":\"uint256\"},{\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"get_HoldersProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"position\",\"type\":\"uint256\"}],\"name\":\"get_Holders\",\"outputs\":[{\"name\":\"listHolders\",\"type\":\"address[64]\"},{\"name\":\"nextPosition\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividendCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_manager\",\"type\":\"address\"}],\"name\":\"changeManager\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_CountAllHolderForProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"}]","ContractName":"SmartRouletteDividend","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://051a8659940d511895996033f124af5daa74414543e0d50f12e6a7d96308c93e"}]}