{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\n/**\r\n * Very basic owned/mortal boilerplate.  Used for basically everything, for\r\n * security/access control purposes.\r\n */\r\ncontract Owned {\r\n  address owner;\r\n\r\n  modifier onlyOwner {\r\n    if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Basic constructor.  The sender is the owner.\r\n   */\r\n  function Owned() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * Transfers ownership of the contract to a new owner.\r\n   * @param newOwner  Who gets to inherit this thing.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    owner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * Shuts down the contract and removes it from the blockchain state.\r\n   * Only available to the owner.\r\n   */\r\n  function shutdown() onlyOwner {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  /**\r\n   * Withdraw all the funds from this contract.\r\n   * Only available to the owner.\r\n   */\r\n  function withdraw() onlyOwner {\r\n    if (!owner.send(this.balance)) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\ncontract LotteryRoundInterface {\r\n  bool public winningNumbersPicked;\r\n  uint256 public closingBlock;\r\n\r\n  function pickTicket(bytes4 picks) payable;\r\n  function randomTicket() payable;\r\n\r\n  function proofOfSalt(bytes32 salt, uint8 N) constant returns(bool);\r\n  function closeGame(bytes32 salt, uint8 N);\r\n  function claimOwnerFee(address payout);\r\n  function withdraw();\r\n  function shutdown();\r\n  function distributeWinnings();\r\n  function claimPrize();\r\n\r\n  function paidOut() constant returns(bool);\r\n  function transferOwnership(address newOwner);\r\n}\r\n\r\n/**\r\n * The meat of the game.  Holds all the rules around picking numbers,\r\n * attempting to establish good sources of entropy, holding the pre-selected\r\n * entropy sources (salt) in a way that is not publicly-revealed, etc.\r\n * The gist is that this is a bit of a PRNG, that advances its entropy each\r\n * time a ticket is picked.\r\n *\r\n * Provides the means to both pick specific numbers or have the PRNG select\r\n * them for the ticketholder.\r\n *\r\n * Also controls payout of winners for a particular round.\r\n */\r\ncontract LotteryRound is LotteryRoundInterface, Owned {\r\n\r\n  /*\r\n    Constants\r\n   */\r\n  // public version string\r\n  string constant VERSION = '0.1.2';\r\n\r\n  // round length\r\n  uint256 constant ROUND_LENGTH = 43200;  // approximately a week\r\n\r\n  // payout fraction (in thousandths):\r\n  uint256 constant PAYOUT_FRACTION = 950;\r\n\r\n  // Cost per ticket\r\n  uint constant TICKET_PRICE = 1 finney;\r\n\r\n  // valid pick mask\r\n  bytes1 constant PICK_MASK = 0x3f; // 0-63\r\n\r\n  /*\r\n    Public variables\r\n   */\r\n  // Pre-selected salt, hashed N times\r\n  // serves as proof-of-salt\r\n  bytes32 public saltHash;\r\n\r\n  // single hash of salt.N.salt\r\n  // serves as proof-of-N\r\n  // 0 < N < 256\r\n  bytes32 public saltNHash;\r\n\r\n  // closing time.\r\n  uint256 public closingBlock;\r\n\r\n  // winning numbers\r\n  bytes4 public winningNumbers;\r\n\r\n  // This becomes true when the numbers have been picked\r\n  bool public winningNumbersPicked = false;\r\n\r\n  // This becomes populated if anyone wins\r\n  address[] public winners;\r\n\r\n  // Stores a flag to signal if the winner has winnings to be claimed\r\n  mapping(address => bool) public winningsClaimable;\r\n\r\n  /**\r\n   * Current picks are from 0 to 63, or 2^6 - 1.\r\n   * Current number of picks is 4\r\n   * Rough odds of winning will be 1 in (2^6)^4, assuming even distributions, etc\r\n   */\r\n  mapping(bytes4 => address[]) public tickets;\r\n  uint256 public nTickets = 0;\r\n\r\n  // Set when winners are drawn, and represents the amount of the contract's current balance that can be paid out.\r\n  uint256 public prizePool;\r\n\r\n  // Set when winners are drawn, and signifies the amount each winner will receive.  In the event of multiple\r\n  // winners, this will be prizePool / winners.length\r\n  uint256 public prizeValue;\r\n\r\n  // The fee at the time winners were picked (if there were winners).  This is the portion of the contract's balance\r\n  // that goes to the contract owner.\r\n  uint256 public ownerFee;\r\n\r\n  // This will be the sha3 hash of the previous entropy + some additional inputs (e.g. randomly-generated hashes, etc)\r\n  bytes32 private accumulatedEntropy;\r\n\r\n  modifier beforeClose {\r\n    if (block.number > closingBlock) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  modifier beforeDraw {\r\n    if (block.number <= closingBlock || winningNumbersPicked) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  modifier afterDraw {\r\n    if (winningNumbersPicked == false) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  // Emitted when the round starts, broadcasting the hidden entropy params, closing block\r\n  // and game version.\r\n  event LotteryRoundStarted(\r\n    bytes32 saltHash,\r\n    bytes32 saltNHash,\r\n    uint256 closingBlock,\r\n    string version\r\n  );\r\n\r\n  // Broadcasted any time a user purchases a ticket.\r\n  event LotteryRoundDraw(\r\n    address indexed ticketHolder,\r\n    bytes4 indexed picks\r\n  );\r\n\r\n  // Broadcast when the round is completed, revealing the hidden entropy sources\r\n  // and the winning picks.\r\n  event LotteryRoundCompleted(\r\n    bytes32 salt,\r\n    uint8 N,\r\n    bytes4 indexed winningPicks,\r\n    uint256 closingBalance\r\n  );\r\n\r\n  // Broadcast for each winner.\r\n  event LotteryRoundWinner(\r\n    address indexed ticketHolder,\r\n    bytes4 indexed picks\r\n  );\r\n\r\n  /**\r\n   * Creates a new Lottery round, and sets the round's parameters.\r\n   *\r\n   * Note that this will implicitly set the factory to be the owner,\r\n   * meaning the factory will need to be able to transfer ownership,\r\n   * to its owner, the C&C contract.\r\n   *\r\n   * @param _saltHash       Hashed salt.  Will be hashed with sha3 N times\r\n   * @param _saltNHash      Hashed proof of N, in the format sha3(salt+N+salt)\r\n   */\r\n  function LotteryRound(\r\n    bytes32 _saltHash,\r\n    bytes32 _saltNHash\r\n  ) payable {\r\n    saltHash = _saltHash;\r\n    saltNHash = _saltNHash;\r\n    closingBlock = block.number + ROUND_LENGTH;\r\n    LotteryRoundStarted(\r\n      saltHash,\r\n      saltNHash,\r\n      closingBlock,\r\n      VERSION\r\n    );\r\n    // start this off with some really poor entropy.\r\n    accumulatedEntropy = block.blockhash(block.number - 1);\r\n  }\r\n\r\n  /**\r\n   * Attempt to generate a new pseudo-random number, while advancing the internal entropy\r\n   * of the contract.  Uses a two-phase approach: first, generates a simple offset [0-255]\r\n   * from simple entropy sources (accumulated, sender, block number).  Uses this offset\r\n   * to index into the history of blockhashes, to attempt to generate some stronger entropy\r\n   * by including previous block hashes.\r\n   *\r\n   * Then advances the interal entropy by rehashing it with the chosen number.\r\n   */\r\n  function generatePseudoRand(bytes32 seed) internal returns(bytes32) {\r\n    uint8 pseudoRandomOffset = uint8(uint256(sha256(\r\n      seed,\r\n      block.difficulty,\r\n      block.coinbase,\r\n      block.timestamp,\r\n      accumulatedEntropy\r\n    )) & 0xff);\r\n    // WARNING: This assumes block.number > 256... If block.number < 256, the below block.blockhash could return 0\r\n    // This is probably only an issue in testing, but shouldn't be a problem there.\r\n    uint256 pseudoRandomBlock = block.number - pseudoRandomOffset - 1;\r\n    bytes32 pseudoRand = sha3(\r\n      block.number,\r\n      block.blockhash(pseudoRandomBlock),\r\n      block.difficulty,\r\n      block.timestamp,\r\n      accumulatedEntropy\r\n    );\r\n    accumulatedEntropy = sha3(accumulatedEntropy, pseudoRand);\r\n    return pseudoRand;\r\n  }\r\n\r\n  /**\r\n   * Buy a ticket with pre-selected picks\r\n   * @param picks User's picks.\r\n   */\r\n  function pickTicket(bytes4 picks) payable beforeClose {\r\n    if (msg.value != TICKET_PRICE) {\r\n      throw;\r\n    }\r\n    // don't allow invalid picks.\r\n    for (uint8 i = 0; i < 4; i++) {\r\n      if (picks[i] & PICK_MASK != picks[i]) {\r\n        throw;\r\n      }\r\n    }\r\n    tickets[picks].push(msg.sender);\r\n    nTickets++;\r\n    generatePseudoRand(bytes32(picks)); // advance the accumulated entropy\r\n    LotteryRoundDraw(msg.sender, picks);\r\n  }\r\n\r\n  /**\r\n   * Interal function to generate valid picks.  Used by both the random\r\n   * ticket functionality, as well as when generating winning picks.\r\n   * Even though the picks are a fixed-width byte array, each pick is\r\n   * chosen separately (e.g. a bytes4 will result in 4 separate sha3 hashes\r\n   * used as sources).\r\n   *\r\n   * Masks the first byte of the seed to use as an offset into the next PRNG,\r\n   * then replaces the seed with the new PRNG.  Pulls a single byte from the\r\n   * resultant offset, masks it to be valid, then adds it to the accumulator.\r\n   *\r\n   * @param seed  The PRNG seed used to pick the numbers.\r\n   */\r\n  function pickValues(bytes32 seed) internal returns (bytes4) {\r\n    bytes4 picks;\r\n    uint8 offset;\r\n    for (uint8 i = 0; i < 4; i++) {\r\n      offset = uint8(seed[0]) & 0x1f;\r\n      seed = sha3(seed, msg.sender);\r\n      picks = (picks >> 8) | bytes1(seed[offset] & PICK_MASK);\r\n    }\r\n    return picks;\r\n  }\r\n\r\n  /**\r\n   * Picks a random ticket, using the internal PRNG and accumulated entropy\r\n   */\r\n  function randomTicket() payable beforeClose {\r\n    if (msg.value != TICKET_PRICE) {\r\n      throw;\r\n    }\r\n    bytes32 pseudoRand = generatePseudoRand(bytes32(msg.sender));\r\n    bytes4 picks = pickValues(pseudoRand);\r\n    tickets[picks].push(msg.sender);\r\n    nTickets++;\r\n    LotteryRoundDraw(msg.sender, picks);\r\n  }\r\n\r\n  /**\r\n   * Public means to prove the salt after numbers are picked.  Not technically necessary\r\n   * for this to be external, because it will be called during the round close process.\r\n   * If the hidden entropy parameters don't match, the contract will refuse to pick\r\n   * numbers or close.\r\n   *\r\n   * @param salt          Hidden entropy source\r\n   * @param N             Secret value proving how to obtain the hashed entropy from the source.\r\n   */\r\n  function proofOfSalt(bytes32 salt, uint8 N) constant returns(bool) {\r\n    // Proof-of-N:\r\n    bytes32 _saltNHash = sha3(salt, N, salt);\r\n    if (_saltNHash != saltNHash) {\r\n      return false;\r\n    }\r\n\r\n    // Proof-of-salt:\r\n    bytes32 _saltHash = sha3(salt);\r\n    for (var i = 1; i < N; i++) {\r\n      _saltHash = sha3(_saltHash);\r\n    }\r\n    if (_saltHash != saltHash) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Internal function to handle tabulating the winners, including edge cases around\r\n   * duplicate winners.  Split out into its own method partially to enable proper\r\n   * testing.\r\n   *\r\n   * @param salt          Hidden entropy source.  Emitted here\r\n   * @param N             Key to the hidden entropy source.\r\n   * @param winningPicks  The winning picks.\r\n   */\r\n  function finalizeRound(bytes32 salt, uint8 N, bytes4 winningPicks) internal {\r\n    winningNumbers = winningPicks;\r\n    winningNumbersPicked = true;\r\n    LotteryRoundCompleted(salt, N, winningNumbers, this.balance);\r\n\r\n    var _winners = tickets[winningNumbers];\r\n    // if we have winners:\r\n    if (_winners.length > 0) {\r\n      // let's dedupe and broadcast the winners before figuring out the prize pool situation.\r\n      for (uint i = 0; i < _winners.length; i++) {\r\n        var winner = _winners[i];\r\n        if (!winningsClaimable[winner]) {\r\n          winners.push(winner);\r\n          winningsClaimable[winner] = true;\r\n          LotteryRoundWinner(winner, winningNumbers);\r\n        }\r\n      }\r\n      // now let's wrap this up by finalizing the prize pool value:\r\n      // There may be some rounding errors in here, but it should only amount to a couple wei.\r\n      prizePool = this.balance * PAYOUT_FRACTION / 1000;\r\n      prizeValue = prizePool / winners.length;\r\n\r\n      // Note that the owner doesn't get to claim a fee until the game is won.\r\n      ownerFee = this.balance - prizePool;\r\n    }\r\n    // we done.\r\n  }\r\n\r\n  /**\r\n   * Reveal the secret sources of entropy, then use them to pick winning numbers.\r\n   *\r\n   * Note that by using no dynamic (e.g. blockhash-based) sources of entropy,\r\n   * censoring this transaction will not change the final outcome of the picks.\r\n   *\r\n   * @param salt          Hidden entropy.\r\n   * @param N             Number of times to hash the hidden entropy to produce the value provided at creation.\r\n   */\r\n  function closeGame(bytes32 salt, uint8 N) onlyOwner beforeDraw {\r\n    // Don't allow picking numbers multiple times.\r\n    if (winningNumbersPicked == true) {\r\n      throw;\r\n    }\r\n\r\n    // prove the pre-selected salt is actually legit.\r\n    if (proofOfSalt(salt, N) != true) {\r\n      throw;\r\n    }\r\n\r\n    bytes32 pseudoRand = sha3(\r\n      salt,\r\n      nTickets,\r\n      accumulatedEntropy\r\n    );\r\n    finalizeRound(salt, N, pickValues(pseudoRand));\r\n  }\r\n\r\n  /**\r\n   * Sends the owner's fee to the specified address.  Note that the\r\n   * owner can only be paid if there actually was a winner. In the\r\n   * event no one wins, the entire balance is carried over into the\r\n   * next round.  No double-dipping here.\r\n   * @param payout        Address to send the owner fee to.\r\n   */\r\n  function claimOwnerFee(address payout) onlyOwner afterDraw {\r\n    if (ownerFee > 0) {\r\n      uint256 value = ownerFee;\r\n      ownerFee = 0;\r\n      if (!payout.send(value)) {\r\n        throw;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Used to withdraw the balance when the round is completed.  This\r\n   * only works if there are either no winners, or all winners + the\r\n   * owner have been paid.\r\n   */\r\n  function withdraw() onlyOwner afterDraw {\r\n    if (paidOut() && ownerFee == 0) {\r\n      if (!owner.send(this.balance)) {\r\n        throw;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Same as above.  This is mostly here because it's overriding the method\r\n   * inherited from `Owned`\r\n   */\r\n  function shutdown() onlyOwner afterDraw {\r\n    if (paidOut() && ownerFee == 0) {\r\n      selfdestruct(owner);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attempt to pay the winners, if any.  If any `send`s fail, the winner\r\n   * will have to collect their winnings on their own.\r\n   */\r\n  function distributeWinnings() onlyOwner afterDraw {\r\n    if (winners.length > 0) {\r\n      for (uint i = 0; i < winners.length; i++) {\r\n        address winner = winners[i];\r\n        bool unclaimed = winningsClaimable[winner];\r\n        if (unclaimed) {\r\n          winningsClaimable[winner] = false;\r\n          if (!winner.send(prizeValue)) {\r\n            // If I can't send you money, dumbshit, you get to claim it on your own.\r\n            // maybe next time don't use a contract or try to exploit the game.\r\n            // Regardless, you're on your own.  Happy birthday to the ground.\r\n            winningsClaimable[winner] = true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if it's after the draw, and either there are no winners, or all the winners have been paid.\r\n   * @return {bool}\r\n   */\r\n  function paidOut() constant returns(bool) {\r\n    // no need to use the modifier on this function, just do the same check\r\n    // and return false instead.\r\n    if (winningNumbersPicked == false) {\r\n      return false;\r\n    }\r\n    if (winners.length > 0) {\r\n      bool claimed = true;\r\n      // if anyone hasn't been sent or claimed their earnings,\r\n      // we still have money to pay out.\r\n      for (uint i = 0; claimed && i < winners.length; i++) {\r\n        claimed = claimed && !winningsClaimable[winners[i]];\r\n      }\r\n      return claimed;\r\n    } else {\r\n      // no winners, nothing to pay.\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Winners can claim their own prizes using this.  If they do\r\n   * something stupid like use a contract, this gives them a\r\n   * a second chance at withdrawing their funds.  Note that\r\n   * this shares an interlock with `distributeWinnings`.\r\n   */\r\n  function claimPrize() afterDraw {\r\n    if (winningsClaimable[msg.sender] == false) {\r\n      // get. out!\r\n      throw;\r\n    }\r\n    winningsClaimable[msg.sender] = false;\r\n    if (!msg.sender.send(prizeValue)) {\r\n      // you really are a dumbshit, aren't you.\r\n      throw;\r\n    }\r\n  }\r\n\r\n  // Man! What do I look like? A charity case?\r\n  // Please.\r\n  // You can't buy me, hot dog man!\r\n  function () {\r\n    throw;\r\n  }\r\n}\r\n\r\ncontract LotteryRoundFactoryInterface {\r\n  string public VERSION;\r\n  function transferOwnership(address newOwner);\r\n}\r\n\r\ncontract LotteryRoundFactoryInterfaceV1 is LotteryRoundFactoryInterface {\r\n  function createRound(bytes32 _saltHash, bytes32 _saltNHash) payable returns(address);\r\n}\r\n\r\ncontract LotteryRoundFactory is LotteryRoundFactoryInterfaceV1, Owned {\r\n\r\n  string public VERSION = '0.1.2';\r\n\r\n  event LotteryRoundCreated(\r\n    address newRound,\r\n    string version\r\n  );\r\n\r\n  /**\r\n   * Creates a new round, and sets the secret (hashed) salt and proof of N.\r\n   * @param _saltHash     Hashed salt\r\n   * @param _saltNHash    Hashed proof of N\r\n   */\r\n  function createRound(\r\n    bytes32 _saltHash,\r\n    bytes32 _saltNHash\r\n  ) payable onlyOwner returns(address) {\r\n    LotteryRound newRound;\r\n    if (msg.value > 0) {\r\n      newRound = (new LotteryRound).value(msg.value)(\r\n        _saltHash,\r\n        _saltNHash\r\n      );\r\n    } else {\r\n      newRound = new LotteryRound(\r\n        _saltHash,\r\n        _saltNHash\r\n      );\r\n    }\r\n\r\n    if (newRound == LotteryRound(0)) {\r\n      throw;\r\n    }\r\n    newRound.transferOwnership(owner);\r\n    LotteryRoundCreated(address(newRound), VERSION);\r\n    return address(newRound);\r\n  }\r\n\r\n  // Man, this ain't my dad!\r\n  // This is a cell phone!\r\n  function () {\r\n    throw;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_saltHash\",\"type\":\"bytes32\"},{\"name\":\"_saltNHash\",\"type\":\"bytes32\"}],\"name\":\"createRound\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"shutdown\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRound\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"string\"}],\"name\":\"LotteryRoundCreated\",\"type\":\"event\"}]","ContractName":"LotteryRoundFactory","CompilerVersion":"v0.4.9+commit.364da425","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f9fd0d37e28429414518f46352d1607babc4a9b47c1285f23c2287874b62c7f8"}]}