{"status":"1","message":"OK","result":[{"SourceCode":"// VERSION J\r\n\r\npragma solidity ^0.4.8;\r\n\r\n\r\n//\r\n// FOR REFERENCE - INCLUDE  iE4RowEscrow  (interface) CONTRACT at the top .....\r\n//\r\n\r\ncontract iE4RowEscrow {\r\n\tfunction getNumGamesStarted() constant returns (int ngames);\r\n}\r\n\r\n// Abstract contract for the full ERC 20 Token standard\r\n// https://github.com/ethereum/EIPs/issues/20\r\n\r\n// ---------------------------------\r\n// ABSTRACT standard token class\r\n// ---------------------------------\r\ncontract Token { \r\n    function totalSupply() constant returns (uint256 supply);\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n// --------------------------\r\n//  E4RowRewards - abstract e4 dividend contract\r\n// --------------------------\r\ncontract E4RowRewards\r\n{\r\n\tfunction checkDividends(address _addr) constant returns(uint _amount);\r\n\tfunction withdrawDividends() public returns (uint namount);\r\n}\r\n\r\n// --------------------------\r\n//  Finney Chip - token contract\r\n// --------------------------\r\ncontract E4Token is Token, E4RowRewards {\r\n    \tevent StatEvent(string msg);\r\n    \tevent StatEventI(string msg, uint val);\r\n\r\n\tenum SettingStateValue  {debug, release, lockedRelease}\r\n\tenum IcoStatusValue {anouncement, saleOpen, saleClosed, failed, succeeded}\r\n\r\n\r\n\r\n\r\n\tstruct tokenAccount {\r\n\t\tbool alloced; // flag to ascert prior allocation\r\n\t\tuint tokens; // num tokens\r\n\t\tuint balance; // rewards balance\r\n\t}\r\n// -----------------------------\r\n//  data storage\r\n// ----------------------------------------\r\n\taddress developers; // developers token holding address\r\n\taddress public owner; // deployer executor\r\n\taddress founderOrg; // founder orginaization contract\r\n\taddress auxPartner; // aux partner (pr/auditing) - 1 percent upon close\r\n\taddress e4_partner; // e4row  contract addresses\r\n\r\n\r\n\tmapping (address => tokenAccount) holderAccounts ; // who holds how many tokens (high two bytes contain curPayId)\r\n\tmapping (uint => address) holderIndexes ; // for iteration thru holder\r\n\tuint numAccounts;\r\n\r\n\tuint partnerCredits; // amount partner (e4row)  has paid\r\n\tmapping (address => mapping (address => uint256)) allowed; // approvals\r\n\r\n\r\n\tuint maxMintableTokens; // ...\r\n\tuint minIcoTokenGoal;// token goal by sale end\r\n\tuint minUsageGoal; //  num games goal by usage deadline\r\n\tuint public  tokenPrice; // price per token\r\n\tuint public payoutThreshold; // threshold till payout\r\n\r\n\tuint totalTokenFundsReceived; \t// running total of token funds received\r\n\tuint public totalTokensMinted; \t// total number of tokens minted\r\n\tuint public holdoverBalance; \t\t// hold this amount until threshhold before reward payout\r\n\tint public payoutBalance; \t\t// hold this amount until threshhold before reward payout\r\n\tint prOrigPayoutBal;\t\t\t// original payout balance before run\r\n\tuint prOrigTokensMint; \t\t\t// tokens minted at start of pay run\r\n\tuint public curPayoutId;\t\t// current payout id\r\n\tuint public lastPayoutIndex;\t\t// payout idx between run segments\r\n\tuint public maxPaysPer;\t\t\t// num pays per segment\r\n\tuint public minPayInterval;\t\t// min interval between start pay run\r\n\r\n\r\n\tuint fundingStart; \t\t// funding start time immediately after anouncement\r\n\tuint fundingDeadline; \t\t// funding end time\r\n\tuint usageDeadline; \t\t// deadline where minimum usage needs to be met before considered success\r\n\tuint public lastPayoutTime; \t// timestamp of last payout time\r\n\tuint vestTime; \t\t// 1 year past sale vest developer tokens\r\n\tuint numDevTokens; \t// 10 per cent of tokens after close to developers\r\n\tbool developersGranted; \t\t// flag\r\n\tuint remunerationStage; \t// 0 for not yet, 1 for 10 percent, 2 for remaining  upon succeeded.\r\n\tuint public remunerationBalance; \t// remuneration balance to release token funds\r\n\tuint auxPartnerBalance; \t// aux partner balance - 1 percent\r\n\tuint rmGas; // remuneration gas\r\n\tuint rwGas; // reward gas\r\n\tuint rfGas; // refund gas\r\n\r\n\tIcoStatusValue icoStatus;  // current status of ico\r\n\tSettingStateValue public settingsState;\r\n\r\n\r\n\t// --------------------\r\n\t// contract constructor\r\n\t// --------------------\r\n\tfunction E4Token() \r\n\t{\r\n\t\towner = msg.sender;\r\n\t\tdevelopers = msg.sender;\r\n\t}\r\n\r\n\t// -----------------------------------\r\n\t// use this to reset everything, will never be called after lockRelease\r\n\t// -----------------------------------\r\n\tfunction applySettings(SettingStateValue qState, uint _saleStart, uint _saleEnd, uint _usageEnd, uint _minUsage, uint _tokGoal, uint  _maxMintable, uint _threshold, uint _price, uint _mpp, uint _mpi )\r\n\t{\r\n\t\tif (msg.sender != owner) \r\n\t\t\treturn;\r\n\r\n\t\t// these settings are permanently tweakable for performance adjustments\r\n\t\tpayoutThreshold = _threshold;\r\n\t\tmaxPaysPer = _mpp;\r\n\t\tminPayInterval = _mpi;\r\n\r\n\t\t// this first test checks if already locked\r\n\t\tif (settingsState == SettingStateValue.lockedRelease)\r\n\t\t\treturn;\r\n\r\n \t \tsettingsState = qState;\r\n\r\n\t\t// this second test allows locking without changing other permanent settings\r\n\t\t// WARNING, MAKE SURE YOUR'RE HAPPY WITH ALL SETTINGS \r\n\t\t// BEFORE LOCKING\r\n\r\n\t\tif (qState == SettingStateValue.lockedRelease) {\r\n\t\t\tStatEvent(\"Locking!\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\ticoStatus = IcoStatusValue.anouncement;\r\n\r\n\t\trmGas = 100000; // remuneration gas\r\n\t\trwGas = 10000; // reward gas\r\n\t\trfGas = 10000; // refund gas\r\n\r\n\r\n\t\t// zero out all token holders.  \r\n\t\t// leave alloced on, leave num accounts\r\n\t\t// cant delete them anyways\r\n\t\r\n\t\tif (totalTokensMinted > 0) {\r\n\t\t\tfor (uint i = 0; i < numAccounts; i++ ) {\r\n\t\t\t\taddress a = holderIndexes[i];\r\n\t\t\t\tif (a != address(0)) {\r\n\t\t\t\t\tholderAccounts[a].tokens = 0;\r\n\t\t\t\t\tholderAccounts[a].balance = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// do not reset numAccounts!\r\n\r\n\t\ttotalTokensMinted = 0; // this will erase\r\n\t\ttotalTokenFundsReceived = 0; // this will erase.\r\n\t\te4_partner = address(0); // must be reset again\r\n\r\n\t\tfundingStart =  _saleStart;\r\n\t\tfundingDeadline = _saleEnd;\r\n\t\tusageDeadline = _usageEnd;\r\n\t\tminUsageGoal = _minUsage;\r\n\t\tminIcoTokenGoal = _tokGoal;\r\n\t\tmaxMintableTokens = _maxMintable;\r\n\t\ttokenPrice = _price;\r\n\r\n\t\tvestTime = fundingStart + (365 days);\r\n\t\tnumDevTokens = 0;\r\n\t\t\r\n\t\tholdoverBalance = 0;\r\n\t\tpayoutBalance = 0;\r\n\t\tcurPayoutId = 1;\r\n\t\tlastPayoutIndex = 0;\r\n\t\tremunerationStage = 0;\r\n\t\tremunerationBalance = 0;\r\n\t\tauxPartnerBalance = 0;\r\n\t\tdevelopersGranted = false;\r\n\t\tlastPayoutTime = 0;\r\n\r\n\t\tif (this.balance > 0) {\r\n\t\t\tif (!owner.call.gas(rfGas).value(this.balance)())\r\n\t\t\t\tStatEvent(\"ERROR!\");\r\n\t\t}\r\n\t\tStatEvent(\"ok\");\r\n\r\n\t}\r\n\r\n\r\n\t// ---------------------------------------------------\r\n\t// tokens held reserve the top two bytes for the payid last paid.\r\n\t// this is so holders at the top of the list dont transfer tokens \r\n\t// to themselves on the bottom of the list thus scamming the \r\n\t// system. this function deconstructs the tokenheld value.\r\n\t// ---------------------------------------------------\r\n\tfunction getPayIdAndHeld(uint _tokHeld) internal returns (uint _payId, uint _held)\r\n\t{\r\n\t\t_payId = (_tokHeld / (2 ** 48)) & 0xffff;\r\n\t\t_held = _tokHeld & 0xffffffffffff;\r\n\t}\r\n\tfunction getHeld(uint _tokHeld) internal  returns (uint _held)\r\n\t{\r\n\t\t_held = _tokHeld & 0xffffffffffff;\r\n\t}\r\n\t// ---------------------------------------------------\r\n\t// allocate a new account by setting alloc to true\r\n\t// set the top to bytes of tokens to cur pay id to leave out of current round\r\n\t// add holder index, bump the num accounts\r\n\t// ---------------------------------------------------\r\n\tfunction addAccount(address _addr) internal  {\r\n\t\tholderAccounts[_addr].alloced = true;\r\n\t\tholderAccounts[_addr].tokens = (curPayoutId * (2 ** 48));\r\n\t\tholderIndexes[numAccounts++] = _addr;\r\n\t}\r\n\t\r\n\r\n// --------------------------------------\r\n// BEGIN ERC-20 from StandardToken\r\n// --------------------------------------\r\n\tfunction totalSupply() constant returns (uint256 supply)\r\n\t{\r\n\t\tif (icoStatus == IcoStatusValue.saleOpen\r\n\t\t\t|| icoStatus == IcoStatusValue.anouncement)\r\n\t\t\tsupply = maxMintableTokens;\r\n\t\telse\r\n\t\t\tsupply = totalTokensMinted;\r\n\t}\r\n\r\n\tfunction transfer(address _to, uint256 _value) returns (bool success) {\r\n\r\n\t\tif ((msg.sender == developers) \r\n\t\t\t&&  (now < vestTime)) {\r\n\t\t\t//statEvent(\"Tokens not yet vested.\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\r\n\t        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n\t        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n\t        //Replace the if with this one instead.\r\n\t        //if (holderAccounts[msg.sender] >= _value && balances[_to] + _value > holderAccounts[_to]) {\r\n\r\n\t\tvar (pidFrom, heldFrom) = getPayIdAndHeld(holderAccounts[msg.sender].tokens);\r\n\t        if (heldFrom >= _value && _value > 0) {\r\n\r\n\t            holderAccounts[msg.sender].tokens -= _value;\r\n\r\n\t\t    if (!holderAccounts[_to].alloced) {\r\n\t\t\taddAccount(_to);\r\n\t\t    }\r\n\r\n\t\t    uint newHeld = _value + getHeld(holderAccounts[_to].tokens);\r\n\t\t    holderAccounts[_to].tokens = newHeld | (pidFrom * (2 ** 48));\r\n\t            Transfer(msg.sender, _to, _value);\r\n\t            return true;\r\n\t        } else { \r\n\t\t\treturn false; \r\n\t\t}\r\n    \t}\r\n\r\n    \tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n\r\n\t\tif ((_from == developers) \r\n\t\t\t&&  (now < vestTime)) {\r\n\t\t\t//statEvent(\"Tokens not yet vested.\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n\r\n\t\tvar (pidFrom, heldFrom) = getPayIdAndHeld(holderAccounts[_from].tokens);\r\n        \tif (heldFrom >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n\t            holderAccounts[_from].tokens -= _value;\r\n\r\n\t\t    if (!holderAccounts[_to].alloced)\r\n\t\t\taddAccount(_to);\r\n\r\n\t\t    uint newHeld = _value + getHeld(holderAccounts[_to].tokens);\r\n\r\n\t\t    holderAccounts[_to].tokens = newHeld | (pidFrom * (2 ** 48));\r\n\t            allowed[_from][msg.sender] -= _value;\r\n\t            Transfer(_from, _to, _value);\r\n\t            return true;\r\n\t        } else { \r\n\t\t    return false; \r\n\t\t}\r\n\t}\r\n\r\n\r\n    \tfunction balanceOf(address _owner) constant returns (uint256 balance) {\r\n\t\t// vars default to 0\r\n\t\tif (holderAccounts[_owner].alloced) {\r\n\t        \tbalance = getHeld(holderAccounts[_owner].tokens);\r\n\t\t} \r\n    \t}\r\n\r\n    \tfunction approve(address _spender, uint256 _value) returns (bool success) {\r\n        \tallowed[msg.sender][_spender] = _value;\r\n        \tApproval(msg.sender, _spender, _value);\r\n        \treturn true;\r\n    \t}\r\n\r\n    \tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      \t\treturn allowed[_owner][_spender];\r\n    \t}\r\n// ----------------------------------\r\n// END ERC20\r\n// ----------------------------------\r\n\r\n  \r\n\t// -------------------------------------------\r\n\t// check the alloced\r\n\t// -------------------------------------------\r\n\tfunction holderExists(address _addr) returns(bool _exist)\r\n\t{\r\n\t\t_exist = holderAccounts[_addr].alloced;\r\n\t}\r\n\r\n\r\n\r\n\t// -------------------------------------------\r\n\t// default payable function.\r\n\t// if sender is e4row  partner, this is a rake fee payment\r\n\t// otherwise this is a token purchase.\r\n\t// tokens only purchaseable between tokenfundingstart and end\r\n\t// -------------------------------------------\r\n\tfunction () payable {\r\n\t\tif (msg.sender == e4_partner) {\r\n\t\t     feePayment(); // from e4row game escrow contract\r\n\t\t} else {\r\n\t\t     purchaseToken();\r\n\t\t}\r\n\t}\r\n\r\n\t// -----------------------------\r\n\t// purchase token function - tokens only sold during sale period up until the max tokens\r\n\t// purchase price is tokenPrice.  all units in wei.\r\n\t// purchaser will not be included in current pay run\r\n\t// -----------------------------\r\n\tfunction purchaseToken() payable {\r\n\r\n\t\tuint nvalue = msg.value; // being careful to preserve msg.value\r\n\t\taddress npurchaser = msg.sender;\r\n\t\tif (nvalue < tokenPrice) \r\n\t\t\tthrow;\r\n\r\n\t\tuint qty = nvalue/tokenPrice;\r\n\t\tupdateIcoStatus();\r\n\t\tif (icoStatus != IcoStatusValue.saleOpen) // purchase is closed\r\n\t\t\tthrow;\r\n\t\tif (totalTokensMinted + qty > maxMintableTokens)\r\n\t\t\tthrow;\r\n\t\tif (!holderAccounts[npurchaser].alloced)\r\n\t\t\taddAccount(npurchaser);\r\n\t\t\r\n\t\t// purchaser waits for next payrun. otherwise can disrupt cur pay run\r\n\t\tuint newHeld = qty + getHeld(holderAccounts[npurchaser].tokens);\r\n\t\tholderAccounts[npurchaser].tokens = newHeld | (curPayoutId * (2 ** 48));\r\n\r\n\t\ttotalTokensMinted += qty;\r\n\t\ttotalTokenFundsReceived += nvalue;\r\n\r\n\t\tif (totalTokensMinted == maxMintableTokens) {\r\n\t\t\ticoStatus = IcoStatusValue.saleClosed;\r\n\t\t\t//test unnecessary -  if (getNumTokensPurchased() >= minIcoTokenGoal)\r\n\t\t\tdoDeveloperGrant();\r\n\t\t\tStatEventI(\"Purchased,Granted\", qty);\r\n\t\t} else\r\n\t\t\tStatEventI(\"Purchased\", qty);\r\n\r\n\t}\r\n\r\n\r\n\t// ---------------------------\r\n\t// accept payment from e4row contract\r\n\t// ---------------------------\r\n\tfunction feePayment() payable  \r\n\t{\r\n\t\tif (msg.sender != e4_partner) {\r\n\t\t\tStatEvent(\"forbidden\");\r\n\t\t\treturn; // thank you\r\n\t\t}\r\n\t\tuint nfvalue = msg.value; // preserve value in case changed in dev grant\r\n\r\n\t\tupdateIcoStatus();\r\n\r\n\t\tholdoverBalance += nfvalue;\r\n\t\tpartnerCredits += nfvalue;\r\n\t\tStatEventI(\"Payment\", nfvalue);\r\n\r\n\t\tif (holdoverBalance > payoutThreshold\r\n\t\t\t|| payoutBalance > 0)\r\n\t\t\tdoPayout(maxPaysPer);\r\n\t\t\r\n\t\r\n\t}\r\n\r\n\t// ---------------------------\r\n\t// set the e4row partner, this is only done once\r\n\t// ---------------------------\r\n\tfunction setE4RowPartner(address _addr) public\t\r\n\t{\r\n\t// ONLY owner can set and ONLY ONCE! (unless \"unlocked\" debug)\r\n\t// once its locked. ONLY ONCE!\r\n\t\tif (msg.sender == owner) {\r\n\t\t\tif ((e4_partner == address(0)) || (settingsState == SettingStateValue.debug)) {\r\n\t\t\t\te4_partner = _addr;\r\n\t\t\t\tpartnerCredits = 0;\r\n\t\t\t\t//StatEventI(\"E4-Set\", 0);\r\n\t\t\t} else {\r\n\t\t\t\tStatEvent(\"Already Set\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// ----------------------------\r\n\t// return the total tokens purchased\r\n\t// ----------------------------\r\n\tfunction getNumTokensPurchased() constant returns(uint _purchased)\r\n\t{\r\n\t\t_purchased = totalTokensMinted-numDevTokens;\r\n\t}\r\n\r\n\t// ----------------------------\r\n\t// return the num games as reported from the e4row  contract\r\n\t// ----------------------------\r\n\tfunction getNumGames() constant returns(uint _games)\r\n\t{\r\n\t\t//_games = 0;\r\n\t\tif (e4_partner != address(0)) {\r\n\t\t\tiE4RowEscrow pe4 = iE4RowEscrow(e4_partner);\r\n\t\t\t_games = uint(pe4.getNumGamesStarted());\r\n\t\t} \r\n\t\t//else\r\n\t\t//StatEvent(\"Empty E4\");\r\n\t}\r\n\r\n\t// ------------------------------------------------\r\n\t// get the founders, auxPartner, developer\r\n\t// --------------------------------------------------\r\n\tfunction getSpecialAddresses() constant returns (address _fndr, address _aux, address _dev, address _e4)\r\n\t{\r\n\t\t//if (_sender == owner) { // no msg.sender on constant functions at least in mew\r\n\t\t\t_fndr = founderOrg;\r\n\t\t\t_aux = auxPartner;\r\n\t\t\t_dev = developers;\r\n\t\t\t_e4  = e4_partner;\r\n\t\t//}\r\n\t}\r\n\r\n\r\n\r\n\t// ----------------------------\r\n\t// update the ico status\r\n\t// ----------------------------\r\n\tfunction updateIcoStatus() public\r\n\t{\r\n\t\tif (icoStatus == IcoStatusValue.succeeded \r\n\t\t\t|| icoStatus == IcoStatusValue.failed)\r\n\t\t\treturn;\r\n\t\telse if (icoStatus == IcoStatusValue.anouncement) {\r\n\t\t\tif (now > fundingStart && now <= fundingDeadline) {\r\n\t\t\t\ticoStatus = IcoStatusValue.saleOpen;\r\n\t\t\t\t\r\n\t\t\t} else if (now > fundingDeadline) {\r\n\t\t\t\t// should not be here - this will eventually fail\r\n\t\t\t\ticoStatus = IcoStatusValue.saleClosed;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tuint numP = getNumTokensPurchased();\r\n\t\t\tuint numG = getNumGames();\r\n\t\t\tif ((now > fundingDeadline && numP < minIcoTokenGoal)\r\n\t\t\t\t|| (now > usageDeadline && numG < minUsageGoal)) {\r\n\t\t\t\ticoStatus = IcoStatusValue.failed;\r\n\t\t\t} else if ((now > fundingDeadline) // dont want to prevent more token sales\r\n\t\t\t\t&& (numP >= minIcoTokenGoal)\r\n\t\t\t\t&& (numG >= minUsageGoal)) {\r\n\t\t\t\ticoStatus = IcoStatusValue.succeeded; // hooray\r\n\t\t\t}\r\n\t\t\tif (icoStatus == IcoStatusValue.saleOpen\r\n\t\t\t\t&& ((numP >= maxMintableTokens)\r\n\t\t\t\t|| (now > fundingDeadline))) {\r\n\t\t\t\t\ticoStatus = IcoStatusValue.saleClosed;\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!developersGranted\r\n\t\t\t&& icoStatus != IcoStatusValue.saleOpen \r\n\t\t\t&& icoStatus != IcoStatusValue.anouncement\r\n\t\t\t&& getNumTokensPurchased() >= minIcoTokenGoal) {\r\n\t\t\t\tdoDeveloperGrant(); // grant whenever status goes from open to anything...\r\n\t\t}\r\n\r\n\t\r\n\t}\r\n\r\n\t\r\n\t// ----------------------------\r\n\t// request refund. Caller must call to request and receive refund \r\n\t// WARNING - withdraw rewards/dividends before calling.\r\n\t// YOU HAVE BEEN WARNED\r\n\t// ----------------------------\r\n\tfunction requestRefund()\r\n\t{\r\n\t\taddress nrequester = msg.sender;\r\n\t\tupdateIcoStatus();\r\n\r\n\t\tuint ntokens = getHeld(holderAccounts[nrequester].tokens);\r\n\t\tif (icoStatus != IcoStatusValue.failed)\r\n\t\t\tStatEvent(\"No Refund\");\r\n\t\telse if (ntokens == 0)\r\n\t\t\tStatEvent(\"No Tokens\");\r\n\t\telse {\r\n\t\t\tuint nrefund = ntokens * tokenPrice;\r\n\t\t\tif (getNumTokensPurchased() >= minIcoTokenGoal)\r\n\t\t\t\tnrefund -= (nrefund /10); // only 90 percent b/c 10 percent payout\r\n\r\n\t\t\tholderAccounts[developers].tokens += ntokens;\r\n\t\t\tholderAccounts[nrequester].tokens = 0;\r\n\t\t\tif (holderAccounts[nrequester].balance > 0) {\r\n\t\t\t\t// see above warning!!\r\n\t\t\t\tif (!holderAccounts[developers].alloced) \r\n\t\t\t\t\taddAccount(developers);\r\n\t\t\t\tholderAccounts[developers].balance += holderAccounts[nrequester].balance;\r\n\t\t\t\tholderAccounts[nrequester].balance = 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (!nrequester.call.gas(rfGas).value(nrefund)())\r\n\t\t\t\tthrow;\r\n\t\t\t//StatEventI(\"Refunded\", nrefund);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\t// ---------------------------------------------------\r\n\t// payout rewards to all token holders\r\n\t// use a second holding variable called PayoutBalance to do \r\n\t// the actual payout from b/c too much gas to iterate thru \r\n\t// each payee. Only start a new run at most once per \"minpayinterval\".\r\n\t// Its done in runs of \"_numPays\"\r\n\t// we use special coding for the holderAccounts to avoid a hack\r\n\t// of getting paid at the top of the list then transfering tokens\r\n\t// to another address at the bottom of the list.\r\n\t// because of that each holderAccounts entry gets the payoutid stamped upon it (top two bytes)\r\n\t// also a token transfer will transfer the payout id.\r\n\t// ---------------------------------------------------\r\n\tfunction doPayout(uint _numPays)  internal\r\n\t{\r\n\t\tif (totalTokensMinted == 0)\r\n\t\t\treturn;\r\n\r\n\t\tif ((holdoverBalance > 0) \r\n\t\t\t&& (payoutBalance == 0)\r\n\t\t\t&& (now > (lastPayoutTime+minPayInterval))) {\r\n\t\t\t// start a new run\r\n\t\t\tcurPayoutId++;\r\n\t\t\tif (curPayoutId >= 32768)\r\n\t\t\t\tcurPayoutId = 1;\r\n\t\t\tlastPayoutTime = now;\r\n\t\t\tpayoutBalance = int(holdoverBalance);\r\n\t\t\tprOrigPayoutBal = payoutBalance;\r\n\t\t\tprOrigTokensMint = totalTokensMinted;\r\n\t\t\tholdoverBalance = 0;\r\n\t\t\tlastPayoutIndex = 0;\r\n\t\t\tStatEventI(\"StartRun\", uint(curPayoutId));\r\n\t\t} else if (payoutBalance > 0) {\r\n\t\t\t// work down the p.o.b\r\n\t\t\tuint nAmount;\r\n\t\t\tuint nPerTokDistrib = uint(prOrigPayoutBal)/prOrigTokensMint;\r\n\t\t\tuint paids = 0;\r\n\t\t\tuint i; // intentional\r\n\t\t\tfor (i = lastPayoutIndex; (paids < _numPays) && (i < numAccounts) && (payoutBalance > 0); i++ ) {\r\n\t\t\t\taddress a = holderIndexes[i];\r\n\t\t\t\tif (a == address(0)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tvar (pid, held) = getPayIdAndHeld(holderAccounts[a].tokens);\r\n\t\t\t\tif ((held > 0) && (pid != curPayoutId)) {\r\n\t\t\t\t\tnAmount = nPerTokDistrib * held;\r\n\t\t\t\t\tif (int(nAmount) <= payoutBalance){\r\n\t\t\t\t\t\tholderAccounts[a].balance += nAmount; \r\n\t\t\t\t\t\tholderAccounts[a].tokens = (curPayoutId * (2 ** 48)) | held;\r\n\t\t\t\t\t\tpayoutBalance -= int(nAmount);\t\t\t\t\t\r\n\t\t\t\t\t\tpaids++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlastPayoutIndex = i;\r\n\t\t\tif (lastPayoutIndex >= numAccounts || payoutBalance <= 0) {\r\n\t\t\t\tlastPayoutIndex = 0;\r\n\t\t\t\tif (payoutBalance > 0)\r\n\t\t\t\t\tholdoverBalance += uint(payoutBalance);// put back any leftovers\r\n\t\t\t\tpayoutBalance = 0;\r\n\t\t\t\tStatEventI(\"RunComplete\", uint(prOrigPayoutBal) );\r\n\r\n\t\t\t} else {\r\n\t\t\t\tStatEventI(\"PayRun\", paids );\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\r\n\t// ----------------------------\r\n\t// sender withdraw entire rewards/dividends\r\n\t// ----------------------------\r\n\tfunction withdrawDividends() public returns (uint _amount)\r\n\t{\r\n\t\tif (holderAccounts[msg.sender].balance == 0) { \r\n\t\t\t//_amount = 0;\r\n\t\t\tStatEvent(\"0 Balance\");\r\n\t\t\treturn;\r\n\t\t} else {\r\n\t\t\tif ((msg.sender == developers) \r\n\t\t\t\t&&  (now < vestTime)) {\r\n\t\t\t\t//statEvent(\"Tokens not yet vested.\");\r\n\t\t\t\t//_amount = 0;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t_amount = holderAccounts[msg.sender].balance; \r\n\t\t\tholderAccounts[msg.sender].balance = 0; \r\n\t\t\tif (!msg.sender.call.gas(rwGas).value(_amount)())\r\n\t\t\t\tthrow;\r\n\t\t\t//StatEventI(\"Paid\", _amount);\r\n\t\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// ----------------------------\r\n\t// set gas for operations\r\n\t// ----------------------------\r\n\tfunction setOpGas(uint _rm, uint _rf, uint _rw)\r\n\t{\r\n\t\tif (msg.sender != owner && msg.sender != developers) {\r\n\t\t\t//StatEvent(\"only owner calls\");\r\n\t\t\treturn;\r\n\t\t} else {\r\n\t\t\trmGas = _rm;\r\n\t\t\trfGas = _rf;\r\n\t\t\trwGas = _rw;\r\n\t\t}\r\n\t}\r\n\r\n\t// ----------------------------\r\n\t// get gas for operations\r\n\t// ----------------------------\r\n\tfunction getOpGas() constant returns (uint _rm, uint _rf, uint _rw)\r\n\t{\r\n\t\t_rm = rmGas;\r\n\t\t_rf = rfGas;\r\n\t\t_rw = rwGas;\r\n\t}\r\n \r\n\r\n\t// ----------------------------\r\n\t// check rewards.  pass in address of token holder\r\n\t// ----------------------------\r\n\tfunction checkDividends(address _addr) constant returns(uint _amount)\r\n\t{\r\n\t\tif (holderAccounts[_addr].alloced)\r\n\t\t\t_amount = holderAccounts[_addr].balance;\r\n\t}\t\t\r\n\r\n\r\n\t// ------------------------------------------------\r\n\t// icoCheckup - check up call for administrators\r\n\t// after sale is closed if min ico tokens sold, 10 percent will be distributed to \r\n\t// company to cover various operating expenses\r\n\t// after sale and usage dealines have been met, remaining 90 percent will be distributed to\r\n\t// company.\r\n\t// ------------------------------------------------\r\n\tfunction icoCheckup() public\r\n\t{\r\n\t\tif (msg.sender != owner && msg.sender != developers)\r\n\t\t\tthrow;\r\n\r\n\t\tuint nmsgmask;\r\n\t\t//nmsgmask = 0;\r\n\t\r\n\t\tif (icoStatus == IcoStatusValue.saleClosed) {\r\n\t\t\tif ((getNumTokensPurchased() >= minIcoTokenGoal)\r\n\t\t\t\t&& (remunerationStage == 0 )) {\r\n\t\t\t\tremunerationStage = 1;\r\n\t\t\t\tremunerationBalance = (totalTokenFundsReceived/100)*9; // 9 percent\r\n\t\t\t\tauxPartnerBalance =  (totalTokenFundsReceived/100); // 1 percent\r\n\t\t\t\tnmsgmask |= 1;\r\n\t\t\t} \r\n\t\t}\r\n\t\tif (icoStatus == IcoStatusValue.succeeded) {\r\n\t\t\r\n\t\t\tif (remunerationStage == 0 ) {\r\n\t\t\t\tremunerationStage = 1;\r\n\t\t\t\tremunerationBalance = (totalTokenFundsReceived/100)*9; \r\n\t\t\t\tauxPartnerBalance =  (totalTokenFundsReceived/100);\r\n\t\t\t\tnmsgmask |= 4;\r\n\t\t\t}\r\n\t\t\tif (remunerationStage == 1) { // we have already suceeded\r\n\t\t\t\tremunerationStage = 2;\r\n\t\t\t\tremunerationBalance += totalTokenFundsReceived - (totalTokenFundsReceived/10); // 90 percent\r\n\t\t\t\tnmsgmask |= 8;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tuint ntmp;\r\n\r\n\t\tif (remunerationBalance > 0) { \r\n\t\t// only pay one entity per call, dont want to run out of gas\r\n\t\t\t\tntmp = remunerationBalance;\r\n\t\t\t\tremunerationBalance = 0;\r\n\t\t\t\tif (!founderOrg.call.gas(rmGas).value(ntmp)()) {\r\n\t\t\t\t\tremunerationBalance = ntmp;\r\n\t\t\t\t\tnmsgmask |= 32;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnmsgmask |= 64;\r\n\t\t\t\t}\t\r\n\t\t} else \tif (auxPartnerBalance > 0) {\r\n\t\t// note the \"else\" only pay one entity per call, dont want to run out of gas\r\n\t\t\tntmp = auxPartnerBalance;\r\n\t\t\tauxPartnerBalance = 0;\r\n\t\t\tif (!auxPartner.call.gas(rmGas).value(ntmp)()) {\r\n\t\t\t\tauxPartnerBalance = ntmp;\r\n\t\t\t\tnmsgmask |= 128;\r\n\t\t\t}  else {\r\n\t\t\t\tnmsgmask |= 256;\r\n\t\t\t}\r\n\r\n\t\t} \r\n\t\t\r\n\t\tStatEventI(\"ico-checkup\", nmsgmask);\r\n\t}\r\n\r\n\r\n\t// ----------------------------\r\n\t// swap executor\r\n\t// ----------------------------\r\n\tfunction changeOwner(address _addr) \r\n\t{\r\n\t\tif (msg.sender != owner\r\n\t\t\t|| settingsState == SettingStateValue.lockedRelease)\r\n\t\t\t throw;\r\n\r\n\t\towner = _addr;\r\n\t}\r\n\r\n\t// ----------------------------\r\n\t// swap developers account\r\n\t// ----------------------------\r\n\tfunction changeDevevoperAccont(address _addr) \r\n\t{\r\n\t\tif (msg.sender != owner\r\n\t\t\t|| settingsState == SettingStateValue.lockedRelease)\r\n\t\t\t throw;\r\n\t\tdevelopers = _addr;\r\n\t}\r\n\r\n\t// ----------------------------\r\n\t// change founder\r\n\t// ----------------------------\r\n\tfunction changeFounder(address _addr) \r\n\t{\r\n\t\tif (msg.sender != owner\r\n\t\t\t|| settingsState == SettingStateValue.lockedRelease)\r\n\t\t\t throw;\r\n\t\tfounderOrg = _addr;\r\n\t}\r\n\r\n\t// ----------------------------\r\n\t// change auxPartner\r\n\t// ----------------------------\r\n\tfunction changeAuxPartner(address _aux) \r\n\t{\r\n\t\tif (msg.sender != owner\r\n\t\t\t|| settingsState == SettingStateValue.lockedRelease)\r\n\t\t\t throw;\r\n\t\tauxPartner = _aux;\r\n\t}\r\n\r\n\r\n\t// ----------------------------\r\n\t// DEBUG ONLY - end this contract, suicide to developers\r\n\t// ----------------------------\r\n\tfunction haraKiri()\r\n\t{\r\n\t\tif (settingsState != SettingStateValue.debug)\r\n\t\t\tthrow;\r\n\t\tif (msg.sender != owner)\r\n\t\t\t throw;\r\n\t\tsuicide(developers);\r\n\t}\r\n\r\n\t// ----------------------------\r\n\t// get all ico status, funding and usage info\r\n\t// ----------------------------\r\n\tfunction getIcoInfo() constant returns(IcoStatusValue _status, uint _saleStart, uint _saleEnd, uint _usageEnd, uint _saleGoal, uint _usageGoal, uint _sold, uint _used, uint _funds, uint _credits, uint _remuStage, uint _vest)\r\n\t{\r\n\t\t_status = icoStatus;\r\n\t\t_saleStart = fundingStart;\r\n\t\t_saleEnd = fundingDeadline;\r\n\t\t_usageEnd = usageDeadline;\r\n\t\t_vest = vestTime;\r\n\t\t_saleGoal = minIcoTokenGoal;\r\n\t\t_usageGoal = minUsageGoal;\r\n\t\t_sold = getNumTokensPurchased();\r\n\t\t_used = getNumGames();\r\n\t\t_funds = totalTokenFundsReceived;\r\n\t\t_credits = partnerCredits;\r\n\t\t_remuStage = remunerationStage;\r\n\t}\r\n\r\n\t// ----------------------------\r\n\t// NOTE! CALL AT THE RISK OF RUNNING OUT OF GAS.\r\n\t// ANYONE CAN CALL THIS FUNCTION BUT YOU HAVE TO SUPPLY \r\n\t// THE CORRECT AMOUNT OF GAS WHICH MAY DEPEND ON \r\n\t// THE _NUMPAYS PARAMETER.  WHICH MUST BE BETWEEN 1 AND 1000\r\n\t// THE STANDARD VALUE IS STORED IN \"maxPaysPer\"\r\n\t// ----------------------------\r\n\tfunction flushDividends(uint _numPays)\r\n\t{\r\n\t\tif ((_numPays == 0) || (_numPays > 1000)) {\r\n\t\t\tStatEvent(\"Invalid.\");\r\n\t\t} else if (holdoverBalance > 0 || payoutBalance > 0) {\r\n\t\t\tdoPayout(_numPays);\r\n\t\t} else {\r\n\t\t\tStatEvent(\"Nothing to do.\");\r\n\t\t}\r\n\t\t\t\t\r\n\t}\r\n\r\n\tfunction doDeveloperGrant() internal\r\n\t{\r\n\t\tif (!developersGranted) {\r\n\t\t\tdevelopersGranted = true;\r\n\t\t\tnumDevTokens = totalTokensMinted/10;\r\n\t\t\ttotalTokensMinted += numDevTokens;\r\n\t\t\tif (!holderAccounts[developers].alloced) \r\n\t\t\t\taddAccount(developers);\r\n\t\t\tuint newHeld = getHeld(holderAccounts[developers].tokens) + numDevTokens;\r\n\t\t\tholderAccounts[developers].tokens = newHeld |  (curPayoutId * (2 ** 48));\r\n\r\n\t\t}\r\n\t}\r\n\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"changeDevevoperAccont\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"supply\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remunerationBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkDividends\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPaysPer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateIcoStatus\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDividends\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"feePayment\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rm\",\"type\":\"uint256\"},{\"name\":\"_rf\",\"type\":\"uint256\"},{\"name\":\"_rw\",\"type\":\"uint256\"}],\"name\":\"setOpGas\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curPayoutId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numPays\",\"type\":\"uint256\"}],\"name\":\"flushDividends\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPayoutTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settingsState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumGames\",\"outputs\":[{\"name\":\"_games\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"icoCheckup\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensMinted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getIcoInfo\",\"outputs\":[{\"name\":\"_status\",\"type\":\"uint8\"},{\"name\":\"_saleStart\",\"type\":\"uint256\"},{\"name\":\"_saleEnd\",\"type\":\"uint256\"},{\"name\":\"_usageEnd\",\"type\":\"uint256\"},{\"name\":\"_saleGoal\",\"type\":\"uint256\"},{\"name\":\"_usageGoal\",\"type\":\"uint256\"},{\"name\":\"_sold\",\"type\":\"uint256\"},{\"name\":\"_used\",\"type\":\"uint256\"},{\"name\":\"_funds\",\"type\":\"uint256\"},{\"name\":\"_credits\",\"type\":\"uint256\"},{\"name\":\"_remuStage\",\"type\":\"uint256\"},{\"name\":\"_vest\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setE4RowPartner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"qState\",\"type\":\"uint8\"},{\"name\":\"_saleStart\",\"type\":\"uint256\"},{\"name\":\"_saleEnd\",\"type\":\"uint256\"},{\"name\":\"_usageEnd\",\"type\":\"uint256\"},{\"name\":\"_minUsage\",\"type\":\"uint256\"},{\"name\":\"_tokGoal\",\"type\":\"uint256\"},{\"name\":\"_maxMintable\",\"type\":\"uint256\"},{\"name\":\"_threshold\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_mpp\",\"type\":\"uint256\"},{\"name\":\"_mpi\",\"type\":\"uint256\"}],\"name\":\"applySettings\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"changeFounder\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOpGas\",\"outputs\":[{\"name\":\"_rm\",\"type\":\"uint256\"},{\"name\":\"_rf\",\"type\":\"uint256\"},{\"name\":\"_rw\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"holderExists\",\"outputs\":[{\"name\":\"_exist\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_aux\",\"type\":\"address\"}],\"name\":\"changeAuxPartner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSpecialAddresses\",\"outputs\":[{\"name\":\"_fndr\",\"type\":\"address\"},{\"name\":\"_aux\",\"type\":\"address\"},{\"name\":\"_dev\",\"type\":\"address\"},{\"name\":\"_e4\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"purchaseToken\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumTokensPurchased\",\"outputs\":[{\"name\":\"_purchased\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"haraKiri\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minPayInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"requestRefund\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"holdoverBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPayoutIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"StatEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"StatEventI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"E4Token","CompilerVersion":"v0.4.10+commit.f0d539ae","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4f2a84508476015d4feefc6ba421d36589ae2a9105fdffc2a1aeae19c2110557"}]}