{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.6;\r\n\r\n\r\ncontract iE4RowEscrow {\r\n        function getNumGamesStarted() constant returns (int ngames);\r\n}\r\n\r\n\r\ncontract E4RowEscrowU is iE4RowEscrow {\r\n\r\nevent StatEvent(string msg);\r\nevent StatEventI(string msg, uint val);\r\nevent StatEventA(string msg, address addr);\r\n\r\n        uint constant MAX_PLAYERS = 5;\r\n\r\n        enum EndReason  {erWinner, erTimeOut, erCheat}\r\n        enum SettingStateValue  {debug, release, lockedRelease}\r\n\r\n        struct gameInstance {\r\n                address[5] players;\r\n                uint[5] playerPots;\r\n                uint numPlayers;\r\n\r\n                bool active; // active\r\n                bool allocd; //  allocated already. \r\n                uint started; // time game started\r\n                uint lastMoved; // time game last moved\r\n                uint payout; // payout amont\r\n                address winner; // address of winner\r\n\r\n\r\n                EndReason reasonEnded; // enum reason of ended\r\n\r\n        }\r\n\r\n        struct arbiter {\r\n                mapping (uint => uint)  gameIndexes; // game handles\r\n\r\n                uint arbToken; // 2 bytes\r\n                uint gameSlots; // a counter of alloc'd game structs (they can be reused)\r\n                uint gamesStarted; // total games started\r\n                uint gamesCompleted;\r\n                uint gamesCheated;\r\n                uint gamesTimedout;\r\n                uint numPlayers;\r\n                bool registered; \r\n                bool locked;\r\n        }\r\n\r\n\r\n        address public  owner;  // owner is address that deployed contract\r\n        address public  tokenPartner;   // the address of partner that receives rake fees\r\n        uint public numArbiters;        // number of arbiters\r\n\r\n        int numGamesStarted;    // total stats from all arbiters\r\n\r\n        uint public numGamesCompleted; // ...\r\n        uint public numGamesCheated;    // ...\r\n        uint public numGamesTimedOut;   // ...\r\n\r\n        uint public houseFeeHoldover; // hold fee till threshold\r\n        uint public lastPayoutTime;     // timestamp of last payout time\r\n\r\n\r\n        // configurables\r\n        uint public gameTimeOut;\r\n        uint public registrationFee;\r\n        uint public houseFeeThreshold;\r\n        uint public payoutInterval;\r\n\r\n        uint raGas; // for register arb\r\n        uint sgGas;// for start game\r\n        uint wpGas; // for winner paid\r\n        uint rfGas; // for refund\r\n        uint feeGas; // for rake fee payout\r\n\r\n        SettingStateValue public settingsState = SettingStateValue.debug; \r\n\r\n\r\n        mapping (address => arbiter)  arbiters;\r\n        mapping (uint => address)  arbiterTokens;\r\n        mapping (uint => address)  arbiterIndexes;\r\n        mapping (uint => gameInstance)  games;\r\n\r\n\r\n        function E4RowEscrowU() public\r\n        {\r\n                owner = msg.sender;\r\n        }\r\n\r\n\r\n        function applySettings(SettingStateValue _state, uint _fee, uint _threshold, uint _timeout, uint _interval)\r\n        {\r\n                if (msg.sender != owner) \r\n                        throw;\r\n\r\n                // ----------------------------------------------\r\n                // these items are tweakable for game optimization\r\n                // ----------------------------------------------\r\n                houseFeeThreshold = _threshold;\r\n                gameTimeOut = _timeout;\r\n                payoutInterval = _interval;\r\n\r\n                if (settingsState == SettingStateValue.lockedRelease) {\r\n                        StatEvent(\"Settings Tweaked\");\r\n                        return;\r\n                }\r\n\r\n                settingsState = _state;\r\n                registrationFee = _fee;\r\n\r\n                // set default op gas -  any futher settings done in set up gas\r\n                raGas = 150000; \r\n                sgGas = 110000;\r\n                wpGas = 20000; \r\n                rfGas = 20000; \r\n                feeGas = 360000; \r\n\r\n                StatEvent(\"Settings Changed\");\r\n\r\n\r\n        }\r\n\r\n        //-----------------------------\r\n        // return an arbiter token from an hGame\r\n        //-----------------------------\r\n        function ArbTokFromHGame(uint _hGame) returns (uint _tok)\r\n        { \r\n                _tok =  (_hGame / (2 ** 48)) & 0xffff;\r\n        }\r\n\r\n\r\n        //-----------------------------\r\n        // suicide the contract, not called for release\r\n        //-----------------------------\r\n        function HaraKiri()\r\n        {\r\n                if ((msg.sender == owner) && (settingsState != SettingStateValue.lockedRelease))\r\n                          suicide(tokenPartner);\r\n                else\r\n                        StatEvent(\"Kill attempt failed\");\r\n        }\r\n\r\n\r\n\r\n\r\n        //-----------------------------\r\n        // default function\r\n        //-----------------------------\r\n        function() payable  {\r\n                throw;\r\n        }\r\n\r\n        //------------------------------------------------------\r\n        // check active game and valid player, return player index\r\n        //-------------------------------------------------------\r\n        function validPlayer(uint _hGame, address _addr)  internal returns( bool _valid, uint _pidx)\r\n        {\r\n                _valid = false;\r\n                if (activeGame(_hGame)) {\r\n                        for (uint i = 0; i < games[_hGame].numPlayers; i++) {\r\n                                if (games[_hGame].players[i] == _addr) {\r\n                                        _valid=true;\r\n                                        _pidx = i;\r\n                                        break;\r\n                                }\r\n                        }\r\n                }\r\n        }\r\n\r\n        //------------------------------------------------------\r\n        // check valid player, return player index\r\n        //-------------------------------------------------------\r\n        function validPlayer2(uint _hGame, address _addr) internal  returns( bool _valid, uint _pidx)\r\n        {\r\n                _valid = false;\r\n                for (uint i = 0; i < games[_hGame].numPlayers; i++) {\r\n                        if (games[_hGame].players[i] == _addr) {\r\n                                _valid=true;\r\n                                _pidx = i;\r\n                                break;\r\n                        }\r\n                }\r\n        }\r\n\r\n        //------------------------------------------------------\r\n        // check the arbiter is valid by comparing token\r\n        //------------------------------------------------------\r\n        function validArb(address _addr, uint _tok) internal  returns( bool _valid)\r\n        {\r\n                _valid = false;\r\n\r\n                if ((arbiters[_addr].registered)\r\n                        && (arbiters[_addr].arbToken == _tok)) \r\n                        _valid = true;\r\n        }\r\n\r\n        //------------------------------------------------------\r\n        // check the arbiter is valid without comparing token\r\n        //------------------------------------------------------\r\n        function validArb2(address _addr) internal  returns( bool _valid)\r\n        {\r\n                _valid = false;\r\n                if (arbiters[_addr].registered)\r\n                        _valid = true;\r\n        }\r\n\r\n        //------------------------------------------------------\r\n        // check if arbiter is locked out\r\n        //------------------------------------------------------\r\n        function arbLocked(address _addr) internal  returns( bool _locked)\r\n        {\r\n                _locked = false;\r\n                if (validArb2(_addr)) \r\n                        _locked = arbiters[_addr].locked;\r\n        }\r\n\r\n        //------------------------------------------------------\r\n        // return if game is active\r\n        //------------------------------------------------------\r\n        function activeGame(uint _hGame) internal  returns( bool _valid)\r\n        {\r\n                _valid = false;\r\n                if ((_hGame > 0)\r\n                        && (games[_hGame].active))\r\n                        _valid = true;\r\n        }\r\n\r\n\r\n        //------------------------------------------------------\r\n        // register game arbiter, max players of 5, pass in exact registration fee\r\n        //------------------------------------------------------\r\n        function registerArbiter(uint _numPlayers, uint _arbToken) public payable \r\n        {\r\n\r\n                if (msg.value != registrationFee) {\r\n                        throw;  //Insufficient Fee\r\n                }\r\n\r\n                if (_arbToken == 0) {\r\n                        throw; // invalid token\r\n                }\r\n\r\n                if (arbTokenExists(_arbToken & 0xffff)) {\r\n                        throw; // Token Already Exists\r\n                }\r\n\r\n                if (arbiters[msg.sender].registered) {\r\n                        throw; // Arb Already Registered\r\n                }\r\n\r\n                if (_numPlayers > MAX_PLAYERS) {\r\n                        throw; // Exceeds Max Players\r\n                }\r\n\r\n                arbiters[msg.sender].gamesStarted = 0;\r\n                arbiters[msg.sender].gamesCompleted = 0;\r\n                arbiters[msg.sender].gamesCheated = 0;\r\n                arbiters[msg.sender].gamesTimedout = 0;\r\n                arbiters[msg.sender].locked = false;\r\n                arbiters[msg.sender].arbToken = _arbToken & 0xffff;\r\n                arbiters[msg.sender].numPlayers = _numPlayers;\r\n                arbiters[msg.sender].registered = true;\r\n\r\n                arbiterTokens[(_arbToken & 0xffff)] = msg.sender;\r\n                arbiterIndexes[numArbiters++] = msg.sender;\r\n\r\n\r\n                if (!tokenPartner.call.gas(raGas).value(msg.value)()) {\r\n                        //Statvent(\"Send Error\"); // event never registers\r\n                        throw;\r\n                }\r\n                StatEventI(\"Arb Added\", _arbToken);\r\n        }\r\n\r\n\r\n        //------------------------------------------------------\r\n        // start game.  pass in valid hGame containing token in top two bytes\r\n        //------------------------------------------------------\r\n        function startGame(uint _hGame, int _hkMax, address[] _players) public \r\n        {\r\n                uint ntok = ArbTokFromHGame(_hGame);\r\n                if (!validArb(msg.sender, ntok )) {\r\n                        StatEvent(\"Invalid Arb\");\r\n                        return; \r\n                }\r\n\r\n\r\n                if (arbLocked(msg.sender)) {\r\n                        StatEvent(\"Arb Locked\");\r\n                        return; \r\n                }\r\n\r\n                arbiter xarb = arbiters[msg.sender];\r\n                if (_players.length != xarb.numPlayers) { \r\n                        StatEvent(\"Incorrect num players\");\r\n                        return; \r\n                }\r\n\r\n                if (_hkMax > 0)\r\n                        houseKeep(_hkMax, ntok); \r\n\r\n                if (!games[_hGame].allocd) {\r\n                        games[_hGame].allocd = true;\r\n                        xarb.gameIndexes[xarb.gameSlots++] = _hGame;\r\n                } \r\n                numGamesStarted++; // always inc this one\r\n                xarb.gamesStarted++;\r\n\r\n                games[_hGame].active = true;\r\n                games[_hGame].started = now; \r\n                games[_hGame].lastMoved = now; \r\n                games[_hGame].payout = 0; \r\n                games[_hGame].winner = address(0);\r\n\r\n                games[_hGame].numPlayers = _players.length; // we'll be the judge of how many unique players\r\n                for (uint i = 0; i< _players.length && i < MAX_PLAYERS; i++) {\r\n                    games[_hGame].players[i] = _players[i];\r\n                    games[_hGame].playerPots[i] = 0;\r\n                }\r\n\r\n\r\n                StatEventI(\"Game Added\", _hGame);\r\n\r\n\r\n        }\r\n\r\n        //------------------------------------------------------\r\n        // clean up game, set to inactive, refund any balances\r\n        // called by housekeep ONLY\r\n        //------------------------------------------------------\r\n        function abortGame(address _arb, uint  _hGame, EndReason _reason) private returns(bool _success)\r\n        {\r\n             gameInstance nGame = games[_hGame];\r\n             \r\n                // find game in game id, \r\n                if (nGame.active) {\r\n                        _success = true;\r\n                        for (uint i = 0; i < nGame.numPlayers; i++) {\r\n                                if (nGame.playerPots[i] > 0) {\r\n                                        address a = nGame.players[i];\r\n                                        uint nsend = nGame.playerPots[i];\r\n                                        nGame.playerPots[i] = 0;\r\n                                        if (!a.call.gas(rfGas).value(nsend)()) {\r\n                                                houseFeeHoldover += nsend; // cannot refund due to error, give to the house\r\n                                                StatEventA(\"Cannot Refund Address\", a);\r\n                                        }\r\n                                }\r\n                        }\r\n                        nGame.active = false;\r\n                        nGame.reasonEnded = _reason;\r\n                        if (_reason == EndReason.erCheat) {\r\n                                numGamesCheated++;\r\n                                arbiters[_arb].gamesCheated++;\r\n                                StatEvent(\"Game Aborted-Cheat\");\r\n                        } else if (_reason == EndReason.erTimeOut) {\r\n                                numGamesTimedOut++;\r\n                                arbiters[_arb].gamesTimedout++;\r\n                                StatEvent(\"Game Aborted-TimeOut\");\r\n                        } else \r\n                                StatEvent(\"Game Aborted!\");\r\n                }\r\n        }\r\n\r\n\r\n        //------------------------------------------------------\r\n        // called by arbiter when winner is decided\r\n        //------------------------------------------------------\r\n        function winnerDecided(uint _hGame, address _winner, uint _winnerBal) public\r\n        {\r\n\r\n                if (!validArb(msg.sender, ArbTokFromHGame(_hGame))) {\r\n                        StatEvent(\"Invalid Arb\");\r\n                        return; // no throw no change made\r\n                }\r\n\r\n                var (valid, pidx) = validPlayer(_hGame, _winner);\r\n                if (!valid) {\r\n                        StatEvent(\"Invalid Player\");\r\n                        return;\r\n                }\r\n\r\n                arbiter xarb = arbiters[msg.sender];\r\n                gameInstance xgame = games[_hGame];\r\n\r\n                uint totalPot = 0;\r\n\r\n                if (xgame.playerPots[pidx] != _winnerBal) {\r\n                    abortGame(msg.sender, _hGame, EndReason.erCheat);\r\n                    return;\r\n                }\r\n\r\n                for (uint i = 0; i < xgame.numPlayers; i++) {\r\n                        totalPot += xgame.playerPots[i];\r\n                }\r\n\r\n                uint nportion;\r\n                uint nremnant;\r\n                if (totalPot > 0) {\r\n                        nportion = totalPot/50; // 2 percent fixed\r\n                        nremnant = totalPot-nportion;\r\n                } else {\r\n                        nportion = 0;\r\n                        nremnant = 0;\r\n                }\r\n\r\n\r\n                xgame.lastMoved = now;\r\n                xgame.active = false;\r\n                xgame.reasonEnded = EndReason.erWinner;\r\n                xgame.winner = _winner;\r\n                xgame.payout = nremnant;\r\n\r\n                if (nportion > 0) {\r\n                        houseFeeHoldover += nportion;\r\n                        if ((houseFeeHoldover > houseFeeThreshold)\r\n                                && (now > (lastPayoutTime + payoutInterval))) {\r\n                                uint ntmpho = houseFeeHoldover;\r\n                                houseFeeHoldover = 0;\r\n                                lastPayoutTime = now; // reset regardless of succeed/fail\r\n                                if (!tokenPartner.call.gas(feeGas).value(ntmpho)()) {\r\n                                        houseFeeHoldover = ntmpho; // put it back\r\n                                        StatEvent(\"House-Fee Error1\");\r\n                                } \r\n                        }\r\n                }\r\n\r\n                for (i = 0; i < xgame.numPlayers; i++) {\r\n                        xgame.playerPots[i] = 0;\r\n                }\r\n\r\n                xarb.gamesCompleted++;\r\n                numGamesCompleted++;\r\n                if (nremnant > 0) {\r\n                        if (!_winner.call.gas(wpGas).value(uint(nremnant))()) {\r\n                                // StatEvent(\"Send Error\");\r\n                                throw; // if you cant pay the winner - very bad\r\n                        } else {\r\n                                StatEventI(\"Winner Paid\", _hGame);\r\n                        }\r\n                }\r\n        }\r\n\r\n        //------------------------------------------------------\r\n        // handle a bet made by a player, validate the player and game\r\n        // add to players balance\r\n        //------------------------------------------------------\r\n        function handleBet(uint _hGame) public payable \r\n        {\r\n                address narb = arbiterTokens[ArbTokFromHGame(_hGame)];\r\n                if (narb == address(0)) {\r\n                        StatEvent(\"Invalid hGame\");\r\n                        if (settingsState != SettingStateValue.debug)\r\n                                throw;\r\n                        else\r\n                                return;\r\n                }\r\n\r\n                var (valid, pidx) = validPlayer(_hGame, msg.sender);\r\n                if (!valid) {\r\n                        StatEvent(\"Invalid Player\");\r\n                        if (settingsState != SettingStateValue.debug)\r\n                                throw;\r\n                        else\r\n                                return;\r\n                }\r\n\r\n                games[_hGame].playerPots[pidx] += msg.value;\r\n                games[_hGame].lastMoved = now;\r\n\r\n                StatEventI(\"Bet Added\", _hGame);\r\n\r\n        }\r\n\r\n\r\n        //------------------------------------------------------\r\n        // return if arb token exists\r\n        //------------------------------------------------------\r\n        function arbTokenExists(uint _tok) constant returns (bool _exists)\r\n        {\r\n                _exists = false;\r\n                if ((_tok > 0)\r\n                        && (arbiterTokens[_tok] != address(0))\r\n                        && arbiters[arbiterTokens[_tok]].registered)\r\n                        _exists = true;\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n        //------------------------------------------------------\r\n        // called by ico token contract \r\n        //------------------------------------------------------\r\n        function getNumGamesStarted() constant returns (int _games) \r\n        {\r\n                _games = numGamesStarted;\r\n        }\r\n\r\n        //------------------------------------------------------\r\n        // return arbiter game stats\r\n        //------------------------------------------------------\r\n        function getArbInfo(uint _idx) constant  returns (address _addr, uint _started, uint _completed, uint _cheated, uint _timedOut) \r\n        {\r\n                if (_idx >= numArbiters) {\r\n                        StatEvent(\"Invalid Arb\");\r\n                        return;\r\n                }\r\n                _addr = arbiterIndexes[_idx];\r\n                if ((_addr == address(0))\r\n                        || (!arbiters[_addr].registered)) {\r\n                        StatEvent(\"Invalid Arb\");\r\n                        return;\r\n                }\r\n                arbiter xarb = arbiters[_addr];\r\n                _started = xarb.gamesStarted;\r\n                _completed = xarb.gamesCompleted;\r\n                _timedOut = xarb.gamesTimedout;\r\n                _cheated = xarb.gamesCheated;\r\n        }\r\n\r\n\r\n        //------------------------------------------------------\r\n        // scan for a game 10 minutes old\r\n        // if found abort the game, causing funds to be returned\r\n        //------------------------------------------------------\r\n        function houseKeep(int _max, uint _arbToken) public\r\n        {\r\n                uint gi;\r\n                address a;\r\n                int aborted = 0;\r\n\r\n                arbiter xarb = arbiters[msg.sender];// have to set it to something\r\n                \r\n         \r\n                if (msg.sender == owner) {\r\n                        for (uint ar = 0; (ar < numArbiters) && (aborted < _max) ; ar++) {\r\n                            a = arbiterIndexes[ar];\r\n                            xarb = arbiters[a];    \r\n\r\n                            for ( gi = 0; (gi < xarb.gameSlots) && (aborted < _max); gi++) {\r\n                                gameInstance ngame0 = games[xarb.gameIndexes[gi]];\r\n                                if ((ngame0.active)\r\n                                    && ((now - ngame0.lastMoved) > gameTimeOut)) {\r\n                                        abortGame(a, xarb.gameIndexes[gi], EndReason.erTimeOut);\r\n                                        ++aborted;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                } else {\r\n                        if (!validArb(msg.sender, _arbToken))\r\n                                StatEvent(\"Housekeep invalid arbiter\");\r\n                        else {\r\n                            a = msg.sender;\r\n                            xarb = arbiters[a];    \r\n                            for (gi = 0; (gi < xarb.gameSlots) && (aborted < _max); gi++) {\r\n                                gameInstance ngame1 = games[xarb.gameIndexes[gi]];\r\n                                if ((ngame1.active)\r\n                                    && ((now - ngame1.lastMoved) > gameTimeOut)) {\r\n                                        abortGame(a, xarb.gameIndexes[gi], EndReason.erTimeOut);\r\n                                        ++aborted;\r\n                                }\r\n                            }\r\n\r\n                        }\r\n                }\r\n        }\r\n\r\n\r\n        //------------------------------------------------------\r\n        // return game info\r\n        //------------------------------------------------------\r\n        function getGameInfo(uint _hGame)  constant  returns (EndReason _reason, uint _players, uint _payout, bool _active, address _winner )\r\n        {\r\n                gameInstance ngame = games[_hGame];\r\n                _active = ngame.active;\r\n                _players = ngame.numPlayers;\r\n                _winner = ngame.winner;\r\n                _payout = ngame.payout;\r\n                _reason = ngame.reasonEnded;\r\n\r\n        }\r\n\r\n        //------------------------------------------------------\r\n        // return arbToken and low bytes from an HGame\r\n        //------------------------------------------------------\r\n        function checkHGame(uint _hGame) constant returns(uint _arbTok, uint _lowWords)\r\n        {\r\n                _arbTok = ArbTokFromHGame(_hGame);\r\n                _lowWords = _hGame & 0xffffffffffff;\r\n\r\n        }\r\n\r\n        //------------------------------------------------------\r\n        // get operation gas amounts\r\n        //------------------------------------------------------\r\n        function getOpGas() constant returns (uint _ra, uint _sg, uint _wp, uint _rf, uint _fg) \r\n        {\r\n                _ra = raGas; // register arb\r\n                _sg = sgGas; // start game\r\n                _wp = wpGas; // winner paid\r\n                _rf = rfGas; // refund\r\n                _fg = feeGas; // rake fee gas\r\n        }\r\n\r\n\r\n        //------------------------------------------------------\r\n        // set operation gas amounts for forwading operations\r\n        //------------------------------------------------------\r\n        function setOpGas(uint _ra, uint _sg, uint _wp, uint _rf, uint _fg) \r\n        {\r\n                if (msg.sender != owner)\r\n                        throw;\r\n\r\n                raGas = _ra;\r\n                sgGas = _sg;\r\n                wpGas = _wp;\r\n                rfGas = _rf;\r\n                feeGas = _fg;\r\n        }\r\n\r\n        //------------------------------------------------------\r\n        // set a micheivous arbiter to locked\r\n        //------------------------------------------------------\r\n        function setArbiterLocked(address _addr, bool _lock)  public \r\n        {\r\n                if (owner != msg.sender)  {\r\n                        throw; \r\n                } else if (!validArb2(_addr)) {\r\n                        StatEvent(\"invalid arb\");\r\n                } else {\r\n                        arbiters[_addr].locked = _lock;\r\n                }\r\n\r\n        }\r\n\r\n        //------------------------------------------------------\r\n        // flush the house fees whenever commanded to.\r\n        // ignore the threshold and the last payout time\r\n        // but this time only reset lastpayouttime upon success\r\n        //------------------------------------------------------\r\n        function flushHouseFees()\r\n        {\r\n                if (msg.sender != owner) {\r\n                        StatEvent(\"only owner calls this function\");\r\n                } else if (houseFeeHoldover > 0) {\r\n                        uint ntmpho = houseFeeHoldover;\r\n                        houseFeeHoldover = 0;\r\n                        if (!tokenPartner.call.gas(feeGas).value(ntmpho)()) {\r\n                                houseFeeHoldover = ntmpho; // put it back\r\n                                StatEvent(\"House-Fee Error2\"); \r\n                        } else {\r\n                                lastPayoutTime = now;\r\n                                StatEvent(\"House-Fee Paid\");\r\n                        }\r\n                }\r\n\r\n        }\r\n\r\n\r\n        //------------------------------------------------------\r\n        // set the token partner\r\n        //------------------------------------------------------\r\n        function setTokenPartner(address _addr) public\r\n        {\r\n                if (msg.sender != owner) {\r\n                        throw;\r\n                } \r\n\r\n                if ((settingsState == SettingStateValue.lockedRelease) \r\n                        && (tokenPartner == address(0))) {\r\n                        tokenPartner = _addr;\r\n                        StatEvent(\"Token Partner Final!\");\r\n                } else if (settingsState != SettingStateValue.lockedRelease) {\r\n                        tokenPartner = _addr;\r\n                        StatEvent(\"Token Partner Assigned!\");\r\n                }\r\n\r\n        }\r\n\r\n        // ----------------------------\r\n        // swap executor\r\n        // ----------------------------\r\n        function changeOwner(address _addr) \r\n        {\r\n                if (msg.sender != owner\r\n                        || settingsState == SettingStateValue.lockedRelease)\r\n                         throw;\r\n\r\n                owner = _addr;\r\n        }\r\n\r\n\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_numPlayers\",\"type\":\"uint256\"},{\"name\":\"_arbToken\",\"type\":\"uint256\"}],\"name\":\"registerArbiter\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumGamesStarted\",\"outputs\":[{\"name\":\"_games\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_state\",\"type\":\"uint8\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_threshold\",\"type\":\"uint256\"},{\"name\":\"_timeout\",\"type\":\"uint256\"},{\"name\":\"_interval\",\"type\":\"uint256\"}],\"name\":\"applySettings\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registrationFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numArbiters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseFeeThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hGame\",\"type\":\"uint256\"}],\"name\":\"ArbTokFromHGame\",\"outputs\":[{\"name\":\"_tok\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hGame\",\"type\":\"uint256\"}],\"name\":\"getGameInfo\",\"outputs\":[{\"name\":\"_reason\",\"type\":\"uint8\"},{\"name\":\"_players\",\"type\":\"uint256\"},{\"name\":\"_payout\",\"type\":\"uint256\"},{\"name\":\"_active\",\"type\":\"bool\"},{\"name\":\"_winner\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hGame\",\"type\":\"uint256\"}],\"name\":\"handleBet\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameTimeOut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"getArbInfo\",\"outputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_started\",\"type\":\"uint256\"},{\"name\":\"_completed\",\"type\":\"uint256\"},{\"name\":\"_cheated\",\"type\":\"uint256\"},{\"name\":\"_timedOut\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPayoutTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settingsState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hGame\",\"type\":\"uint256\"},{\"name\":\"_winner\",\"type\":\"address\"},{\"name\":\"_winnerBal\",\"type\":\"uint256\"}],\"name\":\"winnerDecided\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setTokenPartner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numGamesTimedOut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_lock\",\"type\":\"bool\"}],\"name\":\"setArbiterLocked\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_max\",\"type\":\"int256\"},{\"name\":\"_arbToken\",\"type\":\"uint256\"}],\"name\":\"houseKeep\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOpGas\",\"outputs\":[{\"name\":\"_ra\",\"type\":\"uint256\"},{\"name\":\"_sg\",\"type\":\"uint256\"},{\"name\":\"_wp\",\"type\":\"uint256\"},{\"name\":\"_rf\",\"type\":\"uint256\"},{\"name\":\"_fg\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numGamesCheated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hGame\",\"type\":\"uint256\"}],\"name\":\"checkHGame\",\"outputs\":[{\"name\":\"_arbTok\",\"type\":\"uint256\"},{\"name\":\"_lowWords\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numGamesCompleted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hGame\",\"type\":\"uint256\"},{\"name\":\"_hkMax\",\"type\":\"int256\"},{\"name\":\"_players\",\"type\":\"address[]\"}],\"name\":\"startGame\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ra\",\"type\":\"uint256\"},{\"name\":\"_sg\",\"type\":\"uint256\"},{\"name\":\"_wp\",\"type\":\"uint256\"},{\"name\":\"_rf\",\"type\":\"uint256\"},{\"name\":\"_fg\",\"type\":\"uint256\"}],\"name\":\"setOpGas\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseFeeHoldover\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"flushHouseFees\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPartner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tok\",\"type\":\"uint256\"}],\"name\":\"arbTokenExists\",\"outputs\":[{\"name\":\"_exists\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"HaraKiri\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"StatEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"StatEventI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"StatEventA\",\"type\":\"event\"}]","ContractName":"E4RowEscrowU","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0e27c804ca1236762feefdc5eb6488ff76511c869956199bc92a1aa566ecebe0"}]}