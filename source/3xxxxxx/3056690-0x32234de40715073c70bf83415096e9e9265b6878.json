{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\nThis file is part of WeiFund.\r\n*/\r\n\r\n/*\r\nThe core campaign contract interface. Used across all WeiFund standard campaign\r\ncontracts.\r\n*/\r\n\r\npragma solidity ^0.4.4;\r\n\r\n\r\n/// @title Campaign contract interface for WeiFund standard campaigns\r\n/// @author Nick Dodson <nick.dodson@consensys.net>\r\ncontract Campaign {\r\n  /// @notice the creater and operator of the campaign\r\n  /// @return the Ethereum standard account address of the owner specified\r\n  function owner() public constant returns(address) {}\r\n\r\n  /// @notice the campaign interface version\r\n  /// @return the version metadata\r\n  function version() public constant returns(string) {}\r\n\r\n  /// @notice the campaign name\r\n  /// @return contractual metadata which specifies the campaign name as a string\r\n  function name() public constant returns(string) {}\r\n\r\n  /// @notice use to determine the contribution method abi/structure\r\n  /// @return will return a string that is the exact contributeMethodABI\r\n  function contributeMethodABI() public constant returns(string) {}\r\n\r\n  /// @notice use to determine the contribution method abi\r\n  /// @return will return a string that is the exact contributeMethodABI\r\n  function refundMethodABI() public constant returns(string) {}\r\n\r\n  /// @notice use to determine the contribution method abi\r\n  /// @return will return a string that is the exact contributeMethodABI\r\n  function payoutMethodABI() public constant returns(string) {}\r\n\r\n  /// @notice use to determine the beneficiary destination for the campaign\r\n  /// @return the beneficiary address that will receive the campaign payout\r\n  function beneficiary() public constant returns(address) {}\r\n\r\n  /// @notice the block number at which the campaign fails or succeeds\r\n  /// @return the uint block number at which time the campaign expires\r\n  function expiry() public constant returns(uint256 blockNumber) {}\r\n\r\n  /// @notice the goal the campaign must reach in order for it to succeed\r\n  /// @return the campaign funding goal specified in wei as a uint256\r\n  function fundingGoal() public constant returns(uint256 amount) {}\r\n\r\n  /// @notice the maximum funding amount for this campaign\r\n  /// @return the campaign funding cap specified in wei as a uint256\r\n  function fundingCap() public constant returns(uint256 amount) {}\r\n\r\n  /// @notice the goal the campaign must reach in order for it to succeed\r\n  /// @return the campaign funding goal specified in wei as a uint256\r\n  function amountRaised() public constant returns(uint256 amount) {}\r\n\r\n  /// @notice the block number that the campaign was created\r\n  /// @return the campaign start block specified as a block number, uint256\r\n  function created() public constant returns(uint256 timestamp) {}\r\n\r\n  /// @notice the current stage the campaign is in\r\n  /// @return the campaign stage the campaign is in with uint256\r\n  function stage() public constant returns(uint256);\r\n\r\n  /// @notice if it supports it, return the contribution by ID\r\n  /// @return returns the contribution tx sender, value and time sent\r\n  function contributions(uint256 _contributionID) public constant returns(address _sender, uint256 _value, uint256 _time) {}\r\n\r\n  // Campaign events\r\n  event ContributionMade (address _contributor);\r\n  event RefundPayoutClaimed(address _payoutDestination, uint256 _payoutAmount);\r\n  event BeneficiaryPayoutClaimed (address _payoutDestination);\r\n}\r\n\r\n/*\r\nThis file is part of WeiFund.\r\n*/\r\n\r\n/*\r\nThe enhancer interface for the CampaignEnhancer contract.\r\n*/\r\n\r\npragma solidity ^0.4.4;\r\n\r\n\r\n/// @title The campaign enhancer interface contract for build enhancer contracts.\r\n/// @author Nick Dodson <nick.dodson@consensys.net>\r\ncontract Enhancer {\r\n  /// @notice enables the setting of the campaign, if any\r\n  /// @dev allow the owner to set the campaign\r\n  function setCampaign(address _campaign) public {}\r\n\r\n  /// @notice notate contribution\r\n  /// @param _sender The address of the contribution sender\r\n  /// @param _value The value of the contribution\r\n  /// @param _blockNumber The block number of the contribution\r\n  /// @param _amounts The specified contribution product amounts, if any\r\n  /// @return Whether or not the campaign is an early success after this contribution\r\n  /// @dev enables the notation of contribution data, and triggering of early success, if need be\r\n  function notate(address _sender, uint256 _value, uint256 _blockNumber, uint256[] _amounts) public returns (bool earlySuccess) {}\r\n}\r\n\r\n/*\r\nThis file is part of WeiFund.\r\n*/\r\n\r\n/*\r\nA common Owned contract that contains properties for contract ownership.\r\n*/\r\n\r\npragma solidity ^0.4.4;\r\n\r\n\r\n/// @title A single owned campaign contract for instantiating ownership properties.\r\n/// @author Nick Dodson <nick.dodson@consensys.net>\r\ncontract Owned {\r\n  // only the owner can use this method\r\n  modifier onlyowner() {\r\n    if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n\r\n    _;\r\n  }\r\n\r\n  // the owner property\r\n  address public owner;\r\n}\r\n/*\r\nThis file is part of WeiFund.\r\n*/\r\n\r\n/*\r\nThis is the standard claim contract interface. This used accross all claim\r\ncontracts. Claim contracts are used for the pickup of digital assets, such as tokens.\r\nNote, a campaign enhancer could be a claim as well. This is our general\r\nclaim interface.\r\n*/\r\n\r\npragma solidity ^0.4.4;\r\n\r\n\r\n/// @title Claim contract interface.\r\n/// @author Nick Dodson <nick.dodson@consensys.net>\r\ncontract Claim {\r\n  /// @return returns the claim ABI solidity method for this claim\r\n  function claimMethodABI() constant public returns (string) {}\r\n\r\n  // the claim success event, used for whent he claim has successfully be used\r\n  event ClaimSuccess(address _sender);\r\n}\r\n/*\r\nThis file is part of WeiFund.\r\n*/\r\n\r\n/*\r\nThe balance claim is used for dispersing balances of refunds for standard\r\ncamaign contracts. Instead of the contract sending a balance directly to the\r\ncontributor, it will send the balance to a balancelciam contract.\r\n*/\r\n\r\npragma solidity ^0.4.4;\r\n\r\n\r\n/// @title The balance claim interface contract, used for defining balance claims.\r\n/// @author Nick Dodson <nick.dodson@consensys.net>\r\ncontract BalanceClaimInterface {\r\n  /// @dev used to claim balance of the balance claim\r\n  function claimBalance() public {}\r\n}\r\n\r\n\r\n/// @title The balance claim, used for sending balances owed to a claim contract.\r\n/// @author Nick Dodson <nick.dodson@consensys.net>\r\ncontract BalanceClaim is Owned, Claim, BalanceClaimInterface {\r\n  /// @notice receive funds\r\n  function () payable public {}\r\n\r\n  /// @dev the claim balance method, claim the balance then suicide the contract\r\n  function claimBalance() onlyowner public {\r\n    // self destruct and send all funds to the balance claim owner\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  /// @notice The BalanceClaim constructor method\r\n  /// @param _owner the address of the balance claim owner\r\n  function BalanceClaim(address _owner) {\r\n    // specify the balance claim owner\r\n    owner = _owner;\r\n  }\r\n\r\n  // the claim method ABI metadata for user interfaces, written in standard\r\n  // solidity ABI method format\r\n  string constant public claimMethodABI = \"claimBalance()\";\r\n}\r\n\r\n/*\r\nThis file is part of WeiFund.\r\n*/\r\n\r\n/*\r\nThe private service registry is used in WeiFund factory contracts to register\r\ngenerated service contracts, such as our WeiFund standard campaign and enhanced\r\nstandard campaign contracts. It is usually only inherited by other contracts.\r\n*/\r\n\r\npragma solidity ^0.4.4;\r\n\r\n\r\n/// @title Private Service Registry - used to register generated service contracts.\r\n/// @author Nick Dodson <nick.dodson@consensys.net>\r\ncontract PrivateServiceRegistryInterface {\r\n  /// @notice register the service '_service' with the private service registry\r\n  /// @param _service the service contract to be registered\r\n  /// @return the service ID 'serviceId'\r\n  function register(address _service) internal returns (uint256 serviceId) {}\r\n\r\n  /// @notice is the service in question '_service' a registered service with this registry\r\n  /// @param _service the service contract address\r\n  /// @return either yes (true) the service is registered or no (false) the service is not\r\n  function isService(address _service) public constant returns (bool) {}\r\n\r\n  /// @notice helps to get service address\r\n  /// @param _serviceId the service ID\r\n  /// @return returns the service address of service ID\r\n  function services(uint256 _serviceId) public constant returns (address _service) {}\r\n\r\n  /// @notice returns the id of a service address, if any\r\n  /// @param _service the service contract address\r\n  /// @return the service id of a service\r\n  function ids(address _service) public constant returns (uint256 serviceId) {}\r\n\r\n  event ServiceRegistered(address _sender, address _service);\r\n}\r\n\r\ncontract PrivateServiceRegistry is PrivateServiceRegistryInterface {\r\n\r\n  modifier isRegisteredService(address _service) {\r\n    // does the service exist in the registry, is the service address not empty\r\n    if (services.length > 0) {\r\n      if (services[ids[_service]] == _service && _service != address(0)) {\r\n        _;\r\n      }\r\n    }\r\n  }\r\n\r\n  modifier isNotRegisteredService(address _service) {\r\n    // if the service '_service' is not a registered service\r\n    if (!isService(_service)) {\r\n      _;\r\n    }\r\n  }\r\n\r\n  function register(address _service)\r\n    internal\r\n    isNotRegisteredService(_service)\r\n    returns (uint serviceId) {\r\n    // create service ID by increasing services length\r\n    serviceId = services.length++;\r\n\r\n    // set the new service ID to the '_service' address\r\n    services[serviceId] = _service;\r\n\r\n    // set the ids store to link to the 'serviceId' created\r\n    ids[_service] = serviceId;\r\n\r\n    // fire the 'ServiceRegistered' event\r\n    ServiceRegistered(msg.sender, _service);\r\n  }\r\n\r\n  function isService(address _service)\r\n    public\r\n    constant\r\n    isRegisteredService(_service)\r\n    returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  address[] public services;\r\n  mapping(address => uint256) public ids;\r\n}\r\n\r\n\r\n/*\r\nThis file is part of WeiFund.\r\n*/\r\n\r\n/*\r\nThis file is part of WeiFund.\r\n*/\r\n\r\n/*\r\nStandard enhanced campaign for WeiFund. A generic crowdsale mechanism for\r\nissuing and dispersing digital assets on Ethereum.\r\n*/\r\n\r\npragma solidity ^0.4.4;\r\n\r\n/*\r\nInterfaces\r\n*/\r\n\r\n/*\r\nSpecified Contracts\r\n*/\r\n\r\n\r\n/// @title Standard Campaign -- enables generic crowdsales that disperse digital assets\r\n/// @author Nick Dodson <nick.dodson@consensys.net>\r\ncontract StandardCampaign is Owned, Campaign {\r\n  // the three possible states\r\n  enum Stages {\r\n    CrowdfundOperational,\r\n    CrowdfundFailure,\r\n    CrowdfundSuccess\r\n  }\r\n\r\n  // the campaign state machine enforcement\r\n  modifier atStage(Stages _expectedStage) {\r\n    // if the current state does not equal the expected one, throw\r\n    if (stage() != uint256(_expectedStage)) {\r\n      throw;\r\n    } else {\r\n      // continue with state changing operations\r\n      _;\r\n    }\r\n  }\r\n\r\n  // if the contribution is valid, then carry on with state changing operations\r\n  // notate the contribution with the enhancer, if the notation method\r\n  // returns true, then trigger an early success (e.g. token cap reached)\r\n  modifier validContribution() {\r\n    // if the msg value is zero or amount raised plus the curent message value\r\n    // is greater than the funding cap, then throw error\r\n    if (msg.value == 0\r\n      || amountRaised + msg.value > fundingCap\r\n      || amountRaised + msg.value < amountRaised) {\r\n      throw;\r\n    } else {\r\n      // carry on with state changing operations\r\n      _;\r\n    }\r\n  }\r\n\r\n  // if the contribution is a valid refund claim, then carry on with state\r\n  // changing operations\r\n  modifier validRefundClaim(uint256 _contributionID) {\r\n    // get the contribution data for the refund\r\n    Contribution refundContribution = contributions[_contributionID];\r\n\r\n    // if the refund has already been claimed or the refund sender is not the\r\n    // current message sender, throw error\r\n    if(refundsClaimed[_contributionID] == true // the refund for this contribution is not claimed\r\n      || refundContribution.sender != msg.sender){ // the contribution sender is the msg.sender\r\n      throw;\r\n    } else {\r\n      // all is good, carry on with state changing operations\r\n      _;\r\n    }\r\n  }\r\n\r\n  // only the beneficiary can use the method with this modifier\r\n  modifier onlybeneficiary() {\r\n    if (msg.sender != beneficiary) {\r\n      throw;\r\n    } else {\r\n      _;\r\n    }\r\n  }\r\n\r\n  // allow for fallback function to be used to make contributions\r\n  function () public payable {\r\n    contributeMsgValue(defaultAmounts);\r\n  }\r\n\r\n  // the current campaign stage\r\n  function stage() public constant returns (uint256) {\r\n    // if current time is less than the expiry, the crowdfund is operational\r\n    if (block.number < expiry\r\n      && earlySuccess == false\r\n      && amountRaised < fundingCap) {\r\n      return uint256(Stages.CrowdfundOperational);\r\n\r\n    // if n >= e and aR < fG then the crowdfund is a failure\r\n    } else if(block.number >= expiry\r\n      && earlySuccess == false\r\n      && amountRaised < fundingGoal) {\r\n      return uint256(Stages.CrowdfundFailure);\r\n\r\n    // if n >= e and aR >= fG or aR >= fC or early success triggered\r\n    // then the crowdfund is a success (enhancers can trigger early success)\r\n    // early success is generally used for TokenCap enforcement\r\n    } else if((block.number >= expiry && amountRaised >= fundingGoal)\r\n      || earlySuccess == true\r\n      || amountRaised >= fundingCap) {\r\n      return uint256(Stages.CrowdfundSuccess);\r\n    }\r\n  }\r\n\r\n  // contribute message value if the contribution is valid and the campaign\r\n  // is in stage operational, allow for complex amounts to be transacted\r\n  function contributeMsgValue(uint256[] _amounts)\r\n    public // anyone can attempt to use this method\r\n    payable // the method is payable and can accept ether\r\n    atStage(Stages.CrowdfundOperational) // must be at stage operational, done before validContribution\r\n    validContribution() // contribution must be valid, stage check done first\r\n    returns (uint256 contributionID) {\r\n    // increase contributions array length by 1, set as contribution ID\r\n    contributionID = contributions.length++;\r\n\r\n    // store contribution data in the contributions array\r\n    contributions[contributionID] = Contribution({\r\n        sender: msg.sender,\r\n        value: msg.value,\r\n        created: block.number\r\n    });\r\n\r\n    // add the contribution ID to that senders address\r\n    contributionsBySender[msg.sender].push(contributionID);\r\n\r\n    // increase the amount raised by the message value\r\n    amountRaised += msg.value;\r\n\r\n    // fire the contribution made event\r\n    ContributionMade(msg.sender);\r\n\r\n    // notate the contribution with the campaign enhancer, if the notation\r\n    // method returns true, then trigger an early success\r\n    // the enahncer is treated as malicious here, and is thus wrapped in a\r\n    // conditional for saftey, note the enhancer may throw as well\r\n    if (enhancer.notate(msg.sender, msg.value, block.number, _amounts)) {\r\n      // set early success to true, note, it cannot be reversed once set to true\r\n      // also validContribution must be after atStage modifier\r\n      // so that early success is triggered after stage check, not before\r\n      // early success is used to trigger an early campaign success before the funding\r\n      // cap is reached. This is generally used for things like hitting the token cap\r\n      earlySuccess = true;\r\n    }\r\n  }\r\n\r\n  // payout the current balance to the beneficiary, if the crowdfund is in\r\n  // stage success\r\n  function payoutToBeneficiary() public onlybeneficiary() {\r\n    // additionally trigger early success, this will force the Success state\r\n    // forcing the success state keeps the contract state machine rigid\r\n    // and ensures other third-party contracts that look to this state\r\n    // that this contract is in state success\r\n    earlySuccess = true;\r\n\r\n    // send funds to the benerifiary\r\n    if (!beneficiary.send(this.balance)) {\r\n      throw;\r\n    } else {\r\n      // fire the BeneficiaryPayoutClaimed event\r\n      BeneficiaryPayoutClaimed(beneficiary);\r\n    }\r\n  }\r\n\r\n  // claim refund owed if you are a contributor and the campaign is in stage\r\n  // failure. Only valid claims will be fulfilled.\r\n  // will return the balance claim address where funds can be picked up by\r\n  // contributor. A BalanceClaim is used to further prevent re-entrancy.\r\n  function claimRefundOwed(uint256 _contributionID)\r\n    public\r\n    atStage(Stages.CrowdfundFailure) // in stage failure\r\n    validRefundClaim(_contributionID) // the claim is a valid refund claim\r\n    returns (address balanceClaim) { // return the balance claim address\r\n    // set claimed to true right away\r\n    refundsClaimed[_contributionID] = true;\r\n\r\n    // get the contribution data for that contribution ID\r\n    Contribution refundContribution = contributions[_contributionID];\r\n\r\n    // send funds to the newly created balance claim contract\r\n    balanceClaim = address(new BalanceClaim(refundContribution.sender));\r\n\r\n    // set refunds claim address\r\n    refundClaimAddress[_contributionID] = balanceClaim;\r\n\r\n    // send funds to the newly created balance claim contract\r\n    if (!balanceClaim.send(refundContribution.value)) {\r\n      throw;\r\n    }\r\n\r\n    // fire the refund payed out event\r\n    RefundPayoutClaimed(balanceClaim, refundContribution.value);\r\n  }\r\n\r\n  // the total number of valid contributions made to this campaign\r\n  function totalContributions() public constant returns (uint256 amount) {\r\n    return uint256(contributions.length);\r\n  }\r\n\r\n  // get the total number of contributions made a sender\r\n  function totalContributionsBySender(address _sender)\r\n    public\r\n    constant\r\n    returns (uint256 amount) {\r\n    return uint256(contributionsBySender[_sender].length);\r\n  }\r\n\r\n  // the contract constructor\r\n  function StandardCampaign(string _name,\r\n    uint256 _expiry,\r\n    uint256 _fundingGoal,\r\n    uint256 _fundingCap,\r\n    address _beneficiary,\r\n    address _owner,\r\n    address _enhancer) public {\r\n    // set the campaign name\r\n    name = _name;\r\n\r\n    // the campaign expiry in blocks\r\n    expiry = _expiry;\r\n\r\n    // the fundign goal in wei\r\n    fundingGoal = _fundingGoal;\r\n\r\n    // the campaign funding cap in wei\r\n    fundingCap = _fundingCap;\r\n\r\n    // the benerifiary address\r\n    beneficiary = _beneficiary;\r\n\r\n    // the owner or operator of the campaign\r\n    owner = _owner;\r\n\r\n    // the time the campaign was created\r\n    created = block.number;\r\n\r\n    // the campaign enhancer contract\r\n    enhancer = Enhancer(_enhancer);\r\n  }\r\n\r\n  // the Contribution data structure\r\n  struct Contribution {\r\n    // the contribution sender\r\n    address sender;\r\n\r\n    // the value of the contribution\r\n    uint256 value;\r\n\r\n    // the time the contribution was created\r\n    uint256 created;\r\n  }\r\n\r\n  // default amounts used\r\n  uint256[] defaultAmounts;\r\n\r\n  // campaign enhancer, usually for token notation\r\n  Enhancer public enhancer;\r\n\r\n  // the early success bool, used for triggering early success\r\n  bool public earlySuccess;\r\n\r\n  // the operator of the campaign\r\n  address public owner;\r\n\r\n  // the minimum amount of funds needed to be a success after expiry (in wei)\r\n  uint256 public fundingGoal;\r\n\r\n  // the maximum amount of funds that can be raised (in wei)\r\n  uint256 public fundingCap;\r\n\r\n  // the total amount raised by this campaign (in wei)\r\n  uint256 public amountRaised;\r\n\r\n  // the current campaign expiry (future block number)\r\n  uint256 public expiry;\r\n\r\n  // the time at which the campaign was created (in UNIX timestamp)\r\n  uint256 public created;\r\n\r\n  // the beneficiary of the funds raised, if the campaign is a success\r\n  address public beneficiary;\r\n\r\n  // the contributions data store, where all contributions are notated\r\n  Contribution[] public contributions;\r\n\r\n  // all contribution ID's of a specific sender\r\n  mapping(address => uint256[]) public contributionsBySender;\r\n\r\n  // the refund BalanceClaim address of a specific refund claim\r\n  // maps the (contribution ID => refund claim address)\r\n  mapping(uint256 => address) public refundClaimAddress;\r\n\r\n  // maps the contribution ID to a bool (has the refund been claimed for this\r\n  // contribution)\r\n  mapping(uint256 => bool) public refundsClaimed;\r\n\r\n  // the human readable name of the Campaign, for metadata\r\n  string public name;\r\n\r\n  // the contract version number, if any\r\n  string constant public version = \"0.1.0\";\r\n\r\n  // the contribution method ABI as a string, written in standard solidity\r\n  // ABI format, this is generally used so that UI's can understand the campaign\r\n  string constant public contributeMethodABI = \"contributeMsgValue(uint256[]):(uint256)\";\r\n\r\n  // the payout to beneficiary ABI, written in standard solidity ABI format\r\n  string constant public payoutMethodABI = \"payoutToBeneficiary()\";\r\n\r\n  // the refund method ABI, written in standard solidity ABI format\r\n  string constant public refundMethodABI = \"claimRefundOwed(uint256):(address)\";\r\n}\r\n\r\n/*\r\nThis file is part of WeiFund.\r\n*/\r\n\r\n/*\r\nAn empty campaign enhancer, used to fulfill an enhancer of a WeiFund enhanced\r\nstandard campaign.\r\n*/\r\n\r\npragma solidity ^0.4.4;\r\n\r\n\r\n/// @title Empty Enhancer - used to test enhanced standard campaign contracts\r\n/// @author Nick Dodson <nick.dodson@consensys.net>\r\ncontract EmptyEnhancer is Enhancer {\r\n  /// @dev notate contribution data, and trigger early success if need be\r\n  function notate(address _sender, uint256 _value, uint256 _blockNumber, uint256[] _amounts)\r\n  public\r\n  returns (bool earlySuccess) {\r\n    return false;\r\n  }\r\n}\r\n\r\n\r\n/*\r\nA factory contract used for the generation and registration of WeiFund enhanced\r\nstandard campaign contracts.\r\n*/\r\n\r\npragma solidity ^0.4.4;\r\n\r\n\r\n/// @title Enhanced Standard Campaign Factory - used to generate and register standard campaigns\r\n/// @author Nick Dodson <nick.dodson@consensys.net>\r\ncontract StandardCampaignFactory is PrivateServiceRegistry {\r\n  function createStandardCampaign(string _name,\r\n    uint256 _expiry,\r\n    uint256 _fundingGoal,\r\n    uint256 _fundingCap,\r\n    address _beneficiary,\r\n    address _enhancer) public returns (address campaignAddress) {\r\n    // create the new enhanced standard campaign\r\n    campaignAddress = address(new StandardCampaign(_name,\r\n      _expiry,\r\n      _fundingGoal,\r\n      _fundingCap,\r\n      _beneficiary,\r\n      msg.sender,\r\n      _enhancer));\r\n\r\n    // register the campaign address\r\n    register(campaignAddress);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ids\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_expiry\",\"type\":\"uint256\"},{\"name\":\"_fundingGoal\",\"type\":\"uint256\"},{\"name\":\"_fundingCap\",\"type\":\"uint256\"},{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_enhancer\",\"type\":\"address\"}],\"name\":\"createStandardCampaign\",\"outputs\":[{\"name\":\"campaignAddress\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"services\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_service\",\"type\":\"address\"}],\"name\":\"isService\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_service\",\"type\":\"address\"}],\"name\":\"ServiceRegistered\",\"type\":\"event\"}]","ContractName":"StandardCampaignFactory","CompilerVersion":"v0.4.4+commit.4633f3de","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}