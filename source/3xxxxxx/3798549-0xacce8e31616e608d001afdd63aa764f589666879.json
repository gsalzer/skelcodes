{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\ncontract FundariaToken {\r\n    uint public totalSupply;\r\n    uint public supplyLimit;\r\n    address public fundariaPoolAddress;\r\n    \r\n    function supplyTo(address, uint);\r\n    function tokenForWei(uint) returns(uint);\r\n    function weiForToken(uint) returns(uint);    \r\n         \r\n}\r\n\r\ncontract FundariaBonusFund {\r\n    function setOwnedBonus() payable {}    \r\n}\r\n\r\ncontract FundariaTokenBuy {\r\n        \r\n    address public fundariaBonusFundAddress;  // address of Fundaria 'bonus fund' contract\r\n    address public fundariaTokenAddress; // address of Fundaria token contract\r\n    \r\n    uint public bonusPeriod = 64 weeks; // bonus period from moment of this contract creating\r\n    uint constant bonusIntervalsCount = 9; // decreasing of bonus share with time\r\n    uint public startTimestampOfBonusPeriod; // when the bonus period starts\r\n    uint public finalTimestampOfBonusPeriod; // when the bonus period ends\r\n    \r\n    // for keeping of data to define bonus share at the moment of calling buy()    \r\n    struct bonusData {\r\n        uint timestamp;\r\n        uint shareKoef;\r\n    }\r\n    \r\n    // array to keep bonus related data\r\n    bonusData[9] bonusShedule;\r\n    \r\n    address creator; // creator address of this contract\r\n    // condition to be creator address to run some functions\r\n    modifier onlyCreator { \r\n        if(msg.sender == creator) _;\r\n    }\r\n    \r\n    function FundariaTokenBuy(address _fundariaTokenAddress) {\r\n        fundariaTokenAddress = _fundariaTokenAddress;\r\n        startTimestampOfBonusPeriod = now;\r\n        finalTimestampOfBonusPeriod = now+bonusPeriod;\r\n        for(uint8 i=0; i<bonusIntervalsCount; i++) {\r\n            // define timestamps of bonus period intervals\r\n            bonusShedule[i].timestamp = finalTimestampOfBonusPeriod-(bonusPeriod*(bonusIntervalsCount-i-1)/bonusIntervalsCount);\r\n            // koef for decreasing bonus share\r\n            bonusShedule[i].shareKoef = bonusIntervalsCount-i;\r\n        }\r\n        creator = msg.sender;\r\n    }\r\n    \r\n    function setFundariaBonusFundAddress(address _fundariaBonusFundAddress) onlyCreator {\r\n        fundariaBonusFundAddress = _fundariaBonusFundAddress;    \r\n    } \r\n    \r\n    // finish bonus if needed (if bonus system not efficient)\r\n    function finishBonusPeriod() onlyCreator {\r\n        finalTimestampOfBonusPeriod = now;    \r\n    }\r\n    \r\n    // if token bought successfuly\r\n    event TokenBought(address buyer, uint tokenToBuyer, uint weiForFundariaPool, uint weiForBonusFund, uint remnantWei);\r\n    \r\n    function buy() payable {\r\n        require(msg.value>0);\r\n        // use Fundaria token contract functions\r\n        FundariaToken ft = FundariaToken(fundariaTokenAddress);\r\n        // should be enough tokens before supply reached limit\r\n        require(ft.supplyLimit()-1>ft.totalSupply());\r\n        // tokens to buyer according to course\r\n        var tokenToBuyer = ft.tokenForWei(msg.value);\r\n        // should be enogh ether for at least 1 token\r\n        require(tokenToBuyer>=1);\r\n        // every second token goes to creator address\r\n        var tokenToCreator = tokenToBuyer;\r\n        uint weiForFundariaPool; // wei distributed to Fundaria pool\r\n        uint weiForBonusFund; // wei distributed to Fundaria bonus fund\r\n        uint returnedWei; // remnant\r\n        // if trying to buy more tokens then supply limit\r\n        if(ft.totalSupply()+tokenToBuyer+tokenToCreator > ft.supplyLimit()) {\r\n            // how many tokens are supposed to buy?\r\n            var supposedTokenToBuyer = tokenToBuyer;\r\n            // get all remaining tokens and devide them between reciepents\r\n            tokenToBuyer = (ft.supplyLimit()-ft.totalSupply())/2;\r\n            // every second token goes to creator address\r\n            tokenToCreator = tokenToBuyer; \r\n            // tokens over limit\r\n            var excessToken = supposedTokenToBuyer-tokenToBuyer;\r\n            // wei to return to buyer\r\n            returnedWei = ft.weiForToken(excessToken);\r\n        }\r\n        \r\n        // remaining wei for tokens\r\n        var remnantValue = msg.value-returnedWei;\r\n        // if bonus period is over\r\n        if(now>finalTimestampOfBonusPeriod) {\r\n            weiForFundariaPool = remnantValue;            \r\n        } else {\r\n            uint prevTimestamp;\r\n            for(uint8 i=0; i<bonusIntervalsCount; i++) {\r\n                // find interval to get needed bonus share\r\n                if(bonusShedule[i].timestamp>=now && now>prevTimestamp) {\r\n                    // wei to be distributed into the Fundaria bonus fund\r\n                    weiForBonusFund = remnantValue*bonusShedule[i].shareKoef/(bonusIntervalsCount+1);    \r\n                }\r\n                prevTimestamp = bonusShedule[i].timestamp;    \r\n            }\r\n            // wei for Fundaria pool\r\n            weiForFundariaPool = remnantValue-weiForBonusFund;           \r\n        }\r\n        // use Fundaria token contract function to distribute tokens to creator address\r\n        ft.supplyTo(creator, tokenToCreator);\r\n        // transfer wei for bought tokens to Fundaria pool\r\n        (ft.fundariaPoolAddress()).transfer(weiForFundariaPool);\r\n        // if we have wei for buyer to be saved in bonus fund\r\n        if(weiForBonusFund>0) {\r\n            FundariaBonusFund fbf = FundariaBonusFund(fundariaBonusFundAddress);\r\n            // distribute bonus wei to bonus fund\r\n            fbf.setOwnedBonus.value(weiForBonusFund)();\r\n        }\r\n        // if have remnant, return it to buyer\r\n        if(returnedWei>0) msg.sender.transfer(returnedWei);\r\n        // use Fundaria token contract function to distribute tokens to buyer\r\n        ft.supplyTo(msg.sender, tokenToBuyer);\r\n        // inform about 'token bought' event\r\n        TokenBought(msg.sender, tokenToBuyer, weiForFundariaPool, weiForBonusFund, returnedWei);\r\n    }\r\n    \r\n    // Prevents accidental sending of ether\r\n    function () {\r\n\t    throw; \r\n    }      \r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"fundariaTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalTimestampOfBonusPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fundariaBonusFundAddress\",\"type\":\"address\"}],\"name\":\"setFundariaBonusFundAddress\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTimestampOfBonusPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishBonusPeriod\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundariaBonusFundAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_fundariaTokenAddress\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenToBuyer\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weiForFundariaPool\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weiForBonusFund\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"remnantWei\",\"type\":\"uint256\"}],\"name\":\"TokenBought\",\"type\":\"event\"}]","ContractName":"FundariaTokenBuy","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000cfae4866c11cf6194d787cf76d479e28a7cc577","Library":"","SwarmSource":"bzzr://a478589130b414114258ded58437f5d28d45ff10c421bfafb68bc3288b73c640"}]}