{"status":"1","message":"OK","result":[{"SourceCode":"/******************************************************************************\\\r\n\r\nfile:   RegBase.sol\r\nver:    0.2.1\r\nupdated:9-May-2017\r\nauthor: Darryl Morris (o0ragman0o)\r\nemail:  o0ragman0o AT gmail.com\r\n\r\nThis file is part of the SandalStraps framework\r\n\r\n`RegBase` provides an inheriting contract the minimal API to be compliant with \r\n`Registrar`.  It includes a set-once, `bytes32 public regName` which is refered\r\nto by `Registrar` lookups.\r\n\r\nAn owner updatable `address public owner` state variable is also provided and is\r\nrequired by `Factory.createNew()`.\r\n\r\nThis software is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  \r\nSee MIT Licence for further details.\r\n<https://opensource.org/licenses/MIT>.\r\n\r\n\\******************************************************************************/\r\n\r\npragma solidity ^0.4.10;\r\n\r\ncontract RegBase\r\n{\r\n//\r\n// Constants\r\n//\r\n\r\n    bytes32 constant public VERSION = \"RegBase v0.2.1\";\r\n\r\n//\r\n// State Variables\r\n//\r\n    \r\n    /// @dev A static identifier, set in the constructor and used for registrar\r\n    /// lookup\r\n    /// @return Registrar name SandalStraps registrars\r\n    bytes32 public regName;\r\n\r\n    /// @dev An general purpose resource such as short text or a key to a\r\n    /// string in a StringsMap\r\n    /// @return resource\r\n    bytes32 public resource;\r\n    \r\n    /// @dev An address permissioned to enact owner restricted functions\r\n    /// @return owner\r\n    address public owner;\r\n\r\n//\r\n// Events\r\n//\r\n\r\n    // Triggered on change of owner address\r\n    event ChangedOwner(address indexed oldOwner, address indexed newOwner);\r\n\r\n    // Triggered on change of resource\r\n    event ChangedResource(bytes32 indexed resource);\r\n\r\n//\r\n// Modifiers\r\n//\r\n\r\n    // Permits only the owner\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n//\r\n// Functions\r\n//\r\n\r\n    /// @param _creator The calling address passed through by a factory,\r\n    /// typically msg.sender\r\n    /// @param _regName A static name referenced by a Registrar\r\n    /// @param _owner optional owner address if creator is not the intended\r\n    /// owner\r\n    /// @dev On 0x0 value for owner, ownership precedence is:\r\n    /// `_owner` else `_creator` else msg.sender\r\n    function RegBase(address _creator, bytes32 _regName, address _owner)\r\n    {\r\n        regName = _regName;\r\n        owner = _owner != 0x0 ? _owner : \r\n                _creator != 0x0 ? _creator : msg.sender;\r\n    }\r\n    \r\n    /// @notice Will selfdestruct the contract\r\n    function destroy()\r\n        public\r\n        onlyOwner\r\n    {\r\n        selfdestruct(msg.sender);\r\n    }\r\n    \r\n    /// @notice Change the owner to `_owner`\r\n    /// @param _owner The address to which ownership is transfered\r\n    function changeOwner(address _owner)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        ChangedOwner(owner, _owner);\r\n        owner = _owner;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Change the resource to `_resource`\r\n    /// @param _resource A key or short text to be stored as the resource.\r\n    function changeResource(bytes32 _resource)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        resource = _resource;\r\n        ChangedResource(_resource);\r\n        return true;\r\n    }\r\n}\r\n\r\n/******************************************************************************\\\r\n\r\nfile:   Factory.sol\r\nver:    0.2.1\r\nupdated:9-May-2017\r\nauthor: Darryl Morris (o0ragman0o)\r\nemail:  o0ragman0o AT gmail.com\r\n\r\nThis file is part of the SandalStraps framework\r\n\r\nFactories are a core but independant concept of the SandalStraps framework and \r\ncan be used to create SandalStraps compliant 'product' contracts from embed\r\nbytecode.\r\n\r\nThe abstract Factory contract is to be used as a SandalStraps compliant base for\r\nproduct specific factories which must impliment the createNew() function.\r\n\r\nis itself compliant with `Registrar` by inhereting `RegBase` and\r\ncompiant with `Factory` through the `createNew(bytes32 _name, address _owner)`\r\nAPI.\r\n\r\nAn optional creation fee can be set and manually collected by the owner.\r\n\r\nThis software is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  \r\nSee MIT Licence for further details.\r\n<https://opensource.org/licenses/MIT>.\r\n\r\n\\******************************************************************************/\r\n\r\npragma solidity ^0.4.10;\r\n\r\n// import \"https://github.com/o0ragman0o/SandalStraps/contracts/RegBase.sol\";\r\n\r\ncontract Factory is RegBase\r\n{\r\n//\r\n// Constants\r\n//\r\n\r\n    // Deriving factories should have `bytes32 constant public regName` being\r\n    // the product's contract name, e.g for products \"Foo\":\r\n    // bytes32 constant public regName = \"Foo\";\r\n\r\n    // Deriving factories should have `bytes32 constant public VERSION` being\r\n    // the product's contract name appended with 'Factory` and the version\r\n    // of the product, e.g for products \"Foo\":\r\n    // bytes32 constant public VERSION \"FooFactory 0.0.1\";\r\n\r\n//\r\n// State Variables\r\n//\r\n\r\n    /// @return The payment in wei required to create the product contract.\r\n    uint public value;\r\n\r\n//\r\n// Events\r\n//\r\n\r\n    // Is triggered when a product is created\r\n    event Created(address _creator, bytes32 _regName, address _address);\r\n\r\n//\r\n// Modifiers\r\n//\r\n\r\n    // To check that the correct fee has bene paid\r\n    modifier feePaid() {\r\n    \trequire(msg.value == value || msg.sender == owner);\r\n    \t_;\r\n    }\r\n\r\n//\r\n// Functions\r\n//\r\n\r\n    /// @param _creator The calling address passed through by a factory,\r\n    /// typically msg.sender\r\n    /// @param _regName A static name referenced by a Registrar\r\n    /// @param _owner optional owner address if creator is not the intended\r\n    /// owner\r\n    /// @dev On 0x0 value for _owner or _creator, ownership precedence is:\r\n    /// `_owner` else `_creator` else msg.sender\r\n    function Factory(address _creator, bytes32 _regName, address _owner)\r\n        RegBase(_creator, _regName, _owner)\r\n    {\r\n        // nothing left to construct\r\n    }\r\n    \r\n    /// @notice Set the product creation fee\r\n    /// @param _fee The desired fee in wei\r\n    function set(uint _fee) \r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        value = _fee;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Send contract balance to `owner`\r\n    function withdraw()\r\n        public\r\n        returns (bool)\r\n    {\r\n        owner.transfer(this.balance);\r\n        return true;\r\n    }\r\n    \r\n    /// @notice Create a new product contract\r\n    /// @param _regName A unique name if the the product is to be registered in\r\n    /// a SandalStraps registrar\r\n    /// @param _owner An address of a third party owner.  Will default to\r\n    /// msg.sender if 0x0\r\n    /// @return kAddr_ The address of the new product contract\r\n    function createNew(bytes32 _regName, address _owner) \r\n        payable returns(address kAddr_);\r\n}\r\n\r\n/* Example implimentation of `createNew()` for a deriving factory\r\n\r\n    function createNew(bytes32 _regName, address _owner)\r\n        payable\r\n        feePaid\r\n        returns (address kAddr_)\r\n    {\r\n        require(_regName != 0x0);\r\n        address kAddr_ = address(new Foo(msg.sender, _regName, _owner));\r\n        Created(msg.sender, _regName, kAddr);\r\n    }\r\n\r\nExample product contract with `Factory` compiant constructor and `Registrar`\r\ncompliant `regName`.\r\n\r\nThe owner will be the caller by default if the `_owner` value is `0x0`.\r\n\r\nIf the contract requires initialization that would normally be done in a\r\nconstructor, then a `init()` function can be used instead post deployment.\r\n\r\n    contract Foo is RegBase\r\n    {\r\n        bytes32 constant public VERSION = \"Foo v0.0.1\";\r\n        uint val;\r\n        uint8 public __initFuse = 1;\r\n        \r\n        function Foo(address _creator, bytes32 _regName, address _owner)\r\n            RegBase(_creator, _regName, _owner)\r\n        {\r\n            // put non-parametric constructor code here.\r\n        }\r\n        \r\n        function _init(uint _val)\r\n        {\r\n            require(__initFuse == 1);\r\n\r\n            // put parametric constructor code here and call _init() post \r\n            // deployment\r\n            val = _val;\r\n            delete __initFuse;\r\n        }\r\n    }\r\n\r\n*/\r\n\r\n/*\r\nfile:   Bakt.sol\r\nver:    0.3.4-beta\r\nupdated:16-May-2017\r\nauthor: Darryl Morris\r\nemail:  o0ragman0o AT gmail.com\r\n\r\nCopyright is retained by the author.  Copying or running this software is only\r\nby express permission.\r\n\r\nThis software is provided WITHOUT ANY WARRANTY; without even the implied\r\nwarranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. The author\r\ncannot be held liable for damage or loss.\r\n\r\nDesign Notes:\r\n\r\nThis contract DOES NOT offer trust to its holders. Holders instead elect a\r\nTrustee from among the holders and the Trustee is responsible for funds.\r\n\r\nThe Trustee has unilateral powers to:\r\n    - remove funds\r\n    - use the contract to execute code on another contract\r\n    - pay dividends\r\n    - add holders\r\n    - issue a token offer to a holder\r\n    - selfdestruct the contract, on condition of 0 supply and 0 ether balance\r\n    - veto a transaction\r\n\r\nHolders have the power to:\r\n    - vote for a preferred Trustee\r\n    - veto a transaction if owned or owns > 10% of tokens\r\n    - purchase tokens offer with ether.\r\n    - redeem tokens for ether at the token price or a price proportional to\r\n      the fund.\r\n    - withdraw their balance of ether.\r\n    - Cause a panic state in the contract if holds > 10% of tokens\r\n\r\nThis contract uses integer tokens so ERC20 `decimalPlaces` is 0.\r\n\r\nMaximum number of holders is limited to 254 to prevent potential OOG loops\r\nduring elections.\r\nPerpetual election of the `Trustee` runs in O(254) time to discover a winner.\r\n\r\nRelease Notes v0.3.4-beta:\r\n-fixed magnitude bug introduced when using scientific notation (10**18 != 10e18)\r\n-using 10**18 notation rather than 1e18 as already using 2**256 notation\r\n-Intend to deploy factory to Ropsten, Rinkeby and Live \r\n\r\nRopsten: 0.3.4-beta-test1 @ 0xc446575f7ed13f7b4b849f70ffa9f209a64db742\r\n\r\n*/\r\n\r\n// import \"https://github.com/o0ragman0o/SandalStraps/contracts/Factory.sol\";\r\n\r\npragma solidity ^0.4.10;\r\n\r\n\r\ncontract BaktInterface\r\n{\r\n\r\n/* Structs */\r\n\r\n    struct Holder {\r\n        uint8 id;\r\n        address votingFor;\r\n        uint40 offerExpiry;\r\n        uint lastClaimed;\r\n        uint tokenBalance;\r\n        uint etherBalance;\r\n        uint votes;\r\n        uint offerAmount;\r\n        mapping (address => uint) allowances;\r\n    }\r\n\r\n    struct TX {\r\n        bool blocked;\r\n        uint40 timeLock;\r\n        address from;\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n\r\n/* Constants */\r\n\r\n    // Constant max tokens and max ether to prevent potential multiplication\r\n    // overflows in 10e17 fixed point     \r\n    uint constant MAXTOKENS = 2**128 - 10**18;\r\n    uint constant MAXETHER = 2**128;\r\n    uint constant BLOCKPCNT = 10; // 10% holding required to block TX's\r\n    uint constant TOKENPRICE = 1000000000000000;\r\n    uint8 public constant decimalPlaces = 15;\r\n\r\n/* State Valiables */\r\n\r\n    // A mutex used for reentry protection\r\n    bool __reMutex;\r\n\r\n    // Initialisation fuse. Blows on initialisation and used for entry check;\r\n    bool __initFuse = true;\r\n\r\n    // Allows the contract to accept or deny payments\r\n    bool public acceptingPayments;\r\n\r\n    // The period for which a panic will prevent functionality to the contract\r\n    uint40 public PANICPERIOD;\r\n\r\n    // The period for which a pending transaction must wait before being sent \r\n    uint40 public TXDELAY;\r\n\r\n    /// @return The Panic flag state. false == calm, true == panicked\r\n    bool public panicked;\r\n\r\n    /// @return The pending transaction queue head pointer\r\n    uint8 public ptxHead;\r\n\r\n    /// @return The pending transaction queue tail pointer\r\n    uint8 public ptxTail;\r\n\r\n    /// @return The `PANIC` timelock expiry date/time\r\n    uint40 public timeToCalm;\r\n\r\n    /// @return The Address of the current elected trustee\r\n    address public trustee;\r\n\r\n    /// @return Total count of tokens\r\n    uint public totalSupply;\r\n\r\n    /// @return The combined balance of ether committed to holder accounts, \r\n    /// unclaimed dividends and values in pending transactions.\r\n    uint public committedEther;\r\n\r\n    /// @dev The running tally of dividends points accured by \r\n    /// dividend/totalSupply at each dividend payment\r\n    uint dividendPoints;\r\n\r\n    /// @return The historic tally of paid dividends\r\n    uint public totalDividends;\r\n\r\n    /// @return A static identifier, set in the constructor and used by\r\n    /// registrars\r\n    bytes32 public regName;\r\n\r\n    /// @return An informational resource. Can be a sha3 of a string to lookup\r\n    /// in a StringsMap\r\n    bytes32 public resource;\r\n\r\n    /// @param address The address of a holder.\r\n    /// @return Holder data cast from struct Holder to an array\r\n    mapping (address => Holder) public holders;\r\n\r\n    /// @param uint8 The index of a holder\r\n    /// @return An address of a holder\r\n    address[256] public holderIndex;\r\n\r\n    /// @param uint8 The index of a pending transaction\r\n    /// @return Transaction details cast from struct TX to array\r\n    TX[256] public pendingTxs;\r\n\r\n/* Events */\r\n\r\n    // Triggered when the contract recieves a payment\r\n    event Deposit(uint value);\r\n\r\n    // Triggered when ether is sent from the contract\r\n    event Withdrawal(address indexed sender, address indexed recipient,\r\n        uint value);\r\n\r\n    // Triggered when a transaction is ordered\r\n    event TransactionPending(uint indexed pTX, address indexed sender, \r\n        address indexed recipient, uint value, uint timeLock);\r\n\r\n    // Triggered when a pending transaction is blocked\r\n    event TransactionBlocked(address indexed by, uint indexed pTX);\r\n\r\n    // Triggered when a transaction fails either by being blocked or failure of \r\n    // reciept\r\n    event TransactionFailed(address indexed sender, address indexed recipient,\r\n        uint value);\r\n\r\n    // Triggered when the trustee pays dividends\r\n    event DividendPaid(uint value);\r\n\r\n    // ERC20 transfer notification\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    // ERC20 approval notification\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n    // Triggered on change of trustee\r\n    event Trustee(address indexed trustee);\r\n\r\n    // Trigger when a new holder is added\r\n    event NewHolder(address indexed holder);\r\n\r\n    // Triggered when a holder vacates\r\n    event HolderVacated(address indexed holder);\r\n\r\n    // Triggered when a offer of tokens is created\r\n    event IssueOffer(address indexed holder);\r\n\r\n    // Triggered on token creation when an offer is accepted\r\n    event TokensCreated(address indexed holder, uint amount);\r\n\r\n    // Triggered when tokens are destroyed during a redeeming round\r\n    event TokensDestroyed(address indexed holder, uint amount);\r\n\r\n    // Triggered when a hold causes a panic\r\n    event Panicked(address indexed by);\r\n\r\n    // Triggered when a holder calms a panic\r\n    event Calm();\r\n\r\n//\r\n// Bakt Functions\r\n//\r\n\r\n    /// @dev Accept payment to the default function\r\n    function() payable;\r\n\r\n    /// @notice This will set the panic and pending periods.\r\n    /// This action is a one off and is irrevocable! \r\n    /// @param _panicDelayInSeconds The panic delay period in seconds\r\n    /// @param _pendingDelayInSeconds The pending period in seconds\r\n    function _init(uint40 _panicDelayInSeconds, uint40 _pendingDelayInSeconds)\r\n        returns (bool);\r\n\r\n    /// @return The balance of uncommitted ether funds.\r\n    function fundBalance() constant returns (uint);\r\n    \r\n    /// @return The constant TOKENPRICE.\r\n    function tokenPrice() constant returns (uint);\r\n\r\n//\r\n// ERC20 API functions\r\n//\r\n\r\n    /// @param _addr The address of a holder\r\n    /// @return The ERC20 token balance of the holder\r\n    function balanceOf(address _addr) constant returns (uint);\r\n\r\n    /// @notice Transfer `_amount` of tokens to `_to`\r\n    /// @param _to the recipient holder's address\r\n    /// @param _amount the number of tokens to transfer\r\n    /// @return success state\r\n    /// @dev `_to` must be an existing holder\r\n    function transfer(address _to, uint _amount) returns (bool);\r\n\r\n    /// @notice Transfer `_amount` of tokens from `_from` to `_to`\r\n    /// @param _from The holder address from which to take tokens\r\n    /// @param _to the recipient holder's address\r\n    /// @param _amount the number of tokens to transfer\r\n    /// @return success state\r\n    /// @dev `_from` and `_to` must be existing holders\r\n    function transferFrom(address _from, address _to, uint256 _amount)\r\n        returns (bool);\r\n\r\n    /// @notice Approve `_spender` to transfer `_amount` of tokens\r\n    /// @param _spender the approved spender address. Does not have to be an\r\n    /// existing holder.\r\n    /// @param _amount the number of tokens to transfer\r\n    function approve(address _spender, uint256 _amount) returns (bool);\r\n\r\n    /// @param _owner The adddress of the holder owning tokens\r\n    /// @param _spender The address of the account allowed to transfer tokens\r\n    /// @return Amount of remaining token that the _spender can transfer\r\n    function allowance(address _owner, address _spender)\r\n        constant returns (uint256);\r\n\r\n//\r\n// Security Functions\r\n//\r\n\r\n    /// @notice Cause the contract to Panic. This will block most state changing\r\n    /// functions for a set delay.\r\n    /// Exceptions are `vote()`, `blockPendingTx(uint _txIdx)` and `PANIC()`.\r\n    function PANIC() returns (bool);\r\n\r\n    /// @notice Release the contract from a Panic after the panic period has\r\n    /// expired.\r\n    function calm() returns (bool);\r\n\r\n    /// @notice Execute the first TX in the pendingTxs queue. Values will\r\n    /// revert if the transaction is blocked or fails.\r\n    function sendPending() returns (bool);\r\n\r\n    /// @notice Block a pending transaction with id `_txIdx`. Pending\r\n    /// transactions can be blocked by any holder at any time but must\r\n    /// still be cleared from the pending transactions queue once the timelock\r\n    /// is cleared.\r\n    /// @param _txIdx Index of the transaction in the pending transactions\r\n    /// table\r\n    function blockPendingTx(uint _txIdx) returns (bool);\r\n\r\n//\r\n// Trustee functions\r\n//\r\n\r\n    /// @notice Send a transaction to `_to` containing `_value` with RLP encoded\r\n    ///     arguments of `_data`\r\n    /// @param _to The recipient address\r\n    /// @param _value value of ether to send\r\n    /// @param _data RLP encoded data to send with the transaction\r\n    /// @dev Allows the trustee to initiate a transaction as the Bakt. It must\r\n    /// be followed by sendPending() after the timeLock expires.\r\n    function execute(address _to, uint _value, bytes _data) returns (uint8);\r\n\r\n    /// @notice Pay dividends of `_value`\r\n    /// @param _value a value of ether upto the fund balance\r\n    /// @dev Allows the trustee to commit a portion of `fundBalance` to dividends.\r\n    function payDividends(uint _value) returns (bool);\r\n\r\n//\r\n// Holder Functions\r\n//\r\n\r\n    /// @return Returns the array of holder addresses.\r\n    function getHolders() constant returns(address[256]);\r\n\r\n    /// @param _addr The address of a holder\r\n    /// @return Returns the holder's withdrawable balance of ether\r\n    function etherBalanceOf(address _addr) constant returns (uint);\r\n\r\n    /// @notice Initiate a withdrawal of the holder's `etherBalance`\r\n    /// Follow up with sendPending() once the timelock has expired\r\n    function withdraw() returns(uint8);\r\n\r\n    /// @notice Vacate holder `_addr`\r\n    /// @param _addr The address of a holder with empty balances.\r\n    function vacate(address _addr) returns (bool);\r\n\r\n//\r\n// Token Creation/Destruction Functions\r\n//\r\n\r\n    /// @notice Create tokens to the value of `msg.value` +\r\n    /// `holder.etherBalance`\r\n    /// @return success state\r\n    /// @dev The amount of tokens created is:\r\n    ///     tokens = floor((`etherBalance` + `msg.value`)/`tokenPrice`)\r\n    ///     Any remainder of ether is credited to the holder's `etherBalance`\r\n    function purchase() payable returns (bool);\r\n\r\n    /// @notice Redeem `_amount` tokens back to the contract\r\n    /// @param _amount The amount of tokens to redeem\r\n    /// @dev ether = `_amount` * `fundBalance()` / `totalSupply`\r\n    /// @return success state\r\n    function redeem(uint _amount) returns (bool);\r\n\r\n//\r\n// Ballot functions\r\n//\r\n\r\n    /// @notice Vote for `_candidate` as preferred Trustee.\r\n    /// @param _candidate The address of the preferred holder\r\n    /// @return success state\r\n    function vote(address _candidate) returns (bool);\r\n}\r\n\r\ncontract Bakt is BaktInterface\r\n{\r\n    bytes32 constant public VERSION = \"Bakt 0.3.4-beta\";\r\n\r\n//\r\n// Bakt Functions\r\n//\r\n\r\n    // SandalStraps compliant constructor\r\n    function Bakt(address _creator, bytes32 _regName, address _trustee)\r\n    {\r\n        regName = _regName;\r\n        trustee = _trustee != 0x0 ? _trustee : \r\n                _creator != 0x0 ? _creator : msg.sender;\r\n        join(trustee);\r\n    }\r\n\r\n    // Accept payment to the default function on the condition that\r\n    // `acceptingPayments` is true\r\n    function()\r\n        payable\r\n    {\r\n        require(msg.value > 0 &&\r\n            msg.value + this.balance < MAXETHER &&\r\n            acceptingPayments);\r\n        Deposit(msg.value);\r\n    }\r\n\r\n    // Destructor\r\n    // Selfdestructs on the condition that `totalSupply` and `committedEther`\r\n    // are 0\r\n    function destroy()\r\n        public\r\n        canEnter\r\n        onlyTrustee\r\n    {\r\n        require(totalSupply == 0 && committedEther == 0);\r\n        \r\n        delete holders[trustee];\r\n        selfdestruct(msg.sender);\r\n    }\r\n\r\n    // One Time Programable shot to set the panic and pending periods.\r\n    // 86400 == 1 day\r\n    function _init(uint40 _panicPeriodInSeconds, uint40 _pendingPeriodInSeconds)\r\n        onlyTrustee\r\n        returns (bool)\r\n    {\r\n        require(__initFuse);\r\n        PANICPERIOD = _panicPeriodInSeconds;\r\n        TXDELAY = _pendingPeriodInSeconds;\r\n        acceptingPayments = true;\r\n        delete __initFuse;\r\n        return true;\r\n    }\r\n\r\n    // Returns calculated fund balance\r\n    function fundBalance()\r\n        public\r\n        constant\r\n        returns (uint)\r\n    {\r\n        return this.balance - committedEther;\r\n    }\r\n\r\n    // Returns token price constant\r\n    function tokenPrice()\r\n        public\r\n        constant\r\n        returns (uint)\r\n    {\r\n        return TOKENPRICE;\r\n    }\r\n\r\n    // `RegBase` compliant `changeResource()` to restrict caller to\r\n    // `trustee` rather than `owner`\r\n    function changeResource(bytes32 _resource)\r\n        public\r\n        canEnter\r\n        onlyTrustee\r\n        returns (bool)\r\n    {\r\n        resource = _resource;\r\n        return true;\r\n    }\r\n\r\n//\r\n// ERC20 API functions\r\n//\r\n\r\n    // Returns holder token balance\r\n    function balanceOf(address _addr) \r\n        public\r\n        constant\r\n        returns (uint)\r\n    {\r\n        return holders[_addr].tokenBalance;\r\n    }\r\n\r\n    // To transfer tokens\r\n    function transfer(address _to, uint _amount)\r\n        public\r\n        canEnter\r\n        isHolder(_to)\r\n        returns (bool)\r\n    {\r\n        Holder from = holders[msg.sender];\r\n        Holder to = holders[_to];\r\n\r\n        Transfer(msg.sender, _to, _amount);\r\n        return xfer(from, to, _amount);\r\n    }\r\n\r\n    // To transfer tokens by proxy\r\n    function transferFrom(address _from, address _to, uint256 _amount)\r\n        public\r\n        canEnter\r\n        isHolder(_to)\r\n        returns (bool)\r\n    {\r\n        require(_amount <= holders[_from].allowances[msg.sender]);\r\n        \r\n        Holder from = holders[_from];\r\n        Holder to = holders[_to];\r\n\r\n        from.allowances[msg.sender] -= _amount;\r\n        Transfer(_from, _to, _amount);\r\n        return xfer(from, to, _amount);\r\n    }\r\n\r\n    // To approve a proxy for token transfers\r\n    function approve(address _spender, uint256 _amount)\r\n        public\r\n        canEnter\r\n        returns (bool)\r\n    {\r\n        holders[msg.sender].allowances[_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    // Return the alloance of a proxy\r\n    function allowance(address _owner, address _spender)\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return holders[_owner].allowances[_spender];\r\n    }\r\n\r\n    // Processes token transfers and subsequent change in voting power\r\n    function xfer(Holder storage _from, Holder storage _to, uint _amount)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        // Ensure dividends are up to date at current balances\r\n        updateDividendsFor(_from);\r\n        updateDividendsFor(_to);\r\n\r\n        // Remove existing votes\r\n        revoke(_from);\r\n        revoke(_to);\r\n\r\n        // Transfer tokens\r\n        _from.tokenBalance -= _amount;\r\n        _to.tokenBalance += _amount;\r\n\r\n        // Revote accoring to changed token balances\r\n        revote(_from);\r\n        revote(_to);\r\n\r\n        // Force election\r\n        election();\r\n        return true;\r\n    }\r\n\r\n//\r\n// Security Functions\r\n//\r\n\r\n    // Cause the contract to Panic. This will block most state changing\r\n    // functions for a set delay.\r\n    function PANIC()\r\n        public\r\n        isHolder(msg.sender)\r\n        returns (bool)\r\n    {\r\n        // A blocking holder requires at least 10% of tokens\r\n        require(holders[msg.sender].tokenBalance >= totalSupply / 10);\r\n        \r\n        panicked = true;\r\n        timeToCalm = uint40(now + PANICPERIOD);\r\n        Panicked(msg.sender);\r\n        return true;\r\n    }\r\n\r\n    // Release the contract from a Panic after the panic period has expired.\r\n    function calm()\r\n        public\r\n        isHolder(msg.sender)\r\n        returns (bool)\r\n    {\r\n        require(uint40(now) > timeToCalm && panicked);\r\n        \r\n        panicked = false;\r\n        Calm();\r\n        return true;\r\n    }\r\n\r\n    // Queues a pending transaction \r\n    function timeLockSend(address _from, address _to, uint _value, bytes _data)\r\n        internal\r\n        returns (uint8)\r\n    {\r\n        // Check that queue is not full\r\n        require(ptxHead + 1 != ptxTail);\r\n\r\n        TX memory tx = TX({\r\n            from: _from,\r\n            to: _to,\r\n            value: _value,\r\n            data: _data,\r\n            blocked: false,\r\n            timeLock: uint40(now + TXDELAY)\r\n        });\r\n        TransactionPending(ptxHead, _from, _to, _value, now + TXDELAY);\r\n        pendingTxs[ptxHead++] = tx;\r\n        return  ptxHead - 1;\r\n    }\r\n\r\n    // Execute the first TX in the pendingTxs queue. Values will\r\n    // revert if the transaction is blocked or fails.\r\n    function sendPending()\r\n        public\r\n        preventReentry\r\n        isHolder(msg.sender)\r\n        returns (bool)\r\n    {\r\n        if (ptxTail == ptxHead) return false; // TX queue is empty\r\n        \r\n        TX memory tx = pendingTxs[ptxTail];\r\n        if(now < tx.timeLock) return false;\r\n        \r\n        // Have memory cached the TX so deleting store now to prevent any chance\r\n        // of double spends.\r\n        delete pendingTxs[ptxTail++];\r\n        \r\n        if(!tx.blocked) {\r\n            if(tx.to.call.value(tx.value)(tx.data)) {\r\n                // TX sent successfully\r\n                committedEther -= tx.value;\r\n                \r\n                Withdrawal(tx.from, tx.to, tx.value);\r\n                return true;\r\n            }\r\n        }\r\n        \r\n        // TX is blocked or failed so manually revert balances to pre-pending\r\n        // state\r\n        if (tx.from == address(this)) {\r\n            // Was sent from fund balance\r\n            committedEther -= tx.value;\r\n        } else {\r\n            // Was sent from holder ether balance\r\n            holders[tx.from].etherBalance += tx.value;\r\n        }\r\n        \r\n        TransactionFailed(tx.from, tx.to, tx.value);\r\n        return false;\r\n    }\r\n\r\n    // To block a pending transaction\r\n    function blockPendingTx(uint _txIdx)\r\n        public\r\n        returns (bool)\r\n    {\r\n        // Only prevent reentry not entry during panic\r\n        require(!__reMutex);\r\n        \r\n        // A blocking holder requires at least 10% of tokens or is trustee or\r\n        // is from own account\r\n        require(holders[msg.sender].tokenBalance >= totalSupply / BLOCKPCNT ||\r\n            msg.sender == pendingTxs[ptxTail].from ||\r\n            msg.sender == trustee);\r\n        \r\n        pendingTxs[_txIdx].blocked = true;\r\n        TransactionBlocked(msg.sender, _txIdx);\r\n        return true;\r\n    }\r\n\r\n//\r\n// Trustee functions\r\n//\r\n\r\n    // For the trustee to send a transaction as the contract. Returns pending\r\n    // TX queue index\r\n    function execute(address _to, uint _value, bytes _data)\r\n        public\r\n        canEnter\r\n        onlyTrustee\r\n        returns (uint8)\r\n    {\r\n        require(_value <= fundBalance());\r\n\r\n        committedEther += _value;\r\n        return timeLockSend(address(this), _to, _value, _data);\r\n    }\r\n\r\n    // For the trustee to commit an amount from the fund balance as a dividend\r\n    function payDividends(uint _value)\r\n        public\r\n        canEnter\r\n        onlyTrustee\r\n        returns (bool)\r\n    {\r\n        require(_value <= fundBalance());\r\n        // Calculates dividend as percent of current `totalSupply` in 10e17\r\n        // fixed point math\r\n        dividendPoints += 10**18 * _value / totalSupply;\r\n        totalDividends += _value;\r\n        committedEther += _value;\r\n        return true;\r\n    }\r\n    \r\n    // For the trustee to add an address as a holder\r\n    function addHolder(address _addr)\r\n        public\r\n        canEnter\r\n        onlyTrustee\r\n        returns (bool)\r\n    {\r\n        return join(_addr);\r\n    }\r\n\r\n    // Creates holder accounts.  Called by addHolder() and issue()\r\n    function join(address _addr)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if(0 != holders[_addr].id) return true;\r\n        \r\n        require(_addr != address(this));\r\n        \r\n        uint8 id;\r\n        // Search for the first available slot.\r\n        while (holderIndex[++id] != 0) {}\r\n        \r\n        // if `id` is 0 then there has been a array full overflow.\r\n        if(id == 0) revert();\r\n        \r\n        Holder holder = holders[_addr];\r\n        holder.id = id;\r\n        holder.lastClaimed = dividendPoints;\r\n        holder.votingFor = trustee;\r\n        holderIndex[id] = _addr;\r\n        NewHolder(_addr);\r\n        return true;\r\n    }\r\n\r\n    // For the trustee to allow or disallow payments made to the Bakt\r\n    function acceptPayments(bool _accepting)\r\n        public\r\n        canEnter\r\n        onlyTrustee\r\n        returns (bool)\r\n    {\r\n        acceptingPayments = _accepting;\r\n        return true;\r\n    }\r\n\r\n    // For the trustee to issue an offer of new tokens to a holder\r\n    function issue(address _addr, uint _amount)\r\n        public\r\n        canEnter\r\n        onlyTrustee\r\n        returns (bool)\r\n    {\r\n        // prevent overflows in total supply\r\n        assert(totalSupply + _amount < MAXTOKENS);\r\n        \r\n        join(_addr);\r\n        Holder holder = holders[_addr];\r\n        holder.offerAmount = _amount;\r\n        holder.offerExpiry = uint40(now + 7 days);\r\n        IssueOffer(_addr);\r\n        return true;\r\n    }\r\n\r\n    // For the trustee to revoke an earlier Issue Offer\r\n    function revokeOffer(address _addr)\r\n        public\r\n        canEnter\r\n        onlyTrustee\r\n        returns (bool)\r\n    {\r\n        Holder holder = holders[_addr];\r\n        delete holder.offerAmount;\r\n        delete holder.offerExpiry;\r\n        return true;\r\n    }\r\n\r\n//\r\n// Holder Functions\r\n//\r\n\r\n    // Returns the array of holder addresses.\r\n    function getHolders()\r\n        public\r\n        constant\r\n        returns(address[256])\r\n    {\r\n        return holderIndex;\r\n    }\r\n\r\n    // Returns the holder's withdrawable balance of ether\r\n    function etherBalanceOf(address _addr)\r\n        public\r\n        constant\r\n        returns (uint)\r\n    {\r\n        Holder holder = holders[_addr];\r\n        return holder.etherBalance + dividendsOwing(holder);\r\n    }\r\n\r\n    // For a holder to initiate a withdrawal of their ether balance\r\n    function withdraw()\r\n        public\r\n        canEnter\r\n        returns(uint8 pTxId_)\r\n    {\r\n        Holder holder = holders[msg.sender];\r\n        updateDividendsFor(holder);\r\n        \r\n        pTxId_ = timeLockSend(msg.sender, msg.sender, holder.etherBalance, \"\");\r\n        holder.etherBalance = 0;\r\n    }\r\n\r\n    // To close a holder account\r\n    function vacate(address _addr)\r\n        public\r\n        canEnter\r\n        isHolder(msg.sender)\r\n        isHolder(_addr)\r\n        returns (bool)\r\n    {\r\n        Holder holder = holders[_addr];\r\n        // Ensure holder account is empty, is not the trustee and there are no\r\n        // pending transactions or dividends\r\n        require(_addr != trustee);\r\n        require(holder.tokenBalance == 0);\r\n        require(holder.etherBalance == 0);\r\n        require(holder.lastClaimed == dividendPoints);\r\n        require(ptxHead == ptxTail);\r\n        \r\n        delete holderIndex[holder.id];\r\n        delete holders[_addr];\r\n        // NB can't garbage collect holder.allowances mapping\r\n        return (true);\r\n    }\r\n\r\n//\r\n// Token Creation/Destruction Functions\r\n//\r\n\r\n    // For a holder to buy an offer of tokens\r\n    function purchase()\r\n        payable\r\n        canEnter\r\n        returns (bool)\r\n    {\r\n        Holder holder = holders[msg.sender];\r\n        // offer must exist\r\n        require(holder.offerAmount > 0);\r\n        // offer not expired\r\n        require(holder.offerExpiry > now);\r\n        // correct payment has been sent\r\n        require(msg.value == holder.offerAmount * TOKENPRICE);\r\n        \r\n        updateDividendsFor(holder);\r\n                \r\n        revoke(holder);\r\n                \r\n        totalSupply += holder.offerAmount;\r\n        holder.tokenBalance += holder.offerAmount;\r\n        TokensCreated(msg.sender, holder.offerAmount);\r\n        \r\n        delete holder.offerAmount;\r\n        delete holder.offerExpiry;\r\n        \r\n        revote(holder);\r\n        election();\r\n        return true;\r\n    }\r\n\r\n    // For holders to destroy tokens in return for ether during a redeeming\r\n    // round\r\n    function redeem(uint _amount)\r\n        public\r\n        canEnter\r\n        isHolder(msg.sender)\r\n        returns (bool)\r\n    {\r\n        uint redeemPrice;\r\n        uint eth;\r\n        \r\n        Holder holder = holders[msg.sender];\r\n        require(_amount <= holder.tokenBalance);\r\n        \r\n        updateDividendsFor(holder);\r\n        \r\n        revoke(holder);\r\n        \r\n        redeemPrice = fundBalance() / totalSupply;\r\n        // prevent redeeming above token price which would allow an arbitrage\r\n        // attack on the fund balance\r\n        redeemPrice = redeemPrice < TOKENPRICE ? redeemPrice : TOKENPRICE;\r\n        \r\n        eth = _amount * redeemPrice;\r\n        \r\n        // will throw if either `amount` or `redeemPRice` are 0\r\n        require(eth > 0);\r\n        \r\n        totalSupply -= _amount;\r\n        holder.tokenBalance -= _amount;\r\n        holder.etherBalance += eth;\r\n        committedEther += eth;\r\n        \r\n        TokensDestroyed(msg.sender, _amount);\r\n        revote(holder);\r\n        election();\r\n        return true;\r\n    }\r\n\r\n//\r\n// Dividend Functions\r\n//\r\n\r\n    function dividendsOwing(Holder storage _holder)\r\n        internal\r\n        constant\r\n        returns (uint _value)\r\n    {\r\n        // Calculates owed dividends in 10e17 fixed point math\r\n        return (dividendPoints - _holder.lastClaimed) * _holder.tokenBalance/\r\n            10**18;\r\n    }\r\n    \r\n    function updateDividendsFor(Holder storage _holder)\r\n        internal\r\n    {\r\n        _holder.etherBalance += dividendsOwing(_holder);\r\n        _holder.lastClaimed = dividendPoints;\r\n    }\r\n\r\n//\r\n// Ballot functions\r\n//\r\n\r\n    // To vote for a preferred Trustee.\r\n    function vote(address _candidate)\r\n        public\r\n        isHolder(msg.sender)\r\n        isHolder(_candidate)\r\n        returns (bool)\r\n    {\r\n        // Only prevent reentry not entry during panic\r\n        require(!__reMutex);\r\n        \r\n        Holder holder = holders[msg.sender];\r\n        revoke(holder);\r\n        holder.votingFor = _candidate;\r\n        revote(holder);\r\n        election();\r\n        return true;\r\n    }\r\n\r\n    // Loops through holders to find the holder with most votes and declares\r\n    // them to be the Executive;\r\n    function election()\r\n        internal\r\n    {\r\n        uint max;\r\n        uint winner;\r\n        uint votes;\r\n        uint8 i;\r\n        address addr;\r\n        \r\n        if (0 == totalSupply) return;\r\n        \r\n        while(++i != 0)\r\n        {\r\n            addr = holderIndex[i];\r\n            if (addr != 0x0) {\r\n                votes = holders[addr].votes;\r\n                if (votes > max) {\r\n                    max = votes;\r\n                    winner = i;\r\n                }\r\n            }\r\n        }\r\n        trustee = holderIndex[winner];\r\n        Trustee(trustee);\r\n    }\r\n\r\n    // Pulls votes from the preferred candidate\r\n    // required before any adjustments to `tokenBalance` or vote preference.\r\n    function revoke(Holder _holder)\r\n        internal\r\n    {\r\n        holders[_holder.votingFor].votes -= _holder.tokenBalance;\r\n    }\r\n\r\n    // Places votes with preferred candidate\r\n    // required after any adjustments to `tokenBalance` or vote preference.\r\n    function revote(Holder _holder)\r\n        internal\r\n    {\r\n        holders[_holder.votingFor].votes += _holder.tokenBalance;\r\n    }\r\n\r\n//\r\n// Modifiers\r\n//\r\n\r\n    // Blocks if reentry mutex or panicked is true or sets rentry mutex to true\r\n    modifier preventReentry() {\r\n        require(!(__reMutex || panicked || __initFuse));\r\n        __reMutex = true;\r\n        _;\r\n        __reMutex = false;\r\n        return;\r\n    }\r\n\r\n    // Blocks if reentry mutex or panicked is true\r\n    modifier canEnter() {\r\n        require(!(__reMutex || panicked || __initFuse));\r\n        _;\r\n    }\r\n\r\n    // Blocks if '_addr' is not a holder\r\n    modifier isHolder(address _addr) {\r\n        require(0 != holders[_addr].id);\r\n        _;\r\n    }\r\n\r\n    // Block non-trustee holders\r\n    modifier onlyTrustee() {\r\n        require(msg.sender == trustee);\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n// SandalStraps compliant factory for Bakt\r\ncontract BaktFactory is Factory\r\n{\r\n    // Live: 0xc7c11eb6983787f7aa0c20abeeac8101cf621e47\r\n    // https://etherscan.io/address/0xc7c11eb6983787f7aa0c20abeeac8101cf621e47\r\n    // Ropsten: 0xda33129464688b7bd752ce64e9ed6bca65f44902 (could not verify),\r\n    //          0x19124dbab3fcba78b8d240ed2f2eb87654e252d4\r\n    // Rinkeby: \r\n\r\n/* Constants */\r\n\r\n    bytes32 constant public regName = \"Bakt\";\r\n    bytes32 constant public VERSION = \"Bakt Factory v0.3.4-beta\";\r\n\r\n/* Constructor Destructor*/\r\n\r\n    function BaktFactory(address _creator, bytes32 _regName, address _owner)\r\n        Factory(_creator, _regName, _owner)\r\n    {\r\n        // nothing to construct\r\n    }\r\n\r\n/* Public Functions */\r\n\r\n    function createNew(bytes32 _regName, address _owner)\r\n        payable\r\n        feePaid\r\n        returns (address kAddr_)\r\n    {\r\n        require(_regName != 0x0);\r\n        kAddr_ = new Bakt(owner, _regName, msg.sender);\r\n        Created(msg.sender, _regName, kAddr_);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_resource\",\"type\":\"bytes32\"}],\"name\":\"changeResource\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"regName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resource\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"value\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"set\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_regName\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"createNew\",\"outputs\":[{\"name\":\"kAddr_\",\"type\":\"address\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_creator\",\"type\":\"address\"},{\"name\":\"_regName\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_regName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ChangedOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"resource\",\"type\":\"bytes32\"}],\"name\":\"ChangedResource\",\"type\":\"event\"}]","ContractName":"BaktFactory","CompilerVersion":"v0.4.10+commit.f0d539ae","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://5cd4e66884034d768ce5f5d3f3438ca5d93bff2aeb0934fd13b3d826ad545b6f"}]}