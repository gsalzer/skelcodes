{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n/*\r\n  Allows owner/seller to deposit ETH in order to participate in\r\n  an ICO on behalf of the contract so that users can buy directly\r\n  from this contract with assurances that they will receive their\r\n  tokens via a user-invoked withdrawal() call once the ICO token\r\n  creator releases tokens for trading.\r\n\r\n  This affords users the ability to reserve/claim tokens that they\r\n  were not able to buy in an ICO, before they hit the exchanges.\r\n\r\n*/\r\ncontract DaoCasinoToken {\r\n  uint256 public CAP;\r\n  uint256 public totalEthers;\r\n  function proxyPayment(address participant) payable;\r\n  function transfer(address _to, uint _amount) returns (bool success);\r\n  function balanceOf(address _owner) constant returns (uint256 balance);\r\n}\r\n\r\ncontract BETSale {\r\n  // Store the amount of BET purchased by a buyer\r\n  mapping (address => uint256) public bet_purchased;\r\n\r\n  // Store the amount of ETH sent in by a buyer. Good to have this record just in case\r\n  mapping (address => uint256) public eth_sent;\r\n\r\n  // Total BET available to sell\r\n  uint256 public total_bet_available;\r\n\r\n  // Total BET purchased by all buyers\r\n  uint256 public total_bet_purchased;\r\n\r\n  // Total BET withdrawn by all buyers\r\n  uint256 public total_bet_withdrawn;\r\n\r\n  // BET per ETH (price)\r\n  uint256 public price_per_eth = 900;\r\n\r\n  //  BET token contract address (IOU offering)\r\n  DaoCasinoToken public token = DaoCasinoToken(0x725803315519de78D232265A8f1040f054e70B98);\r\n\r\n  // The seller's address\r\n  address seller = 0xB00Ae1e677B27Eee9955d632FF07a8590210B366;\r\n\r\n  // Halt further purchase ability just in case\r\n  bool public halt_purchases;\r\n\r\n  /*\r\n    Safety to withdraw all tokens, ONLY if all buyers have already withdrawn their purchases\r\n  */\r\n  function withdrawTokens() {\r\n    if(msg.sender != seller) throw;\r\n    if(total_bet_withdrawn != total_bet_purchased) throw;\r\n\r\n    // reset everything\r\n    total_bet_available = 0;\r\n    total_bet_purchased = 0;\r\n    total_bet_withdrawn = 0;\r\n\r\n    token.transfer(seller, token.balanceOf(address(this)));\r\n  }\r\n\r\n  /*\r\n    Safety to withdraw ETH\r\n  */\r\n  function withdrawETH() {\r\n    if(msg.sender != seller) throw;\r\n    msg.sender.transfer(this.balance);\r\n  }\r\n\r\n  /*\r\n    Initiate ICO purchase\r\n  */\r\n  function buyTokens() payable {\r\n    if(msg.sender != seller) throw;\r\n    if(token.totalEthers() < token.CAP()) {\r\n      token.proxyPayment.value(this.balance)(address(this));\r\n    }\r\n  }\r\n\r\n  /*\r\n    Update available BET to purchase\r\n  */\r\n  function updateAvailability(uint256 _bet_amount) {\r\n    if(msg.sender != seller) throw;\r\n    total_bet_available += _bet_amount;\r\n  }\r\n\r\n  /*\r\n    Update BET price\r\n  */\r\n  function updatePrice(uint256 _price) {\r\n    if(msg.sender != seller) throw;\r\n    price_per_eth = _price;\r\n  }\r\n\r\n  /*\r\n    Safety to prevent anymore purchases/sales from occurring in the event of\r\n    unforeseen issue. Buyer token withdrawals still allowed\r\n  */\r\n  function haltPurchases() {\r\n    if(msg.sender != seller) throw;\r\n    halt_purchases = true;\r\n  }\r\n\r\n  function resumePurchases() {\r\n    if(msg.sender != seller) throw;\r\n    halt_purchases = false;\r\n  }\r\n\r\n  function withdraw() {\r\n    // Dismiss any early or ill attempts at withdrawing\r\n    if(token.balanceOf(address(this)) == 0 || bet_purchased[msg.sender] == 0) throw;\r\n\r\n    uint256 bet_to_withdraw = bet_purchased[msg.sender];\r\n\r\n    // Clear record of buyer's BET balance before transferring out\r\n    bet_purchased[msg.sender] = 0;\r\n\r\n    total_bet_withdrawn += bet_to_withdraw;\r\n\r\n    // Distribute tokens to the buyer\r\n    if(!token.transfer(msg.sender, bet_to_withdraw)) throw;\r\n  }\r\n\r\n  function purchase() payable {\r\n    if(halt_purchases) throw;\r\n\r\n    // Determine amount of tokens user wants to/can buy\r\n    uint256 bet_to_purchase = price_per_eth * msg.value;\r\n\r\n    // Check if we have enough BET left to sell\r\n    if((total_bet_purchased + bet_to_purchase) > total_bet_available) throw;\r\n\r\n    // Update the amount of BET purchased by user. Also keep track of the total ETH they sent in\r\n    bet_purchased[msg.sender] += bet_to_purchase;\r\n    eth_sent[msg.sender] += msg.value;\r\n\r\n    // Update the total amount of BET purchased by all buyers over all periods of availability\r\n    total_bet_purchased += bet_to_purchase;\r\n\r\n    // Tokens are clearly in the contract, therefore we can release ETH to seller's address\r\n    seller.transfer(msg.value);\r\n  }\r\n\r\n  // Fallback function/entry point\r\n  function () payable {\r\n    if(msg.value == 0) {\r\n      withdraw();\r\n    }\r\n    else {\r\n      if(msg.sender == seller) {\r\n        return;\r\n      }\r\n      purchase();\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"eth_sent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"haltPurchases\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_bet_available\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_bet_purchased\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bet_amount\",\"type\":\"uint256\"}],\"name\":\"updateAvailability\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resumePurchases\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"purchase\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bet_purchased\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"updatePrice\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price_per_eth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_bet_withdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halt_purchases\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"payable\":true,\"type\":\"fallback\"}]","ContractName":"BETSale","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://01b76400f83db393db51d03e122e0d0b642b03860ee2900c381f291ce8ddaa5d"}]}