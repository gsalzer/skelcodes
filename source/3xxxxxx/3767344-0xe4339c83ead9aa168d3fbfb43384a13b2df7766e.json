{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n\r\n/* Interface of the ERC223 token */\r\ncontract ERC223TokenInterface {\r\n    function name() constant returns (string _name);\r\n    function symbol() constant returns (string _symbol);\r\n    function decimals() constant returns (uint8 _decimals);\r\n    function totalSupply() constant returns (uint256 _supply);\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 _balance);\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool _success);\r\n    function allowance(address _owner, address spender) constant returns (uint256 _remaining);\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool _success);\r\n    function transfer(address _to, uint256 _value, bytes _metadata) returns (bool _success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool _success);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value, bytes metadata);\r\n}\r\n\r\n\r\n/* Interface of the contract that is going to receive ERC223 tokens */\r\ncontract ERC223ContractInterface {\r\n    function erc223Fallback(address _from, uint256 _value, bytes _data){\r\n        // to avoid warnings during compilation\r\n        _from = _from;\r\n        _value = _value;\r\n        _data = _data;\r\n        // Incoming transaction code here\r\n        throw;\r\n    }\r\n}\r\n\r\n\r\n/* https://github.com/LykkeCity/EthereumApiDotNetCore/blob/master/src/ContractBuilder/contracts/token/SafeMath.sol */\r\ncontract SafeMath {\r\n    uint256 constant public MAX_UINT256 =\r\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        if (x > MAX_UINT256 - y) throw;\r\n        return x + y;\r\n    }\r\n\r\n    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        if (x < y) throw;\r\n        return x - y;\r\n    }\r\n\r\n    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        if (y == 0) return 0;\r\n        if (x > MAX_UINT256 / y) throw;\r\n        return x * y;\r\n    }\r\n}\r\n\r\n\r\ncontract ERC223Token is ERC223TokenInterface, SafeMath {\r\n\r\n    /*\r\n      Storage of the contract\r\n    */\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowances;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n\r\n\r\n    /*\r\n      Getters\r\n    */\r\n\r\n    function name() constant returns (string _name) {\r\n        return name;\r\n    }\r\n\r\n    function symbol() constant returns (string _symbol) {\r\n        return symbol;\r\n    }\r\n\r\n    function decimals() constant returns (uint8 _decimals) {\r\n        return decimals;\r\n    }\r\n\r\n    function totalSupply() constant returns (uint256 _supply) {\r\n        return totalSupply;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 _balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n\r\n    /*\r\n      Allow to spend\r\n    */\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool _success) {\r\n        allowances[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 _remaining) {\r\n        return allowances[_owner][_spender];\r\n    }\r\n\r\n\r\n    /*\r\n      Transfer\r\n    */\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool _success) {\r\n        bytes memory emptyMetadata;\r\n        __transfer(msg.sender, _to, _value, emptyMetadata);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value, bytes _metadata) returns (bool _success)\r\n    {\r\n        __transfer(msg.sender, _to, _value, _metadata);\r\n        Transfer(msg.sender, _to, _value, _metadata);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool _success) {\r\n        if (allowances[_from][msg.sender] < _value) throw;\r\n\r\n        allowances[_from][msg.sender] = safeSub(allowances[_from][msg.sender], _value);\r\n        bytes memory emptyMetadata;\r\n        __transfer(_from, _to, _value, emptyMetadata);\r\n        return true;\r\n    }\r\n\r\n    function __transfer(address _from, address _to, uint256 _value, bytes _metadata) internal\r\n    {\r\n        if (_from == _to) throw;\r\n        if (_value == 0) throw;\r\n        if (balanceOf(_from) < _value) throw;\r\n\r\n        balances[_from] = safeSub(balanceOf(_from), _value);\r\n        balances[_to] = safeAdd(balanceOf(_to), _value);\r\n\r\n        if (isContract(_to)) {\r\n            ERC223ContractInterface receiverContract = ERC223ContractInterface(_to);\r\n            receiverContract.erc223Fallback(_from, _value, _metadata);\r\n        }\r\n\r\n        Transfer(_from, _to, _value);\r\n    }\r\n\r\n\r\n    /*\r\n      Helpers\r\n    */\r\n\r\n    // Assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n    function isContract(address _addr) internal returns (bool _isContract) {\r\n        _addr = _addr; // to avoid warnings during compilation\r\n\r\n        uint256 length;\r\n        assembly {\r\n            //retrieve the size of the code on target address, this needs assembly\r\n            length := extcodesize(_addr)\r\n        }\r\n        return (length > 0);\r\n    }\r\n}\r\n\r\n\r\n// ERC223 token with the ability for the owner to block any account\r\ncontract DASToken is ERC223Token {\r\n    mapping (address => bool) blockedAccounts;\r\n    address public secretaryGeneral;\r\n\r\n\r\n    // Constructor\r\n    function DASToken(\r\n            string _name,\r\n            string _symbol,\r\n            uint8 _decimals,\r\n            uint256 _totalSupply,\r\n            address _initialTokensHolder) {\r\n        secretaryGeneral = msg.sender;\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        totalSupply = _totalSupply;\r\n        balances[_initialTokensHolder] = _totalSupply;\r\n    }\r\n\r\n\r\n    modifier onlySecretaryGeneral {\r\n        if (msg.sender != secretaryGeneral) throw;\r\n        _;\r\n    }\r\n\r\n\r\n    // block account\r\n    function blockAccount(address _account) onlySecretaryGeneral {\r\n        blockedAccounts[_account] = true;\r\n    }\r\n\r\n    // unblock account\r\n    function unblockAccount(address _account) onlySecretaryGeneral {\r\n        blockedAccounts[_account] = false;\r\n    }\r\n\r\n    // check is account blocked\r\n    function isAccountBlocked(address _account) returns (bool){\r\n        return blockedAccounts[_account];\r\n    }\r\n\r\n    // override transfer methods to throw on blocked accounts\r\n    function transfer(address _to, uint256 _value) returns (bool _success) {\r\n        if (blockedAccounts[msg.sender]) {\r\n            throw;\r\n        }\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value, bytes _metadata) returns (bool _success) {\r\n        if (blockedAccounts[msg.sender]) {\r\n            throw;\r\n        }\r\n        return super.transfer(_to, _value, _metadata);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool _success) {\r\n        if (blockedAccounts[_from]) {\r\n            throw;\r\n        }\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n}\r\n\r\n\r\ncontract ABCToken is ERC223Token {\r\n    // Constructor\r\n    function ABCToken(\r\n            string _name,\r\n            string _symbol,\r\n            uint8 _decimals,\r\n            uint256 _totalSupply,\r\n            address _initialTokensHolder) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        totalSupply = _totalSupply;\r\n        balances[_initialTokensHolder] = _totalSupply;\r\n    }\r\n}\r\n\r\n\r\n// Contract with voting on proposals and execution of passed proposals\r\ncontract DAS is ERC223ContractInterface {\r\n\r\n    /* Contract Variables */\r\n\r\n    string name = \"Decentralized Autonomous State\";\r\n    // Source of democracy\r\n    DASToken public dasToken;\r\n    ABCToken public abcToken;\r\n    // Democracy rules\r\n    uint256 public congressMemberThreshold; // User must have more than this amount of tokens to be included into congress\r\n    uint256 public minimumQuorum;           // The minimum number of tokens that must participate in a vote to achieve a quorum\r\n    uint256 public debatingPeriod;          // Min time to vote for an proposal [sec]\r\n    uint256 public marginForMajority;       // Min superiority of votes \"for\" to pass the proposal [number of tokens]\r\n    // Proposals\r\n    Proposal[] public proposals;\r\n    uint256 public proposalsNumber = 0;\r\n    mapping (address => uint32) tokensLocks;         // congress member => number of locks (recursive mutex)\r\n\r\n    /* Contract Events */\r\n    event ProposalAddedEvent(uint256 proposalID, address beneficiary, uint256 etherAmount, string description);\r\n    event VotedEvent(uint256 proposalID, address voter, bool inSupport, uint256 voterTokens, string justificationText);\r\n    event ProposalTalliedEvent(uint256 proposalID, bool quorum, bool result);\r\n    event ProposalExecutedEvent(uint256 proposalID);\r\n    event RulesChangedEvent(uint256 congressMemberThreshold,\r\n                            uint256 minimumQuorum,\r\n                            uint256 debatingPeriod,\r\n                            uint256 marginForMajority);\r\n\r\n    /* Contract Structures */\r\n    enum ProposalState {Proposed, NoQuorum, Rejected, Passed, Executed}\r\n\r\n    struct Proposal {\r\n        /* Proposal content */\r\n        address beneficiary;\r\n        uint256 etherAmount;\r\n        string description;\r\n        bytes32 proposalHash;\r\n\r\n        /* Proposal state */\r\n        ProposalState state;\r\n\r\n        /* Voting state */\r\n        uint256 votingDeadline;\r\n        Vote[] votes;\r\n        uint256 votesNumber;\r\n        mapping (address => bool) voted;\r\n    }\r\n\r\n    struct Vote {\r\n        address voter;\r\n        bool inSupport;\r\n        uint256 voterTokens;\r\n        string justificationText;\r\n    }\r\n\r\n    /* modifier that allows only congress members to vote and create new proposals */\r\n    modifier onlyCongressMembers {\r\n        if (dasToken.balanceOf(msg.sender) < congressMemberThreshold) throw;\r\n        _;\r\n    }\r\n\r\n    /* Constructor */\r\n    function DAS(\r\n        uint256 _congressMemberThreshold,\r\n        uint256 _minimumQuorum,\r\n        uint256 _debatingPeriod,\r\n        uint256 _marginForMajority,\r\n        address _congressLeader\r\n    ) payable {\r\n        // create a source of democracy\r\n        dasToken = new DASToken('DA$', 'DA$', 18, 1000000000 * (10 ** 18), _congressLeader);\r\n        abcToken = new ABCToken('Alphabit', 'ABC', 18, 210000000 * (10 ** 18), _congressLeader);\r\n\r\n        // setup rules\r\n        congressMemberThreshold = _congressMemberThreshold;\r\n        minimumQuorum = _minimumQuorum;\r\n        debatingPeriod = _debatingPeriod;\r\n        marginForMajority = _marginForMajority;\r\n\r\n        RulesChangedEvent(congressMemberThreshold, minimumQuorum, debatingPeriod, marginForMajority);\r\n    }\r\n\r\n    // blank fallback functions to receive ETH and tokens\r\n    function() payable { }\r\n\r\n    function erc223Fallback(address _from, uint256 _value, bytes _data){\r\n        // to avoid warnings during compilation\r\n        _from = _from;\r\n        _value = _value;\r\n        _data = _data;\r\n    }\r\n\r\n\r\n    /* Proposal-related functions */\r\n\r\n    // calculate hash of an proposal\r\n    function getProposalHash(\r\n        address _beneficiary,\r\n        uint256 _etherAmount,\r\n        bytes _transactionBytecode\r\n    )\r\n        constant\r\n        returns (bytes32)\r\n    {\r\n        return sha3(_beneficiary, _etherAmount, _transactionBytecode);\r\n    }\r\n\r\n    // block tokens of an voter\r\n    function blockTokens(address _voter) internal {\r\n        if (tokensLocks[_voter] + 1 < tokensLocks[_voter]) throw;\r\n\r\n        tokensLocks[_voter] += 1;\r\n        if (tokensLocks[_voter] == 1) {\r\n            dasToken.blockAccount(_voter);\r\n        }\r\n    }\r\n\r\n    // unblock tokens of an voter\r\n    function unblockTokens(address _voter) internal {\r\n        if (tokensLocks[_voter] <= 0) throw;\r\n\r\n        tokensLocks[_voter] -= 1;\r\n        if (tokensLocks[_voter] == 0) {\r\n            dasToken.unblockAccount(_voter);\r\n        }\r\n    }\r\n\r\n    // create new proposal\r\n    function createProposal(\r\n        address _beneficiary,\r\n        uint256 _etherAmount,\r\n        string _description,\r\n        bytes _transactionBytecode\r\n    )\r\n        onlyCongressMembers\r\n        returns (uint256 _proposalID)\r\n    {\r\n        _proposalID = proposals.length;\r\n        proposals.length += 1;\r\n        proposalsNumber = _proposalID + 1;\r\n\r\n        proposals[_proposalID].beneficiary = _beneficiary;\r\n        proposals[_proposalID].etherAmount = _etherAmount;\r\n        proposals[_proposalID].description = _description;\r\n        proposals[_proposalID].proposalHash = getProposalHash(_beneficiary, _etherAmount, _transactionBytecode);\r\n        proposals[_proposalID].state = ProposalState.Proposed;\r\n        proposals[_proposalID].votingDeadline = now + debatingPeriod * 1 seconds;\r\n        proposals[_proposalID].votesNumber = 0;\r\n\r\n        ProposalAddedEvent(_proposalID, _beneficiary, _etherAmount, _description);\r\n\r\n        return _proposalID;\r\n    }\r\n\r\n    // vote for an proposal\r\n    function vote(\r\n        uint256 _proposalID,\r\n        bool _inSupport,\r\n        string _justificationText\r\n    )\r\n        onlyCongressMembers\r\n    {\r\n        Proposal p = proposals[_proposalID];\r\n\r\n        if (p.state != ProposalState.Proposed) throw;\r\n        if (p.voted[msg.sender] == true) throw;\r\n\r\n        var voterTokens = dasToken.balanceOf(msg.sender);\r\n        blockTokens(msg.sender);\r\n\r\n        p.voted[msg.sender] = true;\r\n        p.votes.push(Vote(msg.sender, _inSupport, voterTokens, _justificationText));\r\n        p.votesNumber += 1;\r\n\r\n        VotedEvent(_proposalID, msg.sender, _inSupport, voterTokens, _justificationText);\r\n    }\r\n\r\n    // finish voting on an proposal\r\n    function finishProposalVoting(uint256 _proposalID) onlyCongressMembers {\r\n        Proposal p = proposals[_proposalID];\r\n\r\n        if (now < p.votingDeadline) throw;\r\n        if (p.state != ProposalState.Proposed) throw;\r\n\r\n        var _votesNumber = p.votes.length;\r\n        uint256 tokensFor = 0;\r\n        uint256 tokensAgainst = 0;\r\n        for (uint256 i = 0; i < _votesNumber; i++) {\r\n            if (p.votes[i].inSupport) {\r\n                tokensFor += p.votes[i].voterTokens;\r\n            }\r\n            else {\r\n                tokensAgainst += p.votes[i].voterTokens;\r\n            }\r\n\r\n            unblockTokens(p.votes[i].voter);\r\n        }\r\n\r\n        if ((tokensFor + tokensAgainst) < minimumQuorum) {\r\n            p.state = ProposalState.NoQuorum;\r\n            ProposalTalliedEvent(_proposalID, false, false);\r\n            return;\r\n        }\r\n        if ((tokensFor - tokensAgainst) < marginForMajority) {\r\n            p.state = ProposalState.Rejected;\r\n            ProposalTalliedEvent(_proposalID, true, false);\r\n            return;\r\n        }\r\n        p.state = ProposalState.Passed;\r\n        ProposalTalliedEvent(_proposalID, true, true);\r\n        return;\r\n    }\r\n\r\n    // execute passed proposal\r\n    function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {\r\n        Proposal p = proposals[_proposalID];\r\n\r\n        if (p.state != ProposalState.Passed) throw;\r\n\r\n        p.state = ProposalState.Executed;\r\n        if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) {\r\n            throw;\r\n        }\r\n\r\n        ProposalExecutedEvent(_proposalID);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"etherAmount\",\"type\":\"uint256\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"proposalHash\",\"type\":\"bytes32\"},{\"name\":\"state\",\"type\":\"uint8\"},{\"name\":\"votingDeadline\",\"type\":\"uint256\"},{\"name\":\"votesNumber\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"},{\"name\":\"_transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"executeProposal\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"debatingPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_etherAmount\",\"type\":\"uint256\"},{\"name\":\"_description\",\"type\":\"string\"},{\"name\":\"_transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"createProposal\",\"outputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dasToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marginForMajority\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumQuorum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"erc223Fallback\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"}],\"name\":\"finishProposalVoting\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"congressMemberThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"},{\"name\":\"_inSupport\",\"type\":\"bool\"},{\"name\":\"_justificationText\",\"type\":\"string\"}],\"name\":\"vote\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"abcToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_etherAmount\",\"type\":\"uint256\"},{\"name\":\"_transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"getProposalHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_congressMemberThreshold\",\"type\":\"uint256\"},{\"name\":\"_minimumQuorum\",\"type\":\"uint256\"},{\"name\":\"_debatingPeriod\",\"type\":\"uint256\"},{\"name\":\"_marginForMajority\",\"type\":\"uint256\"},{\"name\":\"_congressLeader\",\"type\":\"address\"}],\"payable\":true,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"}],\"name\":\"ProposalAddedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"inSupport\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"voterTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"justificationText\",\"type\":\"string\"}],\"name\":\"VotedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"quorum\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"bool\"}],\"name\":\"ProposalTalliedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalID\",\"type\":\"uint256\"}],\"name\":\"ProposalExecutedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"congressMemberThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"minimumQuorum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"debatingPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"marginForMajority\",\"type\":\"uint256\"}],\"name\":\"RulesChangedEvent\",\"type\":\"event\"}]","ContractName":"DAS","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000d3c21bcecceda100000000000000000000000000000000000000000000000052b7d2dcc80cd2e40000000000000000000000000000000000000000000000000000000000000000002710000000000000000000000000000000000000000000084595161401484a0000000000000000000000000000008e090955f93376bdd758464f80920f8567d0152a","Library":"","SwarmSource":"bzzr://f011aca274c3c3140a8ab2970ab5a9affb1009a97c47957e25acc176a5706b81"}]}