{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Early prototype of the Edgeless Black Jack contract. \r\n * Allows an user to initialize a round of black jack, withdraw the win in case he won or both on the same time,\r\n * while verifying the game data.\r\n * author: Julia Altenried\r\n **/\r\npragma solidity ^0.4.10;\r\n\r\ncontract owned {\r\n  address public owner; \r\n  modifier onlyOwner {\r\n      if (msg.sender != owner)\r\n          throw;\r\n      _;\r\n  }\r\n  function owned() { owner = msg.sender; }\r\n  function changeOwner(address newOwner) onlyOwner{\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\ncontract mortal is owned{\r\n  function close() onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n}\r\ncontract blackjack is mortal {\r\n  struct Game {\r\n    /** the game id is used to reference the game **/\r\n    uint id;\r\n    /** the hash of the (partial) deck **/\r\n    bytes32 deck;\r\n    /** the hash of the casino seed used for randomness generation and deck-hashing**/\r\n    bytes32 seed;\r\n    /** the player address **/\r\n    address player;\r\n    /** the bet **/\r\n    uint bet;\r\n    /** the timestamp of the start of the game, game ends automatically after certain time interval passed **/\r\n    uint start;\r\n  }\r\n\r\n  /** the value of the cards: Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K . Ace can be 1 or 11, of course. \r\n   *   the value of a card can be determined by looking up cardValues[cardId%13]**/\r\n  uint8[13] cardValues = [11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10];\r\n\r\n  /** use the game id to reference the games **/\r\n  mapping(uint => Game) games;\r\n  /** the minimum bet**/\r\n  uint public minimumBet;\r\n  /** the maximum bet **/\r\n  uint public maximumBet;\r\n  /** the address which signs the number of cards dealt **/\r\n  address public signer;\r\n  \r\n  /** notify listeners that a new round of blackjack started **/\r\n  event NewGame(uint indexed id, bytes32 deck, bytes32 srvSeed, bytes32 cSeed, address player, uint bet);\r\n  /** notify listeners of the game outcome **/\r\n  event Result(uint indexed id, address player, uint win);\r\n  /** notify listeners that an error occurred**/\r\n  event Error(uint errorCode);\r\n\r\n  /** constructur. initialize the contract with a minimum bet and a signer address. **/\r\n  function blackjack(uint minBet, uint maxBet, address signerAddress) payable{\r\n    minimumBet = minBet;\r\n    maximumBet = maxBet;\r\n    signer = signerAddress;\r\n  }\r\n\r\n  /** \r\n   *   initializes a round of blackjack with an id, the hash of the (partial) deck and the hash of the server seed. \r\n   *   accepts the bet.\r\n   *   throws an exception if the bet is too low or a game with the given id already exists.\r\n   **/\r\n  function initGame(uint id, bytes32 deck, bytes32 srvSeed, bytes32 cSeed) payable {\r\n    //throw if bet is too low or too high\r\n    if (msg.value < minimumBet || msg.value > maximumBet) throw;\r\n    //throw if user could not be paiud out in case of suited blackjack\r\n    if (msg.value * 3 > address(this).balance) throw;\r\n    _initGame(id, deck, srvSeed, cSeed, msg.value);\r\n  }\r\n\r\n  /** \r\n   * first checks if deck and the player's number of cards are correct, then checks if the player won and if so, sends the win.\r\n   **/\r\n  function stand(uint gameId, uint8[] deck, bytes32 seed, uint8 numCards, uint8 v, bytes32 r, bytes32 s) {\r\n    uint win = _stand(gameId,deck,seed,numCards,v,r,s, true);\r\n  }\r\n  \r\n  /**\r\n  *   first stands, then inits a new game with only one transaction\r\n  **/\r\n  function standAndRebet(uint oldGameId, uint8[] oldDeck, bytes32 oldSeed, uint8 numCards, uint8 v, bytes32 r, bytes32 s, uint newGameId, bytes32 newDeck, bytes32 newSrvSeed, bytes32 newCSeed){\r\n    uint win = _stand(oldGameId,oldDeck,oldSeed,numCards,v,r,s, false);\r\n    uint bet = games[oldGameId].bet;\r\n    if(win >= bet){\r\n      _initGame(newGameId, newDeck, newSrvSeed, newCSeed, bet);\r\n      win-=bet;\r\n    }\r\n    if(win>0 && !msg.sender.send(win)){//pay the rest\r\n      throw;\r\n    }\r\n  }\r\n  \r\n  /** \r\n   *   internal function to initialize a round of blackjack with an id, the hash of the (partial) deck, \r\n   *   the hash of the server seed and the bet. \r\n   **/\r\n  function _initGame(uint id, bytes32 deck, bytes32 srvSeed, bytes32 cSeed, uint bet) internal{\r\n    //throw if game with id already exists. later maybe throw only if game with id is still running\r\n    if (games[id].player != 0x0) throw;\r\n    games[id] = Game(id, deck, srvSeed, msg.sender, bet, now);\r\n    NewGame(id, deck, srvSeed, cSeed, msg.sender, bet);\r\n  }\r\n  \r\n  /**\r\n  * first checks if deck and the player's number of cards are correct, then checks if the player won and if so, calculates the win.\r\n  **/\r\n  function _stand(uint gameId, uint8[] deck, bytes32 seed, uint8 numCards, uint8 v, bytes32 r, bytes32 s, bool payout) internal returns(uint win){\r\n    Game game = games[gameId];\r\n    uint start = game.start;\r\n    game.start = 0; //make sure outcome isn't determined a second time while win payment is still pending -> prevent double payout\r\n    if(msg.sender!=game.player){\r\n      Error(1);\r\n      return 0;\r\n    }\r\n    if(!checkDeck(gameId, deck, seed)){\r\n      Error(2);\r\n      return 0;\r\n    }\r\n    if(!checkNumCards(gameId, numCards, v, r, s)){\r\n      Error(3);\r\n      return 0;\r\n    }\r\n    if(start + 1 hours < now){\r\n      Error(4);\r\n      return 0;\r\n    }\r\n    \r\n    win = determineOutcome(gameId, deck, numCards);\r\n    if (payout && win > 0 && !msg.sender.send(win)){\r\n      Error(5);\r\n      game.start = start;\r\n      return 0;\r\n    }\r\n    Result(gameId, msg.sender, win);\r\n  }\r\n  \r\n  /**\r\n  * check if deck and casino seed are correct.\r\n  **/\r\n  function checkDeck(uint gameId, uint8[] deck, bytes32 seed) constant returns (bool correct){\r\n    if(sha3(seed) != games[gameId].seed) return false;\r\n    if(sha3(convertToBytes(deck), seed) != games[gameId].deck) return false;\r\n    return true;\r\n  }\r\n  \r\n  function convertToBytes(uint8[] byteArray) returns (bytes b){\r\n    b = new bytes(byteArray.length);\r\n    for(uint8 i = 0; i < byteArray.length; i++)\r\n      b[i] = byte(byteArray[i]);\r\n  }\r\n  \r\n  /**\r\n  * check if user and casino agree on the number of cards\r\n  **/\r\n  function checkNumCards(uint gameId, uint8 numCards, uint8 v, bytes32 r, bytes32 s) constant returns (bool correct){\r\n    bytes32 msgHash = sha3(gameId,numCards);\r\n    return ecrecover(msgHash, v, r, s) == signer;\r\n  }\r\n\r\n  /**\r\n   * determines the outcome of a game and returns the win. \r\n   * in case of a loss, win is 0.\r\n   **/\r\n  function determineOutcome(uint gameId, uint8[] cards, uint8 numCards) constant returns(uint win) {\r\n    uint8 playerValue = getPlayerValue(cards, numCards);\r\n    //bust if value > 21\r\n    if (playerValue > 21) return 0;\r\n\r\n    var (dealerValue, dealerBJ) = getDealerValue(cards, numCards);\r\n\r\n    //player wins\r\n    if (playerValue == 21 && numCards == 2 && !dealerBJ){ //player blackjack but no dealer blackjack\r\n      if(isSuited(cards[0], cards[2]))\r\n        return games[gameId].bet * 3; //pay 2 to 1\r\n      else\r\n        return games[gameId].bet * 5 / 2; \r\n    }\r\n    else if(playerValue == 21 && numCards == 5) //automatic win on 5-card 21\r\n      return games[gameId].bet * 2;\r\n    else if (playerValue > dealerValue || dealerValue > 21)\r\n      return games[gameId].bet * 2;\r\n    //tie\r\n    else if (playerValue == dealerValue)\r\n      return games[gameId].bet;\r\n    //player loses\r\n    else\r\n      return 0;\r\n\r\n  }\r\n\r\n  /**\r\n   *   calculates the value of a player's hand.\r\n   *   cards: holds the (partial) deck.\r\n   *   numCards: the number of cards the player holds\r\n   **/\r\n  function getPlayerValue(uint8[] cards, uint8 numCards) constant internal returns(uint8 playerValue) {\r\n    //player receives first and third card and  all further cards after the 4. until he stands \r\n    //determine value of the player's hand\r\n    uint8 numAces;\r\n    uint8 card;\r\n    for (uint8 i = 0; i < numCards + 2; i++) {\r\n      if (i != 1 && i != 3) { //1 and 3 are dealer cards\r\n        card = cards[i] %13;\r\n        playerValue += cardValues[card];\r\n        if (card == 0) numAces++;\r\n      }\r\n\r\n    }\r\n    while (numAces > 0 && playerValue > 21) {\r\n      playerValue -= 10;\r\n      numAces--;\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   *   calculates the value of a dealer's hand.\r\n   *   cards: holds the (partial) deck.\r\n   *   numCards: the number of cards the player holds\r\n   **/\r\n  function getDealerValue(uint8[] cards, uint8 numCards) constant internal returns(uint8 dealerValue, bool bj) {\r\n    \r\n    //dealer always receives second and forth card\r\n    uint8 card  = cards[1] % 13;\r\n    uint8 card2 = cards[3] % 13;\r\n    dealerValue = cardValues[card] + cardValues[card2];\r\n    uint8 numAces;\r\n    if (card == 0) numAces++;\r\n    if (card2 == 0) numAces++;\r\n    if (dealerValue > 21) { //2 aces,count as 12\r\n      dealerValue -= 10;\r\n      numAces--;\r\n    }\r\n    else if(dealerValue==21){\r\n      return (21, true);\r\n    }\r\n    //take cards until value reaches 17 or more. \r\n    uint8 i;\r\n    while (dealerValue < 17) {\r\n      card = cards[numCards + i + 2] % 13 ;\r\n      dealerValue += cardValues[card];\r\n      if (card == 0) numAces++;\r\n      if (dealerValue > 21 && numAces > 0) {\r\n        dealerValue -= 10;\r\n        numAces--;\r\n      }\r\n      i++;\r\n    }\r\n  }\r\n  \r\n  /** determines if two cards have the same color **/\r\n  function isSuited(uint8 card1, uint8 card2) internal returns(bool){\r\n    return card1/13 == card2/13;\r\n  }\r\n  \r\n  /** the fallback function can be used to send ether to increase the casino bankroll **/\r\n  function() payable onlyOwner{\r\n  }\r\n  \r\n  /** allows the owner to withdraw funds **/\r\n  function withdraw(uint amount) onlyOwner{\r\n    if(amount < address(this).balance)\r\n      if(!owner.send(amount))\r\n        Error(6);\r\n  }\r\n  \r\n  /** allows the owner to change the signer address **/\r\n  function setSigner(address signerAddress) onlyOwner{\r\n    signer = signerAddress;\r\n  }\r\n  \r\n  /** allows the owner to change the minimum bet **/\r\n  function setMinimumBet(uint newMin) onlyOwner{\r\n    minimumBet = newMin;\r\n  }\r\n  \r\n  /** allows the owner to change the mximum **/\r\n  function setMaximumBet(uint newMax) onlyOwner{\r\n    minimumBet = newMax;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"},{\"name\":\"deck\",\"type\":\"uint8[]\"},{\"name\":\"seed\",\"type\":\"bytes32\"},{\"name\":\"numCards\",\"type\":\"uint8\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"stand\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"deck\",\"type\":\"bytes32\"},{\"name\":\"srvSeed\",\"type\":\"bytes32\"},{\"name\":\"cSeed\",\"type\":\"bytes32\"}],\"name\":\"initGame\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMax\",\"type\":\"uint256\"}],\"name\":\"setMaximumBet\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"byteArray\",\"type\":\"uint8[]\"}],\"name\":\"convertToBytes\",\"outputs\":[{\"name\":\"b\",\"type\":\"bytes\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"oldGameId\",\"type\":\"uint256\"},{\"name\":\"oldDeck\",\"type\":\"uint8[]\"},{\"name\":\"oldSeed\",\"type\":\"bytes32\"},{\"name\":\"numCards\",\"type\":\"uint8\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"newGameId\",\"type\":\"uint256\"},{\"name\":\"newDeck\",\"type\":\"bytes32\"},{\"name\":\"newSrvSeed\",\"type\":\"bytes32\"},{\"name\":\"newCSeed\",\"type\":\"bytes32\"}],\"name\":\"standAndRebet\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"signerAddress\",\"type\":\"address\"}],\"name\":\"setSigner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMin\",\"type\":\"uint256\"}],\"name\":\"setMinimumBet\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"},{\"name\":\"cards\",\"type\":\"uint8[]\"},{\"name\":\"numCards\",\"type\":\"uint8\"}],\"name\":\"determineOutcome\",\"outputs\":[{\"name\":\"win\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"},{\"name\":\"numCards\",\"type\":\"uint8\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"checkNumCards\",\"outputs\":[{\"name\":\"correct\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"},{\"name\":\"deck\",\"type\":\"uint8[]\"},{\"name\":\"seed\",\"type\":\"bytes32\"}],\"name\":\"checkDeck\",\"outputs\":[{\"name\":\"correct\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"minBet\",\"type\":\"uint256\"},{\"name\":\"maxBet\",\"type\":\"uint256\"},{\"name\":\"signerAddress\",\"type\":\"address\"}],\"payable\":true,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"deck\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"srvSeed\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"cSeed\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bet\",\"type\":\"uint256\"}],\"name\":\"NewGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"win\",\"type\":\"uint256\"}],\"name\":\"Result\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"Error\",\"type\":\"event\"}]","ContractName":"blackjack","CompilerVersion":"v0.4.10+commit.f0d539ae","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000005af3107a4000000000000000000000000000000000000000000000000000002386f26fc10000000000000000000000000000655f6b94c85872383e669d976991bebba2066ecf","Library":"","SwarmSource":"bzzr://cac2632f28f82ceb5df1285bdf6adaaec264400abb90ffe53371898a2f8576bb"}]}