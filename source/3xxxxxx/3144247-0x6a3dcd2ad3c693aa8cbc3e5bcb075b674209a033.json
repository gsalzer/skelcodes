{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\n/*\r\nThis file is part of Pass DAO.\r\n\r\nPass DAO is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nPass DAO is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU lesser General Public License\r\nalong with Pass DAO.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n/*\r\nSmart contract for a Decentralized Autonomous Organization (DAO)\r\nto automate organizational governance and decision-making.\r\n*/\r\n\r\n/// @title Pass Dao smart contract\r\ncontract PassDao {\r\n    \r\n    struct revision {\r\n        // Address of the Committee Room smart contract\r\n        address committeeRoom;\r\n        // Address of the share manager smart contract\r\n        address shareManager;\r\n        // Address of the token manager smart contract\r\n        address tokenManager;\r\n        // Address of the project creator smart contract\r\n        uint startDate;\r\n    }\r\n    // The revisions of the application until today\r\n    revision[] public revisions;\r\n\r\n    struct project {\r\n        // The address of the smart contract\r\n        address contractAddress;\r\n        // The unix effective start date of the contract\r\n        uint startDate;\r\n    }\r\n    // The projects of the Dao\r\n    project[] public projects;\r\n\r\n    // Map with the indexes of the projects\r\n    mapping (address => uint) projectID;\r\n    \r\n    // The address of the meta project\r\n    address metaProject;\r\n\r\n    \r\n// Events\r\n\r\n    event Upgrade(uint indexed RevisionID, address CommitteeRoom, address ShareManager, address TokenManager);\r\n    event NewProject(address Project);\r\n\r\n// Constant functions  \r\n    \r\n    /// @return The effective committee room\r\n    function ActualCommitteeRoom() constant returns (address) {\r\n        return revisions[0].committeeRoom;\r\n    }\r\n    \r\n    /// @return The meta project\r\n    function MetaProject() constant returns (address) {\r\n        return metaProject;\r\n    }\r\n\r\n    /// @return The effective share manager\r\n    function ActualShareManager() constant returns (address) {\r\n        return revisions[0].shareManager;\r\n    }\r\n\r\n    /// @return The effective token manager\r\n    function ActualTokenManager() constant returns (address) {\r\n        return revisions[0].tokenManager;\r\n    }\r\n\r\n// modifiers\r\n\r\n    modifier onlyPassCommitteeRoom {if (msg.sender != revisions[0].committeeRoom  \r\n        && revisions[0].committeeRoom != 0) throw; _;}\r\n    \r\n// Constructor function\r\n\r\n    function PassDao() {\r\n        projects.length = 1;\r\n        revisions.length = 1;\r\n    }\r\n    \r\n// Register functions\r\n\r\n    /// @dev Function to allow the actual Committee Room upgrading the application\r\n    /// @param _newCommitteeRoom The address of the new committee room\r\n    /// @param _newShareManager The address of the new share manager\r\n    /// @param _newTokenManager The address of the new token manager\r\n    /// @return The index of the revision\r\n    function upgrade(\r\n        address _newCommitteeRoom, \r\n        address _newShareManager, \r\n        address _newTokenManager) onlyPassCommitteeRoom returns (uint) {\r\n        \r\n        uint _revisionID = revisions.length++;\r\n        revision r = revisions[_revisionID];\r\n\r\n        if (_newCommitteeRoom != 0) r.committeeRoom = _newCommitteeRoom; else r.committeeRoom = revisions[0].committeeRoom;\r\n        if (_newShareManager != 0) r.shareManager = _newShareManager; else r.shareManager = revisions[0].shareManager;\r\n        if (_newTokenManager != 0) r.tokenManager = _newTokenManager; else r.tokenManager = revisions[0].tokenManager;\r\n\r\n        r.startDate = now;\r\n        \r\n        revisions[0] = r;\r\n        \r\n        Upgrade(_revisionID, _newCommitteeRoom, _newShareManager, _newTokenManager);\r\n            \r\n        return _revisionID;\r\n    }\r\n\r\n    /// @dev Function to set the meta project\r\n    /// @param _projectAddress The address of the meta project\r\n    function addMetaProject(address _projectAddress) onlyPassCommitteeRoom {\r\n\r\n        metaProject = _projectAddress;\r\n    }\r\n    \r\n    /// @dev Function to allow the committee room to add a project when ordering\r\n    /// @param _projectAddress The address of the project\r\n    function addProject(address _projectAddress) onlyPassCommitteeRoom {\r\n\r\n        if (projectID[_projectAddress] == 0) {\r\n\r\n            uint _projectID = projects.length++;\r\n            project p = projects[_projectID];\r\n        \r\n            projectID[_projectAddress] = _projectID;\r\n            p.contractAddress = _projectAddress; \r\n            p.startDate = now;\r\n            \r\n            NewProject(_projectAddress);\r\n        }\r\n    }\r\n    \r\n}\r\n\r\npragma solidity ^0.4.8;\r\n\r\n/*\r\n *\r\n * This file is part of Pass DAO.\r\n *\r\n * The Manager smart contract is used for the management of shares and tokens.\r\n *\r\n*/\r\n\r\n/// @title Token Manager smart contract of the Pass Decentralized Autonomous Organisation\r\ncontract PassTokenManagerInterface {\r\n\r\n    // The Pass Dao smart contract\r\n    PassDao public passDao;\r\n    // The adress of the creator of this smart contract\r\n    address creator;\r\n    \r\n    // The token name for display purpose\r\n    string public name;\r\n    // The token symbol for display purpose\r\n    string public symbol;\r\n    // The quantity of decimals for display purpose\r\n    uint8 public decimals;\r\n    // Total amount of tokens\r\n    uint256 totalTokenSupply;\r\n\r\n    // True if tokens, false if Dao shares\r\n    bool token;\r\n    // If true, the shares or tokens can be transferred\r\n    bool transferable;\r\n\r\n    // The address of the last Manager before cloning\r\n    address public clonedFrom;\r\n    // True if the initial token supply is over\r\n    bool initialTokenSupplyDone;\r\n\r\n    // Array of token or share holders (used for cloning)\r\n    address[] holders;\r\n    // Map with the indexes of the holders (used for cloning)\r\n    mapping (address => uint) holderID;\r\n    \r\n    // Array with all balances\r\n    mapping (address => uint256) balances;\r\n    // Array with all allowances\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    struct funding {\r\n        // The address which sets partners and manages the funding (not mandatory)\r\n        address moderator;\r\n        // The amount (in wei) of the funding\r\n        uint amountToFund;\r\n        // The funded amount (in wei)\r\n        uint fundedAmount;\r\n        // A unix timestamp, denoting the start time of the funding\r\n        uint startTime; \r\n        // A unix timestamp, denoting the closing time of the funding\r\n        uint closingTime;  \r\n        // The price multiplier for a share or a token without considering the inflation rate\r\n        uint initialPriceMultiplier;\r\n        // Rate per year in percentage applied to the share or token price \r\n        uint inflationRate; \r\n        // The total amount of wei given\r\n        uint totalWeiGiven;\r\n    } \r\n    // Map with the fundings rules for each Dao proposal\r\n    mapping (uint => funding) public fundings;\r\n\r\n    // The index of the last funding and proposal\r\n    uint lastProposalID;\r\n    // The index of the last fueled funding and proposal\r\n    uint public lastFueledFundingID;\r\n    \r\n    struct amountsGiven {\r\n        uint weiAmount;\r\n        uint tokenAmount;\r\n    }\r\n    // Map with the amounts given for each proposal \r\n    mapping (uint => mapping (address => amountsGiven)) public Given;\r\n    \r\n    // Map of blocked Dao share accounts. Points to the date when the share holder can transfer shares\r\n    mapping (address => uint) public blockedDeadLine; \r\n\r\n    // @return The client of this manager\r\n    function Client() constant returns (address);\r\n    \r\n    /// @return The total supply of shares or tokens \r\n    function totalSupply() constant external returns (uint256);\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n     function balanceOf(address _owner) constant external returns (uint256 balance);\r\n\r\n    /// @return True if tokens can be transferred\r\n    function Transferable() constant external returns (bool);\r\n    \r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Quantity of remaining tokens of _owner that _spender is allowed to spend\r\n    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\r\n    \r\n    /// @param _proposalID Index of the funding or proposal\r\n    /// @return The result (in wei) of the funding\r\n    function FundedAmount(uint _proposalID) constant external returns (uint);\r\n\r\n    /// @param _proposalID Index of the funding or proposal\r\n    /// @return The amount to fund\r\n    function AmountToFund(uint _proposalID) constant external returns (uint);\r\n    \r\n    /// @param _proposalID Index of the funding or proposal\r\n    /// @return the token price multiplier\r\n    function priceMultiplier(uint _proposalID) constant internal returns (uint);\r\n    \r\n    /// @param _proposalID Index of the funding or proposal\r\n    /// @param _saleDate in case of presale, the date of the presale\r\n    /// @return the share or token price divisor condidering the sale date and the inflation rate\r\n    function priceDivisor(\r\n        uint _proposalID, \r\n        uint _saleDate) constant internal returns (uint);\r\n    \r\n    /// @param _proposalID Index of the funding or proposal\r\n    /// @return the actual price divisor of a share or token\r\n    function actualPriceDivisor(uint _proposalID) constant internal returns (uint);\r\n\r\n    /// @dev Internal function to calculate the amount in tokens according to a price    \r\n    /// @param _weiAmount The amount (in wei)\r\n    /// @param _priceMultiplier The price multiplier\r\n    /// @param _priceDivisor The price divisor\r\n    /// @return the amount in tokens \r\n    function TokenAmount(\r\n        uint _weiAmount,\r\n        uint _priceMultiplier, \r\n        uint _priceDivisor) constant internal returns (uint);\r\n\r\n    /// @dev Internal function to calculate the amount in wei according to a price    \r\n    /// @param _tokenAmount The amount (in wei)\r\n    /// @param _priceMultiplier The price multiplier\r\n    /// @param _priceDivisor The price divisor\r\n    /// @return the amount in wei\r\n    function weiAmount(\r\n        uint _tokenAmount, \r\n        uint _priceMultiplier, \r\n        uint _priceDivisor) constant internal returns (uint);\r\n        \r\n    /// @param _tokenAmount The amount in tokens\r\n    /// @param _proposalID Index of the client proposal. 0 if not linked to a proposal.\r\n    /// @return the actual token price in wei\r\n    function TokenPriceInWei(uint _tokenAmount, uint _proposalID) constant returns (uint);\r\n    \r\n    /// @return The index of the last funding and client's proposal \r\n    function LastProposalID() constant returns (uint);\r\n\r\n    /// @return The number of share or token holders (used for cloning)\r\n    function numberOfHolders() constant returns (uint);\r\n\r\n    /// @param _index The index of the holder\r\n    /// @return the address of the holder\r\n    function HolderAddress(uint _index) constant external returns (address);\r\n   \r\n    /// @dev The constructor function\r\n    /// @param _passDao Address of the pass Dao smart contract\r\n    /// @param _clonedFrom The address of the last Manager before cloning\r\n    /// @param _tokenName The token name for display purpose\r\n    /// @param _tokenSymbol The token symbol for display purpose\r\n    /// @param _tokenDecimals The quantity of decimals for display purpose\r\n    /// @param  _token True if tokens, false if shares\r\n    /// @param  _transferable True if tokens can be transferred\r\n    /// @param _initialPriceMultiplier Price multiplier without considering any inflation rate\r\n    /// @param _inflationRate If 0, the token price doesn't change during the funding\r\n    //function PassTokenManager(\r\n    //    address _passDao,\r\n    //    address _clonedFrom,\r\n    //    string _tokenName,\r\n    //    string _tokenSymbol,\r\n    //    uint8 _tokenDecimals,\r\n    //    bool _token,\r\n    //    bool _transferable,\r\n    //    uint _initialPriceMultiplier,\r\n    //    uint _inflationRate);\r\n    \r\n    /// @dev Function to create initial tokens    \r\n    /// @param _recipient The beneficiary of the created tokens\r\n    /// @param _quantity The quantity of tokens to create    \r\n    /// @param _last True if the initial token suppy is over\r\n    /// @return Whether the function was successful or not     \r\n    function initialTokenSupply(\r\n        address _recipient, \r\n        uint _quantity,\r\n        bool _last) returns (bool success);\r\n        \r\n    /// @notice Function to clone tokens before upgrading\r\n    /// @param _from The index of the first holder\r\n    /// @param _to The index of the last holder\r\n    /// @return Whether the function was successful or not \r\n    function cloneTokens(\r\n        uint _from,\r\n        uint _to) returns (bool success);\r\n\r\n    /// @dev Internal function to add a new token or share holder\r\n    /// @param _holder The address of the token or share holder\r\n    function addHolder(address _holder) internal;\r\n    \r\n    /// @dev Internal function to create initial tokens    \r\n    /// @param _holder The beneficiary of the created tokens\r\n    /// @param _tokenAmount The amount in tokens to create\r\n    function createTokens(\r\n        address _holder, \r\n        uint _tokenAmount) internal;\r\n        \r\n    /// @notice Function used by the client to pay with shares or tokens\r\n    /// @param _recipient The address of the recipient of shares or tokens\r\n    /// @param _amount The amount (in Wei) to calculate the quantity of shares or tokens to create\r\n    /// @return the rewarded amount in tokens or shares\r\n    function rewardTokensForClient(\r\n        address _recipient, \r\n        uint _amount) external  returns (uint);\r\n        \r\n    /// @notice Function to set a funding\r\n    /// @param _moderator The address of the smart contract to manage a private funding\r\n    /// @param _initialPriceMultiplier Price multiplier without considering any inflation rate\r\n    /// @param _amountToFund The amount (in wei) of the funding\r\n    /// @param _minutesFundingPeriod Period in minutes of the funding\r\n    /// @param _inflationRate If 0, the token price doesn't change during the funding\r\n    /// @param _proposalID Index of the client proposal\r\n    function setFundingRules(\r\n        address _moderator,\r\n        uint _initialPriceMultiplier,\r\n        uint _amountToFund,\r\n        uint _minutesFundingPeriod, \r\n        uint _inflationRate,\r\n        uint _proposalID) external;\r\n\r\n    /// @dev Internal function for the sale of shares or tokens\r\n    /// @param _proposalID Index of the client proposal\r\n    /// @param _recipient The recipient address of shares or tokens\r\n    /// @param _amount The funded amount (in wei)\r\n    /// @param _saleDate In case of presale, the date of the presale\r\n    /// @param _presale True if presale\r\n    /// @return Whether the creation was successful or not\r\n    function sale(\r\n        uint _proposalID,\r\n        address _recipient, \r\n        uint _amount,\r\n        uint _saleDate,\r\n        bool _presale\r\n    ) internal returns (bool success);\r\n    \r\n    /// @dev Internal function to close the actual funding\r\n    /// @param _proposalID Index of the client proposal\r\n    function closeFunding(uint _proposalID) internal;\r\n   \r\n    /// @notice Function to send tokens or refund after the closing time of the funding proposals\r\n    /// @param _from The first proposal. 0 if not linked to a proposal\r\n    /// @param _to The last proposal\r\n    /// @param _buyer The address of the buyer\r\n    /// @return Whether the function was successful or not \r\n    function sendPendingAmounts(        \r\n        uint _from,\r\n        uint _to,\r\n        address _buyer) returns (bool);\r\n        \r\n    /// @notice Function to get fees, shares or refund after the closing time of the funding proposals\r\n    /// @return Whether the function was successful or not\r\n    function withdrawPendingAmounts() returns (bool);\r\n    \r\n    /// @notice Function used by the main partner to set the start time of the funding\r\n    /// @param _proposalID Index of the client proposal\r\n    /// @param _startTime The unix start date of the funding \r\n    function setFundingStartTime(\r\n        uint _proposalID, \r\n        uint _startTime) external;\r\n    \r\n    /// @notice Function used by the main partner to set the funding fueled\r\n    /// @param _proposalID Index of the client proposal\r\n    function setFundingFueled(uint _proposalID) external;\r\n\r\n    /// @notice Function to able the transfer of Dao shares or contractor tokens\r\n    function ableTransfer();\r\n\r\n    /// @notice Function to disable the transfer of Dao shares\r\n    function disableTransfer();\r\n\r\n    /// @notice Function used by the client to block the transfer of shares from and to a share holder\r\n    /// @param _shareHolder The address of the share holder\r\n    /// @param _deadLine When the account will be unblocked\r\n    function blockTransfer(\r\n        address _shareHolder, \r\n        uint _deadLine) external;\r\n    \r\n    /// @dev Internal function to send `_value` token to `_to` from `_From`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The quantity of shares or tokens to be transferred\r\n    /// @return Whether the function was successful or not \r\n    function transferFromTo(\r\n        address _from,\r\n        address _to, \r\n        uint256 _value\r\n        ) internal returns (bool success);\r\n    \r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The quantity of shares or tokens to be transferred\r\n    /// @return Whether the function was successful or not \r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The quantity of shares or tokens to be transferred\r\n    function transferFrom(\r\n        address _from, \r\n        address _to, \r\n        uint256 _value\r\n        ) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on its behalf\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(\r\n        address _spender, \r\n        uint256 _value) returns (bool success);\r\n    \r\n    event TokensCreated(address indexed Sender, address indexed TokenHolder, uint TokenAmount);\r\n    event FundingRulesSet(address indexed Moderator, uint indexed ProposalId, uint AmountToFund, uint indexed StartTime, uint ClosingTime);\r\n    event FundingFueled(uint indexed ProposalID, uint FundedAmount);\r\n    event TransferAble();\r\n    event TransferDisable();\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Refund(address indexed Buyer, uint Amount);\r\n    \r\n}    \r\n\r\ncontract PassTokenManager is PassTokenManagerInterface {\r\n\r\n// Constant functions\r\n\r\n    function Client() constant returns (address) {\r\n        return passDao.ActualCommitteeRoom();\r\n    }\r\n   \r\n    function totalSupply() constant external returns (uint256) {\r\n        return totalTokenSupply;\r\n    }\r\n    \r\n    function balanceOf(address _owner) constant external returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n     \r\n    function Transferable() constant external returns (bool) {\r\n        return transferable;\r\n    }\r\n \r\n    function allowance(\r\n        address _owner, \r\n        address _spender) constant external returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function FundedAmount(uint _proposalID) constant external returns (uint) {\r\n        return fundings[_proposalID].fundedAmount;\r\n    }\r\n  \r\n    function AmountToFund(uint _proposalID) constant external returns (uint) {\r\n\r\n        if (now > fundings[_proposalID].closingTime\r\n            || now < fundings[_proposalID].startTime) {\r\n            return 0;   \r\n            } else return fundings[_proposalID].amountToFund;\r\n    }\r\n    \r\n    function priceMultiplier(uint _proposalID) constant internal returns (uint) {\r\n        return fundings[_proposalID].initialPriceMultiplier;\r\n    }\r\n    \r\n    function priceDivisor(uint _proposalID, uint _saleDate) constant internal returns (uint) {\r\n        uint _date = _saleDate;\r\n        \r\n        if (_saleDate > fundings[_proposalID].closingTime) _date = fundings[_proposalID].closingTime;\r\n        if (_saleDate < fundings[_proposalID].startTime) _date = fundings[_proposalID].startTime;\r\n\r\n        return 100 + 100*fundings[_proposalID].inflationRate*(_date - fundings[_proposalID].startTime)/(100*365 days);\r\n    }\r\n    \r\n    function actualPriceDivisor(uint _proposalID) constant internal returns (uint) {\r\n        return priceDivisor(_proposalID, now);\r\n    }\r\n    \r\n    function TokenAmount(\r\n        uint _weiAmount, \r\n        uint _priceMultiplier, \r\n        uint _priceDivisor) constant internal returns (uint) {\r\n        \r\n        uint _a = _weiAmount*_priceMultiplier;\r\n        uint _multiplier = 100*_a;\r\n        uint _amount = _multiplier/_priceDivisor;\r\n        if (_a/_weiAmount != _priceMultiplier\r\n            || _multiplier/100 != _a) return 0; \r\n        \r\n        return _amount;\r\n    }\r\n    \r\n    function weiAmount(\r\n        uint _tokenAmount, \r\n        uint _priceMultiplier, \r\n        uint _priceDivisor) constant internal returns (uint) {\r\n        \r\n        uint _multiplier = _tokenAmount*_priceDivisor;\r\n        uint _divisor = 100*_priceMultiplier;\r\n        uint _amount = _multiplier/_divisor;\r\n        if (_multiplier/_tokenAmount != _priceDivisor\r\n            || _divisor/100 != _priceMultiplier) return 0; \r\n\r\n        return _amount;\r\n    }\r\n    \r\n    function TokenPriceInWei(uint _tokenAmount, uint _proposalID) constant returns (uint) {\r\n        return weiAmount(_tokenAmount, priceMultiplier(_proposalID), actualPriceDivisor(_proposalID));\r\n    }\r\n    \r\n    function LastProposalID() constant returns (uint) {\r\n        return lastProposalID;\r\n    }\r\n    \r\n    function numberOfHolders() constant returns (uint) {\r\n        return holders.length - 1;\r\n    }\r\n    \r\n    function HolderAddress(uint _index) constant external returns (address) {\r\n        return holders[_index];\r\n    }\r\n\r\n// Modifiers\r\n\r\n    // Modifier that allows only the client ..\r\n    modifier onlyClient {if (msg.sender != Client()) throw; _;}\r\n      \r\n    // Modifier for share Manager functions\r\n    modifier onlyShareManager {if (token) throw; _;}\r\n\r\n    // Modifier for token Manager functions\r\n    modifier onlyTokenManager {if (!token) throw; _;}\r\n  \r\n// Constructor function\r\n\r\n    function PassTokenManager(\r\n        PassDao _passDao,\r\n        address _clonedFrom,\r\n        string _tokenName,\r\n        string _tokenSymbol,\r\n        uint8 _tokenDecimals,\r\n        bool _token,\r\n        bool _transferable,\r\n        uint _initialPriceMultiplier,\r\n        uint _inflationRate) {\r\n\r\n        passDao = _passDao;\r\n        creator = msg.sender;\r\n        \r\n        clonedFrom = _clonedFrom;            \r\n\r\n        name = _tokenName;\r\n        symbol = _tokenSymbol;\r\n        decimals = _tokenDecimals;\r\n\r\n        token = _token;\r\n        transferable = _transferable;\r\n\r\n        fundings[0].initialPriceMultiplier = _initialPriceMultiplier;\r\n        fundings[0].inflationRate = _inflationRate;\r\n\r\n        holders.length = 1;\r\n    }\r\n\r\n// Setting functions\r\n\r\n    function initialTokenSupply(\r\n        address _recipient, \r\n        uint _quantity,\r\n        bool _last) returns (bool success) {\r\n\r\n        if (initialTokenSupplyDone) throw;\r\n        \r\n        addHolder(_recipient);\r\n        if (_recipient != 0 && _quantity != 0) createTokens(_recipient, _quantity);\r\n        \r\n        if (_last) initialTokenSupplyDone = true;\r\n        \r\n        return true;\r\n    }\r\n\r\n    function cloneTokens(\r\n        uint _from,\r\n        uint _to) returns (bool success) {\r\n        \r\n        initialTokenSupplyDone = true;\r\n        if (_from == 0) _from = 1;\r\n        \r\n        PassTokenManager _clonedFrom = PassTokenManager(clonedFrom);\r\n        uint _numberOfHolders = _clonedFrom.numberOfHolders();\r\n        if (_to == 0 || _to > _numberOfHolders) _to = _numberOfHolders;\r\n        \r\n        address _holder;\r\n        uint _balance;\r\n\r\n        for (uint i = _from; i <= _to; i++) {\r\n            _holder = _clonedFrom.HolderAddress(i);\r\n            _balance = _clonedFrom.balanceOf(_holder);\r\n            if (balances[_holder] == 0 && _balance != 0) {\r\n                addHolder(_holder);\r\n                createTokens(_holder, _balance);\r\n            }\r\n        }\r\n    }\r\n        \r\n// Token creation\r\n\r\n    function addHolder(address _holder) internal {\r\n        \r\n        if (holderID[_holder] == 0) {\r\n            \r\n            uint _holderID = holders.length++;\r\n            holders[_holderID] = _holder;\r\n            holderID[_holder] = _holderID;\r\n        }\r\n    }\r\n\r\n    function createTokens(\r\n        address _holder, \r\n        uint _tokenAmount) internal {\r\n\r\n        balances[_holder] += _tokenAmount; \r\n        totalTokenSupply += _tokenAmount;\r\n        TokensCreated(msg.sender, _holder, _tokenAmount);\r\n    }\r\n    \r\n    function rewardTokensForClient(\r\n        address _recipient, \r\n        uint _amount\r\n        ) external onlyClient returns (uint) {\r\n\r\n        uint _tokenAmount = TokenAmount(_amount, priceMultiplier(0), actualPriceDivisor(0));\r\n        if (_tokenAmount == 0) throw;\r\n\r\n        addHolder(_recipient);\r\n        createTokens(_recipient, _tokenAmount);\r\n\r\n        return _tokenAmount;\r\n    }\r\n    \r\n    function setFundingRules(\r\n        address _moderator,\r\n        uint _initialPriceMultiplier,\r\n        uint _amountToFund,\r\n        uint _minutesFundingPeriod, \r\n        uint _inflationRate,\r\n        uint _proposalID\r\n    ) external onlyClient {\r\n\r\n        if (_moderator == address(this)\r\n            || _moderator == Client()\r\n            || _amountToFund == 0\r\n            || _minutesFundingPeriod == 0\r\n            || fundings[_proposalID].totalWeiGiven != 0\r\n            ) throw;\r\n            \r\n        fundings[_proposalID].moderator = _moderator;\r\n\r\n        fundings[_proposalID].amountToFund = _amountToFund;\r\n        fundings[_proposalID].fundedAmount = 0;\r\n\r\n        if (_initialPriceMultiplier == 0) {\r\n            if (now < fundings[0].closingTime) {\r\n                fundings[_proposalID].initialPriceMultiplier = 100*priceMultiplier(lastProposalID)/actualPriceDivisor(lastProposalID);\r\n            } else {\r\n                fundings[_proposalID].initialPriceMultiplier = 100*priceMultiplier(lastFueledFundingID)/actualPriceDivisor(lastFueledFundingID);\r\n            }\r\n            fundings[0].initialPriceMultiplier = fundings[_proposalID].initialPriceMultiplier;\r\n        }\r\n        else {\r\n            fundings[_proposalID].initialPriceMultiplier = _initialPriceMultiplier;\r\n            fundings[0].initialPriceMultiplier = _initialPriceMultiplier;\r\n        }\r\n        \r\n        if (_inflationRate == 0) fundings[_proposalID].inflationRate = fundings[0].inflationRate;\r\n        else {\r\n            fundings[_proposalID].inflationRate = _inflationRate;\r\n            fundings[0].inflationRate = _inflationRate;\r\n        }\r\n        \r\n        fundings[_proposalID].startTime = now;\r\n        fundings[0].startTime = now;\r\n        \r\n        fundings[_proposalID].closingTime = now + _minutesFundingPeriod * 1 minutes;\r\n        fundings[0].closingTime = fundings[_proposalID].closingTime;\r\n        \r\n        fundings[_proposalID].totalWeiGiven = 0;\r\n        \r\n        lastProposalID = _proposalID;\r\n        \r\n        FundingRulesSet(_moderator, _proposalID,  _amountToFund, fundings[_proposalID].startTime, fundings[_proposalID].closingTime);\r\n    } \r\n    \r\n    function sale(\r\n        uint _proposalID,\r\n        address _recipient, \r\n        uint _amount,\r\n        uint _saleDate,\r\n        bool _presale) internal returns (bool success) {\r\n\r\n        if (_saleDate == 0) _saleDate = now;\r\n\r\n        if (_saleDate > fundings[_proposalID].closingTime\r\n            || _saleDate < fundings[_proposalID].startTime\r\n            || fundings[_proposalID].totalWeiGiven + _amount > fundings[_proposalID].amountToFund) return;\r\n\r\n        uint _tokenAmount = TokenAmount(_amount, priceMultiplier(_proposalID), priceDivisor(_proposalID, _saleDate));\r\n        if (_tokenAmount == 0) return;\r\n        \r\n        addHolder(_recipient);\r\n        if (_presale) {\r\n            Given[_proposalID][_recipient].tokenAmount += _tokenAmount;\r\n        }\r\n        else createTokens(_recipient, _tokenAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function closeFunding(uint _proposalID) internal {\r\n        fundings[_proposalID].fundedAmount = fundings[_proposalID].totalWeiGiven;\r\n        lastFueledFundingID = _proposalID;\r\n        fundings[_proposalID].closingTime = now;\r\n        FundingFueled(_proposalID, fundings[_proposalID].fundedAmount);\r\n    }\r\n\r\n    function sendPendingAmounts(        \r\n        uint _from,\r\n        uint _to,\r\n        address _buyer) returns (bool) {\r\n        \r\n        if (_from == 0) _from = 1;\r\n        if (_to == 0) _to = lastProposalID;\r\n        if (_buyer == 0) _buyer = msg.sender;\r\n\r\n        uint _amount;\r\n        uint _tokenAmount;\r\n        \r\n        for (uint i = _from; i <= _to; i++) {\r\n\r\n            if (now > fundings[i].closingTime && Given[i][_buyer].weiAmount != 0) {\r\n                \r\n                if (fundings[i].fundedAmount == 0) _amount += Given[i][_buyer].weiAmount;\r\n                else _tokenAmount += Given[i][_buyer].tokenAmount;\r\n\r\n                fundings[i].totalWeiGiven -= Given[i][_buyer].weiAmount;\r\n                Given[i][_buyer].tokenAmount = 0;\r\n                Given[i][_buyer].weiAmount = 0;\r\n            }\r\n        }\r\n\r\n        if (_tokenAmount > 0) {\r\n            createTokens(_buyer, _tokenAmount);\r\n            return true;\r\n        }\r\n        \r\n        if (_amount > 0) {\r\n            if (!_buyer.send(_amount)) throw;\r\n            Refund(_buyer, _amount);\r\n        } else return true;\r\n    }\r\n    \r\n\r\n    function withdrawPendingAmounts() returns (bool) {\r\n        \r\n        return sendPendingAmounts(0, 0, msg.sender);\r\n    }        \r\n\r\n// Funding Moderator functions\r\n\r\n    function setFundingStartTime(uint _proposalID, uint _startTime) external {\r\n        if ((msg.sender !=  fundings[_proposalID].moderator) || now > fundings[_proposalID].closingTime) throw;\r\n        fundings[_proposalID].startTime = _startTime;\r\n    }\r\n\r\n    function setFundingFueled(uint _proposalID) external {\r\n\r\n        if ((msg.sender !=  fundings[_proposalID].moderator) || now > fundings[_proposalID].closingTime) throw;\r\n\r\n        closeFunding(_proposalID);\r\n    }\r\n    \r\n// Tokens transfer management    \r\n    \r\n    function ableTransfer() onlyClient {\r\n        if (!transferable) {\r\n            transferable = true;\r\n            TransferAble();\r\n        }\r\n    }\r\n\r\n    function disableTransfer() onlyClient {\r\n        if (transferable) {\r\n            transferable = false;\r\n            TransferDisable();\r\n        }\r\n    }\r\n    \r\n    function blockTransfer(address _shareHolder, uint _deadLine) external onlyClient onlyShareManager {\r\n        if (_deadLine > blockedDeadLine[_shareHolder]) {\r\n            blockedDeadLine[_shareHolder] = _deadLine;\r\n        }\r\n    }\r\n    \r\n    function transferFromTo(\r\n        address _from,\r\n        address _to, \r\n        uint256 _value\r\n        ) internal returns (bool success) {  \r\n\r\n        if ((transferable)\r\n            && now > blockedDeadLine[_from]\r\n            && now > blockedDeadLine[_to]\r\n            && _to != address(this)\r\n            && balances[_from] >= _value\r\n            && balances[_to] + _value > balances[_to]) {\r\n\r\n            addHolder(_to);\r\n            balances[_from] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n\r\n        } else return false;\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _value) returns (bool success) {  \r\n        if (!transferFromTo(msg.sender, _to, _value)) throw;\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from, \r\n        address _to, \r\n        uint256 _value\r\n        ) returns (bool success) { \r\n        \r\n        if (allowed[_from][msg.sender] < _value\r\n            || !transferFromTo(_from, _to, _value)) throw;\r\n            \r\n        allowed[_from][msg.sender] -= _value;\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n    \r\n}\r\n    \r\n\r\n\r\npragma solidity ^0.4.8;\r\n\r\n/*\r\n *\r\n * This file is part of Pass DAO.\r\n *\r\n * The Manager smart contract is used for the management of the Dao account, shares and tokens.\r\n *\r\n*/\r\n\r\n/// @title Manager smart contract of the Pass Decentralized Autonomous Organisation\r\ncontract PassManager is PassTokenManager {\r\n    \r\n    struct order {\r\n        address buyer;\r\n        uint weiGiven;\r\n    }\r\n    // Orders to buy tokens\r\n    order[] public orders;\r\n    // Number or orders to buy tokens\r\n    uint numberOfOrders;\r\n\r\n    // Map to know if an order was cloned from the precedent manager after an upgrade\r\n    mapping (uint => bool) orderCloned;\r\n    \r\n    function PassManager(\r\n        PassDao _passDao,\r\n        address _clonedFrom,\r\n        string _tokenName,\r\n        string _tokenSymbol,\r\n        uint8 _tokenDecimals,\r\n        bool _token,\r\n        bool _transferable,\r\n        uint _initialPriceMultiplier,\r\n        uint _inflationRate) \r\n        PassTokenManager( _passDao, _clonedFrom, _tokenName, _tokenSymbol, _tokenDecimals, \r\n            _token, _transferable, _initialPriceMultiplier, _inflationRate) { }\r\n    \r\n    /// @notice Function to receive payments\r\n    function () payable onlyShareManager { }\r\n    \r\n    /// @notice Function used by the client to send ethers\r\n    /// @param _recipient The address to send to\r\n    /// @param _amount The amount (in wei) to send\r\n    /// @return Whether the transfer was successful or not\r\n    function sendTo(\r\n        address _recipient,\r\n        uint _amount\r\n    ) external onlyClient returns (bool) {\r\n\r\n        if (_recipient.send(_amount)) return true;\r\n        else return false;\r\n    }\r\n\r\n    /// @dev Internal function to buy tokens and promote a proposal \r\n    /// @param _proposalID The index of the proposal\r\n    /// @param _buyer The address of the buyer\r\n    /// @param _date The unix date to consider for the share or token price calculation\r\n    /// @param _presale True if presale\r\n    /// @return Whether the function was successful or not \r\n    function buyTokensFor(\r\n        uint _proposalID,\r\n        address _buyer, \r\n        uint _date,\r\n        bool _presale) internal returns (bool) {\r\n\r\n        if (_proposalID == 0 || !sale(_proposalID, _buyer, msg.value, _date, _presale)) throw;\r\n\r\n        fundings[_proposalID].totalWeiGiven += msg.value;        \r\n        if (fundings[_proposalID].totalWeiGiven == fundings[_proposalID].amountToFund) closeFunding(_proposalID);\r\n\r\n        Given[_proposalID][_buyer].weiAmount += msg.value;\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /// @notice Function to buy tokens and promote a proposal \r\n    /// @param _proposalID The index of the proposal\r\n    /// @param _buyer The address of the buyer (not mandatory, msg.sender if 0)\r\n    /// @return Whether the function was successful or not \r\n    function buyTokensForProposal(\r\n        uint _proposalID, \r\n        address _buyer) payable returns (bool) {\r\n\r\n        if (_buyer == 0) _buyer = msg.sender;\r\n\r\n        if (fundings[_proposalID].moderator != 0) throw;\r\n\r\n        return buyTokensFor(_proposalID, _buyer, now, true);\r\n    }\r\n\r\n    /// @notice Function used by the moderator to buy shares or tokens\r\n    /// @param _proposalID Index of the client proposal\r\n    /// @param _buyer The address of the recipient of shares or tokens\r\n    /// @param _date The unix date to consider for the share or token price calculation\r\n    /// @param _presale True if presale\r\n    /// @return Whether the function was successful or not \r\n    function buyTokenFromModerator(\r\n        uint _proposalID,\r\n        address _buyer, \r\n        uint _date,\r\n        bool _presale) payable external returns (bool){\r\n\r\n        if (msg.sender != fundings[_proposalID].moderator) throw;\r\n\r\n        return buyTokensFor(_proposalID, _buyer, _date, _presale);\r\n    }\r\n\r\n    /// @dev Internal function to create a buy order\r\n    /// @param _buyer The address of the buyer\r\n    /// @param _weiGiven The amount in wei given by the buyer\r\n    function addOrder(\r\n        address _buyer, \r\n        uint _weiGiven) internal {\r\n\r\n        uint i;\r\n        numberOfOrders += 1;\r\n\r\n        if (numberOfOrders > orders.length) i = orders.length++;\r\n        else i = numberOfOrders - 1;\r\n        \r\n        orders[i].buyer = _buyer;\r\n        orders[i].weiGiven = _weiGiven;\r\n    }\r\n\r\n    /// @dev Internal function to remove a buy order\r\n    /// @param _order The index of the order to remove\r\n    function removeOrder(uint _order) internal {\r\n        \r\n        if (numberOfOrders - 1 < _order) return;\r\n\r\n        numberOfOrders -= 1;\r\n        if (numberOfOrders > 0) {\r\n            for (uint i = _order; i <= numberOfOrders - 1; i++) {\r\n                orders[i].buyer = orders[i+1].buyer;\r\n                orders[i].weiGiven = orders[i+1].weiGiven;\r\n            }\r\n        }\r\n        orders[numberOfOrders].buyer = 0;\r\n        orders[numberOfOrders].weiGiven = 0;\r\n    }\r\n    \r\n    /// @notice Function to create orders to buy tokens\r\n    /// @return Whether the function was successful or not\r\n    function buyTokens() payable returns (bool) {\r\n\r\n        if (!transferable || msg.value < 100 finney) throw;\r\n        \r\n        addOrder(msg.sender, msg.value);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /// @notice Function to sell tokens\r\n    /// @param _tokenAmount in tokens to sell\r\n    /// @param _from Index of the first order\r\n    /// @param _to Index of the last order\r\n    /// @return the revenue in wei\r\n    function sellTokens(\r\n        uint _tokenAmount,\r\n        uint _from,\r\n        uint _to) returns (uint) {\r\n\r\n        if (!transferable \r\n            || uint(balances[msg.sender]) < _amount \r\n            || numberOfOrders == 0) throw;\r\n        \r\n        if (_to == 0 || _to > numberOfOrders - 1) _to = numberOfOrders - 1;\r\n        \r\n        \r\n        uint _tokenAmounto;\r\n        uint _amount;\r\n        uint _totalAmount;\r\n        uint o = _from;\r\n\r\n        for (uint i = _from; i <= _to; i++) {\r\n\r\n            if (_tokenAmount > 0 && orders[o].buyer != msg.sender) {\r\n\r\n                _tokenAmounto = TokenAmount(orders[o].weiGiven, priceMultiplier(0), actualPriceDivisor(0));\r\n\r\n                if (_tokenAmount >= _tokenAmounto \r\n                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmounto)) {\r\n                            \r\n                    _tokenAmount -= _tokenAmounto;\r\n                    _totalAmount += orders[o].weiGiven;\r\n                    removeOrder(o);\r\n                }\r\n                else if (_tokenAmount < _tokenAmounto\r\n                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmount)) {\r\n                        \r\n                    _amount = weiAmount(_tokenAmount, priceMultiplier(0), actualPriceDivisor(0));\r\n                    orders[o].weiGiven -= _amount;\r\n                    _totalAmount += _amount;\r\n                    i = _to + 1;\r\n                }\r\n                else o += 1;\r\n            } \r\n            else o += 1;\r\n        }\r\n        \r\n        if (!msg.sender.send(_totalAmount)) throw;\r\n        else return _totalAmount;\r\n    }    \r\n\r\n    /// @notice Function to remove your orders and refund\r\n    /// @param _from Index of the first order\r\n    /// @param _to Index of the last order\r\n    /// @return Whether the function was successful or not\r\n    function removeOrders(\r\n        uint _from,\r\n        uint _to) returns (bool) {\r\n\r\n        if (_to == 0 || _to > numberOfOrders) _to = numberOfOrders -1;\r\n        \r\n        uint _totalAmount;\r\n        uint o = _from;\r\n\r\n        for (uint i = _from; i <= _to; i++) {\r\n\r\n            if (orders[o].buyer == msg.sender) {\r\n                \r\n                _totalAmount += orders[o].weiGiven;\r\n                removeOrder(o);\r\n\r\n            } else o += 1;\r\n        }\r\n\r\n        if (!msg.sender.send(_totalAmount)) throw;\r\n        else return true;\r\n    }\r\n    \r\n}    \r\n\r\n\r\npragma solidity ^0.4.8;\r\n\r\n/*\r\n *\r\n * This file is part of Pass DAO.\r\n *\r\n * The Project smart contract is used for the management of the Pass Dao projects.\r\n *\r\n*/\r\n\r\n/// @title Project smart contract of the Pass Decentralized Autonomous Organisation\r\ncontract PassProject {\r\n\r\n    // The Pass Dao smart contract\r\n    PassDao public passDao;\r\n    \r\n    // The project name\r\n    string public name;\r\n    // The project description\r\n    string public description;\r\n    // The Hash Of the project Document\r\n    bytes32 public hashOfTheDocument;\r\n    // The project manager smart contract\r\n    address projectManager;\r\n\r\n    struct order {\r\n        // The address of the contractor smart contract\r\n        address contractorAddress;\r\n        // The index of the contractor proposal\r\n        uint contractorProposalID;\r\n        // The amount of the order\r\n        uint amount;\r\n        // The date of the order\r\n        uint orderDate;\r\n    }\r\n    // The orders of the Dao for this project\r\n    order[] public orders;\r\n    \r\n    // The total amount of orders in wei for this project\r\n    uint public totalAmountOfOrders;\r\n\r\n    struct resolution {\r\n        // The name of the resolution\r\n        string name;\r\n        // A description of the resolution\r\n        string description;\r\n        // The date of the resolution\r\n        uint creationDate;\r\n    }\r\n    // Resolutions of the Dao for this project\r\n    resolution[] public resolutions;\r\n    \r\n// Events\r\n\r\n    event OrderAdded(address indexed Client, address indexed ContractorAddress, uint indexed ContractorProposalID, uint Amount, uint OrderDate);\r\n    event ProjectDescriptionUpdated(address indexed By, string NewDescription, bytes32 NewHashOfTheDocument);\r\n    event ResolutionAdded(address indexed Client, uint indexed ResolutionID, string Name, string Description);\r\n\r\n// Constant functions  \r\n\r\n    /// @return the actual committee room of the Dao   \r\n    function Client() constant returns (address) {\r\n        return passDao.ActualCommitteeRoom();\r\n    }\r\n    \r\n    /// @return The number of orders \r\n    function numberOfOrders() constant returns (uint) {\r\n        return orders.length - 1;\r\n    }\r\n    \r\n    /// @return The project Manager address\r\n    function ProjectManager() constant returns (address) {\r\n        return projectManager;\r\n    }\r\n\r\n    /// @return The number of resolutions \r\n    function numberOfResolutions() constant returns (uint) {\r\n        return resolutions.length - 1;\r\n    }\r\n    \r\n// modifiers\r\n\r\n    // Modifier for project manager functions \r\n    modifier onlyProjectManager {if (msg.sender != projectManager) throw; _;}\r\n\r\n    // Modifier for the Dao functions \r\n    modifier onlyClient {if (msg.sender != Client()) throw; _;}\r\n\r\n// Constructor function\r\n\r\n    function PassProject(\r\n        PassDao _passDao, \r\n        string _name,\r\n        string _description,\r\n        bytes32 _hashOfTheDocument) {\r\n\r\n        passDao = _passDao;\r\n        name = _name;\r\n        description = _description;\r\n        hashOfTheDocument = _hashOfTheDocument;\r\n        \r\n        orders.length = 1;\r\n        resolutions.length = 1;\r\n    }\r\n    \r\n// Internal functions\r\n\r\n    /// @dev Internal function to register a new order\r\n    /// @param _contractorAddress The address of the contractor smart contract\r\n    /// @param _contractorProposalID The index of the contractor proposal\r\n    /// @param _amount The amount in wei of the order\r\n    /// @param _orderDate The date of the order \r\n    function addOrder(\r\n\r\n        address _contractorAddress, \r\n        uint _contractorProposalID, \r\n        uint _amount, \r\n        uint _orderDate) internal {\r\n\r\n        uint _orderID = orders.length++;\r\n        order d = orders[_orderID];\r\n        d.contractorAddress = _contractorAddress;\r\n        d.contractorProposalID = _contractorProposalID;\r\n        d.amount = _amount;\r\n        d.orderDate = _orderDate;\r\n        \r\n        totalAmountOfOrders += _amount;\r\n        \r\n        OrderAdded(msg.sender, _contractorAddress, _contractorProposalID, _amount, _orderDate);\r\n    }\r\n    \r\n// Setting functions\r\n\r\n    /// @notice Function to allow cloning orders in case of upgrade\r\n    /// @param _contractorAddress The address of the contractor smart contract\r\n    /// @param _contractorProposalID The index of the contractor proposal\r\n    /// @param _orderAmount The amount in wei of the order\r\n    /// @param _lastOrderDate The unix date of the last order \r\n    function cloneOrder(\r\n        address _contractorAddress, \r\n        uint _contractorProposalID, \r\n        uint _orderAmount, \r\n        uint _lastOrderDate) {\r\n        \r\n        if (projectManager != 0) throw;\r\n        \r\n        addOrder(_contractorAddress, _contractorProposalID, _orderAmount, _lastOrderDate);\r\n    }\r\n    \r\n    /// @notice Function to set the project manager\r\n    /// @param _projectManager The address of the project manager smart contract\r\n    /// @return True if successful\r\n    function setProjectManager(address _projectManager) returns (bool) {\r\n\r\n        if (_projectManager == 0 || projectManager != 0) return;\r\n        \r\n        projectManager = _projectManager;\r\n        \r\n        return true;\r\n    }\r\n\r\n// Project manager functions\r\n\r\n    /// @notice Function to allow the project manager updating the description of the project\r\n    /// @param _projectDescription A description of the project\r\n    /// @param _hashOfTheDocument The hash of the last document\r\n    function updateDescription(string _projectDescription, bytes32 _hashOfTheDocument) onlyProjectManager {\r\n        description = _projectDescription;\r\n        hashOfTheDocument = _hashOfTheDocument;\r\n        ProjectDescriptionUpdated(msg.sender, _projectDescription, _hashOfTheDocument);\r\n    }\r\n\r\n// Client functions\r\n\r\n    /// @dev Function to allow the Dao to register a new order\r\n    /// @param _contractorAddress The address of the contractor smart contract\r\n    /// @param _contractorProposalID The index of the contractor proposal\r\n    /// @param _amount The amount in wei of the order\r\n    function newOrder(\r\n        address _contractorAddress, \r\n        uint _contractorProposalID, \r\n        uint _amount) onlyClient {\r\n            \r\n        addOrder(_contractorAddress, _contractorProposalID, _amount, now);\r\n    }\r\n    \r\n    /// @dev Function to allow the Dao to register a new resolution\r\n    /// @param _name The name of the resolution\r\n    /// @param _description The description of the resolution\r\n    function newResolution(\r\n        string _name, \r\n        string _description) onlyClient {\r\n\r\n        uint _resolutionID = resolutions.length++;\r\n        resolution d = resolutions[_resolutionID];\r\n        \r\n        d.name = _name;\r\n        d.description = _description;\r\n        d.creationDate = now;\r\n\r\n        ResolutionAdded(msg.sender, _resolutionID, d.name, d.description);\r\n    }\r\n}\r\n\r\ncontract PassProjectCreator {\r\n    \r\n    event NewPassProject(PassDao indexed Dao, PassProject indexed Project, string Name, string Description, bytes32 HashOfTheDocument);\r\n\r\n    /// @notice Function to create a new Pass project\r\n    /// @param _passDao The Pass Dao smart contract\r\n    /// @param _name The project name\r\n    /// @param _description The project description (not mandatory, can be updated after by the creator)\r\n    /// @param _hashOfTheDocument The Hash Of the project Document (not mandatory, can be updated after by the creator)\r\n    function createProject(\r\n        PassDao _passDao,\r\n        string _name, \r\n        string _description, \r\n        bytes32 _hashOfTheDocument\r\n        ) returns (PassProject) {\r\n\r\n        PassProject _passProject = new PassProject(_passDao, _name, _description, _hashOfTheDocument);\r\n\r\n        NewPassProject(_passDao, _passProject, _name, _description, _hashOfTheDocument);\r\n\r\n        return _passProject;\r\n    }\r\n}\r\n    \r\n\r\npragma solidity ^0.4.8;\r\n\r\n/*\r\n *\r\n * This file is part of Pass DAO.\r\n *\r\n * The Project smart contract is used for the management of the Pass Dao projects.\r\n *\r\n*/\r\n\r\n/// @title Contractor smart contract of the Pass Decentralized Autonomous Organisation\r\ncontract PassContractor {\r\n    \r\n    // The project smart contract\r\n    PassProject passProject;\r\n    \r\n    // The address of the creator of this smart contract\r\n    address public creator;\r\n    // Address of the recipient;\r\n    address public recipient;\r\n\r\n    // End date of the setup procedure\r\n    uint public smartContractStartDate;\r\n\r\n    struct proposal {\r\n        // Amount (in wei) of the proposal\r\n        uint amount;\r\n        // A description of the proposal\r\n        string description;\r\n        // The hash of the proposal's document\r\n        bytes32 hashOfTheDocument;\r\n        // A unix timestamp, denoting the date when the proposal was created\r\n        uint dateOfProposal;\r\n        // The amount submitted to a vote\r\n        uint submittedAmount;\r\n        // The sum amount (in wei) ordered for this proposal \r\n        uint orderAmount;\r\n        // A unix timestamp, denoting the date of the last order for the approved proposal\r\n        uint dateOfLastOrder;\r\n    }\r\n    // Proposals to work for Pass Dao\r\n    proposal[] public proposals;\r\n\r\n// Events\r\n\r\n    event RecipientUpdated(address indexed By, address LastRecipient, address NewRecipient);\r\n    event Withdrawal(address indexed By, address indexed Recipient, uint Amount);\r\n    event ProposalAdded(address Creator, uint indexed ProposalID, uint Amount, string Description, bytes32 HashOfTheDocument);\r\n    event ProposalSubmitted(address indexed Client, uint Amount);\r\n    event Order(address indexed Client, uint indexed ProposalID, uint Amount);\r\n\r\n// Constant functions\r\n\r\n    /// @return the actual committee room of the Dao\r\n    function Client() constant returns (address) {\r\n        return passProject.Client();\r\n    }\r\n\r\n    /// @return the project smart contract\r\n    function Project() constant returns (PassProject) {\r\n        return passProject;\r\n    }\r\n    \r\n    /// @notice Function used by the client to check the proposal before submitting\r\n    /// @param _sender The creator of the Dao proposal\r\n    /// @param _proposalID The index of the proposal\r\n    /// @param _amount The amount of the proposal\r\n    /// @return true if the proposal can be submitted\r\n    function proposalChecked(\r\n        address _sender,\r\n        uint _proposalID, \r\n        uint _amount) constant external onlyClient returns (bool) {\r\n        if (_sender != recipient && _sender != creator) return;\r\n        if (_amount <= proposals[_proposalID].amount - proposals[_proposalID].submittedAmount) return true;\r\n    }\r\n\r\n    /// @return The number of proposals     \r\n    function numberOfProposals() constant returns (uint) {\r\n        return proposals.length - 1;\r\n    }\r\n\r\n\r\n// Modifiers\r\n\r\n    // Modifier for contractor functions\r\n    modifier onlyContractor {if (msg.sender != recipient) throw; _;}\r\n    \r\n    // Modifier for client functions\r\n    modifier onlyClient {if (msg.sender != Client()) throw; _;}\r\n\r\n// Constructor function\r\n\r\n    function PassContractor(\r\n        address _creator, \r\n        PassProject _passProject, \r\n        address _recipient,\r\n        bool _restore) { \r\n\r\n        if (address(_passProject) == 0) throw;\r\n        \r\n        creator = _creator;\r\n        if (_recipient == 0) _recipient = _creator;\r\n        recipient = _recipient;\r\n        \r\n        passProject = _passProject;\r\n        \r\n        if (!_restore) smartContractStartDate = now;\r\n\r\n        proposals.length = 1;\r\n    }\r\n\r\n// Setting functions\r\n\r\n    /// @notice Function to clone a proposal from the last contractor\r\n    /// @param _amount Amount (in wei) of the proposal\r\n    /// @param _description A description of the proposal\r\n    /// @param _hashOfTheDocument The hash of the proposal's document\r\n    /// @param _dateOfProposal A unix timestamp, denoting the date when the proposal was created\r\n    /// @param _orderAmount The sum amount (in wei) ordered for this proposal \r\n    /// @param _dateOfOrder A unix timestamp, denoting the date of the last order for the approved proposal\r\n    /// @param _cloneOrder True if the order has to be cloned in the project smart contract\r\n    /// @return Whether the function was successful or not \r\n    function cloneProposal(\r\n        uint _amount,\r\n        string _description,\r\n        bytes32 _hashOfTheDocument,\r\n        uint _dateOfProposal,\r\n        uint _orderAmount,\r\n        uint _dateOfOrder,\r\n        bool _cloneOrder\r\n    ) returns (bool success) {\r\n            \r\n        if (smartContractStartDate != 0 || recipient == 0\r\n        || msg.sender != creator) throw;\r\n        \r\n        uint _proposalID = proposals.length++;\r\n        proposal c = proposals[_proposalID];\r\n\r\n        c.amount = _amount;\r\n        c.description = _description;\r\n        c.hashOfTheDocument = _hashOfTheDocument; \r\n        c.dateOfProposal = _dateOfProposal;\r\n        c.orderAmount = _orderAmount;\r\n        c.dateOfLastOrder = _dateOfOrder;\r\n\r\n        ProposalAdded(msg.sender, _proposalID, _amount, _description, _hashOfTheDocument);\r\n        \r\n        if (_cloneOrder) passProject.cloneOrder(address(this), _proposalID, _orderAmount, _dateOfOrder);\r\n        \r\n        return true;\r\n    }\r\n\r\n    /// @notice Function to close the setting procedure and start to use this smart contract\r\n    /// @return True if successful\r\n    function closeSetup() returns (bool) {\r\n        \r\n        if (smartContractStartDate != 0 \r\n            || (msg.sender != creator && msg.sender != Client())) return;\r\n\r\n        smartContractStartDate = now;\r\n\r\n        return true;\r\n    }\r\n    \r\n// Account Management\r\n\r\n    /// @notice Function to update the recipent address\r\n    /// @param _newRecipient The adress of the recipient\r\n    function updateRecipient(address _newRecipient) onlyContractor {\r\n\r\n        if (_newRecipient == 0) throw;\r\n\r\n        RecipientUpdated(msg.sender, recipient, _newRecipient);\r\n        recipient = _newRecipient;\r\n    } \r\n\r\n    /// @notice Function to receive payments\r\n    function () payable { }\r\n    \r\n    /// @notice Function to allow contractors to withdraw ethers\r\n    /// @param _amount The amount (in wei) to withdraw\r\n    function withdraw(uint _amount) onlyContractor {\r\n        if (!recipient.send(_amount)) throw;\r\n        Withdrawal(msg.sender, recipient, _amount);\r\n    }\r\n    \r\n// Project Manager Functions    \r\n\r\n    /// @notice Function to allow the project manager updating the description of the project\r\n    /// @param _projectDescription A description of the project\r\n    /// @param _hashOfTheDocument The hash of the last document\r\n    function updateProjectDescription(string _projectDescription, bytes32 _hashOfTheDocument) onlyContractor {\r\n        passProject.updateDescription(_projectDescription, _hashOfTheDocument);\r\n    }\r\n    \r\n// Management of proposals\r\n\r\n    /// @notice Function to make a proposal to work for the client\r\n    /// @param _creator The address of the creator of the proposal\r\n    /// @param _amount The amount (in wei) of the proposal\r\n    /// @param _description String describing the proposal\r\n    /// @param _hashOfTheDocument The hash of the proposal document\r\n    /// @return The index of the contractor proposal\r\n    function newProposal(\r\n        address _creator,\r\n        uint _amount,\r\n        string _description, \r\n        bytes32 _hashOfTheDocument\r\n    ) external returns (uint) {\r\n        \r\n        if (msg.sender == Client() && _creator != recipient && _creator != creator) throw;\r\n        if (msg.sender != Client() && msg.sender != recipient && msg.sender != creator) throw;\r\n\r\n        if (_amount == 0) throw;\r\n        \r\n        uint _proposalID = proposals.length++;\r\n        proposal c = proposals[_proposalID];\r\n\r\n        c.amount = _amount;\r\n        c.description = _description;\r\n        c.hashOfTheDocument = _hashOfTheDocument; \r\n        c.dateOfProposal = now;\r\n        \r\n        ProposalAdded(msg.sender, _proposalID, c.amount, c.description, c.hashOfTheDocument);\r\n        \r\n        return _proposalID;\r\n    }\r\n    \r\n    /// @notice Function used by the client to infor about the submitted amount\r\n    /// @param _sender The address of the sender who submits the proposal\r\n    /// @param _proposalID The index of the contractor proposal\r\n    /// @param _amount The amount (in wei) submitted\r\n    function submitProposal(\r\n        address _sender, \r\n        uint _proposalID, \r\n        uint _amount) onlyClient {\r\n\r\n        if (_sender != recipient && _sender != creator) throw;    \r\n        proposals[_proposalID].submittedAmount += _amount;\r\n        ProposalSubmitted(msg.sender, _amount);\r\n    }\r\n\r\n    /// @notice Function used by the client to order according to the contractor proposal\r\n    /// @param _proposalID The index of the contractor proposal\r\n    /// @param _orderAmount The amount (in wei) of the order\r\n    /// @return Whether the order was made or not\r\n    function order(\r\n        uint _proposalID,\r\n        uint _orderAmount\r\n    ) external onlyClient returns (bool) {\r\n    \r\n        proposal c = proposals[_proposalID];\r\n        \r\n        uint _sum = c.orderAmount + _orderAmount;\r\n        if (_sum > c.amount\r\n            || _sum < c.orderAmount\r\n            || _sum < _orderAmount) return; \r\n\r\n        c.orderAmount = _sum;\r\n        c.dateOfLastOrder = now;\r\n        \r\n        Order(msg.sender, _proposalID, _orderAmount);\r\n        \r\n        return true;\r\n    }\r\n    \r\n}\r\n\r\ncontract PassContractorCreator {\r\n    \r\n    // Address of the pass Dao smart contract\r\n    PassDao public passDao;\r\n    // Address of the Pass Project creator\r\n    PassProjectCreator public projectCreator;\r\n    \r\n    struct contractor {\r\n        // The address of the creator of the contractor\r\n        address creator;\r\n        // The contractor smart contract\r\n        PassContractor contractor;\r\n        // The address of the recipient for withdrawals\r\n        address recipient;\r\n        // True if meta project\r\n        bool metaProject;\r\n        // The address of the existing project smart contract\r\n        PassProject passProject;\r\n        // The name of the project (if the project smart contract doesn't exist)\r\n        string projectName;\r\n        // A description of the project (can be updated after)\r\n        string projectDescription;\r\n        // The unix creation date of the contractor\r\n        uint creationDate;\r\n    }\r\n    // contractors created to work for Pass Dao\r\n    contractor[] public contractors;\r\n    \r\n    event NewPassContractor(address indexed Creator, address indexed Recipient, PassProject indexed Project, PassContractor Contractor);\r\n\r\n    function PassContractorCreator(PassDao _passDao, PassProjectCreator _projectCreator) {\r\n        passDao = _passDao;\r\n        projectCreator = _projectCreator;\r\n        contractors.length = 0;\r\n    }\r\n\r\n    /// @return The number of created contractors \r\n    function numberOfContractors() constant returns (uint) {\r\n        return contractors.length;\r\n    }\r\n    \r\n    /// @notice Function to create a contractor smart contract\r\n    /// @param _creator The address of the creator of the contractor\r\n    /// @param _recipient The address of the recipient for withdrawals\r\n    /// @param _metaProject True if meta project\r\n    /// @param _passProject The address of the existing project smart contract\r\n    /// @param _projectName The name of the project (if the project smart contract doesn't exist)\r\n    /// @param _projectDescription A description of the project (can be updated after)\r\n    /// @param _restore True if orders or proposals are to be cloned from other contracts\r\n    /// @return The address of the created contractor smart contract\r\n    function createContractor(\r\n        address _creator,\r\n        address _recipient, \r\n        bool _metaProject,\r\n        PassProject _passProject,\r\n        string _projectName, \r\n        string _projectDescription,\r\n        bool _restore) returns (PassContractor) {\r\n \r\n        PassProject _project;\r\n\r\n        if (_creator == 0) _creator = msg.sender;\r\n        \r\n        if (_metaProject) _project = PassProject(passDao.MetaProject());\r\n        else if (address(_passProject) == 0) \r\n            _project = projectCreator.createProject(passDao, _projectName, _projectDescription, 0);\r\n        else _project = _passProject;\r\n\r\n        PassContractor _contractor = new PassContractor(_creator, _project, _recipient, _restore);\r\n        if (!_metaProject && address(_passProject) == 0 && !_restore) _project.setProjectManager(address(_contractor));\r\n        \r\n        uint _contractorID = contractors.length++;\r\n        contractor c = contractors[_contractorID];\r\n        c.creator = _creator;\r\n        c.contractor = _contractor;\r\n        c.recipient = _recipient;\r\n        c.metaProject = _metaProject;\r\n        c.passProject = _passProject;\r\n        c.projectName = _projectName;\r\n        c.projectDescription = _projectDescription;\r\n        c.creationDate = now;\r\n\r\n        NewPassContractor(_creator, _recipient, _project, _contractor);\r\n \r\n        return _contractor;\r\n    }\r\n    \r\n}\r\n\r\n\r\npragma solidity ^0.4.8;\r\n\r\n/*\r\n *\r\n * This file is part of Pass DAO.\r\n *\r\n\r\n/*\r\nSmart contract for a Decentralized Autonomous Organization (DAO)\r\nto automate organizational governance and decision-making.\r\n*/\r\n\r\n/// @title Pass Committee Room\r\ncontract PassCommitteeRoomInterface {\r\n\r\n    // The Pass Dao smart contract\r\n    PassDao public passDao;\r\n\r\n    enum ProposalTypes { contractor, resolution, rules, upgrade }\r\n\r\n    struct Committee {        \r\n        // Address of the creator of the committee\r\n        address creator;  \r\n        // The type of the proposal\r\n        ProposalTypes proposalType;\r\n        // Index to identify the proposal\r\n        uint proposalID;\r\n        // unix timestamp, denoting the end of the set period of a proposal before the committee \r\n        uint setDeadline;\r\n        // Fees (in wei) paid by the creator of the proposal\r\n        uint fees;\r\n        // Total of fees (in wei) rewarded to the voters\r\n        uint totalRewardedAmount;\r\n        // A unix timestamp, denoting the end of the voting period\r\n        uint votingDeadline;\r\n        // True if the proposal's votes have yet to be counted, otherwise False\r\n        bool open; \r\n        // A unix timestamp, denoting the date of the execution of the approved proposal\r\n        uint dateOfExecution;\r\n        // Number of shares in favor of the proposal\r\n        uint yea; \r\n        // Number of shares opposed to the proposal\r\n        uint nay; \r\n    }\r\n    // Committees organized to vote for or against a proposal\r\n    Committee[] public Committees; \r\n    // mapping to indicate if a shareholder has voted at a committee or not\r\n    mapping (uint => mapping (address => bool)) hasVoted;\r\n\r\n    struct Proposal {\r\n        // Index to identify the committee\r\n        uint committeeID;\r\n        // The contractor smart contract (not mandatory if funding)\r\n        PassContractor contractor;\r\n        // The index of the contractor proposal in the contractor contract (not mandatory if funding)\r\n        uint contractorProposalID;\r\n        // The amount of the proposal from the share manager balance (for funding or contractor proposals)\r\n        uint amount;\r\n        // The address which sets partners and manages the funding (not mandatory)\r\n        address moderator;\r\n        // Amount from the sale of shares (for funding or contractor proposals)\r\n        uint amountForShares;\r\n        // The initial price multiplier of Dao shares at the beginning of the funding (not mandatory)\r\n        uint initialSharePriceMultiplier; \r\n        // Amount from the sale of tokens (for project manager proposals)\r\n        uint amountForTokens;\r\n        // A unix timestamp, denoting the start time of the funding\r\n        uint minutesFundingPeriod;\r\n        // True if the proposal is closed\r\n        bool open; \r\n    }\r\n    // Proposals to pay a contractor or/and fund the Dao\r\n    Proposal[] public Proposals;\r\n\r\n    struct Question {\r\n        // Index to identify a committee\r\n        uint committeeID; \r\n        // The project smart contract\r\n        PassProject project;\r\n        // The name of the question for display purpose\r\n        string name;\r\n        // A description of the question\r\n        string description;\r\n    }\r\n    // Questions submitted to a vote by the shareholders \r\n    Question[] public ResolutionProposals;\r\n    \r\n    struct Rules {\r\n        // Index to identify a committee\r\n        uint committeeID; \r\n        // The quorum needed for each proposal is calculated by totalSupply / minQuorumDivisor\r\n        uint minQuorumDivisor;  \r\n        // Minimum fees (in wei) to create a proposal\r\n        uint minCommitteeFees; \r\n        // Minimum percentage of votes for a proposal to reward the creator\r\n        uint minPercentageOfLikes;\r\n        // Period in minutes to consider or set a proposal before the voting procedure\r\n        uint minutesSetProposalPeriod; \r\n        // The minimum debate period in minutes that a generic proposal can have\r\n        uint minMinutesDebatePeriod;\r\n        // The inflation rate to calculate the reward of fees to voters\r\n        uint feesRewardInflationRate;\r\n        // The inflation rate to calculate the token price (for project manager proposals) \r\n        uint tokenPriceInflationRate;\r\n        // The default minutes funding period\r\n        uint defaultMinutesFundingPeriod;\r\n    } \r\n    // Proposals to update the committee rules\r\n    Rules[] public rulesProposals;\r\n\r\n    struct Upgrade {\r\n        // Index to identify a committee\r\n        uint committeeID; \r\n        // Address of the proposed Committee Room smart contract\r\n        address newCommitteeRoom;\r\n        // Address of the proposed share manager smart contract\r\n        address newShareManager;\r\n        // Address of the proposed token manager smart contract\r\n        address newTokenManager;\r\n    }\r\n    // Proposals to upgrade\r\n    Upgrade[] public UpgradeProposals;\r\n    \r\n    // The minimum periods in minutes \r\n    uint minMinutesPeriods;\r\n    // The maximum inflation rate for token price or rewards to voters\r\n    uint maxInflationRate;\r\n    \r\n    /// @return the effective share manager\r\n    function ShareManager() constant returns (PassManager);\r\n\r\n    /// @return the effective token manager\r\n    function TokenManager() constant returns (PassManager);\r\n\r\n    /// return the balance of the DAO\r\n    function Balance() constant returns (uint);\r\n    \r\n    /// @param _committeeID The index of the committee\r\n    /// @param _shareHolder The shareholder (not mandatory, default : msg.sender)\r\n    /// @return true if the shareholder has voted at the committee\r\n    function HasVoted(\r\n        uint _committeeID, \r\n        address _shareHolder) constant external returns (bool);\r\n    \r\n    /// @return The minimum quorum for proposals to pass \r\n    function minQuorum() constant returns (uint);\r\n\r\n    /// @return The number of committees \r\n    function numberOfCommittees() constant returns (uint);\r\n    \r\n    /// @dev The constructor function\r\n    /// @param _passDao Address of Pass Dao\r\n    //function PassCommitteeRoom(address _passDao);\r\n\r\n    /// @notice Function to init an set the committee rules\r\n    /// @param _maxInflationRate The maximum inflation rate for contractor and funding proposals\r\n    /// @param _minMinutesPeriods The minimum periods in minutes\r\n    /// @param _minQuorumDivisor The initial minimum quorum divisor for the proposals\r\n    /// @param _minCommitteeFees The minimum amount (in wei) to make a proposal\r\n    /// @param _minPercentageOfLikes Minimum percentage of votes for a proposal to reward the creator\r\n    /// @param _minutesSetProposalPeriod The minimum period in minutes before a committee\r\n    /// @param _minMinutesDebatePeriod The minimum period in minutes of the board meetings\r\n    /// @param _feesRewardInflationRate The inflation rate to calculate the reward of fees to voters during a committee\r\n    /// @param _tokenPriceInflationRate The inflation rate to calculate the token price for project manager proposals\r\n    /// @param _defaultMinutesFundingPeriod Default period in minutes of the funding\r\n    function init(\r\n        uint _maxInflationRate,\r\n        uint _minMinutesPeriods,\r\n        uint _minQuorumDivisor,\r\n        uint _minCommitteeFees,\r\n        uint _minPercentageOfLikes,\r\n        uint _minutesSetProposalPeriod,\r\n        uint _minMinutesDebatePeriod,\r\n        uint _feesRewardInflationRate,\r\n        uint _tokenPriceInflationRate,\r\n        uint _defaultMinutesFundingPeriod);\r\n\r\n    /// @notice Function to create a contractor smart contract\r\n    /// @param _contractorCreator The contractor creator smart contract\r\n    /// @param _recipient The recipient of the contractor smart contract\r\n    /// @param _metaProject True if meta project\r\n    /// @param _passProject The project smart contract (not mandatory)\r\n    /// @param _projectName The name of the project (if the project smart contract doesn't exist)\r\n    /// @param _projectDescription A description of the project (not mandatory, can be updated after)\r\n    /// @return The contractor smart contract\r\n    function createContractor(\r\n        PassContractorCreator _contractorCreator,\r\n        address _recipient,\r\n        bool _metaProject,\r\n        PassProject _passProject,\r\n        string _projectName, \r\n        string _projectDescription) returns (PassContractor);\r\n    \r\n    /// @notice Function to make a proposal to pay a contractor or/and fund the Dao\r\n    /// @param _amount Amount of the proposal\r\n    /// @param _contractor The contractor smart contract\r\n    /// @param _contractorProposalID Index of the contractor proposal in the contractor smart contract (not mandatory)\r\n    /// @param _proposalDescription String describing the proposal (if not existing proposal)\r\n    /// @param _hashOfTheContractorProposalDocument The hash of the Contractor proposal document (if not existing proposal)\r\n    /// @param _moderator The address which sets partners and manage the funding (not mandatory)\r\n    /// @param _initialSharePriceMultiplier The initial price multiplier of shares (for funding or contractor proposals)\r\n    /// @param _minutesFundingPeriod Period in minutes of the funding (not mandatory)\r\n    /// @param _minutesDebatingPeriod Period in minutes of the board meeting to vote on the proposal (not mandatory)\r\n    /// @return The index of the proposal\r\n    function contractorProposal(\r\n        uint _amount,\r\n        PassContractor _contractor,\r\n        uint _contractorProposalID,\r\n        string _proposalDescription, \r\n        bytes32 _hashOfTheContractorProposalDocument,\r\n        address _moderator,\r\n        uint _initialSharePriceMultiplier, \r\n        uint _minutesFundingPeriod,\r\n        uint _minutesDebatingPeriod) payable returns (uint);\r\n\r\n    /// @notice Function to submit a question\r\n    /// @param _name Name of the question for display purpose\r\n    /// @param _description A description of the question\r\n    /// @param _project The project smart contract\r\n    /// @param _minutesDebatingPeriod Period in minutes of the board meeting to vote on the proposal\r\n    /// @return The index of the proposal\r\n    function resolutionProposal(\r\n        string _name,\r\n        string _description,\r\n        PassProject _project,\r\n        uint _minutesDebatingPeriod) payable returns (uint);\r\n        \r\n    /// @notice Function to make a proposal to change the rules of the committee room \r\n    /// @param _minQuorumDivisor If 5, the minimum quorum is 20%\r\n    /// @param _minCommitteeFees The minimum amount (in wei) to make a proposal\r\n    /// @param _minPercentageOfLikes Minimum percentage of votes for a proposal to reward the creator\r\n    /// @param _minutesSetProposalPeriod Minimum period in minutes before a committee\r\n    /// @param _minMinutesDebatePeriod The minimum period in minutes of the committees\r\n    /// @param _feesRewardInflationRate The inflation rate to calculate the reward of fees to voters during a committee\r\n    /// @param _defaultMinutesFundingPeriod Period in minutes of the funding\r\n    /// @param _tokenPriceInflationRate The inflation rate to calculate the token price for project manager proposals\r\n    /// @return The index of the proposal\r\n    function rulesProposal(\r\n        uint _minQuorumDivisor, \r\n        uint _minCommitteeFees,\r\n        uint _minPercentageOfLikes,\r\n        uint _minutesSetProposalPeriod,\r\n        uint _minMinutesDebatePeriod,\r\n        uint _feesRewardInflationRate,\r\n        uint _defaultMinutesFundingPeriod,\r\n        uint _tokenPriceInflationRate) payable returns (uint);\r\n    \r\n    /// @notice Function to make a proposal to upgrade the application\r\n    /// @param _newCommitteeRoom Address of a new Committee Room smart contract (not mandatory)   \r\n    /// @param _newShareManager Address of a new share manager smart contract (not mandatory)\r\n    /// @param _newTokenManager Address of a new token manager smart contract (not mandatory)\r\n    /// @param _minutesDebatingPeriod Period in minutes of the committee to vote on the proposal (not mandatory)\r\n    /// @return The index of the proposal\r\n    function upgradeProposal(\r\n        address _newCommitteeRoom,\r\n        address _newShareManager,\r\n        address _newTokenManager,\r\n        uint _minutesDebatingPeriod) payable returns (uint);\r\n\r\n    /// @dev Internal function to create a committee\r\n    /// @param _proposalType The type of the proposal\r\n    /// @param _proposalID The index of the proposal\r\n    /// @param _minutesDebatingPeriod The duration in minutes of the committee\r\n    /// @return the index of the board meeting\r\n    function newCommittee(\r\n        ProposalTypes _proposalType,\r\n        uint _proposalID, \r\n        uint _minutesDebatingPeriod) internal returns (uint);\r\n        \r\n    /// @notice Function to vote for or against a proposal during a committee\r\n    /// @param _committeeID The index of the committee\r\n    /// @param _supportsProposal True if the proposal is supported\r\n    function vote(\r\n        uint _committeeID, \r\n        bool _supportsProposal);\r\n    \r\n    /// @notice Function to execute a decision and close the committee\r\n    /// @param _committeeID The index of the committee\r\n    /// @return Whether the proposal was executed or not\r\n    function executeDecision(uint _committeeID) returns (bool);\r\n    \r\n    /// @notice Function to order to a contractor and close a contractor proposal\r\n    /// @param _proposalID The index of the proposal\r\n    /// @return Whether the proposal was ordered and the proposal amount sent or not\r\n    function orderToContractor(uint _proposalID) returns (bool);   \r\n\r\n    /// @notice Function to buy shares and or/and promote a contractor proposal \r\n    /// @param _proposalID The index of the proposal\r\n    /// @return Whether the function was successful or not\r\n    function buySharesForProposal(uint _proposalID) payable returns (bool);\r\n    \r\n    /// @notice Function to send tokens or refund after the closing time of the funding proposals\r\n    /// @param _from The first proposal. 0 if not linked to a proposal\r\n    /// @param _to The last proposal\r\n    /// @param _buyer The address of the buyer\r\n    /// @return Whether the function was successful or not \r\n    function sendPendingAmounts(        \r\n        uint _from,\r\n        uint _to,\r\n        address _buyer) returns (bool);\r\n        \r\n    /// @notice Function to receive tokens or refund after the closing time of the funding proposals\r\n    /// @return Whether the function was successful or not\r\n    function withdrawPendingAmounts() returns (bool);\r\n\r\n    event CommitteeLimits(uint maxInflationRate, uint minMinutesPeriods);\r\n    \r\n    event ContractorCreated(PassContractorCreator Creator, address indexed Sender, PassContractor Contractor, address Recipient);\r\n\r\n    event ProposalSubmitted(uint indexed ProposalID, uint CommitteeID, PassContractor indexed Contractor, uint indexed ContractorProposalID, \r\n        uint Amount, string Description, address Moderator, uint SharePriceMultiplier, uint MinutesFundingPeriod);\r\n    event ResolutionProposalSubmitted(uint indexed QuestionID, uint indexed CommitteeID, PassProject indexed Project, string Name, string Description);\r\n    event RulesProposalSubmitted(uint indexed rulesProposalID, uint CommitteeID, uint MinQuorumDivisor, uint MinCommitteeFees, uint MinPercentageOfLikes, \r\n        uint MinutesSetProposalPeriod, uint MinMinutesDebatePeriod, uint FeesRewardInflationRate, uint DefaultMinutesFundingPeriod, uint TokenPriceInflationRate);\r\n    event UpgradeProposalSubmitted(uint indexed UpgradeProposalID, uint indexed CommitteeID, address NewCommitteeRoom, \r\n        address NewShareManager, address NewTokenManager);\r\n\r\n    event Voted(uint indexed CommitteeID, bool Position, address indexed Voter, uint RewardedAmount);\r\n\r\n    event ProposalClosed(uint indexed ProposalID, ProposalTypes indexed ProposalType, uint CommitteeID, \r\n        uint TotalRewardedAmount, bool ProposalExecuted, uint RewardedSharesAmount, uint SentToManager);\r\n    event ContractorProposalClosed(uint indexed ProposalID, uint indexed ContractorProposalID, PassContractor indexed Contractor, uint AmountSent);\r\n    event DappUpgraded(address NewCommitteeRoom, address NewShareManager, address NewTokenManager);\r\n\r\n}\r\n\r\ncontract PassCommitteeRoom is PassCommitteeRoomInterface {\r\n\r\n// Constant functions\r\n\r\n    function ShareManager() constant returns (PassManager) {\r\n        return PassManager(passDao.ActualShareManager());\r\n    }\r\n    \r\n    function TokenManager() constant returns (PassManager) {\r\n        return PassManager(passDao.ActualTokenManager());\r\n    }\r\n    \r\n    function Balance() constant returns (uint) {\r\n        return passDao.ActualShareManager().balance;\r\n    }\r\n\r\n    function HasVoted(\r\n        uint _committeeID, \r\n        address _shareHolder) constant external returns (bool) {\r\n\r\n        if (_shareHolder == 0) return hasVoted[_committeeID][msg.sender];\r\n        else return hasVoted[_committeeID][_shareHolder];\r\n    }\r\n    \r\n    function minQuorum() constant returns (uint) {\r\n        return (uint(ShareManager().totalSupply()) / rulesProposals[0].minQuorumDivisor);\r\n    }\r\n\r\n    function numberOfCommittees() constant returns (uint) {\r\n        return Committees.length - 1;\r\n    }\r\n    \r\n// Constructor and init functions\r\n\r\n    function PassCommitteeRoom(address _passDao) {\r\n\r\n        passDao = PassDao(_passDao);\r\n        rulesProposals.length = 1; \r\n        Committees.length = 1;\r\n        Proposals.length = 1;\r\n        ResolutionProposals.length = 1;\r\n        UpgradeProposals.length = 1;\r\n    }\r\n    \r\n    function init(\r\n        uint _maxInflationRate,\r\n        uint _minMinutesPeriods,\r\n        uint _minQuorumDivisor,\r\n        uint _minCommitteeFees,\r\n        uint _minPercentageOfLikes,\r\n        uint _minutesSetProposalPeriod,\r\n        uint _minMinutesDebatePeriod,\r\n        uint _feesRewardInflationRate,\r\n        uint _tokenPriceInflationRate,\r\n        uint _defaultMinutesFundingPeriod) {\r\n\r\n        maxInflationRate = _maxInflationRate;\r\n        minMinutesPeriods = _minMinutesPeriods;\r\n        CommitteeLimits(maxInflationRate, minMinutesPeriods);\r\n        \r\n        if (rulesProposals[0].minQuorumDivisor != 0) throw;\r\n        rulesProposals[0].minQuorumDivisor = _minQuorumDivisor;\r\n        rulesProposals[0].minCommitteeFees = _minCommitteeFees;\r\n        rulesProposals[0].minPercentageOfLikes = _minPercentageOfLikes;\r\n        rulesProposals[0].minutesSetProposalPeriod = _minutesSetProposalPeriod;\r\n        rulesProposals[0].minMinutesDebatePeriod = _minMinutesDebatePeriod;\r\n        rulesProposals[0].feesRewardInflationRate = _feesRewardInflationRate;\r\n        rulesProposals[0].tokenPriceInflationRate = _tokenPriceInflationRate;\r\n        rulesProposals[0].defaultMinutesFundingPeriod = _defaultMinutesFundingPeriod;\r\n\r\n    }\r\n\r\n// Project manager and contractor management\r\n\r\n    function createContractor(\r\n        PassContractorCreator _contractorCreator,\r\n        address _recipient,\r\n        bool _metaProject,\r\n        PassProject _passProject,\r\n        string _projectName, \r\n        string _projectDescription) returns (PassContractor) {\r\n\r\n        PassContractor _contractor = _contractorCreator.createContractor(msg.sender, _recipient, \r\n            _metaProject, _passProject, _projectName, _projectDescription, false);\r\n        ContractorCreated(_contractorCreator, msg.sender, _contractor, _recipient);\r\n        return _contractor;\r\n    }   \r\n\r\n// Proposals Management\r\n\r\n    function contractorProposal(\r\n        uint _amount,\r\n        PassContractor _contractor,\r\n        uint _contractorProposalID,\r\n        string _proposalDescription, \r\n        bytes32 _hashOfTheContractorProposalDocument,        \r\n        address _moderator,\r\n        uint _initialSharePriceMultiplier, \r\n        uint _minutesFundingPeriod,\r\n        uint _minutesDebatingPeriod\r\n    ) payable returns (uint) {\r\n\r\n        if (_minutesFundingPeriod == 0) _minutesFundingPeriod = rulesProposals[0].defaultMinutesFundingPeriod;\r\n\r\n        if (address(_contractor) != 0 && _contractorProposalID != 0) {\r\n            if (_hashOfTheContractorProposalDocument != 0 \r\n                ||!_contractor.proposalChecked(msg.sender, _contractorProposalID, _amount)) throw;\r\n            else _proposalDescription = \"Proposal checked\";\r\n        }\r\n\r\n        if ((address(_contractor) != 0 && _contractorProposalID == 0 && _hashOfTheContractorProposalDocument == 0)\r\n            || _amount == 0\r\n            || _minutesFundingPeriod < minMinutesPeriods) throw;\r\n\r\n        uint _proposalID = Proposals.length++;\r\n        Proposal p = Proposals[_proposalID];\r\n\r\n        p.contractor = _contractor;\r\n        \r\n        if (_contractorProposalID == 0 && _hashOfTheContractorProposalDocument != 0) {\r\n            _contractorProposalID = _contractor.newProposal(msg.sender, _amount, _proposalDescription, _hashOfTheContractorProposalDocument);\r\n        }\r\n        p.contractorProposalID = _contractorProposalID;\r\n\r\n        if (address(_contractor) == 0) p.amountForShares = _amount;\r\n        else {\r\n            _contractor.submitProposal(msg.sender, _contractorProposalID, _amount);\r\n            if (_contractor.Project().ProjectManager() == address(_contractor)) p.amountForTokens = _amount;\r\n            else {\r\n                p.amount = Balance();\r\n                if (_amount > p.amount) p.amountForShares = _amount - p.amount;\r\n                else p.amount = _amount;\r\n            }\r\n        }\r\n        \r\n        p.moderator = _moderator;\r\n\r\n        p.initialSharePriceMultiplier = _initialSharePriceMultiplier;\r\n\r\n        p.minutesFundingPeriod = _minutesFundingPeriod;\r\n\r\n        p.committeeID = newCommittee(ProposalTypes.contractor, _proposalID, _minutesDebatingPeriod);   \r\n\r\n        p.open = true;\r\n        \r\n        ProposalSubmitted(_proposalID, p.committeeID, p.contractor, p.contractorProposalID, p.amount+p.amountForShares+p.amountForTokens, \r\n            _proposalDescription, p.moderator, p.initialSharePriceMultiplier, p.minutesFundingPeriod);\r\n\r\n        return _proposalID;\r\n    }\r\n\r\n    function resolutionProposal(\r\n        string _name,\r\n        string _description,\r\n        PassProject _project,\r\n        uint _minutesDebatingPeriod) payable returns (uint) {\r\n        \r\n        if (address(_project) == 0) _project = PassProject(passDao.MetaProject());\r\n        \r\n        uint _questionID = ResolutionProposals.length++;\r\n        Question q = ResolutionProposals[_questionID];\r\n        \r\n        q.project = _project;\r\n        q.name = _name;\r\n        q.description = _description;\r\n        \r\n        q.committeeID = newCommittee(ProposalTypes.resolution, _questionID, _minutesDebatingPeriod);\r\n        \r\n        ResolutionProposalSubmitted(_questionID, q.committeeID, q.project, q.name, q.description);\r\n        \r\n        return _questionID;\r\n    }\r\n\r\n    function rulesProposal(\r\n        uint _minQuorumDivisor, \r\n        uint _minCommitteeFees,\r\n        uint _minPercentageOfLikes,\r\n        uint _minutesSetProposalPeriod,\r\n        uint _minMinutesDebatePeriod,\r\n        uint _feesRewardInflationRate,\r\n        uint _defaultMinutesFundingPeriod,\r\n        uint _tokenPriceInflationRate) payable returns (uint) {\r\n\r\n    \r\n        if (_minQuorumDivisor <= 1\r\n            || _minQuorumDivisor > 10\r\n            || _minutesSetProposalPeriod < minMinutesPeriods\r\n            || _minMinutesDebatePeriod < minMinutesPeriods\r\n            || _feesRewardInflationRate > maxInflationRate\r\n            || _tokenPriceInflationRate > maxInflationRate\r\n            || _defaultMinutesFundingPeriod < minMinutesPeriods) throw; \r\n        \r\n        uint _rulesProposalID = rulesProposals.length++;\r\n        Rules r = rulesProposals[_rulesProposalID];\r\n\r\n        r.minQuorumDivisor = _minQuorumDivisor;\r\n        r.minCommitteeFees = _minCommitteeFees;\r\n        r.minPercentageOfLikes = _minPercentageOfLikes;\r\n        r.minutesSetProposalPeriod = _minutesSetProposalPeriod;\r\n        r.minMinutesDebatePeriod = _minMinutesDebatePeriod;\r\n        r.feesRewardInflationRate = _feesRewardInflationRate;\r\n        r.defaultMinutesFundingPeriod = _defaultMinutesFundingPeriod;\r\n        r.tokenPriceInflationRate = _tokenPriceInflationRate;\r\n\r\n        r.committeeID = newCommittee(ProposalTypes.rules, _rulesProposalID, 0);\r\n\r\n        RulesProposalSubmitted(_rulesProposalID, r.committeeID, _minQuorumDivisor, _minCommitteeFees, \r\n            _minPercentageOfLikes, _minutesSetProposalPeriod, _minMinutesDebatePeriod, \r\n            _feesRewardInflationRate, _defaultMinutesFundingPeriod, _tokenPriceInflationRate);\r\n\r\n        return _rulesProposalID;\r\n    }\r\n    \r\n    function upgradeProposal(\r\n        address _newCommitteeRoom,\r\n        address _newShareManager,\r\n        address _newTokenManager,\r\n        uint _minutesDebatingPeriod\r\n    ) payable returns (uint) {\r\n        \r\n        uint _upgradeProposalID = UpgradeProposals.length++;\r\n        Upgrade u = UpgradeProposals[_upgradeProposalID];\r\n        \r\n        u.newCommitteeRoom = _newCommitteeRoom;\r\n        u.newShareManager = _newShareManager;\r\n        u.newTokenManager = _newTokenManager;\r\n\r\n        u.committeeID = newCommittee(ProposalTypes.upgrade, _upgradeProposalID, _minutesDebatingPeriod);\r\n        \r\n        UpgradeProposalSubmitted(_upgradeProposalID, u.committeeID, u.newCommitteeRoom, u.newShareManager, u.newTokenManager);\r\n        \r\n        return _upgradeProposalID;\r\n    }\r\n    \r\n// Committees management\r\n\r\n    function newCommittee(\r\n        ProposalTypes _proposalType,\r\n        uint _proposalID, \r\n        uint _minutesDebatingPeriod\r\n    ) internal returns (uint) {\r\n\r\n        if (_minutesDebatingPeriod == 0) _minutesDebatingPeriod = rulesProposals[0].minMinutesDebatePeriod;\r\n        \r\n        if (passDao.ActualCommitteeRoom() != address(this)\r\n            || msg.value < rulesProposals[0].minCommitteeFees\r\n            || now + ((rulesProposals[0].minutesSetProposalPeriod + _minutesDebatingPeriod) * 1 minutes) < now\r\n            || _minutesDebatingPeriod < rulesProposals[0].minMinutesDebatePeriod\r\n            || msg.sender == address(this)) throw;\r\n\r\n        uint _committeeID = Committees.length++;\r\n        Committee b = Committees[_committeeID];\r\n\r\n        b.creator = msg.sender;\r\n\r\n        b.proposalType = _proposalType;\r\n        b.proposalID = _proposalID;\r\n\r\n        b.fees = msg.value;\r\n        \r\n        b.setDeadline = now + (rulesProposals[0].minutesSetProposalPeriod * 1 minutes);        \r\n        b.votingDeadline = b.setDeadline + (_minutesDebatingPeriod * 1 minutes); \r\n\r\n        b.open = true; \r\n\r\n        return _committeeID;\r\n    }\r\n    \r\n    function vote(\r\n        uint _committeeID, \r\n        bool _supportsProposal) {\r\n        \r\n        Committee b = Committees[_committeeID];\r\n\r\n        if (hasVoted[_committeeID][msg.sender] \r\n            || now < b.setDeadline\r\n            || now > b.votingDeadline) throw;\r\n            \r\n        PassManager _shareManager = ShareManager();\r\n\r\n        uint _balance = uint(_shareManager.balanceOf(msg.sender));\r\n        if (_balance == 0) throw;\r\n        \r\n        hasVoted[_committeeID][msg.sender] = true;\r\n\r\n        _shareManager.blockTransfer(msg.sender, b.votingDeadline);\r\n\r\n        if (_supportsProposal) b.yea += _balance;\r\n        else b.nay += _balance; \r\n\r\n        uint _a = 100*b.fees;\r\n        if ((_a/100 != b.fees) || ((_a*_balance)/_a != _balance)) throw;\r\n        uint _multiplier = (_a*_balance)/uint(_shareManager.totalSupply());\r\n        uint _divisor = 100 + 100*rulesProposals[0].feesRewardInflationRate*(now - b.setDeadline)/(100*365 days);\r\n        uint _rewardedamount = _multiplier/_divisor;\r\n        if (b.totalRewardedAmount + _rewardedamount > b.fees) _rewardedamount = b.fees - b.totalRewardedAmount;\r\n        b.totalRewardedAmount += _rewardedamount;\r\n        if (!msg.sender.send(_rewardedamount)) throw;\r\n\r\n        Voted(_committeeID, _supportsProposal, msg.sender, _rewardedamount);    \r\n}\r\n\r\n// Decisions management\r\n\r\n    function executeDecision(uint _committeeID) returns (bool) {\r\n\r\n        Committee b = Committees[_committeeID];\r\n        \r\n        if (now < b.votingDeadline || !b.open) return;\r\n        \r\n        b.open = false;\r\n\r\n        PassManager _shareManager = ShareManager();\r\n        uint _quantityOfShares;\r\n        PassManager _tokenManager = TokenManager();\r\n\r\n        if (100*b.yea > rulesProposals[0].minPercentageOfLikes * uint(_shareManager.totalSupply())) {       \r\n            _quantityOfShares = _shareManager.rewardTokensForClient(b.creator, rulesProposals[0].minCommitteeFees);\r\n        }        \r\n\r\n        uint _sentToDaoManager = b.fees - b.totalRewardedAmount;\r\n        if (_sentToDaoManager > 0) {\r\n            if (!address(_shareManager).send(_sentToDaoManager)) throw;\r\n        }\r\n        \r\n        if (b.yea + b.nay < minQuorum() || b.yea <= b.nay) {\r\n            if (b.proposalType == ProposalTypes.contractor) Proposals[b.proposalID].open = false;\r\n            ProposalClosed(b.proposalID, b.proposalType, _committeeID, b.totalRewardedAmount, false, _quantityOfShares, _sentToDaoManager);\r\n            return;\r\n        }\r\n\r\n        b.dateOfExecution = now;\r\n\r\n        if (b.proposalType == ProposalTypes.contractor) {\r\n\r\n            Proposal p = Proposals[b.proposalID];\r\n    \r\n            if (p.contractorProposalID == 0) p.open = false;\r\n            \r\n            if (p.amountForShares == 0 && p.amountForTokens == 0) orderToContractor(b.proposalID);\r\n            else {\r\n                if (p.amountForShares != 0) {\r\n                    _shareManager.setFundingRules(p.moderator, p.initialSharePriceMultiplier, p.amountForShares, p.minutesFundingPeriod, 0, b.proposalID);\r\n                }\r\n\r\n                if (p.amountForTokens != 0) {\r\n                    _tokenManager.setFundingRules(p.moderator, 0, p.amountForTokens, p.minutesFundingPeriod, rulesProposals[0].tokenPriceInflationRate, b.proposalID);\r\n                }\r\n            }\r\n\r\n        } else if (b.proposalType == ProposalTypes.resolution) {\r\n            \r\n            Question q = ResolutionProposals[b.proposalID];\r\n            \r\n            q.project.newResolution(q.name, q.description);\r\n            \r\n        } else if (b.proposalType == ProposalTypes.rules) {\r\n\r\n            Rules r = rulesProposals[b.proposalID];\r\n            \r\n            rulesProposals[0].committeeID = r.committeeID;\r\n            rulesProposals[0].minQuorumDivisor = r.minQuorumDivisor;\r\n            rulesProposals[0].minMinutesDebatePeriod = r.minMinutesDebatePeriod; \r\n            rulesProposals[0].minCommitteeFees = r.minCommitteeFees;\r\n            rulesProposals[0].minPercentageOfLikes = r.minPercentageOfLikes;\r\n            rulesProposals[0].minutesSetProposalPeriod = r.minutesSetProposalPeriod;\r\n            rulesProposals[0].feesRewardInflationRate = r.feesRewardInflationRate;\r\n            rulesProposals[0].tokenPriceInflationRate = r.tokenPriceInflationRate;\r\n            rulesProposals[0].defaultMinutesFundingPeriod = r.defaultMinutesFundingPeriod;\r\n\r\n        } else if (b.proposalType == ProposalTypes.upgrade) {\r\n\r\n            Upgrade u = UpgradeProposals[b.proposalID];\r\n\r\n            if ((u.newShareManager != 0) && (u.newShareManager != address(_shareManager))) {\r\n                _shareManager.disableTransfer();\r\n                if (_shareManager.balance > 0) {\r\n                    if (!_shareManager.sendTo(u.newShareManager, _shareManager.balance)) throw;\r\n                }\r\n            }\r\n\r\n            if ((u.newTokenManager != 0) && (u.newTokenManager != address(_tokenManager))) {\r\n                _tokenManager.disableTransfer();\r\n            }\r\n\r\n            passDao.upgrade(u.newCommitteeRoom, u.newShareManager, u.newTokenManager);\r\n                \r\n            DappUpgraded(u.newCommitteeRoom, u.newShareManager, u.newTokenManager);\r\n            \r\n        }\r\n\r\n        ProposalClosed(b.proposalID, b.proposalType, _committeeID , b.totalRewardedAmount, true, _quantityOfShares, _sentToDaoManager);\r\n            \r\n        return true;\r\n    }\r\n    \r\n    function orderToContractor(uint _proposalID) returns (bool) {\r\n        \r\n        Proposal p = Proposals[_proposalID];\r\n        Committee b = Committees[p.committeeID];\r\n\r\n        if (b.open || !p.open) return;\r\n        \r\n        uint _amountForShares;\r\n        uint _amountForTokens;\r\n\r\n        if (p.amountForShares != 0) {\r\n            _amountForShares = ShareManager().FundedAmount(_proposalID);\r\n            if (_amountForShares == 0 && now <= b.dateOfExecution + (p.minutesFundingPeriod * 1 minutes)) return;\r\n        }\r\n\r\n        if (p.amountForTokens != 0) {\r\n            _amountForTokens = TokenManager().FundedAmount(_proposalID);\r\n            if (_amountForTokens == 0 && now <= b.dateOfExecution + (p.minutesFundingPeriod * 1 minutes)) return;\r\n        }\r\n        \r\n        p.open = false;   \r\n\r\n        uint _amount = p.amount + _amountForShares + _amountForTokens;\r\n\r\n        PassProject _project = PassProject(p.contractor.Project());\r\n\r\n        if (_amount == 0) {\r\n            ContractorProposalClosed(_proposalID, p.contractorProposalID, p.contractor, 0);\r\n            return;\r\n        }    \r\n\r\n        if (!p.contractor.order(p.contractorProposalID, _amount)) throw;\r\n        \r\n        if (p.amount + _amountForShares > 0) {\r\n            if (!ShareManager().sendTo(p.contractor, p.amount + _amountForShares)) throw;\r\n        }\r\n        if (_amountForTokens > 0) {\r\n            if (!TokenManager().sendTo(p.contractor, _amountForTokens)) throw;\r\n        }\r\n\r\n        ContractorProposalClosed(_proposalID, p.contractorProposalID, p.contractor, _amount);\r\n        \r\n        passDao.addProject(_project);\r\n        _project.newOrder(p.contractor, p.contractorProposalID, _amount);\r\n        \r\n        return true;\r\n    }\r\n\r\n// Holder Account management\r\n\r\n    function buySharesForProposal(uint _proposalID) payable returns (bool) {\r\n        \r\n        return ShareManager().buyTokensForProposal.value(msg.value)(_proposalID, msg.sender);\r\n    }   \r\n\r\n    function sendPendingAmounts(\r\n        uint _from,\r\n        uint _to,\r\n        address _buyer) returns (bool) {\r\n        \r\n        return ShareManager().sendPendingAmounts(_from, _to, _buyer);\r\n    }        \r\n    \r\n    function withdrawPendingAmounts() returns (bool) {\r\n        \r\n        if (!ShareManager().sendPendingAmounts(0, 0, msg.sender)) throw;\r\n    }        \r\n            \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"}],\"name\":\"buySharesForProposal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Committees\",\"outputs\":[{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"proposalType\",\"type\":\"uint8\"},{\"name\":\"proposalID\",\"type\":\"uint256\"},{\"name\":\"setDeadline\",\"type\":\"uint256\"},{\"name\":\"fees\",\"type\":\"uint256\"},{\"name\":\"totalRewardedAmount\",\"type\":\"uint256\"},{\"name\":\"votingDeadline\",\"type\":\"uint256\"},{\"name\":\"open\",\"type\":\"bool\"},{\"name\":\"dateOfExecution\",\"type\":\"uint256\"},{\"name\":\"yea\",\"type\":\"uint256\"},{\"name\":\"nay\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ResolutionProposals\",\"outputs\":[{\"name\":\"committeeID\",\"type\":\"uint256\"},{\"name\":\"project\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"description\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_committeeID\",\"type\":\"uint256\"},{\"name\":\"_shareHolder\",\"type\":\"address\"}],\"name\":\"HasVoted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_committeeID\",\"type\":\"uint256\"}],\"name\":\"executeDecision\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxInflationRate\",\"type\":\"uint256\"},{\"name\":\"_minMinutesPeriods\",\"type\":\"uint256\"},{\"name\":\"_minQuorumDivisor\",\"type\":\"uint256\"},{\"name\":\"_minCommitteeFees\",\"type\":\"uint256\"},{\"name\":\"_minPercentageOfLikes\",\"type\":\"uint256\"},{\"name\":\"_minutesSetProposalPeriod\",\"type\":\"uint256\"},{\"name\":\"_minMinutesDebatePeriod\",\"type\":\"uint256\"},{\"name\":\"_feesRewardInflationRate\",\"type\":\"uint256\"},{\"name\":\"_tokenPriceInflationRate\",\"type\":\"uint256\"},{\"name\":\"_defaultMinutesFundingPeriod\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"passDao\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"uint256\"},{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"sendPendingAmounts\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfCommittees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPendingAmounts\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_contractor\",\"type\":\"address\"},{\"name\":\"_contractorProposalID\",\"type\":\"uint256\"},{\"name\":\"_proposalDescription\",\"type\":\"string\"},{\"name\":\"_hashOfTheContractorProposalDocument\",\"type\":\"bytes32\"},{\"name\":\"_moderator\",\"type\":\"address\"},{\"name\":\"_initialSharePriceMultiplier\",\"type\":\"uint256\"},{\"name\":\"_minutesFundingPeriod\",\"type\":\"uint256\"},{\"name\":\"_minutesDebatingPeriod\",\"type\":\"uint256\"}],\"name\":\"contractorProposal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minQuorumDivisor\",\"type\":\"uint256\"},{\"name\":\"_minCommitteeFees\",\"type\":\"uint256\"},{\"name\":\"_minPercentageOfLikes\",\"type\":\"uint256\"},{\"name\":\"_minutesSetProposalPeriod\",\"type\":\"uint256\"},{\"name\":\"_minMinutesDebatePeriod\",\"type\":\"uint256\"},{\"name\":\"_feesRewardInflationRate\",\"type\":\"uint256\"},{\"name\":\"_defaultMinutesFundingPeriod\",\"type\":\"uint256\"},{\"name\":\"_tokenPriceInflationRate\",\"type\":\"uint256\"}],\"name\":\"rulesProposal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rulesProposals\",\"outputs\":[{\"name\":\"committeeID\",\"type\":\"uint256\"},{\"name\":\"minQuorumDivisor\",\"type\":\"uint256\"},{\"name\":\"minCommitteeFees\",\"type\":\"uint256\"},{\"name\":\"minPercentageOfLikes\",\"type\":\"uint256\"},{\"name\":\"minutesSetProposalPeriod\",\"type\":\"uint256\"},{\"name\":\"minMinutesDebatePeriod\",\"type\":\"uint256\"},{\"name\":\"feesRewardInflationRate\",\"type\":\"uint256\"},{\"name\":\"tokenPriceInflationRate\",\"type\":\"uint256\"},{\"name\":\"defaultMinutesFundingPeriod\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_description\",\"type\":\"string\"},{\"name\":\"_project\",\"type\":\"address\"},{\"name\":\"_minutesDebatingPeriod\",\"type\":\"uint256\"}],\"name\":\"resolutionProposal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"UpgradeProposals\",\"outputs\":[{\"name\":\"committeeID\",\"type\":\"uint256\"},{\"name\":\"newCommitteeRoom\",\"type\":\"address\"},{\"name\":\"newShareManager\",\"type\":\"address\"},{\"name\":\"newTokenManager\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minQuorum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"}],\"name\":\"orderToContractor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TokenManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_committeeID\",\"type\":\"uint256\"},{\"name\":\"_supportsProposal\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Proposals\",\"outputs\":[{\"name\":\"committeeID\",\"type\":\"uint256\"},{\"name\":\"contractor\",\"type\":\"address\"},{\"name\":\"contractorProposalID\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"moderator\",\"type\":\"address\"},{\"name\":\"amountForShares\",\"type\":\"uint256\"},{\"name\":\"initialSharePriceMultiplier\",\"type\":\"uint256\"},{\"name\":\"amountForTokens\",\"type\":\"uint256\"},{\"name\":\"minutesFundingPeriod\",\"type\":\"uint256\"},{\"name\":\"open\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCommitteeRoom\",\"type\":\"address\"},{\"name\":\"_newShareManager\",\"type\":\"address\"},{\"name\":\"_newTokenManager\",\"type\":\"address\"},{\"name\":\"_minutesDebatingPeriod\",\"type\":\"uint256\"}],\"name\":\"upgradeProposal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ShareManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractorCreator\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_metaProject\",\"type\":\"bool\"},{\"name\":\"_passProject\",\"type\":\"address\"},{\"name\":\"_projectName\",\"type\":\"string\"},{\"name\":\"_projectDescription\",\"type\":\"string\"}],\"name\":\"createContractor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_passDao\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"maxInflationRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"minMinutesPeriods\",\"type\":\"uint256\"}],\"name\":\"CommitteeLimits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"Creator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"Sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"Contractor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"Recipient\",\"type\":\"address\"}],\"name\":\"ContractorCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ProposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"CommitteeID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"Contractor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"ContractorProposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"Description\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"Moderator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"SharePriceMultiplier\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"MinutesFundingPeriod\",\"type\":\"uint256\"}],\"name\":\"ProposalSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"QuestionID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"CommitteeID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"Project\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"Name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"Description\",\"type\":\"string\"}],\"name\":\"ResolutionProposalSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"rulesProposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"CommitteeID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"MinQuorumDivisor\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"MinCommitteeFees\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"MinPercentageOfLikes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"MinutesSetProposalPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"MinMinutesDebatePeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"FeesRewardInflationRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"DefaultMinutesFundingPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"TokenPriceInflationRate\",\"type\":\"uint256\"}],\"name\":\"RulesProposalSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"UpgradeProposalID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"CommitteeID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"NewCommitteeRoom\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"NewShareManager\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"NewTokenManager\",\"type\":\"address\"}],\"name\":\"UpgradeProposalSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"CommitteeID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"Position\",\"type\":\"bool\"},{\"indexed\":true,\"name\":\"Voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"RewardedAmount\",\"type\":\"uint256\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ProposalID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"ProposalType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"CommitteeID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"TotalRewardedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ProposalExecuted\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"RewardedSharesAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"SentToManager\",\"type\":\"uint256\"}],\"name\":\"ProposalClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ProposalID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"ContractorProposalID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"Contractor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"AmountSent\",\"type\":\"uint256\"}],\"name\":\"ContractorProposalClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"NewCommitteeRoom\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"NewShareManager\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"NewTokenManager\",\"type\":\"address\"}],\"name\":\"DappUpgraded\",\"type\":\"event\"}]","ContractName":"PassCommitteeRoom","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ad2d970edff30d8f166989470aaf4be3ff6375ae","Library":"","SwarmSource":"bzzr://15045f8597bb52bec234682d2c2015fdf1afa695f3a5133afee09f126ea88293"}]}