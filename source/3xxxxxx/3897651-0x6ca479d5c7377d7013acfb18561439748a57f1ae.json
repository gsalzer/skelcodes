{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n contract SafeMathLib {\r\n\r\n  function safeMul(uint a, uint b) returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a);\r\n    return c;\r\n  }\r\n\r\n  function assert(bool assertion) private {\r\n    if (!assertion) throw;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  modifier onlyOwner() {\r\n    if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract ERC20Basic {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function transfer(address _to, uint _value) returns (bool success);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n  function approve(address _spender, uint _value) returns (bool success);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract FractionalERC20 is ERC20 {\r\n\r\n  uint public decimals;\r\n\r\n}\r\n\r\ncontract StandardToken is ERC20, SafeMathLib{\r\n  \r\n  event Minted(address receiver, uint amount);\r\n\r\n  \r\n  mapping(address => uint) balances;\r\n\r\n  \r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  modifier onlyPayloadSize(uint size) {\r\n     if(msg.data.length != size + 4) {\r\n       throw;\r\n     }\r\n     _;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\n   \r\n   \r\n    balances[msg.sender] = safeSub(balances[msg.sender],_value);\r\n    balances[_to] = safeAdd(balances[_to],_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n    uint _allowance = allowed[_from][msg.sender];\r\n\r\n    balances[_to] = safeAdd(balances[_to],_value);\r\n    balances[_from] = safeSub(balances[_from],_value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance,_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n function addApproval(address _spender, uint _addedValue)\r\n  onlyPayloadSize(2 * 32)\r\n  returns (bool success) {\r\n      uint oldValue = allowed[msg.sender][_spender];\r\n      allowed[msg.sender][_spender] = safeAdd(oldValue,_addedValue);\r\n      Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n      return true;\r\n  }\r\n\r\n  function subApproval(address _spender, uint _subtractedValue)\r\n  onlyPayloadSize(2 * 32)\r\n  returns (bool success) {\r\n\r\n      uint oldVal = allowed[msg.sender][_spender];\r\n\r\n      if (_subtractedValue > oldVal) {\r\n          allowed[msg.sender][_spender] = 0;\r\n      } else {\r\n          allowed[msg.sender][_spender] = safeSub(oldVal,_subtractedValue);\r\n      }\r\n      Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n      return true;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\ncontract UpgradeAgent {\r\n\r\n  uint public originalSupply;\r\n\r\n  \r\n  function isUpgradeAgent() public constant returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  function upgradeFrom(address _from, uint256 _value) public;\r\n\r\n}\r\n\r\n\r\n\r\n contract UpgradeableToken is StandardToken {\r\n\r\n  \r\n  address public upgradeMaster;\r\n\r\n  \r\n  UpgradeAgent public upgradeAgent;\r\n\r\n  \r\n  uint256 public totalUpgraded;\r\n\r\n  \r\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\r\n\r\n  \r\n  event Upgrade(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n  \r\n  event UpgradeAgentSet(address agent);\r\n\r\n  \r\n  function UpgradeableToken(address _upgradeMaster) {\r\n    upgradeMaster = _upgradeMaster;\r\n  }\r\n\r\n  \r\n  function upgrade(uint256 value) public {\r\n\r\n      UpgradeState state = getUpgradeState();\r\n      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\r\n        \r\n        throw;\r\n      }\r\n\r\n      \r\n      if (value == 0) throw;\r\n\r\n      balances[msg.sender] = safeSub(balances[msg.sender],value);\r\n\r\n      \r\n      totalSupply = safeSub(totalSupply,value);\r\n      totalUpgraded = safeAdd(totalUpgraded,value);\r\n\r\n      \r\n      upgradeAgent.upgradeFrom(msg.sender, value);\r\n      Upgrade(msg.sender, upgradeAgent, value);\r\n  }\r\n\r\n \r\n  function setUpgradeAgent(address agent) external {\r\n\r\n      if(!canUpgrade()) {\r\n        \r\n        throw;\r\n      }\r\n\r\n      if (agent == 0x0) throw;\r\n      \r\n      if (msg.sender != upgradeMaster) throw;\r\n      \r\n      if (getUpgradeState() == UpgradeState.Upgrading) throw;\r\n\r\n      upgradeAgent = UpgradeAgent(agent);\r\n\r\n      \r\n      if(!upgradeAgent.isUpgradeAgent()) throw;\r\n      \r\n      if (upgradeAgent.originalSupply() != totalSupply) throw;\r\n\r\n      UpgradeAgentSet(upgradeAgent);\r\n  }\r\n\r\n  function getUpgradeState() public constant returns(UpgradeState) {\r\n    if(!canUpgrade()) return UpgradeState.NotAllowed;\r\n    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\r\n    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\r\n    else return UpgradeState.Upgrading;\r\n  }\r\n\r\n  \r\n  function setUpgradeMaster(address master) public {\r\n      if (master == 0x0) throw;\r\n      if (msg.sender != upgradeMaster) throw;\r\n      upgradeMaster = master;\r\n  }\r\n\r\n  \r\n  function canUpgrade() public constant returns(bool) {\r\n     return true;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract ReleasableToken is ERC20, Ownable {\r\n\r\n  \r\n  address public releaseAgent;\r\n\r\n  \r\n  bool public released = false;\r\n\r\n  \r\n  mapping (address => bool) public transferAgents;\r\n\r\n\r\n  modifier canTransfer(address _sender) {\r\n\r\n    if(!released) {\r\n        if(!transferAgents[_sender]) {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    _;\r\n  }\r\n\r\n\r\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\r\n    releaseAgent = addr;\r\n  }\r\n\r\n\r\n  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\r\n    transferAgents[addr] = state;\r\n  }\r\n\r\n\r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\n    released = true;\r\n  }\r\n\r\n  \r\n  modifier inReleaseState(bool releaseState) {\r\n    if(releaseState != released) {\r\n        throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  \r\n  modifier onlyReleaseAgent() {\r\n    if(msg.sender != releaseAgent) {\r\n        throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\r\n    \r\n   return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\r\n    \r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n}\r\n\r\ncontract MintableToken is StandardToken, Ownable {\r\n\r\n  bool public mintingFinished = false;\r\n\r\n  \r\n  mapping (address => bool) public mintAgents;\r\n\r\n  event MintingAgentChanged(address addr, bool state  );\r\n\r\n\r\n  function mint(address receiver, uint amount) onlyMintAgent canMint public {\r\n    totalSupply = safeAdd(totalSupply,amount);\r\n    balances[receiver] = safeAdd(balances[receiver],amount);\r\n\r\n\r\n    Transfer(0, receiver, amount);\r\n  }\r\n\r\n\r\n  function setMintAgent(address addr, bool state) onlyOwner canMint public {\r\n    mintAgents[addr] = state;\r\n    MintingAgentChanged(addr, state);\r\n  }\r\n\r\n  modifier onlyMintAgent() {\r\n    \r\n    if(!mintAgents[msg.sender]) {\r\n        throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  \r\n  modifier canMint() {\r\n    if(mintingFinished) throw;\r\n    _;\r\n  }\r\n}\r\n\r\n\r\ncontract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken {\r\n\r\n  event UpdatedTokenInformation(string newName, string newSymbol);\r\n\r\n  string public name;\r\n\r\n  string public symbol;\r\n\r\n  uint public decimals;\r\n\r\n  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)\r\n    UpgradeableToken(msg.sender) {\r\n\r\n    owner = msg.sender;\r\n\r\n    name = _name;\r\n    symbol = _symbol;\r\n\r\n    totalSupply = _initialSupply;\r\n\r\n    decimals = _decimals;\r\n\r\n    \r\n    balances[owner] = totalSupply;\r\n\r\n    if(totalSupply > 0) {\r\n      Minted(owner, totalSupply);\r\n    }\r\n\r\n    \r\n    if(!_mintable) {\r\n      mintingFinished = true;\r\n      if(totalSupply == 0) {\r\n        throw; \r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\n    mintingFinished = true;\r\n    super.releaseTokenTransfer();\r\n  }\r\n\r\n\r\n  function canUpgrade() public constant returns(bool) {\r\n    return released && super.canUpgrade();\r\n  }\r\n\r\n\r\n  function setTokenInformation(string _name, string _symbol) onlyOwner {\r\n    name = _name;\r\n    symbol = _symbol;\r\n\r\n    UpdatedTokenInformation(name, symbol);\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract FinalizeAgent {\r\n\r\n  function isFinalizeAgent() public constant returns(bool) {\r\n    return true;\r\n  }\r\n  function isSane() public constant returns (bool);\r\n  function finalizeCrowdsale();\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n contract PricingStrategy {\r\n  function isPricingStrategy() public constant returns (bool) {\r\n    return true;\r\n  }\r\n  function isSane(address crowdsale) public constant returns (bool) {\r\n    return true;\r\n  }\r\n  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n contract Haltable is Ownable {\r\n  bool public halted;\r\n\r\n  modifier stopInEmergency {\r\n    if (halted) throw;\r\n    _;\r\n  }\r\n\r\n  modifier onlyInEmergency {\r\n    if (!halted) throw;\r\n    _;\r\n  }\r\n  function halt() external onlyOwner {\r\n    halted = true;\r\n  }\r\n  function unhalt() external onlyOwner onlyInEmergency {\r\n    halted = false;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\ncontract Crowdsale is Haltable, SafeMathLib {\r\n  FractionalERC20 public token;\r\n  PricingStrategy public pricingStrategy;\r\n  FinalizeAgent public finalizeAgent;\r\n  address public multisigWallet;\r\n  uint public minimumFundingGoal;\r\n  uint public startsAt;\r\n  uint public endsAt;\r\n  uint public tokensSold = 0;\r\n  uint public weiRaised = 0;\r\n  uint public investorCount = 0;\r\n  uint public loadedRefund = 0;\r\n  uint public weiRefunded = 0;\r\n  bool public finalized;\r\n  bool public requireCustomerId;\r\n  bool public requiredSignedAddress;\r\n  address public signerAddress;\r\n  mapping (address => uint256) public investedAmountOf;\r\n  mapping (address => uint256) public tokenAmountOf;\r\n  mapping (address => bool) public earlyParticipantWhitelist;\r\n  uint public ownerTestValue;\r\n  enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\r\n  event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\r\n  event Refund(address investor, uint weiAmount);\r\n  event InvestmentPolicyChanged(bool requireCustomerId, bool requiredSignedAddress, address signerAddress);\r\n  event Whitelisted(address addr, bool status);\r\n  event EndsAtChanged(uint endsAt);\r\n\r\n  function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) {\r\n\r\n    owner = msg.sender;\r\n\r\n    token = FractionalERC20(_token);\r\n\r\n    setPricingStrategy(_pricingStrategy);\r\n\r\n    multisigWallet = _multisigWallet;\r\n    if(multisigWallet == 0) {\r\n        throw;\r\n    }\r\n\r\n    if(_start == 0) {\r\n        throw;\r\n    }\r\n\r\n    startsAt = _start;\r\n\r\n    if(_end == 0) {\r\n        throw;\r\n    }\r\n\r\n    endsAt = _end;\r\n    if(startsAt >= endsAt) {\r\n        throw;\r\n    }\r\n    minimumFundingGoal = _minimumFundingGoal;\r\n  }\r\n  function() payable {\r\n    throw;\r\n  }\r\n  function investInternal(address receiver, uint128 customerId) stopInEmergency private {\r\n    if(getState() == State.PreFunding) {\r\n      if(!earlyParticipantWhitelist[receiver]) {\r\n        throw;\r\n      }\r\n    } else if(getState() == State.Funding) {\r\n    } else {\r\n      throw;\r\n    }\r\n\r\n    uint weiAmount = msg.value;\r\n    uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\r\n\r\n    if(tokenAmount == 0) {\r\n      throw;\r\n    }\r\n\r\n    if(investedAmountOf[receiver] == 0) {\r\n       investorCount++;\r\n    }\r\n    investedAmountOf[receiver] = safeAdd(investedAmountOf[receiver],weiAmount);\r\n    tokenAmountOf[receiver] = safeAdd(tokenAmountOf[receiver],tokenAmount);\r\n    weiRaised = safeAdd(weiRaised,weiAmount);\r\n    tokensSold = safeAdd(tokensSold,tokenAmount);\r\n    if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\r\n      throw;\r\n    }\r\n\r\n    assignTokens(receiver, tokenAmount);\r\n    if(!multisigWallet.send(weiAmount)) throw;\r\n    Invested(receiver, weiAmount, tokenAmount, customerId);\r\n  }\r\n  function preallocate(address receiver, uint fullTokens, uint weiPrice) public onlyOwner {\r\n\r\n    uint tokenAmount = fullTokens * 10**token.decimals();\r\n    uint weiAmount = weiPrice * fullTokens;\r\n\r\n    weiRaised = safeAdd(weiRaised,weiAmount);\r\n    tokensSold = safeAdd(tokensSold,tokenAmount);\r\n\r\n    investedAmountOf[receiver] = safeAdd(investedAmountOf[receiver],weiAmount);\r\n    tokenAmountOf[receiver] = safeAdd(tokenAmountOf[receiver],tokenAmount);\r\n\r\n    assignTokens(receiver, tokenAmount);\r\n    Invested(receiver, weiAmount, tokenAmount, 0);\r\n  }\r\n  function investWithSignedAddress(address addr, uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\r\n     bytes32 hash = sha256(addr);\r\n     if (ecrecover(hash, v, r, s) != signerAddress) throw;\r\n     if(customerId == 0) throw;\r\n     investInternal(addr, customerId);\r\n  }\r\n  function investWithCustomerId(address addr, uint128 customerId) public payable {\r\n    if(requiredSignedAddress) throw;\r\n    if(customerId == 0) throw;\r\n    investInternal(addr, customerId);\r\n  }\r\n  function invest(address addr) public payable {\r\n    if(requireCustomerId) throw;\r\n    if(requiredSignedAddress) throw;\r\n    investInternal(addr, 0);\r\n  }\r\n  function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\r\n    investWithSignedAddress(msg.sender, customerId, v, r, s);\r\n  }\r\n  function buyWithCustomerId(uint128 customerId) public payable {\r\n    investWithCustomerId(msg.sender, customerId);\r\n  }\r\n  function buy() public payable {\r\n    invest(msg.sender);\r\n  }\r\n  function finalize() public inState(State.Success) onlyOwner stopInEmergency {\r\n    if(finalized) {\r\n      throw;\r\n    }\r\n    if(address(finalizeAgent) != 0) {\r\n      finalizeAgent.finalizeCrowdsale();\r\n    }\r\n\r\n    finalized = true;\r\n  }\r\n  function setFinalizeAgent(FinalizeAgent addr) onlyOwner {\r\n    finalizeAgent = addr;\r\n    if(!finalizeAgent.isFinalizeAgent()) {\r\n      throw;\r\n    }\r\n  }\r\n  function setRequireCustomerId(bool value) onlyOwner {\r\n    requireCustomerId = value;\r\n    InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\r\n  }\r\n  function setRequireSignedAddress(bool value, address _signerAddress) onlyOwner {\r\n    requiredSignedAddress = value;\r\n    signerAddress = _signerAddress;\r\n    InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\r\n  }\r\n  function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner {\r\n    earlyParticipantWhitelist[addr] = status;\r\n    Whitelisted(addr, status);\r\n  }\r\n  function setEndsAt(uint time) onlyOwner {\r\n\r\n    if(now > time) {\r\n      throw;\r\n    }\r\n\r\n    endsAt = time;\r\n    EndsAtChanged(endsAt);\r\n  }\r\n  function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner {\r\n    pricingStrategy = _pricingStrategy;\r\n    if(!pricingStrategy.isPricingStrategy()) {\r\n      throw;\r\n    }\r\n  }\r\n  function loadRefund() public payable inState(State.Failure) {\r\n    if(msg.value == 0) throw;\r\n    loadedRefund = safeAdd(loadedRefund,msg.value);\r\n  }\r\n  function refund() public inState(State.Refunding) {\r\n    uint256 weiValue = investedAmountOf[msg.sender];\r\n    if (weiValue == 0) throw;\r\n    investedAmountOf[msg.sender] = 0;\r\n    weiRefunded = safeAdd(weiRefunded,weiValue);\r\n    Refund(msg.sender, weiValue);\r\n    if (!msg.sender.send(weiValue)) throw;\r\n  }\r\n  function isMinimumGoalReached() public constant returns (bool reached) {\r\n    return weiRaised >= minimumFundingGoal;\r\n  }\r\n  function isFinalizerSane() public constant returns (bool sane) {\r\n    return finalizeAgent.isSane();\r\n  }\r\n  function isPricingSane() public constant returns (bool sane) {\r\n    return pricingStrategy.isSane(address(this));\r\n  }\r\n  function getState() public constant returns (State) {\r\n    if(finalized) return State.Finalized;\r\n    else if (address(finalizeAgent) == 0) return State.Preparing;\r\n    else if (!finalizeAgent.isSane()) return State.Preparing;\r\n    else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\r\n    else if (block.timestamp < startsAt) return State.PreFunding;\r\n    else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\r\n    else if (isMinimumGoalReached()) return State.Success;\r\n    else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\r\n    else return State.Failure;\r\n  }\r\n  function setOwnerTestValue(uint val) onlyOwner {\r\n    ownerTestValue = val;\r\n  }\r\n  function isCrowdsale() public constant returns (bool) {\r\n    return true;\r\n  }\r\n  modifier inState(State state) {\r\n    if(getState() != state) throw;\r\n    _;\r\n  }\r\n  function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken);\r\n  function isCrowdsaleFull() public constant returns (bool);\r\n  function assignTokens(address receiver, uint tokenAmount) private;\r\n}\r\n\r\n\r\ncontract BonusFinalizeAgent is FinalizeAgent,SafeMathLib {\r\n\r\n  CrowdsaleToken public token;\r\n  Crowdsale public crowdsale;\r\n  uint public totalMembers;\r\n  uint public allocatedBonus;\r\n  mapping (address=>uint) bonusOf;\r\n  address[] public teamAddresses;\r\n\r\n\r\n  function BonusFinalizeAgent(CrowdsaleToken _token, Crowdsale _crowdsale, uint[] _bonusBasePoints, address[] _teamAddresses) {\r\n    token = _token;\r\n    crowdsale = _crowdsale;\r\n    if(address(crowdsale) == 0) {\r\n      throw;\r\n    }\r\n    if(_bonusBasePoints.length != _teamAddresses.length){\r\n      throw;\r\n    }\r\n\r\n    totalMembers = _teamAddresses.length;\r\n    teamAddresses = _teamAddresses;\r\n    for (uint i=0;i<totalMembers;i++){\r\n      if(_bonusBasePoints[i] == 0) throw;\r\n    }\r\n    for (uint j=0;j<totalMembers;j++){\r\n      if(_teamAddresses[j] == 0) throw;\r\n      bonusOf[_teamAddresses[j]] = _bonusBasePoints[j];\r\n    }\r\n  }\r\n  function isSane() public constant returns (bool) {\r\n    return (token.mintAgents(address(this)) == true) && (token.releaseAgent() == address(this));\r\n  }\r\n  function finalizeCrowdsale() {\r\n    if(msg.sender != address(crowdsale)) {\r\n      throw;\r\n    }\r\n    uint tokensSold = crowdsale.tokensSold();\r\n\r\n    for (uint i=0;i<totalMembers;i++){\r\n      allocatedBonus = safeMul(tokensSold,bonusOf[teamAddresses[i]]) / 10000;\r\n      token.mint(teamAddresses[i], allocatedBonus);\r\n    }\r\n    token.releaseTokenTransfer();\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"finalizeCrowdsale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teamAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalizeAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allocatedBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalMembers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSane\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeSub\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeMul\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_crowdsale\",\"type\":\"address\"},{\"name\":\"_bonusBasePoints\",\"type\":\"uint256[]\"},{\"name\":\"_teamAddresses\",\"type\":\"address[]\"}],\"payable\":false,\"type\":\"constructor\"}]","ContractName":"BonusFinalizeAgent","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000b1724cc9fda0186911ef6a75949e9c0d3f0f2f300000000000000000000000039df5af51c47256e5c63b3dae1a21f3da4a58e89000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000024c000000000000000000000000000000000000000000000000000000000000024c00000000000000000000000000000000000000000000000000000000000001fb000000000000000000000000000000000000000000000000000000000000000f0000000000000000000000000000000000000000000000000000000000000004000000000000000000000000fbdae352c530b6c9091089d5762989e34f416ec1000000000000000000000000448f86da428839c975d69ff79720d19fb6cce78f000000000000000000000000f567ab113a1235508dccf4d4a8ec7a835812e8f2000000000000000000000000efdd9035103b73cf8b2f6a0a3ec8fa41c37d8977","Library":"","SwarmSource":"bzzr://a110f649d073a87326653b4b34ea716001a60ea0476cf18475b2e69a85a24e27"}]}