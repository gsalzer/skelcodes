{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\ncontract Ownable {\r\n  // replace with proper zeppelin smart contract\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    if (msg.sender != owner)\r\n      throw;\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0))\r\n      owner = newOwner;\r\n  }\r\n}\r\n\r\n\r\ncontract Destructable is Ownable {\r\n  function selfdestruct() external onlyOwner {\r\n    // free ethereum network state when done\r\n    selfdestruct(owner);\r\n  }\r\n}\r\n\r\n\r\ncontract Math {\r\n  // scale of the emulated fixed point operations\r\n  uint constant public FP_SCALE = 10000;\r\n\r\n  // todo: should be a library\r\n  function divRound(uint v, uint d) internal constant returns(uint) {\r\n    // round up if % is half or more\r\n    return (v + (d/2)) / d;\r\n  }\r\n\r\n  function absDiff(uint v1, uint v2) public constant returns(uint) {\r\n    return v1 > v2 ? v1 - v2 : v2 - v1;\r\n  }\r\n\r\n  function safeMul(uint a, uint b) public constant returns (uint) {\r\n    uint c = a * b;\r\n    if (a == 0 || c / a == b)\r\n      return c;\r\n    else\r\n      throw;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal constant returns (uint) {\r\n    uint c = a + b;\r\n    if (!(c>=a && c>=b))\r\n      throw;\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ncontract TimeSource {\r\n  uint32 private mockNow;\r\n\r\n  function currentTime() public constant returns (uint32) {\r\n    // we do not support dates much into future (Sun, 07 Feb 2106 06:28:15 GMT)\r\n    if (block.timestamp > 0xFFFFFFFF)\r\n      throw;\r\n    return mockNow > 0 ? mockNow : uint32(block.timestamp);\r\n  }\r\n\r\n  function mockTime(uint32 t) public {\r\n    // no mocking on mainnet\r\n    if (block.number > 3316029)\r\n      throw;\r\n    mockNow = t;\r\n  }\r\n}\r\n\r\n\r\ncontract BaseOptionsConverter {\r\n\r\n  // modifiers are inherited, check `owned` pattern\r\n  //   http://solidity.readthedocs.io/en/develop/contracts.html#function-modifiers\r\n  modifier onlyESOP() {\r\n    if (msg.sender != getESOP())\r\n      throw;\r\n    _;\r\n  }\r\n\r\n  // returns ESOP address which is a sole executor of exerciseOptions function\r\n  function getESOP() public constant returns (address);\r\n  // deadline for employees to exercise options\r\n  function getExercisePeriodDeadline() public constant returns (uint32);\r\n\r\n  // exercise of options for given employee and amount, please note that employee address may be 0\r\n  // .. in which case the intention is to burn options\r\n  function exerciseOptions(address employee, uint poolOptions, uint extraOptions, uint bonusOptions,\r\n    bool agreeToAcceleratedVestingBonusConditions) onlyESOP public;\r\n}\r\n\r\ncontract ESOPTypes {\r\n  // enums are numbered starting from 0. NotSet is used to check for non existing mapping\r\n  enum EmployeeState { NotSet, WaitingForSignature, Employed, Terminated, OptionsExercised }\r\n  // please note that 32 bit unsigned int is used to represent UNIX time which is enough to represent dates until Sun, 07 Feb 2106 06:28:15 GMT\r\n  // storage access is optimized so struct layout is important\r\n  struct Employee {\r\n      // when vesting starts\r\n      uint32 issueDate;\r\n      // wait for employee signature until that time\r\n      uint32 timeToSign;\r\n      // date when employee was terminated, 0 for not terminated\r\n      uint32 terminatedAt;\r\n      // when fade out starts, 0 for not set, initally == terminatedAt\r\n      // used only when calculating options returned to pool\r\n      uint32 fadeoutStarts;\r\n      // poolOptions employee gets (exit bonus not included)\r\n      uint32 poolOptions;\r\n      // extra options employee gets (neufund will not this option)\r\n      uint32 extraOptions;\r\n      // time at which employee got suspended, 0 - not suspended\r\n      uint32 suspendedAt;\r\n      // what is employee current status, takes 8 bit in storage\r\n      EmployeeState state;\r\n      // index in iterable mapping\r\n      uint16 idx;\r\n      // reserve until full 256 bit word\r\n      //uint24 reserved;\r\n  }\r\n\r\n  function serializeEmployee(Employee memory employee)\r\n    internal\r\n    constant\r\n    returns(uint[9] emp)\r\n  {\r\n      // guess what: struct layout in memory is aligned to word (256 bits)\r\n      // struct in storage is byte aligned\r\n      assembly {\r\n        // return memory aligned struct as array of words\r\n        // I just wonder when 'employee' memory is deallocated\r\n        // answer: memory is not deallocated until transaction ends\r\n        emp := employee\r\n      }\r\n  }\r\n\r\n  function deserializeEmployee(uint[9] serializedEmployee)\r\n    internal\r\n    constant\r\n    returns (Employee memory emp)\r\n  {\r\n      assembly { emp := serializedEmployee }\r\n  }\r\n}\r\n\r\n\r\ncontract CodeUpdateable is Ownable {\r\n    // allows to stop operations and migrate data to different contract\r\n    enum CodeUpdateState { CurrentCode, OngoingUpdate /*, CodeUpdated*/}\r\n    CodeUpdateState public codeUpdateState;\r\n\r\n    modifier isCurrentCode() {\r\n      if (codeUpdateState != CodeUpdateState.CurrentCode)\r\n        throw;\r\n      _;\r\n    }\r\n\r\n    modifier inCodeUpdate() {\r\n      if (codeUpdateState != CodeUpdateState.OngoingUpdate)\r\n        throw;\r\n      _;\r\n    }\r\n\r\n    function beginCodeUpdate() public onlyOwner isCurrentCode {\r\n      codeUpdateState = CodeUpdateState.OngoingUpdate;\r\n    }\r\n\r\n    function cancelCodeUpdate() public onlyOwner inCodeUpdate {\r\n      codeUpdateState = CodeUpdateState.CurrentCode;\r\n    }\r\n\r\n    function completeCodeUpdate() public onlyOwner inCodeUpdate {\r\n      selfdestruct(owner);\r\n    }\r\n}\r\n\r\ncontract EmployeesList is ESOPTypes, Ownable, Destructable {\r\n  event CreateEmployee(address indexed e, uint32 poolOptions, uint32 extraOptions, uint16 idx);\r\n  event UpdateEmployee(address indexed e, uint32 poolOptions, uint32 extraOptions, uint16 idx);\r\n  event ChangeEmployeeState(address indexed e, EmployeeState oldState, EmployeeState newState);\r\n  event RemoveEmployee(address indexed e);\r\n  mapping (address => Employee) employees;\r\n  // addresses in the mapping, ever\r\n  address[] public addresses;\r\n\r\n  function size() external constant returns (uint16) {\r\n    return uint16(addresses.length);\r\n  }\r\n\r\n  function setEmployee(address e, uint32 issueDate, uint32 timeToSign, uint32 terminatedAt, uint32 fadeoutStarts,\r\n    uint32 poolOptions, uint32 extraOptions, uint32 suspendedAt, EmployeeState state)\r\n    external\r\n    onlyOwner\r\n    returns (bool isNew)\r\n  {\r\n    uint16 empIdx = employees[e].idx;\r\n    if (empIdx == 0) {\r\n      // new element\r\n      uint size = addresses.length;\r\n      if (size == 0xFFFF)\r\n        throw;\r\n      isNew = true;\r\n      empIdx = uint16(size + 1);\r\n      addresses.push(e);\r\n      CreateEmployee(e, poolOptions, extraOptions, empIdx);\r\n    } else {\r\n      isNew = false;\r\n      UpdateEmployee(e, poolOptions, extraOptions, empIdx);\r\n    }\r\n    employees[e] = Employee({\r\n        issueDate: issueDate,\r\n        timeToSign: timeToSign,\r\n        terminatedAt: terminatedAt,\r\n        fadeoutStarts: fadeoutStarts,\r\n        poolOptions: poolOptions,\r\n        extraOptions: extraOptions,\r\n        suspendedAt: suspendedAt,\r\n        state: state,\r\n        idx: empIdx\r\n      });\r\n  }\r\n\r\n  function changeState(address e, EmployeeState state)\r\n    external\r\n    onlyOwner\r\n  {\r\n    if (employees[e].idx == 0)\r\n      throw;\r\n    ChangeEmployeeState(e, employees[e].state, state);\r\n    employees[e].state = state;\r\n  }\r\n\r\n  function setFadeoutStarts(address e, uint32 fadeoutStarts)\r\n    external\r\n    onlyOwner\r\n  {\r\n    if (employees[e].idx == 0)\r\n      throw;\r\n    UpdateEmployee(e, employees[e].poolOptions, employees[e].extraOptions, employees[e].idx);\r\n    employees[e].fadeoutStarts = fadeoutStarts;\r\n  }\r\n\r\n  function removeEmployee(address e)\r\n    external\r\n    onlyOwner\r\n    returns (bool)\r\n  {\r\n    uint16 empIdx = employees[e].idx;\r\n    if (empIdx > 0) {\r\n        delete employees[e];\r\n        delete addresses[empIdx-1];\r\n        RemoveEmployee(e);\r\n        return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function terminateEmployee(address e, uint32 issueDate, uint32 terminatedAt, uint32 fadeoutStarts, EmployeeState state)\r\n    external\r\n    onlyOwner\r\n  {\r\n    if (state != EmployeeState.Terminated)\r\n        throw;\r\n    Employee employee = employees[e]; // gets reference to storage and optimizer does it with one SSTORE\r\n    if (employee.idx == 0)\r\n      throw;\r\n    ChangeEmployeeState(e, employee.state, state);\r\n    employee.state = state;\r\n    employee.issueDate = issueDate;\r\n    employee.terminatedAt = terminatedAt;\r\n    employee.fadeoutStarts = fadeoutStarts;\r\n    employee.suspendedAt = 0;\r\n    UpdateEmployee(e, employee.poolOptions, employee.extraOptions, employee.idx);\r\n  }\r\n\r\n  function getEmployee(address e)\r\n    external\r\n    constant\r\n    returns (uint32, uint32, uint32, uint32, uint32, uint32, uint32, EmployeeState)\r\n  {\r\n      Employee employee = employees[e];\r\n      if (employee.idx == 0)\r\n        throw;\r\n      // where is struct zip/unzip :>\r\n      return (employee.issueDate, employee.timeToSign, employee.terminatedAt, employee.fadeoutStarts,\r\n        employee.poolOptions, employee.extraOptions, employee.suspendedAt, employee.state);\r\n  }\r\n\r\n   function hasEmployee(address e)\r\n     external\r\n     constant\r\n     returns (bool)\r\n   {\r\n      // this is very inefficient - whole word is loaded just to check this\r\n      return employees[e].idx != 0;\r\n    }\r\n\r\n  function getSerializedEmployee(address e)\r\n    external\r\n    constant\r\n    returns (uint[9])\r\n  {\r\n    Employee memory employee = employees[e];\r\n    if (employee.idx == 0)\r\n      throw;\r\n    return serializeEmployee(employee);\r\n  }\r\n}\r\n\r\n\r\ncontract ERC20OptionsConverter is BaseOptionsConverter, TimeSource, Math {\r\n  // see base class for explanations\r\n  address esopAddress;\r\n  uint32 exercisePeriodDeadline;\r\n  // balances for converted options\r\n  mapping(address => uint) internal balances;\r\n  // total supply\r\n  uint public totalSupply;\r\n\r\n  // deadline for all options conversion including company's actions\r\n  uint32 public optionsConversionDeadline;\r\n\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n  modifier converting() {\r\n    // throw after deadline\r\n    if (currentTime() >= exercisePeriodDeadline)\r\n      throw;\r\n    _;\r\n  }\r\n\r\n  modifier converted() {\r\n    // throw before deadline\r\n    if (currentTime() < optionsConversionDeadline)\r\n      throw;\r\n    _;\r\n  }\r\n\r\n\r\n  function getESOP() public constant returns (address) {\r\n    return esopAddress;\r\n  }\r\n\r\n  function getExercisePeriodDeadline() public constant returns(uint32) {\r\n    return exercisePeriodDeadline;\r\n  }\r\n\r\n  function exerciseOptions(address employee, uint poolOptions, uint extraOptions, uint bonusOptions,\r\n    bool agreeToAcceleratedVestingBonusConditions)\r\n    public\r\n    onlyESOP\r\n    converting\r\n  {\r\n    // if no overflow on totalSupply, no overflows later\r\n    uint options = safeAdd(safeAdd(poolOptions, extraOptions), bonusOptions);\r\n    totalSupply = safeAdd(totalSupply, options);\r\n    balances[employee] += options;\r\n    Transfer(0, employee, options);\r\n  }\r\n\r\n  function transfer(address _to, uint _value) converted public {\r\n    if (balances[msg.sender] < _value)\r\n      throw;\r\n    balances[msg.sender] -= _value;\r\n    balances[_to] += _value;\r\n    Transfer(msg.sender, _to, _value);\r\n  }\r\n\r\n  function balanceOf(address _owner) constant public returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function () payable {\r\n    throw;\r\n  }\r\n\r\n  function ERC20OptionsConverter(address esop, uint32 exerciseDeadline, uint32 conversionDeadline) {\r\n    esopAddress = esop;\r\n    exercisePeriodDeadline = exerciseDeadline;\r\n    optionsConversionDeadline = conversionDeadline;\r\n  }\r\n}\r\n\r\ncontract ESOPMigration {\r\n  modifier onlyOldESOP() {\r\n    if (msg.sender != getOldESOP())\r\n      throw;\r\n    _;\r\n  }\r\n\r\n  // returns ESOP address which is a sole executor of exerciseOptions function\r\n  function getOldESOP() public constant returns (address);\r\n\r\n  // migrate employee to new ESOP contract, throws if not possible\r\n  // in simplest case new ESOP contract should derive from this contract and implement abstract methods\r\n  // employees list is available for inspection by employee address\r\n  // poolOptions and extraOption is amount of options transferred out of old ESOP contract\r\n  function migrate(address employee, uint poolOptions, uint extraOptions) onlyOldESOP public;\r\n}\r\n\r\ncontract ESOP is ESOPTypes, CodeUpdateable, TimeSource {\r\n  // employee changed events\r\n  event ESOPOffered(address indexed employee, address company, uint32 poolOptions, uint32 extraOptions);\r\n  event EmployeeSignedToESOP(address indexed employee);\r\n  event SuspendEmployee(address indexed employee, uint32 suspendedAt);\r\n  event ContinueSuspendedEmployee(address indexed employee, uint32 continuedAt, uint32 suspendedPeriod);\r\n  event TerminateEmployee(address indexed employee, address company, uint32 terminatedAt, TerminationType termType);\r\n  event EmployeeOptionsExercised(address indexed employee, address exercisedFor, uint32 poolOptions, bool disableAcceleratedVesting);\r\n  event EmployeeMigrated(address indexed employee, address migration, uint pool, uint extra);\r\n  // esop changed events\r\n  event ESOPOpened(address company);\r\n  event OptionsConversionOffered(address company, address converter, uint32 convertedAt, uint32 exercisePeriodDeadline);\r\n  enum ESOPState { New, Open, Conversion }\r\n  // use retrun codes until revert opcode is implemented\r\n  enum ReturnCodes { OK, InvalidEmployeeState, TooLate, InvalidParameters, TooEarly  }\r\n  // event raised when return code from a function is not OK, when OK is returned one of events above is raised\r\n  event ReturnCode(ReturnCodes rc);\r\n  enum TerminationType { Regular, BadLeaver }\r\n\r\n  //CONFIG\r\n  OptionsCalculator public optionsCalculator;\r\n  // total poolOptions in The Pool\r\n  uint public totalPoolOptions;\r\n  // ipfs hash of document establishing this ESOP\r\n  bytes public ESOPLegalWrapperIPFSHash;\r\n  // company address\r\n  address public companyAddress;\r\n  // root of immutable root of trust pointing to given ESOP implementation\r\n  address public rootOfTrust;\r\n  // default period for employee signature\r\n  uint32 constant public MINIMUM_MANUAL_SIGN_PERIOD = 2 weeks;\r\n\r\n  // STATE\r\n  // poolOptions that remain to be assigned\r\n  uint public remainingPoolOptions;\r\n  // state of ESOP\r\n  ESOPState public esopState; // automatically sets to Open (0)\r\n  // list of employees\r\n  EmployeesList public employees;\r\n  // how many extra options inserted\r\n  uint public totalExtraOptions;\r\n  // when conversion event happened\r\n  uint32 public conversionOfferedAt;\r\n  // employee conversion deadline\r\n  uint32 public exerciseOptionsDeadline;\r\n  // option conversion proxy\r\n  BaseOptionsConverter public optionsConverter;\r\n\r\n  // migration destinations per employee\r\n  mapping (address => ESOPMigration) private migrations;\r\n\r\n  modifier hasEmployee(address e) {\r\n    // will throw on unknown address\r\n    if (!employees.hasEmployee(e))\r\n      throw;\r\n    _;\r\n  }\r\n\r\n  modifier onlyESOPNew() {\r\n    if (esopState != ESOPState.New)\r\n      throw;\r\n    _;\r\n  }\r\n\r\n  modifier onlyESOPOpen() {\r\n    if (esopState != ESOPState.Open)\r\n      throw;\r\n    _;\r\n  }\r\n\r\n  modifier onlyESOPConversion() {\r\n    if (esopState != ESOPState.Conversion)\r\n      throw;\r\n    _;\r\n  }\r\n\r\n  modifier onlyCompany() {\r\n    if (companyAddress != msg.sender)\r\n      throw;\r\n    _;\r\n  }\r\n\r\n  function distributeAndReturnToPool(uint distributedOptions, uint idx)\r\n    internal\r\n    returns (uint)\r\n  {\r\n    // enumerate all employees that were offered poolOptions after than fromIdx -1 employee\r\n    Employee memory emp;\r\n    for (uint i = idx; i < employees.size(); i++) {\r\n      address ea = employees.addresses(i);\r\n      if (ea != 0) { // address(0) is deleted employee\r\n        emp = _loademp(ea);\r\n        // skip employees with no poolOptions and terminated employees\r\n        if (emp.poolOptions > 0 && ( emp.state == EmployeeState.WaitingForSignature || emp.state == EmployeeState.Employed) ) {\r\n          uint newoptions = optionsCalculator.calcNewEmployeePoolOptions(distributedOptions);\r\n          emp.poolOptions += uint32(newoptions);\r\n          distributedOptions -= uint32(newoptions);\r\n          _saveemp(ea, emp);\r\n        }\r\n      }\r\n    }\r\n    return distributedOptions;\r\n  }\r\n\r\n  function removeEmployeesWithExpiredSignaturesAndReturnFadeout()\r\n    onlyESOPOpen\r\n    isCurrentCode\r\n    public\r\n  {\r\n    // removes employees that didn't sign and sends their poolOptions back to the pool\r\n    // computes fadeout for terminated employees and returns it to pool\r\n    // we let anyone to call that method and spend gas on it\r\n    Employee memory emp;\r\n    uint32 ct = currentTime();\r\n    for (uint i = 0; i < employees.size(); i++) {\r\n      address ea = employees.addresses(i);\r\n      if (ea != 0) { // address(0) is deleted employee\r\n        var ser = employees.getSerializedEmployee(ea);\r\n        emp = deserializeEmployee(ser);\r\n        // remove employees with expired signatures\r\n        if (emp.state == EmployeeState.WaitingForSignature && ct > emp.timeToSign) {\r\n          remainingPoolOptions += distributeAndReturnToPool(emp.poolOptions, i+1);\r\n          totalExtraOptions -= emp.extraOptions;\r\n          // actually this just sets address to 0 so iterator can continue\r\n          employees.removeEmployee(ea);\r\n        }\r\n        // return fadeout to pool\r\n        if (emp.state == EmployeeState.Terminated && ct > emp.fadeoutStarts) {\r\n          var (returnedPoolOptions, returnedExtraOptions) = optionsCalculator.calculateFadeoutToPool(ct, ser);\r\n          if (returnedPoolOptions > 0 || returnedExtraOptions > 0) {\r\n            employees.setFadeoutStarts(ea, ct);\r\n            // options from fadeout are not distributed to other employees but returned to pool\r\n            remainingPoolOptions += returnedPoolOptions;\r\n            // we maintain extraPool for easier statistics\r\n            totalExtraOptions -= returnedExtraOptions;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function openESOP(uint32 pTotalPoolOptions, bytes pESOPLegalWrapperIPFSHash)\r\n    external\r\n    onlyCompany\r\n    onlyESOPNew\r\n    isCurrentCode\r\n    returns (ReturnCodes)\r\n  {\r\n    // options are stored in unit32\r\n    if (pTotalPoolOptions > 1100000 || pTotalPoolOptions < 10000) {\r\n      return _logerror(ReturnCodes.InvalidParameters);\r\n    }\r\n\r\n    totalPoolOptions = pTotalPoolOptions;\r\n    remainingPoolOptions = totalPoolOptions;\r\n    ESOPLegalWrapperIPFSHash = pESOPLegalWrapperIPFSHash;\r\n\r\n    esopState = ESOPState.Open;\r\n    ESOPOpened(companyAddress);\r\n    return ReturnCodes.OK;\r\n  }\r\n\r\n  function offerOptionsToEmployee(address e, uint32 issueDate, uint32 timeToSign, uint32 extraOptions, bool poolCleanup)\r\n    external\r\n    onlyESOPOpen\r\n    onlyCompany\r\n    isCurrentCode\r\n    returns (ReturnCodes)\r\n  {\r\n    // do not add twice\r\n    if (employees.hasEmployee(e)) {\r\n      return _logerror(ReturnCodes.InvalidEmployeeState);\r\n    }\r\n    if (timeToSign < currentTime() + MINIMUM_MANUAL_SIGN_PERIOD) {\r\n      return _logerror(ReturnCodes.TooLate);\r\n    }\r\n    if (poolCleanup) {\r\n      // recover poolOptions for employees with expired signatures\r\n      // return fade out to pool\r\n      removeEmployeesWithExpiredSignaturesAndReturnFadeout();\r\n    }\r\n    uint poolOptions = optionsCalculator.calcNewEmployeePoolOptions(remainingPoolOptions);\r\n    if (poolOptions > 0xFFFFFFFF)\r\n      throw;\r\n    Employee memory emp = Employee({\r\n      issueDate: issueDate, timeToSign: timeToSign, terminatedAt: 0, fadeoutStarts: 0, poolOptions: uint32(poolOptions),\r\n      extraOptions: extraOptions, suspendedAt: 0, state: EmployeeState.WaitingForSignature, idx: 0\r\n    });\r\n    _saveemp(e, emp);\r\n    remainingPoolOptions -= poolOptions;\r\n    totalExtraOptions += extraOptions;\r\n    ESOPOffered(e, companyAddress, uint32(poolOptions), extraOptions);\r\n    return ReturnCodes.OK;\r\n  }\r\n\r\n  // todo: implement group add someday, however func distributeAndReturnToPool gets very complicated\r\n  // todo: function calcNewEmployeePoolOptions(uint remaining, uint8 groupSize)\r\n  // todo: function addNewEmployeesToESOP(address[] emps, uint32 issueDate, uint32 timeToSign)\r\n\r\n  function offerOptionsToEmployeeOnlyExtra(address e, uint32 issueDate, uint32 timeToSign, uint32 extraOptions)\r\n    external\r\n    onlyESOPOpen\r\n    onlyCompany\r\n    isCurrentCode\r\n    returns (ReturnCodes)\r\n  {\r\n    // do not add twice\r\n    if (employees.hasEmployee(e)) {\r\n      return _logerror(ReturnCodes.InvalidEmployeeState);\r\n    }\r\n    if (timeToSign < currentTime() + MINIMUM_MANUAL_SIGN_PERIOD) {\r\n      return _logerror(ReturnCodes.TooLate);\r\n    }\r\n    Employee memory emp = Employee({\r\n      issueDate: issueDate, timeToSign: timeToSign, terminatedAt: 0, fadeoutStarts: 0, poolOptions: 0,\r\n      extraOptions: extraOptions, suspendedAt: 0, state: EmployeeState.WaitingForSignature, idx: 0\r\n    });\r\n    _saveemp(e, emp);\r\n    totalExtraOptions += extraOptions;\r\n    ESOPOffered(e, companyAddress, 0, extraOptions);\r\n    return ReturnCodes.OK;\r\n  }\r\n\r\n  function increaseEmployeeExtraOptions(address e, uint32 extraOptions)\r\n    external\r\n    onlyESOPOpen\r\n    onlyCompany\r\n    isCurrentCode\r\n    hasEmployee(e)\r\n    returns (ReturnCodes)\r\n  {\r\n    Employee memory emp = _loademp(e);\r\n    if (emp.state != EmployeeState.Employed && emp.state != EmployeeState.WaitingForSignature) {\r\n      return _logerror(ReturnCodes.InvalidEmployeeState);\r\n    }\r\n    emp.extraOptions += extraOptions;\r\n    _saveemp(e, emp);\r\n    totalExtraOptions += extraOptions;\r\n    ESOPOffered(e, companyAddress, 0, extraOptions);\r\n    return ReturnCodes.OK;\r\n  }\r\n\r\n  function employeeSignsToESOP()\r\n    external\r\n    hasEmployee(msg.sender)\r\n    onlyESOPOpen\r\n    isCurrentCode\r\n    returns (ReturnCodes)\r\n  {\r\n    Employee memory emp = _loademp(msg.sender);\r\n    if (emp.state != EmployeeState.WaitingForSignature) {\r\n      return _logerror(ReturnCodes.InvalidEmployeeState);\r\n    }\r\n    uint32 t = currentTime();\r\n    if (t > emp.timeToSign) {\r\n      remainingPoolOptions += distributeAndReturnToPool(emp.poolOptions, emp.idx);\r\n      totalExtraOptions -= emp.extraOptions;\r\n      employees.removeEmployee(msg.sender);\r\n      return _logerror(ReturnCodes.TooLate);\r\n    }\r\n    employees.changeState(msg.sender, EmployeeState.Employed);\r\n    EmployeeSignedToESOP(msg.sender);\r\n    return ReturnCodes.OK;\r\n  }\r\n\r\n  function toggleEmployeeSuspension(address e, uint32 toggledAt)\r\n    external\r\n    onlyESOPOpen\r\n    onlyCompany\r\n    hasEmployee(e)\r\n    isCurrentCode\r\n    returns (ReturnCodes)\r\n  {\r\n    Employee memory emp = _loademp(e);\r\n    if (emp.state != EmployeeState.Employed) {\r\n      return _logerror(ReturnCodes.InvalidEmployeeState);\r\n    }\r\n    if (emp.suspendedAt == 0) {\r\n      //suspend action\r\n      emp.suspendedAt = toggledAt;\r\n      SuspendEmployee(e, toggledAt);\r\n    } else {\r\n      if (emp.suspendedAt > toggledAt) {\r\n        return _logerror(ReturnCodes.TooLate);\r\n      }\r\n      uint32 suspendedPeriod = toggledAt - emp.suspendedAt;\r\n      // move everything by suspension period by changing issueDate\r\n      emp.issueDate += suspendedPeriod;\r\n      emp.suspendedAt = 0;\r\n      ContinueSuspendedEmployee(e, toggledAt, suspendedPeriod);\r\n    }\r\n    _saveemp(e, emp);\r\n    return ReturnCodes.OK;\r\n  }\r\n\r\n  function terminateEmployee(address e, uint32 terminatedAt, uint8 terminationType)\r\n    external\r\n    onlyESOPOpen\r\n    onlyCompany\r\n    hasEmployee(e)\r\n    isCurrentCode\r\n    returns (ReturnCodes)\r\n  {\r\n    // terminates an employee\r\n    TerminationType termType = TerminationType(terminationType);\r\n    Employee memory emp = _loademp(e);\r\n    // todo: check termination time against issueDate\r\n    if (terminatedAt < emp.issueDate) {\r\n      return _logerror(ReturnCodes.InvalidParameters);\r\n    }\r\n    if (emp.state == EmployeeState.WaitingForSignature)\r\n      termType = TerminationType.BadLeaver;\r\n    else if (emp.state != EmployeeState.Employed) {\r\n      return _logerror(ReturnCodes.InvalidEmployeeState);\r\n    }\r\n    // how many poolOptions returned to pool\r\n    uint returnedOptions;\r\n    uint returnedExtraOptions;\r\n    if (termType == TerminationType.Regular) {\r\n      // regular termination, compute suspension\r\n      if (emp.suspendedAt > 0 && emp.suspendedAt < terminatedAt)\r\n        emp.issueDate += terminatedAt - emp.suspendedAt;\r\n      // vesting applies\r\n      returnedOptions = emp.poolOptions - optionsCalculator.calculateVestedOptions(terminatedAt, emp.issueDate, emp.poolOptions);\r\n      returnedExtraOptions = emp.extraOptions - optionsCalculator.calculateVestedOptions(terminatedAt, emp.issueDate, emp.extraOptions);\r\n      employees.terminateEmployee(e, emp.issueDate, terminatedAt, terminatedAt, EmployeeState.Terminated);\r\n    } else if (termType == TerminationType.BadLeaver) {\r\n      // bad leaver - employee is kicked out from ESOP, return all poolOptions\r\n      returnedOptions = emp.poolOptions;\r\n      returnedExtraOptions = emp.extraOptions;\r\n      employees.removeEmployee(e);\r\n    }\r\n    remainingPoolOptions += distributeAndReturnToPool(returnedOptions, emp.idx);\r\n    totalExtraOptions -= returnedExtraOptions;\r\n    TerminateEmployee(e, companyAddress, terminatedAt, termType);\r\n    return ReturnCodes.OK;\r\n  }\r\n\r\n  function offerOptionsConversion(BaseOptionsConverter converter)\r\n    external\r\n    onlyESOPOpen\r\n    onlyCompany\r\n    isCurrentCode\r\n    returns (ReturnCodes)\r\n  {\r\n    uint32 offerMadeAt = currentTime();\r\n    if (converter.getExercisePeriodDeadline() - offerMadeAt < MINIMUM_MANUAL_SIGN_PERIOD) {\r\n      return _logerror(ReturnCodes.TooLate);\r\n    }\r\n    // exerciseOptions must be callable by us\r\n    if (converter.getESOP() != address(this)) {\r\n      return _logerror(ReturnCodes.InvalidParameters);\r\n    }\r\n    // return to pool everything we can\r\n    removeEmployeesWithExpiredSignaturesAndReturnFadeout();\r\n    // from now vesting and fadeout stops, no new employees may be added\r\n    conversionOfferedAt = offerMadeAt;\r\n    exerciseOptionsDeadline = converter.getExercisePeriodDeadline();\r\n    optionsConverter = converter;\r\n    // this is very irreversible\r\n    esopState = ESOPState.Conversion;\r\n    OptionsConversionOffered(companyAddress, address(converter), offerMadeAt, exerciseOptionsDeadline);\r\n    return ReturnCodes.OK;\r\n  }\r\n\r\n  function exerciseOptionsInternal(uint32 calcAtTime, address employee, address exerciseFor,\r\n    bool disableAcceleratedVesting)\r\n    internal\r\n    returns (ReturnCodes)\r\n  {\r\n    Employee memory emp = _loademp(employee);\r\n    if (emp.state == EmployeeState.OptionsExercised) {\r\n      return _logerror(ReturnCodes.InvalidEmployeeState);\r\n    }\r\n    // if we are burning options then send 0\r\n    if (exerciseFor != address(0)) {\r\n      var (pool, extra, bonus) = optionsCalculator.calculateOptionsComponents(serializeEmployee(emp),\r\n        calcAtTime, conversionOfferedAt, disableAcceleratedVesting);\r\n      }\r\n    // call before options conversion contract to prevent re-entry\r\n    employees.changeState(employee, EmployeeState.OptionsExercised);\r\n    // exercise options in the name of employee and assign those to exerciseFor\r\n    optionsConverter.exerciseOptions(exerciseFor, pool, extra, bonus, !disableAcceleratedVesting);\r\n    EmployeeOptionsExercised(employee, exerciseFor, uint32(pool + extra + bonus), !disableAcceleratedVesting);\r\n    return ReturnCodes.OK;\r\n  }\r\n\r\n  function employeeExerciseOptions(bool agreeToAcceleratedVestingBonusConditions)\r\n    external\r\n    onlyESOPConversion\r\n    hasEmployee(msg.sender)\r\n    isCurrentCode\r\n    returns (ReturnCodes)\r\n  {\r\n    uint32 ct = currentTime();\r\n    if (ct > exerciseOptionsDeadline) {\r\n      return _logerror(ReturnCodes.TooLate);\r\n    }\r\n    return exerciseOptionsInternal(ct, msg.sender, msg.sender, !agreeToAcceleratedVestingBonusConditions);\r\n  }\r\n\r\n  function employeeDenyExerciseOptions()\r\n    external\r\n    onlyESOPConversion\r\n    hasEmployee(msg.sender)\r\n    isCurrentCode\r\n    returns (ReturnCodes)\r\n  {\r\n    uint32 ct = currentTime();\r\n    if (ct > exerciseOptionsDeadline) {\r\n      return _logerror(ReturnCodes.TooLate);\r\n    }\r\n    // burn the options by sending to 0\r\n    return exerciseOptionsInternal(ct, msg.sender, address(0), true);\r\n  }\r\n\r\n  function exerciseExpiredEmployeeOptions(address e, bool disableAcceleratedVesting)\r\n    external\r\n    onlyESOPConversion\r\n    onlyCompany\r\n    hasEmployee(e)\r\n    isCurrentCode\r\n  returns (ReturnCodes)\r\n  {\r\n    // company can convert options for any employee that did not converted (after deadline)\r\n    uint32 ct = currentTime();\r\n    if (ct <= exerciseOptionsDeadline) {\r\n      return _logerror(ReturnCodes.TooEarly);\r\n    }\r\n    return exerciseOptionsInternal(ct, e, companyAddress, disableAcceleratedVesting);\r\n  }\r\n\r\n  function allowEmployeeMigration(address employee, ESOPMigration migration)\r\n    external\r\n    onlyESOPOpen\r\n    hasEmployee(employee)\r\n    onlyCompany\r\n    isCurrentCode\r\n    returns (ReturnCodes)\r\n  {\r\n    if (address(migration) == 0)\r\n      throw;\r\n    // only employed and terminated users may migrate\r\n    Employee memory emp = _loademp(employee);\r\n    if (emp.state != EmployeeState.Employed && emp.state != EmployeeState.Terminated) {\r\n      return _logerror(ReturnCodes.InvalidEmployeeState);\r\n    }\r\n    migrations[employee] = migration; // can be cleared with 0 address\r\n    return ReturnCodes.OK;\r\n  }\r\n\r\n  function employeeMigratesToNewESOP(ESOPMigration migration)\r\n    external\r\n    onlyESOPOpen\r\n    hasEmployee(msg.sender)\r\n    isCurrentCode\r\n    returns (ReturnCodes)\r\n  {\r\n    // employee may migrate to new ESOP contract with different rules\r\n    // if migration not set up by company then throw\r\n    if (address(migration) == 0 || migrations[msg.sender] != migration)\r\n      throw;\r\n    // first give back what you already own\r\n    removeEmployeesWithExpiredSignaturesAndReturnFadeout();\r\n    // only employed and terminated users may migrate\r\n    Employee memory emp = _loademp(msg.sender);\r\n    if (emp.state != EmployeeState.Employed && emp.state != EmployeeState.Terminated) {\r\n      return _logerror(ReturnCodes.InvalidEmployeeState);\r\n    }\r\n    // with accelerated vesting if possible - take out all possible options\r\n    var (pool, extra, _) = optionsCalculator.calculateOptionsComponents(serializeEmployee(emp), currentTime(), 0, false);\r\n    delete migrations[msg.sender];\r\n    // execute migration procedure\r\n    migration.migrate(msg.sender, pool, extra);\r\n    // extra options are moved to new contract\r\n    totalExtraOptions -= emp.state == EmployeeState.Employed ? emp.extraOptions : extra;\r\n    // pool options are moved to new contract and removed from The Pool\r\n    // please note that separate Pool will manage migrated options and\r\n    // algorithm that returns to pool and distributes will not be used\r\n    totalPoolOptions -= emp.state == EmployeeState.Employed ? emp.poolOptions : pool;\r\n    // gone from current contract\r\n    employees.removeEmployee(msg.sender);\r\n    EmployeeMigrated(msg.sender, migration, pool, extra);\r\n    return ReturnCodes.OK;\r\n  }\r\n\r\n  function calcEffectiveOptionsForEmployee(address e, uint32 calcAtTime)\r\n    public\r\n    constant\r\n    hasEmployee(e)\r\n    isCurrentCode\r\n    returns (uint)\r\n  {\r\n    return optionsCalculator.calculateOptions(employees.getSerializedEmployee(e), calcAtTime, conversionOfferedAt, false);\r\n  }\r\n\r\n  function _logerror(ReturnCodes c) private returns (ReturnCodes) {\r\n    ReturnCode(c);\r\n    return c;\r\n  }\r\n\r\n  function _loademp(address e) private constant returns (Employee memory) {\r\n    return deserializeEmployee(employees.getSerializedEmployee(e));\r\n  }\r\n\r\n  function _saveemp(address e, Employee memory emp) private {\r\n    employees.setEmployee(e, emp.issueDate, emp.timeToSign, emp.terminatedAt, emp.fadeoutStarts, emp.poolOptions,\r\n      emp.extraOptions, emp.suspendedAt, emp.state);\r\n  }\r\n\r\n  function completeCodeUpdate() public onlyOwner inCodeUpdate {\r\n    employees.transferOwnership(msg.sender);\r\n    CodeUpdateable.completeCodeUpdate();\r\n  }\r\n\r\n  function()\r\n      payable\r\n  {\r\n      throw;\r\n  }\r\n\r\n  function ESOP(address company, address pRootOfTrust, OptionsCalculator pOptionsCalculator, EmployeesList pEmployeesList) {\r\n    //esopState = ESOPState.New; // thats initial value\r\n    companyAddress = company;\r\n    rootOfTrust = pRootOfTrust;\r\n    employees = pEmployeesList;\r\n    optionsCalculator = pOptionsCalculator;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\ncontract OptionsCalculator is Ownable, Destructable, Math, ESOPTypes {\r\n  // cliff duration in seconds\r\n  uint public cliffPeriod;\r\n  // vesting duration in seconds\r\n  uint public vestingPeriod;\r\n  // maximum promille that can fade out\r\n  uint public maxFadeoutPromille;\r\n  // minimal options after fadeout\r\n  function residualAmountPromille() public constant returns(uint) { return FP_SCALE - maxFadeoutPromille; }\r\n  // exit bonus promille\r\n  uint public bonusOptionsPromille;\r\n  // per mille of unassigned poolOptions that new employee gets\r\n  uint public newEmployeePoolPromille;\r\n  // options per share\r\n  uint public optionsPerShare;\r\n  // options strike price\r\n  uint constant public STRIKE_PRICE = 1;\r\n  // company address\r\n  address public companyAddress;\r\n  // checks if calculator i initialized\r\n  function hasParameters() public constant returns(bool) { return optionsPerShare > 0; }\r\n\r\n  modifier onlyCompany() {\r\n    if (companyAddress != msg.sender)\r\n      throw;\r\n    _;\r\n  }\r\n\r\n  function calcNewEmployeePoolOptions(uint remainingPoolOptions)\r\n    public\r\n    constant\r\n    returns (uint)\r\n  {\r\n    return divRound(remainingPoolOptions * newEmployeePoolPromille, FP_SCALE);\r\n  }\r\n\r\n  function calculateVestedOptions(uint t, uint vestingStarts, uint options)\r\n    public\r\n    constant\r\n    returns (uint)\r\n  {\r\n    if (t <= vestingStarts)\r\n      return 0;\r\n    // apply vesting\r\n    uint effectiveTime = t - vestingStarts;\r\n    // if within cliff nothing is due\r\n    if (effectiveTime < cliffPeriod)\r\n      return 0;\r\n    else\r\n      return  effectiveTime < vestingPeriod ? divRound(options * effectiveTime, vestingPeriod) : options;\r\n  }\r\n\r\n  function applyFadeoutToOptions(uint32 t, uint32 issueDate, uint32 terminatedAt, uint options, uint vestedOptions)\r\n    public\r\n    constant\r\n    returns (uint)\r\n  {\r\n    if (t < terminatedAt)\r\n      return vestedOptions;\r\n    uint timefromTermination = t - terminatedAt;\r\n    // fadeout duration equals to employment duration\r\n    uint employmentPeriod = terminatedAt - issueDate;\r\n    // minimum value of options at the end of fadeout, it is a % of all employee's options\r\n    uint minFadeValue = divRound(options * (FP_SCALE - maxFadeoutPromille), FP_SCALE);\r\n    // however employee cannot have more than options after fadeout than he was vested at termination\r\n    if (minFadeValue >= vestedOptions)\r\n      return vestedOptions;\r\n    return timefromTermination > employmentPeriod ?\r\n      minFadeValue  :\r\n      (minFadeValue + divRound((vestedOptions - minFadeValue) * (employmentPeriod - timefromTermination), employmentPeriod));\r\n  }\r\n\r\n  function calculateOptionsComponents(uint[9] employee, uint32 calcAtTime, uint32 conversionOfferedAt,\r\n    bool disableAcceleratedVesting)\r\n    public\r\n    constant\r\n    returns (uint, uint, uint)\r\n  {\r\n    // returns tuple of (vested pool options, vested extra options, bonus)\r\n    Employee memory emp = deserializeEmployee(employee);\r\n    // no options for converted options or when esop is not singed\r\n    if (emp.state == EmployeeState.OptionsExercised || emp.state == EmployeeState.WaitingForSignature)\r\n      return (0,0,0);\r\n    // no options when esop is being converted and conversion deadline expired\r\n    bool isESOPConverted = conversionOfferedAt > 0 && calcAtTime >= conversionOfferedAt; // this function time-travels\r\n    uint issuedOptions = emp.poolOptions + emp.extraOptions;\r\n    // employee with no options\r\n    if (issuedOptions == 0)\r\n      return (0,0,0);\r\n    // if emp is terminated but we calc options before term, simulate employed again\r\n    if (calcAtTime < emp.terminatedAt && emp.terminatedAt > 0)\r\n      emp.state = EmployeeState.Employed;\r\n    uint vestedOptions = issuedOptions;\r\n    bool accelerateVesting = isESOPConverted && emp.state == EmployeeState.Employed && !disableAcceleratedVesting;\r\n    if (!accelerateVesting) {\r\n      // choose vesting time\r\n      uint32 calcVestingAt = emp.state ==\r\n        // if terminated then vesting calculated at termination\r\n        EmployeeState.Terminated ? emp.terminatedAt :\r\n        // if employee is supended then compute vesting at suspension time\r\n        (emp.suspendedAt > 0 && emp.suspendedAt < calcAtTime ? emp.suspendedAt :\r\n        // if conversion offer then vesting calucated at time the offer was made\r\n        conversionOfferedAt > 0 ? conversionOfferedAt :\r\n        // otherwise use current time\r\n        calcAtTime);\r\n      vestedOptions = calculateVestedOptions(calcVestingAt, emp.issueDate, issuedOptions);\r\n    }\r\n    // calc fadeout for terminated employees\r\n    if (emp.state == EmployeeState.Terminated) {\r\n      // use conversion event time to compute fadeout to stop fadeout on conversion IF not after conversion date\r\n      vestedOptions = applyFadeoutToOptions(isESOPConverted ? conversionOfferedAt : calcAtTime,\r\n        emp.issueDate, emp.terminatedAt, issuedOptions, vestedOptions);\r\n    }\r\n    var (vestedPoolOptions, vestedExtraOptions) = extractVestedOptionsComponents(emp.poolOptions, emp.extraOptions, vestedOptions);\r\n    // if (vestedPoolOptions + vestedExtraOptions != vestedOptions) throw;\r\n    return  (vestedPoolOptions, vestedExtraOptions,\r\n      accelerateVesting ? divRound(vestedPoolOptions*bonusOptionsPromille, FP_SCALE) : 0 );\r\n  }\r\n\r\n  function calculateOptions(uint[9] employee, uint32 calcAtTime, uint32 conversionOfferedAt, bool disableAcceleratedVesting)\r\n    public\r\n    constant\r\n    returns (uint)\r\n  {\r\n    var (vestedPoolOptions, vestedExtraOptions, bonus) = calculateOptionsComponents(employee, calcAtTime,\r\n      conversionOfferedAt, disableAcceleratedVesting);\r\n    return vestedPoolOptions + vestedExtraOptions + bonus;\r\n  }\r\n\r\n  function extractVestedOptionsComponents(uint issuedPoolOptions, uint issuedExtraOptions, uint vestedOptions)\r\n    public\r\n    constant\r\n    returns (uint, uint)\r\n  {\r\n    // breaks down vested options into pool options and extra options components\r\n    if (issuedExtraOptions == 0)\r\n      return (vestedOptions, 0);\r\n    uint poolOptions = divRound(issuedPoolOptions*vestedOptions, issuedPoolOptions + issuedExtraOptions);\r\n    return (poolOptions, vestedOptions - poolOptions);\r\n  }\r\n\r\n  function calculateFadeoutToPool(uint32 t, uint[9] employee)\r\n    public\r\n    constant\r\n    returns (uint, uint)\r\n  {\r\n    Employee memory emp = deserializeEmployee(employee);\r\n\r\n    uint vestedOptions = calculateVestedOptions(emp.terminatedAt, emp.issueDate, emp.poolOptions);\r\n    uint returnedPoolOptions = applyFadeoutToOptions(emp.fadeoutStarts, emp.issueDate, emp.terminatedAt, emp.poolOptions, vestedOptions) -\r\n      applyFadeoutToOptions(t, emp.issueDate, emp.terminatedAt, emp.poolOptions, vestedOptions);\r\n    uint vestedExtraOptions = calculateVestedOptions(emp.terminatedAt, emp.issueDate, emp.extraOptions);\r\n    uint returnedExtraOptions = applyFadeoutToOptions(emp.fadeoutStarts, emp.issueDate, emp.terminatedAt, emp.extraOptions, vestedExtraOptions) -\r\n      applyFadeoutToOptions(t, emp.issueDate, emp.terminatedAt, emp.extraOptions, vestedExtraOptions);\r\n\r\n    return (returnedPoolOptions, returnedExtraOptions);\r\n  }\r\n\r\n  function simulateOptions(uint32 issueDate, uint32 terminatedAt, uint32 poolOptions,\r\n    uint32 extraOptions, uint32 suspendedAt, uint8 employeeState, uint32 calcAtTime)\r\n    public\r\n    constant\r\n    returns (uint)\r\n  {\r\n    Employee memory emp = Employee({issueDate: issueDate, terminatedAt: terminatedAt,\r\n      poolOptions: poolOptions, extraOptions: extraOptions, state: EmployeeState(employeeState),\r\n      timeToSign: issueDate+2 weeks, fadeoutStarts: terminatedAt, suspendedAt: suspendedAt,\r\n      idx:1});\r\n    return calculateOptions(serializeEmployee(emp), calcAtTime, 0, false);\r\n  }\r\n\r\n  function setParameters(uint32 pCliffPeriod, uint32 pVestingPeriod, uint32 pResidualAmountPromille,\r\n    uint32 pBonusOptionsPromille, uint32 pNewEmployeePoolPromille, uint32 pOptionsPerShare)\r\n    external\r\n    onlyCompany\r\n  {\r\n    if (pResidualAmountPromille > FP_SCALE || pBonusOptionsPromille > FP_SCALE || pNewEmployeePoolPromille > FP_SCALE\r\n     || pOptionsPerShare == 0)\r\n      throw;\r\n    if (pCliffPeriod > pVestingPeriod)\r\n      throw;\r\n    // initialization cannot be called for a second time\r\n    if (hasParameters())\r\n      throw;\r\n    cliffPeriod = pCliffPeriod;\r\n    vestingPeriod = pVestingPeriod;\r\n    maxFadeoutPromille = FP_SCALE - pResidualAmountPromille;\r\n    bonusOptionsPromille = pBonusOptionsPromille;\r\n    newEmployeePoolPromille = pNewEmployeePoolPromille;\r\n    optionsPerShare = pOptionsPerShare;\r\n  }\r\n\r\n  function OptionsCalculator(address pCompanyAddress) {\r\n    companyAddress = pCompanyAddress;\r\n  }\r\n}\r\n\r\ncontract ProceedsOptionsConverter is Ownable, ERC20OptionsConverter {\r\n  mapping (address => uint) internal withdrawals;\r\n  uint[] internal payouts;\r\n\r\n  function makePayout() converted payable onlyOwner public {\r\n    // it does not make sense to distribute less than ether\r\n    if (msg.value < 1 ether)\r\n      throw;\r\n    payouts.push(msg.value);\r\n  }\r\n\r\n  function withdraw() converted public returns (uint) {\r\n    // withdraw for msg.sender\r\n    uint balance = balanceOf(msg.sender);\r\n    if (balance == 0)\r\n      return 0;\r\n    uint paymentId = withdrawals[msg.sender];\r\n    // if all payouts for given token holder executed then exit\r\n    if (paymentId == payouts.length)\r\n      return 0;\r\n    uint payout = 0;\r\n    for (uint i = paymentId; i<payouts.length; i++) {\r\n      // it is safe to make payouts pro-rata: (1) token supply will not change - check converted/conversion modifiers\r\n      // -- (2) balances will not change: check transfer override which limits transfer between accounts\r\n      // NOTE: safeMul throws on overflow, can lock users out of their withdrawals if balance is very high\r\n      // @remco I know. any suggestions? expression below gives most precision\r\n      uint thisPayout = divRound(safeMul(payouts[i], balance), totalSupply);\r\n      payout += thisPayout;\r\n    }\r\n    // change now to prevent re-entry (not necessary due to low send() gas limit)\r\n    withdrawals[msg.sender] = payouts.length;\r\n    if (payout > 0) {\r\n      // now modify payout within 1000 weis as we had rounding errors coming from pro-rata amounts\r\n      // @remco maximum rounding error is (num_employees * num_payments) / 2 with the mean 0\r\n      // --- 1000 wei is still nothing, please explain me what problem you see here\r\n      if ( absDiff(this.balance, payout) < 1000 wei )\r\n        payout = this.balance; // send all\r\n      //if(!msg.sender.call.value(payout)()) // re entry test\r\n      //  throw;\r\n      if (!msg.sender.send(payout))\r\n        throw;\r\n    }\r\n    return payout;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) public converted {\r\n    // if anything was withdrawn then block transfer to prevent multiple withdrawals\r\n    // todo: we could allow transfer to new account (no token balance)\r\n    // todo: we could allow transfer between account that fully withdrawn (but what's the point? -token has 0 value then)\r\n    // todo: there are a few other edge cases where there's transfer and no double spending\r\n    if (withdrawals[_to] > 0 || withdrawals[msg.sender] > 0)\r\n      throw;\r\n    ERC20OptionsConverter.transfer(_to, _value);\r\n  }\r\n\r\n  function ProceedsOptionsConverter(address esop, uint32 exerciseDeadline, uint32 conversionDeadline)\r\n    ERC20OptionsConverter(esop, exerciseDeadline, conversionDeadline)\r\n  {\r\n  }\r\n}\r\n\r\ncontract RoT is Ownable {\r\n    address public ESOPAddress;\r\n    event ESOPAndCompanySet(address ESOPAddress, address companyAddress);\r\n\r\n    function setESOP(address ESOP, address company) public onlyOwner {\r\n      // owner sets ESOP and company only once then passes ownership to company\r\n      // initially owner is a developer/admin\r\n      ESOPAddress = ESOP;\r\n      transferOwnership(company);\r\n      ESOPAndCompanySet(ESOP, company);\r\n    }\r\n\r\n    function killOnUnsupportedFork() public onlyOwner {\r\n      // this method may only be called by company on unsupported forks\r\n      delete ESOPAddress;\r\n      selfdestruct(owner);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"e\",\"type\":\"address\"}],\"name\":\"hasEmployee\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"e\",\"type\":\"address\"}],\"name\":\"getSerializedEmployee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[9]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"e\",\"type\":\"address\"},{\"name\":\"fadeoutStarts\",\"type\":\"uint32\"}],\"name\":\"setFadeoutStarts\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"e\",\"type\":\"address\"},{\"name\":\"issueDate\",\"type\":\"uint32\"},{\"name\":\"terminatedAt\",\"type\":\"uint32\"},{\"name\":\"fadeoutStarts\",\"type\":\"uint32\"},{\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"terminateEmployee\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"e\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"changeState\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"e\",\"type\":\"address\"}],\"name\":\"getEmployee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"selfdestruct\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"e\",\"type\":\"address\"},{\"name\":\"issueDate\",\"type\":\"uint32\"},{\"name\":\"timeToSign\",\"type\":\"uint32\"},{\"name\":\"terminatedAt\",\"type\":\"uint32\"},{\"name\":\"fadeoutStarts\",\"type\":\"uint32\"},{\"name\":\"poolOptions\",\"type\":\"uint32\"},{\"name\":\"extraOptions\",\"type\":\"uint32\"},{\"name\":\"suspendedAt\",\"type\":\"uint32\"},{\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"setEmployee\",\"outputs\":[{\"name\":\"isNew\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"size\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"e\",\"type\":\"address\"}],\"name\":\"removeEmployee\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"e\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"poolOptions\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"extraOptions\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"idx\",\"type\":\"uint16\"}],\"name\":\"CreateEmployee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"e\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"poolOptions\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"extraOptions\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"idx\",\"type\":\"uint16\"}],\"name\":\"UpdateEmployee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"e\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldState\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"newState\",\"type\":\"uint8\"}],\"name\":\"ChangeEmployeeState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"e\",\"type\":\"address\"}],\"name\":\"RemoveEmployee\",\"type\":\"event\"}]","ContractName":"EmployeesList","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4167505c63130bbcc38de78fc0cc34da8e50bfab7142f9dfd5ae24c4f81d2c31"}]}