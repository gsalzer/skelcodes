{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\n\r\ncontract SafeMath {\r\n  //internals\r\n\r\n  function safeMul(uint256 a, uint256 b) internal returns (uint256 c) {\r\n    c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n  }\r\n\r\n  function safeSub(uint256 a, uint256 b) internal returns (uint256 c) {\r\n    assert(b <= a);\r\n    c = a - b;\r\n  }\r\n\r\n  function safeAdd(uint256 a, uint256 b) internal returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c>=a && c>=b);\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) throw;\r\n  }\r\n}\r\n\r\ncontract Token {\r\n  /// @return total amount of tokens\r\n  function totalSupply() constant returns (uint256 supply) {}\r\n\r\n  /// @param _owner The address from which the balance will be retrieved\r\n  /// @return The balance\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n  /// @notice send `_value` token to `_to` from `msg.sender`\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n  /// @param _from The address of the sender\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @param _value The amount of wei to be approved for transfer\r\n  /// @return Whether the approval was successful or not\r\n  function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n  /// @param _owner The address of the account owning tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @return Amount of remaining tokens allowed to spent\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n  uint public decimals;\r\n  string public name;\r\n}\r\n\r\ncontract ValueToken is SafeMath,Token{\r\n    \r\n    string name = \"Value\";\r\n    uint decimals = 0;\r\n    \r\n    uint256 supplyNow = 0; \r\n    mapping (address => uint256) internal balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function totalSupply() constant returns (uint256 totalSupply){\r\n        return supplyNow;\r\n    }\r\n    \r\n    function balanceOf(address _owner) constant returns (uint256 balance){\r\n        return balances[_owner];\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _value) returns (bool success){\r\n        if (balanceOf(msg.sender) >= _value) {\r\n            balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\r\n            balances[_to] = safeAdd(balanceOf(_to), _value);\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n        \r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success){\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\r\n            balances[_to] = safeAdd(balanceOf(_to), _value);\r\n            balances[_from] = safeSub(balanceOf(_from), _value);\r\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n    \r\n    function approve(address _spender, uint256 _value) returns (bool success){\r\n        if(balances[msg.sender] >= _value){\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n        } else { return false; }\r\n    }\r\n    \r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining){\r\n        return allowed[_owner][_spender];\r\n    }\r\n    \r\n    function createValue(address _owner, uint256 _value) internal returns (bool success){\r\n        balances[_owner] = safeAdd(balances[_owner], _value);\r\n        supplyNow = safeAdd(supplyNow, _value);\r\n        Mint(_owner, _value);\r\n    }\r\n    \r\n    function destroyValue(address _owner, uint256 _value) internal returns (bool success){\r\n        balances[_owner] = safeSub(balances[_owner], _value);\r\n        supplyNow = safeSub(supplyNow, _value);\r\n        Burn(_owner, _value);\r\n    }\r\n    \r\n    event Mint(address indexed _owner, uint256 _value);\r\n    \r\n    event Burn(address indexed _owner, uint256 _value);\r\n    \r\n}\r\n\r\n/// @title Quick trading and interest-yielding savings.\r\ncontract ValueTrader is SafeMath,ValueToken{\r\n    \r\n    function () payable {\r\n        // this contract eats any money sent to it incorrectly.\r\n        // thank you for the donation.\r\n    }\r\n    \r\n    // use this to manage tokens\r\n    struct TokenData {\r\n        bool isValid; // is this token currently accepted\r\n        uint256 basePrice; //base price of this token\r\n        uint256 baseLiquidity; //target liquidity of this token (price = basePrice +psf)\r\n        uint256 priceScaleFactor; //how quickly does price increase above base\r\n        bool hasDividend;\r\n        address divContractAddress;\r\n        bytes divData;\r\n    }\r\n    \r\n    address owner;\r\n    address etherContract;\r\n    uint256 tradeCoefficient; // 1-(this/10000) = fee for instant trades, \"negative\" fees possible.\r\n    mapping (address => TokenData) tokenManage;\r\n    bool public burning = false; //after draining is finished, burn to retrieve tokens, allow suicide.\r\n    bool public draining = false; //prevent creation of new value\r\n    \r\n    modifier owned(){\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    modifier burnBlock(){\r\n        assert(!burning);\r\n        _;\r\n    }\r\n    \r\n    modifier drainBlock(){\r\n        assert(!draining);\r\n        _;\r\n    }\r\n    \r\n    //you cannot turn off draining without turning off burning first.\r\n    function toggleDrain() burnBlock owned {\r\n        draining = !draining;\r\n    }\r\n    \r\n    function toggleBurn() owned {\r\n        assert(draining);\r\n        assert(balanceOf(owner) == supplyNow);\r\n        burning = !burning;\r\n    }\r\n    \r\n    function die() owned burnBlock{\r\n        //MAKE SURE TO RETRIEVE TOKEN BALANCES BEFORE DOING THIS!\r\n        selfdestruct(owner);\r\n    }\r\n    \r\n    function validateToken(address token_, uint256 bP_, uint256 bL_, uint256 pF_) owned {\r\n        \r\n        tokenManage[token_].isValid = true;\r\n        tokenManage[token_].basePrice = bP_;\r\n        tokenManage[token_].baseLiquidity = bL_;\r\n        tokenManage[token_].priceScaleFactor = pF_;\r\n        \r\n    }\r\n    \r\n    function configureTokenDividend(address token_, bool hD_, address dA_, bytes dD_) owned {\r\n    \r\n        tokenManage[token_].hasDividend = hD_;\r\n        tokenManage[token_].divContractAddress = dA_;\r\n        tokenManage[token_].divData = dD_;\r\n    }\r\n    \r\n    function callDividend(address token_) owned {\r\n        //this is a dangerous and irresponsible feature,\r\n        //gives owner ability to do virtually anything \r\n        //(bar running away with all the ether)\r\n        //I can't think of a better solution until there is a standard for dividend-paying contracts.\r\n        assert(tokenManage[token_].hasDividend);\r\n        assert(tokenManage[token_].divContractAddress.call.value(0)(tokenManage[token_].divData));\r\n    }\r\n    \r\n    function invalidateToken(address token_) owned {\r\n        tokenManage[token_].isValid = false;\r\n    }\r\n    \r\n    function changeOwner(address owner_) owned {\r\n        owner = owner_;\r\n    }\r\n    \r\n    function changeFee(uint256 tradeFee) owned {\r\n        tradeCoefficient = tradeFee;\r\n    }\r\n    \r\n    function changeEtherContract(address eC) owned {\r\n        etherContract = eC;\r\n    }\r\n    \r\n    event Buy(address tokenAddress, address buyer, uint256 amount, uint256 remaining);\r\n    event Sell(address tokenAddress, address buyer, uint256 amount, uint256 remaining);\r\n    event Trade(address fromTokAddress, address toTokAddress, address buyer, uint256 amount);\r\n\r\n    function ValueTrader(){\r\n        owner = msg.sender;\r\n        burning = false;\r\n        draining = false;\r\n    }\r\n    \r\n    \r\n    \r\n    function valueWithFee(uint256 tempValue) internal returns (uint256 doneValue){\r\n        doneValue = safeMul(tempValue,tradeCoefficient)/10000;\r\n        if(tradeCoefficient < 10000){\r\n            //send fees to owner (in value tokens).\r\n            createValue(owner,safeSub(tempValue,doneValue));\r\n        }\r\n    }\r\n    \r\n    function currentPrice(address token) constant returns (uint256 price){\r\n        if(draining){\r\n            price = 1;\r\n        } else {\r\n        assert(tokenManage[token].isValid);\r\n        uint256 basePrice = tokenManage[token].basePrice;\r\n        uint256 baseLiquidity = tokenManage[token].baseLiquidity;\r\n        uint256 priceScaleFactor = tokenManage[token].priceScaleFactor;\r\n        uint256 currentLiquidity;\r\n        if(token == etherContract){\r\n            currentLiquidity = this.balance;\r\n        }else{\r\n            currentLiquidity = Token(token).balanceOf(this);\r\n        }\r\n        price = safeAdd(basePrice,safeMul(priceScaleFactor,baseLiquidity/currentLiquidity));\r\n        }\r\n    }\r\n    \r\n    function currentLiquidity(address token) constant returns (uint256 liquidity){\r\n        liquidity = Token(token).balanceOf(this);\r\n    }\r\n    \r\n    function valueToToken(address token, uint256 amount) constant internal returns (uint256 value){\r\n        value = amount/currentPrice(token);\r\n        assert(value != 0);\r\n    }\r\n    \r\n    function tokenToValue(address token, uint256 amount) constant internal returns (uint256 value){\r\n        value = safeMul(amount,currentPrice(token));\r\n    }\r\n    \r\n    function sellToken(address token, uint256 amount) drainBlock {\r\n    //remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\r\n        assert(verifiedTransferFrom(token,msg.sender,amount));\r\n        assert(createValue(msg.sender, tokenToValue(token,amount)));\r\n        Sell(token, msg.sender, amount, balances[msg.sender]);\r\n    }\r\n\r\n    function buyToken(address token, uint256 amount) {\r\n        assert(!(valueToToken(token,balances[msg.sender]) < amount));\r\n        assert(destroyValue(msg.sender, tokenToValue(token,amount)));\r\n        assert(Token(token).transfer(msg.sender, amount));\r\n        Buy(token, msg.sender, amount, balances[msg.sender]);\r\n    }\r\n    \r\n    function sellEther() payable drainBlock {\r\n        assert(createValue(msg.sender, tokenToValue(etherContract,msg.value)));\r\n        Sell(etherContract, msg.sender, msg.value, balances[msg.sender]);\r\n    }\r\n    \r\n    function buyEther(uint256 amount) {\r\n        assert(valueToToken(etherContract,balances[msg.sender]) >= amount);\r\n        assert(destroyValue(msg.sender, tokenToValue(etherContract,amount)));\r\n        assert(msg.sender.call.value(amount)());\r\n        Buy(etherContract, msg.sender, amount, balances[msg.sender]);\r\n    }\r\n    \r\n    //input a mixture of a token and ether, recieve the output token\r\n    function quickTrade(address tokenFrom, address tokenTo, uint256 input) payable drainBlock {\r\n        //remember to call Token(address).approve(this, amount) or this contract will not be able to do the (token) transfer on your behalf.\r\n        uint256 inValue;\r\n        uint256 tempInValue = safeAdd(tokenToValue(etherContract,msg.value),\r\n        tokenToValue(tokenFrom,input));\r\n        inValue = valueWithFee(tempInValue);\r\n        uint256 outValue = valueToToken(tokenTo,inValue);\r\n        assert(verifiedTransferFrom(tokenFrom,msg.sender,input));\r\n        if (tokenTo == etherContract){\r\n          assert(msg.sender.call.value(outValue)());  \r\n        } else assert(Token(tokenTo).transfer(msg.sender, outValue));\r\n        Trade(tokenFrom, tokenTo, msg.sender, inValue);\r\n    }\r\n    \r\n    function verifiedTransferFrom(address tokenFrom, address senderAdd, uint256 amount) internal returns (bool success){\r\n    uint256 balanceBefore = Token(tokenFrom).balanceOf(this);\r\n    success = Token(tokenFrom).transferFrom(senderAdd, this, amount);\r\n    uint256 balanceAfter = Token(tokenFrom).balanceOf(this);\r\n    assert((safeSub(balanceAfter,balanceBefore)==amount));\r\n    }\r\n\r\n    \r\n}\r\n\r\n//manage ValueTrader in an automated way!\r\n//fixed amount of (2) holders/managers,\r\n//because I'm too lazy to make anything more complex.\r\ncontract ShopKeeper is SafeMath{\r\n    \r\n    ValueTrader public shop;\r\n    address holderA; //actually manages the trader, recieves equal share of profits\r\n    address holderB; //only recieves manages own profits, (for profit-container type contracts)\r\n    \r\n    \r\n    modifier onlyHolders(){\r\n        assert(msg.sender == holderA || msg.sender == holderB);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyA(){\r\n        assert(msg.sender == holderA);\r\n        _;\r\n    }\r\n    \r\n    function(){\r\n        //this contract is not greedy, should not hold any value.\r\n        throw;\r\n    }\r\n    \r\n    function ShopKeeper(address other){\r\n        shop = new ValueTrader();\r\n        holderA = msg.sender;\r\n        holderB = other;\r\n    }\r\n    \r\n    function giveAwayOwnership(address newHolder) onlyHolders {\r\n        if(msg.sender == holderB){\r\n            holderB = newHolder;\r\n        } else {\r\n            holderA = newHolder;\r\n        }\r\n    }\r\n    \r\n    function splitProfits(){\r\n        uint256 unprocessedProfit = shop.balanceOf(this);\r\n        uint256 equalShare = unprocessedProfit/2;\r\n        assert(shop.transfer(holderA,equalShare));\r\n        assert(shop.transfer(holderB,equalShare));\r\n    }\r\n    \r\n    //Management interface below\r\n    \r\n    function toggleDrain() onlyA {\r\n        shop.toggleDrain();\r\n    }\r\n    \r\n    function toggleBurn() onlyA {\r\n        shop.toggleBurn();\r\n    }\r\n    \r\n    function die() onlyA {\r\n        shop.die();\r\n    }\r\n    \r\n    function validateToken(address token_, uint256 bP_, uint256 bL_, uint256 pF_) onlyHolders {\r\n        shop.validateToken(token_,bP_,bL_,pF_);\r\n    }\r\n    \r\n    function configureTokenDividend(address token_, bool hD_, address dA_, bytes dD_) onlyA {\r\n        shop.configureTokenDividend(token_,hD_,dA_,dD_);\r\n    }\r\n    \r\n    function callDividend(address token_) onlyA {\r\n        shop.callDividend(token_);\r\n    }\r\n    \r\n    function invalidateToken(address token_) onlyHolders {\r\n        shop.invalidateToken(token_);\r\n    }\r\n    \r\n    function changeOwner(address owner_) onlyA {\r\n        if(holderB == holderA){ \r\n            //if holder has full ownership, they can discard this management contract\r\n            shop.changeOwner(owner_); \r\n        }\r\n        holderA = owner_;\r\n    }\r\n    \r\n    function changeShop(address newShop) onlyA {\r\n        if(holderB == holderA){\r\n            //if holder has full ownership, they can reengage the shop contract\r\n            shop = ValueTrader(newShop);\r\n        }\r\n    }\r\n    \r\n    function changeFee(uint256 tradeFee) onlyHolders {\r\n        shop.changeFee(tradeFee);\r\n    }\r\n    \r\n    function changeEtherContract(address eC) onlyHolders {\r\n        shop.changeEtherContract(eC);\r\n    }\r\n}\r\n\r\n//this contract should be holderB in the shopKeeper contract.\r\ncontract ProfitContainerAdapter is SafeMath{\r\n    \r\n    address owner;\r\n    address shopLocation;\r\n    address shopKeeperLocation;\r\n    address profitContainerLocation;\r\n    \r\n    modifier owned(){\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    function changeShop(address newShop) owned {\r\n        shopLocation = newShop;\r\n    }\r\n    \r\n    \r\n    function changeKeeper(address newKeeper) owned {\r\n        shopKeeperLocation = newKeeper;\r\n    }\r\n    \r\n    \r\n    function changeContainer(address newContainer) owned {\r\n        profitContainerLocation = newContainer;\r\n    }\r\n    \r\n    function ProfitContainerAdapter(address sL, address sKL, address pCL){\r\n        owner = msg.sender;\r\n        shopLocation = sL;\r\n        shopKeeperLocation = sKL;\r\n        profitContainerLocation = pCL;\r\n    }\r\n    \r\n    function takeEtherProfits(){\r\n        ShopKeeper(shopKeeperLocation).splitProfits();\r\n        ValueTrader shop = ValueTrader(shopLocation);\r\n        shop.buyEther(shop.balanceOf(this));\r\n        assert(profitContainerLocation.call.value(this.balance)());\r\n    }\r\n    \r\n    //warning: your profit container needs to be able to handle tokens or this is lost forever\r\n    function takeTokenProfits(address token){\r\n        ShopKeeper(shopKeeperLocation).splitProfits();\r\n        ValueTrader shop = ValueTrader(shopLocation);\r\n        shop.buyToken(token,shop.balanceOf(this));\r\n        assert(Token(token).transfer(profitContainerLocation,Token(token).balanceOf(this)));\r\n    }\r\n    \r\n    function giveAwayHoldership(address holderB) owned {\r\n        ShopKeeper(shopKeeperLocation).giveAwayOwnership(holderB);\r\n    }\r\n    \r\n    function giveAwayOwnership(address newOwner) owned {\r\n        owner = newOwner;\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"die\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token_\",\"type\":\"address\"}],\"name\":\"invalidateToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"eC\",\"type\":\"address\"}],\"name\":\"changeEtherContract\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burning\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token_\",\"type\":\"address\"}],\"name\":\"callDividend\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tradeFee\",\"type\":\"uint256\"}],\"name\":\"changeFee\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token_\",\"type\":\"address\"},{\"name\":\"bP_\",\"type\":\"uint256\"},{\"name\":\"bL_\",\"type\":\"uint256\"},{\"name\":\"pF_\",\"type\":\"uint256\"}],\"name\":\"validateToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"toggleBurn\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token_\",\"type\":\"address\"},{\"name\":\"hD_\",\"type\":\"bool\"},{\"name\":\"dA_\",\"type\":\"address\"},{\"name\":\"dD_\",\"type\":\"bytes\"}],\"name\":\"configureTokenDividend\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"draining\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sellEther\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyEther\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"currentPrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"toggleDrain\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sellToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"currentLiquidity\",\"outputs\":[{\"name\":\"liquidity\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenFrom\",\"type\":\"address\"},{\"name\":\"tokenTo\",\"type\":\"address\"},{\"name\":\"input\",\"type\":\"uint256\"}],\"name\":\"quickTrade\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"remaining\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"remaining\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromTokAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"toTokAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ValueTrader","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b1815232dc394e830d610929869517c573d3371a3b70d4276ed51c52a9e6d7cb"}]}