{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\ncontract Base {\r\n\r\n    function max(uint a, uint b) returns (uint) { return a >= b ? a : b; }\r\n    function min(uint a, uint b) returns (uint) { return a <= b ? a : b; }\r\n\r\n    modifier only(address allowed) {\r\n        if (msg.sender != allowed) throw;\r\n        _;\r\n    }\r\n\r\n\r\n    ///@return True if `_addr` is a contract\r\n    function isContract(address _addr) constant internal returns (bool) {\r\n        if (_addr == 0) return false;\r\n        uint size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return (size > 0);\r\n    }\r\n\r\n    // *************************************************\r\n    // *          reentrancy handling                  *\r\n    // *************************************************\r\n\r\n    //@dev predefined locks (up to uint bit length, i.e. 256 possible)\r\n    uint constant internal L00 = 2 ** 0;\r\n    uint constant internal L01 = 2 ** 1;\r\n    uint constant internal L02 = 2 ** 2;\r\n    uint constant internal L03 = 2 ** 3;\r\n    uint constant internal L04 = 2 ** 4;\r\n    uint constant internal L05 = 2 ** 5;\r\n\r\n    //prevents reentrancy attacs: specific locks\r\n    uint private bitlocks = 0;\r\n    modifier noReentrancy(uint m) {\r\n        var _locks = bitlocks;\r\n        if (_locks & m > 0) throw;\r\n        bitlocks |= m;\r\n        _;\r\n        bitlocks = _locks;\r\n    }\r\n\r\n    modifier noAnyReentrancy {\r\n        var _locks = bitlocks;\r\n        if (_locks > 0) throw;\r\n        bitlocks = uint(-1);\r\n        _;\r\n        bitlocks = _locks;\r\n    }\r\n\r\n    ///@dev empty marking modifier signaling to user of the marked function , that it can cause an reentrant call.\r\n    ///     developer should make the caller function reentrant-safe if it use a reentrant function.\r\n    modifier reentrant { _; }\r\n\r\n}\r\n\r\ncontract Owned is Base {\r\n\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) only(owner) {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() only(newOwner) {\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n}\r\n\r\n\r\ncontract ERC20 is Owned {\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function transfer(address _to, uint256 _value) isStartedOnly returns (bool success) {\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) isStartedOnly returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) isStartedOnly returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    uint256 public totalSupply;\r\n    bool    public isStarted = false;\r\n\r\n    modifier onlyHolder(address holder) {\r\n        if (balanceOf(holder) == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier isStartedOnly() {\r\n        if (!isStarted) throw;\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n//Decision made.\r\n// 1 - Provider is solely responsible to consider failed sub charge as an error and stop the service,\r\n//    therefore there is no separate error state or counter for that in this Token Contract.\r\n//\r\n// 2 - A call originated from the user (isContract(msg.sender)==false) should throw an exception on error,\r\n//     but it should return \"false\" on error if called from other contract (isContract(msg.sender)==true).\r\n//     Reason: thrown exception are easier to see in wallets, returned boolean values are easier to evaluate in the code of the calling contract.\r\n//\r\n// 3 - Service providers are responsible for firing events in case of offer changes;\r\n//     it is theirs decision to inform DApps about offer changes or not.\r\n//\r\n//ToDo:\r\n// 8 - validate linking modules and deployment process: attachToken(address token) public\r\n\r\n\r\n///@dev an base class to implement by Service Provider contract to be notified about subscription changes (in-Tx notification).\r\n///     Additionally it contains standard events to be fired by service provider on offer changes.\r\n///     see alse EVM events logged by subscription module.\r\n//\r\ncontract ServiceProvider {\r\n\r\n    ///@dev get human readable descriptor (or url) for this Service provider\r\n    //\r\n    function info() constant public returns(string);\r\n\r\n    ///@dev called to post-approve/reject incoming single payment.\r\n    ///@return `false` causes an exception and reverts the payment.\r\n    //\r\n    function onPayment(address _from, uint _value, bytes _paymentData) public returns (bool);\r\n\r\n    ///@dev called to post-approve/reject subscription charge.\r\n    ///@return `false` causes an exception and reverts the operation.\r\n    //\r\n    function onSubExecuted(uint subId) public returns (bool);\r\n\r\n    ///@dev called to post-approve/reject a creation of the subscription.\r\n    ///@return `false` causes an exception and reverts the operation.\r\n    //\r\n    function onSubNew(uint newSubId, uint offerId) public returns (bool);\r\n\r\n    ///@dev called to notify service provider about subscription cancellation.\r\n    ///     Provider is not able to prevent the cancellation.\r\n    ///@return <<reserved for future implementation>>\r\n    //\r\n    function onSubCanceled(uint subId, address caller) public returns (bool);\r\n\r\n    ///@dev called to notify service provider about subscription got hold/unhold.\r\n    ///@return `false` causes an exception and reverts the operation.\r\n    //\r\n    function onSubUnHold(uint subId, address caller, bool isOnHold) public returns (bool);\r\n\r\n\r\n    ///@dev following events should be used by ServiceProvider contract to notify DApps about offer changes.\r\n    ///     SubscriptionModule do not this notification and expects it from Service Provider if desired.\r\n    ///\r\n    ///@dev to be fired by ServiceProvider on new Offer created in a platform.\r\n    event OfferCreated(uint offerId,  bytes descriptor, address provider);\r\n\r\n    ///@dev to be fired by ServiceProvider on Offer updated.\r\n    event OfferUpdated(uint offerId,  bytes descriptor, uint oldExecCounter, address provider);\r\n\r\n    ///@dev to be fired by ServiceProvider on Offer canceled.\r\n    event OfferCanceled(uint offerId, bytes descriptor, address provider);\r\n\r\n    ///@dev to be fired by ServiceProvider on Offer hold/unhold status changed.\r\n    event OfferUnHold(uint offerId,   bytes descriptor, bool isOnHoldNow, address provider);\r\n} //ServiceProvider\r\n\r\n///@notice XRateProvider is an external service providing an exchange rate from external currency to SAN token.\r\n/// it used for subscriptions priced in other currency than SAN (even calculated and paid formally in SAN).\r\n/// if non-default XRateProvider is set for some subscription, then the amount in SAN for every periodic payment\r\n/// will be recalculated using provided exchange rate.\r\n///\r\n/// Please note, that the exchange rate fraction is (uint32,uint32) number. It should be enough to express\r\n/// any real exchange rate volatility. Nevertheless you are advised to avoid too big numbers in the fraction.\r\n/// Possiibly you could implement the ratio of multiple token per SAN in order to keep the average ratio around 1:1.\r\n///\r\n/// The default XRateProvider (with id==0) defines exchange rate 1:1 and represents exchange rate of SAN token to itself.\r\n/// this provider is set by defalult and thus the subscription becomes nominated in SAN.\r\n//\r\ncontract XRateProvider {\r\n\r\n    //@dev returns current exchange rate (in form of a simple fraction) from other currency to SAN (f.e. ETH:SAN).\r\n    //@dev fraction numbers are restricted to uint16 to prevent overflow in calculations;\r\n    function getRate() public returns (uint32 /*nominator*/, uint32 /*denominator*/);\r\n\r\n    //@dev provides a code for another currency, f.e. \"ETH\" or \"USD\"\r\n    function getCode() public returns (string);\r\n}\r\n\r\n\r\n//@dev data structure for SubscriptionModule\r\ncontract SubscriptionBase {\r\n\r\n    enum SubState   {NOT_EXIST, BEFORE_START, PAID, CHARGEABLE, ON_HOLD, CANCELED, EXPIRED, FINALIZED}\r\n    enum OfferState {NOT_EXIST, BEFORE_START, ACTIVE, SOLD_OUT, ON_HOLD, EXPIRED}\r\n\r\n    string[] internal SUB_STATES   = [\"NOT_EXIST\", \"BEFORE_START\", \"PAID\", \"CHARGEABLE\", \"ON_HOLD\", \"CANCELED\", \"EXPIRED\", \"FINALIZED\" ];\r\n    string[] internal OFFER_STATES = [\"NOT_EXIST\", \"BEFORE_START\", \"ACTIVE\", \"SOLD_OUT\", \"ON_HOLD\", \"EXPIRED\"];\r\n\r\n    //@dev subscription and subscription offer use the same structure. Offer is technically a template for subscription.\r\n    struct Subscription {\r\n        address transferFrom;   // customer (unset in subscription offer)\r\n        address transferTo;     // service provider\r\n        uint pricePerHour;      // price in SAN per hour (possibly recalculated using exchange rate)\r\n        uint32 initialXrate_n;  // nominator\r\n        uint32 initialXrate_d;  // denominator\r\n        uint16 xrateProviderId; // id of a registered exchange rate provider\r\n        uint paidUntil;         // subscription is paid until time\r\n        uint chargePeriod;      // subscription can't be charged more often than this period\r\n        uint depositAmount;     // upfront deposit on creating subscription (possibly recalculated using exchange rate)\r\n\r\n        uint startOn;           // for offer: can't be accepted before  <startOn> ; for subscription: can't be charged before <startOn>\r\n        uint expireOn;          // for offer: can't be accepted after  <expireOn> ; for subscription: can't be charged after  <expireOn>\r\n        uint execCounter;       // for offer: max num of subscriptions available  ; for subscription: num of charges made.\r\n        bytes descriptor;       // subscription payload (subject): evaluated by service provider.\r\n        uint onHoldSince;       // subscription: on-hold since time or 0 if not onHold. offer: unused: //ToDo: to be implemented\r\n    }\r\n\r\n    struct Deposit {\r\n        uint value;         // value on deposit\r\n        address owner;      // usually a customer\r\n        bytes descriptor;   // service related descriptor to be evaluated by service provider\r\n    }\r\n\r\n    event NewSubscription(address customer, address service, uint offerId, uint subId);\r\n    event NewDeposit(uint depositId, uint value, address sender);\r\n    event NewXRateProvider(address addr, uint16 xRateProviderId, address sender);\r\n    event DepositReturned(uint depositId, address returnedTo);\r\n    event SubscriptionDepositReturned(uint subId, uint amount, address returnedTo, address sender);\r\n    event OfferOnHold(uint offerId, bool onHold, address sender);\r\n    event OfferCanceled(uint offerId, address sender);\r\n    event SubOnHold(uint offerId, bool onHold, address sender);\r\n    event SubCanceled(uint subId, address sender);\r\n\r\n}\r\n\r\n///@dev an Interface for SubscriptionModule.\r\n///     extracted here for better overview.\r\n///     see detailed documentation in implementation module.\r\ncontract SubscriptionModule is SubscriptionBase, Base {\r\n\r\n    ///@dev ***** module configuration *****\r\n    function attachToken(address token) public;\r\n\r\n    ///@dev ***** single payment handling *****\r\n    function paymentTo(uint _value, bytes _paymentData, ServiceProvider _to) public reentrant returns (bool success);\r\n    function paymentFrom(uint _value, bytes _paymentData, address _from, ServiceProvider _to) public reentrant returns (bool success);\r\n\r\n    ///@dev ***** subscription handling *****\r\n    ///@dev some functions are marked as reentrant, even theirs implementation is marked with noReentrancy(LOCK).\r\n    ///     This is intentionally because these noReentrancy(LOCK) restrictions can be lifted in the future.\r\n    //      Functions would become reentrant.\r\n    function createSubscription(uint _offerId, uint _expireOn, uint _startOn) public reentrant returns (uint newSubId);\r\n    function cancelSubscription(uint subId) reentrant public;\r\n    function cancelSubscription(uint subId, uint gasReserve) reentrant public;\r\n    function holdSubscription(uint subId) public reentrant returns (bool success);\r\n    function unholdSubscription(uint subId) public reentrant returns (bool success);\r\n    function executeSubscription(uint subId) public reentrant returns (bool success);\r\n    function postponeDueDate(uint subId, uint newDueDate) public returns (bool success);\r\n    function returnSubscriptionDesposit(uint subId) public;\r\n    function claimSubscriptionDeposit(uint subId) public;\r\n    function state(uint subId) public constant returns(string state);\r\n    function stateCode(uint subId) public constant returns(uint stateCode);\r\n\r\n    ///@dev ***** subscription offer handling *****\r\n    function createSubscriptionOffer(uint _price, uint16 _xrateProviderId, uint _chargePeriod, uint _expireOn, uint _offerLimit, uint _depositValue, uint _startOn, bytes _descriptor) public reentrant returns (uint subId);\r\n    function updateSubscriptionOffer(uint offerId, uint _offerLimit) public;\r\n    function holdSubscriptionOffer(uint offerId) public returns (bool success);\r\n    function unholdSubscriptionOffer(uint offerId) public returns (bool success);\r\n    function cancelSubscriptionOffer(uint offerId) public returns (bool);\r\n\r\n    ///@dev ***** simple deposit handling *****\r\n    function createDeposit(uint _value, bytes _descriptor) public returns (uint subId);\r\n    function claimDeposit(uint depositId) public;\r\n\r\n    ///@dev ***** ExchangeRate provider *****\r\n    function registerXRateProvider(XRateProvider addr) public returns (uint16 xrateProviderId);\r\n\r\n    ///@dev ***** Service provider (payment receiver) *****\r\n    function enableServiceProvider(ServiceProvider addr, bytes moreInfo) public;\r\n    function disableServiceProvider(ServiceProvider addr, bytes moreInfo) public;\r\n\r\n\r\n    ///@dev ***** convenience subscription getter *****\r\n    function subscriptionDetails(uint subId) public constant returns(\r\n        address transferFrom,\r\n        address transferTo,\r\n        uint pricePerHour,\r\n        uint32 initialXrate_n, //nominator\r\n        uint32 initialXrate_d, //denominator\r\n        uint16 xrateProviderId,\r\n        uint chargePeriod,\r\n        uint startOn,\r\n        bytes descriptor\r\n    );\r\n\r\n    function subscriptionStatus(uint subId) public constant returns(\r\n        uint depositAmount,\r\n        uint expireOn,\r\n        uint execCounter,\r\n        uint paidUntil,\r\n        uint onHoldSince\r\n    );\r\n\r\n    enum PaymentStatus {OK, BALANCE_ERROR, APPROVAL_ERROR}\r\n    event Payment(address _from, address _to, uint _value, uint _fee, address sender, PaymentStatus status, uint subId);\r\n    event ServiceProviderEnabled(address addr, bytes moreInfo);\r\n    event ServiceProviderDisabled(address addr, bytes moreInfo);\r\n\r\n} //SubscriptionModule\r\n\r\ncontract ERC20ModuleSupport {\r\n    function _fulfillPreapprovedPayment(address _from, address _to, uint _value, address msg_sender) public returns(bool success);\r\n    function _fulfillPayment(address _from, address _to, uint _value, uint subId, address msg_sender) public returns (bool success);\r\n    function _mintFromDeposit(address owner, uint amount) public;\r\n    function _burnForDeposit(address owner, uint amount) public returns(bool success);\r\n}\r\n\r\n//@dev implementation\r\ncontract SubscriptionModuleImpl is SubscriptionModule, Owned  {\r\n\r\n    string public constant VERSION = \"0.1.0\";\r\n\r\n    // *************************************************\r\n    // *              contract states                  *\r\n    // *************************************************\r\n\r\n    ///@dev list of all registered service provider contracts implemented as a map for better lookup.\r\n    mapping (address=>bool) public providerRegistry;\r\n\r\n    ///@dev all subscriptions and offers (incl. FINALIZED).\r\n    mapping (uint => Subscription) public subscriptions;\r\n\r\n    ///@dev all active simple deposits gived by depositId.\r\n    mapping (uint => Deposit) public deposits;\r\n\r\n    ///@dev addresses of registered exchange rate providers.\r\n    XRateProvider[] public xrateProviders;\r\n\r\n    ///@dev ongoing counter for subscription ids starting from 1.\r\n    ///     Current value represents an id of last created subscription.\r\n    uint public subscriptionCounter = 0;\r\n\r\n    ///@dev ongoing counter for simple deposit ids starting from 1.\r\n    ///     Current value represents an id of last created deposit.\r\n    uint public depositCounter = 0;\r\n\r\n    ///@dev Token contract with ERC20ModuleSupport addon.\r\n    ///     Subscription Module operates on its balances via ERC20ModuleSupport interface as trusted module.\r\n    ERC20ModuleSupport public san;\r\n\r\n\r\n\r\n    // *************************************************\r\n    // *     reject all ether sent to this contract    *\r\n    // *************************************************\r\n    function () {\r\n        throw;\r\n    }\r\n\r\n\r\n\r\n    // *************************************************\r\n    // *            setup and configuration            *\r\n    // *************************************************\r\n\r\n    ///@dev constructor\r\n    function SubscriptionModuleImpl() {\r\n        owner = msg.sender;\r\n        xrateProviders.push(XRateProvider(this)); //this is a default SAN:SAN (1:1) provider with default id == 0\r\n    }\r\n\r\n\r\n    ///@dev attach SAN token to work with; can be done only once.\r\n    function attachToken(address token) public {\r\n        assert(address(san) == 0); //only in new deployed state\r\n        san = ERC20ModuleSupport(token);\r\n    }\r\n\r\n\r\n    ///@dev register a new service provider to the platform.\r\n    function enableServiceProvider(ServiceProvider addr, bytes moreInfo) public only(owner) {\r\n        providerRegistry[addr] = true;\r\n        ServiceProviderEnabled(addr, moreInfo);\r\n    }\r\n\r\n\r\n    ///@dev de-register the service provider with given `addr`.\r\n    function disableServiceProvider(ServiceProvider addr, bytes moreInfo) public only(owner) {\r\n        delete providerRegistry[addr];\r\n        ServiceProviderDisabled(addr, moreInfo);\r\n    }\r\n\r\n\r\n    ///@dev register new exchange rate provider.\r\n    ///     XRateProvider can't be de-registered, because they could be still in use by some subscription.\r\n    function registerXRateProvider(XRateProvider addr) public only(owner) returns (uint16 xrateProviderId) {\r\n        xrateProviderId = uint16(xrateProviders.length);\r\n        xrateProviders.push(addr);\r\n        NewXRateProvider(addr, xrateProviderId, msg.sender);\r\n    }\r\n\r\n\r\n    ///@dev xrateProviders length accessor.\r\n    function getXRateProviderLength() public constant returns (uint) {\r\n        return xrateProviders.length;\r\n    }\r\n\r\n\r\n    // *************************************************\r\n    // *           single payment methods              *\r\n    // *************************************************\r\n\r\n    ///@notice makes single payment to service provider.\r\n    ///@param _value - amount of SAN token to sent\r\n    ///@param _paymentData - 'payment purpose' code usually issued by service provider to customer before payment.\r\n    ///@param _to - service provider contract\r\n    ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract)\r\n    //\r\n    function paymentTo(uint _value, bytes _paymentData, ServiceProvider _to) public reentrant returns (bool success) {\r\n        if (san._fulfillPayment(msg.sender, _to, _value, 0, msg.sender)) {\r\n            // a ServiceProvider (a ServiceProvider) has here an opportunity verify and reject the payment\r\n            assert (ServiceProvider(_to).onPayment(msg.sender, _value, _paymentData));                      // <=== possible reentrancy\r\n            return true;\r\n        }\r\n        if (isContract(msg.sender)) { return false; }\r\n        else { throw; }\r\n    }\r\n\r\n\r\n    ///@notice makes single preapproved payment to service provider. An amount must be already preapproved by payment sender to recepient.\r\n    ///@param _value - amount of SAN token to sent\r\n    ///@param _paymentData - 'payment purpose' code usually issued by service provider to customer before payment.\r\n    ///@param _from - sender of the payment (other than msg.sender)\r\n    ///@param _to - service provider contract\r\n    ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract)\r\n    //\r\n    function paymentFrom(uint _value, bytes _paymentData, address _from, ServiceProvider _to) public reentrant returns (bool success) {\r\n        if (san._fulfillPreapprovedPayment(_from, _to, _value, msg.sender)) {\r\n            // a ServiceProvider (a ServiceProvider) has here an opportunity verify and reject the payment\r\n            assert (ServiceProvider(_to).onPayment(_from, _value, _paymentData));                           // <=== possible reentrancy\r\n            return true;\r\n        }\r\n        if (isContract(msg.sender)) { return false; }\r\n        else { throw; }\r\n    }\r\n\r\n\r\n    // *************************************************\r\n    // *            subscription handling              *\r\n    // *************************************************\r\n\r\n    ///@dev convenience getter for some subscription fields\r\n    function subscriptionDetails(uint subId) public constant returns (\r\n        address transferFrom,\r\n        address transferTo,\r\n        uint pricePerHour,\r\n        uint32 initialXrate_n, //nominator\r\n        uint32 initialXrate_d, //denominator\r\n        uint16 xrateProviderId,\r\n        uint chargePeriod,\r\n        uint startOn,\r\n        bytes descriptor\r\n    ) {\r\n        Subscription sub = subscriptions[subId];\r\n        return (sub.transferFrom, sub.transferTo, sub.pricePerHour, sub.initialXrate_n, sub.initialXrate_d, sub.xrateProviderId, sub.chargePeriod, sub.startOn, sub.descriptor);\r\n    }\r\n\r\n\r\n    ///@dev convenience getter for some subscription fields\r\n    ///     a caller must know, that the subscription with given id exists, because all these fields can be 0 even the subscription with given id exists.\r\n    function subscriptionStatus(uint subId) public constant returns(\r\n        uint depositAmount,\r\n        uint expireOn,\r\n        uint execCounter,\r\n        uint paidUntil,\r\n        uint onHoldSince\r\n    ) {\r\n        Subscription sub = subscriptions[subId];\r\n        return (sub.depositAmount, sub.expireOn, sub.execCounter, sub.paidUntil, sub.onHoldSince);\r\n    }\r\n\r\n\r\n    ///@notice execute periodic subscription payment.\r\n    ///        Any of customer, service provider and platform owner can execute this function.\r\n    ///        This ensures, that the subscription charge doesn't become delayed.\r\n    ///        At least the platform owner has an incentive to get fee and thus can trigger the function.\r\n    ///        An execution fails if subscription is not in status `CHARGEABLE`.\r\n    ///@param subId - subscription to be charged.\r\n    ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract)\r\n    //\r\n    function executeSubscription(uint subId) public noReentrancy(L00) returns (bool) {\r\n        Subscription storage sub = subscriptions[subId];\r\n        assert (msg.sender == sub.transferFrom || msg.sender == sub.transferTo || msg.sender == owner);\r\n        if (_subscriptionState(sub)==SubState.CHARGEABLE) {\r\n            var _from = sub.transferFrom;\r\n            var _to = sub.transferTo;\r\n            var _value = _amountToCharge(sub);\r\n            if (san._fulfillPayment(_from, _to, _value, subId, msg.sender)) {\r\n                sub.paidUntil  = max(sub.paidUntil, sub.startOn) + sub.chargePeriod;\r\n                ++sub.execCounter;\r\n                // a ServiceProvider (a ServiceProvider) has here an opportunity to verify and reject the payment\r\n                assert (ServiceProvider(_to).onSubExecuted(subId));\r\n                return true;\r\n            }\r\n        }\r\n        if (isContract(msg.sender)) { return false; }\r\n        else { throw; }\r\n    }\r\n\r\n\r\n    ///@notice move `paidUntil` forward to given `newDueDate`. It waives payments for given time.\r\n    ///        This function can be used by service provider to `give away` some service time for free.\r\n    ///@param subId - id of subscription to be postponed.\r\n    ///@param newDueDate - new `paidUntil` datetime; require `newDueDate > paidUntil`.\r\n    ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract)\r\n    //\r\n    function postponeDueDate(uint subId, uint newDueDate) public returns (bool success){\r\n        Subscription storage sub = subscriptions[subId];\r\n        assert (_isSubscription(sub));\r\n        assert (sub.transferTo == msg.sender); //only Service Provider is allowed to postpone the DueDate\r\n        if (sub.paidUntil < newDueDate) {\r\n            sub.paidUntil = newDueDate;\r\n            return true;\r\n        } else if (isContract(msg.sender)) { return false; }\r\n          else { throw; }\r\n    }\r\n\r\n\r\n    ///@dev return current status as a name of a subscription (or an offer) with given id;\r\n    function state(uint subOrOfferId) public constant returns(string state) {\r\n        Subscription subOrOffer = subscriptions[subOrOfferId];\r\n        return _isOffer(subOrOffer)\r\n              ? OFFER_STATES[uint(_offerState(subOrOffer))]\r\n              : SUB_STATES[uint(_subscriptionState(subOrOffer))];\r\n    }\r\n\r\n\r\n    ///@dev return current status as a code of a subscription (or an offer) with given id;\r\n    function stateCode(uint subOrOfferId) public constant returns(uint stateCode) {\r\n        Subscription subOrOffer = subscriptions[subOrOfferId];\r\n        return _isOffer(subOrOffer)\r\n              ? uint(_offerState(subOrOffer))\r\n              : uint(_subscriptionState(subOrOffer));\r\n    }\r\n\r\n\r\n    function _offerState(Subscription storage sub) internal constant returns(OfferState status) {\r\n        if (!_isOffer(sub)) {\r\n            return OfferState.NOT_EXIST;\r\n        } else if (sub.startOn > now) {\r\n            return OfferState.BEFORE_START;\r\n        } else if (sub.onHoldSince > 0) {\r\n            return OfferState.ON_HOLD;\r\n        } else if (now <= sub.expireOn) {\r\n            return sub.execCounter > 0\r\n                ? OfferState.ACTIVE\r\n                : OfferState.SOLD_OUT;\r\n        } else {\r\n            return OfferState.EXPIRED;\r\n        }\r\n    }\r\n\r\n    function _subscriptionState(Subscription storage sub) internal constant returns(SubState status) {\r\n        if (!_isSubscription(sub)) {\r\n            return SubState.NOT_EXIST;\r\n        } else if (sub.startOn > now) {\r\n            return SubState.BEFORE_START;\r\n        } else if (sub.onHoldSince > 0) {\r\n            return SubState.ON_HOLD;\r\n        } else if (sub.paidUntil >= sub.expireOn) {\r\n            return now < sub.expireOn\r\n                ? SubState.CANCELED\r\n                : sub.depositAmount > 0\r\n                    ? SubState.EXPIRED\r\n                    : SubState.FINALIZED;\r\n        } else if (sub.paidUntil <= now) {\r\n            return SubState.CHARGEABLE;\r\n        } else {\r\n            return SubState.PAID;\r\n        }\r\n    }\r\n\r\n\r\n    ///@notice create a new subscription offer.\r\n    ///@dev only registered service provider is allowed to create offers.\r\n    ///@dev subscription uses SAN token for payment, but an exact amount to be paid or deposit is calculated using exchange rate from external xrateProvider (previosly registered on platform).\r\n    ///    This allows to create a subscription bound to another token or even fiat currency.\r\n    ///@param _pricePerHour - subscription price per hour in SAN\r\n    ///@param _xrateProviderId - id of external exchange rate provider from subscription currency to SAN; \"0\" means subscription is priced in SAN natively.\r\n    ///@param _chargePeriod - time period to charge; subscription can't be charged more often than this period. Time units are native ethereum time, returning by `now`, i.e. seconds.\r\n    ///@param _expireOn - offer can't be accepted after this time.\r\n    ///@param _offerLimit - how many subscription are available to created from this offer; there is no magic number for unlimited offer -- use big number instead.\r\n    ///@param _depositAmount - upfront deposit required for creating a subscription; this deposit becomes fully returned on subscription is over.\r\n    ///       currently this deposit is not subject of platform fees and will be refunded in full. Next versions of this module can use deposit in case of outstanding payments.\r\n    ///@param _startOn - a subscription from this offer can't be created before this time. Time units are native ethereum time, returning by `now`, i.e. seconds.\r\n    ///@param _descriptor - arbitrary bytes as an offer descriptor. This descriptor is copied into subscription and then service provider becomes it passed in notifications.\r\n    //\r\n    function createSubscriptionOffer(uint _pricePerHour, uint16 _xrateProviderId, uint _chargePeriod, uint _expireOn, uint _offerLimit, uint _depositAmount, uint _startOn, bytes _descriptor)\r\n    public\r\n    noReentrancy(L01)\r\n    onlyRegisteredProvider\r\n    returns (uint subId) {\r\n        assert (_startOn < _expireOn);\r\n        assert (_chargePeriod <= 10 years); //sanity check\r\n        var (_xrate_n, _xrate_d) = _xrateProviderId == 0\r\n                                 ? (1,1)\r\n                                 : XRateProvider(xrateProviders[_xrateProviderId]).getRate(); // <=== possible reentrancy\r\n        assert (_xrate_n > 0 && _xrate_d > 0);\r\n        subscriptions[++subscriptionCounter] = Subscription ({\r\n            transferFrom    : 0,                  // empty transferFrom field means we have an offer, not a subscription\r\n            transferTo      : msg.sender,         // service provider is a beneficiary of subscripton payments\r\n            pricePerHour    : _pricePerHour,      // price per hour in SAN (recalculated from base currency if needed)\r\n            xrateProviderId : _xrateProviderId,   // id of registered exchange rate provider or zero if an offer is nominated in SAN.\r\n            initialXrate_n  : _xrate_n,           // fraction nominator of the initial exchange rate\r\n            initialXrate_d  : _xrate_d,           // fraction denominator of the initial exchange rate\r\n            paidUntil       : 0,                  // service is considered to be paid until this time; no charge is possible while subscription is paid for now.\r\n            chargePeriod    : _chargePeriod,      // period in seconds (ethereum block time unit) to charge.\r\n            depositAmount   : _depositAmount,     // deposit required for subscription accept.\r\n            startOn         : _startOn,\r\n            expireOn        : _expireOn,\r\n            execCounter     : _offerLimit,\r\n            descriptor      : _descriptor,\r\n            onHoldSince     : 0                   // offer is not on hold by default.\r\n        });\r\n        return subscriptionCounter;               // returns an id of the new offer.\r\n    }\r\n\r\n\r\n    ///@notice updates currently available number of subscription for this offer.\r\n    ///        Other offer's parameter can't be updated because they are considered to be a public offer reviewed by customers.\r\n    ///        The service provider should recreate the offer as a new one in case of other changes.\r\n    //\r\n    function updateSubscriptionOffer(uint _offerId, uint _offerLimit) public {\r\n        Subscription storage offer = subscriptions[_offerId];\r\n        assert (_isOffer(offer));\r\n        assert (offer.transferTo == msg.sender); //only Provider is allowed to update the offer.\r\n        offer.execCounter = _offerLimit;\r\n    }\r\n\r\n\r\n    ///@notice accept given offer and create a new subscription on the base of it.\r\n    ///\r\n    ///@dev the service provider (offer.`transferTo`) becomes notified about new subscription by call `onSubNew(newSubId, _offerId)`.\r\n    ///     It is provider's responsibility to retrieve and store any necessary information about offer and this new subscription. Some of info is only available at this point.\r\n    ///     The Service Provider can also reject the new subscription by throwing an exception or returning `false` from `onSubNew(newSubId, _offerId)` event handler.\r\n    ///@param _offerId   - id of the offer to be accepted\r\n    ///@param _expireOn  - subscription expiration time; no charges are possible behind this time.\r\n    ///@param _startOn   - subscription start time; no charges are possible before this time.\r\n    ///                    If the `_startOn` is in the past or is zero, it means start the subscription ASAP.\r\n    //\r\n    function createSubscription(uint _offerId, uint _expireOn, uint _startOn) public noReentrancy(L02) returns (uint newSubId) {\r\n        assert (_startOn < _expireOn);\r\n        Subscription storage offer = subscriptions[_offerId];\r\n        assert (_isOffer(offer));\r\n        assert (offer.startOn == 0     || offer.startOn  <= now);\r\n        assert (offer.expireOn == 0    || offer.expireOn >= now);\r\n        assert (offer.onHoldSince == 0);\r\n        assert (offer.execCounter > 0);\r\n        --offer.execCounter;\r\n        newSubId = ++subscriptionCounter;\r\n        //create a clone of the offer...\r\n        Subscription storage newSub = subscriptions[newSubId] = offer;\r\n        //... and adjust some fields specific to subscription\r\n        newSub.transferFrom = msg.sender;\r\n        newSub.execCounter = 0;\r\n        newSub.paidUntil = newSub.startOn = max(_startOn, now);     //no debts before actual creation time!\r\n        newSub.expireOn = _expireOn;\r\n        newSub.depositAmount = _applyXchangeRate(newSub.depositAmount, newSub);                    // <=== possible reentrancy\r\n        //depositAmount is now stored in the sub, so burn the same amount from customer's account.\r\n        assert (san._burnForDeposit(msg.sender, newSub.depositAmount));\r\n        assert (ServiceProvider(newSub.transferTo).onSubNew(newSubId, _offerId));                  // <=== possible reentrancy; service provider can still reject the new subscription here\r\n\r\n        NewSubscription(newSub.transferFrom, newSub.transferTo, _offerId, newSubId);\r\n        return newSubId;\r\n    }\r\n\r\n\r\n    ///@notice cancel an offer given by `offerId`.\r\n    ///@dev sets offer.`expireOn` to `expireOn`.\r\n    ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract)\r\n    //\r\n    function cancelSubscriptionOffer(uint offerId) public returns (bool) {\r\n        Subscription storage offer = subscriptions[offerId];\r\n        assert (_isOffer(offer));\r\n        assert (offer.transferTo == msg.sender || owner == msg.sender); //only service provider or platform owner is allowed to cancel the offer\r\n        if (offer.expireOn>now){\r\n            offer.expireOn = now;\r\n            OfferCanceled(offerId, msg.sender);\r\n            return true;\r\n        }\r\n        if (isContract(msg.sender)) { return false; }\r\n        else { throw; }\r\n    }\r\n\r\n\r\n    ///@notice cancel an subscription given by `subId` (a graceful version).\r\n    ///@notice IMPORTANT: a malicious service provider can consume all gas and preventing subscription from cancellation.\r\n    ///        If so, use `cancelSubscription(uint subId, uint gasReserve)` as the forced version.\r\n    ///         see `cancelSubscription(uint subId, uint gasReserve)` for more documentation.\r\n    //\r\n    function cancelSubscription(uint subId) public {\r\n        return cancelSubscription(subId, 0);\r\n    }\r\n\r\n\r\n    ///@notice cancel an subscription given by `subId` (a forced version).\r\n    ///        Cancellation means no further charges to this subscription are possible. The provided subscription deposit can be withdrawn only `paidUntil` period is over.\r\n    ///        Depending on nature of the service provided, the service provider can allow an immediate deposit withdrawal by `returnSubscriptionDesposit(uint subId)` call, but its on his own.\r\n    ///        In some business cases a deposit must remain locked until `paidUntil` period is over even, the subscription is already canceled.\r\n    ///@notice gasReserve is a gas amount reserved for contract execution AFTER service provider becomes `onSubCanceled(uint256,address)` notification.\r\n    ///        It guarantees, that cancellation becomes executed even a (malicious) service provider consumes all gas provided.\r\n    ///        If so, use `cancelSubscription(uint subId, uint gasReserve)` as the forced version.\r\n    ///        This difference is because the customer must always have a possibility to cancel his contract even the service provider disagree on cancellation.\r\n    ///@param subId - subscription to be cancelled\r\n    ///@param gasReserve - gas reserved for call finalization (minimum reservation is 10000 gas)\r\n    //\r\n    function cancelSubscription(uint subId, uint gasReserve) public noReentrancy(L03) {\r\n        Subscription storage sub = subscriptions[subId];\r\n        assert (sub.transferFrom == msg.sender || owner == msg.sender); //only subscription owner or platform owner is allowed to cancel it\r\n        assert (_isSubscription(sub));\r\n        var _to = sub.transferTo;\r\n        sub.expireOn = max(now, sub.paidUntil);\r\n        if (msg.sender != _to) {\r\n            //supress re-throwing of exceptions; reserve enough gas to finish this function\r\n            gasReserve = max(gasReserve,10000);  //reserve minimum 10000 gas\r\n            assert (msg.gas > gasReserve);       //sanity check\r\n            if (_to.call.gas(msg.gas-gasReserve)(bytes4(sha3(\"onSubCanceled(uint256,address)\")), subId, msg.sender)) {     // <=== possible reentrancy\r\n                //do nothing. it is notification only.\r\n                //Later: is it possible to evaluate return value here? If is better to return the subscription deposit here.\r\n            }\r\n        }\r\n        SubCanceled(subId, msg.sender);\r\n    }\r\n\r\n\r\n    ///@notice place an active offer on hold; it means no subscriptions can be created from this offer.\r\n    ///        Only service provider (or platform owner) is allowed to hold/unhold a subscription offer.\r\n    ///@param offerId - id of the offer to be placed on hold.\r\n    ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract)\r\n    //\r\n    function holdSubscriptionOffer(uint offerId) public returns (bool success) {\r\n        Subscription storage offer = subscriptions[offerId];\r\n        assert (_isOffer(offer));\r\n        require (msg.sender == offer.transferTo || msg.sender == owner); //only owner or service provider can place the offer on hold.\r\n        if (offer.onHoldSince == 0) {\r\n            offer.onHoldSince = now;\r\n            OfferOnHold(offerId, true, msg.sender);\r\n            return true;\r\n        }\r\n        if (isContract(msg.sender)) { return false; }\r\n        else { throw; }\r\n    }\r\n\r\n\r\n    ///@notice resume on-hold offer; subscriptions can be created from this offer again (if other conditions are met).\r\n    ///        Only service provider (or platform owner) is allowed to hold/unhold a subscription offer.\r\n    ///@param offerId - id of the offer to be resumed.\r\n    ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract)\r\n    //\r\n    function unholdSubscriptionOffer(uint offerId) public returns (bool success) {\r\n        Subscription storage offer = subscriptions[offerId];\r\n        assert (_isOffer(offer));\r\n        require (msg.sender == offer.transferTo || msg.sender == owner); //only owner or service provider can reactivate the offer.\r\n        if (offer.onHoldSince > 0) {\r\n            offer.onHoldSince = 0;\r\n            OfferOnHold(offerId, false, msg.sender);\r\n            return true;\r\n        }\r\n        if (isContract(msg.sender)) { return false; }\r\n        else { throw; }\r\n    }\r\n\r\n\r\n    ///@notice called by customer or service provider to place a subscription on hold.\r\n    ///        If call is originated by customer the service provider can reject the request.\r\n    ///        A subscription on hold will not be charged. The service is usually not provided as well.\r\n    ///        During hold time a subscription preserve remaining paid time period, which becomes available after unhold.\r\n    ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract)\r\n    //\r\n    function holdSubscription(uint subId) public noReentrancy(L04) returns (bool success) {\r\n        Subscription storage sub = subscriptions[subId];\r\n        assert (_isSubscription(sub));\r\n        var _to = sub.transferTo;\r\n        require (msg.sender == _to || msg.sender == sub.transferFrom); //only customer or provider can place the subscription on hold.\r\n        if (sub.onHoldSince == 0) {\r\n            if (msg.sender == _to || ServiceProvider(_to).onSubUnHold(subId, msg.sender, true)) {          // <=== possible reentrancy\r\n                sub.onHoldSince = now;\r\n                SubOnHold(subId, true, msg.sender);\r\n                return true;\r\n            }\r\n        }\r\n        if (isContract(msg.sender)) { return false; }\r\n        else { throw; }\r\n    }\r\n\r\n\r\n    ///@notice called by customer or service provider to unhold subscription.\r\n    ///        If call is originated by customer the service provider can reject the request.\r\n    ///        A subscription on hold will not be charged. The service is usually not provided as well.\r\n    ///        During hold time a subscription preserve remaining paid time period, which becomes available after unhold.\r\n    ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract)\r\n    //\r\n    function unholdSubscription(uint subId) public noReentrancy(L05) returns (bool success) {\r\n        Subscription storage sub = subscriptions[subId];\r\n        assert (_isSubscription(sub));\r\n        var _to = sub.transferTo;\r\n        require (msg.sender == _to || msg.sender == sub.transferFrom); //only customer or provider can place the subscription on hold.\r\n        if (sub.onHoldSince > 0) {\r\n            if (msg.sender == _to || ServiceProvider(_to).onSubUnHold(subId, msg.sender, false)) {         // <=== possible reentrancy\r\n                sub.paidUntil += now - sub.onHoldSince;\r\n                sub.onHoldSince = 0;\r\n                SubOnHold(subId, false, msg.sender);\r\n                return true;\r\n            }\r\n        }\r\n        if (isContract(msg.sender)) { return false; }\r\n        else { throw; }\r\n    }\r\n\r\n\r\n\r\n    // *************************************************\r\n    // *              deposit handling                 *\r\n    // *************************************************\r\n\r\n    ///@notice can be called by provider on CANCELED subscription to return a subscription deposit to customer immediately.\r\n    ///        Customer can anyway collect his deposit after `paidUntil` period is over.\r\n    ///@param subId - subscription holding the deposit\r\n    //\r\n    function returnSubscriptionDesposit(uint subId) public {\r\n        Subscription storage sub = subscriptions[subId];\r\n        assert (_subscriptionState(sub) == SubState.CANCELED);\r\n        assert (sub.depositAmount > 0); //sanity check\r\n        assert (sub.transferTo == msg.sender || owner == msg.sender); //only subscription owner or platform owner is allowed to release deposit.\r\n        sub.expireOn = now;\r\n        _returnSubscriptionDesposit(subId, sub);\r\n    }\r\n\r\n\r\n    ///@notice called by customer on EXPIRED subscription (`paidUntil` period is over) to collect a subscription deposit.\r\n    ///        Customer can anyway collect his deposit after `paidUntil` period is over.\r\n    ///@param subId - subscription holding the deposit\r\n    //\r\n    function claimSubscriptionDeposit(uint subId) public {\r\n        Subscription storage sub = subscriptions[subId];\r\n        assert (_subscriptionState(sub) == SubState.EXPIRED);\r\n        assert (sub.transferFrom == msg.sender);\r\n        assert (sub.depositAmount > 0);\r\n        _returnSubscriptionDesposit(subId, sub);\r\n    }\r\n\r\n\r\n    //@dev returns subscription deposit to customer\r\n    function _returnSubscriptionDesposit(uint subId, Subscription storage sub) internal {\r\n        uint depositAmount = sub.depositAmount;\r\n        sub.depositAmount = 0;\r\n        san._mintFromDeposit(sub.transferFrom, depositAmount);\r\n        SubscriptionDepositReturned(subId, depositAmount, sub.transferFrom, msg.sender);\r\n    }\r\n\r\n\r\n    ///@notice create simple unlocked deposit, required by some services. It can be considered as prove of customer's stake.\r\n    ///        This desposit can be claimed back by the customer at anytime.\r\n    ///        The service provider is responsible to check the deposit before providing the service.\r\n    ///@param _value - non zero deposit amount.\r\n    ///@param _descriptor - is a uniq key, usually given by service provider to the customer in order to make this deposit unique.\r\n    ///        Service Provider should reject deposit with unknown descriptor, because most probably it is in use for some another service.\r\n    ///@return depositId - a handle to claim back the deposit later.\r\n    //\r\n    function createDeposit(uint _value, bytes _descriptor) public returns (uint depositId) {\r\n        require (_value > 0);\r\n        assert (san._burnForDeposit(msg.sender,_value));\r\n        deposits[++depositCounter] = Deposit ({\r\n            owner : msg.sender,\r\n            value : _value,\r\n            descriptor : _descriptor\r\n        });\r\n        NewDeposit(depositCounter, _value, msg.sender);\r\n        return depositCounter;\r\n    }\r\n\r\n\r\n    ///@notice return previously created deposit to the user. User can collect only own deposit.\r\n    ///        The service provider is responsible to check the deposit before providing the service.\r\n    ///@param _depositId - an id of the deposit to be collected.\r\n    //\r\n    function claimDeposit(uint _depositId) public {\r\n        var deposit = deposits[_depositId];\r\n        require (deposit.owner == msg.sender);\r\n        var value = deposits[_depositId].value;\r\n        delete deposits[_depositId];\r\n        san._mintFromDeposit(msg.sender, value);\r\n        DepositReturned(_depositId, msg.sender);\r\n    }\r\n\r\n\r\n\r\n    // *************************************************\r\n    // *            some internal functions            *\r\n    // *************************************************\r\n\r\n    function _amountToCharge(Subscription storage sub) internal reentrant returns (uint) {\r\n        return _applyXchangeRate(sub.pricePerHour * sub.chargePeriod, sub) / 1 hours;       // <==== reentrant function usage\r\n    }\r\n\r\n    function _applyXchangeRate(uint amount, Subscription storage sub) internal reentrant returns (uint) {  // <== actually called from reentrancy guarded context only (i.e. externally secured)\r\n        if (sub.xrateProviderId > 0) {\r\n            // xrate_n: nominator\r\n            // xrate_d: denominator of the exchange rate fraction.\r\n            var (xrate_n, xrate_d) = XRateProvider(xrateProviders[sub.xrateProviderId]).getRate();        // <=== possible reentrancy\r\n            amount = amount * sub.initialXrate_n * xrate_d / sub.initialXrate_d / xrate_n;\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    function _isOffer(Subscription storage sub) internal constant returns (bool){\r\n        return sub.transferFrom == 0 && sub.transferTo != 0;\r\n    }\r\n\r\n    function _isSubscription(Subscription storage sub) internal constant returns (bool){\r\n        return sub.transferFrom != 0 && sub.transferTo != 0;\r\n    }\r\n\r\n    function _exists(Subscription storage sub) internal constant returns (bool){\r\n        return sub.transferTo != 0;   //existing subscription or offer has always transferTo set.\r\n    }\r\n\r\n    modifier onlyRegisteredProvider(){\r\n        if (!providerRegistry[msg.sender]) throw;\r\n        _;\r\n    }\r\n\r\n} //SubscriptionModuleImpl","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"moreInfo\",\"type\":\"bytes\"}],\"name\":\"disableServiceProvider\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"subId\",\"type\":\"uint256\"}],\"name\":\"returnSubscriptionDesposit\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"subId\",\"type\":\"uint256\"}],\"name\":\"cancelSubscription\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"subscriptions\",\"outputs\":[{\"name\":\"transferFrom\",\"type\":\"address\"},{\"name\":\"transferTo\",\"type\":\"address\"},{\"name\":\"pricePerHour\",\"type\":\"uint256\"},{\"name\":\"initialXrate_n\",\"type\":\"uint32\"},{\"name\":\"initialXrate_d\",\"type\":\"uint32\"},{\"name\":\"xrateProviderId\",\"type\":\"uint16\"},{\"name\":\"paidUntil\",\"type\":\"uint256\"},{\"name\":\"chargePeriod\",\"type\":\"uint256\"},{\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"name\":\"startOn\",\"type\":\"uint256\"},{\"name\":\"expireOn\",\"type\":\"uint256\"},{\"name\":\"execCounter\",\"type\":\"uint256\"},{\"name\":\"descriptor\",\"type\":\"bytes\"},{\"name\":\"onHoldSince\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subId\",\"type\":\"uint256\"}],\"name\":\"subscriptionDetails\",\"outputs\":[{\"name\":\"transferFrom\",\"type\":\"address\"},{\"name\":\"transferTo\",\"type\":\"address\"},{\"name\":\"pricePerHour\",\"type\":\"uint256\"},{\"name\":\"initialXrate_n\",\"type\":\"uint32\"},{\"name\":\"initialXrate_d\",\"type\":\"uint32\"},{\"name\":\"xrateProviderId\",\"type\":\"uint16\"},{\"name\":\"chargePeriod\",\"type\":\"uint256\"},{\"name\":\"startOn\",\"type\":\"uint256\"},{\"name\":\"descriptor\",\"type\":\"bytes\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_paymentData\",\"type\":\"bytes\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"paymentFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subOrOfferId\",\"type\":\"uint256\"}],\"name\":\"state\",\"outputs\":[{\"name\":\"state\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"attachToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subId\",\"type\":\"uint256\"}],\"name\":\"subscriptionStatus\",\"outputs\":[{\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"name\":\"expireOn\",\"type\":\"uint256\"},{\"name\":\"execCounter\",\"type\":\"uint256\"},{\"name\":\"paidUntil\",\"type\":\"uint256\"},{\"name\":\"onHoldSince\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"registerXRateProvider\",\"outputs\":[{\"name\":\"xrateProviderId\",\"type\":\"uint16\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pricePerHour\",\"type\":\"uint256\"},{\"name\":\"_xrateProviderId\",\"type\":\"uint16\"},{\"name\":\"_chargePeriod\",\"type\":\"uint256\"},{\"name\":\"_expireOn\",\"type\":\"uint256\"},{\"name\":\"_offerLimit\",\"type\":\"uint256\"},{\"name\":\"_depositAmount\",\"type\":\"uint256\"},{\"name\":\"_startOn\",\"type\":\"uint256\"},{\"name\":\"_descriptor\",\"type\":\"bytes\"}],\"name\":\"createSubscriptionOffer\",\"outputs\":[{\"name\":\"subId\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_depositId\",\"type\":\"uint256\"}],\"name\":\"claimDeposit\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"moreInfo\",\"type\":\"bytes\"}],\"name\":\"enableServiceProvider\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"subId\",\"type\":\"uint256\"},{\"name\":\"newDueDate\",\"type\":\"uint256\"}],\"name\":\"postponeDueDate\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"max\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"offerId\",\"type\":\"uint256\"}],\"name\":\"unholdSubscriptionOffer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"min\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"subId\",\"type\":\"uint256\"}],\"name\":\"holdSubscription\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"subscriptionCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"offerId\",\"type\":\"uint256\"}],\"name\":\"holdSubscriptionOffer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_offerId\",\"type\":\"uint256\"},{\"name\":\"_offerLimit\",\"type\":\"uint256\"}],\"name\":\"updateSubscriptionOffer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"offerId\",\"type\":\"uint256\"}],\"name\":\"cancelSubscriptionOffer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"descriptor\",\"type\":\"bytes\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_offerId\",\"type\":\"uint256\"},{\"name\":\"_expireOn\",\"type\":\"uint256\"},{\"name\":\"_startOn\",\"type\":\"uint256\"}],\"name\":\"createSubscription\",\"outputs\":[{\"name\":\"newSubId\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"subId\",\"type\":\"uint256\"}],\"name\":\"claimSubscriptionDeposit\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_paymentData\",\"type\":\"bytes\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"paymentTo\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subOrOfferId\",\"type\":\"uint256\"}],\"name\":\"stateCode\",\"outputs\":[{\"name\":\"stateCode\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"providerRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"san\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"subId\",\"type\":\"uint256\"},{\"name\":\"gasReserve\",\"type\":\"uint256\"}],\"name\":\"cancelSubscription\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"subId\",\"type\":\"uint256\"}],\"name\":\"unholdSubscription\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"subId\",\"type\":\"uint256\"}],\"name\":\"executeSubscription\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"xrateProviders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_descriptor\",\"type\":\"bytes\"}],\"name\":\"createDeposit\",\"outputs\":[{\"name\":\"depositId\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getXRateProviderLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_fee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"subId\",\"type\":\"uint256\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"moreInfo\",\"type\":\"bytes\"}],\"name\":\"ServiceProviderEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"moreInfo\",\"type\":\"bytes\"}],\"name\":\"ServiceProviderDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"customer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"offerId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"subId\",\"type\":\"uint256\"}],\"name\":\"NewSubscription\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"depositId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"xRateProviderId\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"NewXRateProvider\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"depositId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"returnedTo\",\"type\":\"address\"}],\"name\":\"DepositReturned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"subId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"returnedTo\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"SubscriptionDepositReturned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"offerId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"onHold\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"OfferOnHold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"offerId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"OfferCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"offerId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"onHold\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"SubOnHold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"subId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"SubCanceled\",\"type\":\"event\"}]","ContractName":"SubscriptionModuleImpl","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ae6de997413a50b86f35d6d83a45e80c24956b2a45b5fefdd4088aeb7026d702"}]}