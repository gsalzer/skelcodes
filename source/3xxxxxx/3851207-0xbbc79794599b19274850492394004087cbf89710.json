{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n/*\r\n    Overflow protected math functions\r\n*/\r\ncontract SafeMath {\r\n    /**\r\n        constructor\r\n    */\r\n    function SafeMath() {\r\n    }\r\n\r\n    /**\r\n        @dev returns the sum of _x and _y, asserts if the calculation overflows\r\n\r\n        @param _x   value 1\r\n        @param _y   value 2\r\n\r\n        @return sum\r\n    */\r\n    function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        assert(z >= _x);\r\n        return z;\r\n    }\r\n\r\n    /**\r\n        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\r\n\r\n        @param _x   minuend\r\n        @param _y   subtrahend\r\n\r\n        @return difference\r\n    */\r\n    function safeSub(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        assert(_x >= _y);\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\r\n\r\n        @param _x   factor 1\r\n        @param _y   factor 2\r\n\r\n        @return product\r\n    */\r\n    function safeMul(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        uint256 z = _x * _y;\r\n        assert(_x == 0 || z / _x == _y);\r\n        return z;\r\n    }\r\n}\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ncontract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public constant returns (address owner) { owner; }\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n}\r\n\r\n/*\r\n    Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n\r\n    /**\r\n        @dev constructor\r\n    */\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev allows transferring the contract ownership\r\n        the new owner still need to accept the transfer\r\n        can only be called by the contract owner\r\n\r\n        @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n        @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n}\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ncontract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public constant returns (string name) { name; }\r\n    function symbol() public constant returns (string symbol) { symbol; }\r\n    function decimals() public constant returns (uint8 decimals) { decimals; }\r\n    function totalSupply() public constant returns (uint256 totalSupply) { totalSupply; }\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; }\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n/*\r\n    Token Holder interface\r\n*/\r\ncontract ITokenHolder is IOwned {\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\r\n}\r\n\r\n/*\r\n    We consider every contract to be a 'token holder' since it's currently not possible\r\n    for a contract to deny receiving tokens.\r\n\r\n    The TokenHolder's contract sole purpose is to provide a safety mechanism that allows\r\n    the owner to send tokens that were sent to the contract by mistake back to their sender.\r\n*/\r\ncontract TokenHolder is ITokenHolder, Owned {\r\n    /**\r\n        @dev constructor\r\n    */\r\n    function TokenHolder() {\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        require(_address != 0x0);\r\n        _;\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        require(_address != address(this));\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev withdraws tokens held by the contract and sends them to an account\r\n        can only be called by the owner\r\n\r\n        @param _token   ERC20 token contract address\r\n        @param _to      account to receive the new amount\r\n        @param _amount  amount to withdraw\r\n    */\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        ownerOnly\r\n        validAddress(_token)\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        assert(_token.transfer(_to, _amount));\r\n    }\r\n}\r\n\r\n/*\r\n    Smart Token interface\r\n*/\r\ncontract ISmartToken is ITokenHolder, IERC20Token {\r\n    function disableTransfers(bool _disable) public;\r\n    function issue(address _to, uint256 _amount) public;\r\n    function destroy(address _from, uint256 _amount) public;\r\n}\r\n\r\n/*\r\n    The smart token controller is an upgradable part of the smart token that allows\r\n    more functionality as well as fixes for bugs/exploits.\r\n    Once it accepts ownership of the token, it becomes the token's sole controller\r\n    that can execute any of its functions.\r\n\r\n    To upgrade the controller, ownership must be transferred to a new controller, along with\r\n    any relevant data.\r\n\r\n    The smart token must be set on construction and cannot be changed afterwards.\r\n    Wrappers are provided (as opposed to a single 'execute' function) for each of the token's functions, for easier access.\r\n\r\n    Note that the controller can transfer token ownership to a new controller that\r\n    doesn't allow executing any function on the token, for a trustless solution.\r\n    Doing that will also remove the owner's ability to upgrade the controller.\r\n*/\r\ncontract SmartTokenController is TokenHolder {\r\n    ISmartToken public token;   // smart token\r\n\r\n    /**\r\n        @dev constructor\r\n    */\r\n    function SmartTokenController(ISmartToken _token)\r\n        validAddress(_token)\r\n    {\r\n        token = _token;\r\n    }\r\n\r\n    // ensures that the controller is the token's owner\r\n    modifier active() {\r\n        assert(token.owner() == address(this));\r\n        _;\r\n    }\r\n\r\n    // ensures that the controller is not the token's owner\r\n    modifier inactive() {\r\n        assert(token.owner() != address(this));\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev allows transferring the token ownership\r\n        the new owner still need to accept the transfer\r\n        can only be called by the contract owner\r\n\r\n        @param _newOwner    new token owner\r\n    */\r\n    function transferTokenOwnership(address _newOwner) public ownerOnly {\r\n        token.transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n        @dev used by a new owner to accept a token ownership transfer\r\n        can only be called by the contract owner\r\n    */\r\n    function acceptTokenOwnership() public ownerOnly {\r\n        token.acceptOwnership();\r\n    }\r\n\r\n    /**\r\n        @dev disables/enables token transfers\r\n        can only be called by the contract owner\r\n\r\n        @param _disable    true to disable transfers, false to enable them\r\n    */\r\n    function disableTokenTransfers(bool _disable) public ownerOnly {\r\n        token.disableTransfers(_disable);\r\n    }\r\n\r\n    /**\r\n        @dev allows the owner to execute the token's issue function\r\n\r\n        @param _to         account to receive the new amount\r\n        @param _amount     amount to increase the supply by\r\n    */\r\n    function issueTokens(address _to, uint256 _amount) public ownerOnly {\r\n        token.issue(_to, _amount);\r\n    }\r\n\r\n    /**\r\n        @dev allows the owner to execute the token's destroy function\r\n\r\n        @param _from       account to remove the amount from\r\n        @param _amount     amount to decrease the supply by\r\n    */\r\n    function destroyTokens(address _from, uint256 _amount) public ownerOnly {\r\n        token.destroy(_from, _amount);\r\n    }\r\n\r\n    /**\r\n        @dev withdraws tokens held by the token and sends them to an account\r\n        can only be called by the owner\r\n\r\n        @param _token   ERC20 token contract address\r\n        @param _to      account to receive the new amount\r\n        @param _amount  amount to withdraw\r\n    */\r\n    function withdrawFromToken(IERC20Token _token, address _to, uint256 _amount) public ownerOnly {\r\n        token.withdrawTokens(_token, _to, _amount);\r\n    }\r\n}\r\n\r\n/*\r\n    Crowdsale v0.1\r\n\r\n    The crowdsale version of the smart token controller, allows contributing ether in exchange for Bancor tokens\r\n    The price remains fixed for the entire duration of the crowdsale\r\n    Note that 20% of the contributions are the Bancor token's reserve\r\n*/\r\ncontract CrowdsaleController is SmartTokenController, SafeMath {\r\n    uint256 public constant DURATION = 14 days;                 // crowdsale duration\r\n    uint256 public constant TOKEN_PRICE_N = 1;                  // initial price in wei (numerator)\r\n    uint256 public constant TOKEN_PRICE_D = 100;                // initial price in wei (denominator)\r\n    uint256 public constant BTCS_ETHER_CAP = 50000 ether;       // maximum bitcoin suisse ether contribution\r\n    uint256 public constant MAX_GAS_PRICE = 50000000000 wei;    // maximum gas price for contribution transactions\r\n\r\n    string public version = '0.1';\r\n\r\n    uint256 public startTime = 0;                   // crowdsale start time (in seconds)\r\n    uint256 public endTime = 0;                     // crowdsale end time (in seconds)\r\n    uint256 public totalEtherCap = 1000000 ether;   // current ether contribution cap, initialized with a temp value as a safety mechanism until the real cap is revealed\r\n    uint256 public totalEtherContributed = 0;       // ether contributed so far\r\n    bytes32 public realEtherCapHash;                // ensures that the real cap is predefined on deployment and cannot be changed later\r\n    address public beneficiary = 0x0;               // address to receive all ether contributions\r\n    address public btcs = 0x0;                      // bitcoin suisse address\r\n\r\n    // triggered on each contribution\r\n    event Contribution(address indexed _contributor, uint256 _amount, uint256 _return);\r\n\r\n    /**\r\n        @dev constructor\r\n\r\n        @param _token          smart token the crowdsale is for\r\n        @param _startTime      crowdsale start time\r\n        @param _beneficiary    address to receive all ether contributions\r\n        @param _btcs           bitcoin suisse address\r\n    */\r\n    function CrowdsaleController(ISmartToken _token, uint256 _startTime, address _beneficiary, address _btcs, bytes32 _realEtherCapHash)\r\n        SmartTokenController(_token)\r\n        validAddress(_beneficiary)\r\n        validAddress(_btcs)\r\n        earlierThan(_startTime)\r\n        validAmount(uint256(_realEtherCapHash))\r\n    {\r\n        startTime = _startTime;\r\n        endTime = startTime + DURATION;\r\n        beneficiary = _beneficiary;\r\n        btcs = _btcs;\r\n        realEtherCapHash = _realEtherCapHash;\r\n    }\r\n\r\n    // verifies that an amount is greater than zero\r\n    modifier validAmount(uint256 _amount) {\r\n        require(_amount > 0);\r\n        _;\r\n    }\r\n\r\n    // verifies that the gas price is lower than 50 gwei\r\n    modifier validGasPrice() {\r\n        assert(tx.gasprice <= MAX_GAS_PRICE);\r\n        _;\r\n    }\r\n\r\n    // verifies that the ether cap is valid based on the key provided\r\n    modifier validEtherCap(uint256 _cap, uint256 _key) {\r\n        require(computeRealCap(_cap, _key) == realEtherCapHash);\r\n        _;\r\n    }\r\n\r\n    // ensures that it's earlier than the given time\r\n    modifier earlierThan(uint256 _time) {\r\n        assert(now < _time);\r\n        _;\r\n    }\r\n\r\n    // ensures that the current time is between _startTime (inclusive) and _endTime (exclusive)\r\n    modifier between(uint256 _startTime, uint256 _endTime) {\r\n        assert(now >= _startTime && now < _endTime);\r\n        _;\r\n    }\r\n\r\n    // ensures that the sender is bitcoin suisse\r\n    modifier btcsOnly() {\r\n        assert(msg.sender == btcs);\r\n        _;\r\n    }\r\n\r\n    // ensures that we didn't reach the ether cap\r\n    modifier etherCapNotReached(uint256 _contribution) {\r\n        assert(safeAdd(totalEtherContributed, _contribution) <= totalEtherCap);\r\n        _;\r\n    }\r\n\r\n    // ensures that we didn't reach the bitcoin suisse ether cap\r\n    modifier btcsEtherCapNotReached(uint256 _ethContribution) {\r\n        assert(safeAdd(totalEtherContributed, _ethContribution) <= BTCS_ETHER_CAP);\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev computes the real cap based on the given cap & key\r\n\r\n        @param _cap    cap\r\n        @param _key    key used to compute the cap hash\r\n\r\n        @return computed real cap hash\r\n    */\r\n    function computeRealCap(uint256 _cap, uint256 _key) public constant returns (bytes32) {\r\n        return keccak256(_cap, _key);\r\n    }\r\n\r\n    /**\r\n        @dev enables the real cap defined on deployment\r\n\r\n        @param _cap    predefined cap\r\n        @param _key    key used to compute the cap hash\r\n    */\r\n    function enableRealCap(uint256 _cap, uint256 _key)\r\n        public\r\n        ownerOnly\r\n        active\r\n        between(startTime, endTime)\r\n        validEtherCap(_cap, _key)\r\n    {\r\n        require(_cap < totalEtherCap); // validate input\r\n        totalEtherCap = _cap;\r\n    }\r\n\r\n    /**\r\n        @dev computes the number of tokens that should be issued for a given contribution\r\n\r\n        @param _contribution    contribution amount\r\n\r\n        @return computed number of tokens\r\n    */\r\n    function computeReturn(uint256 _contribution) public constant returns (uint256) {\r\n        return safeMul(_contribution, TOKEN_PRICE_D) / TOKEN_PRICE_N;\r\n    }\r\n\r\n    /**\r\n        @dev ETH contribution\r\n        can only be called during the crowdsale\r\n\r\n        @return tokens issued in return\r\n    */\r\n    function contributeETH()\r\n        public\r\n        payable\r\n        between(startTime, endTime)\r\n        returns (uint256 amount)\r\n    {\r\n        return processContribution();\r\n    }\r\n\r\n    /**\r\n        @dev Contribution through BTCs (Bitcoin Suisse only)\r\n        can only be called before the crowdsale started\r\n\r\n        @return tokens issued in return\r\n    */\r\n    function contributeBTCs()\r\n        public\r\n        payable\r\n        btcsOnly\r\n        btcsEtherCapNotReached(msg.value)\r\n        earlierThan(startTime)\r\n        returns (uint256 amount)\r\n    {\r\n        return processContribution();\r\n    }\r\n\r\n    /**\r\n        @dev handles contribution logic\r\n        note that the Contribution event is triggered using the sender as the contributor, regardless of the actual contributor\r\n\r\n        @return tokens issued in return\r\n    */\r\n    function processContribution() private\r\n        active\r\n        etherCapNotReached(msg.value)\r\n        validGasPrice\r\n        returns (uint256 amount)\r\n    {\r\n        uint256 tokenAmount = computeReturn(msg.value);\r\n        assert(beneficiary.send(msg.value)); // transfer the ether to the beneficiary account\r\n        totalEtherContributed = safeAdd(totalEtherContributed, msg.value); // update the total contribution amount\r\n        token.issue(msg.sender, tokenAmount); // issue new funds to the contributor in the smart token\r\n        token.issue(beneficiary, tokenAmount); // issue tokens to the beneficiary\r\n\r\n        Contribution(msg.sender, msg.value, tokenAmount);\r\n        return tokenAmount;\r\n    }\r\n\r\n    // fallback\r\n    function() payable {\r\n        contributeETH();\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"BTCS_ETHER_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_PRICE_D\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"contributeETH\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contribution\",\"type\":\"uint256\"}],\"name\":\"computeReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferTokenOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEtherCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptTokenOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_PRICE_N\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"issueTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_disable\",\"type\":\"bool\"}],\"name\":\"disableTokenTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"realEtherCapHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_key\",\"type\":\"uint256\"}],\"name\":\"enableRealCap\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"contributeBTCs\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEtherContributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"btcs\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"destroyTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_key\",\"type\":\"uint256\"}],\"name\":\"computeRealCap\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_GAS_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_btcs\",\"type\":\"address\"},{\"name\":\"_realEtherCapHash\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_return\",\"type\":\"uint256\"}],\"name\":\"Contribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"CrowdsaleController","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001f573d6fb3f13d689ff844b4ce37794d79a7ff1c00000000000000000000000000000000000000000000000000000000593e9e600000000000000000000000005894110995b8c8401bd38262ba0c8ee41d4e4658000000000000000000000000eb68aa2764b4a9a943658b2e61db4c902b2ebf85a20f37b82967dda1159a5f415d6f6411c6b2e0e8711c624b4082578bf5e55d6f","Library":"","SwarmSource":"bzzr://375c4e86125d979c65864f60e3287707c15b099926de569918fff2f4ff799574"}]}