{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.10;\r\n\r\ncontract AbstractENS {\r\n    function owner(bytes32 node) constant returns(address);\r\n    function resolver(bytes32 node) constant returns(address);\r\n    function ttl(bytes32 node) constant returns(uint64);\r\n    function setOwner(bytes32 node, address owner);\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner);\r\n    function setResolver(bytes32 node, address resolver);\r\n    function setTTL(bytes32 node, uint64 ttl);\r\n}\r\n\r\ncontract Resolver {\r\n    function setName(bytes32 node, string name) public;\r\n}\r\n\r\n/**\r\n * @dev Provides a default implementation of a resolver for reverse records,\r\n * which permits only the owner to update it.\r\n */\r\ncontract DefaultReverseResolver is Resolver {\r\n    // namehash('addr.reverse')\r\n    bytes32 constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\r\n\r\n    AbstractENS public ens;\r\n    mapping(bytes32=>string) public name;\r\n    \r\n    /**\r\n     * @dev Constructor\r\n     * @param ensAddr The address of the ENS registry.\r\n     */\r\n    function DefaultReverseResolver(AbstractENS ensAddr) {\r\n        ens = ensAddr;\r\n\r\n        // Assign ownership of the reverse record to our deployer\r\n        var registrar = ReverseRegistrar(ens.owner(ADDR_REVERSE_NODE));\r\n        if(address(registrar) != 0) {\r\n            registrar.claim(msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Only permits calls by the reverse registrar.\r\n     * @param node The node permission is required for.\r\n     */\r\n    modifier owner_only(bytes32 node) {\r\n        require(msg.sender == ens.owner(node));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the name for a node.\r\n     * @param node The node to update.\r\n     * @param _name The name to set.\r\n     */\r\n    function setName(bytes32 node, string _name) public owner_only(node) {\r\n        name[node] = _name;\r\n    }\r\n}\r\n\r\ncontract ReverseRegistrar {\r\n    // namehash('addr.reverse')\r\n    bytes32 constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\r\n\r\n    AbstractENS public ens;\r\n    Resolver public defaultResolver;\r\n\r\n    /**\r\n     * @dev Constructor\r\n     * @param ensAddr The address of the ENS registry.\r\n     * @param resolverAddr The address of the default reverse resolver.\r\n     */\r\n    function ReverseRegistrar(AbstractENS ensAddr, Resolver resolverAddr) {\r\n        ens = ensAddr;\r\n        defaultResolver = resolverAddr;\r\n\r\n        // Assign ownership of the reverse record to our deployer\r\n        var oldRegistrar = ReverseRegistrar(ens.owner(ADDR_REVERSE_NODE));\r\n        if(address(oldRegistrar) != 0) {\r\n            oldRegistrar.claim(msg.sender);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Transfers ownership of the reverse ENS record associated with the\r\n     *      calling account.\r\n     * @param owner The address to set as the owner of the reverse record in ENS.\r\n     * @return The ENS node hash of the reverse record.\r\n     */\r\n    function claim(address owner) returns (bytes32 node) {\r\n        return claimWithResolver(owner, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the reverse ENS record associated with the\r\n     *      calling account.\r\n     * @param owner The address to set as the owner of the reverse record in ENS.\r\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\r\n     * @return The ENS node hash of the reverse record.\r\n     */\r\n    function claimWithResolver(address owner, address resolver) returns (bytes32 node) {\r\n        var label = sha3HexAddress(msg.sender);\r\n        node = sha3(ADDR_REVERSE_NODE, label);\r\n        var currentOwner = ens.owner(node);\r\n\r\n        // Update the resolver if required\r\n        if(resolver != 0 && resolver != ens.resolver(node)) {\r\n            // Transfer the name to us first if it's not already\r\n            if(currentOwner != address(this)) {\r\n                ens.setSubnodeOwner(ADDR_REVERSE_NODE, label, this);\r\n                currentOwner = address(this);\r\n            }\r\n            ens.setResolver(node, resolver);\r\n        }\r\n\r\n        // Update the owner if required\r\n        if(currentOwner != owner) {\r\n            ens.setSubnodeOwner(ADDR_REVERSE_NODE, label, owner);\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the `name()` record for the reverse ENS record associated with\r\n     * the calling account. First updates the resolver to the default reverse\r\n     * resolver if necessary.\r\n     * @param name The name to set for this address.\r\n     * @return The ENS node hash of the reverse record.\r\n     */\r\n    function setName(string name) returns (bytes32 node) {\r\n        node = claimWithResolver(this, defaultResolver);\r\n        defaultResolver.setName(node, name);\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the node hash for a given account's reverse records.\r\n     * @param addr The address to hash\r\n     * @return The ENS node hash.\r\n     */\r\n    function node(address addr) constant returns (bytes32 ret) {\r\n        return sha3(ADDR_REVERSE_NODE, sha3HexAddress(addr));\r\n    }\r\n\r\n    /**\r\n     * @dev An optimised function to compute the sha3 of the lower-case\r\n     *      hexadecimal representation of an Ethereum address.\r\n     * @param addr The address to hash\r\n     * @return The SHA3 hash of the lower-case hexadecimal encoding of the\r\n     *         input address.\r\n     */\r\n    function sha3HexAddress(address addr) private returns (bytes32 ret) {\r\n        addr; ret; // Stop warning us about unused variables\r\n        assembly {\r\n            let lookup := 0x3031323334353637383961626364656600000000000000000000000000000000\r\n            let i := 40\r\n        loop:\r\n            i := sub(i, 1)\r\n            mstore8(i, byte(and(addr, 0xf), lookup))\r\n            addr := div(addr, 0x10)\r\n            i := sub(i, 1)\r\n            mstore8(i, byte(and(addr, 0xf), lookup))\r\n            addr := div(addr, 0x10)\r\n            jumpi(loop, i)\r\n            ret := sha3(0, 40)\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"claimWithResolver\",\"outputs\":[{\"name\":\"node\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[{\"name\":\"node\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultResolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"node\",\"outputs\":[{\"name\":\"ret\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[{\"name\":\"node\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"ensAddr\",\"type\":\"address\"},{\"name\":\"resolverAddr\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"}]","ContractName":"ReverseRegistrar","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000314159265dd8dbb310642f98f50c066173c1259b0000000000000000000000005fbb459c49bb06083c33109fa4f14810ec2cf358","Library":"","SwarmSource":"bzzr://b5a0fc071ea98f50e75fb7b3a50f25e129679487596a27697ba42f422dc0d6dc"}]}