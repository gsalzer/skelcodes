{"status":"1","message":"OK","result":[{"SourceCode":"contract SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\ncontract Arithmetic {\r\n    function mul256By256(uint a, uint b)\r\n        constant\r\n        returns (uint ab32, uint ab1, uint ab0)\r\n    {\r\n        uint ahi = a >> 128;\r\n        uint alo = a & 2**128-1;\r\n        uint bhi = b >> 128;\r\n        uint blo = b & 2**128-1;\r\n        ab0 = alo * blo;\r\n        ab1 = (ab0 >> 128) + (ahi * blo & 2**128-1) + (alo * bhi & 2**128-1);\r\n        ab32 = (ab1 >> 128) + ahi * bhi + (ahi * blo >> 128) + (alo * bhi >> 128);\r\n        ab1 &= 2**128-1;\r\n        ab0 &= 2**128-1;\r\n    }\r\n\r\n    // I adapted this from Fast Division of Large Integers by Karl Hasselstr√∂m\r\n    // Algorithm 3.4: Divide-and-conquer division (3 by 2)\r\n    // Karl got it from Burnikel and Ziegler and the GMP lib implementation\r\n    function div256_128By256(uint a21, uint a0, uint b)\r\n        constant\r\n        returns (uint q, uint r)\r\n    {\r\n        uint qhi = (a21 / b) << 128;\r\n        a21 %= b;\r\n\r\n        uint shift = 0;\r\n        while(b >> shift > 0) shift++;\r\n        shift = 256 - shift;\r\n        a21 = (a21 << shift) + (shift > 128 ? a0 << (shift - 128) : a0 >> (128 - shift));\r\n        a0 = (a0 << shift) & 2**128-1;\r\n        b <<= shift;\r\n        var (b1, b0) = (b >> 128, b & 2**128-1);\r\n\r\n        uint rhi;\r\n        q = a21 / b1;\r\n        rhi = a21 % b1;\r\n\r\n        uint rsub0 = (q & 2**128-1) * b0;\r\n        uint rsub21 = (q >> 128) * b0 + (rsub0 >> 128);\r\n        rsub0 &= 2**128-1;\r\n\r\n        while(rsub21 > rhi || rsub21 == rhi && rsub0 > a0) {\r\n            q--;\r\n            a0 += b0;\r\n            rhi += b1 + (a0 >> 128);\r\n            a0 &= 2**128-1;\r\n        }\r\n\r\n        q += qhi;\r\n        r = (((rhi - rsub21) << 128) + a0 - rsub0) >> shift;\r\n    }\r\n\r\n    function overflowResistantFraction(uint a, uint b, uint divisor)\r\n        returns (uint)\r\n    {\r\n        uint ab32_q1; uint ab1_r1; uint ab0;\r\n        if(b <= 1 || b != 0 && a * b / b == a) {\r\n            return a * b / divisor;\r\n        } else {\r\n            (ab32_q1, ab1_r1, ab0) = mul256By256(a, b);\r\n            (ab32_q1, ab1_r1) = div256_128By256(ab32_q1, ab1_r1, divisor);\r\n            (a, b) = div256_128By256(ab1_r1, ab0, divisor);\r\n            return (ab32_q1 << 128) + a;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function transfer(address to, uint value) returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n  function transferFrom(address from, address to, uint value);\r\n  function approve(address spender, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n\r\n\r\ncontract Presale is Ownable, SafeMath, Arithmetic  {\r\n    uint public minInvest = 10 ether;\r\n    uint public maxcap = 490 ether;   // 100k euro based on kraken rates on 27/06/2017 at 13h20\r\n    address public ledgerWallet = \"0xa4dbbF474a6f026Cf0a2d3e45aB192Fbd98D3a5f\";\r\n    uint public count = 0;\r\n    uint public totalFunding;\r\n    bool public saleOn;\r\n    bool public distributed;\r\n    address public crowdsaleContract;\r\n    uint public balanceToken;\r\n    address[] public listBackers;\r\n    mapping (address => uint) public backers;\r\n    ERC20 public DTR;                       // wait to be instantiate when ERC20 will be created\r\n    event ReceivedETH(address addr, uint value);\r\n    event Logs(address addr, uint value1, uint value2);\r\n    event Logs2(uint value1, uint value2,uint value3, uint value4,uint value5, uint value6);\r\n    function Presale () {\r\n        saleOn = true;\r\n        distributed = false;\r\n    }\r\n    function() payable {\r\n        require(saleOn);\r\n        require(msg.value > minInvest);\r\n        require( SafeMath.add(totalFunding, msg.value) <= maxcap);\r\n        if (backers[msg.sender] == 0)\r\n          listBackers.push(msg.sender);\r\n        backers[msg.sender] =  SafeMath.add(backers[msg.sender], msg.value);\r\n        totalFunding = SafeMath.add(totalFunding, msg.value);\r\n        ledgerWallet.transfer(this.balance);\r\n        ReceivedETH(msg.sender, msg.value);\r\n    }\r\n    function balanceOf(address _owner) constant returns (uint balance) {\r\n      return backers[_owner];\r\n    }\r\n    function setDTR (address dtrAddress) onlyOwner {\r\n        DTR = ERC20(dtrAddress);\r\n        balanceToken = DTR.balanceOf(this);\r\n        Logs(dtrAddress, balanceToken, this.balance);\r\n    }\r\n\r\n    function withdraw() onlyOwner {\r\n        ledgerWallet.transfer(this.balance);\r\n    }\r\n\r\n    function closeSale() onlyOwner {\r\n        saleOn = false;\r\n    }\r\n\r\n    // when closing ICO, token will be send to this contract, then this function will be called and token will be distribute among early investor\r\n    function distributes(uint max) onlyOwner {\r\n        require(!saleOn);\r\n        while(count < max) {\r\n            uint toSend = Arithmetic.overflowResistantFraction(balanceToken, backers[listBackers[count]], totalFunding);\r\n            require(DTR.transfer(listBackers[count], toSend));\r\n            count++;\r\n            if (count == listBackers.length) {\r\n                distributed = true;\r\n                break ;\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"listBackers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"count\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"mul256By256\",\"outputs\":[{\"name\":\"ab32\",\"type\":\"uint256\"},{\"name\":\"ab1\",\"type\":\"uint256\"},{\"name\":\"ab0\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"},{\"name\":\"divisor\",\"type\":\"uint256\"}],\"name\":\"overflowResistantFraction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a21\",\"type\":\"uint256\"},{\"name\":\"a0\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"div256_128By256\",\"outputs\":[{\"name\":\"q\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxcap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInvest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleOn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dtrAddress\",\"type\":\"address\"}],\"name\":\"setDTR\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ledgerWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"distributes\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"backers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DTR\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeSale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ReceivedETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value1\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value2\",\"type\":\"uint256\"}],\"name\":\"Logs\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value1\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value2\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value3\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value4\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value5\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value6\",\"type\":\"uint256\"}],\"name\":\"Logs2\",\"type\":\"event\"}]","ContractName":"Presale","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e77bce3f578f928225544c3f234faeed3604537c350a9e5852ff7cd6475dbfc5"}]}