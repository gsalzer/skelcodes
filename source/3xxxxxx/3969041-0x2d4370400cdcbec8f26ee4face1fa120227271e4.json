{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\ncontract Base {\r\n\r\n    function max(uint a, uint b) returns (uint) { return a >= b ? a : b; }\r\n    function min(uint a, uint b) returns (uint) { return a <= b ? a : b; }\r\n\r\n    modifier only(address allowed) {\r\n        if (msg.sender != allowed) throw;\r\n        _;\r\n    }\r\n\r\n\r\n    ///@return True if `_addr` is a contract\r\n    function isContract(address _addr) constant internal returns (bool) {\r\n        if (_addr == 0) return false;\r\n        uint size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return (size > 0);\r\n    }\r\n\r\n    // *************************************************\r\n    // *          reentrancy handling                  *\r\n    // *************************************************\r\n\r\n    //@dev predefined locks (up to uint bit length, i.e. 256 possible)\r\n    uint constant internal L00 = 2 ** 0;\r\n    uint constant internal L01 = 2 ** 1;\r\n    uint constant internal L02 = 2 ** 2;\r\n    uint constant internal L03 = 2 ** 3;\r\n    uint constant internal L04 = 2 ** 4;\r\n    uint constant internal L05 = 2 ** 5;\r\n\r\n    //prevents reentrancy attacs: specific locks\r\n    uint private bitlocks = 0;\r\n    modifier noReentrancy(uint m) {\r\n        var _locks = bitlocks;\r\n        if (_locks & m > 0) throw;\r\n        bitlocks |= m;\r\n        _;\r\n        bitlocks = _locks;\r\n    }\r\n\r\n    modifier noAnyReentrancy {\r\n        var _locks = bitlocks;\r\n        if (_locks > 0) throw;\r\n        bitlocks = uint(-1);\r\n        _;\r\n        bitlocks = _locks;\r\n    }\r\n\r\n    ///@dev empty marking modifier signaling to user of the marked function , that it can cause an reentrant call.\r\n    ///     developer should make the caller function reentrant-safe if it use a reentrant function.\r\n    modifier reentrant { _; }\r\n\r\n}\r\n\r\ncontract Owned is Base {\r\n\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) only(owner) {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() only(newOwner) {\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n}\r\n\r\n\r\ncontract ERC20 is Base {\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function transfer(address _to, uint256 _value) isStartedOnly returns (bool success) {\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) isStartedOnly returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) isStartedOnly returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    uint256 public totalSupply;\r\n    bool    public isStarted = false;\r\n\r\n    modifier onlyHolder(address holder) {\r\n        if (balanceOf(holder) == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier isStartedOnly() {\r\n        if (!isStarted) throw;\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract SubscriptionModule {\r\n    function attachToken(address addr) public ;\r\n}\r\n\r\ncontract SAN is Owned, ERC20 {\r\n\r\n    string public constant name     = \"SANtiment network token\";\r\n    string public constant symbol   = \"SAN\";\r\n    uint8  public constant decimals = 15;\r\n\r\n    address CROWDSALE_MINTER = 0xD88E4822687d0F9c73E296296Ed3eCd0a193dd46;\r\n    address public SUBSCRIPTION_MODULE = 0x00000000;\r\n    address public beneficiary;\r\n\r\n    uint public PLATFORM_FEE_PER_10000 = 1; //0.01%\r\n    uint public totalOnDeposit;\r\n    uint public totalInCirculation;\r\n\r\n    ///@dev constructor\r\n    function SAN() {\r\n        beneficiary = owner = msg.sender;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Don't accept ethers\r\n    // ------------------------------------------------------------------------\r\n    function () {\r\n        throw;\r\n    }\r\n\r\n    //======== SECTION Configuration: Owner only ========\r\n    //\r\n    ///@notice set beneficiary - the account receiving platform fees.\r\n    function setBeneficiary(address newBeneficiary)\r\n    external\r\n    only(owner) {\r\n        beneficiary = newBeneficiary;\r\n    }\r\n\r\n\r\n    ///@notice attach module managing subscriptions. if subModule==0x0, then disables subscription functionality for this token.\r\n    /// detached module can usually manage subscriptions, but all operations changing token balances are disabled.\r\n    function attachSubscriptionModule(SubscriptionModule subModule)\r\n    noAnyReentrancy\r\n    external\r\n    only(owner) {\r\n        SUBSCRIPTION_MODULE = subModule;\r\n        if (address(subModule) > 0) subModule.attachToken(this);\r\n    }\r\n\r\n    ///@notice set platform fee denominated in 1/10000 of SAN token. Thus \"1\" means 0.01% of SAN token.\r\n    function setPlatformFeePer10000(uint newFee)\r\n    external\r\n    only(owner) {\r\n        require (newFee <= 10000); //formally maximum fee is 100% (completely insane but technically possible)\r\n        PLATFORM_FEE_PER_10000 = newFee;\r\n    }\r\n\r\n\r\n    //======== Interface XRateProvider: a trivial exchange rate provider. Rate is 1:1 and SAN symbol as the code\r\n    //\r\n    ///@dev used as a default XRateProvider (id==0) by subscription module.\r\n    ///@notice returns always 1 because exchange rate of the token to itself is always 1.\r\n    function getRate() returns(uint32 ,uint32) { return (1,1);  }\r\n    function getCode() public returns(string)  { return symbol; }\r\n\r\n\r\n    //==== Interface ERC20ModuleSupport: Subscription, Deposit and Payment Support =====\r\n    ///\r\n    ///@dev used by subscription module to operate on token balances.\r\n    ///@param msg_sender should be an original msg.sender provided to subscription module.\r\n    function _fulfillPreapprovedPayment(address _from, address _to, uint _value, address msg_sender)\r\n    public\r\n    onlyTrusted\r\n    returns(bool success) {\r\n        success = _from != msg_sender && allowed[_from][msg_sender] >= _value;\r\n        if (!success) {\r\n            Payment(_from, _to, _value, _fee(_value), msg_sender, PaymentStatus.APPROVAL_ERROR, 0);\r\n        } else {\r\n            success = _fulfillPayment(_from, _to, _value, 0, msg_sender);\r\n            if (success) {\r\n                allowed[_from][msg_sender] -= _value;\r\n            }\r\n        }\r\n        return success;\r\n    }\r\n\r\n    ///@dev used by subscription module to operate on token balances.\r\n    ///@param msg_sender should be an original msg.sender provided to subscription module.\r\n    function _fulfillPayment(address _from, address _to, uint _value, uint subId, address msg_sender)\r\n    public\r\n    onlyTrusted\r\n    returns (bool success) {\r\n        var fee = _fee(_value);\r\n        assert (fee <= _value); //internal sanity check\r\n        if (balances[_from] >= _value && balances[_to] + _value > balances[_to]) {\r\n            balances[_from] -= _value;\r\n            balances[_to] += _value - fee;\r\n            balances[beneficiary] += fee;\r\n            Payment(_from, _to, _value, fee, msg_sender, PaymentStatus.OK, subId);\r\n            return true;\r\n        } else {\r\n            Payment(_from, _to, _value, fee, msg_sender, PaymentStatus.BALANCE_ERROR, subId);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _fee(uint _value) internal constant returns (uint fee) {\r\n        return _value * PLATFORM_FEE_PER_10000 / 10000;\r\n    }\r\n\r\n    ///@notice used by subscription module to re-create token from returning deposit.\r\n    ///@dev a subscription module is responsible to correct deposit management.\r\n    function _mintFromDeposit(address owner, uint amount)\r\n    public\r\n    onlyTrusted {\r\n        balances[owner] += amount;\r\n        totalOnDeposit -= amount;\r\n        totalInCirculation += amount;\r\n    }\r\n\r\n    ///@notice used by subscription module to burn token while creating a new deposit.\r\n    ///@dev a subscription module is responsible to create and maintain the deposit record.\r\n    function _burnForDeposit(address owner, uint amount)\r\n    public\r\n    onlyTrusted\r\n    returns (bool success) {\r\n        if (balances[owner] >= amount) {\r\n            balances[owner] -= amount;\r\n            totalOnDeposit += amount;\r\n            totalInCirculation -= amount;\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    //========= Crowdsale Only ===============\r\n    ///@notice mint new token for given account in crowdsale stage\r\n    ///@dev allowed only if token not started yet and only for registered minter.\r\n    ///@dev tokens are become in circulation after token start.\r\n    function mint(uint amount, address account)\r\n    onlyCrowdsaleMinter\r\n    isNotStartedOnly\r\n    {\r\n        totalSupply += amount;\r\n        balances[account]+=amount;\r\n    }\r\n\r\n    ///@notice start normal operation of the token. No minting is possible after this point.\r\n    function start()\r\n    isNotStartedOnly\r\n    only(owner) {\r\n        totalInCirculation = totalSupply;\r\n        isStarted = true;\r\n    }\r\n\r\n    //========= SECTION: Modifier ===============\r\n\r\n    modifier onlyCrowdsaleMinter() {\r\n        if (msg.sender != CROWDSALE_MINTER) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyTrusted() {\r\n        if (msg.sender != SUBSCRIPTION_MODULE) throw;\r\n        _;\r\n    }\r\n\r\n    ///@dev token not started means minting is possible, but usual token operations are not.\r\n    modifier isNotStartedOnly() {\r\n        if (isStarted) throw;\r\n        _;\r\n    }\r\n\r\n    enum PaymentStatus {OK, BALANCE_ERROR, APPROVAL_ERROR}\r\n    ///@notice event issued on any fee based payment (made of failed).\r\n    ///@param subId - related subscription Id if any, or zero otherwise.\r\n    event Payment(address _from, address _to, uint _value, uint _fee, address caller, PaymentStatus status, uint subId);\r\n\r\n}//contract SAN","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newBeneficiary\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_mintFromDeposit\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"subId\",\"type\":\"uint256\"},{\"name\":\"msg_sender\",\"type\":\"address\"}],\"name\":\"_fulfillPayment\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SUBSCRIPTION_MODULE\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"msg_sender\",\"type\":\"address\"}],\"name\":\"_fulfillPreapprovedPayment\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInCirculation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"max\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"subModule\",\"type\":\"address\"}],\"name\":\"attachSubscriptionModule\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"min\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalOnDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_burnForDeposit\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PLATFORM_FEE_PER_10000\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getCode\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setPlatformFeePer10000\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_fee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"subId\",\"type\":\"uint256\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SAN","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8dd0649314020ceadea1aec9b52b8b59519a4f1e52d1053f565a3a00b0f915a6"}]}