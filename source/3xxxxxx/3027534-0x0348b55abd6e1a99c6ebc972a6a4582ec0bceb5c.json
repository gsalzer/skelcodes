{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\n//This contract is backed by the constitution of superDAO deployed at : .\r\n//The constitution of the superDAO is the social contract, terms, founding principles and definitions of the vision,\r\n//mission, anti-missions, rules and operation guidelines of superDAO.\r\n//The total number of 3,000,000 represents 3% of 100,000,000 immutable number of superDAO tokens,\r\n//which is the alloted budget of operation for the earliest funding activities.\r\n//Every prommissory token is exchangeable for the real superDAO tokens on a one on one basis.\r\n//Promissiory contract will be deployed with the actual superDAO token contract.\r\n//Early backers can call the \"redeem\" function on the actual token contract to exchange promissory tokens for the final tokens.\r\n\r\n/**\r\n * @title Promisory Token Contract\r\n * @author ola\r\n * --- Collaborators ---\r\n * @author zlatinov\r\n * @author panos\r\n * @author yemi\r\n * @author archil\r\n * @author anthony\r\n */\r\ncontract PromissoryToken {\r\n\r\n    event FounderSwitchRequestEvent(address _newFounderAddr);\r\n    event FounderSwitchedEvent(address _newFounderAddr);\r\n    event CofounderSwitchedEvent(address _newCofounderAddr);\r\n\r\n    event AddedPrepaidTokensEvent(address backer, uint index, uint price, uint amount);\r\n    event PrepaidTokensClaimedEvent(address backer, uint index, uint price, uint amount);\r\n    event TokensClaimedEvent(address backer, uint index, uint price, uint amount);\r\n\r\n    event RedeemEvent(address backer, uint amount);\r\n\r\n    event WithdrawalCreatedEvent(uint withdrawalId, uint amount, bytes reason);\r\n    event WithdrawalVotedEvent(uint withdrawalId, address backer, uint backerStakeWeigth, uint totalStakeWeight);\r\n    event WithdrawalApproved(uint withdrawalId, uint stakeWeight, bool isMultiPayment, uint amount, bytes reason);\r\n\r\n    address founder; //deployer of constitution and PromissoryToken\r\n    bytes32 founderHash; // hash must be confirmed in order to replace founder address\r\n    mapping(address => bytes32) tempHashes; // structure to contain new address to hash storage,\r\n    address cofounder;//helper to aid founder key exchange in case of key loss\r\n    address [] public previousFounders; //list of addresses replaced using the switching process.\r\n    uint constant discountAmount = 60; //discount amount\r\n    uint constant divisor = 100; //divisor to get discount value\r\n\r\n    uint public constant minimumPrepaidClaimedPercent = 65;\r\n    uint public promissoryUnits = 3000000; //amount of tokens contants set\r\n    uint public prepaidUnits = 0; //prepaid and set by founder out of 3 million tokens\r\n    uint public claimedUnits = 0; //claimed tokens out of 3 million tokens\r\n    uint public claimedPrepaidUnits = 0; //claimed tokens out of the early backer's tokens/prepaidUnits\r\n    uint public redeemedTokens = 0; //number of tokens out of claimed tokens, redeemed by superDAO token call\r\n    uint public lastPrice = 0; //latest price of token acquired by backer in Wei\r\n    uint public numOfBackers; //number of early backers\r\n\r\n    struct backerData {\r\n       uint tokenPrice;\r\n       uint tokenAmount;\r\n       bytes32 privateHash;\r\n       bool prepaid;\r\n       bool claimed;\r\n       uint backerRank;\r\n    }\r\n\r\n    address[] public earlyBackerList; //addresses of earliest backers\r\n    address[] public backersAddresses; //addresses of all backers\r\n    mapping(address => backerData[]) public backers;// backer address to backer info mapping\r\n    mapping(address => bool) public backersRedeemed;\r\n\r\n    struct withdrawalData {\r\n       uint Amount;\r\n       bool approved;\r\n       bool spent;\r\n       bytes reason;\r\n       address[] backerApprovals;\r\n       uint totalStake;\r\n       address[] destination;\r\n    }\r\n\r\n    withdrawalData[] public withdrawals; // Data structure specifying withdrawal\r\n    mapping(address => mapping(uint => bool)) public withdrawalsVotes;\r\n\r\n    /**\r\n    * @notice Deploy PromissoryToken contract with `msg.sender.address()` as founder with `_prepaidBackers.number()` prepaid backers\r\n    * @dev This is the constructor of the promisory token contract\r\n    * @param _founderHash Founders password hash, preferable a message digest to further obfuscate duplicaion\r\n    * @param _cofounderAddress The helper cofounder to aid founder key exchange in case of key loss/\r\n    * @param _numOfBackers The number of Early backers. Will be used to control setting early backers\r\n    */\r\n    function PromissoryToken( bytes32 _founderHash, address _cofounderAddress, uint _numOfBackers){\r\n        founder = msg.sender;\r\n        founderHash = sha3(_founderHash);\r\n        cofounder = _cofounderAddress;\r\n        numOfBackers = _numOfBackers;\r\n    }\r\n\r\n    /**\r\n    * @notice `msg.sender.address()` updating cofounder address to `_newFounderAddr.address()`\r\n    * @dev allows cofounder to switch out addres for a new one.Can be repeated as many times as needed\r\n    * @param _newCofounderAddr New Address of Cofounder\r\n    * @return True if the coFounder address successfully updated\r\n    */\r\n    function cofounderSwitchAddress(address _newCofounderAddr) external returns (bool success){\r\n        if (msg.sender != cofounder) throw;\r\n\r\n        cofounder = _newCofounderAddr;\r\n        CofounderSwitchedEvent(_newCofounderAddr);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Founder address update to `_newFounderAddr.address()` is being requested\r\n    * @dev founderSwitchAddress founder indicates intent to switch addresses with new address,\r\n    * hash of pass phrase and a \"onetime shared phrase shared with coufounder\"\r\n    * @param _founderHash Secret Key to be used to confirm Address update\r\n    * @param _oneTimesharedPhrase Shared pre-hashed Secret key for offline trust to be shared with coFounder to approve Address update\r\n    * @return True if Address switch request successfully created and Temporary hash Values set\r\n    */\r\n    function founderSwitchRequest(bytes32 _founderHash, bytes32 _oneTimesharedPhrase) returns (bool success){\r\n        if(sha3(_founderHash) != founderHash) throw;\r\n\r\n        tempHashes[msg.sender] = sha3(msg.sender, founderHash, _oneTimesharedPhrase);\r\n        FounderSwitchRequestEvent(msg.sender);\r\n\r\n        return true;\r\n    }\r\n\r\n   /**\r\n    * @notice `msg.sender.address()` approving `_newFounderAddr.address()` as new founder address\r\n    * @dev CofounderSwitchAddress which allows previously set cofounder to approve address\r\n    * switch by founder. Must have a one time shared phrase thats is shared with founder that corresponding with a\r\n    * hashed value.\r\n    * @param _newFounderAddr The address of Founder to be newly set\r\n    * @param _oneTimesharedPhrase Shared pre-hashed Secret key for offline trust, to provide access to the approval function\r\n    * @return True if new Founder address successfully approved\r\n    */\r\n    function cofounderApproveSwitchRequest(address _newFounderAddr, bytes32 _oneTimesharedPhrase) external returns (bool success){\r\n        if(msg.sender != cofounder || sha3(_newFounderAddr, founderHash, _oneTimesharedPhrase) != tempHashes[_newFounderAddr]) throw;\r\n\r\n        previousFounders.push(founder);\r\n        founder = _newFounderAddr;\r\n        FounderSwitchedEvent(_newFounderAddr);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Adding `_backer.address()` as an early backer\r\n    * @dev Add Early backers to Contract setting the transacton details\r\n    * @param _backer The address of the superDAO backer\r\n    * @param _tokenPrice The price/rate at which the superDAO tokens were bought\r\n    * @param _tokenAmount The total number of superDAO token purcgased at the indicated rate\r\n    * @param _privatePhrase Shared pre-hashed Secret key for offline price negotiation to online attestation of SuperDAO tokens ownership\r\n    * @param _backerRank Rank of the backer in the backers list\r\n    * @return Thre index of _backer  in the backers list\r\n    */\r\n    function setPrepaid(address _backer, uint _tokenPrice, uint _tokenAmount, string _privatePhrase, uint _backerRank)\r\n        external\r\n        founderCall\r\n        returns (uint)\r\n    {\r\n        if (_tokenPrice == 0 || _tokenAmount == 0 || claimedPrepaidUnits>0 ||\r\n            _tokenAmount + prepaidUnits + claimedUnits > promissoryUnits) throw;\r\n        if (earlyBackerList.length == numOfBackers && backers[_backer].length == 0) throw ;\r\n        if (backers[_backer].length == 0) {\r\n            earlyBackerList.push(_backer);\r\n            backersAddresses.push(_backer);\r\n        }\r\n        backers[_backer].push(backerData(_tokenPrice, _tokenAmount, sha3(_privatePhrase, _backer), true, false, _backerRank));\r\n\r\n        prepaidUnits +=_tokenAmount;\r\n        lastPrice = _tokenPrice;\r\n\r\n        AddedPrepaidTokensEvent(_backer, backers[_backer].length - 1, _tokenPrice, _tokenAmount);\r\n\r\n        return backers[_backer].length - 1;\r\n    }\r\n\r\n    /**\r\n    * @notice Claiming `_tokenAmount.number()` superDAO tokens by `msg.sender.address()`\r\n    * @dev Claim superDAO Early backer tokens\r\n    * @param _index index of tokens to claim\r\n    * @param _boughtTokensPrice Price at which the superDAO tokens were bought\r\n    * @param _tokenAmount Number of superDAO tokens to be claimed\r\n    * @param _privatePhrase Shared pre-hashed Secret key for offline price negotiation to online attestation of SuperDAO tokens ownership\r\n    * @param _backerRank Backer rank of the backer in the superDAO\r\n    */\r\n    function claimPrepaid(uint _index, uint _boughtTokensPrice, uint _tokenAmount, string _privatePhrase, uint _backerRank)\r\n        external\r\n        EarliestBackersSet\r\n    {\r\n        if(backers[msg.sender][_index].prepaid == true &&\r\n           backers[msg.sender][_index].claimed == false &&\r\n           backers[msg.sender][_index].tokenAmount == _tokenAmount &&\r\n           backers[msg.sender][_index].tokenPrice == _boughtTokensPrice &&\r\n           backers[msg.sender][_index].privateHash == sha3( _privatePhrase, msg.sender) &&\r\n           backers[msg.sender][_index].backerRank == _backerRank)\r\n        {\r\n            backers[msg.sender][_index].claimed = true;\r\n            claimedPrepaidUnits += _tokenAmount;\r\n\r\n            PrepaidTokensClaimedEvent(msg.sender, _index, _boughtTokensPrice, _tokenAmount);\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice `msg.sender.address()` is Purchasing `(msg.value / lastPrice).toFixed(0)` superDAO Tokens at `lastPrice`\r\n    * @dev Purchase new superDAO Tokens if the amount of tokens are still available for purchase\r\n    */\r\n    function claim()\r\n        payable\r\n        external\r\n        MinimumBackersClaimed\r\n   {\r\n        if (lastPrice == 0) throw;\r\n\r\n        //don`t accept transactions with zero value\r\n        if (msg.value == 0) throw;\r\n\r\n\r\n        //Effective discount for Pre-crowdfunding backers of 40% Leaving effective rate of 60%\r\n        uint discountPrice = lastPrice * discountAmount / divisor;\r\n\r\n        uint tokenAmount = (msg.value / discountPrice);//Effect the discount rate 0f 40%\r\n\r\n        if (tokenAmount + claimedUnits + prepaidUnits > promissoryUnits) throw;\r\n\r\n        if (backers[msg.sender].length == 0) {\r\n            backersAddresses.push(msg.sender);\r\n        }\r\n        backers[msg.sender].push(backerData(discountPrice, tokenAmount, sha3(msg.sender), false, true, 0));\r\n\r\n        claimedUnits += tokenAmount;\r\n\r\n        TokensClaimedEvent(msg.sender, backers[msg.sender].length - 1, discountPrice, tokenAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice checking `_backerAddress.address()` superDAO Token balance: `index`\r\n     * @dev Check Token balance by index of backer, return values can be used to instantiate a backerData struct\r\n     * @param _backerAddress The Backer's address\r\n     * @param index The balance to check\r\n     * @return tokenPrice The Price at which the tokens were bought\r\n     * @return tokenAmount The number of tokens that were bought\r\n     * @return Shared pre-hashed Secret key for offline price negotiation \r\n     * @return prepaid True if backer is an early backer\r\n     * @return claimed True if the Token has already been claimed by the backer\r\n     */\r\n    function checkBalance(address _backerAddress, uint index) constant returns (uint, uint, bytes32, bool, bool){\r\n        return (\r\n            backers[_backerAddress][index].tokenPrice,\r\n            backers[_backerAddress][index].tokenAmount,\r\n            backers[_backerAddress][index].privateHash,\r\n            backers[_backerAddress][index].prepaid,\r\n            backers[_backerAddress][index].claimed\r\n            );\r\n    }\r\n\r\n    /**\r\n    * @notice Approving withdrawal `_withdrawalID`\r\n    * @dev Approve a withdrawal from the superDAO and mark the withdrawal as spent\r\n    * @param _withdrawalID The ID of the withdrawal\r\n    */\r\n    function approveWithdraw(uint _withdrawalID)\r\n        external\r\n        backerCheck(_withdrawalID)\r\n    {\r\n        withdrawalsVotes[msg.sender][_withdrawalID] = true;\r\n\r\n        uint backerStake = 0;\r\n        for (uint i = 0; i < backers[msg.sender].length; i++) {\r\n            backerStake += backers[msg.sender][i].tokenAmount;\r\n        }\r\n        withdrawals[_withdrawalID].backerApprovals.push(msg.sender);\r\n        withdrawals[_withdrawalID].totalStake += backerStake;\r\n\r\n        WithdrawalVotedEvent(_withdrawalID, msg.sender, backerStake, withdrawals[_withdrawalID].totalStake);\r\n\r\n        if(withdrawals[_withdrawalID].totalStake >= (claimedPrepaidUnits + claimedUnits) / 3) {\r\n            uint amountPerAddr;\r\n            bool isMultiPayment = withdrawals[_withdrawalID].destination.length > 1;\r\n\r\n            if(isMultiPayment == false){\r\n                amountPerAddr = withdrawals[_withdrawalID].Amount;\r\n            }\r\n            else {\r\n                amountPerAddr = withdrawals[_withdrawalID].Amount / withdrawals[_withdrawalID].destination.length;\r\n            }\r\n\r\n            withdrawals[_withdrawalID].approved = true;\r\n            withdrawals[_withdrawalID].spent = true;\r\n\r\n            for(i = 0; i < withdrawals[_withdrawalID].destination.length; i++){\r\n                if(!withdrawals[_withdrawalID].destination[i].send(amountPerAddr)) throw;\r\n            }\r\n\r\n            WithdrawalApproved(_withdrawalID,\r\n                withdrawals[_withdrawalID].totalStake,\r\n                isMultiPayment,\r\n                withdrawals[_withdrawalID].Amount,\r\n                withdrawals[_withdrawalID].reason);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Requestng withdrawal of `_totalAmount` to `_destination.address()`\r\n    * @dev Create a new withdrawal request\r\n    * @param _totalAmount The total amount of tokens to be withdrawan, should be equal to the total number of owned tokens\r\n    * @param _reason Reason/Description for the withdrawal\r\n    * @param _destination The receiving address\r\n    */\r\n    function withdraw(uint _totalAmount, bytes _reason, address[] _destination)\r\n        external\r\n        founderCall\r\n    {\r\n        if (this.balance < _totalAmount) throw;\r\n\r\n        uint withdrawalID = withdrawals.length++;\r\n\r\n        withdrawals[withdrawalID].Amount = _totalAmount;\r\n        withdrawals[withdrawalID].reason = _reason;\r\n        withdrawals[withdrawalID].destination = _destination;\r\n        withdrawals[withdrawalID].approved = false;\r\n        withdrawals[withdrawalID].spent = false;\r\n\r\n        WithdrawalCreatedEvent(withdrawalID, _totalAmount, _reason);\r\n    }\r\n\r\n    /**\r\n    * @notice Backer `_bacherAddr.address()` is redeeming `_amount` superDAO Tokens\r\n    * @dev Check if backer tokens have been claimed but not redeemed, then redeem them\r\n    * @param _amount The total number of redeemable tokens\r\n    * @param _backerAddr The address of the backer\r\n    * @return True if tokens were successfully redeemed else false\r\n    */\r\n    function redeem(uint _amount, address _backerAddr) returns(bool){\r\n        if (backersRedeemed[_backerAddr] == true) {\r\n            return false;\r\n        }\r\n\r\n        uint totalTokens = 0;\r\n\r\n        for (uint i = 0; i < backers[_backerAddr].length; i++) {\r\n            if (backers[_backerAddr][i].claimed == false) {\r\n                return false;\r\n            }\r\n            totalTokens += backers[_backerAddr][i].tokenAmount;\r\n        }\r\n\r\n        if (totalTokens == _amount){\r\n            backersRedeemed[_backerAddr] = true;\r\n\r\n            RedeemEvent(_backerAddr, totalTokens);\r\n\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice check withdrawal status of `_withdrawalID`\r\n    * @dev Get the withdrawal of a withdrawal. Return values can be used to instantiate a withdrawalData struct\r\n    * @param _withdrawalID The ID of the withdrawal\r\n    * @return Amount The Amount requested in the withdrawal\r\n    * @return approved True if the withdrawal has been approved\r\n    * @return reason Reason/Description of the Withdrawal\r\n    * @return backerApprovals Addresses of backers who approved the withdrawal\r\n    * @return totalStake Total number of tokens which backed the withdrawal(Total number of tokens owned by backers who approved the withdrawal)\r\n    * @return destination Receiving address of the withdrawal\r\n    */\r\n    function getWithdrawalData(uint _withdrawalID) constant public returns (uint, bool, bytes, address[], uint, address[]){\r\n        return (\r\n            withdrawals[_withdrawalID].Amount,\r\n            withdrawals[_withdrawalID].approved,\r\n            withdrawals[_withdrawalID].reason,\r\n            withdrawals[_withdrawalID].backerApprovals,\r\n            withdrawals[_withdrawalID].totalStake,\r\n            withdrawals[_withdrawalID].destination);\r\n    }\r\n\r\n    modifier founderCall{\r\n        if (msg.sender != founder) throw;\r\n        _;\r\n    }\r\n\r\n    modifier backerCheck(uint _withdrawalID){\r\n        if(backers[msg.sender].length == 0 || withdrawals[_withdrawalID].spent == true || withdrawalsVotes[msg.sender][_withdrawalID] == true) throw;\r\n        _;\r\n    }\r\n\r\n    modifier EarliestBackersSet{\r\n       if(earlyBackerList.length < numOfBackers) throw;\r\n       _;\r\n    }\r\n\r\n    modifier MinimumBackersClaimed(){\r\n      if(prepaidUnits == 0 ||\r\n        claimedPrepaidUnits == 0 ||\r\n        (claimedPrepaidUnits * divisor / prepaidUnits) < minimumPrepaidClaimedPercent) {\r\n            throw;\r\n        }\r\n      _;\r\n    }\r\n\r\n    /*\r\n     * Safeguard function.\r\n     * This function gets executed if a transaction with invalid data is sent to\r\n     * the contract or just ether without data.\r\n     */\r\n    function () {\r\n        throw;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"lastPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newFounderAddr\",\"type\":\"address\"},{\"name\":\"_oneTimesharedPhrase\",\"type\":\"bytes32\"}],\"name\":\"cofounderApproveSwitchRequest\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_withdrawalID\",\"type\":\"uint256\"}],\"name\":\"getWithdrawalData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bytes\"},{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"backersAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numOfBackers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_totalAmount\",\"type\":\"uint256\"},{\"name\":\"_reason\",\"type\":\"bytes\"},{\"name\":\"_destination\",\"type\":\"address[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_backer\",\"type\":\"address\"},{\"name\":\"_tokenPrice\",\"type\":\"uint256\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_privatePhrase\",\"type\":\"string\"},{\"name\":\"_backerRank\",\"type\":\"uint256\"}],\"name\":\"setPrepaid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_backerAddress\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"checkBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_founderHash\",\"type\":\"bytes32\"},{\"name\":\"_oneTimesharedPhrase\",\"type\":\"bytes32\"}],\"name\":\"founderSwitchRequest\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimedPrepaidUnits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"promissoryUnits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawals\",\"outputs\":[{\"name\":\"Amount\",\"type\":\"uint256\"},{\"name\":\"approved\",\"type\":\"bool\"},{\"name\":\"spent\",\"type\":\"bool\"},{\"name\":\"reason\",\"type\":\"bytes\"},{\"name\":\"totalStake\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"backers\",\"outputs\":[{\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"privateHash\",\"type\":\"bytes32\"},{\"name\":\"prepaid\",\"type\":\"bool\"},{\"name\":\"claimed\",\"type\":\"bool\"},{\"name\":\"backerRank\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prepaidUnits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_backerAddr\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"backersRedeemed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCofounderAddr\",\"type\":\"address\"}],\"name\":\"cofounderSwitchAddress\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"previousFounders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawalsVotes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimedUnits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumPrepaidClaimedPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"redeemedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawalID\",\"type\":\"uint256\"}],\"name\":\"approveWithdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"earlyBackerList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"},{\"name\":\"_boughtTokensPrice\",\"type\":\"uint256\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_privatePhrase\",\"type\":\"string\"},{\"name\":\"_backerRank\",\"type\":\"uint256\"}],\"name\":\"claimPrepaid\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_founderHash\",\"type\":\"bytes32\"},{\"name\":\"_cofounderAddress\",\"type\":\"address\"},{\"name\":\"_numOfBackers\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newFounderAddr\",\"type\":\"address\"}],\"name\":\"FounderSwitchRequestEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newFounderAddr\",\"type\":\"address\"}],\"name\":\"FounderSwitchedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newCofounderAddr\",\"type\":\"address\"}],\"name\":\"CofounderSwitchedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddedPrepaidTokensEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PrepaidTokensClaimedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensClaimedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RedeemEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"withdrawalId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reason\",\"type\":\"bytes\"}],\"name\":\"WithdrawalCreatedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"withdrawalId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"backerStakeWeigth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalStakeWeight\",\"type\":\"uint256\"}],\"name\":\"WithdrawalVotedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"withdrawalId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stakeWeight\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isMultiPayment\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reason\",\"type\":\"bytes\"}],\"name\":\"WithdrawalApproved\",\"type\":\"event\"}]","ContractName":"PromissoryToken","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"3565393966316635353137653534616465303438343961623564346236346239000000000000000000000000be715f6bfbef7e45583ec6c87d4664d04b5c88fd0000000000000000000000000000000000000000000000000000000000000004","Library":"","SwarmSource":"bzzr://1085ca20145d81536f12eef85686f820c9d2c25834d4176b3fbfeb00fbe81b5a"}]}