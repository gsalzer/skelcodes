{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\ncontract Pixel {\r\n    /* This creates an array with all balances */\r\n    struct Section {\r\n        address owner;\r\n        uint256 price;\r\n        bool for_sale;\r\n        bool initial_purchase_done;\r\n        uint image_id;\r\n        string md5;\r\n        uint last_update;\r\n        address sell_only_to;\r\n        uint16 index;\r\n        //bytes32[10] image_data;\r\n    }\r\n    string public standard = \"IPO 0.9\";\r\n    string public constant name = \"Initial Pixel Offering\";\r\n    string public constant symbol = \"IPO\";\r\n    uint8 public constant decimals = 0;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => uint256) public ethBalance;\r\n    address owner;\r\n    uint256 public ipo_price;\r\n    Section[10000] public sections;\r\n    uint256 public pool;\r\n    uint public mapWidth;\r\n    uint public mapHeight;\r\n    uint256 tokenTotalSupply = 10000;\r\n\r\n    event Buy(uint section_id);\r\n    event NewListing(uint section_id, uint price);\r\n    event Delisted(uint section_id);\r\n    event NewImage(uint section_id);\r\n    event AreaPrice(uint start_section_index, uint end_section_index, uint area_price);\r\n    event SentValue(uint value);\r\n    event PriceUpdate(uint256 price);\r\n    event WithdrawEvent(string msg);\r\n\r\n    function Pixel() {\r\n        pool = tokenTotalSupply; //Number of token / spaces\r\n        ipo_price = 100000000000000000; // 0.1\r\n        mapWidth = 1000;\r\n        mapHeight = 1000;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function totalSupply() constant returns (uint totalSupply)\r\n    {\r\n        totalSupply = tokenTotalSupply;\r\n    }\r\n\r\n    /// Updates a pixel section's index number\r\n    /// Not to be called by anyone but the contract owner\r\n    function updatePixelIndex(\r\n        uint16 _start,\r\n        uint16 _end\r\n    ) {\r\n        if(msg.sender != owner) throw; \r\n        if(_end < _start) throw;\r\n        while(_start < _end)\r\n        {\r\n            sections[_start].index = _start;\r\n            _start++;\r\n        }\r\n    }\r\n\r\n    /// Update the current IPO price\r\n    function updateIPOPrice(\r\n        uint256 _new_price\r\n    ) {\r\n        if(msg.sender != owner) throw;\r\n        ipo_price = _new_price;\r\n        PriceUpdate(ipo_price);\r\n    }\r\n\r\n    /* Get the index to access a section object from the provided raw x,y */\r\n    /// Convert from a pixel's x, y coordinates to its section index\r\n    /// This is a helper function\r\n    function getSectionIndexFromRaw(\r\n        uint _x,\r\n        uint _y\r\n    ) returns (uint) {\r\n        if (_x >= mapWidth) throw;\r\n        if (_y >= mapHeight) throw;\r\n        // Convert raw x, y to section identifer x y\r\n        _x = _x / 10;\r\n        _y = _y / 10;\r\n        //Get section_identifier from coords\r\n        return _x + (_y * 100);\r\n    }\r\n\r\n    /* Get the index to access a section object from its section identifier */\r\n    /// Get Section index based on its upper left x,y coordinates or \"identifier\"\r\n    /// coordinates\r\n    /// This is a helper function\r\n    function getSectionIndexFromIdentifier (\r\n        uint _x_section_identifier,\r\n        uint _y_section_identifier\r\n    ) returns (uint) {\r\n        if (_x_section_identifier >= (mapWidth / 10)) throw;\r\n        if (_y_section_identifier >= (mapHeight / 10)) throw;\r\n        uint index = _x_section_identifier + (_y_section_identifier * 100);\r\n        return index;\r\n    }\r\n\r\n    /* Get x,y section_identifier from a section index */\r\n    /// Get Section upper left x,y coordinates or \"identifier\" coordinates\r\n    /// based on its index number\r\n    /// This is a helper function\r\n    function getIdentifierFromSectionIndex(\r\n        uint _index\r\n    ) returns (uint x, uint y) {\r\n        if (_index > (mapWidth * mapHeight)) throw;\r\n        x = _index % 100;\r\n        y = (_index - (_index % 100)) / 100;\r\n    }\r\n\r\n    /* Check to see if Section is available for first purchase */\r\n    /// Returns whether a section is available for purchase at IPO price\r\n    function sectionAvailable(\r\n        uint _section_index\r\n    ) returns (bool) {\r\n        if (_section_index >= sections.length) throw;\r\n        Section s = sections[_section_index];\r\n        // The section has not been puchased previously\r\n        return !s.initial_purchase_done;\r\n    }\r\n\r\n    /* Check to see if Section is available for purchase */\r\n    /// Returns whether a section is available for purchase as a market sale\r\n    function sectionForSale(\r\n        uint _section_index\r\n    ) returns (bool) {\r\n        if (_section_index >= sections.length) throw;\r\n        Section s = sections[_section_index];\r\n        // Has the user set the section as for_sale\r\n        if(s.for_sale)\r\n        {\r\n            // Has the owner set a \"sell only to\" address?\r\n            if(s.sell_only_to == 0x0) return true;\r\n            if(s.sell_only_to == msg.sender) return true;\r\n            return false;\r\n        }\r\n        else\r\n        {\r\n            // Not for sale\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /* Get the price of the Section */\r\n    /// Returns the price of a section at market price.\r\n    /// This is a helper function, it is more efficient to just access the\r\n    /// contract's sections attribute directly\r\n    function sectionPrice(\r\n        uint _section_index\r\n    ) returns (uint) {\r\n        if (_section_index >= sections.length) throw;\r\n        Section s = sections[_section_index];\r\n        return s.price;\r\n    }\r\n\r\n    /*\r\n    Check to see if a region is available provided the\r\n    top-left (start) section and the bottom-right (end)\r\n    section.\r\n    */\r\n    /// Returns if a section is available for purchase, it returns the following:\r\n    /// bool: if the region is available for purchase\r\n    /// uint256: the extended price, sum of all of the market prices of the sections\r\n    ///   in the region\r\n    /// uint256: the number of sections available in the region at the IPO price\r\n    function regionAvailable(\r\n        uint _start_section_index,\r\n        uint _end_section_index\r\n    ) returns (bool available, uint extended_price, uint ipo_count) {\r\n        if (_end_section_index < _start_section_index) throw;\r\n        var (start_x, start_y) = getIdentifierFromSectionIndex(_start_section_index);\r\n        var (end_x, end_y) = getIdentifierFromSectionIndex(_end_section_index);\r\n        if (start_x >= mapWidth) throw;\r\n        if (start_y >= mapHeight) throw;\r\n        if (end_x >= mapWidth) throw;\r\n        if (end_y >= mapHeight) throw;\r\n        uint y_pos = start_y;\r\n        available = false;\r\n        extended_price = 0;\r\n        ipo_count = 0;\r\n        while (y_pos <= end_y)\r\n        {\r\n            uint x_pos = start_x;\r\n            while (x_pos <= end_x)\r\n            {\r\n                uint identifier = (x_pos + (y_pos * 100));\r\n                // Is this section available for first (IPO) purchase?\r\n                if(sectionAvailable(identifier))\r\n                {\r\n                    // The section is available as an IPO\r\n                    ipo_count = ipo_count + 1;\r\n                } else\r\n                {\r\n                    // The section has been purchased, it can only be available\r\n                    // as a market sale.\r\n                    if(sectionForSale(identifier))\r\n                    {\r\n                        extended_price = extended_price + sectionPrice(identifier);\r\n                    } else\r\n                    {\r\n                        available = false;\r\n                        //Don't return a price if there is an unavailable section\r\n                        //to reduce confusion\r\n                        extended_price = 0;\r\n                        ipo_count = 0;\r\n                        return;\r\n                    }\r\n                }\r\n                x_pos = x_pos + 1;\r\n            }\r\n            y_pos = y_pos + 1;\r\n        }\r\n        available = true;\r\n        return;\r\n    }\r\n\r\n    /// Buy a section based on its index and set its cloud image_id and md5\r\n    /// This function is payable, any over payment will be withdraw-able\r\n    function buySection (\r\n        uint _section_index,\r\n        uint _image_id,\r\n        string _md5\r\n    ) payable {\r\n        if (_section_index >= sections.length) throw;\r\n        Section section = sections[_section_index];\r\n        if(!section.for_sale && section.initial_purchase_done)\r\n        {\r\n            //Section not for sale\r\n            throw;\r\n        }\r\n        // Process payment\r\n        // Is this Section on the open market?\r\n        if(section.initial_purchase_done)\r\n        {\r\n            // Section sold, sell for market price\r\n            if(msg.value < section.price)\r\n            {\r\n                // Not enough funds were sent\r\n                throw;\r\n            } else\r\n            {\r\n                // Calculate Fee\r\n                // We only need to change the balance if the section price is non-zero\r\n                if (section.price != 0)\r\n                {\r\n                    uint fee = section.price / 100;\r\n                    // Pay contract owner the fee\r\n                    ethBalance[owner] += fee;\r\n                    // Pay the section owner the price minus the fee\r\n                    ethBalance[section.owner] += (msg.value - fee);\r\n                }\r\n                // Refund any overpayment\r\n                //require(msg.value > (msg.value - section.price));\r\n                ethBalance[msg.sender] += (msg.value - section.price);\r\n                // Owner loses a token\r\n                balanceOf[section.owner]--;\r\n                // Buyer gets a token\r\n                balanceOf[msg.sender]++;\r\n            }\r\n        } else\r\n        {\r\n            // Initial sale, sell for IPO price\r\n            if(msg.value < ipo_price)\r\n            {\r\n                // Not enough funds were sent\r\n                throw;\r\n            } else\r\n            {\r\n                // Pay the contract owner\r\n                ethBalance[owner] += msg.value;\r\n                // Refund any overpayment\r\n                //require(msg.value > (msg.value - ipo_price));\r\n                ethBalance[msg.sender] += (msg.value - ipo_price);\r\n                // Reduce token pool\r\n                pool--;\r\n                // Buyer gets a token\r\n                balanceOf[msg.sender]++;\r\n            }\r\n        }\r\n        //Payment and token transfer complete\r\n        //Transfer ownership and set not for sale by default\r\n        section.owner = msg.sender;\r\n        section.md5 = _md5;\r\n        section.image_id = _image_id;\r\n        section.last_update = block.timestamp;\r\n        section.for_sale = false;\r\n        section.initial_purchase_done = true; // even if not the first, we can pretend it is\r\n    }\r\n\r\n    /* Buy an entire region */\r\n    /// Buy a region of sections starting and including the top left section index\r\n    /// ending at and including the bottom left section index. And set its cloud\r\n    /// image_id and md5. This function is payable, if the value sent is less\r\n    /// than the price of the region, the function will throw.\r\n    function buyRegion(\r\n        uint _start_section_index,\r\n        uint _end_section_index,\r\n        uint _image_id,\r\n        string _md5\r\n    ) payable returns (uint start_section_y, uint start_section_x,\r\n    uint end_section_y, uint end_section_x){\r\n        if (_end_section_index < _start_section_index) throw;\r\n        if (_start_section_index >= sections.length) throw;\r\n        if (_end_section_index >= sections.length) throw;\r\n        // ico_ammount reffers to the number of sections that are available\r\n        // at ICO price\r\n        var (available, ext_price, ico_amount) = regionAvailable(_start_section_index, _end_section_index);\r\n        if (!available) throw;\r\n\r\n        // Calculate price\r\n        uint area_price =  ico_amount * ipo_price;\r\n        area_price = area_price + ext_price;\r\n        AreaPrice(_start_section_index, _end_section_index, area_price);\r\n        SentValue(msg.value);\r\n        if (area_price > msg.value) throw;\r\n\r\n        // ico_ammount reffers to the amount in wei that the contract owner\r\n        // is owed\r\n        ico_amount = 0;\r\n        // ext_price reffers to the amount in wei that the contract owner is\r\n        // owed in fees from market sales\r\n        ext_price = 0;\r\n\r\n        // User sent enough funds, let's go\r\n        start_section_x = _start_section_index % 100;\r\n        end_section_x = _end_section_index % 100;\r\n        start_section_y = _start_section_index - (_start_section_index % 100);\r\n        start_section_y = start_section_y / 100;\r\n        end_section_y = _end_section_index - (_end_section_index % 100);\r\n        end_section_y = end_section_y / 100;\r\n        uint x_pos = start_section_x;\r\n        while (x_pos <= end_section_x)\r\n        {\r\n            uint y_pos = start_section_y;\r\n            while (y_pos <= end_section_y)\r\n            {\r\n                // Is this an IPO section?\r\n                Section s = sections[x_pos + (y_pos * 100)];\r\n                if (s.initial_purchase_done)\r\n                {\r\n                    // Sale, we need to transfer balance\r\n                    // We only need to modify balances if the section's price\r\n                    // is non-zero\r\n                    if(s.price != 0)\r\n                    {\r\n                        // Pay the contract owner the price\r\n                        ethBalance[owner] += (s.price / 100);\r\n                        // Pay the owner the price minus the fee\r\n                        ethBalance[s.owner] += (s.price - (s.price / 100));\r\n                    }\r\n                    // Refund any overpayment\r\n                    //if(msg.value > (msg.value - s.price)) throw;\r\n                    ext_price += s.price;\r\n                    // Owner loses a token\r\n                    balanceOf[s.owner]--;\r\n                    // Buyer gets a token\r\n                    balanceOf[msg.sender]++;\r\n                } else\r\n                {\r\n                    // IPO we get to keep the value\r\n                    // Pay the contract owner\r\n                    ethBalance[owner] += ipo_price;\r\n                    // Refund any overpayment\r\n                    //if(msg.value > (msg.value - ipo_price)) throw;\r\n                    // TODO Decrease the value\r\n                    ico_amount += ipo_price;\r\n                    // Reduce token pool\r\n                    pool--;\r\n                    // Buyer gets a token\r\n                    balanceOf[msg.sender]++;\r\n                }\r\n\r\n                // Payment and token transfer complete\r\n                // Transfer ownership and set not for sale by default\r\n                s.owner = msg.sender;\r\n                s.md5 = _md5;\r\n                s.image_id = _image_id;\r\n                //s.last_update = block.timestamp;\r\n                s.for_sale = false;\r\n                s.initial_purchase_done = true; // even if not the first, we can pretend it is\r\n\r\n                Buy(x_pos + (y_pos * 100));\r\n                // Done\r\n                y_pos = y_pos + 1;\r\n            }\r\n            x_pos = x_pos + 1;\r\n        }\r\n        ethBalance[msg.sender] += msg.value - (ext_price + ico_amount);\r\n        return;\r\n    }\r\n\r\n    /* Set the for sale flag and a price for a section */\r\n    /// Set an inidividual section as for sale at the provided price in wei.\r\n    /// The section will be available for purchase by any address.\r\n    function setSectionForSale(\r\n        uint _section_index,\r\n        uint256 _price\r\n    ) {\r\n        if (_section_index >= sections.length) throw;\r\n        Section section = sections[_section_index];\r\n        if(section.owner != msg.sender) throw;\r\n        section.price = _price;\r\n        section.for_sale = true;\r\n        section.sell_only_to = 0x0;\r\n        NewListing(_section_index, _price);\r\n    }\r\n\r\n    /* Set the for sale flag and price for a region */\r\n    /// Set a section region for sale at the provided price in wei.\r\n    /// The sections in the region will be available for purchase by any address.\r\n    function setRegionForSale(\r\n        uint _start_section_index,\r\n        uint _end_section_index,\r\n        uint _price\r\n    ) {\r\n        if(_start_section_index > _end_section_index) throw;\r\n        if(_end_section_index > 9999) throw;\r\n        uint x_pos = _start_section_index % 100;\r\n        uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100;\r\n        uint x_max = _end_section_index % 100;\r\n        uint y_max = (_end_section_index - (_end_section_index % 100)) / 100;\r\n        while(x_pos <= x_max)\r\n        {\r\n            uint y_pos = base_y_pos;\r\n            while(y_pos <= y_max)\r\n            {\r\n                Section section = sections[x_pos + (y_pos * 100)];\r\n                if(section.owner == msg.sender)\r\n                {\r\n                    section.price = _price;\r\n                    section.for_sale = true;\r\n                    section.sell_only_to = 0x0;\r\n                    NewListing(x_pos + (y_pos * 100), _price);\r\n                }\r\n                y_pos++;\r\n            }\r\n            x_pos++;\r\n        }\r\n    }\r\n\r\n    /* Set the for sale flag and price for a region */\r\n    /// Set a section region starting in the top left at the supplied start section\r\n    /// index to and including the supplied bottom right end section index\r\n    /// for sale at the provided price in wei, to the provided address.\r\n    /// The sections in the region will be available for purchase only by the\r\n    /// provided address.\r\n    function setRegionForSaleToAddress(\r\n        uint _start_section_index,\r\n        uint _end_section_index,\r\n        uint _price,\r\n        address _only_sell_to\r\n    ) {\r\n        if(_start_section_index > _end_section_index) throw;\r\n        if(_end_section_index > 9999) throw;\r\n        uint x_pos = _start_section_index % 100;\r\n        uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100;\r\n        uint x_max = _end_section_index % 100;\r\n        uint y_max = (_end_section_index - (_end_section_index % 100)) / 100;\r\n        while(x_pos <= x_max)\r\n        {\r\n            uint y_pos = base_y_pos;\r\n            while(y_pos <= y_max)\r\n            {\r\n                Section section = sections[x_pos + (y_pos * 100)];\r\n                if(section.owner == msg.sender)\r\n                {\r\n                    section.price = _price;\r\n                    section.for_sale = true;\r\n                    section.sell_only_to = _only_sell_to;\r\n                    NewListing(x_pos + (y_pos * 100), _price);\r\n                }\r\n                y_pos++;\r\n            }\r\n            x_pos++;\r\n        }\r\n    }\r\n\r\n    /*\r\n    Set an entire region's cloud image data\r\n    */\r\n    /// Update a region of sections' cloud image_id and md5 to be redrawn on the\r\n    /// map starting at the top left start section index to and including the\r\n    /// bottom right section index. Fires a NewImage event with the top left\r\n    /// section index. If any sections not owned by the sender are in the region\r\n    /// they are ignored.\r\n    function setRegionImageDataCloud(\r\n        uint _start_section_index,\r\n        uint _end_section_index,\r\n        uint _image_id,\r\n        string _md5\r\n    ) {\r\n        if (_end_section_index < _start_section_index) throw;\r\n        var (start_x, start_y) = getIdentifierFromSectionIndex(_start_section_index);\r\n        var (end_x, end_y) = getIdentifierFromSectionIndex(_end_section_index);\r\n        if (start_x >= mapWidth) throw;\r\n        if (start_y >= mapHeight) throw;\r\n        if (end_x >= mapWidth) throw;\r\n        if (end_y >= mapHeight) throw;\r\n        uint y_pos = start_y;\r\n        while (y_pos <= end_y)\r\n        {\r\n            uint x_pos = start_x;\r\n            while (x_pos <= end_x)\r\n            {\r\n                uint identifier = (x_pos + (y_pos * 100));\r\n                Section s = sections[identifier];\r\n                if(s.owner == msg.sender)\r\n                {\r\n                    s.image_id = _image_id;\r\n                    s.md5 = _md5;\r\n                }\r\n                x_pos = x_pos + 1;\r\n            }\r\n            y_pos = y_pos + 1;\r\n        }\r\n        NewImage(_start_section_index);\r\n        return;\r\n    }\r\n\r\n    /* Set the for sale flag and a price for a section to a specific address */\r\n    /// Set a single section as for sale at the provided price in wei only\r\n    /// to the supplied address.\r\n    function setSectionForSaleToAddress(\r\n        uint _section_index,\r\n        uint256 _price,\r\n        address _to\r\n    ) {\r\n        if (_section_index >= sections.length) throw;\r\n        Section section = sections[_section_index];\r\n        if(section.owner != msg.sender) throw;\r\n        section.price = _price;\r\n        section.for_sale = true;\r\n        section.sell_only_to = _to;\r\n        NewListing(_section_index, _price);\r\n    }\r\n\r\n    /* Remove the for sale flag from a section */\r\n    /// Delist a section for sale. Making it no longer available on the market.\r\n    function unsetSectionForSale(\r\n        uint _section_index\r\n    ) {\r\n        if (_section_index >= sections.length) throw;\r\n        Section section = sections[_section_index];\r\n        if(section.owner != msg.sender) throw;\r\n        section.for_sale = false;\r\n        section.price = 0;\r\n        section.sell_only_to = 0x0;\r\n        Delisted(_section_index);\r\n    }\r\n\r\n    /* Set the for sale flag and price for a region */\r\n    /// Delist a region of sections for sale. Making the sections no longer\r\n    /// no longer available on the market.\r\n    function unsetRegionForSale(\r\n        uint _start_section_index,\r\n        uint _end_section_index\r\n    ) {\r\n        if(_start_section_index > _end_section_index) throw;\r\n        if(_end_section_index > 9999) throw;\r\n        uint x_pos = _start_section_index % 100;\r\n        uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100;\r\n        uint x_max = _end_section_index % 100;\r\n        uint y_max = (_end_section_index - (_end_section_index % 100)) / 100;\r\n        while(x_pos <= x_max)\r\n        {\r\n            uint y_pos = base_y_pos;\r\n            while(y_pos <= y_max)\r\n            {\r\n                Section section = sections[x_pos + (y_pos * 100)];\r\n                if(section.owner == msg.sender)\r\n                {\r\n                    section.for_sale = false;\r\n                    section.price = 0;\r\n                    Delisted(x_pos + (y_pos * 100));\r\n                }\r\n                y_pos++;\r\n            }\r\n            x_pos++;\r\n        }\r\n    }\r\n\r\n    /// Depreciated. Store the raw image data in the contract.\r\n    function setImageData(\r\n        uint _section_index\r\n        // bytes32 _row_zero,\r\n        // bytes32 _row_one,\r\n        // bytes32 _row_two,\r\n        // bytes32 _row_three,\r\n        // bytes32 _row_four,\r\n        // bytes32 _row_five,\r\n        // bytes32 _row_six,\r\n        // bytes32 _row_seven,\r\n        // bytes32 _row_eight,\r\n        // bytes32 _row_nine\r\n    ) {\r\n        if (_section_index >= sections.length) throw;\r\n        Section section = sections[_section_index];\r\n        if(section.owner != msg.sender) throw;\r\n        // section.image_data[0] = _row_zero;\r\n        // section.image_data[1] = _row_one;\r\n        // section.image_data[2] = _row_two;\r\n        // section.image_data[3] = _row_three;\r\n        // section.image_data[4] = _row_four;\r\n        // section.image_data[5] = _row_five;\r\n        // section.image_data[6] = _row_six;\r\n        // section.image_data[7] = _row_seven;\r\n        // section.image_data[8] = _row_eight;\r\n        // section.image_data[9] = _row_nine;\r\n        section.image_id = 0;\r\n        section.md5 = \"\";\r\n        section.last_update = block.timestamp;\r\n        NewImage(_section_index);\r\n    }\r\n\r\n    /// Set a section's image data to be redrawn on the map. Fires a NewImage\r\n    /// event.\r\n    function setImageDataCloud(\r\n        uint _section_index,\r\n        uint _image_id,\r\n        string _md5\r\n    ) {\r\n        if (_section_index >= sections.length) throw;\r\n        Section section = sections[_section_index];\r\n        if(section.owner != msg.sender) throw;\r\n        section.image_id = _image_id;\r\n        section.md5 = _md5;\r\n        section.last_update = block.timestamp;\r\n        NewImage(_section_index);\r\n    }\r\n\r\n    /// Withdraw ethereum from the sender's ethBalance.\r\n    function withdraw() returns (bool) {\r\n        var amount = ethBalance[msg.sender];\r\n        if (amount > 0) {\r\n            // It is important to set this to zero because the recipient\r\n            // can call this function again as part of the receiving call\r\n            // before `send` returns.\r\n            ethBalance[msg.sender] = 0;\r\n            WithdrawEvent(\"Reset Sender\");\r\n            msg.sender.transfer(amount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// Deposit ethereum into the sender's ethBalance. Not recommended.\r\n    function deposit() payable\r\n    {\r\n        ethBalance[msg.sender] += msg.value;\r\n    }\r\n\r\n    /// Transfer a section and an IPO token to the supplied address.\r\n    function transfer(\r\n      address _to,\r\n      uint _section_index\r\n    ) {\r\n        if (_section_index > 9999) throw;\r\n        if (sections[_section_index].owner != msg.sender) throw;\r\n        if (balanceOf[_to] + 1 < balanceOf[_to]) throw;\r\n        sections[_section_index].owner = _to;\r\n        sections[_section_index].for_sale = false;\r\n        balanceOf[msg.sender] -= 1;\r\n        balanceOf[_to] += 1;\r\n    }\r\n\r\n\r\n\r\n    /// Transfer a region of sections and IPO tokens to the supplied address.\r\n    function transferRegion(\r\n        uint _start_section_index,\r\n        uint _end_section_index,\r\n        address _to\r\n    ) {\r\n        if(_start_section_index > _end_section_index) throw;\r\n        if(_end_section_index > 9999) throw;\r\n        uint x_pos = _start_section_index % 100;\r\n        uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100;\r\n        uint x_max = _end_section_index % 100;\r\n        uint y_max = (_end_section_index - (_end_section_index % 100)) / 100;\r\n        while(x_pos <= x_max)\r\n        {\r\n            uint y_pos = base_y_pos;\r\n            while(y_pos <= y_max)\r\n            {\r\n                Section section = sections[x_pos + (y_pos * 100)];\r\n                if(section.owner == msg.sender)\r\n                {\r\n                  if (balanceOf[_to] + 1 < balanceOf[_to]) throw;\r\n                  section.owner = _to;\r\n                  section.for_sale = false;\r\n                  balanceOf[msg.sender] -= 1;\r\n                  balanceOf[_to] += 1;\r\n                }\r\n                y_pos++;\r\n            }\r\n            x_pos++;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_section_index\",\"type\":\"uint256\"},{\"name\":\"_image_id\",\"type\":\"uint256\"},{\"name\":\"_md5\",\"type\":\"string\"}],\"name\":\"setImageDataCloud\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_section_index\",\"type\":\"uint256\"}],\"name\":\"setImageData\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_x_section_identifier\",\"type\":\"uint256\"},{\"name\":\"_y_section_identifier\",\"type\":\"uint256\"}],\"name\":\"getSectionIndexFromIdentifier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sections\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"for_sale\",\"type\":\"bool\"},{\"name\":\"initial_purchase_done\",\"type\":\"bool\"},{\"name\":\"image_id\",\"type\":\"uint256\"},{\"name\":\"md5\",\"type\":\"string\"},{\"name\":\"last_update\",\"type\":\"uint256\"},{\"name\":\"sell_only_to\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint16\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_section_index\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setSectionForSale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_section_index\",\"type\":\"uint256\"}],\"name\":\"unsetSectionForSale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start_section_index\",\"type\":\"uint256\"},{\"name\":\"_end_section_index\",\"type\":\"uint256\"}],\"name\":\"regionAvailable\",\"outputs\":[{\"name\":\"available\",\"type\":\"bool\"},{\"name\":\"extended_price\",\"type\":\"uint256\"},{\"name\":\"ipo_count\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start_section_index\",\"type\":\"uint256\"},{\"name\":\"_end_section_index\",\"type\":\"uint256\"},{\"name\":\"_image_id\",\"type\":\"uint256\"},{\"name\":\"_md5\",\"type\":\"string\"}],\"name\":\"buyRegion\",\"outputs\":[{\"name\":\"start_section_y\",\"type\":\"uint256\"},{\"name\":\"start_section_x\",\"type\":\"uint256\"},{\"name\":\"end_section_y\",\"type\":\"uint256\"},{\"name\":\"end_section_x\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_x\",\"type\":\"uint256\"},{\"name\":\"_y\",\"type\":\"uint256\"}],\"name\":\"getSectionIndexFromRaw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start_section_index\",\"type\":\"uint256\"},{\"name\":\"_end_section_index\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setRegionForSale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_section_index\",\"type\":\"uint256\"}],\"name\":\"sectionAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_section_index\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"setSectionForSaleToAddress\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_section_index\",\"type\":\"uint256\"},{\"name\":\"_image_id\",\"type\":\"uint256\"},{\"name\":\"_md5\",\"type\":\"string\"}],\"name\":\"buySection\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start_section_index\",\"type\":\"uint256\"},{\"name\":\"_end_section_index\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferRegion\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start_section_index\",\"type\":\"uint256\"},{\"name\":\"_end_section_index\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_only_sell_to\",\"type\":\"address\"}],\"name\":\"setRegionForSaleToAddress\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ipo_price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mapWidth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_section_index\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_section_index\",\"type\":\"uint256\"}],\"name\":\"sectionForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getIdentifierFromSectionIndex\",\"outputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start_section_index\",\"type\":\"uint256\"},{\"name\":\"_end_section_index\",\"type\":\"uint256\"}],\"name\":\"unsetRegionForSale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_new_price\",\"type\":\"uint256\"}],\"name\":\"updateIPOPrice\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint16\"},{\"name\":\"_end\",\"type\":\"uint16\"}],\"name\":\"updatePixelIndex\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start_section_index\",\"type\":\"uint256\"},{\"name\":\"_end_section_index\",\"type\":\"uint256\"},{\"name\":\"_image_id\",\"type\":\"uint256\"},{\"name\":\"_md5\",\"type\":\"string\"}],\"name\":\"setRegionImageDataCloud\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ethBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_section_index\",\"type\":\"uint256\"}],\"name\":\"sectionPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mapHeight\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"section_id\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"section_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"NewListing\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"section_id\",\"type\":\"uint256\"}],\"name\":\"Delisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"section_id\",\"type\":\"uint256\"}],\"name\":\"NewImage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"start_section_index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"end_section_index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"area_price\",\"type\":\"uint256\"}],\"name\":\"AreaPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SentValue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PriceUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"WithdrawEvent\",\"type\":\"event\"}]","ContractName":"Pixel","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2be1615063e4899d77deac8c7513da14ed9fd226ced2583ab232f1d4ad1f975f"}]}