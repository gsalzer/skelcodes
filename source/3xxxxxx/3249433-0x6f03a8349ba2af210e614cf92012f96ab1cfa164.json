{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.9;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() constant returns (uint256 totalSupply);\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n/**\r\n * @title MainstreetToken\r\n */\r\ncontract MainstreetToken is ERC20 {\r\n    string public name = 'Mainstreet Token';             //The Token's name: e.g. DigixDAO Tokens\r\n    uint8 public decimals = 18;             // 1Token ¨= 1$ (1ETH ¨= 10$)\r\n    string public symbol = 'MIT';           //An identifier: e.g. REP\r\n    string public version = 'MIT_0.1';\r\n\r\n    mapping (address => uint) ownerMIT;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n    uint public totalMIT;\r\n    uint public start;\r\n\r\n    address public mainstreetCrowdfund;\r\n\r\n    address public intellisys;\r\n\r\n    bool public testing;\r\n\r\n    modifier fromCrowdfund() {\r\n        if (msg.sender != mainstreetCrowdfund) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isActive() {\r\n        if (block.timestamp < start) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isNotActive() {\r\n        if (!testing && block.timestamp >= start) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier recipientIsValid(address recipient) {\r\n        if (recipient == 0 || recipient == address(this)) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier allowanceIsZero(address spender, uint value) {\r\n        // To change the approve amount you first have to reduce the addresses´\r\n        // allowance to zero by calling `approve(_spender,0)` if it is not\r\n        // already 0 to mitigate the race condition described here:\r\n        // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        if ((value != 0) && (allowed[msg.sender][spender] != 0)) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Constructor.\r\n     * @param _mainstreetCrowdfund Address of crowdfund contract.\r\n     * @param _intellisys Address to receive intellisys' tokens.\r\n     * @param _start Timestamp when the token becomes active.\r\n     */\r\n    function MainstreetToken(address _mainstreetCrowdfund, address _intellisys, uint _start, bool _testing) {\r\n        mainstreetCrowdfund = _mainstreetCrowdfund;\r\n        intellisys = _intellisys;\r\n        start = _start;\r\n        testing = _testing;\r\n    }\r\n\r\n    /**\r\n     * @dev Add to token balance on address. Must be from crowdfund.\r\n     * @param recipient Address to add tokens to.\r\n     * @return MIT Amount of MIT to add.\r\n     */\r\n    function addTokens(address recipient, uint MIT) external isNotActive fromCrowdfund {\r\n        ownerMIT[recipient] += MIT;\r\n        uint intellisysMIT = MIT / 10;\r\n        ownerMIT[intellisys] += intellisysMIT;\r\n        totalMIT += MIT + intellisysMIT;\r\n        Transfer(0x0, recipient, MIT);\r\n        Transfer(0x0, intellisys, intellisysMIT);\r\n    }\r\n\r\n    /**\r\n     * @dev Implements ERC20 totalSupply()\r\n     */\r\n    function totalSupply() constant returns (uint256 totalSupply) {\r\n        totalSupply = totalMIT;\r\n    }\r\n\r\n    /**\r\n     * @dev Implements ERC20 balanceOf()\r\n     */\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        balance = ownerMIT[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Implements ERC20 transfer()\r\n     */\r\n    function transfer(address _to, uint256 _value) isActive recipientIsValid(_to) returns (bool success) {\r\n        if (ownerMIT[msg.sender] >= _value) {\r\n            ownerMIT[msg.sender] -= _value;\r\n            ownerMIT[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Implements ERC20 transferFrom()\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) isActive recipientIsValid(_to) returns (bool success) {\r\n        if (allowed[_from][msg.sender] >= _value && ownerMIT[_from] >= _value) {\r\n            ownerMIT[_to] += _value;\r\n            ownerMIT[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Implements ERC20 approve()\r\n     */\r\n    function approve(address _spender, uint256 _value) isActive allowanceIsZero(_spender, _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Implements ERC20 allowance()\r\n     */\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        remaining = allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title MainstreetCrowdfund\r\n */\r\ncontract MainstreetCrowdfund {\r\n\r\n    uint public start;\r\n    uint public end;\r\n\r\n    mapping (address => uint) public senderETH;\r\n    mapping (address => uint) public senderMIT;\r\n    mapping (address => uint) public recipientETH;\r\n    mapping (address => uint) public recipientMIT;\r\n    mapping (address => uint) public recipientExtraMIT;\r\n\r\n    uint public totalETH;\r\n    uint public limitETH;\r\n\r\n    uint public bonus1StartETH;\r\n    uint public bonus2StartETH;\r\n\r\n    mapping (address => bool) public whitelistedAddresses;\r\n\r\n    address public exitAddress;\r\n    address public creator;\r\n\r\n    MainstreetToken public mainstreetToken;\r\n\r\n    event MITPurchase(address indexed sender, address indexed recipient, uint ETH, uint MIT);\r\n\r\n    modifier saleActive() {\r\n        if (address(mainstreetToken) == 0) {\r\n            throw;\r\n        }\r\n        if (block.timestamp < start || block.timestamp >= end) {\r\n            throw;\r\n        }\r\n        if (totalETH + msg.value > limitETH) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier hasValue() {\r\n        if (msg.value == 0) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier senderIsWhitelisted() {\r\n        if (whitelistedAddresses[msg.sender] != true) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier recipientIsValid(address recipient) {\r\n        if (recipient == 0 || recipient == address(this)) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isCreator() {\r\n        if (msg.sender != creator) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier tokenContractNotSet() {\r\n        if (address(mainstreetToken) != 0) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Constructor.\r\n     * @param _start Timestamp of when the crowdsale will start.\r\n     * @param _end Timestamp of when the crowdsale will end.\r\n     * @param _limitETH Maximum amount of ETH that can be sent to the contract in total. Denominated in wei.\r\n     * @param _bonus1StartETH Amount of Ether (denominated in wei) that is required to qualify for the first bonus.\r\n     * @param _bonus1StartETH Amount of Ether (denominated in wei) that is required to qualify for the second bonus.\r\n     * @param _exitAddress Address that all ETH should be forwarded to.\r\n     * @param whitelist1 First address that can send ETH.\r\n     * @param whitelist2 Second address that can send ETH.\r\n     * @param whitelist3 Third address that can send ETH.\r\n     */\r\n    function MainstreetCrowdfund(uint _start, uint _end, uint _limitETH, uint _bonus1StartETH, uint _bonus2StartETH, address _exitAddress, address whitelist1, address whitelist2, address whitelist3) {\r\n        creator = msg.sender;\r\n        start = _start;\r\n        end = _end;\r\n        limitETH = _limitETH;\r\n        bonus1StartETH = _bonus1StartETH;\r\n        bonus2StartETH = _bonus2StartETH;\r\n\r\n        whitelistedAddresses[whitelist1] = true;\r\n        whitelistedAddresses[whitelist2] = true;\r\n        whitelistedAddresses[whitelist3] = true;\r\n        exitAddress = _exitAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the address of the token contract. Must be called by creator of this. Can only be set once.\r\n     * @param _mainstreetToken Address of the token contract.\r\n     */\r\n    function setTokenContract(MainstreetToken _mainstreetToken) external isCreator tokenContractNotSet {\r\n        mainstreetToken = _mainstreetToken;\r\n    }\r\n\r\n    /**\r\n     * @dev Forward Ether to the exit address. Store all ETH and MIT information in public state and logs.\r\n     * @param recipient Address that tokens should be attributed to.\r\n     * @return MIT Amount of MIT purchased. This does not include the per-recipient quantity bonus.\r\n     */\r\n    function purchaseMIT(address recipient) external senderIsWhitelisted payable saleActive hasValue recipientIsValid(recipient) returns (uint increaseMIT) {\r\n\r\n        // Attempt to send the ETH to the exit address.\r\n        if (!exitAddress.send(msg.value)) {\r\n            throw;\r\n        }\r\n\r\n        // Update ETH amounts.\r\n        senderETH[msg.sender] += msg.value;\r\n        recipientETH[recipient] += msg.value;\r\n        totalETH += msg.value;\r\n\r\n        // Calculate MIT purchased directly in this transaction.\r\n        uint MIT = msg.value * 10;   // $1 / MIT based on $10 / ETH value\r\n\r\n        // Calculate time-based bonus.\r\n        if (block.timestamp - start < 2 weeks) {\r\n            MIT += MIT / 10;    // 10% bonus\r\n        }\r\n        else if (block.timestamp - start < 5 weeks) {\r\n            MIT += MIT / 20;    // 5% bonus\r\n        }\r\n\r\n        // Record directly-purchased MIT.\r\n        senderMIT[msg.sender] += MIT;\r\n        recipientMIT[recipient] += MIT;\r\n\r\n        // Store previous value-based bonus for this address.\r\n        uint oldExtra = recipientExtraMIT[recipient];\r\n\r\n        // Calculate new value-based bonus.\r\n        if (recipientETH[recipient] >= bonus2StartETH) {\r\n            recipientExtraMIT[recipient] = (recipientMIT[recipient] * 75) / 1000;      // 7.5% bonus\r\n        }\r\n        else if (recipientETH[recipient] >= bonus1StartETH) {\r\n            recipientExtraMIT[recipient] = (recipientMIT[recipient] * 375) / 10000;      // 3.75% bonus\r\n        }\r\n\r\n        // Calculate MIT increase for this address from this transaction.\r\n        increaseMIT = MIT + (recipientExtraMIT[recipient] - oldExtra);\r\n\r\n        // Tell the token contract about the increase.\r\n        mainstreetToken.addTokens(recipient, increaseMIT);\r\n\r\n        // Log this purchase.\r\n        MITPurchase(msg.sender, recipient, msg.value, increaseMIT);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"recipientExtraMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"recipientETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exitAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"purchaseMIT\",\"outputs\":[{\"name\":\"increaseMIT\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"senderETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainstreetToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonus1StartETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mainstreetToken\",\"type\":\"address\"}],\"name\":\"setTokenContract\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limitETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"senderMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"recipientMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonus2StartETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"end\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"},{\"name\":\"_limitETH\",\"type\":\"uint256\"},{\"name\":\"_bonus1StartETH\",\"type\":\"uint256\"},{\"name\":\"_bonus2StartETH\",\"type\":\"uint256\"},{\"name\":\"_exitAddress\",\"type\":\"address\"},{\"name\":\"whitelist1\",\"type\":\"address\"},{\"name\":\"whitelist2\",\"type\":\"address\"},{\"name\":\"whitelist3\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ETH\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"MIT\",\"type\":\"uint256\"}],\"name\":\"MITPurchase\",\"type\":\"event\"}]","ContractName":"MainstreetCrowdfund","CompilerVersion":"v0.4.9+commit.364da425","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000058b1c6200000000000000000000000000000000000000000000000000000000058b36c0000000000000000000000000000000000000000000002116545850052128000000000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000001bc16d674ec8000000000000000000000000000085bfbc2d19901bdfeae29fdcfaf087b2e41aea4c000000000000000000000000007174732705604bbbf77038332dc52fd5a5000c000000000000000000000000009bab5fb86c584dc85d0eb9df1591400c6079890000000000000000000000001dba1131000664b884a1ba238464159892252d3a","Library":"","SwarmSource":"bzzr://5cd4d809e7c5636165885a83db435892c95f752ad385f6b6ec97838438971c81"}]}