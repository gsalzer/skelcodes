{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\n/// @title Oracle contract where m of n predetermined voters determine a value\r\ncontract FederatedOracleBytes8 {\r\n    struct Voter {\r\n        bool isVoter;\r\n        bool hasVoted;\r\n    }\r\n\r\n    event VoterAdded(address account);\r\n    event VoteSubmitted(address account, bytes8 value);\r\n    event ValueFinalized(bytes8 value);\r\n\r\n    mapping(address => Voter) public voters;\r\n    mapping(bytes8 => uint8) public votes;\r\n\r\n    uint8 public m;\r\n    uint8 public n;\r\n    bytes8 public finalValue;\r\n\r\n    uint8 private voterCount;\r\n    address private creator;\r\n\r\n    function FederatedOracleBytes8(uint8 m_, uint8 n_) {\r\n        creator = msg.sender;\r\n        m = m_;\r\n        n = n_;\r\n    }\r\n\r\n    function addVoter(address account) {\r\n        if (msg.sender != creator) {\r\n            throw;\r\n        }\r\n        if (voterCount == n) {\r\n            throw;\r\n        }\r\n\r\n        var voter = voters[account];\r\n        if (voter.isVoter) {\r\n            throw;\r\n        }\r\n\r\n        voter.isVoter = true;\r\n        voterCount++;\r\n        VoterAdded(account);\r\n    }\r\n\r\n    function submitValue(bytes8 value) {\r\n        var voter = voters[msg.sender];\r\n        if (!voter.isVoter) {\r\n            throw;\r\n        }\r\n        if (voter.hasVoted) {\r\n            throw;\r\n        }\r\n\r\n        voter.hasVoted = true;\r\n        votes[value]++;\r\n        VoteSubmitted(msg.sender, value);\r\n\r\n        if (votes[value] == m) {\r\n            finalValue = value;\r\n            ValueFinalized(value);\r\n        }\r\n    }\r\n}\r\n\r\n// This library can be used to score byte brackets. Byte brackets are a succinct encoding of a\r\n// 64 team bracket into an 8-byte array. The tournament results are encoded in the same format and\r\n// compared against the bracket picks. To reduce the computation time of scoring a bracket, a 64-bit\r\n// value called the \"scoring mask\" is first computed once for a particular result set and used to\r\n// score all brackets.\r\n//\r\n// Algorithm description: https://drive.google.com/file/d/0BxHbbgrucCx2N1MxcnA1ZE1WQW8/view\r\n// Reference implementation: https://gist.github.com/pursuingpareto/b15f1197d96b1a2bbc48\r\nlibrary ByteBracket {\r\n    function getBracketScore(bytes8 bracket, bytes8 results, uint64 filter)\r\n        constant\r\n        returns (uint8 points)\r\n    {\r\n        uint8 roundNum = 0;\r\n        uint8 numGames = 32;\r\n        uint64 blacklist = (uint64(1) << numGames) - 1;\r\n        uint64 overlap = uint64(~(bracket ^ results));\r\n\r\n        while (numGames > 0) {\r\n            uint64 scores = overlap & blacklist;\r\n            points += popcount(scores) << roundNum;\r\n            blacklist = pairwiseOr(scores & filter);\r\n            overlap >>= numGames;\r\n            filter >>= numGames;\r\n            numGames /= 2;\r\n            roundNum++;\r\n        }\r\n    }\r\n\r\n    function getScoringMask(bytes8 results) constant returns (uint64 mask) {\r\n        // Filter for the second most significant bit since MSB is ignored.\r\n        bytes8 bitSelector = 1 << 62;\r\n        for (uint i = 0; i < 31; i++) {\r\n            mask <<= 2;\r\n            if (results & bitSelector != 0) {\r\n                mask |= 1;\r\n            } else {\r\n                mask |= 2;\r\n            }\r\n            results <<= 1;\r\n        }\r\n    }\r\n\r\n    // Returns a bitstring of half the length by taking bits two at a time and ORing them.\r\n    //\r\n    // Separates the even and odd bits by repeatedly\r\n    // shuffling smaller segments of a bitstring.\r\n    function pairwiseOr(uint64 bits) internal returns (uint64) {\r\n        uint64 tmp;\r\n        tmp = (bits ^ (bits >> 1)) & 0x22222222;\r\n        bits ^= (tmp ^ (tmp << 1));\r\n        tmp = (bits ^ (bits >> 2)) & 0x0c0c0c0c;\r\n        bits ^= (tmp ^ (tmp << 2));\r\n        tmp = (bits ^ (bits >> 4)) & 0x00f000f0;\r\n        bits ^= (tmp ^ (tmp << 4));\r\n        tmp = (bits ^ (bits >> 8)) & 0x0000ff00;\r\n        bits ^= (tmp ^ (tmp << 8));\r\n        uint64 evens = bits >> 16;\r\n        uint64 odds = bits % 0x10000;\r\n        return evens | odds;\r\n    }\r\n\r\n    // Counts the number of 1s in a bitstring.\r\n    function popcount(uint64 bits) internal returns (uint8) {\r\n        bits -= (bits >> 1) & 0x5555555555555555;\r\n        bits = (bits & 0x3333333333333333) + ((bits >> 2) & 0x3333333333333333);\r\n        bits = (bits + (bits >> 4)) & 0x0f0f0f0f0f0f0f0f;\r\n        return uint8(((bits * 0x0101010101010101) & 0xffffffffffffffff) >> 56);\r\n    }\r\n}\r\n\r\n/**\r\n * @title March Madness bracket pool smart contract\r\n *\r\n * The contract has four phases: submission, tournament, scoring, then the contest is over. During\r\n * the submission phase, entrants submit a cryptographic commitment to their bracket picks. Each\r\n * address may only make one submission. Entrants may reveal their brackets at any time after making\r\n * the commitment. Once the tournament starts, no further submissions are allowed. When the\r\n * tournament ends, the results are submitted by the oracles and the scoring period begins. During\r\n * the scoring period, entrants may reveal their bracket picks and score their brackets. The highest\r\n * scoring bracket revealed is recorded. After the scoring period ends, all entrants with a highest\r\n * scoring bracket split the pot and may withdraw their winnings.\r\n *\r\n * In the event that the oracles do not submit results or fail to reach consensus after a certain\r\n * amount of time, entry fees will be returned to entrants.\r\n */\r\ncontract MarchMadness {\r\n    struct Submission {\r\n        bytes32 commitment;\r\n        bytes8 bracket;\r\n        uint8 score;\r\n        bool collectedWinnings;\r\n        bool collectedEntryFee;\r\n    }\r\n\r\n    event SubmissionAccepted(address account);\r\n    event NewWinner(address winner, uint8 score);\r\n    event TournamentOver();\r\n\r\n    FederatedOracleBytes8 resultsOracle;\r\n\r\n\tmapping(address => Submission) submissions;\r\n\r\n    // Amount that winners will collect\r\n    uint public winnings;\r\n\r\n    // Number of submissions with a winning score\r\n    uint public numWinners;\r\n\r\n    // Data derived from results used by bracket scoring algorithm\r\n    uint64 private scoringMask;\r\n\r\n    // Fee in wei required to enter a bracket\r\n    uint public entryFee;\r\n\r\n    // Duration in seconds of the scoring phase\r\n    uint public scoringDuration;\r\n\r\n    // Timestamp of the start of the tournament phase\r\n    uint public tournamentStartTime;\r\n\r\n    // In case the oracles fail to submit the results or reach consensus, the amount of time after\r\n    // the tournament has started after which to return entry fees to users.\r\n    uint public noContestTime;\r\n\r\n    // Timestamp of the end of the scoring phase\r\n    uint public contestOverTime;\r\n\r\n    // Byte bracket representation of the tournament results\r\n    bytes8 public results;\r\n\r\n    // The highest score of a bracket scored so far\r\n    uint8 public winningScore;\r\n\r\n    // The maximum allowed number of submissions\r\n    uint32 public maxSubmissions;\r\n\r\n    // The number of brackets submitted so far\r\n    uint32 public numSubmissions;\r\n\r\n    // IPFS hash of JSON file containing tournament information (eg. teams, regions, etc)\r\n    string public tournamentDataIPFSHash;\r\n\r\n\tfunction MarchMadness(\r\n        uint entryFee_,\r\n        uint tournamentStartTime_,\r\n        uint noContestTime_,\r\n        uint scoringDuration_,\r\n        uint32 maxSubmissions_,\r\n        string tournamentDataIPFSHash_,\r\n        address oracleAddress\r\n    ) {\r\n\t\tentryFee = entryFee_;\r\n        tournamentStartTime = tournamentStartTime_;\r\n        scoringDuration = scoringDuration_;\r\n        noContestTime = noContestTime_;\r\n        maxSubmissions = maxSubmissions_;\r\n        tournamentDataIPFSHash = tournamentDataIPFSHash_;\r\n        resultsOracle = FederatedOracleBytes8(oracleAddress);\r\n\t}\r\n\r\n    function submitBracket(bytes32 commitment) payable {\r\n        if (msg.value != entryFee) {\r\n            throw;\r\n        }\r\n        if (now >= tournamentStartTime) {\r\n            throw;\r\n        }\r\n        if (numSubmissions >= maxSubmissions) {\r\n            throw;\r\n        }\r\n\r\n        var submission = submissions[msg.sender];\r\n        if (submission.commitment != 0) {\r\n            throw;\r\n        }\r\n\r\n        submission.commitment = commitment;\r\n        numSubmissions++;\r\n        SubmissionAccepted(msg.sender);\r\n    }\r\n\r\n    function startScoring() returns (bool) {\r\n        if (results != 0) {\r\n            return false;\r\n        }\r\n        if (now < tournamentStartTime) {\r\n            return false;\r\n        }\r\n        if (now > noContestTime) {\r\n            return false;\r\n        }\r\n\r\n        bytes8 oracleValue = resultsOracle.finalValue();\r\n        if (oracleValue == 0) {\r\n            return false;\r\n        }\r\n\r\n        results = oracleValue;\r\n        scoringMask = ByteBracket.getScoringMask(results);\r\n        contestOverTime = now + scoringDuration;\r\n        TournamentOver();\r\n        return true;\r\n    }\r\n\r\n    function revealBracket(bytes8 bracket, bytes16 salt) returns (bool) {\r\n        var submission = submissions[msg.sender];\r\n        if (sha3(msg.sender, bracket, salt) != submission.commitment) {\r\n            return false;\r\n        }\r\n\r\n        submission.bracket = bracket;\r\n        return true;\r\n    }\r\n\r\n    function scoreBracket(address account) returns (bool) {\r\n        if (results == 0) {\r\n            return false;\r\n        }\r\n        if (now >= contestOverTime) {\r\n            return false;\r\n        }\r\n\r\n        var submission = submissions[account];\r\n        if (submission.bracket == 0) {\r\n            return false;\r\n        }\r\n        if (submission.score != 0) {\r\n            return false;\r\n        }\r\n\r\n        submission.score = ByteBracket.getBracketScore(submission.bracket, results, scoringMask);\r\n\r\n        if (submission.score > winningScore) {\r\n            winningScore = submission.score;\r\n            numWinners = 0;\r\n        }\r\n        if (submission.score == winningScore) {\r\n            numWinners++;\r\n            winnings = this.balance / numWinners;\r\n            NewWinner(account, submission.score);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function collectWinnings() returns (bool) {\r\n        if (now < contestOverTime) {\r\n            return false;\r\n        }\r\n\r\n        var submission = submissions[msg.sender];\r\n        if (submission.score != winningScore) {\r\n            return false;\r\n        }\r\n        if (submission.collectedWinnings) {\r\n            return false;\r\n        }\r\n\r\n        submission.collectedWinnings = true;\r\n\r\n        if (!msg.sender.send(winnings)) {\r\n            throw;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function collectEntryFee() returns (bool) {\r\n        if (now < noContestTime) {\r\n            return false;\r\n        }\r\n        if (results != 0) {\r\n            return false;\r\n        }\r\n\r\n        var submission = submissions[msg.sender];\r\n        if (submission.commitment == 0) {\r\n            return false;\r\n        }\r\n        if (submission.collectedEntryFee) {\r\n            return false;\r\n        }\r\n\r\n        submission.collectedEntryFee = true;\r\n\r\n        if (!msg.sender.send(entryFee)) {\r\n            throw;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function getBracketScore(bytes8 bracket) constant returns (uint8) {\r\n        if (results == 0) {\r\n            throw;\r\n        }\r\n        return ByteBracket.getBracketScore(bracket, results, scoringMask);\r\n    }\r\n\r\n    function getBracket(address account) constant returns (bytes8) {\r\n        return submissions[account].bracket;\r\n    }\r\n\r\n    function getScore(address account) constant returns (uint8) {\r\n        return submissions[account].score;\r\n    }\r\n\r\n    function getCommitment(address account) constant returns (bytes32) {\r\n        return submissions[account].commitment;\r\n    }\r\n\r\n    function hasCollectedWinnings(address account) constant returns (bool) {\r\n        return submissions[account].collectedWinnings;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"entryFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startScoring\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSubmissions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"commitment\",\"type\":\"bytes32\"}],\"name\":\"submitBracket\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winningScore\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tournamentDataIPFSHash\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tournamentStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bracket\",\"type\":\"bytes8\"},{\"name\":\"salt\",\"type\":\"bytes16\"}],\"name\":\"revealBracket\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collectWinnings\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBracket\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"scoreBracket\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numSubmissions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collectEntryFee\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numWinners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contestOverTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bracket\",\"type\":\"bytes8\"}],\"name\":\"getBracketScore\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"results\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winnings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"scoringDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getScore\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"noContestTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasCollectedWinnings\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getCommitment\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"entryFee_\",\"type\":\"uint256\"},{\"name\":\"tournamentStartTime_\",\"type\":\"uint256\"},{\"name\":\"noContestTime_\",\"type\":\"uint256\"},{\"name\":\"scoringDuration_\",\"type\":\"uint256\"},{\"name\":\"maxSubmissions_\",\"type\":\"uint32\"},{\"name\":\"tournamentDataIPFSHash_\",\"type\":\"string\"},{\"name\":\"oracleAddress\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"SubmissionAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"score\",\"type\":\"uint8\"}],\"name\":\"NewWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TournamentOver\",\"type\":\"event\"}]","ContractName":"MarchMadness","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000003782dace9d900000000000000000000000000000000000000000000000000000000000058cab6800000000000000000000000000000000000000000000000000000000058eacb00000000000000000000000000000000000000000000000000000000000003f480000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000bdf12a64b482d292f6a45eb8db1809abcd1bb8d1000000000000000000000000000000000000000000000000000000000000002e516d5a384b6e716f745672576741746a6b7a48396d35514e6f6e58797876514e69686b7a4c3552677167346a5942000000000000000000000000000000000000","Library":"ByteBracket:5b86ae7b8db6fa4daf7d47ee9dcd56b7b5608b0e","SwarmSource":"bzzr://9a9e9b28126c9ad3b2e8956023231d46becfe97202dc0614c4084479dfeb14a5"}]}