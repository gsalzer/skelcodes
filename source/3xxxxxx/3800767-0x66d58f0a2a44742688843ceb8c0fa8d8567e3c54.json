{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n// SafeMath handles math with overflow.\r\ncontract SafeMath {\r\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\r\n        uint256 z = x + y;\r\n        assert((z >= x) && (z >= y));\r\n        return z;\r\n    }\r\n\r\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\r\n        assert(x >= y);\r\n        uint256 z = x - y;\r\n        return z;\r\n    }\r\n\r\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\r\n        uint256 z = x * y;\r\n        assert((x == 0)||(z/x == y));\r\n        return z;\r\n    }\r\n}\r\n\r\n// Random is a block hash based random number generator.\r\ncontract Random {\r\n    // Generates a random number from 0 to max based on the last block hash.\r\n    function getRand(uint blockNumber, uint max) constant internal returns(uint) {\r\n        return(uint(sha3(block.blockhash(blockNumber))) % max);\r\n    }\r\n}\r\n\r\n// Manages contract ownership.\r\ncontract Owned {\r\n    address public owner;\r\n    function owned() {\r\n        owner = msg.sender;\r\n    }\r\n    modifier onlyOwner {\r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n// DoubleOrNothing is the main public interface for gambling.\r\n// To gamble:\r\n//   Step 1: Send up to maxWagerEth ETH to this contract address.\r\n//   Step 2: Wait waitTimeBlocks.\r\n//   Step 3: Call payout() to receive your payment, if any.\r\ncontract DoubleOrNothing {\r\n    // maxWagerWei is the maximum wager in Wei.\r\n    uint256 public maxWagerWei;\r\n    \r\n    // waitTime is the number of blocks before payout is available.\r\n    uint public waitTimeBlocks;\r\n    \r\n    // payoutOdds is the value / 10000 that a payee will win a wager.\r\n    // eg. payoutOdds of 4950 implies a 49.5% chance of winning.\r\n    uint public payoutOdds;\r\n    \r\n    // Wager represents one wager.\r\n    struct Wager {\r\n        address sender;\r\n        uint256 wagerWei;\r\n        uint256 creationBlockNumber;\r\n        bool active;\r\n    }\r\n    \r\n    // wagers contains all current outstanding wagers.\r\n    // TODO: Support multiple Wagers per address.\r\n    mapping (address => Wager) wagers;\r\n    \r\n    function makeWager() payable public;\r\n    function payout() public;\r\n}\r\n\r\ncontract DoubleOrNothingImpl is DoubleOrNothing, Owned, Random, SafeMath {\r\n    \r\n    // Initialize state by assigning the owner to the contract deployer.\r\n    function DoubleOrNothingImpl() {\r\n        owner = msg.sender;\r\n        maxWagerWei = 100000000000000000;\r\n        waitTimeBlocks = 2;\r\n        payoutOdds = 4950;\r\n    }\r\n    \r\n    // Allow the owner to set maxWagerWei.\r\n    function setMaxWagerWei(uint256 maxWager) public onlyOwner {\r\n        maxWagerWei = maxWager;\r\n    }\r\n    \r\n    // Allow the owner to set waitTimeBlocks.\r\n    function setWaitTimeBlocks(uint waitTime) public onlyOwner {\r\n        waitTimeBlocks = waitTime;\r\n    }\r\n    \r\n    // Allow the owner to set payoutOdds.\r\n    function setPayoutOdds(uint odds) public onlyOwner {\r\n        payoutOdds = odds;\r\n    }\r\n    \r\n    // Allow the owner to cash out the holdings of this contract.\r\n    function withdraw(address recipient, uint256 balance) public onlyOwner {\r\n        recipient.transfer(balance);\r\n    }\r\n    \r\n    // Allow the owner to payout outstanding wagers on others' behalf.\r\n    function ownerPayout(address wager_owner) public onlyOwner {\r\n        _payout(wager_owner);\r\n    }\r\n    \r\n    // Assume that simple transactions are trying to make a wager, unless it is\r\n    // from the owner.\r\n    function () payable public {\r\n        if (msg.sender != owner) {\r\n            makeWager();\r\n        }\r\n    }\r\n    \r\n    // Make a wager.\r\n    function makeWager() payable public {\r\n        if (msg.value == 0 || msg.value > maxWagerWei) throw;\r\n        if (wagers[msg.sender].active) {\r\n            // A Wager already exists for this user.\r\n            throw;\r\n        }\r\n        wagers[msg.sender] = Wager({\r\n            sender: msg.sender,\r\n            wagerWei: msg.value,\r\n            creationBlockNumber: block.number,\r\n            active: true,\r\n        });\r\n    }\r\n    \r\n    // View your wager.\r\n    function getMyWager() constant public returns (\r\n        uint256 wagerWei,\r\n        uint creationBlockNumber,\r\n        bool active) {\r\n        return getWager(msg.sender);\r\n    }\r\n    \r\n    // View the wager for a given address.\r\n    function getWager(address wager_owner) constant public returns (\r\n        uint256 wagerWei,\r\n        uint creationBlockNumber,\r\n        bool active) {\r\n        Wager thisWager = wagers[wager_owner];\r\n        return (thisWager.wagerWei, thisWager.creationBlockNumber, thisWager.active);\r\n    }\r\n    \r\n    // Payout any wagers associated with the sending address.\r\n    function payout() public {\r\n        _payout(msg.sender);\r\n    }\r\n    \r\n    // Internal implementation of payout().\r\n    function _payout(address wager_owner) internal {\r\n        if (!wagers[wager_owner].active) {\r\n            // No outstanding active Wager.\r\n            throw;\r\n        }\r\n        uint256 blockDepth = block.number - wagers[wager_owner].creationBlockNumber;\r\n        if (blockDepth > waitTimeBlocks) {\r\n            // waitTimeBlocks has passed, resolve and payout this wager.\r\n            uint256 payoutBlock = wagers[wager_owner].creationBlockNumber + waitTimeBlocks - 1;\r\n            uint randNum = getRand(payoutBlock, 10000);\r\n            if (randNum < payoutOdds) {\r\n                // Wager wins, payout wager.\r\n                uint256 winnings = safeMult(wagers[wager_owner].wagerWei, 2);\r\n                if (wagers[wager_owner].sender.send(winnings)) {\r\n                    wagers[wager_owner].active = false;\r\n                }\r\n            } else {\r\n                // Wager loses, disable wager.\r\n                wagers[wager_owner].active = false;\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"maxWager\",\"type\":\"uint256\"}],\"name\":\"setMaxWagerWei\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wager_owner\",\"type\":\"address\"}],\"name\":\"ownerPayout\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxWagerWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"odds\",\"type\":\"uint256\"}],\"name\":\"setPayoutOdds\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"waitTimeBlocks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wager_owner\",\"type\":\"address\"}],\"name\":\"getWager\",\"outputs\":[{\"name\":\"wagerWei\",\"type\":\"uint256\"},{\"name\":\"creationBlockNumber\",\"type\":\"uint256\"},{\"name\":\"active\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMyWager\",\"outputs\":[{\"name\":\"wagerWei\",\"type\":\"uint256\"},{\"name\":\"creationBlockNumber\",\"type\":\"uint256\"},{\"name\":\"active\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"makeWager\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"waitTime\",\"type\":\"uint256\"}],\"name\":\"setWaitTimeBlocks\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutOdds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"owned\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"}]","ContractName":"DoubleOrNothingImpl","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://56764ca7a136db4c98e824729d111f6dde7cad6fe347513a23e2a10962efb90b"}]}