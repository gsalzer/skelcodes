{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.4;\r\n\r\ncontract Sale {\r\n    uint public startTime;\r\n    uint public stopTime;\r\n    uint public target;\r\n    uint public raised;\r\n    uint public collected;\r\n    uint public numContributors;\r\n    mapping(address => uint) public balances;\r\n\r\n    function buyTokens(address _a, uint _eth, uint _time) returns (uint); \r\n    function getTokens(address holder) constant returns (uint); \r\n    function getRefund(address holder) constant returns (uint); \r\n    function getSoldTokens() constant returns (uint); \r\n    function getOwnerEth() constant returns (uint); \r\n    function tokensPerEth() constant returns (uint);\r\n    function isActive(uint time) constant returns (bool); \r\n    function isComplete(uint time) constant returns (bool); \r\n}\r\n\r\ncontract Constants {\r\n    uint DECIMALS = 8;\r\n}\r\n\r\ncontract EventDefinitions {\r\n    event logSaleStart(uint startTime, uint stopTime);\r\n    event logPurchase(address indexed purchaser, uint eth);\r\n    event logClaim(address indexed purchaser, uint refund, uint tokens);\r\n\r\n    //Token standard events\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n} \r\n\r\ncontract Testable {\r\n    uint fakeTime;\r\n    bool public testing;\r\n    modifier onlyTesting() {\r\n        if (!testing) throw;\r\n        _;\r\n    }\r\n    function setFakeTime(uint t) onlyTesting {\r\n        fakeTime = t;\r\n    }\r\n    function addMinutes(uint m) onlyTesting {\r\n        fakeTime = fakeTime + (m * 1 minutes);\r\n    }\r\n    function addDays(uint d) onlyTesting {\r\n        fakeTime = fakeTime + (d * 1 days);\r\n    }\r\n    function currTime() constant returns (uint) {\r\n        if (testing) {\r\n            return fakeTime;\r\n        } else {\r\n            return block.timestamp;\r\n        }\r\n    }\r\n    function weiPerEth() constant returns (uint) {\r\n        if (testing) {\r\n            return 200;\r\n        } else {\r\n            return 10**18;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    \r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n\r\n    address newOwner;\r\n\r\n    function changeOwner(address _newOwner) onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n        }\r\n    }    \r\n}\r\n\r\n//from Zeppelin\r\ncontract SafeMath {\r\n    function safeMul(uint a, uint b) internal returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n\r\n    function assert(bool assertion) internal {\r\n        if (!assertion) throw;\r\n    }\r\n}\r\n\r\ncontract Token is SafeMath, Owned, Constants {\r\n    uint public totalSupply;\r\n\r\n    address ico;\r\n    address controller;\r\n\r\n    string public name;\r\n    uint8 public decimals; \r\n    string public symbol;     \r\n\r\n    modifier onlyControllers() {\r\n        if (msg.sender != ico &&\r\n            msg.sender != controller) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyPayloadSize(uint numwords) {\r\n        assert(msg.data.length == numwords * 32 + 4);\r\n        _;\r\n    } \r\n\r\n    function Token() { \r\n        owner = msg.sender;\r\n        name = \"Monolith TKN\";\r\n        decimals = uint8(DECIMALS);\r\n        symbol = \"TKN\";\r\n    }\r\n\r\n    function setICO(address _ico) onlyOwner {\r\n        if (ico != 0) throw;\r\n        ico = _ico;\r\n    }\r\n    function setController(address _controller) onlyOwner {\r\n        if (controller != 0) throw;\r\n        controller = _controller;\r\n    }\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Mint(address owner, uint amount);\r\n\r\n    //only called from contracts so don't need msg.data.length check\r\n    function mint(address addr, uint amount) onlyControllers {\r\n        if (maxSupply > 0 && safeAdd(totalSupply, amount) > maxSupply) throw;\r\n        balanceOf[addr] = safeAdd(balanceOf[addr], amount);\r\n        totalSupply = safeAdd(totalSupply, amount);\r\n        Mint(addr, amount);\r\n    }\r\n\r\n    mapping(address => uint) public balanceOf;\r\n    mapping (address => mapping (address => uint)) public allowance;\r\n\r\n    function transfer(address _to, uint _value) \r\n    onlyPayloadSize(2)\r\n    returns (bool success) {\r\n        if (balanceOf[msg.sender] < _value) return false;\r\n\r\n        balanceOf[msg.sender] = balanceOf[msg.sender] - _value;\r\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) \r\n    onlyPayloadSize(3)\r\n    returns (bool success) {\r\n        if (balanceOf[_from] < _value) return false; \r\n\r\n        var allowed = allowance[_from][msg.sender];\r\n        if (allowed < _value) return false;\r\n\r\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\r\n        balanceOf[_from] = safeSub(balanceOf[_from], _value);\r\n        allowance[_from][msg.sender] = safeSub(allowed, _value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint _value) \r\n    onlyPayloadSize(2)\r\n    returns (bool success) {\r\n        //require user to set to zero before resetting to nonzero\r\n        if ((_value != 0) && (allowance[msg.sender][_spender] != 0)) {\r\n            return false;\r\n        }\r\n    \r\n        allowance[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval (address _spender, uint _addedValue) \r\n    onlyPayloadSize(2)\r\n    returns (bool success) {\r\n        uint oldValue = allowance[msg.sender][_spender];\r\n        allowance[msg.sender][_spender] = safeAdd(oldValue, _addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval (address _spender, uint _subtractedValue) \r\n    onlyPayloadSize(2)\r\n    returns (bool success) {\r\n        uint oldValue = allowance[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowance[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowance[msg.sender][_spender] = safeSub(oldValue, _subtractedValue);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    //Holds accumulated dividend tokens other than TKN\r\n    TokenHolder tokenholder;\r\n\r\n    //once locked, can no longer upgrade tokenholder\r\n    bool lockedTokenHolder;\r\n\r\n    function lockTokenHolder() onlyOwner {\r\n        lockedTokenHolder = true;\r\n    }\r\n\r\n    //while unlocked, \r\n    //this gives owner lots of power over held dividend tokens\r\n    //effectively can deny access to all accumulated tokens\r\n    //thus crashing TKN value\r\n    function setTokenHolder(address _th) onlyOwner {\r\n        if (lockedTokenHolder) throw;\r\n        tokenholder = TokenHolder(_th);\r\n    }\r\n\r\n    event Burn(address burner, uint amount);\r\n\r\n    function burn(uint _amount) returns (bool result) {\r\n        if (_amount > balanceOf[msg.sender]) return false;\r\n        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _amount);\r\n        totalSupply = safeSub(totalSupply, _amount);\r\n        result = tokenholder.burn(msg.sender, _amount);\r\n        if (!result) throw;\r\n        Burn(msg.sender, _amount);\r\n    }\r\n\r\n    uint public maxSupply;\r\n\r\n    function setMaxSupply(uint _maxSupply) {\r\n        if (msg.sender != controller) throw;\r\n        if (maxSupply > 0) throw;\r\n        maxSupply = _maxSupply;\r\n    }\r\n}\r\n\r\ncontract TokenHolder {\r\n    function burn(address _burner, uint _amount)\r\n    returns (bool result) { \r\n        return false;\r\n    }\r\n}\r\n\r\n\r\ncontract ICO is EventDefinitions, Testable, SafeMath, Owned {\r\n    Token public token;\r\n    address public controller;\r\n    address public payee;\r\n\r\n    Sale[] public sales;\r\n    \r\n    //salenum => minimum wei\r\n    mapping (uint => uint) saleMinimumPurchases;\r\n\r\n    //next sale number user can claim from\r\n    mapping (address => uint) public nextClaim;\r\n\r\n    //net contributed ETH by each user (in case of stop/refund)\r\n    mapping (address => uint) refundInStop;\r\n\r\n    modifier tokenIsSet() {\r\n        if (address(token) == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyController() {\r\n        if (msg.sender != address(controller)) throw;\r\n        _;\r\n    }\r\n\r\n    function ICO() { \r\n        owner = msg.sender;\r\n        payee = msg.sender;\r\n        allStopper = msg.sender;\r\n    }\r\n\r\n    //payee can only be changed once\r\n    //intent is to lock payee to a contract that holds or distributes funds\r\n    //in deployment, be sure to do this before changing owner!\r\n    //we initialize to owner to keep things simple if there's no payee contract\r\n    function changePayee(address newPayee) \r\n    onlyOwner notAllStopped {\r\n        payee = newPayee;\r\n    }\r\n\r\n    function setToken(address _token) onlyOwner {\r\n        if (address(token) != 0x0) throw;\r\n        token = Token(_token);\r\n    }\r\n\r\n    //before adding sales, we can set this to be a test ico\r\n    //this lets us manipulate time and drastically lowers weiPerEth\r\n    function setAsTest() onlyOwner {\r\n        if (sales.length == 0) {\r\n            testing = true;\r\n        }\r\n    }\r\n\r\n    function setController(address _controller) \r\n    onlyOwner notAllStopped {\r\n        if (address(controller) != 0x0) throw;\r\n        controller = _controller; //ICOController(_controller);\r\n    }\r\n\r\n    //********************************************************\r\n    //Sales\r\n    //********************************************************\r\n\r\n    function addSale(address sale, uint minimumPurchase) \r\n    onlyController notAllStopped {\r\n        uint salenum = sales.length;\r\n        sales.push(Sale(sale));\r\n        saleMinimumPurchases[salenum] = minimumPurchase;\r\n        logSaleStart(Sale(sale).startTime(), Sale(sale).stopTime());\r\n    }\r\n\r\n    function addSale(address sale) onlyController {\r\n        addSale(sale, 0);\r\n    }\r\n\r\n    function getCurrSale() constant returns (uint) {\r\n        if (sales.length == 0) throw; //no reason to call before startFirstSale\r\n        return sales.length - 1;\r\n    }\r\n\r\n    function currSaleActive() constant returns (bool) {\r\n        return sales[getCurrSale()].isActive(currTime());\r\n    }\r\n\r\n    function currSaleComplete() constant returns (bool) {\r\n        return sales[getCurrSale()].isComplete(currTime());\r\n    }\r\n\r\n    function numSales() constant returns (uint) {\r\n        return sales.length;\r\n    }\r\n\r\n    function numContributors(uint salenum) constant returns (uint) {\r\n        return sales[salenum].numContributors();\r\n    }\r\n\r\n    //********************************************************\r\n    //ETH Purchases\r\n    //********************************************************\r\n\r\n    event logPurchase(address indexed purchaser, uint value);\r\n\r\n    function () payable {\r\n        deposit();\r\n    }\r\n\r\n    function deposit() payable notAllStopped {\r\n        doDeposit(msg.sender, msg.value);\r\n\r\n        //not in doDeposit because only for Eth:\r\n        uint contrib = refundInStop[msg.sender];\r\n        refundInStop[msg.sender] = contrib + msg.value;\r\n\r\n        logPurchase(msg.sender, msg.value);\r\n    }\r\n\r\n    //is also called by token contributions\r\n    function doDeposit(address _for, uint _value) private {\r\n        uint currSale = getCurrSale();\r\n        if (!currSaleActive()) throw;\r\n        if (_value < saleMinimumPurchases[currSale]) throw;\r\n\r\n        uint tokensToMintNow = sales[currSale].buyTokens(_for, _value, currTime());\r\n\r\n        if (tokensToMintNow > 0) {\r\n            token.mint(_for, tokensToMintNow);\r\n        }\r\n    }\r\n\r\n    //********************************************************\r\n    //Token Purchases\r\n    //********************************************************\r\n\r\n    //Support for purchase via other tokens\r\n    //We don't attempt to deal with those tokens directly\r\n    //We just give admin ability to tell us what deposit to credit\r\n    //We only allow for first sale \r\n    //because first sale normally has no refunds\r\n    //As written, the refund would be in ETH\r\n\r\n    event logPurchaseViaToken(\r\n                        address indexed purchaser, address indexed token, \r\n                        uint depositedTokens, uint ethValue, \r\n                        bytes32 _reference);\r\n\r\n    event logPurchaseViaFiat(\r\n                        address indexed purchaser, uint ethValue, \r\n                        bytes32 _reference);\r\n\r\n    mapping (bytes32 => bool) public mintRefs;\r\n    mapping (address => uint) public raisedFromToken;\r\n    uint public raisedFromFiat;\r\n\r\n    function depositFiat(address _for, uint _ethValue, bytes32 _reference) \r\n    notAllStopped onlyOwner {\r\n        if (getCurrSale() > 0) throw; //only first sale allows this\r\n        if (mintRefs[_reference]) throw; //already minted for this reference\r\n        mintRefs[_reference] = true;\r\n        raisedFromFiat = safeAdd(raisedFromFiat, _ethValue);\r\n\r\n        doDeposit(_for, _ethValue);\r\n        logPurchaseViaFiat(_for, _ethValue, _reference);\r\n    }\r\n\r\n    function depositTokens(address _for, address _token, \r\n                           uint _ethValue, uint _depositedTokens, \r\n                           bytes32 _reference) \r\n    notAllStopped onlyOwner {\r\n        if (getCurrSale() > 0) throw; //only first sale allows this\r\n        if (mintRefs[_reference]) throw; //already minted for this reference\r\n        mintRefs[_reference] = true;\r\n        raisedFromToken[_token] = safeAdd(raisedFromToken[_token], _ethValue);\r\n\r\n        //tokens do not count toward price changes and limits\r\n        //we have to look up pricing, and do our own mint()\r\n        uint tokensPerEth = sales[0].tokensPerEth();\r\n        uint tkn = safeMul(_ethValue, tokensPerEth) / weiPerEth();\r\n        token.mint(_for, tkn);\r\n        \r\n        logPurchaseViaToken(_for, _token, _depositedTokens, _ethValue, _reference);\r\n    }\r\n\r\n    //********************************************************\r\n    //Roundoff Protection\r\n    //********************************************************\r\n    //protect against roundoff in payouts\r\n    //this prevents last person getting refund from not being able to collect\r\n    function safebalance(uint bal) private returns (uint) {\r\n        if (bal > this.balance) {\r\n            return this.balance;\r\n        } else {\r\n            return bal;\r\n        }\r\n    }\r\n\r\n    //It'd be nicer if last person got full amount\r\n    //instead of getting shorted by safebalance()\r\n    //topUp() allows admin to deposit excess ether to cover it\r\n    //and later get back any left over \r\n\r\n    uint public topUpAmount;\r\n\r\n    function topUp() payable onlyOwner notAllStopped {\r\n        topUpAmount = safeAdd(topUpAmount, msg.value);\r\n    }\r\n\r\n    function withdrawTopUp() onlyOwner notAllStopped {\r\n        uint amount = topUpAmount;\r\n        topUpAmount = 0;\r\n        if (!msg.sender.call.value(safebalance(amount))()) throw;\r\n    }\r\n\r\n    //********************************************************\r\n    //Claims\r\n    //********************************************************\r\n\r\n    //Claim whatever you're owed, \r\n    //from whatever completed sales you haven't already claimed\r\n    //this covers refunds, and any tokens not minted immediately\r\n    //(i.e. auction tokens, not firstsale tokens)\r\n    function claim() notAllStopped {\r\n        var (tokens, refund, nc) = claimable(msg.sender, true);\r\n        nextClaim[msg.sender] = nc;\r\n        logClaim(msg.sender, refund, tokens);\r\n        if (tokens > 0) {\r\n            token.mint(msg.sender, tokens);\r\n        }\r\n        if (refund > 0) {\r\n            refundInStop[msg.sender] = safeSub(refundInStop[msg.sender], refund);\r\n            if (!msg.sender.send(safebalance(refund))) throw;\r\n        }\r\n    }\r\n\r\n    //Allow admin to claim on behalf of user and send to any address.\r\n    //Scenarios:\r\n    //  user lost key\r\n    //  user sent from an exchange\r\n    //  user has expensive fallback function\r\n    //  user is unknown, funds presumed abandoned\r\n    //We only allow this after one year has passed.\r\n    function claimFor(address _from, address _to) \r\n    onlyOwner notAllStopped {\r\n        var (tokens, refund, nc) = claimable(_from, false);\r\n        nextClaim[_from] = nc;\r\n\r\n        logClaim(_from, refund, tokens);\r\n\r\n        if (tokens > 0) {\r\n            token.mint(_to, tokens);\r\n        }\r\n        if (refund > 0) {\r\n            refundInStop[_from] = safeSub(refundInStop[_from], refund);\r\n            if (!_to.send(safebalance(refund))) throw;\r\n        }\r\n    }\r\n\r\n    function claimable(address _a, bool _includeRecent) \r\n    constant private tokenIsSet \r\n    returns (uint tokens, uint refund, uint nc) {\r\n        nc = nextClaim[_a];\r\n\r\n        while (nc < sales.length &&\r\n               sales[nc].isComplete(currTime()) &&\r\n               ( _includeRecent || \r\n                 sales[nc].stopTime() + 1 years < currTime() )) \r\n        {\r\n            refund = safeAdd(refund, sales[nc].getRefund(_a));\r\n            tokens = safeAdd(tokens, sales[nc].getTokens(_a));\r\n            nc += 1;\r\n        }\r\n    }\r\n\r\n    function claimableTokens(address a) constant returns (uint) {\r\n        var (tokens, refund, nc) = claimable(a, true);\r\n        return tokens;\r\n    }\r\n\r\n    function claimableRefund(address a) constant returns (uint) {\r\n        var (tokens, refund, nc) = claimable(a, true);\r\n        return refund;\r\n    }\r\n\r\n    function claimableTokens() constant returns (uint) {\r\n        return claimableTokens(msg.sender);\r\n    }\r\n\r\n    function claimableRefund() constant returns (uint) {\r\n        return claimableRefund(msg.sender);\r\n    }\r\n\r\n    //********************************************************\r\n    //Withdraw ETH\r\n    //********************************************************\r\n\r\n    mapping (uint => bool) ownerClaimed;\r\n\r\n    function claimableOwnerEth(uint salenum) constant returns (uint) {\r\n        uint time = currTime();\r\n        if (!sales[salenum].isComplete(time)) return 0;\r\n        return sales[salenum].getOwnerEth();\r\n    }\r\n\r\n    function claimOwnerEth(uint salenum) onlyOwner notAllStopped {\r\n        if (ownerClaimed[salenum]) throw;\r\n\r\n        uint ownereth = claimableOwnerEth(salenum);\r\n        if (ownereth > 0) {\r\n            ownerClaimed[salenum] = true;\r\n            if ( !payee.call.value(safebalance(ownereth))() ) throw;\r\n        }\r\n    }\r\n\r\n    //********************************************************\r\n    //Sweep tokens sent here\r\n    //********************************************************\r\n\r\n    //Support transfer of erc20 tokens out of this contract's address\r\n    //Even if we don't intend for people to send them here, somebody will\r\n\r\n    event logTokenTransfer(address token, address to, uint amount);\r\n\r\n    function transferTokens(address _token, address _to) onlyOwner {\r\n        Token token = Token(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(_to, balance);\r\n        logTokenTransfer(_token, _to, balance);\r\n    }\r\n\r\n    //********************************************************\r\n    //Emergency Stop\r\n    //********************************************************\r\n\r\n    bool allstopped;\r\n    bool permastopped;\r\n\r\n    //allow allStopper to be more secure address than owner\r\n    //in which case it doesn't make sense to let owner change it again\r\n    address allStopper;\r\n    function setAllStopper(address _a) onlyOwner {\r\n        if (allStopper != owner) return;\r\n        allStopper = _a;\r\n    }\r\n    modifier onlyAllStopper() {\r\n        if (msg.sender != allStopper) throw;\r\n        _;\r\n    }\r\n\r\n    event logAllStop();\r\n    event logAllStart();\r\n\r\n    modifier allStopped() {\r\n        if (!allstopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier notAllStopped() {\r\n        if (allstopped) throw;\r\n        _;\r\n    }\r\n\r\n    function allStop() onlyAllStopper {\r\n        allstopped = true;    \r\n        logAllStop();\r\n    }\r\n\r\n    function allStart() onlyAllStopper {\r\n        if (!permastopped) {\r\n            allstopped = false;\r\n            logAllStart();\r\n        }\r\n    }\r\n\r\n    function emergencyRefund(address _a, uint _amt) \r\n    allStopped \r\n    onlyAllStopper {\r\n        //if you start actually calling this refund, the disaster is real.\r\n        //Don't allow restart, so this can't be abused \r\n        permastopped = true;\r\n\r\n        uint amt = _amt;\r\n\r\n        uint ethbal = refundInStop[_a];\r\n\r\n        //convenient default so owner doesn't have to look up balances\r\n        //this is fine as long as no funds have been stolen\r\n        if (amt == 0) amt = ethbal; \r\n\r\n        //nobody can be refunded more than they contributed\r\n        if (amt > ethbal) amt = ethbal;\r\n\r\n        //since everything is halted, safer to call.value\r\n        //so we don't have to worry about expensive fallbacks\r\n        if ( !_a.call.value(safebalance(amt))() ) throw;\r\n    }\r\n\r\n    function raised() constant returns (uint) {\r\n        return sales[getCurrSale()].raised();\r\n    }\r\n\r\n    function tokensPerEth() constant returns (uint) {\r\n        return sales[getCurrSale()].tokensPerEth();\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"raisedFromToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_a\",\"type\":\"address\"}],\"name\":\"setAllStopper\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPayee\",\"type\":\"address\"}],\"name\":\"changePayee\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currSaleActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_for\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_ethValue\",\"type\":\"uint256\"},{\"name\":\"_depositedTokens\",\"type\":\"uint256\"},{\"name\":\"_reference\",\"type\":\"bytes32\"}],\"name\":\"depositTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allStart\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currSaleComplete\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sale\",\"type\":\"address\"}],\"name\":\"addSale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"salenum\",\"type\":\"uint256\"}],\"name\":\"claimableOwnerEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimableRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_a\",\"type\":\"address\"},{\"name\":\"_amt\",\"type\":\"uint256\"}],\"name\":\"emergencyRefund\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiPerEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"address\"}],\"name\":\"claimableRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"salenum\",\"type\":\"uint256\"}],\"name\":\"numContributors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"t\",\"type\":\"uint256\"}],\"name\":\"setFakeTime\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"address\"}],\"name\":\"claimableTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"testing\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"m\",\"type\":\"uint256\"}],\"name\":\"addMinutes\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setAsTest\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numSales\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"raisedFromFiat\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"salenum\",\"type\":\"uint256\"}],\"name\":\"claimOwnerEth\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTopUp\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payee\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"claimFor\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sales\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimableTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"mintRefs\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nextClaim\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"d\",\"type\":\"uint256\"}],\"name\":\"addDays\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"topUp\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"topUpAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allStop\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_for\",\"type\":\"address\"},{\"name\":\"_ethValue\",\"type\":\"uint256\"},{\"name\":\"_reference\",\"type\":\"bytes32\"}],\"name\":\"depositFiat\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sale\",\"type\":\"address\"},{\"name\":\"minimumPurchase\",\"type\":\"uint256\"}],\"name\":\"addSale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"raised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"logPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"depositedTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_reference\",\"type\":\"bytes32\"}],\"name\":\"logPurchaseViaToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_reference\",\"type\":\"bytes32\"}],\"name\":\"logPurchaseViaFiat\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"logTokenTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"logAllStop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"logAllStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stopTime\",\"type\":\"uint256\"}],\"name\":\"logSaleStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"refund\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"logClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ICO","CompilerVersion":"v0.4.10+commit.f0d539ae","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f0811d8f921c387af47f7a37b04616fc6ee77f8321d9bb1e4ac21f3b1c61db8e"}]}