{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\n\r\n/**\r\n* @title RLPReader\r\n*\r\n* RLPReader is used to read and parse RLP encoded data in memory.\r\n*\r\n* @author Andreas Olofsson (androlo1980@gmail.com)\r\n*/\r\nlibrary RLP {\r\n\r\n uint constant DATA_SHORT_START = 0x80;\r\n uint constant DATA_LONG_START = 0xB8;\r\n uint constant LIST_SHORT_START = 0xC0;\r\n uint constant LIST_LONG_START = 0xF8;\r\n\r\n uint constant DATA_LONG_OFFSET = 0xB7;\r\n uint constant LIST_LONG_OFFSET = 0xF7;\r\n\r\n\r\n struct RLPItem {\r\n     uint _unsafe_memPtr;    // Pointer to the RLP-encoded bytes.\r\n     uint _unsafe_length;    // Number of bytes. This is the full length of the string.\r\n }\r\n\r\n struct Iterator {\r\n     RLPItem _unsafe_item;   // Item that's being iterated over.\r\n     uint _unsafe_nextPtr;   // Position of the next item in the list.\r\n }\r\n\r\n /* Iterator */\r\n\r\n function next(Iterator memory self) internal constant returns (RLPItem memory subItem) {\r\n     if(hasNext(self)) {\r\n         var ptr = self._unsafe_nextPtr;\r\n         var itemLength = _itemLength(ptr);\r\n         subItem._unsafe_memPtr = ptr;\r\n         subItem._unsafe_length = itemLength;\r\n         self._unsafe_nextPtr = ptr + itemLength;\r\n     }\r\n     else\r\n         throw;\r\n }\r\n\r\n function next(Iterator memory self, bool strict) internal constant returns (RLPItem memory subItem) {\r\n     subItem = next(self);\r\n     if(strict && !_validate(subItem))\r\n         throw;\r\n     return;\r\n }\r\n\r\n function hasNext(Iterator memory self) internal constant returns (bool) {\r\n     var item = self._unsafe_item;\r\n     return self._unsafe_nextPtr < item._unsafe_memPtr + item._unsafe_length;\r\n }\r\n\r\n /* RLPItem */\r\n\r\n /// @dev Creates an RLPItem from an array of RLP encoded bytes.\r\n /// @param self The RLP encoded bytes.\r\n /// @return An RLPItem\r\n function toRLPItem(bytes memory self) internal constant returns (RLPItem memory) {\r\n     uint len = self.length;\r\n     if (len == 0) {\r\n         return RLPItem(0, 0);\r\n     }\r\n     uint memPtr;\r\n     assembly {\r\n         memPtr := add(self, 0x20)\r\n     }\r\n     return RLPItem(memPtr, len);\r\n }\r\n\r\n /// @dev Creates an RLPItem from an array of RLP encoded bytes.\r\n /// @param self The RLP encoded bytes.\r\n /// @param strict Will throw if the data is not RLP encoded.\r\n /// @return An RLPItem\r\n function toRLPItem(bytes memory self, bool strict) internal constant returns (RLPItem memory) {\r\n     var item = toRLPItem(self);\r\n     if(strict) {\r\n         uint len = self.length;\r\n         if(_payloadOffset(item) > len)\r\n             throw;\r\n         if(_itemLength(item._unsafe_memPtr) != len)\r\n             throw;\r\n         if(!_validate(item))\r\n             throw;\r\n     }\r\n     return item;\r\n }\r\n\r\n /// @dev Check if the RLP item is null.\r\n /// @param self The RLP item.\r\n /// @return 'true' if the item is null.\r\n function isNull(RLPItem memory self) internal constant returns (bool ret) {\r\n     return self._unsafe_length == 0;\r\n }\r\n\r\n /// @dev Check if the RLP item is a list.\r\n /// @param self The RLP item.\r\n /// @return 'true' if the item is a list.\r\n function isList(RLPItem memory self) internal constant returns (bool ret) {\r\n     if (self._unsafe_length == 0)\r\n         return false;\r\n     uint memPtr = self._unsafe_memPtr;\r\n     assembly {\r\n         ret := iszero(lt(byte(0, mload(memPtr)), 0xC0))\r\n     }\r\n }\r\n\r\n /// @dev Check if the RLP item is data.\r\n /// @param self The RLP item.\r\n /// @return 'true' if the item is data.\r\n function isData(RLPItem memory self) internal constant returns (bool ret) {\r\n     if (self._unsafe_length == 0)\r\n         return false;\r\n     uint memPtr = self._unsafe_memPtr;\r\n     assembly {\r\n         ret := lt(byte(0, mload(memPtr)), 0xC0)\r\n     }\r\n }\r\n\r\n /// @dev Check if the RLP item is empty (string or list).\r\n /// @param self The RLP item.\r\n /// @return 'true' if the item is null.\r\n function isEmpty(RLPItem memory self) internal constant returns (bool ret) {\r\n     if(isNull(self))\r\n         return false;\r\n     uint b0;\r\n     uint memPtr = self._unsafe_memPtr;\r\n     assembly {\r\n         b0 := byte(0, mload(memPtr))\r\n     }\r\n     return (b0 == DATA_SHORT_START || b0 == LIST_SHORT_START);\r\n }\r\n\r\n /// @dev Get the number of items in an RLP encoded list.\r\n /// @param self The RLP item.\r\n /// @return The number of items.\r\n function items(RLPItem memory self) internal constant returns (uint) {\r\n     if (!isList(self))\r\n         return 0;\r\n     uint b0;\r\n     uint memPtr = self._unsafe_memPtr;\r\n     assembly {\r\n         b0 := byte(0, mload(memPtr))\r\n     }\r\n     uint pos = memPtr + _payloadOffset(self);\r\n     uint last = memPtr + self._unsafe_length - 1;\r\n     uint itms;\r\n     while(pos <= last) {\r\n         pos += _itemLength(pos);\r\n         itms++;\r\n     }\r\n     return itms;\r\n }\r\n\r\n /// @dev Create an iterator.\r\n /// @param self The RLP item.\r\n /// @return An 'Iterator' over the item.\r\n function iterator(RLPItem memory self) internal constant returns (Iterator memory it) {\r\n     if (!isList(self))\r\n         throw;\r\n     uint ptr = self._unsafe_memPtr + _payloadOffset(self);\r\n     it._unsafe_item = self;\r\n     it._unsafe_nextPtr = ptr;\r\n }\r\n\r\n /// @dev Return the RLP encoded bytes.\r\n /// @param self The RLPItem.\r\n /// @return The bytes.\r\n function toBytes(RLPItem memory self) internal constant returns (bytes memory bts) {\r\n     var len = self._unsafe_length;\r\n     if (len == 0)\r\n         return;\r\n     bts = new bytes(len);\r\n     _copyToBytes(self._unsafe_memPtr, bts, len);\r\n }\r\n\r\n /// @dev Decode an RLPItem into bytes. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toData(RLPItem memory self) internal constant returns (bytes memory bts) {\r\n     if(!isData(self))\r\n         throw;\r\n     var (rStartPos, len) = _decode(self);\r\n     bts = new bytes(len);\r\n     _copyToBytes(rStartPos, bts, len);\r\n }\r\n\r\n /// @dev Get the list of sub-items from an RLP encoded list.\r\n /// Warning: This is inefficient, as it requires that the list is read twice.\r\n /// @param self The RLP item.\r\n /// @return Array of RLPItems.\r\n function toList(RLPItem memory self) internal constant returns (RLPItem[] memory list) {\r\n     if(!isList(self))\r\n         throw;\r\n     var numItems = items(self);\r\n     list = new RLPItem[](numItems);\r\n     var it = iterator(self);\r\n     uint idx;\r\n     while(hasNext(it)) {\r\n         list[idx] = next(it);\r\n         idx++;\r\n     }\r\n }\r\n\r\n /// @dev Decode an RLPItem into an ascii string. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toAscii(RLPItem memory self) internal constant returns (string memory str) {\r\n     if(!isData(self))\r\n         throw;\r\n     var (rStartPos, len) = _decode(self);\r\n     bytes memory bts = new bytes(len);\r\n     _copyToBytes(rStartPos, bts, len);\r\n     str = string(bts);\r\n }\r\n\r\n /// @dev Decode an RLPItem into a uint. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toUint(RLPItem memory self) internal constant returns (uint data) {\r\n     if(!isData(self))\r\n         throw;\r\n     var (rStartPos, len) = _decode(self);\r\n     if (len > 32 || len == 0)\r\n         throw;\r\n     assembly {\r\n         data := div(mload(rStartPos), exp(256, sub(32, len)))\r\n     }\r\n }\r\n\r\n /// @dev Decode an RLPItem into a boolean. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toBool(RLPItem memory self) internal constant returns (bool data) {\r\n     if(!isData(self))\r\n         throw;\r\n     var (rStartPos, len) = _decode(self);\r\n     if (len != 1)\r\n         throw;\r\n     uint temp;\r\n     assembly {\r\n         temp := byte(0, mload(rStartPos))\r\n     }\r\n     if (temp > 1)\r\n         throw;\r\n     return temp == 1 ? true : false;\r\n }\r\n\r\n /// @dev Decode an RLPItem into a byte. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toByte(RLPItem memory self) internal constant returns (byte data) {\r\n     if(!isData(self))\r\n         throw;\r\n     var (rStartPos, len) = _decode(self);\r\n     if (len != 1)\r\n         throw;\r\n     uint temp;\r\n     assembly {\r\n         temp := byte(0, mload(rStartPos))\r\n     }\r\n     return byte(temp);\r\n }\r\n\r\n /// @dev Decode an RLPItem into an int. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toInt(RLPItem memory self) internal constant returns (int data) {\r\n     return int(toUint(self));\r\n }\r\n\r\n /// @dev Decode an RLPItem into a bytes32. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toBytes32(RLPItem memory self) internal constant returns (bytes32 data) {\r\n     return bytes32(toUint(self));\r\n }\r\n\r\n /// @dev Decode an RLPItem into an address. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toAddress(RLPItem memory self) internal constant returns (address data) {\r\n     if(!isData(self))\r\n         throw;\r\n     var (rStartPos, len) = _decode(self);\r\n     if (len != 20)\r\n         throw;\r\n     assembly {\r\n         data := div(mload(rStartPos), exp(256, 12))\r\n     }\r\n }\r\n\r\n // Get the payload offset.\r\n function _payloadOffset(RLPItem memory self) private constant returns (uint) {\r\n     if(self._unsafe_length == 0)\r\n         return 0;\r\n     uint b0;\r\n     uint memPtr = self._unsafe_memPtr;\r\n     assembly {\r\n         b0 := byte(0, mload(memPtr))\r\n     }\r\n     if(b0 < DATA_SHORT_START)\r\n         return 0;\r\n     if(b0 < DATA_LONG_START || (b0 >= LIST_SHORT_START && b0 < LIST_LONG_START))\r\n         return 1;\r\n     if(b0 < LIST_SHORT_START)\r\n         return b0 - DATA_LONG_OFFSET + 1;\r\n     return b0 - LIST_LONG_OFFSET + 1;\r\n }\r\n\r\n // Get the full length of an RLP item.\r\n function _itemLength(uint memPtr) private constant returns (uint len) {\r\n     uint b0;\r\n     assembly {\r\n         b0 := byte(0, mload(memPtr))\r\n     }\r\n     if (b0 < DATA_SHORT_START)\r\n         len = 1;\r\n     else if (b0 < DATA_LONG_START)\r\n         len = b0 - DATA_SHORT_START + 1;\r\n     else if (b0 < LIST_SHORT_START) {\r\n         assembly {\r\n             let bLen := sub(b0, 0xB7) // bytes length (DATA_LONG_OFFSET)\r\n             let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\r\n             len := add(1, add(bLen, dLen)) // total length\r\n         }\r\n     }\r\n     else if (b0 < LIST_LONG_START)\r\n         len = b0 - LIST_SHORT_START + 1;\r\n     else {\r\n         assembly {\r\n             let bLen := sub(b0, 0xF7) // bytes length (LIST_LONG_OFFSET)\r\n             let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\r\n             len := add(1, add(bLen, dLen)) // total length\r\n         }\r\n     }\r\n }\r\n\r\n // Get start position and length of the data.\r\n function _decode(RLPItem memory self) private constant returns (uint memPtr, uint len) {\r\n     if(!isData(self))\r\n         throw;\r\n     uint b0;\r\n     uint start = self._unsafe_memPtr;\r\n     assembly {\r\n         b0 := byte(0, mload(start))\r\n     }\r\n     if (b0 < DATA_SHORT_START) {\r\n         memPtr = start;\r\n         len = 1;\r\n         return;\r\n     }\r\n     if (b0 < DATA_LONG_START) {\r\n         len = self._unsafe_length - 1;\r\n         memPtr = start + 1;\r\n     } else {\r\n         uint bLen;\r\n         assembly {\r\n             bLen := sub(b0, 0xB7) // DATA_LONG_OFFSET\r\n         }\r\n         len = self._unsafe_length - 1 - bLen;\r\n         memPtr = start + bLen + 1;\r\n     }\r\n     return;\r\n }\r\n\r\n // Assumes that enough memory has been allocated to store in target.\r\n function _copyToBytes(uint btsPtr, bytes memory tgt, uint btsLen) private constant {\r\n     // Exploiting the fact that 'tgt' was the last thing to be allocated,\r\n     // we can write entire words, and just overwrite any excess.\r\n     assembly {\r\n         {\r\n                 let i := 0 // Start at arr + 0x20\r\n                 let words := div(add(btsLen, 31), 32)\r\n                 let rOffset := btsPtr\r\n                 let wOffset := add(tgt, 0x20)\r\n             tag_loop:\r\n                 jumpi(end, eq(i, words))\r\n                 {\r\n                     let offset := mul(i, 0x20)\r\n                     mstore(add(wOffset, offset), mload(add(rOffset, offset)))\r\n                     i := add(i, 1)\r\n                 }\r\n                 jump(tag_loop)\r\n             end:\r\n                 mstore(add(tgt, add(0x20, mload(tgt))), 0)\r\n         }\r\n     }\r\n }\r\n\r\n     // Check that an RLP item is valid.\r\n     function _validate(RLPItem memory self) private constant returns (bool ret) {\r\n         // Check that RLP is well-formed.\r\n         uint b0;\r\n         uint b1;\r\n         uint memPtr = self._unsafe_memPtr;\r\n         assembly {\r\n             b0 := byte(0, mload(memPtr))\r\n             b1 := byte(1, mload(memPtr))\r\n         }\r\n         if(b0 == DATA_SHORT_START + 1 && b1 < DATA_SHORT_START)\r\n             return false;\r\n         return true;\r\n     }\r\n}\r\n\r\n\r\ncontract RLPReaderTest {\r\n\r\n    using RLP for RLP.RLPItem;\r\n    using RLP for RLP.Iterator;\r\n    using RLP for bytes;\r\n\r\n    function RLPReaderTest() {}\r\n\r\n    function testItemStrict(bytes rlp) constant returns (bool res) {\r\n        res = true;\r\n        rlp.toRLPItem(true);\r\n    }\r\n\r\n    function testFirst(bytes rlp) constant returns (uint memPtr, uint len, byte first) {\r\n        var item = rlp.toRLPItem();\r\n        memPtr = item._unsafe_memPtr;\r\n        len = item._unsafe_length;\r\n        uint b0;\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n        }\r\n        first = byte(b0);\r\n    }\r\n\r\n    function testIsList(bytes rlp) constant returns (bool ret) {\r\n        ret = rlp.toRLPItem().isList();\r\n    }\r\n\r\n    function testIsData(bytes rlp) constant returns (bool ret) {\r\n        ret = rlp.toRLPItem().isData();\r\n    }\r\n\r\n    function testIsNull(bytes rlp) constant returns (bool ret) {\r\n        ret = rlp.toRLPItem().isNull();\r\n    }\r\n\r\n    function testIsEmpty(bytes rlp) constant returns (bool ret) {\r\n        ret = rlp.toRLPItem().isEmpty();\r\n    }\r\n\r\n    function testItems(bytes rlp) constant returns (uint) {\r\n        return rlp.toRLPItem().items();\r\n    }\r\n\r\n    function testSubItem(bytes rlp, uint index) constant returns (uint memPtr, uint len, bool isList, uint[] list, uint listLen) {\r\n        var it = rlp.toRLPItem().iterator();\r\n        uint idx;\r\n        while(it.hasNext() && idx < index) {\r\n            it.next();\r\n            idx++;\r\n        }\r\n       var si = it.next();\r\n       return _testItem(si);\r\n    }\r\n\r\n    function testToData(bytes rlp) constant returns (bytes memory bts) {\r\n        bts = rlp.toRLPItem().toData();\r\n    }\r\n\r\n    function testToUint(bytes rlp) constant returns (uint) {\r\n        return rlp.toRLPItem().toUint();\r\n    }\r\n\r\n    function testToInt(bytes rlp) constant returns (int) {\r\n        return rlp.toRLPItem().toInt();\r\n    }\r\n\r\n    function testToBytes32(bytes rlp) constant returns (bytes32) {\r\n        return rlp.toRLPItem().toBytes32();\r\n    }\r\n\r\n    function testToAddress(bytes rlp) constant returns (address) {\r\n        return rlp.toRLPItem().toAddress();\r\n    }\r\n\r\n    function testToByte(bytes rlp) constant returns (byte) {\r\n        return rlp.toRLPItem().toByte();\r\n    }\r\n\r\n    function testToBool(bytes rlp) constant returns (bool) {\r\n        return rlp.toRLPItem().toBool();\r\n    }\r\n\r\n    function _testItem(RLP.RLPItem item) internal constant returns (uint memPtr, uint len, bool isList, uint[] memory list, uint listLen) {\r\n        memPtr = item._unsafe_memPtr;\r\n        len = item._unsafe_length;\r\n        isList = item.isList();\r\n\r\n        if (isList) {\r\n            uint i;\r\n            listLen = item.items();\r\n            list = new uint[](listLen);\r\n            var it = item.iterator();\r\n            while(it.hasNext() && i < listLen) {\r\n                var si = it.next();\r\n                uint ptr;\r\n                assembly {\r\n                    ptr := mload(si)\r\n                }\r\n                list[i] = ptr;\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function testItem(bytes rlp) constant returns (uint memPtr, uint len, bool isList, uint[] list, uint listLen) {\r\n        var item = rlp.toRLPItem();\r\n        return _testItem(item);\r\n    }\r\n    \r\n    function getItem(bytes rlp, uint itemIndex) constant returns(uint) {\r\n        var it = rlp.toRLPItem().iterator();        \r\n        uint idx;\r\n        while(it.hasNext() && idx < itemIndex) {\r\n            it.next();                    \r\n            idx++;\r\n        }\r\n\r\n        \r\n        return it.next().toUint();\r\n    }\r\n    \r\n}\r\n\r\n\r\n    \r\n\r\n\r\ncontract SHA3_512 {\r\n    function SHA3_512() {}\r\n\r\n    function keccak_f(uint[25] A) constant internal returns(uint[25]) {\r\n        uint[5] memory C;\r\n        uint[5] memory D;\r\n        uint x;\r\n        uint y;\r\n        //uint D_0; uint D_1; uint D_2; uint D_3; uint D_4;\r\n        uint[25] memory B;\r\n        \r\n        uint[24] memory RC= [\r\n                   uint(0x0000000000000001),\r\n                   0x0000000000008082,\r\n                   0x800000000000808A,\r\n                   0x8000000080008000,\r\n                   0x000000000000808B,\r\n                   0x0000000080000001,\r\n                   0x8000000080008081,\r\n                   0x8000000000008009,\r\n                   0x000000000000008A,\r\n                   0x0000000000000088,\r\n                   0x0000000080008009,\r\n                   0x000000008000000A,\r\n                   0x000000008000808B,\r\n                   0x800000000000008B,\r\n                   0x8000000000008089,\r\n                   0x8000000000008003,\r\n                   0x8000000000008002,\r\n                   0x8000000000000080,\r\n                   0x000000000000800A,\r\n                   0x800000008000000A,\r\n                   0x8000000080008081,\r\n                   0x8000000000008080,\r\n                   0x0000000080000001,\r\n                   0x8000000080008008 ];\r\n        \r\n        for( uint i = 0 ; i < 24 ; i++ ) {\r\n            /*\r\n            for( x = 0 ; x < 5 ; x++ ) {\r\n                C[x] = A[5*x]^A[5*x+1]^A[5*x+2]^A[5*x+3]^A[5*x+4];                \r\n            }*/\r\n                       \r\n            C[0]=A[0]^A[1]^A[2]^A[3]^A[4];\r\n            C[1]=A[5]^A[6]^A[7]^A[8]^A[9];\r\n            C[2]=A[10]^A[11]^A[12]^A[13]^A[14];\r\n            C[3]=A[15]^A[16]^A[17]^A[18]^A[19];\r\n            C[4]=A[20]^A[21]^A[22]^A[23]^A[24];\r\n\r\n            /*\r\n            for( x = 0 ; x < 5 ; x++ ) {\r\n                D[x] = C[(x+4)%5]^((C[(x+1)%5] * 2)&0xffffffffffffffff | (C[(x+1)%5]/(2**63)));\r\n            }*/\r\n                        \r\n            \r\n            D[0]=C[4] ^ ((C[1] * 2)&0xffffffffffffffff | (C[1] / (2 ** 63)));\r\n            D[1]=C[0] ^ ((C[2] * 2)&0xffffffffffffffff | (C[2] / (2 ** 63)));\r\n            D[2]=C[1] ^ ((C[3] * 2)&0xffffffffffffffff | (C[3] / (2 ** 63)));\r\n            D[3]=C[2] ^ ((C[4] * 2)&0xffffffffffffffff | (C[4] / (2 ** 63)));\r\n            D[4]=C[3] ^ ((C[0] * 2)&0xffffffffffffffff | (C[0] / (2 ** 63)));\r\n\r\n            /*\r\n            for( x = 0 ; x < 5 ; x++ ) {\r\n                for( y = 0 ; y < 5 ; y++ ) {\r\n                    A[5*x+y] = A[5*x+y] ^ D[x];\r\n                }            \r\n            }*/\r\n            \r\n\r\n            \r\n            A[0]=A[0] ^ D[0];\r\n            A[1]=A[1] ^ D[0];\r\n            A[2]=A[2] ^ D[0];\r\n            A[3]=A[3] ^ D[0];\r\n            A[4]=A[4] ^ D[0];\r\n            A[5]=A[5] ^ D[1];\r\n            A[6]=A[6] ^ D[1];\r\n            A[7]=A[7] ^ D[1];\r\n            A[8]=A[8] ^ D[1];\r\n            A[9]=A[9] ^ D[1];\r\n            A[10]=A[10] ^ D[2];\r\n            A[11]=A[11] ^ D[2];\r\n            A[12]=A[12] ^ D[2];\r\n            A[13]=A[13] ^ D[2];\r\n            A[14]=A[14] ^ D[2];\r\n            A[15]=A[15] ^ D[3];\r\n            A[16]=A[16] ^ D[3];\r\n            A[17]=A[17] ^ D[3];\r\n            A[18]=A[18] ^ D[3];\r\n            A[19]=A[19] ^ D[3];\r\n            A[20]=A[20] ^ D[4];\r\n            A[21]=A[21] ^ D[4];\r\n            A[22]=A[22] ^ D[4];\r\n            A[23]=A[23] ^ D[4];\r\n            A[24]=A[24] ^ D[4];\r\n\r\n            /*Rho and pi steps*/            \r\n            B[0]=A[0];\r\n            B[8]=((A[1] * (2 ** 36))&0xffffffffffffffff | (A[1] / (2 ** 28)));\r\n            B[11]=((A[2] * (2 ** 3))&0xffffffffffffffff | (A[2] / (2 ** 61)));\r\n            B[19]=((A[3] * (2 ** 41))&0xffffffffffffffff | (A[3] / (2 ** 23)));\r\n            B[22]=((A[4] * (2 ** 18))&0xffffffffffffffff | (A[4] / (2 ** 46)));\r\n            B[2]=((A[5] * (2 ** 1))&0xffffffffffffffff | (A[5] / (2 ** 63)));\r\n            B[5]=((A[6] * (2 ** 44))&0xffffffffffffffff | (A[6] / (2 ** 20)));\r\n            B[13]=((A[7] * (2 ** 10))&0xffffffffffffffff | (A[7] / (2 ** 54)));\r\n            B[16]=((A[8] * (2 ** 45))&0xffffffffffffffff | (A[8] / (2 ** 19)));\r\n            B[24]=((A[9] * (2 ** 2))&0xffffffffffffffff | (A[9] / (2 ** 62)));\r\n            B[4]=((A[10] * (2 ** 62))&0xffffffffffffffff | (A[10] / (2 ** 2)));\r\n            B[7]=((A[11] * (2 ** 6))&0xffffffffffffffff | (A[11] / (2 ** 58)));\r\n            B[10]=((A[12] * (2 ** 43))&0xffffffffffffffff | (A[12] / (2 ** 21)));\r\n            B[18]=((A[13] * (2 ** 15))&0xffffffffffffffff | (A[13] / (2 ** 49)));\r\n            B[21]=((A[14] * (2 ** 61))&0xffffffffffffffff | (A[14] / (2 ** 3)));\r\n            B[1]=((A[15] * (2 ** 28))&0xffffffffffffffff | (A[15] / (2 ** 36)));\r\n            B[9]=((A[16] * (2 ** 55))&0xffffffffffffffff | (A[16] / (2 ** 9)));\r\n            B[12]=((A[17] * (2 ** 25))&0xffffffffffffffff | (A[17] / (2 ** 39)));\r\n            B[15]=((A[18] * (2 ** 21))&0xffffffffffffffff | (A[18] / (2 ** 43)));\r\n            B[23]=((A[19] * (2 ** 56))&0xffffffffffffffff | (A[19] / (2 ** 8)));\r\n            B[3]=((A[20] * (2 ** 27))&0xffffffffffffffff | (A[20] / (2 ** 37)));\r\n            B[6]=((A[21] * (2 ** 20))&0xffffffffffffffff | (A[21] / (2 ** 44)));\r\n            B[14]=((A[22] * (2 ** 39))&0xffffffffffffffff | (A[22] / (2 ** 25)));\r\n            B[17]=((A[23] * (2 ** 8))&0xffffffffffffffff | (A[23] / (2 ** 56)));\r\n            B[20]=((A[24] * (2 ** 14))&0xffffffffffffffff | (A[24] / (2 ** 50)));\r\n\r\n            /*Xi state*/\r\n            /*\r\n            for( x = 0 ; x < 5 ; x++ ) {\r\n                for( y = 0 ; y < 5 ; y++ ) {\r\n                    A[5*x+y] = B[5*x+y]^((~B[5*((x+1)%5)+y]) & B[5*((x+2)%5)+y]);\r\n                }\r\n            }*/\r\n            \r\n            \r\n            A[0]=B[0]^((~B[5]) & B[10]);\r\n            A[1]=B[1]^((~B[6]) & B[11]);\r\n            A[2]=B[2]^((~B[7]) & B[12]);\r\n            A[3]=B[3]^((~B[8]) & B[13]);\r\n            A[4]=B[4]^((~B[9]) & B[14]);\r\n            A[5]=B[5]^((~B[10]) & B[15]);\r\n            A[6]=B[6]^((~B[11]) & B[16]);\r\n            A[7]=B[7]^((~B[12]) & B[17]);\r\n            A[8]=B[8]^((~B[13]) & B[18]);\r\n            A[9]=B[9]^((~B[14]) & B[19]);\r\n            A[10]=B[10]^((~B[15]) & B[20]);\r\n            A[11]=B[11]^((~B[16]) & B[21]);\r\n            A[12]=B[12]^((~B[17]) & B[22]);\r\n            A[13]=B[13]^((~B[18]) & B[23]);\r\n            A[14]=B[14]^((~B[19]) & B[24]);\r\n            A[15]=B[15]^((~B[20]) & B[0]);\r\n            A[16]=B[16]^((~B[21]) & B[1]);\r\n            A[17]=B[17]^((~B[22]) & B[2]);\r\n            A[18]=B[18]^((~B[23]) & B[3]);\r\n            A[19]=B[19]^((~B[24]) & B[4]);\r\n            A[20]=B[20]^((~B[0]) & B[5]);\r\n            A[21]=B[21]^((~B[1]) & B[6]);\r\n            A[22]=B[22]^((~B[2]) & B[7]);\r\n            A[23]=B[23]^((~B[3]) & B[8]);\r\n            A[24]=B[24]^((~B[4]) & B[9]);\r\n\r\n            /*Last step*/\r\n            A[0]=A[0]^RC[i];            \r\n        }\r\n\r\n        \r\n        return A;\r\n    }\r\n \r\n    \r\n    function sponge(uint[9] M) constant internal returns(uint[16]) {\r\n        if( (M.length * 8) != 72 ) throw;\r\n        M[5] = 0x01;\r\n        M[8] = 0x8000000000000000;\r\n        \r\n        uint r = 72;\r\n        uint w = 8;\r\n        uint size = M.length * 8;\r\n        \r\n        uint[25] memory S;\r\n        uint i; uint y; uint x;\r\n        /*Absorbing Phase*/\r\n        for( i = 0 ; i < size/r ; i++ ) {\r\n            for( y = 0 ; y < 5 ; y++ ) {\r\n                for( x = 0 ; x < 5 ; x++ ) {\r\n                    if( (x+5*y) < (r/w) ) {\r\n                        S[5*x+y] = S[5*x+y] ^ M[i*9 + x + 5*y];\r\n                    }\r\n                }\r\n            }\r\n            S = keccak_f(S);\r\n        }\r\n\r\n        /*Squeezing phase*/\r\n        uint[16] memory result;\r\n        uint b = 0;\r\n        while( b < 16 ) {\r\n            for( y = 0 ; y < 5 ; y++ ) {\r\n                for( x = 0 ; x < 5 ; x++ ) {\r\n                    if( (x+5*y)<(r/w) && (b<16) ) {\r\n                        result[b] = S[5*x+y] & 0xFFFFFFFF; \r\n                        result[b+1] = S[5*x+y] / 0x100000000;\r\n                        b+=2;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n         \r\n        return result;\r\n   }\r\n\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\ncontract Ethash is SHA3_512 {\r\n    \r\n    address public owner;    \r\n    \r\n    struct EthashCacheData {\r\n        uint128 merkleRoot;\r\n        uint64  fullSizeIn128Resultion;\r\n        uint64  branchDepth;\r\n    }\r\n    \r\n    mapping(uint=>EthashCacheData) epochData;    \r\n    \r\n    using RLP for RLP.RLPItem;\r\n    using RLP for RLP.Iterator;\r\n    using RLP for bytes;\r\n \r\n    struct BlockHeader {\r\n        uint       prevBlockHash; // 0\r\n        uint       coinbase;      // 1\r\n        uint       blockNumber;   // 8\r\n        uint       timestamp;     // 11\r\n        bytes32    extraData;     // 12\r\n    }\r\n    \r\n    function Ethash() {\r\n        owner = msg.sender;\r\n    }\r\n           \r\n    function setEpochData( uint128 merkleRoot, uint64 fullSizeIn128Resultion, uint64 branchDepth, uint epoch ) {\r\n        EthashCacheData memory data;\r\n        data.merkleRoot = merkleRoot;\r\n        data.fullSizeIn128Resultion = fullSizeIn128Resultion;\r\n        data.branchDepth = branchDepth;\r\n        \r\n        epochData[epoch] = data;        \r\n    }    \r\n      \r\n    function parseBlockHeader( bytes rlpHeader ) constant internal returns(BlockHeader) {\r\n        BlockHeader memory header;\r\n        \r\n        var it = rlpHeader.toRLPItem().iterator();        \r\n        uint idx;\r\n        while(it.hasNext()) {\r\n            if( idx == 0 ) header.prevBlockHash = it.next().toUint();\r\n            else if ( idx == 2 ) header.coinbase = it.next().toUint();\r\n            else if ( idx == 8 ) header.blockNumber = it.next().toUint();\r\n            else if ( idx == 11 ) header.timestamp = it.next().toUint();\r\n            else if ( idx == 12 ) header.extraData = bytes32(it.next().toUint());\r\n            else it.next();\r\n            \r\n            idx++;\r\n        }\r\n \r\n        return header;        \r\n    }\r\n        \r\n     \r\n    function fnv( uint v1, uint v2 ) constant internal returns(uint) {\r\n        return ((v1*0x01000193) ^ v2) & 0xFFFFFFFF;\r\n    }\r\n\r\n\r\n\r\n    function computeCacheRoot( uint index,\r\n                               uint indexInElementsArray,\r\n                               uint[] elements,\r\n                               uint[] witness,\r\n                               uint branchSize ) constant private returns(uint) {\r\n \r\n                       \r\n        uint leaf = computeLeaf(elements, indexInElementsArray) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n        uint left;\r\n        uint right;\r\n        uint node;\r\n        bool oddBranchSize = (branchSize % 2) > 0;\r\n         \r\n        assembly {\r\n            branchSize := div(branchSize,2)\r\n            //branchSize /= 2;\r\n        }\r\n        uint witnessIndex = indexInElementsArray * branchSize;\r\n        if( oddBranchSize ) witnessIndex += indexInElementsArray;  \r\n\r\n        for( uint depth = 0 ; depth < branchSize ; depth++ ) {\r\n            assembly {\r\n                node := mload(add(add(witness,0x20),mul(add(depth,witnessIndex),0x20)))\r\n            }\r\n            //node  = witness[witnessIndex + depth] & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n            if( index & 0x1 == 0 ) {\r\n                left = leaf;\r\n                assembly{\r\n                    //right = node & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;                \r\n                    right := and(node,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                }\r\n                \r\n            }\r\n            else {\r\n                assembly{\r\n                    //left = node & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n                    left := and(node,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                }\r\n                right = leaf;\r\n            }\r\n            \r\n            leaf = uint(sha3(left,right)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n            assembly {\r\n                index := div(index,2) \r\n            }\r\n            //index = index / 2;\r\n\r\n            //node  = witness[witnessIndex + depth] / (2**128);\r\n            if( index & 0x1 == 0 ) {\r\n                left = leaf;\r\n                assembly{\r\n                    right := div(node,0x100000000000000000000000000000000)\r\n                    //right = node / 0x100000000000000000000000000000000;\r\n                }\r\n            }\r\n            else {\r\n                assembly {\r\n                    //left = node / 0x100000000000000000000000000000000;\r\n                    left := div(node,0x100000000000000000000000000000000)\r\n                }\r\n                right = leaf;\r\n            }\r\n            \r\n            leaf = uint(sha3(left,right)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n            assembly {\r\n                index := div(index,2) \r\n            }\r\n            //index = index / 2;\r\n        }\r\n        \r\n        if( oddBranchSize ) {\r\n            assembly {\r\n                node := mload(add(add(witness,0x20),mul(add(depth,witnessIndex),0x20)))\r\n            }\r\n        \r\n            //node  = witness[witnessIndex + depth] & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n            if( index & 0x1 == 0 ) {\r\n                left = leaf;\r\n                assembly{\r\n                    //right = node & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;                \r\n                    right := and(node,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                }                \r\n            }\r\n            else {\r\n                assembly{\r\n                    //left = node & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;                \r\n                    left := and(node,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                }\r\n            \r\n                right = leaf;\r\n            }\r\n            \r\n            leaf = uint(sha3(left,right)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;        \r\n        }\r\n        \r\n        \r\n        return leaf;\r\n    }\r\n\r\n    \r\n    function toBE( uint x ) constant internal returns(uint) {\r\n        uint y = 0;\r\n        for( uint i = 0 ; i < 32 ; i++ ) {\r\n            y = y * 256;\r\n            y += (x & 0xFF);\r\n            x = x / 256;            \r\n        }\r\n        \r\n        return y;\r\n        \r\n    }\r\n    \r\n    function computeSha3( uint[16] s, uint[8] cmix ) constant internal returns(uint) {\r\n        uint s0 = s[0] + s[1] * (2**32) + s[2] * (2**64) + s[3] * (2**96) +\r\n                  (s[4] + s[5] * (2**32) + s[6] * (2**64) + s[7] * (2**96))*(2**128);\r\n\r\n        uint s1 = s[8] + s[9] * (2**32) + s[10] * (2**64) + s[11] * (2**96) +\r\n                  (s[12] + s[13] * (2**32) + s[14] * (2**64) + s[15] * (2**96))*(2**128);\r\n                  \r\n        uint c = cmix[0] + cmix[1] * (2**32) + cmix[2] * (2**64) + cmix[3] * (2**96) +\r\n                  (cmix[4] + cmix[5] * (2**32) + cmix[6] * (2**64) + cmix[7] * (2**96))*(2**128);\r\n\r\n        \r\n        /* god knows why need to convert to big endian */\r\n        return uint( sha3(toBE(s0),toBE(s1),toBE(c)) );\r\n    }\r\n \r\n \r\n    function computeLeaf( uint[] dataSetLookup, uint index ) constant internal returns(uint) {\r\n        return uint( sha3(dataSetLookup[4*index],\r\n                          dataSetLookup[4*index + 1],\r\n                          dataSetLookup[4*index + 2],\r\n                          dataSetLookup[4*index + 3]) );\r\n                                    \r\n    }\r\n \r\n    function computeS( uint header, uint nonceLe ) constant internal returns(uint[16]) {\r\n        uint[9]  memory M;\r\n        \r\n        header = reverseBytes(header);\r\n        \r\n        M[0] = uint(header) & 0xFFFFFFFFFFFFFFFF;\r\n        header = header / 2**64;\r\n        M[1] = uint(header) & 0xFFFFFFFFFFFFFFFF;\r\n        header = header / 2**64;\r\n        M[2] = uint(header) & 0xFFFFFFFFFFFFFFFF;\r\n        header = header / 2**64;\r\n        M[3] = uint(header) & 0xFFFFFFFFFFFFFFFF;\r\n\r\n        // make little endian nonce\r\n        M[4] = nonceLe;\r\n        return sponge(M);\r\n    }\r\n    \r\n    function reverseBytes( uint input ) constant internal returns(uint) {\r\n        uint result = 0;\r\n        for(uint i = 0 ; i < 32 ; i++ ) {\r\n            result = result * 256;\r\n            result += input & 0xff;\r\n            \r\n            input /= 256;\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    function hashimoto( bytes32 header,\r\n                        bytes8 nonceLe,\r\n                        uint fullSizeIn128Resultion,\r\n                        uint[] dataSetLookup,\r\n                        uint[] witnessForLookup,\r\n                        uint   branchSize,\r\n                        uint   root ) constant returns(uint) {\r\n         \r\n        uint[16] memory s;\r\n        uint[32] memory mix;\r\n        uint[8]  memory cmix;\r\n                \r\n        uint i;\r\n        uint j;\r\n        \r\n\r\n        \r\n        s = computeS(uint(header), uint(nonceLe));\r\n        for( i = 0 ; i < 16 ; i++ ) {            \r\n            assembly {\r\n                let offset := mul(i,0x20)\r\n                \r\n                //mix[i] = s[i];\r\n                mstore(add(mix,offset),mload(add(s,offset)))\r\n                \r\n                // mix[i+16] = s[i];\r\n                mstore(add(mix,add(0x200,offset)),mload(add(s,offset)))    \r\n            }\r\n        }\r\n        \r\n        for( i = 0 ; i < 64 ; i++ ) {\r\n            uint p = fnv( i ^ s[0], mix[i % 32]) % fullSizeIn128Resultion;\r\n            if( computeCacheRoot( p, i, dataSetLookup,  witnessForLookup, branchSize )  != root ) {\r\n                // PoW failed\r\n                return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n            }        \r\n\r\n            for( j = 0 ; j < 8 ; j++ ) {\r\n\r\n                assembly{\r\n                    //mix[j] = fnv(mix[j], dataSetLookup[4*i] & varFFFFFFFF );\r\n                    let dataOffset := add(mul(0x80,i),add(dataSetLookup,0x20))\r\n                    let dataValue   := and(mload(dataOffset),0xFFFFFFFF)\r\n                    \r\n                    let mixOffset := add(mix,mul(0x20,j))\r\n                    let mixValue  := mload(mixOffset)\r\n                    \r\n                    // fnv = return ((v1*0x01000193) ^ v2) & 0xFFFFFFFF;\r\n                    let fnvValue := and(xor(mul(mixValue,0x01000193),dataValue),0xFFFFFFFF)                    \r\n                    mstore(mixOffset,fnvValue)\r\n                    \r\n                    //mix[j+8] = fnv(mix[j+8], dataSetLookup[4*i + 1] & 0xFFFFFFFF );\r\n                    dataOffset := add(dataOffset,0x20)\r\n                    dataValue   := and(mload(dataOffset),0xFFFFFFFF)\r\n                    \r\n                    mixOffset := add(mixOffset,0x100)\r\n                    mixValue  := mload(mixOffset)\r\n                    \r\n                    // fnv = return ((v1*0x01000193) ^ v2) & 0xFFFFFFFF;\r\n                    let fnvValue := and(xor(mul(mixValue,0x01000193),dataValue),0xFFFFFFFF)                    \r\n                    mstore(mixOffset,fnvValue)\r\n\r\n                    //mix[j+16] = fnv(mix[j+16], dataSetLookup[4*i + 2] & 0xFFFFFFFF );\r\n                    dataOffset := add(dataOffset,0x20)\r\n                    dataValue   := and(mload(dataOffset),0xFFFFFFFF)\r\n                    \r\n                    mixOffset := add(mixOffset,0x100)\r\n                    mixValue  := mload(mixOffset)\r\n                    \r\n                    // fnv = return ((v1*0x01000193) ^ v2) & 0xFFFFFFFF;\r\n                    let fnvValue := and(xor(mul(mixValue,0x01000193),dataValue),0xFFFFFFFF)                    \r\n                    mstore(mixOffset,fnvValue)\r\n\r\n                    //mix[j+24] = fnv(mix[j+24], dataSetLookup[4*i + 3] & 0xFFFFFFFF );\r\n                    dataOffset := add(dataOffset,0x20)\r\n                    dataValue   := and(mload(dataOffset),0xFFFFFFFF)\r\n                    \r\n                    mixOffset := add(mixOffset,0x100)\r\n                    mixValue  := mload(mixOffset)\r\n                    \r\n                    // fnv = return ((v1*0x01000193) ^ v2) & 0xFFFFFFFF;\r\n                    let fnvValue := and(xor(mul(mixValue,0x01000193),dataValue),0xFFFFFFFF)                    \r\n                    mstore(mixOffset,fnvValue)                    \r\n                                        \r\n                }\r\n\r\n                \r\n                //mix[j] = fnv(mix[j], dataSetLookup[4*i] & 0xFFFFFFFF );\r\n                //mix[j+8] = fnv(mix[j+8], dataSetLookup[4*i + 1] & 0xFFFFFFFF );\r\n                //mix[j+16] = fnv(mix[j+16], dataSetLookup[4*i + 2] & 0xFFFFFFFF );                \r\n                //mix[j+24] = fnv(mix[j+24], dataSetLookup[4*i + 3] & 0xFFFFFFFF );\r\n                \r\n                \r\n                //dataSetLookup[4*i    ] = dataSetLookup[4*i    ]/(2**32);\r\n                //dataSetLookup[4*i + 1] = dataSetLookup[4*i + 1]/(2**32);\r\n                //dataSetLookup[4*i + 2] = dataSetLookup[4*i + 2]/(2**32);\r\n                //dataSetLookup[4*i + 3] = dataSetLookup[4*i + 3]/(2**32);                \r\n                \r\n                assembly{\r\n                    let offset := add(add(dataSetLookup,0x20),mul(i,0x80))\r\n                    let value  := div(mload(offset),0x100000000)\r\n                    mstore(offset,value)\r\n                                       \r\n                    offset := add(offset,0x20)\r\n                    value  := div(mload(offset),0x100000000)\r\n                    mstore(offset,value)\r\n                    \r\n                    offset := add(offset,0x20)\r\n                    value  := div(mload(offset),0x100000000)\r\n                    mstore(offset,value)                    \r\n                    \r\n                    offset := add(offset,0x20)\r\n                    value  := div(mload(offset),0x100000000)\r\n                    mstore(offset,value)                                                                                \r\n                }                \r\n            }\r\n        }\r\n        \r\n        \r\n        for( i = 0 ; i < 32 ; i += 4) {\r\n            cmix[i/4] = (fnv(fnv(fnv(mix[i], mix[i+1]), mix[i+2]), mix[i+3]));\r\n        }\r\n        \r\n\r\n        uint result = computeSha3(s,cmix); \r\n        return result;        \r\n    }    \r\n\r\n    event EthashValue( uint value );\r\n        \r\n    function verifyHash( bytes rlpHeader,\r\n                          uint  nonce,\r\n                          uint[] dataSetLookup,\r\n                          uint[] witnessForLookup ) constant returns(uint) {\r\n                          \r\n        BlockHeader memory header = parseBlockHeader(rlpHeader);        \r\n        \r\n        uint leafHash = uint(sha3(rlpHeader));                          \r\n        \r\n        // get epoch data\r\n        EthashCacheData memory eData = epochData[header.blockNumber / 30000];\r\n        \r\n        // verify ethash\r\n        uint ethash = hashimoto( bytes32(leafHash),\r\n                                 bytes8(nonce),\r\n                                 eData.fullSizeIn128Resultion,\r\n                                 dataSetLookup,\r\n                                 witnessForLookup,                                 \r\n                                 eData.branchDepth,\r\n                                 eData.merkleRoot );\r\n                                 \r\n        EthashValue( ethash );\r\n        \r\n        return ethash;\r\n    }             \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"header\",\"type\":\"bytes32\"},{\"name\":\"nonceLe\",\"type\":\"bytes8\"},{\"name\":\"fullSizeIn128Resultion\",\"type\":\"uint256\"},{\"name\":\"dataSetLookup\",\"type\":\"uint256[]\"},{\"name\":\"witnessForLookup\",\"type\":\"uint256[]\"},{\"name\":\"branchSize\",\"type\":\"uint256\"},{\"name\":\"root\",\"type\":\"uint256\"}],\"name\":\"hashimoto\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"merkleRoot\",\"type\":\"uint128\"},{\"name\":\"fullSizeIn128Resultion\",\"type\":\"uint64\"},{\"name\":\"branchDepth\",\"type\":\"uint64\"},{\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"setEpochData\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rlpHeader\",\"type\":\"bytes\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"dataSetLookup\",\"type\":\"uint256[]\"},{\"name\":\"witnessForLookup\",\"type\":\"uint256[]\"}],\"name\":\"verifyHash\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"EthashValue\",\"type\":\"event\"}]","ContractName":"Ethash","CompilerVersion":"v0.4.9+commit.364da425","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ec2ee2a0cf380cea8ba0b454499e42379808356489ec1b60fe54613bf642aac8"}]}