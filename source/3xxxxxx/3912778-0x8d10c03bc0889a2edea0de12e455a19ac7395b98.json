{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n/*\r\n    Overflow protected math functions\r\n*/\r\ncontract SafeMath {\r\n    /**\r\n        constructor\r\n    */\r\n    function SafeMath() {\r\n    }\r\n\r\n    /**\r\n        @dev returns the sum of _x and _y, asserts if the calculation overflows\r\n\r\n        @param _x   value 1\r\n        @param _y   value 2\r\n\r\n        @return sum\r\n    */\r\n    function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        assert(z >= _x);\r\n        return z;\r\n    }\r\n\r\n    /**\r\n        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\r\n\r\n        @param _x   minuend\r\n        @param _y   subtrahend\r\n\r\n        @return difference\r\n    */\r\n    function safeSub(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        assert(_x >= _y);\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\r\n\r\n        @param _x   factor 1\r\n        @param _y   factor 2\r\n\r\n        @return product\r\n    */\r\n    function safeMul(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        uint256 z = _x * _y;\r\n        assert(_x == 0 || z / _x == _y);\r\n        return z;\r\n    }\r\n}\r\n\r\n/*\r\n    Bancor Formula interface\r\n*/\r\ncontract IBancorFormula {\r\n    function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint16 _reserveRatio, uint256 _depositAmount) public constant returns (uint256);\r\n    function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint16 _reserveRatio, uint256 _sellAmount) public constant returns (uint256);\r\n}\r\n\r\n/*\r\n    Open issues:\r\n    - The formula is not yet super accurate, especially for very small/very high ratios\r\n    - Possibly support dynamic precision in the future\r\n*/\r\n\r\ncontract BancorFormula is IBancorFormula, SafeMath {\r\n\r\n    uint8 constant PRECISION   = 32;  // fractional bits\r\n    uint256 constant FIXED_ONE = uint256(1) << PRECISION; // 0x100000000\r\n    uint256 constant FIXED_TWO = uint256(2) << PRECISION; // 0x200000000\r\n    uint256 constant MAX_VAL   = uint256(1) << (256 - PRECISION); // 0x0000000100000000000000000000000000000000000000000000000000000000\r\n    string public version = '0.1';\r\n\r\n    function BancorFormula() {\r\n    }\r\n\r\n    /**\r\n        @dev given a token supply, reserve, CRR and a deposit amount (in the reserve token), calculates the return for a given change (in the main token)\r\n\r\n        Formula:\r\n        Return = _supply * ((1 + _depositAmount / _reserveBalance) ^ (_reserveRatio / 100) - 1)\r\n\r\n        @param _supply             token total supply\r\n        @param _reserveBalance     total reserve\r\n        @param _reserveRatio       constant reserve ratio, 1-100\r\n        @param _depositAmount      deposit amount, in reserve token\r\n\r\n        @return purchase return amount\r\n    */\r\n    function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint16 _reserveRatio, uint256 _depositAmount) public constant returns (uint256) {\r\n        // validate input\r\n        require(_supply != 0 && _reserveBalance != 0 && _reserveRatio > 0 && _reserveRatio <= 100);\r\n\r\n        // special case for 0 deposit amount\r\n        if (_depositAmount == 0)\r\n            return 0;\r\n\r\n        uint256 baseN = safeAdd(_depositAmount, _reserveBalance);\r\n        uint256 temp;\r\n\r\n        // special case if the CRR = 100\r\n        if (_reserveRatio == 100) {\r\n            temp = safeMul(_supply, baseN) / _reserveBalance;\r\n            return safeSub(temp, _supply); \r\n        }\r\n\r\n        uint256 resN = power(baseN, _reserveBalance, _reserveRatio, 100);\r\n\r\n        temp = safeMul(_supply, resN) / FIXED_ONE;\r\n\r\n        uint256 result =  safeSub(temp, _supply);\r\n        // from the result, we deduct the minimal increment, which is a         \r\n        // function of S and precision.       \r\n        return safeSub(result, _supply / 0x100000000);\r\n     }\r\n\r\n    /**\r\n        @dev given a token supply, reserve, CRR and a sell amount (in the main token), calculates the return for a given change (in the reserve token)\r\n\r\n        Formula:\r\n        Return = _reserveBalance * (1 - (1 - _sellAmount / _supply) ^ (1 / (_reserveRatio / 100)))\r\n\r\n        @param _supply             token total supply\r\n        @param _reserveBalance     total reserve\r\n        @param _reserveRatio       constant reserve ratio, 1-100\r\n        @param _sellAmount         sell amount, in the token itself\r\n\r\n        @return sale return amount\r\n    */\r\n    function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint16 _reserveRatio, uint256 _sellAmount) public constant returns (uint256) {\r\n        // validate input\r\n        require(_supply != 0 && _reserveBalance != 0 && _reserveRatio > 0 && _reserveRatio <= 100 && _sellAmount <= _supply);\r\n\r\n        // special case for 0 sell amount\r\n        if (_sellAmount == 0)\r\n            return 0;\r\n\r\n        uint256 baseN = safeSub(_supply, _sellAmount);\r\n        uint256 temp1;\r\n        uint256 temp2;\r\n\r\n        // special case if the CRR = 100\r\n        if (_reserveRatio == 100) {\r\n            temp1 = safeMul(_reserveBalance, _supply);\r\n            temp2 = safeMul(_reserveBalance, baseN);\r\n            return safeSub(temp1, temp2) / _supply;\r\n        }\r\n\r\n        // special case for selling the entire supply\r\n        if (_sellAmount == _supply)\r\n            return _reserveBalance;\r\n\r\n        uint256 resN = power(_supply, baseN, 100, _reserveRatio);\r\n\r\n        temp1 = safeMul(_reserveBalance, resN);\r\n        temp2 = safeMul(_reserveBalance, FIXED_ONE);\r\n\r\n        uint256 result = safeSub(temp1, temp2) / resN;\r\n\r\n        // from the result, we deduct the minimal increment, which is a         \r\n        // function of R and precision.       \r\n        return safeSub(result, _reserveBalance / 0x100000000);\r\n    }\r\n\r\n    /**\r\n        @dev Calculate (_baseN / _baseD) ^ (_expN / _expD)\r\n        Returns result upshifted by PRECISION\r\n\r\n        This method is overflow-safe\r\n    */ \r\n    function power(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) constant returns (uint256 resN) {\r\n        uint256 logbase = ln(_baseN, _baseD);\r\n        // Not using safeDiv here, since safeDiv protects against\r\n        // precision loss. It's unavoidable, however\r\n        // Both `ln` and `fixedExp` are overflow-safe. \r\n        resN = fixedExp(safeMul(logbase, _expN) / _expD);\r\n        return resN;\r\n\t}\r\n    \r\n    /**\r\n        input range: \r\n            - numerator: [1, uint256_max >> PRECISION]    \r\n            - denominator: [1, uint256_max >> PRECISION]\r\n        output range:\r\n            [0, 0x9b43d4f8d6]\r\n\r\n        This method asserts outside of bounds\r\n\r\n    */\r\n    function ln(uint256 _numerator, uint256 _denominator) public constant returns (uint256) {\r\n        // denominator > numerator: less than one yields negative values. Unsupported\r\n        assert(_denominator <= _numerator);\r\n\r\n        // log(1) is the lowest we can go\r\n        assert(_denominator != 0 && _numerator != 0);\r\n\r\n        // Upper 32 bits are scaled off by PRECISION\r\n        assert(_numerator < MAX_VAL);\r\n        assert(_denominator < MAX_VAL);\r\n\r\n        return fixedLoge( (_numerator * FIXED_ONE) / _denominator);\r\n    }\r\n\r\n    /**\r\n        input range: \r\n            [0x100000000,uint256_max]\r\n        output range:\r\n            [0, 0x9b43d4f8d6]\r\n\r\n        This method asserts outside of bounds\r\n\r\n    */\r\n    function fixedLoge(uint256 _x) constant returns (uint256 logE) {\r\n        /*\r\n        Since `fixedLog2_min` output range is max `0xdfffffffff` \r\n        (40 bits, or 5 bytes), we can use a very large approximation\r\n        for `ln(2)`. This one is used since it's the max accuracy \r\n        of Python `ln(2)`\r\n\r\n        0xb17217f7d1cf78 = ln(2) * (1 << 56)\r\n        \r\n        */\r\n        //Cannot represent negative numbers (below 1)\r\n        assert(_x >= FIXED_ONE);\r\n\r\n        uint256 log2 = fixedLog2(_x);\r\n        logE = (log2 * 0xb17217f7d1cf78) >> 56;\r\n    }\r\n\r\n    /**\r\n        Returns log2(x >> 32) << 32 [1]\r\n        So x is assumed to be already upshifted 32 bits, and \r\n        the result is also upshifted 32 bits. \r\n        \r\n        [1] The function returns a number which is lower than the \r\n        actual value\r\n\r\n        input-range : \r\n            [0x100000000,uint256_max]\r\n        output-range: \r\n            [0,0xdfffffffff]\r\n\r\n        This method asserts outside of bounds\r\n\r\n    */\r\n    function fixedLog2(uint256 _x) constant returns (uint256) {\r\n        // Numbers below 1 are negative. \r\n        assert( _x >= FIXED_ONE);\r\n\r\n        uint256 hi = 0;\r\n        while (_x >= FIXED_TWO) {\r\n            _x >>= 1;\r\n            hi += FIXED_ONE;\r\n        }\r\n\r\n        for (uint8 i = 0; i < PRECISION; ++i) {\r\n            _x = (_x * _x) / FIXED_ONE;\r\n            if (_x >= FIXED_TWO) {\r\n                _x >>= 1;\r\n                hi += uint256(1) << (PRECISION - 1 - i);\r\n            }\r\n        }\r\n\r\n        return hi;\r\n    }\r\n\r\n    /**\r\n        fixedExp is a 'protected' version of `fixedExpUnsafe`, which \r\n        asserts instead of overflows\r\n    */\r\n    function fixedExp(uint256 _x) constant returns (uint256) {\r\n        assert(_x <= 0x386bfdba29);\r\n        return fixedExpUnsafe(_x);\r\n    }\r\n\r\n    /**\r\n        fixedExp \r\n        Calculates e^x according to maclauren summation:\r\n\r\n        e^x = 1+x+x^2/2!...+x^n/n!\r\n\r\n        and returns e^(x>>32) << 32, that is, upshifted for accuracy\r\n\r\n        Input range:\r\n            - Function ok at    <= 242329958953 \r\n            - Function fails at >= 242329958954\r\n\r\n        This method is is visible for testcases, but not meant for direct use. \r\n \r\n        The values in this method been generated via the following python snippet: \r\n\r\n        def calculateFactorials():\r\n            \"\"\"Method to print out the factorials for fixedExp\"\"\"\r\n\r\n            ni = []\r\n            ni.append( 295232799039604140847618609643520000000) # 34!\r\n            ITERATIONS = 34\r\n            for n in range( 1,  ITERATIONS,1 ) :\r\n                ni.append(math.floor(ni[n - 1] / n))\r\n            print( \"\\n        \".join([\"xi = (xi * _x) >> PRECISION;\\n        res += xi * %s;\" % hex(int(x)) for x in ni]))\r\n\r\n    */\r\n    function fixedExpUnsafe(uint256 _x) constant returns (uint256) {\r\n    \r\n        uint256 xi = FIXED_ONE;\r\n        uint256 res = 0xde1bc4d19efcac82445da75b00000000 * xi;\r\n\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0xde1bc4d19efcb0000000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x6f0de268cf7e58000000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x2504a0cd9a7f72000000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x9412833669fdc800000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x1d9d4d714865f500000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x4ef8ce836bba8c0000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0xb481d807d1aa68000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x16903b00fa354d000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x281cdaac677b3400000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x402e2aad725eb80000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x5d5a6c9f31fe24000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x7c7890d442a83000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x9931ed540345280000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0xaf147cf24ce150000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0xbac08546b867d000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0xbac08546b867d00000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0xafc441338061b8000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x9c3cabbc0056e000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x839168328705c80000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x694120286c04a0000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x50319e98b3d2c400;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x3a52a1e36b82020;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x289286e0fce002;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x1b0c59eb53400;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x114f95b55400;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0xaa7210d200;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x650139600;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x39b78e80;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x1fd8080;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x10fbc0;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x8c40;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x462;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x22;\r\n\r\n        return res / 0xde1bc4d19efcac82445da75b00000000;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_x\",\"type\":\"uint256\"}],\"name\":\"fixedLog2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_x\",\"type\":\"uint256\"}],\"name\":\"fixedLoge\",\"outputs\":[{\"name\":\"logE\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_baseN\",\"type\":\"uint256\"},{\"name\":\"_baseD\",\"type\":\"uint256\"},{\"name\":\"_expN\",\"type\":\"uint32\"},{\"name\":\"_expD\",\"type\":\"uint32\"}],\"name\":\"power\",\"outputs\":[{\"name\":\"resN\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_numerator\",\"type\":\"uint256\"},{\"name\":\"_denominator\",\"type\":\"uint256\"}],\"name\":\"ln\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_x\",\"type\":\"uint256\"}],\"name\":\"fixedExpUnsafe\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_supply\",\"type\":\"uint256\"},{\"name\":\"_reserveBalance\",\"type\":\"uint256\"},{\"name\":\"_reserveRatio\",\"type\":\"uint16\"},{\"name\":\"_depositAmount\",\"type\":\"uint256\"}],\"name\":\"calculatePurchaseReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_x\",\"type\":\"uint256\"}],\"name\":\"fixedExp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_supply\",\"type\":\"uint256\"},{\"name\":\"_reserveBalance\",\"type\":\"uint256\"},{\"name\":\"_reserveRatio\",\"type\":\"uint16\"},{\"name\":\"_sellAmount\",\"type\":\"uint256\"}],\"name\":\"calculateSaleReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"}]","ContractName":"BancorFormula","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://62be896f544ff888bdc915ed977f9691e1f00060c370efdc4920c3ba5045f59f"}]}