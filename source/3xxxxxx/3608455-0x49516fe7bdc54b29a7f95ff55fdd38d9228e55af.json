{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\nlibrary ArrayLib {\r\n  // Inserts to keep array sorted (assumes input array is sorted)\r\n\tfunction insertInPlace(uint8[] storage self, uint8 n) {\r\n\t\tuint8 insertingIndex = 0;\r\n\r\n\t\twhile (self.length > 0 && insertingIndex < self.length && self[insertingIndex] < n) {\r\n\t\t\tinsertingIndex += 1;\r\n\t\t}\r\n\r\n\t\tself.length += 1;\r\n\t\tfor (uint8 i = uint8(self.length) - 1; i > insertingIndex; i--) {\r\n\t\t\tself[i] = self[i - 1];\r\n\t\t}\r\n\r\n\t\tself[insertingIndex] = n;\r\n\t}\r\n}\r\n\r\nlibrary DeckLib {\r\n\tusing ArrayLib for uint8[];\r\n\r\n\tenum Suit { Spades, Hearts, Clubs, Diamonds }\r\n\tuint8 constant cardsPerSuit = 13;\r\n\tuint8 constant suits = 4;\r\n\tuint8 constant totalCards = cardsPerSuit * suits;\r\n\r\n\tstruct Deck {\r\n\t\tuint8[] usedCards; // always has to be sorted\r\n\t\taddress player;\r\n\t\tuint256 gameID;\r\n\t}\r\n\r\n\tfunction init(Deck storage self, uint256 gameID)  {\r\n\t\tself.usedCards = new uint8[](0);\r\n\t\tself.player = msg.sender;\r\n\t\tself.gameID = gameID;\r\n\t}\r\n\r\n\tfunction getCard(Deck storage self, uint256 blockNumber)  returns (uint8)  {\r\n\t\tuint cardIndex = self.usedCards.length;\r\n\t\tif (cardIndex >= totalCards) throw;\r\n\t\tuint8 r = uint8(getRandomNumber(blockNumber, self.player, self.gameID, cardIndex, totalCards - cardIndex));\r\n\r\n\t\tfor (uint8 i = 0; i < cardIndex; i++) {\r\n\t\t\tif (self.usedCards[i] <= r) r += 1;\r\n\t\t}\r\n\r\n\t\tself.usedCards.insertInPlace(r);\r\n\r\n\t\treturn r;\r\n\t}\r\n\r\n\tfunction cardDescription(uint8 self) constant returns (Suit, uint8) {\r\n\t\treturn (Suit(self / cardsPerSuit), cardFacevalue(self));\r\n\t}\r\n\r\n\tfunction cardEmojified(uint8 self) constant returns (uint8, string) {\r\n\t\tstring memory emojiSuit;\r\n\r\n\t\tvar (suit, number) = cardDescription(self);\r\n\t\tif (suit == Suit.Clubs) emojiSuit = \"♣️\";\r\n\t\telse if (suit == Suit.Diamonds) emojiSuit = \"♦️\";\r\n\t\telse if (suit == Suit.Hearts) emojiSuit = \"♥️\";\r\n\t\telse if (suit == Suit.Spades) emojiSuit = \"♠️\";\r\n\r\n\t\treturn (number, emojiSuit);\r\n\t}\r\n\r\n\tfunction cardFacevalue(uint8 self) constant returns (uint8) {\r\n\t\treturn 1 + self % cardsPerSuit;\r\n\t}\r\n\r\n\tfunction blackjackValue(uint8 self) constant returns (uint8) {\r\n\t\tuint8 cardValue = cardFacevalue(self);\r\n\t\treturn cardValue < 10 ? cardValue : 10;\r\n\t}\r\n\r\n\tfunction getRandomNumber(uint b, address player, uint256 gameID, uint n, uint m) constant returns (uint) {\r\n\t\t// Uses blockhash as randomness source.\r\n\t\t// Credits: https://github.com/Bunjin/Rouleth/blob/master/Provably_Fair_No_Cheating.md\r\n\t\tbytes32 blockHash = block.blockhash(b);\r\n\t\tif (blockHash == 0x0) throw;\r\n\t\treturn uint(uint256(keccak256(blockHash, player, gameID, n)) % m);\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\nlibrary GameLib {\r\n  using DeckLib for *;\r\n\r\n  uint8 constant houseLimit = 17;\r\n  uint8 constant target = 21;\r\n\r\n  enum ComparaisonResult { First, Second, Tie }\r\n  enum GameState { InitialCards, Waiting, Hit, Stand, DoubleDown, Finished }\r\n  enum GameResult { Ongoing, House, Tie, Player, PlayerNatural }\r\n\r\n  struct Game {\r\n    address player;\r\n    uint256 bet;\r\n    uint256 payout;\r\n    uint256 gameID;\r\n\r\n    DeckLib.Deck deck;\r\n    uint8[] houseCards;\r\n    uint8[] playerCards;\r\n\r\n    uint256 actionBlock; // Block on which commitment to perform an action happens.\r\n\r\n    GameState state;\r\n    GameResult result;\r\n\r\n    bool closed;\r\n  }\r\n\r\n  function init(Game storage self, uint256 gameID) {\r\n    self.player = msg.sender;\r\n    self.bet = msg.value;\r\n    self.payout = 0;\r\n    self.houseCards = new uint8[](0);\r\n    self.playerCards = new uint8[](0);\r\n    self.actionBlock = block.number;\r\n    self.state = GameState.InitialCards;\r\n    self.result = GameResult.Ongoing;\r\n    self.closed = false;\r\n    self.gameID = gameID;\r\n\r\n    self.deck.init(gameID);\r\n  }\r\n\r\n  function tick(Game storage self) returns (bool) {\r\n    if (block.number <= self.actionBlock) return false; // Can't tick yet\r\n    if (self.actionBlock + 255 < block.number) {\r\n      endGame(self, GameResult.House);\r\n      return true;\r\n    }\r\n    if (!needsTick(self)) return true; // not needed, everything is fine\r\n    if (self.state == GameState.InitialCards) dealInitialCards(self);\r\n    if (self.state == GameState.Hit) dealHitCard(self);\r\n    if (self.state == GameState.DoubleDown) {\r\n      dealHitCard(self);\r\n      forceStand(self);\r\n    }\r\n\r\n    if (self.state == GameState.Stand) {\r\n      dealHouseCards(self);\r\n      checkGameResult(self);\r\n    } else {\r\n      checkGameContinues(self);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function needsTick(Game storage self) constant returns (bool) {\r\n    if (self.state == GameState.Waiting) return false;\r\n    if (self.state == GameState.Finished) return false;\r\n\r\n    return true;\r\n  }\r\n\r\n  function checkGameResult(Game storage self)  {\r\n    uint8 houseHand = countHand(self.houseCards);\r\n\r\n    if (houseHand == target && self.houseCards.length == 2) return endGame(self, GameResult.House); // House natural\r\n\r\n    ComparaisonResult result = compareHands(houseHand, countHand(self.playerCards));\r\n    if (result == ComparaisonResult.First) return endGame(self, GameResult.House);\r\n    if (result == ComparaisonResult.Second) return endGame(self, GameResult.Player);\r\n\r\n    endGame(self, GameResult.Tie);\r\n  }\r\n\r\n  function checkGameContinues(Game storage self)  {\r\n    uint8 playerHand = countHand(self.playerCards);\r\n    if (playerHand == target && self.playerCards.length == 2) return endGame(self, GameResult.PlayerNatural); // player natural\r\n    if (playerHand > target) return endGame(self, GameResult.House); // Player busted\r\n    if (playerHand == target && self.state == GameState.Waiting) {\r\n      // Player is forced to stand with 21 (but should not  already standing, ie in double down)\r\n      forceStand(self);\r\n    }\r\n  }\r\n\r\n  function forceStand(Game storage self) {\r\n    uint256 currentActionBlock = self.actionBlock;\r\n    playerDecision(self, GameState.Stand);\r\n    self.actionBlock = currentActionBlock;\r\n    if (!tick(self)) throw; // Forces tick, commitment to play actually happened past block\r\n  }\r\n\r\n  function canDoubleDown(Game storage self) returns (bool) {\r\n    if (self.playerCards.length > 2) return false;\r\n    uint8 totalPlayer = countHand(self.playerCards);\r\n    if (totalPlayer < 9 || totalPlayer > 11) return false;\r\n    if (msg.value != self.bet) return false;\r\n    return true;\r\n  }\r\n\r\n  function playerDecision(Game storage self, GameState decision)  {\r\n    if (self.state != GameState.Waiting) throw;\r\n    if (decision != GameState.Hit && decision != GameState.Stand && decision != GameState.DoubleDown) throw;\r\n\r\n    if (decision == GameState.DoubleDown){\r\n      if (!canDoubleDown(self)) throw;\r\n      self.bet += msg.value;\r\n    }\r\n\r\n    self.state = decision;\r\n    self.actionBlock = block.number;\r\n  }\r\n\r\n  function dealInitialCards(Game storage self) private {\r\n    self.playerCards.push(self.deck.getCard(self.actionBlock));\r\n    self.houseCards.push(self.deck.getCard(self.actionBlock));\r\n    self.playerCards.push(self.deck.getCard(self.actionBlock));\r\n    self.state = GameState.Waiting;\r\n  }\r\n\r\n  function dealHitCard(Game storage self) private {\r\n    self.playerCards.push(self.deck.getCard(self.actionBlock));\r\n    self.state = GameState.Waiting;\r\n  }\r\n\r\n  function dealHouseCards(Game storage self) private {\r\n    self.houseCards.push(self.deck.getCard(self.actionBlock));\r\n    if (countHand(self.houseCards) < houseLimit) dealHouseCards(self);\r\n  }\r\n\r\n  function endGame(Game storage self, GameResult result) {\r\n    self.result = result;\r\n    self.state = GameState.Finished;\r\n    self.payout = payoutForResult(self.result, self.bet);\r\n\r\n    closeGame(self);\r\n  }\r\n\r\n  function closeGame(Game storage self) private {\r\n    if (self.closed) throw; // cannot re-close\r\n    if (self.state != GameState.Finished) throw; // not closable\r\n\r\n    self.closed = true;\r\n\r\n    if (self.payout > 0) {\r\n      if (!self.player.send(self.payout)) throw;\r\n    }\r\n  }\r\n\r\n  function payoutForResult(GameResult result, uint256 bet) private returns (uint256) {\r\n    if (result == GameResult.PlayerNatural) return bet * 5 / 2; // bet + 1.5x bet\r\n    if (result == GameResult.Player) return bet * 2; // doubles bet\r\n    if (result == GameResult.Tie) return bet; // returns bet\r\n\r\n    return 0;\r\n  }\r\n\r\n  function countHand(uint8[] memory hand)  returns (uint8) {\r\n    uint8[] memory possibleSums = new uint8[](1);\r\n\r\n    for (uint i = 0; i < hand.length; i++) {\r\n      uint8 value = hand[i].blackjackValue();\r\n      uint l = possibleSums.length;\r\n      for (uint j = 0; j < l; j++) {\r\n        possibleSums[j] += value;\r\n        if (value == 1) { // is Ace\r\n          possibleSums = appendArray(possibleSums, possibleSums[j] + 10); // Fork possible sum with 11 as ace value.\r\n        }\r\n      }\r\n    }\r\n\r\n    return bestSum(possibleSums);\r\n  }\r\n\r\n  function bestSum(uint8[] possibleSums)  returns (uint8 bestSum) {\r\n    bestSum = 50; // very bad hand\r\n    for (uint i = 0; i < possibleSums.length; i++) {\r\n      if (compareHands(bestSum, possibleSums[i]) == ComparaisonResult.Second) {\r\n        bestSum = possibleSums[i];\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  function appendArray(uint8[] memory array, uint8 n)  returns (uint8[] memory) {\r\n    uint8[] memory newArray = new uint8[](array.length + 1);\r\n    for (uint8 i = 0; i < array.length; i++) {\r\n      newArray[i] = array[i];\r\n    }\r\n    newArray[array.length] = n;\r\n    return newArray;\r\n  }\r\n\r\n  function compareHands(uint8 a, uint8 b)  returns (ComparaisonResult) {\r\n    if (a <= target && b <= target) {\r\n      if (a > b) return ComparaisonResult.First;\r\n      if (a < b) return ComparaisonResult.Second;\r\n    }\r\n\r\n    if (a > target && b > target) {\r\n      if (a < b) return ComparaisonResult.First;\r\n      if (a > b) return ComparaisonResult.Second;\r\n    }\r\n\r\n    if (a > target) return ComparaisonResult.Second;\r\n    if (b > target) return ComparaisonResult.First;\r\n\r\n    return ComparaisonResult.Tie;\r\n  }\r\n}\r\n\r\ncontract Blockjack {\r\n  \r\n  event GameEnded(uint256 gameID, address player, uint gameResult, uint256 wager, uint256 payout, uint8 playerHand, uint8 houseHand);\r\n  event GameNeedsTick(uint256 gameID, address player, uint256 actionBlock);\r\n\r\n  using GameLib for GameLib.Game;\r\n\r\n  GameLib.Game[] games;\r\n  mapping (address => uint256) public currentGame;\r\n\r\n  // Initial settings\r\n  uint256 public minBet = 10 finney;\r\n  uint256 public maxBet = 500 finney;\r\n  bool public allowsNewGames = true;\r\n  uint256 public maxBlockActions = 10;\r\n\r\n  mapping (uint256 => uint256) blockActions;\r\n\r\n  //main\r\n  address public DX;\r\n  address public DEV;\r\n\r\n  uint256 public initialBankroll;\r\n  uint256 public currentBankroll;\r\n\r\n  mapping (address => bool) public isOwner;\r\n\r\n  modifier onlyOwner {\r\n    if (!isOwner[msg.sender]) throw;\r\n    _;\r\n  }\r\n\r\n  modifier only(address x) {\r\n    if (msg.sender != x) throw;\r\n    _;\r\n  }\r\n\r\n  modifier onlyPlayer(uint256 gameID) {\r\n    if (msg.sender != games[gameID].player) throw;\r\n    _;\r\n  }\r\n\r\n  modifier blockActionProtected {\r\n    blockActions[block.number] += 1;\r\n    if (blockActions[block.number] > maxBlockActions) throw;\r\n    _;\r\n  }\r\n\r\n  function Blockjack(address _DX, address _DEV) {\r\n    DX = _DX;\r\n    DEV = _DEV;\r\n    games.length += 1;\r\n    games[0].init(0); // Init game 0 so indices start on 1\r\n    games[0].player = this;\r\n    isOwner[DX] = true;\r\n    isOwner[DEV] = true;\r\n  }\r\n\r\n  function () payable {\r\n    startGame();\r\n  }\r\n\r\n  function startGame() blockActionProtected payable {\r\n    if (!allowsNewGames) throw;\r\n    if (msg.value < minBet) throw;\r\n    if (msg.value > maxBet) throw;\r\n\r\n    // check if player has game opened\r\n    uint256 currentGameId = currentGame[msg.sender];\r\n    if (games.length > currentGameId) {\r\n      GameLib.Game openedGame = games[currentGameId];\r\n      if (openedGame.player == msg.sender && !openedGame.closed) { // Check for index 0 mapping problems\r\n\tif (!openedGame.tick()) throw;\r\n\tif (!openedGame.closed) throw; // cannot start game with on-going game\r\n\trecordEndedGame(currentGameId);\r\n      }\r\n    }\r\n    uint256 newGameID = games.length;\r\n\r\n    games.length += 1;\r\n    games[newGameID].init(newGameID);\r\n    currentGame[msg.sender] = newGameID;\r\n    tickRequiredLog(games[newGameID]);\r\n  }\r\n\r\n  function hit(uint256 gameID) onlyPlayer(gameID) blockActionProtected {\r\n    GameLib.Game game = games[gameID];\r\n    if (!game.tick()) throw;\r\n    game.playerDecision(GameLib.GameState.Hit);\r\n    tickRequiredLog(game);\r\n  }\r\n\r\n  function doubleDown(uint256 gameID) onlyPlayer(gameID) blockActionProtected payable {\r\n    GameLib.Game game = games[gameID];\r\n    if (!game.tick()) throw;\r\n    game.playerDecision(GameLib.GameState.DoubleDown);\r\n    tickRequiredLog(game);\r\n  }\r\n\r\n  function stand(uint256 gameID) onlyPlayer(gameID) blockActionProtected {\r\n    GameLib.Game game = games[gameID];\r\n    if (!game.tick()) throw;\r\n    game.playerDecision(GameLib.GameState.Stand);\r\n    tickRequiredLog(game);\r\n  }\r\n\r\n  function gameTick(uint256 gameID) blockActionProtected {\r\n    GameLib.Game openedGame = games[gameID];\r\n    if (openedGame.closed) throw;\r\n    if (!openedGame.tick()) throw;\r\n    if (openedGame.closed) recordEndedGame(gameID);\r\n  }\r\n\r\n  function recordEndedGame(uint gameID) private {\r\n    GameLib.Game openedGame = games[gameID];\r\n\r\n    //vs potential overflow when croupier is not ticking frequently enough\r\n    if(currentBankroll + openedGame.bet > openedGame.payout){\r\n      currentBankroll = currentBankroll + openedGame.bet - openedGame.payout;\r\n    }\r\n\r\n    GameEnded(\r\n\t      openedGame.gameID,\r\n\t      openedGame.player,\r\n\t      uint(openedGame.result),\r\n\t      openedGame.bet,\r\n\t      openedGame.payout,\r\n\t      GameLib.countHand(openedGame.playerCards),\r\n\t      GameLib.countHand(openedGame.houseCards)\r\n\t      );\r\n  }\r\n\r\n  function tickRequiredLog(GameLib.Game storage game) private {\r\n    GameNeedsTick(game.gameID, game.player, game.actionBlock);\r\n  }\r\n\r\n  // Constants\r\n\r\n  function gameState(uint i) constant returns (uint8[], uint8[], uint8, uint8, uint256, uint256, uint8, uint8, bool, uint256) {\r\n    GameLib.Game game = games[i];\r\n\r\n    return (\r\n\t    game.houseCards,\r\n\t    game.playerCards,\r\n\t    GameLib.countHand(game.houseCards),\r\n\t    GameLib.countHand(game.playerCards),\r\n\t    game.bet,\r\n\t    game.payout,\r\n\t    uint8(game.state),\r\n\t    uint8(game.result),\r\n\t    game.closed,\r\n\t    game.actionBlock\r\n\t    );\r\n  }\r\n\r\n\r\n  function changeDev(address newDev) only(DEV) {\r\n    isOwner[DEV] = false;\r\n    DEV = newDev;\r\n    isOwner[DEV] = true;\r\n  }\r\n\r\n  function changeDX(address newDX) only(DX) {\r\n    isOwner[DX] = false;\r\n    DX = newDX;\r\n    isOwner[DX] = true;\r\n  }\r\n\r\n  function setSettings(uint256 _min, uint256 _max, uint256 _maxBlockActions) only(DX) {\r\n    minBet = _min;\r\n    maxBet = _max;\r\n    maxBlockActions = _maxBlockActions;\r\n  }\r\n\r\n  function registerOwner(address _new_watcher) only(DX) {\r\n    isOwner[_new_watcher] = true;\r\n  }\r\n\r\n  function removeOwner(address _old_watcher) only(DX) {\r\n    isOwner[_old_watcher] = false;\r\n  }\r\n\r\n  function stopBlockjack() onlyOwner {\r\n    allowsNewGames = false;\r\n  }\r\n\r\n  function startBlockjack() only(DX) {\r\n    allowsNewGames = true;\r\n  }\r\n\r\n  function addBankroll() only(DX) payable {\r\n    initialBankroll += msg.value;\r\n    currentBankroll += msg.value;\r\n  }\r\n\r\n  function migrateBlockjack() only(DX) {\r\n    stopBlockjack();\r\n    shareProfits();\r\n    suicide(DX);\r\n  }\r\n\r\n  uint256 DX_PROFITS = 90;\r\n  uint256 DEV_PROFITS = 10;\r\n  uint256 PROFITS_BASE = 100;\r\n  \r\n  function shareProfits() onlyOwner{\r\n    if (currentBankroll <= initialBankroll) return; // there are no profits\r\n    uint256 profit = currentBankroll - initialBankroll;\r\n    uint256 notSent;\r\n    if (!DX.send(profit * DX_PROFITS / PROFITS_BASE)) {\r\n      notSent = profit * DX_PROFITS / PROFITS_BASE;\r\n    }\r\n    if (!DEV.send(profit * DEV_PROFITS / PROFITS_BASE)){\r\n      notSent = profit * DEV_PROFITS / PROFITS_BASE;\r\n    }\r\n    currentBankroll -= profit - notSent;\r\n  }\r\n\r\n\r\n  \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_new_watcher\",\"type\":\"address\"}],\"name\":\"registerOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addBankroll\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_old_watcher\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"shareProfits\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameID\",\"type\":\"uint256\"}],\"name\":\"doubleDown\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_min\",\"type\":\"uint256\"},{\"name\":\"_max\",\"type\":\"uint256\"},{\"name\":\"_maxBlockActions\",\"type\":\"uint256\"}],\"name\":\"setSettings\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"gameState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8[]\"},{\"name\":\"\",\"type\":\"uint8[]\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"migrateBlockjack\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopBlockjack\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"currentGame\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDev\",\"type\":\"address\"}],\"name\":\"changeDev\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameID\",\"type\":\"uint256\"}],\"name\":\"gameTick\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameID\",\"type\":\"uint256\"}],\"name\":\"stand\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentBankroll\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDX\",\"type\":\"address\"}],\"name\":\"changeDX\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBlockActions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEV\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DX\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startBlockjack\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startGame\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameID\",\"type\":\"uint256\"}],\"name\":\"hit\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowsNewGames\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialBankroll\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_DX\",\"type\":\"address\"},{\"name\":\"_DEV\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gameID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"gameResult\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"wager\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payout\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerHand\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"houseHand\",\"type\":\"uint8\"}],\"name\":\"GameEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gameID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"actionBlock\",\"type\":\"uint256\"}],\"name\":\"GameNeedsTick\",\"type\":\"event\"}]","ContractName":"Blockjack","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000c26a6dbf6b285145ca4f64397a521f8b5e49a790000000000000000000000000c26a6dbf6b285145ca4f64397a521f8b5e49a79","Library":"ArrayLib:cbf109aafdbdd2797aeea214cf3297b2361743f6;DeckLib:3ae855a405c9bd435a4ab226dd5c82e66a6b81bf;GameLib:4a0af9db6314e61013dd0c4b2de13d8a226b3b44","SwarmSource":"bzzr://98bd82430d1d8ba83ccfb6480cdb4bb0eba5da2529e643f7f5e3927f67e5f288"}]}