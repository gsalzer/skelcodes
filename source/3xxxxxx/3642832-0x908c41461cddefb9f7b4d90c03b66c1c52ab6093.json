{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\ncontract Rouleth\r\n{\r\n  //Game and Global Variables, Structure of gambles\r\n  address public developer;\r\n  uint8 public blockDelay; //nb of blocks to wait before spin\r\n  uint8 public blockExpiration; //nb of blocks before bet expiration (due to hash storage limits)\r\n  uint256 public maxGamble; //max gamble value manually set by config\r\n  uint256 public minGamble; //min gamble value manually set by config\r\n  uint public maxBetsPerBlock; //limits the number of bets per blocks to prevent miner cheating\r\n  uint nbBetsCurrentBlock; //counts the nb of bets in the block\r\n\r\n    \r\n  //Gambles\r\n  enum BetTypes{number, color, parity, dozen, column, lowhigh} \r\n  struct Gamble\r\n  {\r\n    address player;\r\n    bool spinned; //Was the rouleth spinned ?\r\n    bool win;\r\n    //Possible bet types\r\n    BetTypes betType;\r\n    uint8 input; //stores number, color, dozen or oddeven\r\n    uint256 wager;\r\n    uint256 blockNumber; //block of bet\r\n    uint256 blockSpinned; //block of spin\r\n    uint8 wheelResult;\r\n  }\r\n  Gamble[] private gambles;\r\n  uint public totalGambles; \r\n  //Tracking progress of players\r\n  mapping (address=>uint) gambleIndex; //current gamble index of the player\r\n  //records current status of player\r\n  enum Status {waitingForBet, waitingForSpin} mapping (address=>Status) playerStatus; \r\n\r\n\r\n  //**********************************************\r\n  //        Management & Config FUNCTIONS        //\r\n  //**********************************************\r\n\r\n  function  Rouleth() //creation settings\r\n  { \r\n    developer = msg.sender;\r\n    blockDelay=0; //indicates which block after bet will be used for RNG\r\n    blockExpiration=200; //delay after which gamble expires\r\n    minGamble=50 finney; //configurable min bet\r\n    maxGamble=750 finney; //configurable max bet\r\n    maxBetsPerBlock=5; // limit of bets per block, to prevent multiple bets per miners\r\n  }\r\n    \r\n  modifier onlyDeveloper() \r\n  {\r\n    if (msg.sender!=developer) throw;\r\n    _;\r\n  }\r\n\r\n  function addBankroll()\r\n    onlyDeveloper\r\n    payable {\r\n  }\r\n\r\n  function removeBankroll(uint256 _amount_wei)\r\n    onlyDeveloper\r\n  {\r\n    if (!developer.send(_amount_wei)) throw;\r\n  }\r\n    \r\n  function changeDeveloper_only_Dev(address new_dev)\r\n    onlyDeveloper\r\n  {\r\n    developer=new_dev;\r\n  }\r\n\r\n\r\n  //Activate, Deactivate Betting\r\n  enum States{active, inactive} States private contract_state;\r\n    \r\n  function disableBetting_only_Dev()\r\n    onlyDeveloper\r\n  {\r\n    contract_state=States.inactive;\r\n  }\r\n\r\n\r\n  function enableBetting_only_Dev()\r\n    onlyDeveloper\r\n  {\r\n    contract_state=States.active;\r\n\r\n  }\r\n    \r\n  modifier onlyActive()\r\n  {\r\n    if (contract_state==States.inactive) throw;\r\n    _;\r\n  }\r\n\r\n\r\n\r\n  //Change some settings within safety bounds\r\n  function changeSettings_only_Dev(uint newMaxBetsBlock, uint256 newMinGamble, uint256 newMaxGamble, uint8 newBlockDelay, uint8 newBlockExpiration)\r\n    onlyDeveloper\r\n  {\r\n    //Max number of bets per block to prevent miner cheating\r\n    maxBetsPerBlock=newMaxBetsBlock;\r\n    //MAX BET : limited by payroll/(casinoStatisticalLimit*35)\r\n    if (newMaxGamble<newMinGamble) throw;  \r\n    maxGamble=newMaxGamble; \r\n    minGamble=newMinGamble;\r\n    //Delay before spin :\r\n    blockDelay=newBlockDelay;\r\n    if (newBlockExpiration < blockDelay + 250) throw;\r\n    blockExpiration=newBlockExpiration;\r\n  }\r\n\r\n\r\n  //**********************************************\r\n  //                 BETTING FUNCTIONS                    //\r\n  //**********************************************\r\n\r\n  //***//basic betting without Mist or contract call\r\n  //activates when the player only sends eth to the contract\r\n  //without specifying any type of bet.\r\n  function ()\r\n    payable\r\n    {\r\n      //defaut bet : bet on red\r\n      betOnColor(false);\r\n    } \r\n\r\n  //***//Guarantees that gamble is under max bet and above min.\r\n  // returns bet value\r\n  function checkBetValue() private returns(uint256)\r\n  {\r\n    uint256 playerBetValue;\r\n    if (msg.value < minGamble) throw;\r\n    if (msg.value > maxGamble){\r\n      playerBetValue = maxGamble;\r\n    }\r\n    else{\r\n      playerBetValue=msg.value;\r\n    }\r\n    return playerBetValue;\r\n  }\r\n\r\n\r\n  //check number of bets in block (to prevent miner cheating)\r\n  modifier checkNbBetsCurrentBlock()\r\n  {\r\n    if (gambles.length!=0 && block.number==gambles[gambles.length-1].blockNumber) nbBetsCurrentBlock+=1;\r\n    else nbBetsCurrentBlock=0;\r\n    if (nbBetsCurrentBlock>=maxBetsPerBlock) throw;\r\n    _;\r\n  }\r\n\r\n\r\n  //Function record bet called by all others betting functions\r\n  function placeBet(BetTypes betType_, uint8 input_) private\r\n  {\r\n    if (playerStatus[msg.sender]!=Status.waitingForBet)\r\n      {\r\n\tSpinTheWheel(msg.sender);\r\n      }\r\n    //Once this is done, we can record the new bet\r\n    playerStatus[msg.sender]=Status.waitingForSpin;\r\n    gambleIndex[msg.sender]=gambles.length;\r\n    totalGambles++;\r\n    //adapts wager to casino limits\r\n    uint256 betValue = checkBetValue();\r\n    gambles.push(Gamble(msg.sender, false, false, betType_, input_, betValue, block.number, 0, 37)); //37 indicates not spinned yet\r\n    //refund excess bet (at last step vs re-entry)\r\n    if (betValue < msg.value) \r\n      {\r\n\tif (msg.sender.send(msg.value-betValue)==false) throw;\r\n      }\r\n  }\r\n\r\n\r\n  //***//bet on Number\t\r\n  function betOnNumber(uint8 numberChosen)\r\n    payable\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n  {\r\n    //check that number chosen is valid and records bet\r\n    if (numberChosen>36) throw;\r\n    placeBet(BetTypes.number, numberChosen);\r\n  }\r\n\r\n  //***// function betOnColor\r\n  //bet type : color\r\n  //input : 0 for red\r\n  //input : 1 for black\r\n  function betOnColor(bool Black)\r\n    payable\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n  {\r\n    uint8 input;\r\n    if (!Black) \r\n      { \r\n\tinput=0;\r\n      }\r\n    else{\r\n      input=1;\r\n    }\r\n    placeBet(BetTypes.color, input);\r\n  }\r\n\r\n  //***// function betOnLow_High\r\n  //bet type : lowhigh\r\n  //input : 0 for low\r\n  //input : 1 for low\r\n  function betOnLowHigh(bool High)\r\n    payable\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n  {\r\n    uint8 input;\r\n    if (!High) \r\n      { \r\n\tinput=0;\r\n      }\r\n    else \r\n      {\r\n\tinput=1;\r\n      }\r\n    placeBet(BetTypes.lowhigh, input);\r\n  }\r\n\r\n  //***// function betOnOddEven\r\n  //bet type : parity\r\n  //input : 0 for even\r\n  //input : 1 for odd\r\n  function betOnOddEven(bool Odd)\r\n    payable\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n  {\r\n    uint8 input;\r\n    if (!Odd) \r\n      { \r\n\tinput=0;\r\n      }\r\n    else{\r\n      input=1;\r\n    }\r\n    placeBet(BetTypes.parity, input);\r\n  }\r\n\r\n  //***// function betOnDozen\r\n  //     //bet type : dozen\r\n  //     //input : 0 for first dozen\r\n  //     //input : 1 for second dozen\r\n  //     //input : 2 for third dozen\r\n  function betOnDozen(uint8 dozen_selected_0_1_2)\r\n    payable\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n  {\r\n    if (dozen_selected_0_1_2 > 2) throw;\r\n    placeBet(BetTypes.dozen, dozen_selected_0_1_2);\r\n  }\r\n\r\n\r\n  // //***// function betOnColumn\r\n  //     //bet type : column\r\n  //     //input : 0 for first column\r\n  //     //input : 1 for second column\r\n  //     //input : 2 for third column\r\n  function betOnColumn(uint8 column_selected_0_1_2)\r\n    payable\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n  {\r\n    if (column_selected_0_1_2 > 2) throw;\r\n    placeBet(BetTypes.column, column_selected_0_1_2);\r\n  }\r\n\r\n  //**********************************************\r\n  // Spin The Wheel & Check Result FUNCTIONS//\r\n  //**********************************************\r\n\r\n  event Win(address player, uint8 result, uint value_won, bytes32 bHash, bytes32 sha3Player, uint gambleId, uint bet);\r\n  event Loss(address player, uint8 result, uint value_loss, bytes32 bHash, bytes32 sha3Player, uint gambleId, uint bet);\r\n\r\n  //***//function to spin callable\r\n  // no eth allowed\r\n  function spinTheWheel(address spin_for_player)\r\n  {\r\n    SpinTheWheel(spin_for_player);\r\n  }\r\n\r\n\r\n  function SpinTheWheel(address playerSpinned) private\r\n  {\r\n    if (playerSpinned==0)\r\n      {\r\n\tplayerSpinned=msg.sender;         //if no index spins for the sender\r\n      }\r\n\r\n    //check that player has to spin\r\n    if (playerStatus[playerSpinned]!=Status.waitingForSpin) throw;\r\n    //redundent double check : check that gamble has not been spinned already\r\n    if (gambles[gambleIndex[playerSpinned]].spinned==true) throw;\r\n    //check that the player waited for the delay before spin\r\n    //and also that the bet is not expired\r\n    uint playerblock = gambles[gambleIndex[playerSpinned]].blockNumber;\r\n    //too early to spin\r\n    if (block.number<=playerblock+blockDelay) throw;\r\n    //too late, bet expired, player lost\r\n    else if (block.number>playerblock+blockExpiration)  solveBet(playerSpinned, 255, false, 1, 0, 0) ;\r\n    //spin !\r\n    else\r\n      {\r\n\tuint8 wheelResult;\r\n\t//Spin the wheel, \r\n\tbytes32 blockHash= block.blockhash(playerblock+blockDelay);\r\n\t//security check that the Hash is not empty\r\n\tif (blockHash==0) throw;\r\n\t// generate the hash for RNG from the blockHash and the player's address\r\n\tbytes32 shaPlayer = sha3(playerSpinned, blockHash, this);\r\n\t// get the final wheel result\r\n\twheelResult = uint8(uint256(shaPlayer)%37);\r\n\t//check result against bet and pay if win\r\n\tcheckBetResult(wheelResult, playerSpinned, blockHash, shaPlayer);\r\n      }\r\n  }\r\n    \r\n\r\n  //CHECK BETS FUNCTIONS private\r\n  function checkBetResult(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n  {\r\n    BetTypes betType=gambles[gambleIndex[player]].betType;\r\n    //bet on Number\r\n    if (betType==BetTypes.number) checkBetNumber(result, player, blockHash, shaPlayer);\r\n    else if (betType==BetTypes.parity) checkBetParity(result, player, blockHash, shaPlayer);\r\n    else if (betType==BetTypes.color) checkBetColor(result, player, blockHash, shaPlayer);\r\n    else if (betType==BetTypes.lowhigh) checkBetLowhigh(result, player, blockHash, shaPlayer);\r\n    else if (betType==BetTypes.dozen) checkBetDozen(result, player, blockHash, shaPlayer);\r\n    else if (betType==BetTypes.column) checkBetColumn(result, player, blockHash, shaPlayer);\r\n  }\r\n\r\n  // function solve Bet once result is determined : sends to winner, adds loss to profit\r\n  function solveBet(address player, uint8 result, bool win, uint8 multiplier, bytes32 blockHash, bytes32 shaPlayer) private\r\n  {\r\n    //Update status and record spinned\r\n    playerStatus[player]=Status.waitingForBet;\r\n    gambles[gambleIndex[player]].wheelResult=result;\r\n    gambles[gambleIndex[player]].spinned=true;\r\n    gambles[gambleIndex[player]].blockSpinned=block.number;\r\n    uint bet_v = gambles[gambleIndex[player]].wager;\r\n\t\r\n    if (win)\r\n      {\r\n\tgambles[gambleIndex[player]].win=true;\r\n\tuint win_v = (multiplier-1)*bet_v;\r\n\tWin(player, result, win_v, blockHash, shaPlayer, gambleIndex[player], bet_v);\r\n\t//send win!\r\n\t//safe send vs potential callstack overflowed spins\r\n\tif (player.send(win_v+bet_v)==false) throw;\r\n      }\r\n    else\r\n      {\r\n\tLoss(player, result, bet_v-1, blockHash, shaPlayer, gambleIndex[player], bet_v);\r\n\t//send 1 wei to confirm spin if loss\r\n\tif (player.send(1)==false) throw;\r\n      }\r\n\r\n  }\r\n\r\n  // checkbeton number(input)\r\n  // bet type : number\r\n  // input : chosen number\r\n  function checkBetNumber(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n  {\r\n    bool win;\r\n    //win\r\n    if (result==gambles[gambleIndex[player]].input)\r\n      {\r\n\twin=true;  \r\n      }\r\n    solveBet(player, result,win,36, blockHash, shaPlayer);\r\n  }\r\n\r\n\r\n  // checkbet on oddeven\r\n  // bet type : parity\r\n  // input : 0 for even, 1 for odd\r\n  function checkBetParity(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n  {\r\n    bool win;\r\n    //win\r\n    if (result%2==gambles[gambleIndex[player]].input && result!=0)\r\n      {\r\n\twin=true;                \r\n      }\r\n    solveBet(player,result,win,2, blockHash, shaPlayer);\r\n  }\r\n    \r\n  // checkbet on lowhigh\r\n  // bet type : lowhigh\r\n  // input : 0 low, 1 high\r\n  function checkBetLowhigh(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n  {\r\n    bool win;\r\n    //win\r\n    if (result!=0 && ( (result<19 && gambles[gambleIndex[player]].input==0)\r\n\t\t       || (result>18 && gambles[gambleIndex[player]].input==1)\r\n\t\t       ) )\r\n      {\r\n\twin=true;\r\n      }\r\n    solveBet(player,result,win,2, blockHash, shaPlayer);\r\n  }\r\n\r\n  // checkbet on color\r\n  // bet type : color\r\n  // input : 0 red, 1 black\r\n  uint[18] red_list=[1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];\r\n  function checkBetColor(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n  {\r\n    bool red;\r\n    //check if red\r\n    for (uint8 k; k<18; k++)\r\n      { \r\n\tif (red_list[k]==result) \r\n\t  { \r\n\t    red=true; \r\n\t    break;\r\n\t  }\r\n      }\r\n    bool win;\r\n    //win\r\n    if ( result!=0\r\n\t && ( (gambles[gambleIndex[player]].input==0 && red)  \r\n\t      || ( gambles[gambleIndex[player]].input==1 && !red)  ) )\r\n      {\r\n\twin=true;\r\n      }\r\n    solveBet(player,result,win,2, blockHash, shaPlayer);\r\n  }\r\n\r\n  // checkbet on dozen\r\n  // bet type : dozen\r\n  // input : 0 first, 1 second, 2 third\r\n  function checkBetDozen(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n  { \r\n    bool win;\r\n    //win on first dozen\r\n    if ( result!=0 &&\r\n\t ( (result<13 && gambles[gambleIndex[player]].input==0)\r\n\t   ||\r\n\t   (result>12 && result<25 && gambles[gambleIndex[player]].input==1)\r\n\t   ||\r\n\t   (result>24 && gambles[gambleIndex[player]].input==2) ) )\r\n      {\r\n\twin=true;                \r\n      }\r\n    solveBet(player,result,win,3, blockHash, shaPlayer);\r\n  }\r\n\r\n  // checkbet on column\r\n  // bet type : column\r\n  // input : 0 first, 1 second, 2 third\r\n  function checkBetColumn(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n  {\r\n    bool win;\r\n    //win\r\n    if ( result!=0\r\n\t && ( (gambles[gambleIndex[player]].input==0 && result%3==1)  \r\n\t      || ( gambles[gambleIndex[player]].input==1 && result%3==2)\r\n\t      || ( gambles[gambleIndex[player]].input==2 && result%3==0)  ) )\r\n      {\r\n\twin=true;\r\n      }\r\n    solveBet(player,result,win,3, blockHash, shaPlayer);\r\n  }\r\n\r\n\r\n  function checkMyBet(address player) constant returns(Status player_status, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb, uint blockSpin, uint gambleID)\r\n  {\r\n    player_status=playerStatus[player];\r\n    bettype=gambles[gambleIndex[player]].betType;\r\n    input=gambles[gambleIndex[player]].input;\r\n    value=gambles[gambleIndex[player]].wager;\r\n    result=gambles[gambleIndex[player]].wheelResult;\r\n    wheelspinned=gambles[gambleIndex[player]].spinned;\r\n    win=gambles[gambleIndex[player]].win;\r\n    blockNb=gambles[gambleIndex[player]].blockNumber;\r\n    blockSpin=gambles[gambleIndex[player]].blockSpinned;\r\n    gambleID=gambleIndex[player];\r\n    return;\r\n  }\r\n    \r\n  function getGamblesList(uint256 index) constant returns(address player, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb, uint blockSpin)\r\n  {\r\n    player=gambles[index].player;\r\n    bettype=gambles[index].betType;\r\n    input=gambles[index].input;\r\n    value=gambles[index].wager;\r\n    result=gambles[index].wheelResult;\r\n    wheelspinned=gambles[index].spinned;\r\n    win=gambles[index].win;\r\n    blockNb=gambles[index].blockNumber;\r\n    blockSpin=gambles[index].blockSpinned;\r\n    return;\r\n  }\r\n\r\n} //end of contract","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"newMaxBetsBlock\",\"type\":\"uint256\"},{\"name\":\"newMinGamble\",\"type\":\"uint256\"},{\"name\":\"newMaxGamble\",\"type\":\"uint256\"},{\"name\":\"newBlockDelay\",\"type\":\"uint8\"},{\"name\":\"newBlockExpiration\",\"type\":\"uint8\"}],\"name\":\"changeSettings_only_Dev\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addBankroll\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount_wei\",\"type\":\"uint256\"}],\"name\":\"removeBankroll\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBetsPerBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"column_selected_0_1_2\",\"type\":\"uint8\"}],\"name\":\"betOnColumn\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"Black\",\"type\":\"bool\"}],\"name\":\"betOnColor\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableBetting_only_Dev\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minGamble\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"checkMyBet\",\"outputs\":[{\"name\":\"player_status\",\"type\":\"uint8\"},{\"name\":\"bettype\",\"type\":\"uint8\"},{\"name\":\"input\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint8\"},{\"name\":\"wheelspinned\",\"type\":\"bool\"},{\"name\":\"win\",\"type\":\"bool\"},{\"name\":\"blockNb\",\"type\":\"uint256\"},{\"name\":\"blockSpin\",\"type\":\"uint256\"},{\"name\":\"gambleID\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableBetting_only_Dev\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_dev\",\"type\":\"address\"}],\"name\":\"changeDeveloper_only_Dev\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxGamble\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"Odd\",\"type\":\"bool\"}],\"name\":\"betOnOddEven\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"High\",\"type\":\"bool\"}],\"name\":\"betOnLowHigh\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dozen_selected_0_1_2\",\"type\":\"uint8\"}],\"name\":\"betOnDozen\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"numberChosen\",\"type\":\"uint8\"}],\"name\":\"betOnNumber\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getGamblesList\",\"outputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"bettype\",\"type\":\"uint8\"},{\"name\":\"input\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint8\"},{\"name\":\"wheelspinned\",\"type\":\"bool\"},{\"name\":\"win\",\"type\":\"bool\"},{\"name\":\"blockNb\",\"type\":\"uint256\"},{\"name\":\"blockSpin\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"developer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockExpiration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalGambles\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockDelay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spin_for_player\",\"type\":\"address\"}],\"name\":\"spinTheWheel\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"value_won\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"sha3Player\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"gambleId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bet\",\"type\":\"uint256\"}],\"name\":\"Win\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"value_loss\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"sha3Player\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"gambleId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bet\",\"type\":\"uint256\"}],\"name\":\"Loss\",\"type\":\"event\"}]","ContractName":"Rouleth","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a940fd759973b961e86e2c6629cd894fdda095d50ca71d41e59dd68775765926"}]}