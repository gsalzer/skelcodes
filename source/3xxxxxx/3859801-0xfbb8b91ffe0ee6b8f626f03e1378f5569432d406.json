{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\n//solc --bin --abi --optimize  --optimize-runs 20000 -o . Testpool.sol \r\n\r\n\r\n//import \"./SHA3_512.sol\";\r\n\r\ncontract SHA3_512 {\r\n    function SHA3_512() {}\r\n    \r\n    function keccak_f(uint[25] A) constant internal returns(uint[25]) {\r\n        uint[5] memory C;\r\n        uint[5] memory D;\r\n        uint x;\r\n        uint y;\r\n        //uint D_0; uint D_1; uint D_2; uint D_3; uint D_4;\r\n        uint[25] memory B;\r\n        \r\n        uint[24] memory RC= [\r\n                   uint(0x0000000000000001),\r\n                   0x0000000000008082,\r\n                   0x800000000000808A,\r\n                   0x8000000080008000,\r\n                   0x000000000000808B,\r\n                   0x0000000080000001,\r\n                   0x8000000080008081,\r\n                   0x8000000000008009,\r\n                   0x000000000000008A,\r\n                   0x0000000000000088,\r\n                   0x0000000080008009,\r\n                   0x000000008000000A,\r\n                   0x000000008000808B,\r\n                   0x800000000000008B,\r\n                   0x8000000000008089,\r\n                   0x8000000000008003,\r\n                   0x8000000000008002,\r\n                   0x8000000000000080,\r\n                   0x000000000000800A,\r\n                   0x800000008000000A,\r\n                   0x8000000080008081,\r\n                   0x8000000000008080,\r\n                   0x0000000080000001,\r\n                   0x8000000080008008 ];\r\n        \r\n        for( uint i = 0 ; i < 24 ; i++ ) {\r\n            /*\r\n            for( x = 0 ; x < 5 ; x++ ) {\r\n                C[x] = A[5*x]^A[5*x+1]^A[5*x+2]^A[5*x+3]^A[5*x+4];                \r\n            }*/\r\n                       \r\n            C[0]=A[0]^A[1]^A[2]^A[3]^A[4];\r\n            C[1]=A[5]^A[6]^A[7]^A[8]^A[9];\r\n            C[2]=A[10]^A[11]^A[12]^A[13]^A[14];\r\n            C[3]=A[15]^A[16]^A[17]^A[18]^A[19];\r\n            C[4]=A[20]^A[21]^A[22]^A[23]^A[24];\r\n\r\n            /*\r\n            for( x = 0 ; x < 5 ; x++ ) {\r\n                D[x] = C[(x+4)%5]^((C[(x+1)%5] * 2)&0xffffffffffffffff | (C[(x+1)%5]/(2**63)));\r\n            }*/\r\n                        \r\n            \r\n            D[0]=C[4] ^ ((C[1] * 2)&0xffffffffffffffff | (C[1] / (2 ** 63)));\r\n            D[1]=C[0] ^ ((C[2] * 2)&0xffffffffffffffff | (C[2] / (2 ** 63)));\r\n            D[2]=C[1] ^ ((C[3] * 2)&0xffffffffffffffff | (C[3] / (2 ** 63)));\r\n            D[3]=C[2] ^ ((C[4] * 2)&0xffffffffffffffff | (C[4] / (2 ** 63)));\r\n            D[4]=C[3] ^ ((C[0] * 2)&0xffffffffffffffff | (C[0] / (2 ** 63)));\r\n\r\n            /*\r\n            for( x = 0 ; x < 5 ; x++ ) {\r\n                for( y = 0 ; y < 5 ; y++ ) {\r\n                    A[5*x+y] = A[5*x+y] ^ D[x];\r\n                }            \r\n            }*/\r\n            \r\n\r\n            \r\n            A[0]=A[0] ^ D[0];\r\n            A[1]=A[1] ^ D[0];\r\n            A[2]=A[2] ^ D[0];\r\n            A[3]=A[3] ^ D[0];\r\n            A[4]=A[4] ^ D[0];\r\n            A[5]=A[5] ^ D[1];\r\n            A[6]=A[6] ^ D[1];\r\n            A[7]=A[7] ^ D[1];\r\n            A[8]=A[8] ^ D[1];\r\n            A[9]=A[9] ^ D[1];\r\n            A[10]=A[10] ^ D[2];\r\n            A[11]=A[11] ^ D[2];\r\n            A[12]=A[12] ^ D[2];\r\n            A[13]=A[13] ^ D[2];\r\n            A[14]=A[14] ^ D[2];\r\n            A[15]=A[15] ^ D[3];\r\n            A[16]=A[16] ^ D[3];\r\n            A[17]=A[17] ^ D[3];\r\n            A[18]=A[18] ^ D[3];\r\n            A[19]=A[19] ^ D[3];\r\n            A[20]=A[20] ^ D[4];\r\n            A[21]=A[21] ^ D[4];\r\n            A[22]=A[22] ^ D[4];\r\n            A[23]=A[23] ^ D[4];\r\n            A[24]=A[24] ^ D[4];\r\n\r\n            /*Rho and pi steps*/            \r\n            B[0]=A[0];\r\n            B[8]=((A[1] * (2 ** 36))&0xffffffffffffffff | (A[1] / (2 ** 28)));\r\n            B[11]=((A[2] * (2 ** 3))&0xffffffffffffffff | (A[2] / (2 ** 61)));\r\n            B[19]=((A[3] * (2 ** 41))&0xffffffffffffffff | (A[3] / (2 ** 23)));\r\n            B[22]=((A[4] * (2 ** 18))&0xffffffffffffffff | (A[4] / (2 ** 46)));\r\n            B[2]=((A[5] * (2 ** 1))&0xffffffffffffffff | (A[5] / (2 ** 63)));\r\n            B[5]=((A[6] * (2 ** 44))&0xffffffffffffffff | (A[6] / (2 ** 20)));\r\n            B[13]=((A[7] * (2 ** 10))&0xffffffffffffffff | (A[7] / (2 ** 54)));\r\n            B[16]=((A[8] * (2 ** 45))&0xffffffffffffffff | (A[8] / (2 ** 19)));\r\n            B[24]=((A[9] * (2 ** 2))&0xffffffffffffffff | (A[9] / (2 ** 62)));\r\n            B[4]=((A[10] * (2 ** 62))&0xffffffffffffffff | (A[10] / (2 ** 2)));\r\n            B[7]=((A[11] * (2 ** 6))&0xffffffffffffffff | (A[11] / (2 ** 58)));\r\n            B[10]=((A[12] * (2 ** 43))&0xffffffffffffffff | (A[12] / (2 ** 21)));\r\n            B[18]=((A[13] * (2 ** 15))&0xffffffffffffffff | (A[13] / (2 ** 49)));\r\n            B[21]=((A[14] * (2 ** 61))&0xffffffffffffffff | (A[14] / (2 ** 3)));\r\n            B[1]=((A[15] * (2 ** 28))&0xffffffffffffffff | (A[15] / (2 ** 36)));\r\n            B[9]=((A[16] * (2 ** 55))&0xffffffffffffffff | (A[16] / (2 ** 9)));\r\n            B[12]=((A[17] * (2 ** 25))&0xffffffffffffffff | (A[17] / (2 ** 39)));\r\n            B[15]=((A[18] * (2 ** 21))&0xffffffffffffffff | (A[18] / (2 ** 43)));\r\n            B[23]=((A[19] * (2 ** 56))&0xffffffffffffffff | (A[19] / (2 ** 8)));\r\n            B[3]=((A[20] * (2 ** 27))&0xffffffffffffffff | (A[20] / (2 ** 37)));\r\n            B[6]=((A[21] * (2 ** 20))&0xffffffffffffffff | (A[21] / (2 ** 44)));\r\n            B[14]=((A[22] * (2 ** 39))&0xffffffffffffffff | (A[22] / (2 ** 25)));\r\n            B[17]=((A[23] * (2 ** 8))&0xffffffffffffffff | (A[23] / (2 ** 56)));\r\n            B[20]=((A[24] * (2 ** 14))&0xffffffffffffffff | (A[24] / (2 ** 50)));\r\n\r\n            /*Xi state*/\r\n            /*\r\n            for( x = 0 ; x < 5 ; x++ ) {\r\n                for( y = 0 ; y < 5 ; y++ ) {\r\n                    A[5*x+y] = B[5*x+y]^((~B[5*((x+1)%5)+y]) & B[5*((x+2)%5)+y]);\r\n                }\r\n            }*/\r\n            \r\n            \r\n            A[0]=B[0]^((~B[5]) & B[10]);\r\n            A[1]=B[1]^((~B[6]) & B[11]);\r\n            A[2]=B[2]^((~B[7]) & B[12]);\r\n            A[3]=B[3]^((~B[8]) & B[13]);\r\n            A[4]=B[4]^((~B[9]) & B[14]);\r\n            A[5]=B[5]^((~B[10]) & B[15]);\r\n            A[6]=B[6]^((~B[11]) & B[16]);\r\n            A[7]=B[7]^((~B[12]) & B[17]);\r\n            A[8]=B[8]^((~B[13]) & B[18]);\r\n            A[9]=B[9]^((~B[14]) & B[19]);\r\n            A[10]=B[10]^((~B[15]) & B[20]);\r\n            A[11]=B[11]^((~B[16]) & B[21]);\r\n            A[12]=B[12]^((~B[17]) & B[22]);\r\n            A[13]=B[13]^((~B[18]) & B[23]);\r\n            A[14]=B[14]^((~B[19]) & B[24]);\r\n            A[15]=B[15]^((~B[20]) & B[0]);\r\n            A[16]=B[16]^((~B[21]) & B[1]);\r\n            A[17]=B[17]^((~B[22]) & B[2]);\r\n            A[18]=B[18]^((~B[23]) & B[3]);\r\n            A[19]=B[19]^((~B[24]) & B[4]);\r\n            A[20]=B[20]^((~B[0]) & B[5]);\r\n            A[21]=B[21]^((~B[1]) & B[6]);\r\n            A[22]=B[22]^((~B[2]) & B[7]);\r\n            A[23]=B[23]^((~B[3]) & B[8]);\r\n            A[24]=B[24]^((~B[4]) & B[9]);\r\n\r\n            /*Last step*/\r\n            A[0]=A[0]^RC[i];            \r\n        }\r\n\r\n        \r\n        return A;\r\n    }\r\n \r\n    \r\n    function sponge(uint[9] M) constant internal returns(uint[16]) {\r\n        if( (M.length * 8) != 72 ) throw;\r\n        M[5] = 0x01;\r\n        M[8] = 0x8000000000000000;\r\n        \r\n        uint r = 72;\r\n        uint w = 8;\r\n        uint size = M.length * 8;\r\n        \r\n        uint[25] memory S;\r\n        uint i; uint y; uint x;\r\n        /*Absorbing Phase*/\r\n        for( i = 0 ; i < size/r ; i++ ) {\r\n            for( y = 0 ; y < 5 ; y++ ) {\r\n                for( x = 0 ; x < 5 ; x++ ) {\r\n                    if( (x+5*y) < (r/w) ) {\r\n                        S[5*x+y] = S[5*x+y] ^ M[i*9 + x + 5*y];\r\n                    }\r\n                }\r\n            }\r\n            S = keccak_f(S);\r\n        }\r\n\r\n        /*Squeezing phase*/\r\n        uint[16] memory result;\r\n        uint b = 0;\r\n        while( b < 16 ) {\r\n            for( y = 0 ; y < 5 ; y++ ) {\r\n                for( x = 0 ; x < 5 ; x++ ) {\r\n                    if( (x+5*y)<(r/w) && (b<16) ) {\r\n                        result[b] = S[5*x+y] & 0xFFFFFFFF; \r\n                        result[b+1] = S[5*x+y] / 0x100000000;\r\n                        b+=2;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n         \r\n        return result;\r\n   }\r\n\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\ncontract Ethash is SHA3_512 {\r\n    \r\n    mapping(address=>bool) public owners;\r\n    \r\n    function Ethash(address[3] _owners) {\r\n        owners[_owners[0]] = true;\r\n        owners[_owners[1]] = true;\r\n        owners[_owners[2]] = true;                \r\n    }\r\n     \r\n    function fnv( uint v1, uint v2 ) constant internal returns(uint) {\r\n        return ((v1*0x01000193) ^ v2) & 0xFFFFFFFF;\r\n    }\r\n\r\n\r\n\r\n    function computeCacheRoot( uint index,\r\n                               uint indexInElementsArray,\r\n                               uint[] elements,\r\n                               uint[] witness,\r\n                               uint branchSize ) constant private returns(uint) {\r\n \r\n                       \r\n        uint leaf = computeLeaf(elements, indexInElementsArray) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n        uint left;\r\n        uint right;\r\n        uint node;\r\n        bool oddBranchSize = (branchSize % 2) > 0;\r\n         \r\n        assembly {\r\n            branchSize := div(branchSize,2)\r\n            //branchSize /= 2;\r\n        }\r\n        uint witnessIndex = indexInElementsArray * branchSize;\r\n        if( oddBranchSize ) witnessIndex += indexInElementsArray;  \r\n\r\n        for( uint depth = 0 ; depth < branchSize ; depth++ ) {\r\n            assembly {\r\n                node := mload(add(add(witness,0x20),mul(add(depth,witnessIndex),0x20)))\r\n            }\r\n            //node  = witness[witnessIndex + depth] & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n            if( index & 0x1 == 0 ) {\r\n                left = leaf;\r\n                assembly{\r\n                    //right = node & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;                \r\n                    right := and(node,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                }\r\n                \r\n            }\r\n            else {\r\n                assembly{\r\n                    //left = node & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n                    left := and(node,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                }\r\n                right = leaf;\r\n            }\r\n            \r\n            leaf = uint(sha3(left,right)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n            assembly {\r\n                index := div(index,2) \r\n            }\r\n            //index = index / 2;\r\n\r\n            //node  = witness[witnessIndex + depth] / (2**128);\r\n            if( index & 0x1 == 0 ) {\r\n                left = leaf;\r\n                assembly{\r\n                    right := div(node,0x100000000000000000000000000000000)\r\n                    //right = node / 0x100000000000000000000000000000000;\r\n                }\r\n            }\r\n            else {\r\n                assembly {\r\n                    //left = node / 0x100000000000000000000000000000000;\r\n                    left := div(node,0x100000000000000000000000000000000)\r\n                }\r\n                right = leaf;\r\n            }\r\n            \r\n            leaf = uint(sha3(left,right)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n            assembly {\r\n                index := div(index,2) \r\n            }\r\n            //index = index / 2;\r\n        }\r\n        \r\n        if( oddBranchSize ) {\r\n            assembly {\r\n                node := mload(add(add(witness,0x20),mul(add(depth,witnessIndex),0x20)))\r\n            }\r\n        \r\n            //node  = witness[witnessIndex + depth] & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n            if( index & 0x1 == 0 ) {\r\n                left = leaf;\r\n                assembly{\r\n                    //right = node & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;                \r\n                    right := and(node,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                }                \r\n            }\r\n            else {\r\n                assembly{\r\n                    //left = node & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;                \r\n                    left := and(node,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                }\r\n            \r\n                right = leaf;\r\n            }\r\n            \r\n            leaf = uint(sha3(left,right)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;        \r\n        }\r\n        \r\n        \r\n        return leaf;\r\n    }\r\n\r\n    \r\n    function toBE( uint x ) constant internal returns(uint) {\r\n        uint y = 0;\r\n        for( uint i = 0 ; i < 32 ; i++ ) {\r\n            y = y * 256;\r\n            y += (x & 0xFF);\r\n            x = x / 256;            \r\n        }\r\n        \r\n        return y;\r\n        \r\n    }\r\n    \r\n    function computeSha3( uint[16] s, uint[8] cmix ) constant internal returns(uint) {\r\n        uint s0 = s[0] + s[1] * (2**32) + s[2] * (2**64) + s[3] * (2**96) +\r\n                  (s[4] + s[5] * (2**32) + s[6] * (2**64) + s[7] * (2**96))*(2**128);\r\n\r\n        uint s1 = s[8] + s[9] * (2**32) + s[10] * (2**64) + s[11] * (2**96) +\r\n                  (s[12] + s[13] * (2**32) + s[14] * (2**64) + s[15] * (2**96))*(2**128);\r\n                  \r\n        uint c = cmix[0] + cmix[1] * (2**32) + cmix[2] * (2**64) + cmix[3] * (2**96) +\r\n                  (cmix[4] + cmix[5] * (2**32) + cmix[6] * (2**64) + cmix[7] * (2**96))*(2**128);\r\n\r\n        \r\n        /* god knows why need to convert to big endian */\r\n        return uint( sha3(toBE(s0),toBE(s1),toBE(c)) );\r\n    }\r\n \r\n \r\n    function computeLeaf( uint[] dataSetLookup, uint index ) constant internal returns(uint) {\r\n        return uint( sha3(dataSetLookup[4*index],\r\n                          dataSetLookup[4*index + 1],\r\n                          dataSetLookup[4*index + 2],\r\n                          dataSetLookup[4*index + 3]) );\r\n                                    \r\n    }\r\n \r\n    function computeS( uint header, uint nonceLe ) constant internal returns(uint[16]) {\r\n        uint[9]  memory M;\r\n        \r\n        header = reverseBytes(header);\r\n        \r\n        M[0] = uint(header) & 0xFFFFFFFFFFFFFFFF;\r\n        header = header / 2**64;\r\n        M[1] = uint(header) & 0xFFFFFFFFFFFFFFFF;\r\n        header = header / 2**64;\r\n        M[2] = uint(header) & 0xFFFFFFFFFFFFFFFF;\r\n        header = header / 2**64;\r\n        M[3] = uint(header) & 0xFFFFFFFFFFFFFFFF;\r\n\r\n        // make little endian nonce\r\n        M[4] = nonceLe;\r\n        return sponge(M);\r\n    }\r\n    \r\n    function reverseBytes( uint input ) constant internal returns(uint) {\r\n        uint result = 0;\r\n        for(uint i = 0 ; i < 32 ; i++ ) {\r\n            result = result * 256;\r\n            result += input & 0xff;\r\n            \r\n            input /= 256;\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    struct EthashCacheOptData {\r\n        uint[512]    merkleNodes;\r\n        uint         fullSizeIn128Resultion;\r\n        uint         branchDepth;\r\n    }\r\n    \r\n    mapping(uint=>EthashCacheOptData) epochData;\r\n    \r\n    function getEpochData( uint epochIndex, uint nodeIndex ) constant returns(uint[3]) {\r\n        return [epochData[epochIndex].merkleNodes[nodeIndex],\r\n                epochData[epochIndex].fullSizeIn128Resultion,\r\n                epochData[epochIndex].branchDepth];\r\n    }\r\n    \r\n    function isEpochDataSet( uint epochIndex ) constant returns(bool) {\r\n        return epochData[epochIndex].fullSizeIn128Resultion != 0;\r\n    \r\n    }\r\n        \r\n    event SetEpochData( address indexed sender, uint error, uint errorInfo );    \r\n    function setEpochData( uint epoch,\r\n                           uint fullSizeIn128Resultion,\r\n                           uint branchDepth,\r\n                           uint[] merkleNodes,\r\n                           uint start,\r\n                           uint numElems ) {\r\n\r\n        if( ! owners[msg.sender] ) {\r\n            //ErrorLog( \"setEpochData: only owner can set data\", uint(msg.sender) );\r\n            SetEpochData( msg.sender, 0x82000000, uint(msg.sender) );\r\n            return;        \r\n        }                           \r\n                           \r\n        for( uint i = 0 ; i < numElems ; i++ ) {\r\n            if( epochData[epoch].merkleNodes[start+i] > 0 ) {\r\n                //ErrorLog(\"epoch already set\", epoch[i]);\r\n                SetEpochData( msg.sender, 0x82000001, epoch * (2**128) + start + i );\r\n                return;            \r\n\r\n            } \r\n            epochData[epoch].merkleNodes[start+i] = merkleNodes[i];\r\n        }\r\n        epochData[epoch].fullSizeIn128Resultion = fullSizeIn128Resultion;\r\n        epochData[epoch].branchDepth = branchDepth;\r\n        \r\n        SetEpochData( msg.sender, 0 , 0 );        \r\n    }\r\n\r\n    function getMerkleLeave( uint epochIndex, uint p ) constant internal returns(uint) {        \r\n        uint rootIndex = p >> epochData[epochIndex].branchDepth;\r\n        uint expectedRoot = epochData[epochIndex].merkleNodes[(rootIndex/2)];\r\n        if( (rootIndex % 2) == 0 ) expectedRoot = expectedRoot & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n        else expectedRoot = expectedRoot / (2**128);\r\n        \r\n        return expectedRoot;\r\n    }\r\n\r\n\r\n    function hashimoto( bytes32      header,\r\n                        bytes8       nonceLe,\r\n                        uint[]       dataSetLookup,\r\n                        uint[]       witnessForLookup,\r\n                        uint         epochIndex ) constant returns(uint) {\r\n         \r\n        uint[16] memory s;\r\n        uint[32] memory mix;\r\n        uint[8]  memory cmix;\r\n        \r\n        uint[2]  memory depthAndFullSize = [epochData[epochIndex].branchDepth, \r\n                                            epochData[epochIndex].fullSizeIn128Resultion];\r\n                \r\n        uint i;\r\n        uint j;\r\n        \r\n        if( ! isEpochDataSet( epochIndex ) ) return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE;\r\n        \r\n        if( depthAndFullSize[1] == 0 ) {\r\n            return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n        }\r\n\r\n        \r\n        s = computeS(uint(header), uint(nonceLe));\r\n        for( i = 0 ; i < 16 ; i++ ) {            \r\n            assembly {\r\n                let offset := mul(i,0x20)\r\n                \r\n                //mix[i] = s[i];\r\n                mstore(add(mix,offset),mload(add(s,offset)))\r\n                \r\n                // mix[i+16] = s[i];\r\n                mstore(add(mix,add(0x200,offset)),mload(add(s,offset)))    \r\n            }\r\n        }\r\n\r\n        for( i = 0 ; i < 64 ; i++ ) {\r\n            uint p = fnv( i ^ s[0], mix[i % 32]) % depthAndFullSize[1];\r\n            \r\n            \r\n            if( computeCacheRoot( p, i, dataSetLookup,  witnessForLookup, depthAndFullSize[0] )  != getMerkleLeave( epochIndex, p ) ) {\r\n            \r\n                // PoW failed\r\n                return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n            }       \r\n\r\n            for( j = 0 ; j < 8 ; j++ ) {\r\n\r\n                assembly{\r\n                    //mix[j] = fnv(mix[j], dataSetLookup[4*i] & varFFFFFFFF );\r\n                    let dataOffset := add(mul(0x80,i),add(dataSetLookup,0x20))\r\n                    let dataValue   := and(mload(dataOffset),0xFFFFFFFF)\r\n                    \r\n                    let mixOffset := add(mix,mul(0x20,j))\r\n                    let mixValue  := mload(mixOffset)\r\n                    \r\n                    // fnv = return ((v1*0x01000193) ^ v2) & 0xFFFFFFFF;\r\n                    let fnvValue := and(xor(mul(mixValue,0x01000193),dataValue),0xFFFFFFFF)                    \r\n                    mstore(mixOffset,fnvValue)\r\n                    \r\n                    //mix[j+8] = fnv(mix[j+8], dataSetLookup[4*i + 1] & 0xFFFFFFFF );\r\n                    dataOffset := add(dataOffset,0x20)\r\n                    dataValue   := and(mload(dataOffset),0xFFFFFFFF)\r\n                    \r\n                    mixOffset := add(mixOffset,0x100)\r\n                    mixValue  := mload(mixOffset)\r\n                    \r\n                    // fnv = return ((v1*0x01000193) ^ v2) & 0xFFFFFFFF;\r\n                    fnvValue := and(xor(mul(mixValue,0x01000193),dataValue),0xFFFFFFFF)                    \r\n                    mstore(mixOffset,fnvValue)\r\n\r\n                    //mix[j+16] = fnv(mix[j+16], dataSetLookup[4*i + 2] & 0xFFFFFFFF );\r\n                    dataOffset := add(dataOffset,0x20)\r\n                    dataValue   := and(mload(dataOffset),0xFFFFFFFF)\r\n                    \r\n                    mixOffset := add(mixOffset,0x100)\r\n                    mixValue  := mload(mixOffset)\r\n                    \r\n                    // fnv = return ((v1*0x01000193) ^ v2) & 0xFFFFFFFF;\r\n                    fnvValue := and(xor(mul(mixValue,0x01000193),dataValue),0xFFFFFFFF)                    \r\n                    mstore(mixOffset,fnvValue)\r\n\r\n                    //mix[j+24] = fnv(mix[j+24], dataSetLookup[4*i + 3] & 0xFFFFFFFF );\r\n                    dataOffset := add(dataOffset,0x20)\r\n                    dataValue   := and(mload(dataOffset),0xFFFFFFFF)\r\n                    \r\n                    mixOffset := add(mixOffset,0x100)\r\n                    mixValue  := mload(mixOffset)\r\n                    \r\n                    // fnv = return ((v1*0x01000193) ^ v2) & 0xFFFFFFFF;\r\n                    fnvValue := and(xor(mul(mixValue,0x01000193),dataValue),0xFFFFFFFF)                    \r\n                    mstore(mixOffset,fnvValue)                    \r\n                                        \r\n                }\r\n\r\n                \r\n                //mix[j] = fnv(mix[j], dataSetLookup[4*i] & 0xFFFFFFFF );\r\n                //mix[j+8] = fnv(mix[j+8], dataSetLookup[4*i + 1] & 0xFFFFFFFF );\r\n                //mix[j+16] = fnv(mix[j+16], dataSetLookup[4*i + 2] & 0xFFFFFFFF );                \r\n                //mix[j+24] = fnv(mix[j+24], dataSetLookup[4*i + 3] & 0xFFFFFFFF );\r\n                \r\n                \r\n                //dataSetLookup[4*i    ] = dataSetLookup[4*i    ]/(2**32);\r\n                //dataSetLookup[4*i + 1] = dataSetLookup[4*i + 1]/(2**32);\r\n                //dataSetLookup[4*i + 2] = dataSetLookup[4*i + 2]/(2**32);\r\n                //dataSetLookup[4*i + 3] = dataSetLookup[4*i + 3]/(2**32);                \r\n                \r\n                assembly{\r\n                    let offset := add(add(dataSetLookup,0x20),mul(i,0x80))\r\n                    let value  := div(mload(offset),0x100000000)\r\n                    mstore(offset,value)\r\n                                       \r\n                    offset := add(offset,0x20)\r\n                    value  := div(mload(offset),0x100000000)\r\n                    mstore(offset,value)\r\n                    \r\n                    offset := add(offset,0x20)\r\n                    value  := div(mload(offset),0x100000000)\r\n                    mstore(offset,value)                    \r\n                    \r\n                    offset := add(offset,0x20)\r\n                    value  := div(mload(offset),0x100000000)\r\n                    mstore(offset,value)                                                                                \r\n                }                \r\n            }\r\n        }\r\n        \r\n        \r\n        for( i = 0 ; i < 32 ; i += 4) {\r\n            cmix[i/4] = (fnv(fnv(fnv(mix[i], mix[i+1]), mix[i+2]), mix[i+3]));\r\n        }\r\n        \r\n\r\n        uint result = computeSha3(s,cmix); \r\n\r\n        return result;\r\n        \r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"header\",\"type\":\"bytes32\"},{\"name\":\"nonceLe\",\"type\":\"bytes8\"},{\"name\":\"dataSetLookup\",\"type\":\"uint256[]\"},{\"name\":\"witnessForLookup\",\"type\":\"uint256[]\"},{\"name\":\"epochIndex\",\"type\":\"uint256\"}],\"name\":\"hashimoto\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"epochIndex\",\"type\":\"uint256\"},{\"name\":\"nodeIndex\",\"type\":\"uint256\"}],\"name\":\"getEpochData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[3]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"epochIndex\",\"type\":\"uint256\"}],\"name\":\"isEpochDataSet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"epoch\",\"type\":\"uint256\"},{\"name\":\"fullSizeIn128Resultion\",\"type\":\"uint256\"},{\"name\":\"branchDepth\",\"type\":\"uint256\"},{\"name\":\"merkleNodes\",\"type\":\"uint256[]\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"numElems\",\"type\":\"uint256\"}],\"name\":\"setEpochData\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[3]\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"errorInfo\",\"type\":\"uint256\"}],\"name\":\"SetEpochData\",\"type\":\"event\"}]","ContractName":"Ethash","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f214dde57f32f3f34492ba3148641693058d4a9e000000000000000000000000c8a1dab586dee8a30cb88c87b8a3614e0a391fc50000000000000000000000002be2f917397bacfb3c939f6db3bee80aa606ae31","Library":"","SwarmSource":"bzzr://109d958a474ba203240e8fce81dfb9a50240ed3d531c7a6663a4f1f267a844f1"}]}