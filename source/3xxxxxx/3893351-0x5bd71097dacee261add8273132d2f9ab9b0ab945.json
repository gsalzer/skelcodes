{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\n\r\ncontract AbstractENS {\r\n    function owner(bytes32 node) constant returns(address);\r\n    function resolver(bytes32 node) constant returns(address);\r\n    function ttl(bytes32 node) constant returns(uint64);\r\n    function setOwner(bytes32 node, address owner);\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner);\r\n    function setResolver(bytes32 node, address resolver);\r\n    function setTTL(bytes32 node, uint64 ttl);\r\n}\r\n\r\n/**\r\n * A simple resolver intended for use with token contracts. Only allows the\r\n * owner of a node to set its address, and returns the ERC20 JSON ABI for all\r\n * ABI queries.\r\n * \r\n * Also acts as the registrar for 'thetoken.eth' to simplify setting up new tokens.\r\n */\r\ncontract TokenResolver {\r\n    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\r\n    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\r\n    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\r\n    bytes32 constant ROOT_NODE = 0x637f12e7cd6bed65eeceee34d35868279778fc56c3e5e951f46b801fb78a2d26;\r\n    bytes TOKEN_JSON_ABI = '[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"decimals\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"symbol\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"}]';\r\n    \r\n    event AddrChanged(bytes32 indexed node, address a);\r\n\r\n    AbstractENS ens = AbstractENS(0x314159265dD8dbb310642f98f50C066173C1259b);\r\n    mapping(bytes32=>address) addresses;\r\n    address owner;\r\n\r\n    modifier only_node_owner(bytes32 node) {\r\n        require(ens.owner(node) == msg.sender || owner == msg.sender);\r\n        _;\r\n    }\r\n    \r\n    modifier only_owner() {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n    \r\n    function setOwner(address newOwner) only_owner {\r\n        owner = newOwner;\r\n    }\r\n\r\n    function newToken(string name, address addr) only_owner {\r\n        var label = sha3(name);\r\n        var node = sha3(ROOT_NODE, name);\r\n        \r\n        ens.setSubnodeOwner(ROOT_NODE, label, this);\r\n        ens.setResolver(node, this);\r\n        addresses[node] = addr;\r\n        AddrChanged(node, addr);\r\n    }\r\n    \r\n    function setSubnodeOwner(bytes22 label, address newOwner) only_owner {\r\n        ens.setSubnodeOwner(ROOT_NODE, label, newOwner);\r\n    }\r\n\r\n    function TokenResolver() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the resolver implements the interface specified by the provided hash.\r\n     * @param interfaceID The ID of the interface to check for.\r\n     * @return True if the contract implements the requested interface.\r\n     */\r\n    function supportsInterface(bytes4 interfaceID) constant returns (bool) {\r\n        return interfaceID == ADDR_INTERFACE_ID ||\r\n               interfaceID == ABI_INTERFACE_ID ||\r\n               interfaceID == INTERFACE_META_ID;\r\n    }\r\n\r\n    /**\r\n     * Returns the address associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated address.\r\n     */\r\n    function addr(bytes32 node) constant returns (address ret) {\r\n        ret = addresses[node];\r\n    }\r\n\r\n    /**\r\n     * Sets the address associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param addr The address to set.\r\n     */\r\n    function setAddr(bytes32 node, address addr) only_node_owner(node) {\r\n        addresses[node] = addr;\r\n        AddrChanged(node, addr);\r\n    }\r\n\r\n    /**\r\n     * Returns the ABI associated with an ENS node.\r\n     * Defined in EIP205.\r\n     * @param node The ENS node to query\r\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\r\n     * @return contentType The content type of the return value\r\n     * @return data The ABI data\r\n     */\r\n    function ABI(bytes32 node, uint256 contentTypes) constant returns (uint256 contentType, bytes data) {\r\n        node;\r\n        if(contentTypes & 1 == 1) {\r\n            // JSON ABI\r\n            contentType = 1;\r\n            data = TOKEN_JSON_ABI;\r\n            return;\r\n        }\r\n        contentType = 0;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"node\",\"type\":\"bytes32\"},{\"name\":\"contentTypes\",\"type\":\"uint256\"}],\"name\":\"ABI\",\"outputs\":[{\"name\":\"contentType\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"addr\",\"outputs\":[{\"name\":\"ret\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"newToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"label\",\"type\":\"bytes22\"},{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setSubnodeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"node\",\"type\":\"bytes32\"},{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAddr\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"a\",\"type\":\"address\"}],\"name\":\"AddrChanged\",\"type\":\"event\"}]","ContractName":"TokenResolver","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4f6057505f820d2a0d654711ca53fe26a5b03a7851d1b64ecce9dd1c3e269372"}]}