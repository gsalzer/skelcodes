{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.10;\r\n\r\ncontract Token {\r\n    uint256 public totalSupply;\r\n\r\n    /* This creates an array with all balances */\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /* Send coins */\r\n    function transfer(address _to, uint256 _value) {\r\n        require(balanceOf[msg.sender] >= _value);            // Check if the sender has enough\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]);  // Check for overflows\r\n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\r\n        balanceOf[_to] += _value;                            // Add the same to the recipient\r\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\r\n    }\r\n\r\n    /* Allow another contract to spend some tokens in your behalf */\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    /* A contract attempts to get the coins */\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        require(balanceOf[_from] >= _value);                 // Check if the sender has enough\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]);  // Check for overflows\r\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n        balanceOf[_from] -= _value;                          // Subtract from the sender\r\n        balanceOf[_to] += _value;                            // Add the same to the recipient\r\n        allowance[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    uint public id; /* To ensure distinct contracts for different tokens owned by the same owner */\r\n    address public owner;\r\n    bool public sealed = false;\r\n\r\n    function Token(uint _id) {\r\n        owner = msg.sender;\r\n        id = _id;\r\n    }\r\n\r\n    /* Allows the owner to mint more tokens */\r\n    function mint(address _to, uint256 _value) returns (bool) {\r\n        require(msg.sender == owner);                        // Only the owner is allowed to mint\r\n        require(!sealed);                                    // Can only mint while unsealed\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]);  // Check for overflows\r\n        balanceOf[_to] += _value;\r\n        totalSupply += _value;\r\n        return true;\r\n    }\r\n\r\n    function seal() {\r\n        require(msg.sender == owner);\r\n        sealed = true;\r\n    }\r\n}\r\n\r\ncontract Withdraw {\r\n    Token public token;\r\n\r\n    function Withdraw(Token _token) {\r\n        token = _token;\r\n    }\r\n\r\n    function () payable {}\r\n\r\n    function withdraw() {\r\n        require(token.sealed());\r\n        require(token.balanceOf(msg.sender) > 0);\r\n        uint token_amount = token.balanceOf(msg.sender);\r\n        uint wei_amount = this.balance * token_amount / token.totalSupply();\r\n        if (!token.transferFrom(msg.sender, this, token_amount) || !msg.sender.send(wei_amount)) {\r\n            throw;\r\n        }\r\n    }\r\n}\r\n\r\ncontract TokenGame {\r\n    address public owner;\r\n    uint public cap_in_wei;\r\n    uint constant initial_duration = 1 hours;\r\n    uint constant time_extension_from_doubling = 1 hours;\r\n    uint constant time_of_half_decay = 1 hours;\r\n    Token public excess_token; /* Token contract used to receive excess after the sale */\r\n    Withdraw public excess_withdraw;  /* Withdraw contract distributing the excess */\r\n    Token public game_token;   /* Token contract used to receive prizes */\r\n    uint public end_time;      /* Current end time */\r\n    uint last_time = 0;        /* Timestamp of the latest contribution */\r\n    uint256 ema = 0;           /* Current value of the EMA */\r\n    uint public total_wei_given = 0;  /* Total amount of wei given via fallback function */\r\n\r\n    function TokenGame(uint _cap_in_wei) {\r\n        owner = msg.sender;\r\n        cap_in_wei = _cap_in_wei;\r\n        excess_token = new Token(1);\r\n        excess_withdraw = new Withdraw(excess_token);\r\n        game_token = new Token(2);\r\n        end_time = now + initial_duration;\r\n    }\r\n\r\n    function play() payable {\r\n        require(now <= end_time);   // Check that the sale has not ended\r\n        require(msg.value > 0);     // Check that something has been sent\r\n        total_wei_given += msg.value;\r\n        ema = msg.value + ema * time_of_half_decay / (time_of_half_decay + (now - last_time) );\r\n        last_time = now;\r\n        uint extended_time = now + ema * time_extension_from_doubling / total_wei_given;\r\n        if (extended_time > end_time) {\r\n            end_time = extended_time;\r\n        }\r\n        if (!excess_token.mint(msg.sender, msg.value) || !game_token.mint(msg.sender, msg.value)) {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function finalise() {\r\n        require(now > end_time);\r\n        excess_token.seal();\r\n        game_token.seal();\r\n        uint to_owner = 0;\r\n        if (this.balance > cap_in_wei) {\r\n            to_owner = cap_in_wei;\r\n            if (!excess_withdraw.send(this.balance - cap_in_wei)) {\r\n                throw;\r\n            }\r\n        } else {\r\n            to_owner = this.balance;\r\n        }\r\n        if (to_owner > 0) {\r\n            if (!owner.send(to_owner)) {\r\n                throw;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract ZeroCap is TokenGame {\r\n    Withdraw public game_withdraw;\r\n\r\n    function ZeroCap() TokenGame(0) {\r\n        game_withdraw = new Withdraw(game_token);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"game_withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"game_token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"end_time\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"excess_withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"play\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap_in_wei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalise\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"excess_token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_wei_given\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"}]","ContractName":"ZeroCap","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6af7e9572ab61f5b2c4bf4542624c4d1464e4c03079dadbe1404d95f495e277b"}]}