{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\ncontract KeberuntunganAcak {\r\n//##########################################################\r\n//##Payout ialah acak dan tidak mengikut antrian####\r\n//##Keacakan berdasarkan random hashblock oleh miner####\r\n//#### Deposit 0.05 ETHER + fee gas utk partisipasi ####\r\n//#### 2% dari 0.05 Ether akan diperuntukkan utk fee kepada owner ####\r\n//#### Jika transfer lebih dari 0.05Ether maka sisanya akan dikembalikan ####\r\n//###Jika beruntung maka bisa lgs dapat payout##########\r\n//###Jika gak beruntung maka harus wait ##########\r\n//###payout ialah 125% ##########\r\n//###payout ialah otomatis dan contract tidak dapat dimodif lagi setelah deploy oleh sesiapapun termasuk owner ##########\r\n//COPYRIGHT 2017 hadioneyesoneno\r\n//Edukasi dan eksperimen purpose only\r\n\r\n\r\n    address private owner;\r\n    \r\n    //Stored variables\r\n    uint private balance = 0;\r\n    uint private fee = 2;\r\n    uint private multiplier = 125;\r\n\r\n    mapping (address => User) private users;\r\n    Entry[] private entries;\r\n    uint[] private unpaidEntries;\r\n    \r\n    //Set owner on contract creation\r\n    function KeberuntunganAcak() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyowner { if (msg.sender == owner) _ ;}\r\n    \r\n    struct User {\r\n        address id;\r\n        uint deposits;\r\n        uint payoutsReceived;\r\n    }\r\n    \r\n    struct Entry {\r\n        address entryAddress;\r\n        uint deposit;\r\n        uint payout;\r\n        bool paid;\r\n    }\r\n\r\n    //Fallback function\r\n    function() {\r\n        init();\r\n    }\r\n    \r\n    function init() private{\r\n        \r\n        if (msg.value < 50 finney) {\r\n             (msg.sender.send(msg.value));\r\n            return;\r\n        }\r\n        \r\n        join();\r\n    }\r\n    \r\n    function join() public payable {\r\n        \r\n        //Limit deposits to 0.05ETH\r\n        uint dValue = 50 finney;\r\n        \r\n        if (msg.value > 50 finney) {\r\n            \r\n        \t(msg.sender.send(msg.value - 50 finney));\t\r\n        \tdValue = 50 finney;\r\n        }\r\n      \r\n        //Add new users to the users array\r\n        if (users[msg.sender].id == address(0))\r\n        {\r\n            users[msg.sender].id = msg.sender;\r\n            users[msg.sender].deposits = 0;\r\n            users[msg.sender].payoutsReceived = 0;\r\n        }\r\n        \r\n        //Add new entry to the entries array\r\n        entries.push(Entry(msg.sender, dValue, (dValue * (multiplier) / 100), false));\r\n        users[msg.sender].deposits++;\r\n        unpaidEntries.push(entries.length -1);\r\n        \r\n        //Collect fees and update contract balance\r\n        balance += (dValue * (100 - fee)) / 100;\r\n        \r\n        uint index = unpaidEntries.length > 1 ? rand(unpaidEntries.length) : 0;\r\n        Entry theEntry = entries[unpaidEntries[index]];\r\n        \r\n        //Pay pending entries if the new balance allows for it\r\n        if (balance > theEntry.payout) {\r\n            \r\n            uint payout = theEntry.payout;\r\n            \r\n            (theEntry.entryAddress.send(payout));\r\n            theEntry.paid = true;\r\n            users[theEntry.entryAddress].payoutsReceived++;\r\n\r\n            balance -= payout;\r\n            \r\n            if (index < unpaidEntries.length - 1)\r\n                unpaidEntries[index] = unpaidEntries[unpaidEntries.length - 1];\r\n           \r\n            unpaidEntries.length--;\r\n            \r\n        }\r\n        \r\n        //Collect money from fees and possible leftovers from errors (actual balance untouched)\r\n        uint fees = this.balance - balance;\r\n        if (fees > 0)\r\n        {\r\n                (owner.send(fees));\r\n        }      \r\n       \r\n    }\r\n    \r\n    //Generate random number between 0 & max\r\n    uint256 constant private FACTOR =  1157920892373161954235709850086879078532699846656405640394575840079131296399;\r\n    function rand(uint max) constant private returns (uint256 result){\r\n        uint256 factor = FACTOR * 100 / max;\r\n        uint256 lastBlockNumber = block.number - 1;\r\n        uint256 hashVal = uint256(block.blockhash(lastBlockNumber));\r\n    \r\n        return uint256((uint256(hashVal) / factor)) % max;\r\n    }\r\n    \r\n    \r\n    //Contract management\r\n    function changeOwner(address newOwner) onlyowner private {\r\n        owner = newOwner;\r\n    }\r\n    \r\n    function changeMultiplier(uint multi) onlyowner private {\r\n        if (multi < 110 || multi > 150) throw;\r\n        \r\n        multiplier = multi;\r\n    }\r\n    \r\n    function changeFee(uint newFee) onlyowner private {\r\n        if (fee > 2) \r\n            throw;\r\n        fee = newFee;\r\n    }\r\n    \r\n    \r\n    //JSON functions\r\n    function multiplierFactor() constant returns (uint factor, string info) {\r\n        factor = multiplier;\r\n        info = 'multipliyer ialah 125%'; \r\n    }\r\n    \r\n    function currentFee() constant returns (uint feePercentage, string info) {\r\n        feePercentage = fee;\r\n        info = 'fee ialah 2%.';\r\n    }\r\n    \r\n    function totalEntries() constant returns (uint count, string info) {\r\n        count = entries.length;\r\n        info = 'seberapa banyak deposit';\r\n    }\r\n    \r\n    function userStats(address user) constant returns (uint deposits, uint payouts, string info)\r\n    {\r\n        if (users[user].id != address(0x0))\r\n        {\r\n            deposits = users[user].deposits;\r\n            payouts = users[user].payoutsReceived;\r\n            info = 'Users stats: total deposits, payouts diterima.';\r\n        }\r\n    }\r\n    \r\n    function entryDetails(uint index) constant returns (address user, uint payout, bool paid, string info)\r\n    {\r\n        if (index < entries.length) {\r\n            user = entries[index].entryAddress;\r\n            payout = entries[index].payout / 1 finney;\r\n            paid = entries[index].paid;\r\n            info = 'Entry info: user address, expected payout in Finneys, payout status.';\r\n        }\r\n    }\r\n    \r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"multiplierFactor\",\"outputs\":[{\"name\":\"factor\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEntries\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userStats\",\"outputs\":[{\"name\":\"deposits\",\"type\":\"uint256\"},{\"name\":\"payouts\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"join\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentFee\",\"outputs\":[{\"name\":\"feePercentage\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"entryDetails\",\"outputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"payout\",\"type\":\"uint256\"},{\"name\":\"paid\",\"type\":\"bool\"},{\"name\":\"info\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"}]","ContractName":"KeberuntunganAcak","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2eb159159a2fe252b3bd7f8f1eca3d5f4af2860a52ce60542e8732c83885b563"}]}