{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  modifier onlyOwner() {\r\n    if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function transfer(address _to, uint _value) returns (bool success);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n  function approve(address _spender, uint _value) returns (bool success);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\ncontract FractionalERC20 is ERC20 {\r\n\r\n  uint public decimals;\r\n\r\n}\r\n\r\ncontract FinalizeAgent {\r\n\r\n  function isFinalizeAgent() public constant returns(bool) {\r\n    return true;\r\n  }\r\n\r\n\r\n  function isSane() public constant returns (bool);\r\n\r\n  function finalizeCrowdsale();\r\n\r\n}\r\n\r\ncontract PricingStrategy {\r\n\r\n  function isPricingStrategy() public constant returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  \r\n  function isSane(address crowdsale) public constant returns (bool) {\r\n    return true;\r\n  }\r\n\r\n \r\n  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\r\n}\r\n\r\n\r\ncontract SafeMathLib {\r\n\r\n  function safeMul(uint a, uint b) returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a);\r\n    return c;\r\n  }\r\n\r\n  function assert(bool assertion) private {\r\n    if (!assertion) throw;\r\n  }\r\n}\r\n\r\ncontract Haltable is Ownable {\r\n  bool public halted;\r\n\r\n  modifier stopInEmergency {\r\n    if (halted) throw;\r\n    _;\r\n  }\r\n\r\n  modifier onlyInEmergency {\r\n    if (!halted) throw;\r\n    _;\r\n  }\r\n\r\n  function halt() external onlyOwner {\r\n    halted = true;\r\n  }\r\n\r\n  function unhalt() external onlyOwner onlyInEmergency {\r\n    halted = false;\r\n  }\r\n\r\n}\r\n\r\ncontract Crowdsale is Haltable, SafeMathLib {\r\n\r\n \r\n  FractionalERC20 public token;\r\n\r\n  PricingStrategy public pricingStrategy;\r\n\r\n  FinalizeAgent public finalizeAgent;\r\n\r\n  address public multisigWallet;\r\n\r\n  uint public minimumFundingGoal;\r\n\r\n  uint public startsAt;\r\n\r\n  uint public endsAt;\r\n\r\n  uint public tokensSold = 0;\r\n\r\n  uint public weiRaised = 0;\r\n\r\n  uint public investorCount = 0;\r\n  uint public loadedRefund = 0;\r\n  uint public weiRefunded = 0;\r\n  bool public finalized;\r\n  bool public requireCustomerId;\r\n  bool public requiredSignedAddress;\r\n  address public signerAddress;\r\n  mapping (address => uint256) public investedAmountOf;\r\n  mapping (address => uint256) public tokenAmountOf;\r\n  mapping (address => bool) public earlyParticipantWhitelist;\r\n  uint public ownerTestValue;\r\n  enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\r\n  event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\r\n  event Refund(address investor, uint weiAmount);\r\n  event InvestmentPolicyChanged(bool requireCustomerId, bool requiredSignedAddress, address signerAddress);\r\n  event Whitelisted(address addr, bool status);\r\n  event EndsAtChanged(uint endsAt);\r\n\r\n  function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) {\r\n\r\n    owner = msg.sender;\r\n\r\n    token = FractionalERC20(_token);\r\n\r\n    setPricingStrategy(_pricingStrategy);\r\n\r\n    multisigWallet = _multisigWallet;\r\n    if(multisigWallet == 0) {\r\n        throw;\r\n    }\r\n\r\n    if(_start == 0) {\r\n        throw;\r\n    }\r\n\r\n    startsAt = _start;\r\n\r\n    if(_end == 0) {\r\n        throw;\r\n    }\r\n\r\n    endsAt = _end;\r\n    if(startsAt >= endsAt) {\r\n        throw;\r\n    }\r\n    minimumFundingGoal = _minimumFundingGoal;\r\n  }\r\n  function() payable {\r\n    throw;\r\n  }\r\n  function investInternal(address receiver, uint128 customerId) stopInEmergency private {\r\n    if(getState() == State.PreFunding) {\r\n      if(!earlyParticipantWhitelist[receiver]) {\r\n        throw;\r\n      }\r\n    } else if(getState() == State.Funding) {\r\n    } else {\r\n      throw;\r\n    }\r\n\r\n    uint weiAmount = msg.value;\r\n    uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\r\n\r\n    if(tokenAmount == 0) {\r\n      throw;\r\n    }\r\n\r\n    if(investedAmountOf[receiver] == 0) {\r\n       investorCount++;\r\n    }\r\n    investedAmountOf[receiver] = safeAdd(investedAmountOf[receiver],weiAmount);\r\n    tokenAmountOf[receiver] = safeAdd(tokenAmountOf[receiver],tokenAmount);\r\n    weiRaised = safeAdd(weiRaised,weiAmount);\r\n    tokensSold = safeAdd(tokensSold,tokenAmount);\r\n    if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\r\n      throw;\r\n    }\r\n\r\n    assignTokens(receiver, tokenAmount);\r\n    if(!multisigWallet.send(weiAmount)) throw;\r\n    Invested(receiver, weiAmount, tokenAmount, customerId);\r\n  }\r\n  function preallocate(address receiver, uint fullTokens, uint weiPrice) public onlyOwner {\r\n\r\n    uint tokenAmount = fullTokens * 10**token.decimals();\r\n    uint weiAmount = weiPrice * fullTokens;\r\n\r\n    weiRaised = safeAdd(weiRaised,weiAmount);\r\n    tokensSold = safeAdd(tokensSold,tokenAmount);\r\n\r\n    investedAmountOf[receiver] = safeAdd(investedAmountOf[receiver],weiAmount);\r\n    tokenAmountOf[receiver] = safeAdd(tokenAmountOf[receiver],tokenAmount);\r\n\r\n    assignTokens(receiver, tokenAmount);\r\n    Invested(receiver, weiAmount, tokenAmount, 0);\r\n  }\r\n  function investWithSignedAddress(address addr, uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\r\n     bytes32 hash = sha256(addr);\r\n     if (ecrecover(hash, v, r, s) != signerAddress) throw;\r\n     if(customerId == 0) throw;\r\n     investInternal(addr, customerId);\r\n  }\r\n  function investWithCustomerId(address addr, uint128 customerId) public payable {\r\n    if(requiredSignedAddress) throw;\r\n    if(customerId == 0) throw;\r\n    investInternal(addr, customerId);\r\n  }\r\n  function invest(address addr) public payable {\r\n    if(requireCustomerId) throw;\r\n    if(requiredSignedAddress) throw;\r\n    investInternal(addr, 0);\r\n  }\r\n  function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\r\n    investWithSignedAddress(msg.sender, customerId, v, r, s);\r\n  }\r\n  function buyWithCustomerId(uint128 customerId) public payable {\r\n    investWithCustomerId(msg.sender, customerId);\r\n  }\r\n  function buy() public payable {\r\n    invest(msg.sender);\r\n  }\r\n  function finalize() public inState(State.Success) onlyOwner stopInEmergency {\r\n    if(finalized) {\r\n      throw;\r\n    }\r\n    if(address(finalizeAgent) != 0) {\r\n      finalizeAgent.finalizeCrowdsale();\r\n    }\r\n\r\n    finalized = true;\r\n  }\r\n  function setFinalizeAgent(FinalizeAgent addr) onlyOwner {\r\n    finalizeAgent = addr;\r\n    if(!finalizeAgent.isFinalizeAgent()) {\r\n      throw;\r\n    }\r\n  }\r\n  function setRequireCustomerId(bool value) onlyOwner {\r\n    requireCustomerId = value;\r\n    InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\r\n  }\r\n  function setRequireSignedAddress(bool value, address _signerAddress) onlyOwner {\r\n    requiredSignedAddress = value;\r\n    signerAddress = _signerAddress;\r\n    InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\r\n  }\r\n  function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner {\r\n    earlyParticipantWhitelist[addr] = status;\r\n    Whitelisted(addr, status);\r\n  }\r\n  function setEndsAt(uint time) onlyOwner {\r\n\r\n    if(now > time) {\r\n      throw;\r\n    }\r\n\r\n    endsAt = time;\r\n    EndsAtChanged(endsAt);\r\n  }\r\n  function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner {\r\n    pricingStrategy = _pricingStrategy;\r\n    if(!pricingStrategy.isPricingStrategy()) {\r\n      throw;\r\n    }\r\n  }\r\n  function loadRefund() public payable inState(State.Failure) {\r\n    if(msg.value == 0) throw;\r\n    loadedRefund = safeAdd(loadedRefund,msg.value);\r\n  }\r\n  function refund() public inState(State.Refunding) {\r\n    uint256 weiValue = investedAmountOf[msg.sender];\r\n    if (weiValue == 0) throw;\r\n    investedAmountOf[msg.sender] = 0;\r\n    weiRefunded = safeAdd(weiRefunded,weiValue);\r\n    Refund(msg.sender, weiValue);\r\n    if (!msg.sender.send(weiValue)) throw;\r\n  }\r\n  function isMinimumGoalReached() public constant returns (bool reached) {\r\n    return weiRaised >= minimumFundingGoal;\r\n  }\r\n  function isFinalizerSane() public constant returns (bool sane) {\r\n    return finalizeAgent.isSane();\r\n  }\r\n  function isPricingSane() public constant returns (bool sane) {\r\n    return pricingStrategy.isSane(address(this));\r\n  }\r\n  function getState() public constant returns (State) {\r\n    if(finalized) return State.Finalized;\r\n    else if (address(finalizeAgent) == 0) return State.Preparing;\r\n    else if (!finalizeAgent.isSane()) return State.Preparing;\r\n    else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\r\n    else if (block.timestamp < startsAt) return State.PreFunding;\r\n    else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\r\n    else if (isMinimumGoalReached()) return State.Success;\r\n    else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\r\n    else return State.Failure;\r\n  }\r\n  function setOwnerTestValue(uint val) onlyOwner {\r\n    ownerTestValue = val;\r\n  }\r\n  function isCrowdsale() public constant returns (bool) {\r\n    return true;\r\n  }\r\n  modifier inState(State state) {\r\n    if(getState() != state) throw;\r\n    _;\r\n  }\r\n  function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken);\r\n  function isCrowdsaleFull() public constant returns (bool);\r\n  function assignTokens(address receiver, uint tokenAmount) private;\r\n}\r\n\r\n\r\n\r\ncontract EthTranchePricing is PricingStrategy, Ownable, SafeMathLib {\r\n\r\n  uint public constant MAX_TRANCHES = 10;\r\n  mapping (address => uint) public preicoAddresses;\r\n\r\n  struct Tranche {\r\n      uint amount;\r\n      uint price;\r\n  }\r\n  Tranche[10] public tranches;\r\n  uint public trancheCount;\r\n  function EthTranchePricing(uint[] _tranches) {\r\n    if(_tranches.length % 2 == 1 || _tranches.length >= MAX_TRANCHES*2) {\r\n      throw;\r\n    }\r\n\r\n    trancheCount = _tranches.length / 2;\r\n\r\n    uint highestAmount = 0;\r\n\r\n    for(uint i=0; i<_tranches.length/2; i++) {\r\n      tranches[i].amount = _tranches[i*2];\r\n      tranches[i].price = _tranches[i*2+1];\r\n      if((highestAmount != 0) && (tranches[i].amount <= highestAmount)) {\r\n        throw;\r\n      }\r\n\r\n      highestAmount = tranches[i].amount;\r\n    }\r\n    if(tranches[0].amount != 0) {\r\n      throw;\r\n    }\r\n    if(tranches[trancheCount-1].price != 0) {\r\n      throw;\r\n    }\r\n  }\r\n  function setPreicoAddress(address preicoAddress, uint pricePerToken)\r\n    public\r\n    onlyOwner\r\n  {\r\n    preicoAddresses[preicoAddress] = pricePerToken;\r\n  }\r\n  function getTranche(uint n) public constant returns (uint, uint) {\r\n    return (tranches[n].amount, tranches[n].price);\r\n  }\r\n\r\n  function getFirstTranche() private constant returns (Tranche) {\r\n    return tranches[0];\r\n  }\r\n\r\n  function getLastTranche() private constant returns (Tranche) {\r\n    return tranches[trancheCount-1];\r\n  }\r\n\r\n  function getPricingStartsAt() public constant returns (uint) {\r\n    return getFirstTranche().amount;\r\n  }\r\n\r\n  function getPricingEndsAt() public constant returns (uint) {\r\n    return getLastTranche().amount;\r\n  }\r\n\r\n  function isSane(address _crowdsale) public constant returns(bool) {\r\n    return true;\r\n  }\r\n  function getCurrentTranche(uint weiRaised) private constant returns (Tranche) {\r\n    uint i;\r\n\r\n    for(i=0; i < tranches.length; i++) {\r\n      if(weiRaised < tranches[i].amount) {\r\n        return tranches[i-1];\r\n      }\r\n    }\r\n  }\r\n  function getCurrentPrice(uint weiRaised) public constant returns (uint result) {\r\n    return getCurrentTranche(weiRaised).price;\r\n  }\r\n  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint) {\r\n\r\n    uint multiplier = 10 ** decimals;\r\n    if(preicoAddresses[msgSender] > 0) {\r\n      return safeMul(value,multiplier) / preicoAddresses[msgSender];\r\n    }\r\n\r\n    uint price = getCurrentPrice(weiRaised);\r\n    return safeMul(value,multiplier) / price;\r\n  }\r\n\r\n  function() payable {\r\n    throw;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"isPricingStrategy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"weiRaised\",\"type\":\"uint256\"},{\"name\":\"tokensSold\",\"type\":\"uint256\"},{\"name\":\"msgSender\",\"type\":\"address\"},{\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"calculatePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tranches\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPricingStartsAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trancheCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPricingEndsAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TRANCHES\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_crowdsale\",\"type\":\"address\"}],\"name\":\"isSane\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeSub\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"weiRaised\",\"type\":\"uint256\"}],\"name\":\"getCurrentPrice\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeMul\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"getTranche\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"preicoAddress\",\"type\":\"address\"},{\"name\":\"pricePerToken\",\"type\":\"uint256\"}],\"name\":\"setPreicoAddress\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"preicoAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tranches\",\"type\":\"uint256[]\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"}]","ContractName":"EthTranchePricing","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000025e546dd9aaaa0000000000000000000000000000000000000000000000a2a15d09519be000000000000000000000000000000000000000000000000000000002bb9c7ec013b100000000000000000000000000000000000000000000010f0cf064dd5920000000000000000000000000000000000000000000000000000000033ad038b4745d0000000000000000000000000000000000000000000001b1ae4d6e2ef50000000000000000000000000000000000000000000000000000000003622f785b86180000000000000000000000000000000000000000000006fceeff6681b2a0000000000000000000000000000000000000000000000000000000038d7ea4c680000000000000000000000000000000000000000000000422ca8b0a00a4250000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://e6249c3d59e8450063e7b3511eeea14a5241cffaf6c823c85e690b80ac800f94"}]}