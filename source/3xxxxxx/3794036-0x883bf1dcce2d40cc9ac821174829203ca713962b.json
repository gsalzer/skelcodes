{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\ncontract SmartRouletteToken \r\n{\r\n   uint8 public decimals;\r\n   function balanceOf( address who ) external constant returns (uint256);\r\n   function gameListOf( address who ) external constant returns (bool);\r\n   function getItemHolders(uint256 index) external constant returns(address);\r\n   function getCountHolders() external constant returns (uint256);\r\n   function getCountTempHolders() external constant returns(uint256);\r\n   function getItemTempHolders(uint256 index) external constant returns(address);\r\n   function tempTokensBalanceOf( address who ) external constant returns (uint256);\r\n   function transfer( address to, uint256 value) returns (bool ok);\r\n   function transferFrom( address from, address to, uint256 value) returns (bool ok);\r\n}\r\n\r\ncontract SmartRouletteTokenDividend {\r\n\r\n\taddress developer;\r\n\taddress manager;\r\n\r\n\tSmartRouletteToken smartToken;\r\n\tuint256 decimal;\r\n\r\n\tenum Status {Initialized, EthSentWaitingForTokens, TokensReceived, PaymentsSent}\r\n\r\n\tstruct DividendInfo\r\n\t{\r\n\t   uint256 amountDividend;\r\n\t   uint256 amountDividendInTokens;\r\n\t   uint256 blockDividend;\r\n\t   Status status;\r\n\t}\r\n\r\n\tDividendInfo[] dividendHistory;\r\n\r\n\taddress public gameAddress;\r\n\r\n\tuint256 public tokensNeededToGetPayment = 1000;\r\n\r\n\r\n\tfunction SmartRouletteTokenDividend() {\r\n\t\tdeveloper = msg.sender;\r\n\t\tmanager = msg.sender;\r\n\r\n\t\t// 0xC631333d0451e95E4F20940B04a68fa5602d5eAC\r\n\t\tsmartToken = SmartRouletteToken(0xcced5b8288086be8c38e23567e684c3740be4d48); //test 0xc46ed6ba652bd552671a46045b495748cd10fa04 main 0x2a650356bd894370cc1d6aba71b36c0ad6b3dc18\r\n\t\tdecimal = 10**uint256(smartToken.decimals());\t\r\n\t\t// 0x69000c5653F211164aE2b3Cc47a243db647F7EAb\t\r\n\t}\r\n\t\r\n\r\n\tmodifier isDeveloper(){\r\n\t\tif (msg.sender!=developer) throw;\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier isManager(){\r\n\t\tif (msg.sender!=manager && msg.sender!=developer) throw;\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction changeTokensLimit(uint256 newTokensLimit) isDeveloper\r\n\t{\r\n\t\ttokensNeededToGetPayment = newTokensLimit;\r\n\t}\r\n\tfunction dividendCount() constant returns(uint256)\r\n\t{\r\n\t\treturn dividendHistory.length;\r\n\t}\r\n\r\n\r\n\tfunction changeDeveloper(address new_developer)\r\n\tisDeveloper\r\n\t{\r\n\t\tif(new_developer == address(0x0)) throw;\r\n\t\tdeveloper = new_developer;\r\n\t}\r\n\r\n\tfunction changeManager(address new_manager)\r\n\tisDeveloper\r\n\t{\r\n\t\tif(new_manager == address(0x0)) throw;\r\n\t\tmanager = new_manager;\r\n\t}\r\n\r\n\tfunction kill() isDeveloper {\r\n\t\tsuicide(developer);\r\n\t}\r\n\r\n\tfunction getDividendInfo(uint256 index) constant returns(uint256 amountDividend, uint256 amountDividendInTokens, uint256 blockDividend, Status status)\r\n\t{\r\n\t\tamountDividend  = dividendHistory[index].amountDividend;\r\n\t\tamountDividendInTokens = dividendHistory[index].amountDividendInTokens;\r\n\t\tblockDividend   = dividendHistory[index].blockDividend;\r\n\t\tstatus = dividendHistory[index].status;\r\n\t}\r\n\r\n\r\n\t//  get total count tokens (to calculate profit for one token)\r\n\tfunction get_CountProfitsToken() constant returns(uint256)\r\n\t{\r\n\t\tuint256 countProfitsTokens = 0;\r\n\r\n        mapping(address => bool) uniqueHolders;\r\n\r\n\t\tuint256 countHolders = smartToken.getCountHolders();\r\n\t\tfor(uint256 i=0; i<countHolders; i++)\r\n\t\t{\r\n\t\t\taddress holder = smartToken.getItemHolders(i);\r\n\t\t\tif(holder!=address(0x0) && !uniqueHolders[holder])\r\n\t\t\t{\r\n\t\t\t\tuint256 holdersTokens = smartToken.balanceOf(holder);\r\n\t\t\t\tif(holdersTokens>0)\r\n\t\t\t\t{\r\n\t\t\t\t\tuint256 tempTokens = smartToken.tempTokensBalanceOf(holder);\r\n\t\t\t\t\tif((holdersTokens+tempTokens)/decimal >= tokensNeededToGetPayment)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tuniqueHolders[holder]=true;\r\n\t\t\t\t\t\tcountProfitsTokens += (holdersTokens+tempTokens);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tuint256 countTempHolders = smartToken.getCountTempHolders();\r\n\t\tfor(uint256 j=0; j<countTempHolders; j++)\r\n\t\t{\r\n\t\t\taddress temp_holder = smartToken.getItemTempHolders(j);\r\n\t\t\tif(temp_holder!=address(0x0) && !uniqueHolders[temp_holder])\r\n\t\t\t{\r\n\t\t\t\tuint256 token_balance = smartToken.balanceOf(temp_holder);\r\n\t\t\t\tif(token_balance==0)\r\n\t\t\t\t{\r\n\t\t\t\t\tuint256 count_tempTokens = smartToken.tempTokensBalanceOf(temp_holder);\r\n\t\t\t\t\tif(count_tempTokens>0 && count_tempTokens/decimal >= tokensNeededToGetPayment)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tuniqueHolders[temp_holder]=true;\r\n\t\t\t\t\t\tcountProfitsTokens += count_tempTokens;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn countProfitsTokens;\r\n\t}\r\n\r\n\tfunction get_CountAllHolderForProfit() constant returns(uint256){\r\n\t\tuint256 countAllHolders = 0;\r\n\r\n\t\tmapping(address => bool) uniqueHolders;\r\n\r\n\t\tuint256 countHolders = smartToken.getCountHolders();\r\n\t\tfor(uint256 i=0; i<countHolders; i++)\r\n\t\t{\r\n\t\t\taddress holder = smartToken.getItemHolders(i);\r\n\t\t\tif(holder!=address(0x0) && !uniqueHolders[holder])\r\n\t\t\t{\r\n\t\t\t\tuint256 holdersTokens = smartToken.balanceOf(holder);\r\n\t\t\t\tif(holdersTokens>0)\r\n\t\t\t\t{\r\n\t\t\t\t\tuint256 tempTokens = smartToken.tempTokensBalanceOf(holder);\r\n\t\t\t\t\tif((holdersTokens+tempTokens)/decimal >= tokensNeededToGetPayment)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tuniqueHolders[holder] = true;\r\n\t\t\t\t\t\tcountAllHolders += 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tuint256 countTempHolders = smartToken.getCountTempHolders();\r\n\t\tfor(uint256 j=0; j<countTempHolders; j++)\r\n\t\t{\r\n\t\t\taddress temp_holder = smartToken.getItemTempHolders(j);\r\n\t\t\tif(temp_holder!=address(0x0) && !uniqueHolders[temp_holder])\r\n\t\t\t{\r\n\t\t\t\tuint256 token_balance = smartToken.balanceOf(temp_holder);\r\n\t\t\t\tif(token_balance==0)\r\n\t\t\t\t{\r\n\t\t\t\t\tuint256 coun_tempTokens = smartToken.tempTokensBalanceOf(temp_holder);\r\n\t\t\t\t\tif(coun_tempTokens>0 && coun_tempTokens/decimal >= tokensNeededToGetPayment)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tuniqueHolders[temp_holder] = true;\r\n\t\t\t\t\t\tcountAllHolders += 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn countAllHolders;\r\n\t}\r\n\r\n\t// get holders addresses to make payment each of them\r\n\tfunction get_Holders(uint256 position) constant returns(address[64] listHolders, uint256 nextPosition) \r\n\t{\r\n\t\tuint8 n = 0;\t\t\r\n\t\tuint256 countHolders = smartToken.getCountHolders();\r\n\t\tfor(; position < countHolders; position++){\t\t\t\r\n\t\t\taddress holder = smartToken.getItemHolders(position);\r\n\t\t\tif(holder!=address(0x0)){\r\n\t\t\t\tuint256 holdersTokens = smartToken.balanceOf(holder);\r\n\t\t\t\tif(holdersTokens>0){\r\n\t\t\t\t\tuint256 tempTokens = smartToken.tempTokensBalanceOf(holder);\r\n\t\t\t\t\tif((holdersTokens+tempTokens)/decimal >= tokensNeededToGetPayment){\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tlistHolders[n++] = holder;\r\n\t\t\t\t\t\tif (n == 64) \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tnextPosition = position + 1;\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t\r\n\t\tif (position >= countHolders)\r\n\t\t{\t\t\t\r\n\t\t\tuint256 countTempHolders = smartToken.getCountTempHolders();\t\t\t\r\n\t\t\tfor(uint256 j=position-countHolders; j<countTempHolders; j++) \r\n\t\t\t{\t\t\t\t\t\t\t\r\n\t\t\t\taddress temp_holder = smartToken.getItemTempHolders(j);\r\n\t\t\t\tif(temp_holder!=address(0x0)){\r\n\t\t\t\t\tuint256 token_balance = smartToken.balanceOf(temp_holder);\r\n\t\t\t\t\tif(token_balance==0){\r\n\t\t\t\t\t\tuint256 count_tempTokens = smartToken.tempTokensBalanceOf(temp_holder);\r\n\t\t\t\t\t\tif(count_tempTokens>0 && count_tempTokens/decimal >= tokensNeededToGetPayment){\r\n\t\t\t\t\t\t\tlistHolders[n++] = temp_holder;\r\n\t\t\t\t\t\t\tif (n == 64) \r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tnextPosition = position + 1;\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tposition = position + 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tnextPosition = 0;\r\n\t}\r\n\r\n\tfunction get_HoldersProfit(address holder, uint256 amountDividendInTokens) constant returns(uint256){\r\n\t\tuint256 profit = 0;\r\n\t\tif(holder != address(0x0) && amountDividendInTokens > 0)\r\n\t\t{\r\n\t\t\tuint256 count_tokens = smartToken.balanceOf(holder) + smartToken.tempTokensBalanceOf(holder);\r\n\t\t\tif(count_tokens/decimal >= tokensNeededToGetPayment){\r\n\t\t\t\tprofit = (count_tokens * amountDividendInTokens) / get_CountProfitsToken();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn profit;\r\n\t}\r\n\r\n\tfunction takeEthForExchange(uint256 dividendPaymentNum) isManager \r\n\t{\r\n\t\tif (dividendHistory[dividendPaymentNum].status == Status.Initialized)\r\n\t\t{\r\n\t\t\tif (manager.send(dividendHistory[dividendPaymentNum].amountDividend) == false) throw;\r\n\t\t\tdividendHistory[dividendPaymentNum].status = Status.EthSentWaitingForTokens;\r\n\t\t}\t\t\r\n\t}\r\n\r\n\tfunction receiveTokens(uint256 dividendPaymentNum,uint256 tokens) isManager\r\n\t{\r\n\t\tif (tokens == 0) throw;\r\n\r\n\t\tif (dividendHistory[dividendPaymentNum].status == Status.EthSentWaitingForTokens)\r\n\t\t{\r\n\t\t\tif (!smartToken.transferFrom(msg.sender, this, tokens)) throw;\r\n\r\n\t\t\tdividendHistory[dividendPaymentNum].amountDividendInTokens = tokens;\r\n\r\n\t\t\tdividendHistory[dividendPaymentNum].status = Status.TokensReceived;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction send_DividendToAddress(address holder, uint256 amount) isManager \r\n\t{\r\n\t\tif (!smartToken.transfer(holder, amount)) throw;\r\n\t}\r\n\r\n\tfunction paymentsFinished(uint256 dividendPaymentNum) isManager\r\n\t{\r\n\t\tif (dividendHistory[dividendPaymentNum].status == Status.TokensReceived) \r\n\t\t{\r\n\t\t\tdividendHistory[dividendPaymentNum].status = Status.PaymentsSent;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction () payable\r\n\t{\r\n\t\tif(smartToken.gameListOf(msg.sender))\r\n\t\t{\r\n\t\t\t// only the one game can be attached to this contract\r\n\t\t\tif (gameAddress == 0) \r\n\t\t\t\tgameAddress = msg.sender;\r\n\t\t\telse if (gameAddress != msg.sender)\r\n\t\t\t\tthrow;\r\n\r\n\t\t\tdividendHistory.push(DividendInfo(msg.value, 0, block.number, Status.Initialized));\t\t\t\r\n\t\t}\r\n\t\telse \r\n\t\t{\r\n\t\t\tthrow;\r\n\t\t}\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"tokensNeededToGetPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getDividendInfo\",\"outputs\":[{\"name\":\"amountDividend\",\"type\":\"uint256\"},{\"name\":\"amountDividendInTokens\",\"type\":\"uint256\"},{\"name\":\"blockDividend\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_CountProfitsToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"holder\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"send_DividendToAddress\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_developer\",\"type\":\"address\"}],\"name\":\"changeDeveloper\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dividendPaymentNum\",\"type\":\"uint256\"}],\"name\":\"paymentsFinished\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTokensLimit\",\"type\":\"uint256\"}],\"name\":\"changeTokensLimit\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"position\",\"type\":\"uint256\"}],\"name\":\"get_Holders\",\"outputs\":[{\"name\":\"listHolders\",\"type\":\"address[64]\"},{\"name\":\"nextPosition\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dividendPaymentNum\",\"type\":\"uint256\"}],\"name\":\"takeEthForExchange\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividendCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"holder\",\"type\":\"address\"},{\"name\":\"amountDividendInTokens\",\"type\":\"uint256\"}],\"name\":\"get_HoldersProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_manager\",\"type\":\"address\"}],\"name\":\"changeManager\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_CountAllHolderForProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dividendPaymentNum\",\"type\":\"uint256\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"receiveTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"}]","ContractName":"SmartRouletteTokenDividend","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://49db8fdf2874163b5af618876fac6cf58b3c98097439f4da196fe32ff251ec48"}]}