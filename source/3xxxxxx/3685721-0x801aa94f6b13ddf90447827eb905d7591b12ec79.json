{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.9;\r\n\r\ncontract PeerBet {\r\n    enum GameStatus { Open, Locked, Scored, Verified }\r\n    // BookType.None exists because parsing a log index for a value of 0 \r\n    // returns all values. It should not be used.\r\n    enum BookType { None, Spread, MoneyLine, OverUnder }\r\n    enum BetStatus { Open, Paid }\r\n\r\n    // indexing on a string causes issues with web3, so category has to be an int\r\n    event GameCreated(bytes32 indexed id, address indexed creator, string home, \r\n        string away, uint16 indexed category, uint64 locktime);\r\n    event BidPlaced(bytes32 indexed game_id, BookType book, \r\n        address bidder, uint amount, bool home, int32 line);\r\n    event BetPlaced(bytes32 indexed game_id, BookType indexed book, \r\n        address indexed user, bool home, uint amount, int32 line);\r\n    event GameScored(bytes32 indexed game_id, int homeScore, int awayScore, uint timestamp);\r\n    event GameVerified(bytes32 indexed game_id);\r\n    event Withdrawal(address indexed user, uint amount, uint timestamp);\r\n\r\n    struct Bid {\r\n        address bidder;\r\n        uint amount; /* in wei */\r\n        bool home; /* true=home, false=away */\r\n        int32 line;\r\n    }\r\n\r\n    struct Bet {\r\n        address home;\r\n        address away;\r\n        uint amount; /* in wei */\r\n        int32 line;\r\n        BetStatus status;\r\n    }\r\n\r\n    struct Book {\r\n        Bid[] homeBids;\r\n        Bid[] awayBids;\r\n        Bet[] bets;\r\n    }\r\n\r\n    struct GameResult {\r\n        int home;\r\n        int away;\r\n        uint timestamp; // when the game was scored\r\n    }\r\n\r\n    struct Game {\r\n        bytes32 id;\r\n        address creator;\r\n        string home;\r\n        string away;\r\n        uint16 category;\r\n        uint64 locktime;\r\n        GameStatus status;\r\n        mapping(uint => Book) books;\r\n        GameResult result;\r\n    }\r\n\r\n    address public owner;\r\n    Game[] games;\r\n    mapping(address => uint) public balances;\r\n\r\n    function PeerBet() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\tfunction createGame (string home, string away, uint16 category, uint64 locktime) returns (int) {\r\n        bytes32 id = getGameId(msg.sender, home, away, category, locktime);\r\n        Game memory game = Game(id, msg.sender, home, away, category, locktime, GameStatus.Open, GameResult(0,0,0));\r\n        games.push(game);\r\n        GameCreated(id, game.creator, home, away, category, locktime);\r\n        return -1;\r\n    }\r\n    \r\n    function cancelOpenBids(Book storage book) private returns (int) {\r\n        for (uint i=0; i < book.homeBids.length; i++) {\r\n            Bid bid = book.homeBids[i];\r\n            if (bid.amount == 0)\r\n                continue;\r\n            balances[bid.bidder] += bid.amount;\r\n        }\r\n        delete book.homeBids;\r\n        for (i=0; i < book.awayBids.length; i++) {\r\n            bid = book.awayBids[i];\r\n            if (bid.amount == 0)\r\n                continue;\r\n            balances[bid.bidder] += bid.amount;\r\n        }\r\n        delete book.awayBids;\r\n\r\n        return -1;\r\n    }\r\n\r\n    function cancelBets(Book storage book, BookType book_type) private returns (int) {\r\n        for (uint i=0; i < book.bets.length; i++) {\r\n            Bet bet = book.bets[i];\r\n            if (bet.status == BetStatus.Paid)\r\n                continue;\r\n            uint awayBetAmount;\r\n            if (book_type == BookType.MoneyLine) {\r\n                if (bet.line < 0)\r\n                    awayBetAmount = bet.amount * 100 / uint(bet.line);\r\n                else\r\n                    awayBetAmount = bet.amount * uint(bet.line) / 100;\r\n            }\r\n            else\r\n                awayBetAmount = bet.amount;\r\n            balances[bet.home] += bet.amount;\r\n            balances[bet.away] += awayBetAmount;\r\n        }\r\n        delete book.bets;\r\n\r\n        return -1;\r\n    }\r\n\r\n    function deleteGame(bytes32 game_id) returns (int) {\r\n        Game game = getGameById(game_id);\r\n        if (msg.sender != game.creator && (game.locktime + 86400*4) > now) return 1;\r\n\r\n        for (uint i=1; i < 4; i++) {\r\n            Book book = game.books[i];\r\n            cancelOpenBids(book);\r\n            cancelBets(book, BookType(i));\r\n        }\r\n        for (i=0; i < games.length; i++) {\r\n            if (games[i].id == game_id) {\r\n                games[i] = games[games.length - 1];\r\n                games.length -= 1;\r\n                break;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    function payBets(bytes32 game_id) private returns (int) {\r\n        Game game = getGameById(game_id);\r\n\r\n        Bet[] spreadBets = game.books[uint(BookType.Spread)].bets;\r\n        Bet[] moneyLineBets = game.books[uint(BookType.MoneyLine)].bets;\r\n        Bet[] overUnderBets = game.books[uint(BookType.OverUnder)].bets;\r\n\r\n        // Spread\r\n        int resultSpread = game.result.away - game.result.home;\r\n        resultSpread *= 10; // because bet.line is 10x the actual line\r\n        for (uint i = 0; i < spreadBets.length; i++) {\r\n            Bet bet = spreadBets[i];\r\n            if (bet.status == BetStatus.Paid)\r\n                continue;\r\n            if (resultSpread > bet.line) \r\n                balances[bet.away] += bet.amount * 2;\r\n            else if (resultSpread < bet.line)\r\n                balances[bet.home] += bet.amount * 2;\r\n            else { // draw\r\n                balances[bet.away] += bet.amount;\r\n                balances[bet.home] += bet.amount;\r\n            }\r\n            bet.status = BetStatus.Paid;\r\n        }\r\n\r\n        // MoneyLine\r\n        bool tie = game.result.home == game.result.away;\r\n        bool homeWin = game.result.home > game.result.away;\r\n        for (i=0; i < moneyLineBets.length; i++) {\r\n            bet = moneyLineBets[i];\r\n            if (bet.status == BetStatus.Paid)\r\n                continue;\r\n            uint awayAmount;\r\n            if (bet.line < 0)\r\n                awayAmount = bet.amount * 100 / uint(-bet.line);\r\n            else\r\n                awayAmount = bet.amount * uint(bet.line) / 100;\r\n            if (tie) {\r\n                balances[bet.home] += bet.amount;\r\n                balances[bet.away] += awayAmount;\r\n            }\r\n            else if (homeWin)\r\n                balances[bet.home] += (bet.amount + awayAmount);\r\n            else\r\n                balances[bet.away] += (bet.amount + awayAmount);\r\n            bet.status = BetStatus.Paid;\r\n        }\r\n\r\n        // OverUnder - bet.line is 10x the actual line to allow half-point spreads\r\n        int totalPoints = (game.result.home + game.result.away) * 10;\r\n        for (i=0; i < overUnderBets.length; i++) {\r\n            bet = overUnderBets[i];\r\n            if (bet.status == BetStatus.Paid)\r\n                continue;\r\n            if (totalPoints > bet.line)\r\n                balances[bet.home] += bet.amount * 2;\r\n            else if (totalPoints < bet.line)\r\n                balances[bet.away] += bet.amount * 2;\r\n            else {\r\n                balances[bet.away] += bet.amount;\r\n                balances[bet.home] += bet.amount;\r\n            }\r\n            bet.status = BetStatus.Paid;\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    function verifyGameResult(bytes32 game_id) returns (int) {\r\n        Game game = getGameById(game_id);\r\n        if (msg.sender != game.creator) return 1;\r\n        if (game.status != GameStatus.Scored) return 2;\r\n        if (now < game.result.timestamp + 12*3600) return 3; // must wait 12 hours to verify \r\n\r\n        payBets(game_id);\r\n        game.status = GameStatus.Verified;\r\n        GameVerified(game_id);\r\n\r\n        return -1;\r\n    }\r\n\r\n    function setGameResult(bytes32 game_id, int homeScore, int awayScore) returns (int) {\r\n        Game game = getGameById(game_id);\r\n        if (msg.sender != game.creator) return 1;\r\n        if (game.locktime > now) return 2;\r\n        if (game.status == GameStatus.Verified) return 3;\r\n\r\n        for (uint i = 1; i < 4; i++)\r\n            cancelOpenBids(game.books[i]);\r\n\r\n        game.result.home = homeScore;\r\n        game.result.away = awayScore;\r\n        game.result.timestamp = now;\r\n        game.status = GameStatus.Scored;\r\n        GameScored(game_id, homeScore, awayScore, now);\r\n\r\n        return -1;\r\n    }\r\n\r\n    // line is actually 10x the line to allow for half-point spreads\r\n    function bid(bytes32 game_id, BookType book_type, bool home, int32 line) payable returns (int) {\r\n        if (book_type == BookType.None)\r\n            return 5;\r\n\r\n        Game game = getGameById(game_id);\r\n        Book book = game.books[uint(book_type)];\r\n        Bid memory bid = Bid(msg.sender, msg.value, home, line);\r\n\r\n        // validate inputs: game status, gametime, line amount\r\n        if (game.status != GameStatus.Open)\r\n            return 1;\r\n        if (now > game.locktime) {\r\n            game.status = GameStatus.Locked;    \r\n            for (uint i = 1; i < 4; i++)\r\n                cancelOpenBids(game.books[i]);\r\n            return 2;\r\n        }\r\n        if ((book_type == BookType.Spread || book_type == BookType.OverUnder)\r\n            && line % 5 != 0)\r\n            return 3;\r\n        else if (book_type == BookType.MoneyLine && line < 100 && line >= -100)\r\n            return 4;\r\n\r\n        Bid memory remainingBid = matchExistingBids(bid, game_id, book_type);\r\n\r\n        // Use leftover funds to place open bids (maker)\r\n        if (bid.amount > 0) {\r\n            Bid[] bidStack = home ? book.homeBids : book.awayBids;\r\n            if (book_type == BookType.OverUnder && home)\r\n                addBidToStack(remainingBid, bidStack, true);\r\n            else\r\n                addBidToStack(remainingBid, bidStack, false);\r\n            BidPlaced(game_id, book_type, remainingBid.bidder, remainingBid.amount, home, line);\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    // returning an array of structs is not allowed, so its time for a hackjob\r\n    // that returns a raw bytes dump of the combined home and away bids\r\n    // clients will have to parse the hex dump to get the bids out\r\n    // This function is for DEBUGGING PURPOSES ONLY. Using it in a production\r\n    // setting will return very large byte arrays that will consume your bandwidth\r\n    // if you are not running a full node  \r\n    function getOpenBids(bytes32 game_id, BookType book_type) constant returns (bytes) {\r\n        Game game = getGameById(game_id);\r\n        Book book = game.books[uint(book_type)];\r\n        uint nBids = book.homeBids.length + book.awayBids.length;\r\n        bytes memory s = new bytes(57 * nBids);\r\n        uint k = 0;\r\n        for (uint i=0; i < nBids; i++) {\r\n            if (i < book.homeBids.length)\r\n                Bid bid = book.homeBids[i];\r\n            else\r\n                bid = book.awayBids[i - book.homeBids.length];\r\n            bytes20 bidder = bytes20(bid.bidder);\r\n            bytes32 amount = bytes32(bid.amount);\r\n            byte home = bid.home ? byte(1) : byte(0);\r\n            bytes4 line = bytes4(bid.line);\r\n\r\n            for (uint j=0; j < 20; j++) { s[k] = bidder[j]; k++; }\r\n            for (j=0; j < 32; j++) { s[k] = amount[j]; k++; }\r\n            s[k] = home; k++;\r\n            for (j=0; j < 4; j++) { s[k] = line[j]; k++; }\r\n\r\n        }\r\n\r\n        return s;\r\n    }\r\n\r\n    // for functions throwing a stack too deep error, this helper will free up 2 local variable spots\r\n    function getBook(bytes32 game_id, BookType book_type) constant private returns (Book storage) {\r\n        Game game = getGameById(game_id);\r\n        Book book = game.books[uint(book_type)];\r\n        return book;\r\n    }\r\n\r\n    \r\n    // for over/under bids, the home boolean is equivalent to the over\r\n    function matchExistingBids(Bid bid, bytes32 game_id, BookType book_type) private returns (Bid) {\r\n        Book book = getBook(game_id, book_type);\r\n        bool home = bid.home;\r\n        Bid[] matchStack = home ?  book.awayBids : book.homeBids;\r\n        int i = int(matchStack.length) - 1;\r\n        while (i >= 0 && bid.amount > 0) {\r\n            uint j = uint(i);\r\n            if (matchStack[j].amount == 0) { // deleted bids\r\n                i--;\r\n                continue;\r\n            }\r\n            if (book_type == BookType.OverUnder) {\r\n                if (home && bid.line < matchStack[j].line \r\n                || !home && bid.line > matchStack[j].line)\r\n                break;\r\n            }\r\n            else if (-bid.line < matchStack[j].line)\r\n                break;\r\n\r\n            // determined required bet amount to match stack bid\r\n            uint requiredBet;\r\n            if (book_type == BookType.Spread || book_type == BookType.OverUnder)\r\n                requiredBet = matchStack[j].amount;\r\n            else if (matchStack[j].line > 0) { // implied MoneyLine\r\n                requiredBet = matchStack[j].amount * uint(matchStack[j].line) / 100;\r\n            }\r\n            else { // implied MoneyLine and negative line\r\n                requiredBet = matchStack[j].amount * 100 / uint(-matchStack[j].line);\r\n            }\r\n\r\n            // determine bet amounts on both sides\r\n            uint betAmount;\r\n            uint opposingBetAmount;\r\n            if (bid.amount < requiredBet) {\r\n                betAmount = bid.amount;\r\n                if (book_type == BookType.Spread || book_type == BookType.OverUnder)\r\n                    opposingBetAmount = bid.amount;\r\n                else if (matchStack[j].line > 0)\r\n                    opposingBetAmount = betAmount * 100 / uint(matchStack[j].line);\r\n                else\r\n                    opposingBetAmount = bid.amount * uint(-matchStack[j].line) / 100;\r\n            }\r\n            else {\r\n                betAmount = requiredBet;\r\n                opposingBetAmount = matchStack[j].amount;\r\n            }\r\n            bid.amount -= betAmount;\r\n            matchStack[j].amount -= opposingBetAmount;\r\n\r\n            int32 myLine;\r\n            if (book_type == BookType.OverUnder)\r\n                myLine = matchStack[j].line;\r\n            else\r\n                myLine = -matchStack[j].line;\r\n            Bet memory bet = Bet(\r\n                home ? bid.bidder : matchStack[j].bidder,\r\n                home ? matchStack[j].bidder : bid.bidder,\r\n                home ? betAmount : opposingBetAmount,\r\n                home ? myLine : matchStack[j].line,\r\n                BetStatus.Open\r\n            );\r\n            book.bets.push(bet);\r\n            BetPlaced(game_id, book_type, bid.bidder, home, betAmount, myLine);\r\n            BetPlaced(game_id, book_type, matchStack[j].bidder, \r\n                !home, opposingBetAmount, matchStack[j].line);\r\n            i--;\r\n        }\r\n        return bid;\r\n    }\r\n\r\n    function cancelBid(bytes32 game_id, BookType book_type, int32 line, bool home) returns (int) {\r\n        Book book = getBook(game_id, book_type);\r\n        Bid[] stack = home ? book.homeBids : book.awayBids;\r\n        address bidder = msg.sender;\r\n\r\n        // Delete bid in stack, refund amount to user\r\n        for (uint i=0; i < stack.length; i++) {\r\n            if (stack[i].amount > 0 && stack[i].bidder == bidder && stack[i].line == line) {\r\n                balances[bidder] += stack[i].amount;\r\n                delete stack[i];\r\n                return -1;\r\n            }\r\n        }\r\n        return 1;\r\n    }\r\n\r\n    function kill () {\r\n        if (msg.sender == owner) selfdestruct(owner);\r\n    }\r\n\r\n    function getGameId (address creator, string home, string away, uint16 category, uint64 locktime) constant returns (bytes32) {\r\n        uint i = 0;\r\n        bytes memory a = bytes(home);\r\n        bytes memory b = bytes(away);\r\n        bytes2 c = bytes2(category);\r\n        bytes8 d = bytes8(locktime);\r\n        bytes20 e = bytes20(creator);\r\n\r\n        uint length = a.length + b.length + c.length + d.length + e.length;\r\n        bytes memory toHash = new bytes(length);\r\n        uint k = 0;\r\n        for (i = 0; i < a.length; i++) { toHash[k] = a[i]; k++; }\r\n        for (i = 0; i < b.length; i++) { toHash[k] = b[i]; k++; }\r\n        for (i = 0; i < c.length; i++) { toHash[k] = c[i]; k++; }\r\n        for (i = 0; i < d.length; i++) { toHash[k] = d[i]; k++; }\r\n        for (i = 0; i < e.length; i++) { toHash[k] = e[i]; k++; }\r\n        return sha3(toHash);\r\n    }\r\n    \r\n    function getActiveGames () constant returns (bytes32[]) {\r\n        bytes32[] memory game_ids = new bytes32[](games.length);\r\n        for (uint i=0; i < games.length; i++) {\r\n            game_ids[i] = (games[i].id);\r\n        }\r\n        return game_ids;\r\n    }\r\n        \r\n    function addBidToStack(Bid bid, Bid[] storage stack, bool reverse) private returns (int) {\r\n        if (stack.length == 0) {\r\n            stack.push(bid);\r\n            return -1;\r\n        }\r\n        \r\n        // determine position of new bid in stack\r\n        uint insertIndex = stack.length;\r\n        if (reverse) {\r\n            while (insertIndex > 0 && bid.line <= stack[insertIndex-1].line)\r\n                insertIndex--;\r\n        }\r\n        else {\r\n            while (insertIndex > 0 && bid.line >= stack[insertIndex-1].line)\r\n                insertIndex--;\r\n        }\r\n        \r\n        // try to find deleted slot to fill\r\n        if (insertIndex > 0 && stack[insertIndex - 1].amount == 0) {\r\n            stack[insertIndex - 1] = bid;\r\n            return -1;\r\n        }\r\n        uint shiftEndIndex = insertIndex;\r\n        while (shiftEndIndex < stack.length && stack[shiftEndIndex].amount > 0) {\r\n            shiftEndIndex++;\r\n        }\r\n        \r\n        // shift bids down (up to deleted index if one exists)\r\n        if (shiftEndIndex == stack.length)\r\n            stack.length += 1;\r\n        for (uint i = shiftEndIndex; i > insertIndex; i--) {\r\n            stack[i] = stack[i-1];\r\n        } \r\n\r\n        stack[insertIndex] = bid;\r\n        \r\n\r\n        return -1;\r\n    }\r\n\r\n    function getGameById(bytes32 game_id) constant private returns (Game storage) {\r\n        bool game_exists = false;\r\n        for (uint i = 0; i < games.length; i++) {\r\n            if (games[i].id == game_id) {\r\n                Game game = games[i];\r\n                game_exists = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!game_exists)\r\n            throw;\r\n        return game;\r\n    }\r\n\r\n\r\n    function withdraw() returns (int) {\r\n        var balance = balances[msg.sender];\r\n        balances[msg.sender] = 0;\r\n        if (!msg.sender.send(balance)) {\r\n            balances[msg.sender] = balance;\r\n            return 1;\r\n        }\r\n        Withdrawal(msg.sender, balance, now);\r\n        return -1;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getActiveGames\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"game_id\",\"type\":\"bytes32\"},{\"name\":\"book_type\",\"type\":\"uint8\"},{\"name\":\"home\",\"type\":\"bool\"},{\"name\":\"line\",\"type\":\"int32\"}],\"name\":\"bid\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"game_id\",\"type\":\"bytes32\"}],\"name\":\"verifyGameResult\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"home\",\"type\":\"string\"},{\"name\":\"away\",\"type\":\"string\"},{\"name\":\"category\",\"type\":\"uint16\"},{\"name\":\"locktime\",\"type\":\"uint64\"}],\"name\":\"getGameId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"game_id\",\"type\":\"bytes32\"}],\"name\":\"deleteGame\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"game_id\",\"type\":\"bytes32\"},{\"name\":\"book_type\",\"type\":\"uint8\"}],\"name\":\"getOpenBids\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"home\",\"type\":\"string\"},{\"name\":\"away\",\"type\":\"string\"},{\"name\":\"category\",\"type\":\"uint16\"},{\"name\":\"locktime\",\"type\":\"uint64\"}],\"name\":\"createGame\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"game_id\",\"type\":\"bytes32\"},{\"name\":\"book_type\",\"type\":\"uint8\"},{\"name\":\"line\",\"type\":\"int32\"},{\"name\":\"home\",\"type\":\"bool\"}],\"name\":\"cancelBid\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"game_id\",\"type\":\"bytes32\"},{\"name\":\"homeScore\",\"type\":\"int256\"},{\"name\":\"awayScore\",\"type\":\"int256\"}],\"name\":\"setGameResult\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"home\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"away\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"category\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"locktime\",\"type\":\"uint64\"}],\"name\":\"GameCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"game_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"book\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"home\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"line\",\"type\":\"int32\"}],\"name\":\"BidPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"game_id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"book\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"home\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"line\",\"type\":\"int32\"}],\"name\":\"BetPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"game_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"homeScore\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"awayScore\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"GameScored\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"game_id\",\"type\":\"bytes32\"}],\"name\":\"GameVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"}]","ContractName":"PeerBet","CompilerVersion":"v0.4.9+commit.364da425","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5b6e0c98b6df76051f0b9c8fe116bddda3f6e4202d6a633617c425cc3424357d"}]}