{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n/*\r\n\r\nStatus Buyer\r\n========================\r\n\r\nBuys Status tokens from the crowdsale on your behalf.\r\nAuthor: /u/Cintix\r\n\r\n*/\r\n\r\n// ERC20 Interface: https://github.com/ethereum/EIPs/issues/20\r\ncontract ERC20 {\r\n  function transfer(address _to, uint256 _value) returns (bool success);\r\n  function balanceOf(address _owner) constant returns (uint256 balance);\r\n}\r\n\r\n// Interface to Status ICO Contract\r\ncontract StatusContribution {\r\n  uint256 public totalNormalCollected;\r\n  function proxyPayment(address _th) payable returns (bool);\r\n}\r\n\r\n// Interface to Status Cap Determination Contract\r\ncontract DynamicCeiling {\r\n  function curves(uint currentIndex) returns (bytes32 hash, \r\n                                              uint256 limit, \r\n                                              uint256 slopeFactor, \r\n                                              uint256 collectMinimum);\r\n  uint256 public currentIndex;\r\n  uint256 public revealedCurves;\r\n}\r\n\r\ncontract StatusBuyer {\r\n  // Store the amount of ETH deposited by each account.\r\n  mapping (address => uint256) public deposits;\r\n  // Track the amount of SNT each account's \"buy\" calls have purchased from the ICO.\r\n  // Allows tracking which accounts would have made it into the ICO on their own.\r\n  mapping (address => uint256) public purchased_snt;\r\n  // Bounty for executing buy.\r\n  uint256 public bounty;\r\n  // Track whether the contract has started buying tokens yet.\r\n  bool public bought_tokens;\r\n  \r\n  // The Status Token Sale address.\r\n  StatusContribution public sale = StatusContribution(0x0);\r\n  // The Status DynamicCeiling Contract address.\r\n  DynamicCeiling public dynamic = DynamicCeiling(0x0);\r\n  // Status Network Token (SNT) Contract address.\r\n  ERC20 public token = ERC20(0x0);\r\n  // The developer address.\r\n  address developer = 0x4e6A1c57CdBfd97e8efe831f8f4418b1F2A09e6e;\r\n  \r\n  // Withdraws all ETH/SNT owned by the user in the ratio currently owned by the contract.\r\n  function withdraw() {\r\n    // Store the user's deposit prior to withdrawal in a temporary variable.\r\n    uint256 user_deposit = deposits[msg.sender];\r\n    // Update the user's deposit prior to sending ETH to prevent recursive call.\r\n    deposits[msg.sender] = 0;\r\n    // Retrieve current ETH balance of contract (less the bounty).\r\n    uint256 contract_eth_balance = this.balance - bounty;\r\n    // Retrieve current SNT balance of contract.\r\n    uint256 contract_snt_balance = token.balanceOf(address(this));\r\n    // Calculate total SNT value of ETH and SNT owned by the contract.\r\n    // 1 ETH Wei -> 10000 SNT Wei\r\n    uint256 contract_value = (contract_eth_balance * 10000) + contract_snt_balance;\r\n    // Calculate amount of ETH to withdraw.\r\n    uint256 eth_amount = (user_deposit * contract_eth_balance * 10000) / contract_value;\r\n    // Calculate amount of SNT to withdraw.\r\n    uint256 snt_amount = 10000 * ((user_deposit * contract_snt_balance) / contract_value);\r\n    // No fee for withdrawing if user would have made it into the crowdsale alone.\r\n    uint256 fee = 0;\r\n    // 1% fee on portion of tokens user would not have been able to buy alone.\r\n    if (purchased_snt[msg.sender] < snt_amount) {\r\n      fee = (snt_amount - purchased_snt[msg.sender]) / 100;\r\n    }\r\n    // Send the funds.  Throws on failure to prevent loss of funds.\r\n    if(!token.transfer(msg.sender, snt_amount - fee)) throw;\r\n    if(!token.transfer(developer, fee)) throw;\r\n    msg.sender.transfer(eth_amount);\r\n  }\r\n  \r\n  // Allow anyone to contribute to the buy execution bounty.\r\n  function add_bounty() payable {\r\n    // Update bounty to include received amount.\r\n    bounty += msg.value;\r\n  }\r\n  \r\n  // Buys tokens for the contract and rewards the caller.  Callable by anyone.\r\n  function buy() {\r\n    buy_for(msg.sender);\r\n  }\r\n  \r\n  // Buys tokens in the crowdsale and rewards the given address.  Callable by anyone.\r\n  // Enables Sybil attacks, wherein a single user creates multiple accounts with which\r\n  // to call \"buy_for\" to reward their primary account.  Useful for bounty-seekers who\r\n  // haven't sent ETH to the contract, but don't want to clean up Sybil dust, or for users\r\n  // who have sent a large amount of ETH to the contract and want to reduce/avoid their fee.\r\n  function buy_for(address user) {\r\n    // Short circuit to save gas if the contract doesn't have any ETH left to buy tokens.\r\n    if (this.balance == 0) return;\r\n    // Store the current curve/cap index as temporary variable to avoid calling twice.\r\n    uint256 currentIndex = dynamic.currentIndex();\r\n    // Check whether the current curve/cap is the last one revealed so far.\r\n    if ((currentIndex + 1) >= dynamic.revealedCurves()) {\r\n      // Extract the buy limit of the current curve/cap.\r\n      uint256 limit;\r\n      (,limit,,) = dynamic.curves(currentIndex);\r\n      // Short circuit to save gas if the ICO is currently at the cap, waiting for a reveal.\r\n      if (limit <= sale.totalNormalCollected()) return;\r\n    }\r\n    // Record that the contract has started buying tokens.\r\n    bought_tokens = true;\r\n    // Store the contract's ETH balance prior to the purchase in a temporary variable.\r\n    uint256 old_contract_eth_balance = this.balance;\r\n    // Transfer all the funds (less the bounty) to the Status ICO contract \r\n    // to buy tokens.  Throws if the crowdsale hasn't started yet or has \r\n    // already completed, preventing loss of funds.\r\n    sale.proxyPayment.value(this.balance - bounty)(address(this));\r\n    // Verify contract ETH balance has not increased instead of decreased.\r\n    if (this.balance > old_contract_eth_balance) throw;\r\n    // Calculate ETH spent to buy tokens.\r\n    uint256 eth_spent = old_contract_eth_balance - this.balance;\r\n    // Update user's number of purchased SNT to include this purchase.\r\n    purchased_snt[user] += (eth_spent * 10000);\r\n    // Calculate the user's bounty proportionally to the amount purchased.\r\n    uint256 user_bounty = (bounty * eth_spent) / old_contract_eth_balance;\r\n    // Update the bounty prior to sending ETH to prevent recursive call.\r\n    bounty -= user_bounty;\r\n    // Send the user their bounty for buying tokens for the contract.\r\n    user.transfer(user_bounty);\r\n  }\r\n  \r\n  // A helper function for the default function, allowing contracts to interact.\r\n  function default_helper() payable {\r\n    // Only allow deposits if the contract hasn't already purchased the tokens.\r\n    if (!bought_tokens) {\r\n      // Update records of deposited ETH to include the received amount.\r\n      deposits[msg.sender] += msg.value;\r\n    }\r\n    // Withdraw the sender's ETH and SNT if the contract has started purchasing SNT.\r\n    else {\r\n      // Reject ETH sent after the contract has already purchased tokens.\r\n      if (msg.value != 0) throw;\r\n      // Withdraw user's funds if they sent 0 ETH to the contract after the ICO.\r\n      withdraw();\r\n    }\r\n  }\r\n  \r\n  // Default function.  Called when a user sends ETH to the contract.\r\n  function () payable {\r\n    throw;  // Safety throw, which will be removed in deployed version.\r\n    // Delegate to the helper function.\r\n    default_helper();\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dynamic\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"default_helper\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bought_tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"add_bounty\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bounty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"buy_for\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"purchased_snt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"payable\":true,\"type\":\"fallback\"}]","ContractName":"StatusBuyer","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a1b4323fbf34c2f2e19c3362320120873558d4791c8823cf04b6b96bb6fc5fcd"}]}