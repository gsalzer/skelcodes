{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\ncontract ERC20 {\r\n  function transfer(address _to, uint _value);\r\n  function balanceOf(address _owner) constant returns (uint balance);\r\n}\r\n\r\ncontract IOU {\r\n  // Store the amount of IOUs purchased by a buyer\r\n  mapping (address => uint256) public iou_purchased;\r\n\r\n  // Store the amount of ETH sent in by a buyer\r\n  mapping (address => uint256) public eth_sent;\r\n\r\n  // Total IOUs available to sell\r\n  uint256 public total_iou_available = 20000000000000000000;\r\n\r\n  // Total IOUs purchased by all buyers\r\n  uint256 public total_iou_purchased;\r\n\r\n  //  BAT token contract address (IOU offering)\r\n  ERC20 public token = ERC20(0x0D8775F648430679A709E98d2b0Cb6250d2887EF);\r\n\r\n  // The seller's address (to receive ETH upon distribution, and for auth withdrawTokens())\r\n  address seller = 0x00203F5b27CB688a402fBDBdd2EaF8542ffF72B6;\r\n\r\n  // Safety to withdraw all tokens back to seller in the event any get stranded\r\n  function withdrawTokens() {\r\n    if(msg.sender != seller) throw;\r\n    token.transfer(seller, token.balanceOf(address(this)));\r\n  }\r\n\r\n  function withdrawEth() {\r\n    if(msg.sender != seller) throw;\r\n    msg.sender.transfer(this.balance);\r\n  }\r\n\r\n  function killya() {\r\n    if(msg.sender != seller) throw;\r\n    selfdestruct(seller);\r\n  }\r\n\r\n  function withdraw() payable {\r\n    /*\r\n      Main mechanism to ensure a buyer's purchase/ETH/IOU is safe.\r\n\r\n      Refund the buyer's ETH if we're beyond the date of our distribution\r\n      promise AND if the contract doesn't have an adequate amount of tokens\r\n      to distribute to the buyer. If we're beyond the given date, yet there\r\n      is an adequate amount of tokens in the contract's balance, then the\r\n      buyer can withdraw accordingly. This allows buyers to withdraw well\r\n      into the future if they need to. It also allows us to extend the sale.\r\n      Time-sensitive ETH protection is only applicable if the contract\r\n      doesn't have adequate tokens for the buyer.\r\n\r\n      The \"adequacy\" check prevents the seller and/or third party attacker\r\n      from locking down buyers' ETH. i.e. The attacker sends 1 token into our\r\n      contract to falsely signal that the contract has been filled and is ready\r\n      for token distribution. If we simply check for a >0 token balance, we risk\r\n      distribution errors AND stranding/locking the buyer's ETH.\r\n\r\n      TODO: confirm there are no logical errors that will allow a buyer/attacker to\r\n            withdraw ETH early/unauthorized/doubly/etc\r\n    */\r\n    if(block.number > 3943365 && iou_purchased[msg.sender] > token.balanceOf(address(this))) {\r\n      // We didn't fulfill our promise to have adequate tokens withdrawable at xx time.\r\n      // Refund the buyer's ETH automatically instead.\r\n      uint256 eth_to_refund = eth_sent[msg.sender];\r\n\r\n      // If the user doesn't have any ETH or tokens to withdraw, get out ASAP\r\n      if(eth_to_refund == 0 || iou_purchased[msg.sender] == 0) throw;\r\n\r\n      // Adjust total accurately in the event we allow purchases in the future\r\n      total_iou_purchased -= iou_purchased[msg.sender];\r\n\r\n      // Clear record of buyer's ETH and IOU balance before refunding\r\n      eth_sent[msg.sender] = 0;\r\n      iou_purchased[msg.sender] = 0;\r\n\r\n      msg.sender.transfer(eth_to_refund);\r\n      return; // ?\r\n    }\r\n\r\n    /*\r\n      At this point, we are still before our distribution date promise.\r\n      Check if there is an adequate amount of tokens in the contract yet\r\n      and allow buyer's token withdrawal and seller's ETH distribution if so.\r\n\r\n      TODO: confirm there are no logical errors that will allow a buyer/attacker to\r\n            withdraw IOU tokens early/unauthorized/doubly/etc\r\n    */\r\n    if(token.balanceOf(address(this)) == 0 || iou_purchased[msg.sender] > token.balanceOf(address(this))) throw;\r\n\r\n    uint256 iou_to_withdraw = iou_purchased[msg.sender];\r\n    uint256 eth_to_release = eth_sent[msg.sender];\r\n\r\n    // If the user doesn't have any IOUs or ETH to withdraw/release, get out ASAP\r\n    if(iou_to_withdraw == 0 || eth_to_release == 0) throw;\r\n\r\n    // Clear record of buyer's IOU and ETH balance before transferring out\r\n    iou_purchased[msg.sender] = 0;\r\n    eth_sent[msg.sender] = 0;\r\n\r\n    // Distribute tokens to the buyer\r\n    token.transfer(msg.sender, iou_to_withdraw);\r\n\r\n    // Release buyer's ETH to the seller\r\n    seller.transfer(eth_to_release);\r\n  }\r\n\r\n  function purchase() payable {\r\n    // Check for pre-determined sale start time\r\n    //if(block.number < 3960990) throw;\r\n    // Check if sale window is still open or not (date of promised distribution - grace?)\r\n    //if(block.number > 3990990) throw;\r\n\r\n    // Determine amount of tokens user wants to/can buy\r\n    uint256 iou_to_purchase = 8600 * msg.value; // price is 8600 per ETH\r\n\r\n    // Check if we have enough IOUs left to sell\r\n    if((total_iou_purchased + iou_to_purchase) > total_iou_available) throw;\r\n\r\n    // Update the amount of IOUs purchased by user. Also keep track of the total ETH they sent in\r\n    iou_purchased[msg.sender] += iou_to_purchase;\r\n    eth_sent[msg.sender] += msg.value;\r\n\r\n    // Update the total amount of IOUs purchased by all buyers\r\n    total_iou_purchased += iou_to_purchase;\r\n  }\r\n\r\n  // Fallback function/entry point\r\n  function () payable {\r\n    if(msg.value == 0) { // If the user sent a 0 ETH transaction, withdraw()\r\n      withdraw();\r\n    }\r\n    else { // If the user sent ETH, purchase IOU\r\n      purchase();\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"eth_sent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"purchase\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"iou_purchased\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_iou_available\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_iou_purchased\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"killya\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"payable\":true,\"type\":\"fallback\"}]","ContractName":"IOU","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6418932ffe5f4126ab3647003c2da42c68038a14005f690ea00376ac1305564c"}]}