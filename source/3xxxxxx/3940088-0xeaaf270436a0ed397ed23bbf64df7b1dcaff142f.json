{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n//------------------------------------------------------------------------------------------------\r\n// LICENSE\r\n//\r\n// This file is part of BattleDrome.\r\n// \r\n// BattleDrome is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// \r\n// BattleDrome is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// \r\n// You should have received a copy of the GNU General Public License\r\n// along with BattleDrome.  If not, see <http://www.gnu.org/licenses/>.\r\n//------------------------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------------------------\r\n// ERC20 Standard Token Implementation, based on ERC Standard:\r\n// https://github.com/ethereum/EIPs/issues/20\r\n// With some inspiration from ConsenSys HumanStandardToken as well\r\n// Copyright 2017 BattleDrome\r\n//------------------------------------------------------------------------------------------------\r\n\r\ncontract ERC20Standard {\r\n\tuint public totalSupply;\r\n\t\r\n\tstring public name;\r\n\tuint8 public decimals;\r\n\tstring public symbol;\r\n\tstring public version;\r\n\t\r\n\tmapping (address => uint256) balances;\r\n\tmapping (address => mapping (address => uint)) allowed;\r\n\r\n\t//Fix for short address attack against ERC20\r\n\tmodifier onlyPayloadSize(uint size) {\r\n\t\tassert(msg.data.length == size + 4);\r\n\t\t_;\r\n\t} \r\n\r\n\tfunction balanceOf(address _owner) constant returns (uint balance) {\r\n\t\treturn balances[_owner];\r\n\t}\r\n\r\n\tfunction transfer(address _recipient, uint _value) onlyPayloadSize(2*32) {\r\n\t\trequire(balances[msg.sender] >= _value && _value > 0);\r\n\t    balances[msg.sender] -= _value;\r\n\t    balances[_recipient] += _value;\r\n\t    Transfer(msg.sender, _recipient, _value);        \r\n    }\r\n\r\n\tfunction transferFrom(address _from, address _to, uint _value) {\r\n\t\trequire(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n    }\r\n\r\n\tfunction approve(address _spender, uint _value) {\r\n\t\tallowed[msg.sender][_spender] = _value;\r\n\t\tApproval(msg.sender, _spender, _value);\r\n\t}\r\n\r\n\tfunction allowance(address _spender, address _owner) constant returns (uint balance) {\r\n\t\treturn allowed[_owner][_spender];\r\n\t}\r\n\r\n\t//Event which is triggered to log all transfers to this contract's event log\r\n\tevent Transfer(\r\n\t\taddress indexed _from,\r\n\t\taddress indexed _to,\r\n\t\tuint _value\r\n\t\t);\r\n\t\t\r\n\t//Event which is triggered whenever an owner approves a new allowance for a spender.\r\n\tevent Approval(\r\n\t\taddress indexed _owner,\r\n\t\taddress indexed _spender,\r\n\t\tuint _value\r\n\t\t);\r\n\r\n}\r\n\r\n//------------------------------------------------------------------------------------------------\r\n// FAME ERC20 Token, based on ERC20Standard interface\r\n// Copyright 2017 BattleDrome\r\n//------------------------------------------------------------------------------------------------\r\n\r\ncontract FAMEToken is ERC20Standard {\r\n\r\n\tfunction FAMEToken() {\r\n\t\ttotalSupply = 2100000 szabo;\t\t\t//Total Supply (including all decimal places!)\r\n\t\tname = \"Fame\";\t\t\t\t\t\t\t//Pretty Name\r\n\t\tdecimals = 12;\t\t\t\t\t\t\t//Decimal places (with 12 decimal places 1 szabo = 1 token in uint256)\r\n\t\tsymbol = \"FAM\";\t\t\t\t\t\t\t//Ticker Symbol (3 characters, upper case)\r\n\t\tversion = \"FAME1.0\";\t\t\t\t\t//Version Code\r\n\t\tbalances[msg.sender] = totalSupply;\t\t//Assign all balance to creator initially for distribution from there.\r\n\t}\r\n\r\n\t//Burn _value of tokens from your balance.\r\n\t//Will destroy the tokens, removing them from your balance, and reduce totalSupply accordingly.\r\n\tfunction burn(uint _value) {\r\n\t\trequire(balances[msg.sender] >= _value && _value > 0);\r\n        balances[msg.sender] -= _value;\r\n        totalSupply -= _value;\r\n        Burn(msg.sender, _value);\r\n\t}\r\n\r\n\t//Event to log any time someone burns tokens to the contract's event log:\r\n\tevent Burn(\r\n\t\taddress indexed _owner,\r\n\t\tuint _value\r\n\t\t);\r\n\r\n}\r\n\r\n//------------------------------------------------------------------------------------------------\r\n// ICO Crowd Sale Contract\r\n// Works like a kickstarter. Minimum goal required, or everyone gets their money back\r\n// Contract holds all tokens, upon success (passing goal on time) sends out all bought tokens\r\n// It then burns the rest.\r\n// In the event of failure, it sends tokens back to creator, and all payments back to senders.\r\n// Each time tokens are bought, a percentage is also issued to the \"Developer\" account.\r\n// Pay-out of collected Ether to creators is managed through an Escrow address.\r\n// Copyright 2017 BattleDrome\r\n//------------------------------------------------------------------------------------------------\r\n\r\ncontract BattleDromeICO {\r\n\tuint public constant ratio = 100 szabo;\t\t\t\t//Ratio of how many tokens (in absolute uint256 form) are issued per ETH\r\n\tuint public constant minimumPurchase = 1 finney;\t//Minimum purchase size (of incoming ETH)\r\n\tuint public constant startBlock = 3960000;\t\t\t//Starting Block Number of Crowsd Sale\r\n\tuint public constant duration = 190000;\t\t\t\t//16s block times 190k is about 35 days, from July 1st, to approx first Friday of August.\r\n\tuint public constant fundingGoal = 500 ether;\t\t//Minimum Goal in Ether Raised\r\n\tuint public constant fundingMax = 20000 ether;\t\t//Maximum Funds in Ether that we will accept before stopping the crowdsale\r\n\tuint public constant devRatio = 20;\t\t\t\t\t//Ratio of Sold Tokens to Dev Tokens (ie 20 = 20:1 or 5%)\r\n\taddress public constant tokenAddress \t= 0x190e569bE071F40c704e15825F285481CB74B6cC;\t//Address of ERC20 Token Contract\r\n\taddress public constant escrow \t\t\t= 0x50115D25322B638A5B8896178F7C107CFfc08144;\t//Address of Escrow Provider Wallet\r\n\r\n\tFAMEToken public Token;\r\n\taddress public creator;\r\n\tuint public savedBalance;\r\n\tbool public creatorPaid = false;\t\t\t//Has the creator been paid? \r\n\r\n\tmapping(address => uint) balances;\t\t\t//Balances in incoming Ether\r\n\tmapping(address => uint) savedBalances;\t\t//Saved Balances in incoming Ether (for after withdrawl validation)\r\n\r\n\t//Constructor, initiate the crowd sale\r\n\tfunction BattleDromeICO() {\r\n\t\tToken = FAMEToken(tokenAddress);\t\t\t\t//Establish the Token Contract to handle token transfers\t\t\t\t\t\r\n\t\tcreator = msg.sender;\t\t\t\t\t\t\t//Establish the Creator address for receiving payout if/when appropriate.\r\n\t}\r\n\r\n\t//Default Function, delegates to contribute function (for ease of use)\r\n\t//WARNING: Not compatible with smart contract invocation, will exceed gas stipend!\r\n\t//Only use from full wallets.\r\n\tfunction () payable {\r\n\t\tcontribute();\r\n\t}\r\n\r\n\t//Contribute Function, accepts incoming payments and tracks balances\r\n\tfunction contribute() payable {\r\n\t\trequire(isStarted());\t\t\t\t\t\t\t\t//Has the crowdsale even started yet?\r\n\t\trequire(this.balance<=fundingMax); \t\t\t\t\t//Does this payment send us over the max?\r\n\t\trequire(msg.value >= minimumPurchase);              //Require that the incoming amount is at least the minimum purchase size.\r\n\t\trequire(!isComplete()); \t\t\t\t\t\t\t//Has the crowdsale completed? We only want to accept payments if we're still active.\r\n\t\tbalances[msg.sender] += msg.value;\t\t\t\t\t//If all checks good, then accept contribution and record new balance.\r\n\t\tsavedBalances[msg.sender] += msg.value;\t\t    \t//Save contributors balance for later\t\r\n\t\tsavedBalance += msg.value;\t\t\t\t\t\t\t//Save the balance for later when we're doing pay-outs so we know what it was.\r\n\t\tContribution(msg.sender,msg.value,now);             //Woohoo! Log the new contribution!\r\n\t}\r\n\r\n\t//Function to view current token balance of the crowdsale contract\r\n\tfunction tokenBalance() constant returns(uint balance) {\r\n\t\treturn Token.balanceOf(address(this));\r\n\t}\r\n\r\n\t//Function to check if crowdsale has started yet, have we passed the start block?\r\n\tfunction isStarted() constant returns(bool) {\r\n\t\treturn block.number >= startBlock;\r\n\t}\r\n\r\n\t//Function to check if crowdsale is complete (have we eigher hit our max, or passed the crowdsale completion block?)\r\n\tfunction isComplete() constant returns(bool) {\r\n\t\treturn (savedBalance >= fundingMax) || (block.number > (startBlock + duration));\r\n\t}\r\n\r\n\t//Function to check if crowdsale has been successful (has incoming contribution balance met, or exceeded the minimum goal?)\r\n\tfunction isSuccessful() constant returns(bool) {\r\n\t\treturn (savedBalance >= fundingGoal);\r\n\t}\r\n\r\n\t//Function to check the Ether balance of a contributor\r\n\tfunction checkEthBalance(address _contributor) constant returns(uint balance) {\r\n\t\treturn balances[_contributor];\r\n\t}\r\n\r\n\t//Function to check the Saved Ether balance of a contributor\r\n\tfunction checkSavedEthBalance(address _contributor) constant returns(uint balance) {\r\n\t\treturn savedBalances[_contributor];\r\n\t}\r\n\r\n\t//Function to check the Token balance of a contributor\r\n\tfunction checkTokBalance(address _contributor) constant returns(uint balance) {\r\n\t\treturn (balances[_contributor] * ratio) / 1 ether;\r\n\t}\r\n\r\n\t//Function to check the current Tokens Sold in the ICO\r\n\tfunction checkTokSold() constant returns(uint total) {\r\n\t\treturn (savedBalance * ratio) / 1 ether;\r\n\t}\r\n\r\n\t//Function to get Dev Tokens issued during ICO\r\n\tfunction checkTokDev() constant returns(uint total) {\r\n\t\treturn checkTokSold() / devRatio;\r\n\t}\r\n\r\n\t//Function to get Total Tokens Issued during ICO (Dev + Sold)\r\n\tfunction checkTokTotal() constant returns(uint total) {\r\n\t\treturn checkTokSold() + checkTokDev();\r\n\t}\r\n\r\n\t//function to check percentage of goal achieved\r\n\tfunction percentOfGoal() constant returns(uint16 goalPercent) {\r\n\t\treturn uint16((savedBalance*100)/fundingGoal);\r\n\t}\r\n\r\n\t//function to initiate payout of either Tokens or Ether payback.\r\n\tfunction payMe() {\r\n\t\trequire(isComplete()); //No matter what must be complete\r\n\t\tif(isSuccessful()) {\r\n\t\t\tpayTokens();\r\n\t\t}else{\r\n\t\t\tpayBack();\r\n\t\t}\r\n\t}\r\n\r\n\t//Function to pay back Ether\r\n\tfunction payBack() internal {\r\n\t\trequire(balances[msg.sender]>0);\t\t\t\t\t\t//Does the requester have a balance?\r\n\t\tbalances[msg.sender] = 0;\t\t\t\t\t\t\t\t//Ok, zero balance first to avoid re-entrance\r\n\t\tmsg.sender.transfer(savedBalances[msg.sender]);\t\t\t//Send them their saved balance\r\n\t\tPayEther(msg.sender,savedBalances[msg.sender],now); \t//Log payback of ether\r\n\t}\r\n\r\n\t//Function to pay out Tokens\r\n\tfunction payTokens() internal {\r\n\t\trequire(balances[msg.sender]>0);\t\t\t\t\t//Does the requester have a balance?\r\n\t\tuint tokenAmount = checkTokBalance(msg.sender);\t\t//If so, then let's calculate how many Tokens we owe them\r\n\t\tbalances[msg.sender] = 0;\t\t\t\t\t\t\t//Zero their balance ahead of transfer to avoid re-entrance (even though re-entrance here should be zero risk)\r\n\t\tToken.transfer(msg.sender,tokenAmount);\t\t\t\t//And transfer the tokens to them\r\n\t\tPayTokens(msg.sender,tokenAmount,now);          \t//Log payout of tokens to contributor\r\n\t}\r\n\r\n\t//Function to pay the creator upon success\r\n\tfunction payCreator() {\r\n\t\trequire(isComplete());\t\t\t\t\t\t\t\t\t\t//Creator can only request payout once ICO is complete\r\n\t\trequire(!creatorPaid);\t\t\t\t\t\t\t\t\t\t//Require that the creator hasn't already been paid\r\n\t\tcreatorPaid = true;\t\t\t\t\t\t\t\t\t\t\t//Set flag to show creator has been paid.\r\n\t\tif(isSuccessful()){\r\n\t\t\tuint tokensToBurn = tokenBalance() - checkTokTotal();\t//How many left-over tokens after sold, and dev tokens are accounted for? (calculated before we muck with balance)\r\n\t\t\tPayEther(escrow,this.balance,now);      \t\t\t\t//Log the payout to escrow\r\n\t\t\tescrow.transfer(this.balance);\t\t\t\t\t\t\t//We were successful, so transfer the balance to the escrow address\r\n\t\t\tPayTokens(creator,checkTokDev(),now);       \t\t\t//Log payout of tokens to creator\r\n\t\t\tToken.transfer(creator,checkTokDev());\t\t\t\t\t//And since successful, send DevRatio tokens to devs directly\t\t\t\r\n\t\t\tToken.burn(tokensToBurn);\t\t\t\t\t\t\t\t//Burn any excess tokens;\r\n\t\t\tBurnTokens(tokensToBurn,now);        \t\t\t\t\t//Log the burning of the tokens.\r\n\t\t}else{\r\n\t\t\tPayTokens(creator,tokenBalance(),now);       \t\t\t//Log payout of tokens to creator\r\n\t\t\tToken.transfer(creator,tokenBalance());\t\t\t\t\t//We were not successful, so send ALL tokens back to creator.\r\n\t\t}\r\n\t}\r\n\t\r\n\t//Event to record new contributions\r\n\tevent Contribution(\r\n\t    address indexed _contributor,\r\n\t    uint indexed _value,\r\n\t    uint indexed _timestamp\r\n\t    );\r\n\t    \r\n\t//Event to record each time tokens are paid out\r\n\tevent PayTokens(\r\n\t    address indexed _receiver,\r\n\t    uint indexed _value,\r\n\t    uint indexed _timestamp\r\n\t    );\r\n\r\n\t//Event to record each time Ether is paid out\r\n\tevent PayEther(\r\n\t    address indexed _receiver,\r\n\t    uint indexed _value,\r\n\t    uint indexed _timestamp\r\n\t    );\r\n\t    \r\n\t//Event to record when tokens are burned.\r\n\tevent BurnTokens(\r\n\t    uint indexed _value,\r\n\t    uint indexed _timestamp\r\n\t    );\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"}],\"name\":\"checkTokBalance\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"}],\"name\":\"checkSavedEthBalance\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkTokDev\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ratio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"savedBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkTokSold\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkTokTotal\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"}],\"name\":\"checkEthBalance\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenBalance\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creatorPaid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumPurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isComplete\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"contribute\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payMe\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payCreator\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escrow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percentOfGoal\",\"outputs\":[{\"name\":\"goalPercent\",\"type\":\"uint16\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSuccessful\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_contributor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"Contribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"PayTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"PayEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"BurnTokens\",\"type\":\"event\"}]","ContractName":"BattleDromeICO","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7abb7abce37314fbd3bac3f6038033fc494c350dac34687f4dd8129bff6163ca"}]}