{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\n/**\r\n * Very basic owned/mortal boilerplate.  Used for basically everything, for\r\n * security/access control purposes.\r\n */\r\ncontract Owned {\r\n  address owner;\r\n\r\n  modifier onlyOwner {\r\n    if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Basic constructor.  The sender is the owner.\r\n   */\r\n  function Owned() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * Transfers ownership of the contract to a new owner.\r\n   * @param newOwner  Who gets to inherit this thing.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    owner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * Shuts down the contract and removes it from the blockchain state.\r\n   * Only available to the owner.\r\n   */\r\n  function shutdown() onlyOwner {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  /**\r\n   * Withdraw all the funds from this contract.\r\n   * Only available to the owner.\r\n   */\r\n  function withdraw() onlyOwner {\r\n    if (!owner.send(this.balance)) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\ncontract LotteryRoundFactoryInterface {\r\n  string public VERSION;\r\n  function transferOwnership(address newOwner);\r\n}\r\n\r\ncontract LotteryRoundFactoryInterfaceV1 is LotteryRoundFactoryInterface {\r\n  function createRound(bytes32 _saltHash, bytes32 _saltNHash) payable returns(address);\r\n}\r\n\r\ncontract LotteryRoundInterface {\r\n  bool public winningNumbersPicked;\r\n  uint256 public closingBlock;\r\n\r\n  function pickTicket(bytes4 picks) payable;\r\n  function randomTicket() payable;\r\n\r\n  function proofOfSalt(bytes32 salt, uint8 N) constant returns(bool);\r\n  function closeGame(bytes32 salt, uint8 N);\r\n  function claimOwnerFee(address payout);\r\n  function withdraw();\r\n  function shutdown();\r\n  function distributeWinnings();\r\n  function claimPrize();\r\n\r\n  function paidOut() constant returns(bool);\r\n  function transferOwnership(address newOwner);\r\n}\r\n\r\n/**\r\n * The base interface is what the parent contract expects to be able to use.\r\n * If rules change in the future, and new logic is introduced, it only has to\r\n * implement these methods, wtih the role of the curator being used\r\n * to execute the additional functionality (if any).\r\n */\r\ncontract LotteryGameLogicInterface {\r\n  address public currentRound;\r\n  function finalizeRound() returns(address);\r\n  function isUpgradeAllowed() constant returns(bool);\r\n  function transferOwnership(address newOwner);\r\n}\r\n\r\ncontract LotteryGameLogicInterfaceV1 is LotteryGameLogicInterface {\r\n  function deposit() payable;\r\n  function setCurator(address newCurator);\r\n}\r\n\r\n\r\n/**\r\n * Core game logic.  Handlings management of rounds, carry-over balances,\r\n * paying winners, etc.  Separate from the main contract because it's more\r\n * tightly-coupled to the factory/round logic than the game logic.  This\r\n * allows for new rules in the future (e.g. partial picks, etc).  Carries\r\n * the caveat that it cannot be upgraded until the current rules produce\r\n * a winner, and can only be upgraded in the period between a winner under\r\n * the current rules and the next round being started.\r\n */\r\ncontract LotteryGameLogic is LotteryGameLogicInterfaceV1, Owned {\r\n\r\n  LotteryRoundFactoryInterfaceV1 public roundFactory;\r\n\r\n  address public curator;\r\n\r\n  LotteryRoundInterface public currentRound;\r\n\r\n  modifier onlyWhenNoRound {\r\n    if (currentRound != LotteryRoundInterface(0)) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  modifier onlyBeforeDraw {\r\n    if (\r\n      currentRound == LotteryRoundInterface(0) ||\r\n      block.number <= currentRound.closingBlock() ||\r\n      currentRound.winningNumbersPicked() == true\r\n    ) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  modifier onlyAfterDraw {\r\n    if (\r\n      currentRound == LotteryRoundInterface(0) ||\r\n      currentRound.winningNumbersPicked() == false\r\n    ) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  modifier onlyCurator {\r\n    if (msg.sender != curator) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  modifier onlyFromCurrentRound {\r\n    if (msg.sender != address(currentRound)) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Creates the core logic of the lottery.  Requires a round factory\r\n   * and an initial curator.\r\n   * @param _roundFactory  The factory to generate new rounds\r\n   * @param _curator       The initial curator\r\n   */\r\n  function LotteryGameLogic(address _roundFactory, address _curator) {\r\n    roundFactory = LotteryRoundFactoryInterfaceV1(_roundFactory);\r\n    curator = _curator;\r\n  }\r\n\r\n  /**\r\n   * Allows the curator to hand over curation responsibilities to someone else.\r\n   * @param newCurator  The new curator\r\n   */\r\n  function setCurator(address newCurator) onlyCurator onlyWhenNoRound {\r\n    curator = newCurator;\r\n  }\r\n\r\n  /**\r\n   * Specifies whether or not upgrading this contract is allowed.  In general, if there\r\n   * is a round underway, or this contract is holding a balance, upgrading is not allowed.\r\n   */\r\n  function isUpgradeAllowed() constant returns(bool) {\r\n    return currentRound == LotteryRoundInterface(0) && this.balance < 1 finney;\r\n  }\r\n\r\n  /**\r\n   * Starts a new round.  Can only be started by the curator, and only when there is no round\r\n   * currently underway\r\n   * @param saltHash    Secret salt, hashed N times.\r\n   * @param saltNHash   Proof of N, in the form of sha3(salt, N, salt)\r\n   */\r\n  function startRound(bytes32 saltHash, bytes32 saltNHash) onlyCurator onlyWhenNoRound {\r\n    if (this.balance > 0) {\r\n      currentRound = LotteryRoundInterface(\r\n        roundFactory.createRound.value(this.balance)(saltHash, saltNHash)\r\n      );\r\n    } else {\r\n      currentRound = LotteryRoundInterface(roundFactory.createRound(saltHash, saltNHash));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reveal the chosen salt and number of hash iterations, then close the current roundn\r\n   * and pick the winning numbers\r\n   * @param salt   The original salt\r\n   * @param N      The original N\r\n   */\r\n  function closeRound(bytes32 salt, uint8 N) onlyCurator onlyBeforeDraw {\r\n    currentRound.closeGame(salt, N);\r\n  }\r\n\r\n  /**\r\n   * Finalize the round before returning it back to the the parent contract for\r\n   * historical purposes.  Attempts to pay winners and the curator if there was a winning\r\n   * draw, otherwise, pulls the balance out of the round before handing over ownership\r\n   * to the curator.\r\n   */\r\n  function finalizeRound() onlyOwner onlyAfterDraw returns(address) {\r\n    address roundAddress = address(currentRound);\r\n    if (!currentRound.paidOut()) {\r\n      // we'll only make one attempt here to pay the winners\r\n      currentRound.distributeWinnings();\r\n      currentRound.claimOwnerFee(curator);\r\n    } else if (currentRound.balance > 0) {\r\n      // otherwise, we have no winners, so just pull out funds in\r\n      // preparation for the next round.\r\n      currentRound.withdraw();\r\n    }\r\n\r\n    // be sure someone can handle disputes, etc, if they arise.\r\n    // not that they'll be able to *do* anything, but they can at least\r\n    // try calling `distributeWinnings()` again...\r\n    currentRound.transferOwnership(curator);\r\n\r\n    // clear this shit out.\r\n    delete currentRound;\r\n\r\n    // if there are or were any problems distributing winnings, the winners can attempt to withdraw\r\n    // funds for themselves.  The contracts won't be destroyed so long as they have funds to pay out.\r\n    // handling them might require special care or something.\r\n\r\n    return roundAddress;\r\n  }\r\n\r\n  /**\r\n   * Mostly just used for testing.  Technically, this contract may be seeded with an initial deposit\r\n   * before\r\n   */\r\n  function deposit() payable onlyOwner onlyWhenNoRound {\r\n    // noop, just used for depositing funds during an upgrade.\r\n  }\r\n\r\n  /**\r\n   * Only accept payments from the current round.  Required due to calling `.withdraw` at round's end.\r\n   */\r\n  function () payable onlyFromCurrentRound {\r\n    // another noop, since we can only receive funds from the current round.\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"saltHash\",\"type\":\"bytes32\"},{\"name\":\"saltNHash\",\"type\":\"bytes32\"}],\"name\":\"startRound\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isUpgradeAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeRound\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"salt\",\"type\":\"bytes32\"},{\"name\":\"N\",\"type\":\"uint8\"}],\"name\":\"closeRound\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCurator\",\"type\":\"address\"}],\"name\":\"setCurator\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"shutdown\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_roundFactory\",\"type\":\"address\"},{\"name\":\"_curator\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"}]","ContractName":"LotteryGameLogic","CompilerVersion":"v0.4.9+commit.364da425","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000010758e3fcfd5c4cb81e0958c95b4ab31575808860000000000000000000000007f72cda90108342b14201f9aa9adb67ef461b315","Library":"","SwarmSource":"bzzr://1e66d13d85b48b581628c03645f70d8b01f9ccfdd45a36790e7f8b06dc9fa7b4"}]}