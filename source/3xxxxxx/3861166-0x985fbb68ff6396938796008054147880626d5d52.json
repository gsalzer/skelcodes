{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.10;\r\n\r\n// Token selling smart contract\r\n// Inspired by https://github.com/bokkypoobah/TokenTrader\r\n\r\n// https://github.com/ethereum/EIPs/issues/20\r\ncontract ERC20 {\r\n    function totalSupply() constant returns (uint totalSupply);\r\n    function balanceOf(address _owner) constant returns (uint balance);\r\n    function transfer(address _to, uint _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n    function approve(address _spender, uint _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n// `owned` contracts allows us to specify an owner address\r\n// which has admin right to this contract\r\ncontract owned {\r\n    address public owner;\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    function owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n// `halting` contracts allow us to stop activity on this contract,\r\n// or even self-destruct if need be.\r\ncontract halting is owned {\r\n    bool public running = true;\r\n\r\n    function start() onlyOwner {\r\n        running = true;\r\n    }\r\n\r\n    function stop() onlyOwner {\r\n        running = false;\r\n    }\r\n\r\n    function destruct() onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    modifier halting {\r\n        assert(running);\r\n        _;\r\n    }\r\n}\r\n\r\n// contract can buy or sell tokens for ETH\r\n// prices are in amount of wei per batch of token units\r\ncontract TokenVault is owned, halting {\r\n\r\n    address public asset;    // address of token\r\n    uint public sellPrice;   // contract sells lots at this price (in wei)\r\n    uint public units;       // lot size (token-wei)\r\n\r\n    event MakerWithdrewAsset(uint tokens);\r\n    event MakerWithdrewEther(uint ethers);\r\n    event SoldTokens(uint tokens);\r\n\r\n    // Constructor - only to be called by the TokenTraderFactory contract\r\n    function TokenVault (\r\n        address _asset,\r\n        uint _sellPrice,\r\n        uint _units\r\n    ) {\r\n        asset       = _asset;\r\n        sellPrice   = _sellPrice;\r\n        units       = _units;\r\n\r\n        require(asset != 0);\r\n        require(sellPrice > 0);\r\n        require(units > 0);\r\n    }\r\n\r\n    // Withdraw asset ERC20 Token\r\n    function makerWithdrawAsset(uint tokens) onlyOwner returns (bool ok) {\r\n        MakerWithdrewAsset(tokens);\r\n        return ERC20(asset).transfer(owner, tokens);\r\n    }\r\n\r\n    // Withdraw all eth from this contract\r\n    function makerWithdrawEther() onlyOwner {\r\n        MakerWithdrewEther(this.balance);\r\n        return owner.transfer(this.balance);\r\n    }\r\n\r\n    // Function to easily check this contracts balance\r\n    function getAssetBalance() constant returns (uint) {\r\n        return ERC20(asset).balanceOf(address(this));\r\n    }\r\n\r\n    function min(uint a, uint b) private returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    // Primary function; called with Ether sent to contract\r\n    function takerBuyAsset() payable halting {\r\n\r\n        // Must request at least one asset\r\n        require(msg.value >= sellPrice);\r\n\r\n        uint order    = msg.value / sellPrice;\r\n        uint can_sell = getAssetBalance() / units;\r\n        // start with no change\r\n        uint256 change = 0;\r\n        if (msg.value > (can_sell * sellPrice)) {\r\n            change  = msg.value - (can_sell * sellPrice);\r\n            order = can_sell;\r\n        }\r\n        if (change > 0) {\r\n            if (!msg.sender.send(change)) throw;\r\n        }\r\n        if (order > 0) {\r\n            if (!ERC20(asset).transfer(msg.sender, order * units)) throw;\r\n        }\r\n        SoldTokens(order);\r\n\r\n    }\r\n\r\n    // Ether is sent to the contract; can be either Maker or Taker\r\n    function () payable {\r\n        if (msg.sender == owner) {\r\n            // Allow owner to simply add eth to contract\r\n            return;\r\n        }\r\n        else {\r\n            // Otherwise, interpret as a buy request\r\n            takerBuyAsset();\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAssetBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"makerWithdrawEther\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destruct\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"asset\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"units\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"takerBuyAsset\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"makerWithdrawAsset\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"running\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_asset\",\"type\":\"address\"},{\"name\":\"_sellPrice\",\"type\":\"uint256\"},{\"name\":\"_units\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"MakerWithdrewAsset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ethers\",\"type\":\"uint256\"}],\"name\":\"MakerWithdrewEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"SoldTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TokenVault","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001f573d6fb3f13d689ff844b4ce37794d79a7ff1c000000000000000000000000000000000000000000000000000000000000012c0000000000000000000000000000000000000000000000000000000000002710","Library":"","SwarmSource":"bzzr://b28c3ca9d7e105bc5ca98074d3c63dde45a73e71c4ec0b152721b406b574c103"}]}