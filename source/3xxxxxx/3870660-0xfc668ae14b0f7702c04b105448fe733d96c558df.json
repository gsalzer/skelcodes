{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\n//solc --bin --abi --optimize  --optimize-runs 20000 -o . Testpool.sol \r\n\r\ncontract SHA3_512 {\r\n    function SHA3_512() {}\r\n    \r\n    function keccak_f(uint[25] A) constant internal returns(uint[25]) {\r\n        uint[5] memory C;\r\n        uint[5] memory D;\r\n        uint x;\r\n        uint y;\r\n        //uint D_0; uint D_1; uint D_2; uint D_3; uint D_4;\r\n        uint[25] memory B;\r\n        \r\n        uint[24] memory RC= [\r\n                   uint(0x0000000000000001),\r\n                   0x0000000000008082,\r\n                   0x800000000000808A,\r\n                   0x8000000080008000,\r\n                   0x000000000000808B,\r\n                   0x0000000080000001,\r\n                   0x8000000080008081,\r\n                   0x8000000000008009,\r\n                   0x000000000000008A,\r\n                   0x0000000000000088,\r\n                   0x0000000080008009,\r\n                   0x000000008000000A,\r\n                   0x000000008000808B,\r\n                   0x800000000000008B,\r\n                   0x8000000000008089,\r\n                   0x8000000000008003,\r\n                   0x8000000000008002,\r\n                   0x8000000000000080,\r\n                   0x000000000000800A,\r\n                   0x800000008000000A,\r\n                   0x8000000080008081,\r\n                   0x8000000000008080,\r\n                   0x0000000080000001,\r\n                   0x8000000080008008 ];\r\n        \r\n        for( uint i = 0 ; i < 24 ; i++ ) {\r\n            /*\r\n            for( x = 0 ; x < 5 ; x++ ) {\r\n                C[x] = A[5*x]^A[5*x+1]^A[5*x+2]^A[5*x+3]^A[5*x+4];                \r\n            }*/\r\n                       \r\n            C[0]=A[0]^A[1]^A[2]^A[3]^A[4];\r\n            C[1]=A[5]^A[6]^A[7]^A[8]^A[9];\r\n            C[2]=A[10]^A[11]^A[12]^A[13]^A[14];\r\n            C[3]=A[15]^A[16]^A[17]^A[18]^A[19];\r\n            C[4]=A[20]^A[21]^A[22]^A[23]^A[24];\r\n\r\n            /*\r\n            for( x = 0 ; x < 5 ; x++ ) {\r\n                D[x] = C[(x+4)%5]^((C[(x+1)%5] * 2)&0xffffffffffffffff | (C[(x+1)%5]/(2**63)));\r\n            }*/\r\n                        \r\n            \r\n            D[0]=C[4] ^ ((C[1] * 2)&0xffffffffffffffff | (C[1] / (2 ** 63)));\r\n            D[1]=C[0] ^ ((C[2] * 2)&0xffffffffffffffff | (C[2] / (2 ** 63)));\r\n            D[2]=C[1] ^ ((C[3] * 2)&0xffffffffffffffff | (C[3] / (2 ** 63)));\r\n            D[3]=C[2] ^ ((C[4] * 2)&0xffffffffffffffff | (C[4] / (2 ** 63)));\r\n            D[4]=C[3] ^ ((C[0] * 2)&0xffffffffffffffff | (C[0] / (2 ** 63)));\r\n\r\n            /*\r\n            for( x = 0 ; x < 5 ; x++ ) {\r\n                for( y = 0 ; y < 5 ; y++ ) {\r\n                    A[5*x+y] = A[5*x+y] ^ D[x];\r\n                }            \r\n            }*/\r\n            \r\n\r\n            \r\n            A[0]=A[0] ^ D[0];\r\n            A[1]=A[1] ^ D[0];\r\n            A[2]=A[2] ^ D[0];\r\n            A[3]=A[3] ^ D[0];\r\n            A[4]=A[4] ^ D[0];\r\n            A[5]=A[5] ^ D[1];\r\n            A[6]=A[6] ^ D[1];\r\n            A[7]=A[7] ^ D[1];\r\n            A[8]=A[8] ^ D[1];\r\n            A[9]=A[9] ^ D[1];\r\n            A[10]=A[10] ^ D[2];\r\n            A[11]=A[11] ^ D[2];\r\n            A[12]=A[12] ^ D[2];\r\n            A[13]=A[13] ^ D[2];\r\n            A[14]=A[14] ^ D[2];\r\n            A[15]=A[15] ^ D[3];\r\n            A[16]=A[16] ^ D[3];\r\n            A[17]=A[17] ^ D[3];\r\n            A[18]=A[18] ^ D[3];\r\n            A[19]=A[19] ^ D[3];\r\n            A[20]=A[20] ^ D[4];\r\n            A[21]=A[21] ^ D[4];\r\n            A[22]=A[22] ^ D[4];\r\n            A[23]=A[23] ^ D[4];\r\n            A[24]=A[24] ^ D[4];\r\n\r\n            /*Rho and pi steps*/            \r\n            B[0]=A[0];\r\n            B[8]=((A[1] * (2 ** 36))&0xffffffffffffffff | (A[1] / (2 ** 28)));\r\n            B[11]=((A[2] * (2 ** 3))&0xffffffffffffffff | (A[2] / (2 ** 61)));\r\n            B[19]=((A[3] * (2 ** 41))&0xffffffffffffffff | (A[3] / (2 ** 23)));\r\n            B[22]=((A[4] * (2 ** 18))&0xffffffffffffffff | (A[4] / (2 ** 46)));\r\n            B[2]=((A[5] * (2 ** 1))&0xffffffffffffffff | (A[5] / (2 ** 63)));\r\n            B[5]=((A[6] * (2 ** 44))&0xffffffffffffffff | (A[6] / (2 ** 20)));\r\n            B[13]=((A[7] * (2 ** 10))&0xffffffffffffffff | (A[7] / (2 ** 54)));\r\n            B[16]=((A[8] * (2 ** 45))&0xffffffffffffffff | (A[8] / (2 ** 19)));\r\n            B[24]=((A[9] * (2 ** 2))&0xffffffffffffffff | (A[9] / (2 ** 62)));\r\n            B[4]=((A[10] * (2 ** 62))&0xffffffffffffffff | (A[10] / (2 ** 2)));\r\n            B[7]=((A[11] * (2 ** 6))&0xffffffffffffffff | (A[11] / (2 ** 58)));\r\n            B[10]=((A[12] * (2 ** 43))&0xffffffffffffffff | (A[12] / (2 ** 21)));\r\n            B[18]=((A[13] * (2 ** 15))&0xffffffffffffffff | (A[13] / (2 ** 49)));\r\n            B[21]=((A[14] * (2 ** 61))&0xffffffffffffffff | (A[14] / (2 ** 3)));\r\n            B[1]=((A[15] * (2 ** 28))&0xffffffffffffffff | (A[15] / (2 ** 36)));\r\n            B[9]=((A[16] * (2 ** 55))&0xffffffffffffffff | (A[16] / (2 ** 9)));\r\n            B[12]=((A[17] * (2 ** 25))&0xffffffffffffffff | (A[17] / (2 ** 39)));\r\n            B[15]=((A[18] * (2 ** 21))&0xffffffffffffffff | (A[18] / (2 ** 43)));\r\n            B[23]=((A[19] * (2 ** 56))&0xffffffffffffffff | (A[19] / (2 ** 8)));\r\n            B[3]=((A[20] * (2 ** 27))&0xffffffffffffffff | (A[20] / (2 ** 37)));\r\n            B[6]=((A[21] * (2 ** 20))&0xffffffffffffffff | (A[21] / (2 ** 44)));\r\n            B[14]=((A[22] * (2 ** 39))&0xffffffffffffffff | (A[22] / (2 ** 25)));\r\n            B[17]=((A[23] * (2 ** 8))&0xffffffffffffffff | (A[23] / (2 ** 56)));\r\n            B[20]=((A[24] * (2 ** 14))&0xffffffffffffffff | (A[24] / (2 ** 50)));\r\n\r\n            /*Xi state*/\r\n            /*\r\n            for( x = 0 ; x < 5 ; x++ ) {\r\n                for( y = 0 ; y < 5 ; y++ ) {\r\n                    A[5*x+y] = B[5*x+y]^((~B[5*((x+1)%5)+y]) & B[5*((x+2)%5)+y]);\r\n                }\r\n            }*/\r\n            \r\n            \r\n            A[0]=B[0]^((~B[5]) & B[10]);\r\n            A[1]=B[1]^((~B[6]) & B[11]);\r\n            A[2]=B[2]^((~B[7]) & B[12]);\r\n            A[3]=B[3]^((~B[8]) & B[13]);\r\n            A[4]=B[4]^((~B[9]) & B[14]);\r\n            A[5]=B[5]^((~B[10]) & B[15]);\r\n            A[6]=B[6]^((~B[11]) & B[16]);\r\n            A[7]=B[7]^((~B[12]) & B[17]);\r\n            A[8]=B[8]^((~B[13]) & B[18]);\r\n            A[9]=B[9]^((~B[14]) & B[19]);\r\n            A[10]=B[10]^((~B[15]) & B[20]);\r\n            A[11]=B[11]^((~B[16]) & B[21]);\r\n            A[12]=B[12]^((~B[17]) & B[22]);\r\n            A[13]=B[13]^((~B[18]) & B[23]);\r\n            A[14]=B[14]^((~B[19]) & B[24]);\r\n            A[15]=B[15]^((~B[20]) & B[0]);\r\n            A[16]=B[16]^((~B[21]) & B[1]);\r\n            A[17]=B[17]^((~B[22]) & B[2]);\r\n            A[18]=B[18]^((~B[23]) & B[3]);\r\n            A[19]=B[19]^((~B[24]) & B[4]);\r\n            A[20]=B[20]^((~B[0]) & B[5]);\r\n            A[21]=B[21]^((~B[1]) & B[6]);\r\n            A[22]=B[22]^((~B[2]) & B[7]);\r\n            A[23]=B[23]^((~B[3]) & B[8]);\r\n            A[24]=B[24]^((~B[4]) & B[9]);\r\n\r\n            /*Last step*/\r\n            A[0]=A[0]^RC[i];            \r\n        }\r\n\r\n        \r\n        return A;\r\n    }\r\n \r\n    \r\n    function sponge(uint[9] M) constant internal returns(uint[16]) {\r\n        if( (M.length * 8) != 72 ) throw;\r\n        M[5] = 0x01;\r\n        M[8] = 0x8000000000000000;\r\n        \r\n        uint r = 72;\r\n        uint w = 8;\r\n        uint size = M.length * 8;\r\n        \r\n        uint[25] memory S;\r\n        uint i; uint y; uint x;\r\n        /*Absorbing Phase*/\r\n        for( i = 0 ; i < size/r ; i++ ) {\r\n            for( y = 0 ; y < 5 ; y++ ) {\r\n                for( x = 0 ; x < 5 ; x++ ) {\r\n                    if( (x+5*y) < (r/w) ) {\r\n                        S[5*x+y] = S[5*x+y] ^ M[i*9 + x + 5*y];\r\n                    }\r\n                }\r\n            }\r\n            S = keccak_f(S);\r\n        }\r\n\r\n        /*Squeezing phase*/\r\n        uint[16] memory result;\r\n        uint b = 0;\r\n        while( b < 16 ) {\r\n            for( y = 0 ; y < 5 ; y++ ) {\r\n                for( x = 0 ; x < 5 ; x++ ) {\r\n                    if( (x+5*y)<(r/w) && (b<16) ) {\r\n                        result[b] = S[5*x+y] & 0xFFFFFFFF; \r\n                        result[b+1] = S[5*x+y] / 0x100000000;\r\n                        b+=2;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n         \r\n        return result;\r\n   }\r\n\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\ncontract Ethash is SHA3_512 {\r\n    \r\n    mapping(address=>bool) public owners;\r\n    \r\n    function Ethash(address[3] _owners) {\r\n        owners[_owners[0]] = true;\r\n        owners[_owners[1]] = true;\r\n        owners[_owners[2]] = true;                \r\n    }\r\n     \r\n    function fnv( uint v1, uint v2 ) constant internal returns(uint) {\r\n        return ((v1*0x01000193) ^ v2) & 0xFFFFFFFF;\r\n    }\r\n\r\n\r\n\r\n    function computeCacheRoot( uint index,\r\n                               uint indexInElementsArray,\r\n                               uint[] elements,\r\n                               uint[] witness,\r\n                               uint branchSize ) constant private returns(uint) {\r\n \r\n                       \r\n        uint leaf = computeLeaf(elements, indexInElementsArray) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n        uint left;\r\n        uint right;\r\n        uint node;\r\n        bool oddBranchSize = (branchSize % 2) > 0;\r\n         \r\n        assembly {\r\n            branchSize := div(branchSize,2)\r\n            //branchSize /= 2;\r\n        }\r\n        uint witnessIndex = indexInElementsArray * branchSize;\r\n        if( oddBranchSize ) witnessIndex += indexInElementsArray;  \r\n\r\n        for( uint depth = 0 ; depth < branchSize ; depth++ ) {\r\n            assembly {\r\n                node := mload(add(add(witness,0x20),mul(add(depth,witnessIndex),0x20)))\r\n            }\r\n            //node  = witness[witnessIndex + depth] & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n            if( index & 0x1 == 0 ) {\r\n                left = leaf;\r\n                assembly{\r\n                    //right = node & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;                \r\n                    right := and(node,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                }\r\n                \r\n            }\r\n            else {\r\n                assembly{\r\n                    //left = node & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n                    left := and(node,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                }\r\n                right = leaf;\r\n            }\r\n            \r\n            leaf = uint(sha3(left,right)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n            assembly {\r\n                index := div(index,2) \r\n            }\r\n            //index = index / 2;\r\n\r\n            //node  = witness[witnessIndex + depth] / (2**128);\r\n            if( index & 0x1 == 0 ) {\r\n                left = leaf;\r\n                assembly{\r\n                    right := div(node,0x100000000000000000000000000000000)\r\n                    //right = node / 0x100000000000000000000000000000000;\r\n                }\r\n            }\r\n            else {\r\n                assembly {\r\n                    //left = node / 0x100000000000000000000000000000000;\r\n                    left := div(node,0x100000000000000000000000000000000)\r\n                }\r\n                right = leaf;\r\n            }\r\n            \r\n            leaf = uint(sha3(left,right)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n            assembly {\r\n                index := div(index,2) \r\n            }\r\n            //index = index / 2;\r\n        }\r\n        \r\n        if( oddBranchSize ) {\r\n            assembly {\r\n                node := mload(add(add(witness,0x20),mul(add(depth,witnessIndex),0x20)))\r\n            }\r\n        \r\n            //node  = witness[witnessIndex + depth] & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n            if( index & 0x1 == 0 ) {\r\n                left = leaf;\r\n                assembly{\r\n                    //right = node & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;                \r\n                    right := and(node,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                }                \r\n            }\r\n            else {\r\n                assembly{\r\n                    //left = node & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;                \r\n                    left := and(node,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                }\r\n            \r\n                right = leaf;\r\n            }\r\n            \r\n            leaf = uint(sha3(left,right)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;        \r\n        }\r\n        \r\n        \r\n        return leaf;\r\n    }\r\n\r\n    \r\n    function toBE( uint x ) constant internal returns(uint) {\r\n        uint y = 0;\r\n        for( uint i = 0 ; i < 32 ; i++ ) {\r\n            y = y * 256;\r\n            y += (x & 0xFF);\r\n            x = x / 256;            \r\n        }\r\n        \r\n        return y;\r\n        \r\n    }\r\n    \r\n    function computeSha3( uint[16] s, uint[8] cmix ) constant internal returns(uint) {\r\n        uint s0 = s[0] + s[1] * (2**32) + s[2] * (2**64) + s[3] * (2**96) +\r\n                  (s[4] + s[5] * (2**32) + s[6] * (2**64) + s[7] * (2**96))*(2**128);\r\n\r\n        uint s1 = s[8] + s[9] * (2**32) + s[10] * (2**64) + s[11] * (2**96) +\r\n                  (s[12] + s[13] * (2**32) + s[14] * (2**64) + s[15] * (2**96))*(2**128);\r\n                  \r\n        uint c = cmix[0] + cmix[1] * (2**32) + cmix[2] * (2**64) + cmix[3] * (2**96) +\r\n                  (cmix[4] + cmix[5] * (2**32) + cmix[6] * (2**64) + cmix[7] * (2**96))*(2**128);\r\n\r\n        \r\n        /* god knows why need to convert to big endian */\r\n        return uint( sha3(toBE(s0),toBE(s1),toBE(c)) );\r\n    }\r\n \r\n \r\n    function computeLeaf( uint[] dataSetLookup, uint index ) constant internal returns(uint) {\r\n        return uint( sha3(dataSetLookup[4*index],\r\n                          dataSetLookup[4*index + 1],\r\n                          dataSetLookup[4*index + 2],\r\n                          dataSetLookup[4*index + 3]) );\r\n                                    \r\n    }\r\n \r\n    function computeS( uint header, uint nonceLe ) constant internal returns(uint[16]) {\r\n        uint[9]  memory M;\r\n        \r\n        header = reverseBytes(header);\r\n        \r\n        M[0] = uint(header) & 0xFFFFFFFFFFFFFFFF;\r\n        header = header / 2**64;\r\n        M[1] = uint(header) & 0xFFFFFFFFFFFFFFFF;\r\n        header = header / 2**64;\r\n        M[2] = uint(header) & 0xFFFFFFFFFFFFFFFF;\r\n        header = header / 2**64;\r\n        M[3] = uint(header) & 0xFFFFFFFFFFFFFFFF;\r\n\r\n        // make little endian nonce\r\n        M[4] = nonceLe;\r\n        return sponge(M);\r\n    }\r\n    \r\n    function reverseBytes( uint input ) constant internal returns(uint) {\r\n        uint result = 0;\r\n        for(uint i = 0 ; i < 32 ; i++ ) {\r\n            result = result * 256;\r\n            result += input & 0xff;\r\n            \r\n            input /= 256;\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    struct EthashCacheOptData {\r\n        uint[512]    merkleNodes;\r\n        uint         fullSizeIn128Resultion;\r\n        uint         branchDepth;\r\n    }\r\n    \r\n    mapping(uint=>EthashCacheOptData) epochData;\r\n    \r\n    function getEpochData( uint epochIndex, uint nodeIndex ) constant returns(uint[3]) {\r\n        return [epochData[epochIndex].merkleNodes[nodeIndex],\r\n                epochData[epochIndex].fullSizeIn128Resultion,\r\n                epochData[epochIndex].branchDepth];\r\n    }\r\n    \r\n    function isEpochDataSet( uint epochIndex ) constant returns(bool) {\r\n        return epochData[epochIndex].fullSizeIn128Resultion != 0;\r\n    \r\n    }\r\n        \r\n    event SetEpochData( address indexed sender, uint error, uint errorInfo );    \r\n    function setEpochData( uint epoch,\r\n                           uint fullSizeIn128Resultion,\r\n                           uint branchDepth,\r\n                           uint[] merkleNodes,\r\n                           uint start,\r\n                           uint numElems ) {\r\n\r\n        if( ! owners[msg.sender] ) {\r\n            //ErrorLog( \"setEpochData: only owner can set data\", uint(msg.sender) );\r\n            SetEpochData( msg.sender, 0x82000000, uint(msg.sender) );\r\n            return;        \r\n        }                           \r\n                           \r\n        for( uint i = 0 ; i < numElems ; i++ ) {\r\n            if( epochData[epoch].merkleNodes[start+i] > 0 ) {\r\n                //ErrorLog(\"epoch already set\", epoch[i]);\r\n                SetEpochData( msg.sender, 0x82000001, epoch * (2**128) + start + i );\r\n                return;            \r\n\r\n            } \r\n            epochData[epoch].merkleNodes[start+i] = merkleNodes[i];\r\n        }\r\n        epochData[epoch].fullSizeIn128Resultion = fullSizeIn128Resultion;\r\n        epochData[epoch].branchDepth = branchDepth;\r\n        \r\n        SetEpochData( msg.sender, 0 , 0 );        \r\n    }\r\n\r\n    function getMerkleLeave( uint epochIndex, uint p ) constant internal returns(uint) {        \r\n        uint rootIndex = p >> epochData[epochIndex].branchDepth;\r\n        uint expectedRoot = epochData[epochIndex].merkleNodes[(rootIndex/2)];\r\n        if( (rootIndex % 2) == 0 ) expectedRoot = expectedRoot & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n        else expectedRoot = expectedRoot / (2**128);\r\n        \r\n        return expectedRoot;\r\n    }\r\n\r\n\r\n    function hashimoto( bytes32      header,\r\n                        bytes8       nonceLe,\r\n                        uint[]       dataSetLookup,\r\n                        uint[]       witnessForLookup,\r\n                        uint         epochIndex ) constant returns(uint) {\r\n         \r\n        uint[16] memory s;\r\n        uint[32] memory mix;\r\n        uint[8]  memory cmix;\r\n        \r\n        uint[2]  memory depthAndFullSize = [epochData[epochIndex].branchDepth, \r\n                                            epochData[epochIndex].fullSizeIn128Resultion];\r\n                \r\n        uint i;\r\n        uint j;\r\n        \r\n        if( ! isEpochDataSet( epochIndex ) ) return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE;\r\n        \r\n        if( depthAndFullSize[1] == 0 ) {\r\n            return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n        }\r\n\r\n        \r\n        s = computeS(uint(header), uint(nonceLe));\r\n        for( i = 0 ; i < 16 ; i++ ) {            \r\n            assembly {\r\n                let offset := mul(i,0x20)\r\n                \r\n                //mix[i] = s[i];\r\n                mstore(add(mix,offset),mload(add(s,offset)))\r\n                \r\n                // mix[i+16] = s[i];\r\n                mstore(add(mix,add(0x200,offset)),mload(add(s,offset)))    \r\n            }\r\n        }\r\n\r\n        for( i = 0 ; i < 64 ; i++ ) {\r\n            uint p = fnv( i ^ s[0], mix[i % 32]) % depthAndFullSize[1];\r\n            \r\n            \r\n            if( computeCacheRoot( p, i, dataSetLookup,  witnessForLookup, depthAndFullSize[0] )  != getMerkleLeave( epochIndex, p ) ) {\r\n            \r\n                // PoW failed\r\n                return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n            }       \r\n\r\n            for( j = 0 ; j < 8 ; j++ ) {\r\n\r\n                assembly{\r\n                    //mix[j] = fnv(mix[j], dataSetLookup[4*i] & varFFFFFFFF );\r\n                    let dataOffset := add(mul(0x80,i),add(dataSetLookup,0x20))\r\n                    let dataValue   := and(mload(dataOffset),0xFFFFFFFF)\r\n                    \r\n                    let mixOffset := add(mix,mul(0x20,j))\r\n                    let mixValue  := mload(mixOffset)\r\n                    \r\n                    // fnv = return ((v1*0x01000193) ^ v2) & 0xFFFFFFFF;\r\n                    let fnvValue := and(xor(mul(mixValue,0x01000193),dataValue),0xFFFFFFFF)                    \r\n                    mstore(mixOffset,fnvValue)\r\n                    \r\n                    //mix[j+8] = fnv(mix[j+8], dataSetLookup[4*i + 1] & 0xFFFFFFFF );\r\n                    dataOffset := add(dataOffset,0x20)\r\n                    dataValue   := and(mload(dataOffset),0xFFFFFFFF)\r\n                    \r\n                    mixOffset := add(mixOffset,0x100)\r\n                    mixValue  := mload(mixOffset)\r\n                    \r\n                    // fnv = return ((v1*0x01000193) ^ v2) & 0xFFFFFFFF;\r\n                    fnvValue := and(xor(mul(mixValue,0x01000193),dataValue),0xFFFFFFFF)                    \r\n                    mstore(mixOffset,fnvValue)\r\n\r\n                    //mix[j+16] = fnv(mix[j+16], dataSetLookup[4*i + 2] & 0xFFFFFFFF );\r\n                    dataOffset := add(dataOffset,0x20)\r\n                    dataValue   := and(mload(dataOffset),0xFFFFFFFF)\r\n                    \r\n                    mixOffset := add(mixOffset,0x100)\r\n                    mixValue  := mload(mixOffset)\r\n                    \r\n                    // fnv = return ((v1*0x01000193) ^ v2) & 0xFFFFFFFF;\r\n                    fnvValue := and(xor(mul(mixValue,0x01000193),dataValue),0xFFFFFFFF)                    \r\n                    mstore(mixOffset,fnvValue)\r\n\r\n                    //mix[j+24] = fnv(mix[j+24], dataSetLookup[4*i + 3] & 0xFFFFFFFF );\r\n                    dataOffset := add(dataOffset,0x20)\r\n                    dataValue   := and(mload(dataOffset),0xFFFFFFFF)\r\n                    \r\n                    mixOffset := add(mixOffset,0x100)\r\n                    mixValue  := mload(mixOffset)\r\n                    \r\n                    // fnv = return ((v1*0x01000193) ^ v2) & 0xFFFFFFFF;\r\n                    fnvValue := and(xor(mul(mixValue,0x01000193),dataValue),0xFFFFFFFF)                    \r\n                    mstore(mixOffset,fnvValue)                    \r\n                                        \r\n                }\r\n\r\n                \r\n                //mix[j] = fnv(mix[j], dataSetLookup[4*i] & 0xFFFFFFFF );\r\n                //mix[j+8] = fnv(mix[j+8], dataSetLookup[4*i + 1] & 0xFFFFFFFF );\r\n                //mix[j+16] = fnv(mix[j+16], dataSetLookup[4*i + 2] & 0xFFFFFFFF );                \r\n                //mix[j+24] = fnv(mix[j+24], dataSetLookup[4*i + 3] & 0xFFFFFFFF );\r\n                \r\n                \r\n                //dataSetLookup[4*i    ] = dataSetLookup[4*i    ]/(2**32);\r\n                //dataSetLookup[4*i + 1] = dataSetLookup[4*i + 1]/(2**32);\r\n                //dataSetLookup[4*i + 2] = dataSetLookup[4*i + 2]/(2**32);\r\n                //dataSetLookup[4*i + 3] = dataSetLookup[4*i + 3]/(2**32);                \r\n                \r\n                assembly{\r\n                    let offset := add(add(dataSetLookup,0x20),mul(i,0x80))\r\n                    let value  := div(mload(offset),0x100000000)\r\n                    mstore(offset,value)\r\n                                       \r\n                    offset := add(offset,0x20)\r\n                    value  := div(mload(offset),0x100000000)\r\n                    mstore(offset,value)\r\n                    \r\n                    offset := add(offset,0x20)\r\n                    value  := div(mload(offset),0x100000000)\r\n                    mstore(offset,value)                    \r\n                    \r\n                    offset := add(offset,0x20)\r\n                    value  := div(mload(offset),0x100000000)\r\n                    mstore(offset,value)                                                                                \r\n                }                \r\n            }\r\n        }\r\n        \r\n        \r\n        for( i = 0 ; i < 32 ; i += 4) {\r\n            cmix[i/4] = (fnv(fnv(fnv(mix[i], mix[i+1]), mix[i+2]), mix[i+3]));\r\n        }\r\n        \r\n\r\n        uint result = computeSha3(s,cmix); \r\n\r\n        return result;\r\n        \r\n    }\r\n}\r\n\r\n/**\r\n* @title RLPReader\r\n*\r\n* RLPReader is used to read and parse RLP encoded data in memory.\r\n*\r\n* @author Andreas Olofsson (androlo1980@gmail.com)\r\n*/\r\nlibrary RLP {\r\n\r\n uint constant DATA_SHORT_START = 0x80;\r\n uint constant DATA_LONG_START = 0xB8;\r\n uint constant LIST_SHORT_START = 0xC0;\r\n uint constant LIST_LONG_START = 0xF8;\r\n\r\n uint constant DATA_LONG_OFFSET = 0xB7;\r\n uint constant LIST_LONG_OFFSET = 0xF7;\r\n\r\n\r\n struct RLPItem {\r\n     uint _unsafe_memPtr;    // Pointer to the RLP-encoded bytes.\r\n     uint _unsafe_length;    // Number of bytes. This is the full length of the string.\r\n }\r\n\r\n struct Iterator {\r\n     RLPItem _unsafe_item;   // Item that's being iterated over.\r\n     uint _unsafe_nextPtr;   // Position of the next item in the list.\r\n }\r\n\r\n /* Iterator */\r\n\r\n function next(Iterator memory self) internal constant returns (RLPItem memory subItem) {\r\n     if(hasNext(self)) {\r\n         var ptr = self._unsafe_nextPtr;\r\n         var itemLength = _itemLength(ptr);\r\n         subItem._unsafe_memPtr = ptr;\r\n         subItem._unsafe_length = itemLength;\r\n         self._unsafe_nextPtr = ptr + itemLength;\r\n     }\r\n     else\r\n         throw;\r\n }\r\n\r\n function next(Iterator memory self, bool strict) internal constant returns (RLPItem memory subItem) {\r\n     subItem = next(self);\r\n     if(strict && !_validate(subItem))\r\n         throw;\r\n     return;\r\n }\r\n\r\n function hasNext(Iterator memory self) internal constant returns (bool) {\r\n     var item = self._unsafe_item;\r\n     return self._unsafe_nextPtr < item._unsafe_memPtr + item._unsafe_length;\r\n }\r\n\r\n /* RLPItem */\r\n\r\n /// @dev Creates an RLPItem from an array of RLP encoded bytes.\r\n /// @param self The RLP encoded bytes.\r\n /// @return An RLPItem\r\n function toRLPItem(bytes memory self) internal constant returns (RLPItem memory) {\r\n     uint len = self.length;\r\n     if (len == 0) {\r\n         return RLPItem(0, 0);\r\n     }\r\n     uint memPtr;\r\n     assembly {\r\n         memPtr := add(self, 0x20)\r\n     }\r\n     return RLPItem(memPtr, len);\r\n }\r\n\r\n /// @dev Creates an RLPItem from an array of RLP encoded bytes.\r\n /// @param self The RLP encoded bytes.\r\n /// @param strict Will throw if the data is not RLP encoded.\r\n /// @return An RLPItem\r\n function toRLPItem(bytes memory self, bool strict) internal constant returns (RLPItem memory) {\r\n     var item = toRLPItem(self);\r\n     if(strict) {\r\n         uint len = self.length;\r\n         if(_payloadOffset(item) > len)\r\n             throw;\r\n         if(_itemLength(item._unsafe_memPtr) != len)\r\n             throw;\r\n         if(!_validate(item))\r\n             throw;\r\n     }\r\n     return item;\r\n }\r\n\r\n /// @dev Check if the RLP item is null.\r\n /// @param self The RLP item.\r\n /// @return 'true' if the item is null.\r\n function isNull(RLPItem memory self) internal constant returns (bool ret) {\r\n     return self._unsafe_length == 0;\r\n }\r\n\r\n /// @dev Check if the RLP item is a list.\r\n /// @param self The RLP item.\r\n /// @return 'true' if the item is a list.\r\n function isList(RLPItem memory self) internal constant returns (bool ret) {\r\n     if (self._unsafe_length == 0)\r\n         return false;\r\n     uint memPtr = self._unsafe_memPtr;\r\n     assembly {\r\n         ret := iszero(lt(byte(0, mload(memPtr)), 0xC0))\r\n     }\r\n }\r\n\r\n /// @dev Check if the RLP item is data.\r\n /// @param self The RLP item.\r\n /// @return 'true' if the item is data.\r\n function isData(RLPItem memory self) internal constant returns (bool ret) {\r\n     if (self._unsafe_length == 0)\r\n         return false;\r\n     uint memPtr = self._unsafe_memPtr;\r\n     assembly {\r\n         ret := lt(byte(0, mload(memPtr)), 0xC0)\r\n     }\r\n }\r\n\r\n /// @dev Check if the RLP item is empty (string or list).\r\n /// @param self The RLP item.\r\n /// @return 'true' if the item is null.\r\n function isEmpty(RLPItem memory self) internal constant returns (bool ret) {\r\n     if(isNull(self))\r\n         return false;\r\n     uint b0;\r\n     uint memPtr = self._unsafe_memPtr;\r\n     assembly {\r\n         b0 := byte(0, mload(memPtr))\r\n     }\r\n     return (b0 == DATA_SHORT_START || b0 == LIST_SHORT_START);\r\n }\r\n\r\n /// @dev Get the number of items in an RLP encoded list.\r\n /// @param self The RLP item.\r\n /// @return The number of items.\r\n function items(RLPItem memory self) internal constant returns (uint) {\r\n     if (!isList(self))\r\n         return 0;\r\n     uint b0;\r\n     uint memPtr = self._unsafe_memPtr;\r\n     assembly {\r\n         b0 := byte(0, mload(memPtr))\r\n     }\r\n     uint pos = memPtr + _payloadOffset(self);\r\n     uint last = memPtr + self._unsafe_length - 1;\r\n     uint itms;\r\n     while(pos <= last) {\r\n         pos += _itemLength(pos);\r\n         itms++;\r\n     }\r\n     return itms;\r\n }\r\n\r\n /// @dev Create an iterator.\r\n /// @param self The RLP item.\r\n /// @return An 'Iterator' over the item.\r\n function iterator(RLPItem memory self) internal constant returns (Iterator memory it) {\r\n     if (!isList(self))\r\n         throw;\r\n     uint ptr = self._unsafe_memPtr + _payloadOffset(self);\r\n     it._unsafe_item = self;\r\n     it._unsafe_nextPtr = ptr;\r\n }\r\n\r\n /// @dev Return the RLP encoded bytes.\r\n /// @param self The RLPItem.\r\n /// @return The bytes.\r\n function toBytes(RLPItem memory self) internal constant returns (bytes memory bts) {\r\n     var len = self._unsafe_length;\r\n     if (len == 0)\r\n         return;\r\n     bts = new bytes(len);\r\n     _copyToBytes(self._unsafe_memPtr, bts, len);\r\n }\r\n\r\n /// @dev Decode an RLPItem into bytes. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toData(RLPItem memory self) internal constant returns (bytes memory bts) {\r\n     if(!isData(self))\r\n         throw;\r\n     var (rStartPos, len) = _decode(self);\r\n     bts = new bytes(len);\r\n     _copyToBytes(rStartPos, bts, len);\r\n }\r\n\r\n /// @dev Get the list of sub-items from an RLP encoded list.\r\n /// Warning: This is inefficient, as it requires that the list is read twice.\r\n /// @param self The RLP item.\r\n /// @return Array of RLPItems.\r\n function toList(RLPItem memory self) internal constant returns (RLPItem[] memory list) {\r\n     if(!isList(self))\r\n         throw;\r\n     var numItems = items(self);\r\n     list = new RLPItem[](numItems);\r\n     var it = iterator(self);\r\n     uint idx;\r\n     while(hasNext(it)) {\r\n         list[idx] = next(it);\r\n         idx++;\r\n     }\r\n }\r\n\r\n /// @dev Decode an RLPItem into an ascii string. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toAscii(RLPItem memory self) internal constant returns (string memory str) {\r\n     if(!isData(self))\r\n         throw;\r\n     var (rStartPos, len) = _decode(self);\r\n     bytes memory bts = new bytes(len);\r\n     _copyToBytes(rStartPos, bts, len);\r\n     str = string(bts);\r\n }\r\n\r\n /// @dev Decode an RLPItem into a uint. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toUint(RLPItem memory self) internal constant returns (uint data) {\r\n     if(!isData(self))\r\n         throw;\r\n     var (rStartPos, len) = _decode(self);\r\n     if (len > 32 || len == 0)\r\n         throw;\r\n     assembly {\r\n         data := div(mload(rStartPos), exp(256, sub(32, len)))\r\n     }\r\n }\r\n\r\n /// @dev Decode an RLPItem into a boolean. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toBool(RLPItem memory self) internal constant returns (bool data) {\r\n     if(!isData(self))\r\n         throw;\r\n     var (rStartPos, len) = _decode(self);\r\n     if (len != 1)\r\n         throw;\r\n     uint temp;\r\n     assembly {\r\n         temp := byte(0, mload(rStartPos))\r\n     }\r\n     if (temp > 1)\r\n         throw;\r\n     return temp == 1 ? true : false;\r\n }\r\n\r\n /// @dev Decode an RLPItem into a byte. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toByte(RLPItem memory self) internal constant returns (byte data) {\r\n     if(!isData(self))\r\n         throw;\r\n     var (rStartPos, len) = _decode(self);\r\n     if (len != 1)\r\n         throw;\r\n     uint temp;\r\n     assembly {\r\n         temp := byte(0, mload(rStartPos))\r\n     }\r\n     return byte(temp);\r\n }\r\n\r\n /// @dev Decode an RLPItem into an int. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toInt(RLPItem memory self) internal constant returns (int data) {\r\n     return int(toUint(self));\r\n }\r\n\r\n /// @dev Decode an RLPItem into a bytes32. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toBytes32(RLPItem memory self) internal constant returns (bytes32 data) {\r\n     return bytes32(toUint(self));\r\n }\r\n\r\n /// @dev Decode an RLPItem into an address. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toAddress(RLPItem memory self) internal constant returns (address data) {\r\n     if(!isData(self))\r\n         throw;\r\n     var (rStartPos, len) = _decode(self);\r\n     if (len != 20)\r\n         throw;\r\n     assembly {\r\n         data := div(mload(rStartPos), exp(256, 12))\r\n     }\r\n }\r\n\r\n // Get the payload offset.\r\n function _payloadOffset(RLPItem memory self) private constant returns (uint) {\r\n     if(self._unsafe_length == 0)\r\n         return 0;\r\n     uint b0;\r\n     uint memPtr = self._unsafe_memPtr;\r\n     assembly {\r\n         b0 := byte(0, mload(memPtr))\r\n     }\r\n     if(b0 < DATA_SHORT_START)\r\n         return 0;\r\n     if(b0 < DATA_LONG_START || (b0 >= LIST_SHORT_START && b0 < LIST_LONG_START))\r\n         return 1;\r\n     if(b0 < LIST_SHORT_START)\r\n         return b0 - DATA_LONG_OFFSET + 1;\r\n     return b0 - LIST_LONG_OFFSET + 1;\r\n }\r\n\r\n // Get the full length of an RLP item.\r\n function _itemLength(uint memPtr) private constant returns (uint len) {\r\n     uint b0;\r\n     assembly {\r\n         b0 := byte(0, mload(memPtr))\r\n     }\r\n     if (b0 < DATA_SHORT_START)\r\n         len = 1;\r\n     else if (b0 < DATA_LONG_START)\r\n         len = b0 - DATA_SHORT_START + 1;\r\n     else if (b0 < LIST_SHORT_START) {\r\n         assembly {\r\n             let bLen := sub(b0, 0xB7) // bytes length (DATA_LONG_OFFSET)\r\n             let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\r\n             len := add(1, add(bLen, dLen)) // total length\r\n         }\r\n     }\r\n     else if (b0 < LIST_LONG_START)\r\n         len = b0 - LIST_SHORT_START + 1;\r\n     else {\r\n         assembly {\r\n             let bLen := sub(b0, 0xF7) // bytes length (LIST_LONG_OFFSET)\r\n             let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\r\n             len := add(1, add(bLen, dLen)) // total length\r\n         }\r\n     }\r\n }\r\n\r\n // Get start position and length of the data.\r\n function _decode(RLPItem memory self) private constant returns (uint memPtr, uint len) {\r\n     if(!isData(self))\r\n         throw;\r\n     uint b0;\r\n     uint start = self._unsafe_memPtr;\r\n     assembly {\r\n         b0 := byte(0, mload(start))\r\n     }\r\n     if (b0 < DATA_SHORT_START) {\r\n         memPtr = start;\r\n         len = 1;\r\n         return;\r\n     }\r\n     if (b0 < DATA_LONG_START) {\r\n         len = self._unsafe_length - 1;\r\n         memPtr = start + 1;\r\n     } else {\r\n         uint bLen;\r\n         assembly {\r\n             bLen := sub(b0, 0xB7) // DATA_LONG_OFFSET\r\n         }\r\n         len = self._unsafe_length - 1 - bLen;\r\n         memPtr = start + bLen + 1;\r\n     }\r\n     return;\r\n }\r\n\r\n // Assumes that enough memory has been allocated to store in target.\r\n function _copyToBytes(uint btsPtr, bytes memory tgt, uint btsLen) private constant {\r\n     // Exploiting the fact that 'tgt' was the last thing to be allocated,\r\n     // we can write entire words, and just overwrite any excess.\r\n     assembly {\r\n         {\r\n                 let i := 0 // Start at arr + 0x20\r\n                 let words := div(add(btsLen, 31), 32)\r\n                 let rOffset := btsPtr\r\n                 let wOffset := add(tgt, 0x20)\r\n             tag_loop:\r\n                 jumpi(end, eq(i, words))\r\n                 {\r\n                     let offset := mul(i, 0x20)\r\n                     mstore(add(wOffset, offset), mload(add(rOffset, offset)))\r\n                     i := add(i, 1)\r\n                 }\r\n                 jump(tag_loop)\r\n             end:\r\n                 mstore(add(tgt, add(0x20, mload(tgt))), 0)\r\n         }\r\n     }\r\n }\r\n\r\n     // Check that an RLP item is valid.\r\n     function _validate(RLPItem memory self) private constant returns (bool ret) {\r\n         // Check that RLP is well-formed.\r\n         uint b0;\r\n         uint b1;\r\n         uint memPtr = self._unsafe_memPtr;\r\n         assembly {\r\n             b0 := byte(0, mload(memPtr))\r\n             b1 := byte(1, mload(memPtr))\r\n         }\r\n         if(b0 == DATA_SHORT_START + 1 && b1 < DATA_SHORT_START)\r\n             return false;\r\n         return true;\r\n     }\r\n}\r\n\r\n\r\n\r\n\r\ncontract Agt {\r\n    using RLP for RLP.RLPItem;\r\n    using RLP for RLP.Iterator;\r\n    using RLP for bytes;\r\n \r\n    struct BlockHeader {\r\n        uint       prevBlockHash; // 0\r\n        uint       coinbase;      // 1\r\n        uint       blockNumber;   // 8\r\n        //uint       gasUsed;       // 10\r\n        uint       timestamp;     // 11\r\n        bytes32    extraData;     // 12\r\n    }\r\n \r\n    function Agt() {}\r\n     \r\n    function parseBlockHeader( bytes rlpHeader ) constant internal returns(BlockHeader) {\r\n        BlockHeader memory header;\r\n        \r\n        var it = rlpHeader.toRLPItem().iterator();        \r\n        uint idx;\r\n        while(it.hasNext()) {\r\n            if( idx == 0 ) header.prevBlockHash = it.next().toUint();\r\n            else if ( idx == 2 ) header.coinbase = it.next().toUint();\r\n            else if ( idx == 8 ) header.blockNumber = it.next().toUint();\r\n            else if ( idx == 11 ) header.timestamp = it.next().toUint();\r\n            else if ( idx == 12 ) header.extraData = bytes32(it.next().toUint());\r\n            else it.next();\r\n            \r\n            idx++;\r\n        }\r\n \r\n        return header;        \r\n    }\r\n            \r\n    //event VerifyAgt( string msg, uint index );\r\n    event VerifyAgt( uint error, uint index );    \r\n    \r\n    struct VerifyAgtData {\r\n        uint rootHash;\r\n        uint rootMin;\r\n        uint rootMax;\r\n        \r\n        uint leafHash;\r\n        uint leafCounter;        \r\n    }\r\n\r\n    function verifyAgt( VerifyAgtData data,\r\n                        uint   branchIndex,\r\n                        uint[] countersBranch,\r\n                        uint[] hashesBranch ) constant internal returns(bool) {\r\n                        \r\n        uint currentHash = data.leafHash & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n        \r\n        uint leftCounterMin;\r\n        uint leftCounterMax;        \r\n        uint leftHash;\r\n        \r\n        uint rightCounterMin;\r\n        uint rightCounterMax;        \r\n        uint rightHash;\r\n        \r\n        uint min = data.leafCounter;\r\n        uint max = data.leafCounter;\r\n        \r\n        for( uint i = 0 ; i < countersBranch.length ; i++ ) {\r\n            if( branchIndex & 0x1 > 0 ) {\r\n                leftCounterMin = countersBranch[i] & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n                leftCounterMax = countersBranch[i] >> 128;                \r\n                leftHash    = hashesBranch[i];\r\n                \r\n                rightCounterMin = min;\r\n                rightCounterMax = max;\r\n                rightHash    = currentHash;                \r\n            }\r\n            else {                \r\n                leftCounterMin = min;\r\n                leftCounterMax = max;\r\n                leftHash    = currentHash;\r\n                \r\n                rightCounterMin = countersBranch[i] & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n                rightCounterMax = countersBranch[i] >> 128;                \r\n                rightHash    = hashesBranch[i];                                            \r\n            }\r\n            \r\n            currentHash = uint(sha3(leftCounterMin + (leftCounterMax << 128),\r\n                                    leftHash,\r\n                                    rightCounterMin + (rightCounterMax << 128),\r\n                                    rightHash)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n            \r\n            if( (leftCounterMin >= leftCounterMax) || (rightCounterMin >= rightCounterMax) ) {\r\n                if( i > 0 ) {\r\n                    //VerifyAgt( \"counters mismatch\",i);\r\n                    VerifyAgt( 0x80000000, i );\r\n                    return false;\r\n                }\r\n                if( leftCounterMin > leftCounterMax ) {\r\n                    //VerifyAgt( \"counters mismatch\",i);\r\n                    VerifyAgt( 0x80000001, i );                \r\n                    return false;\r\n                }\r\n                if( rightCounterMin > rightCounterMax ) {\r\n                    //VerifyAgt( \"counters mismatch\",i);\r\n                    VerifyAgt( 0x80000002, i );                \r\n                    return false;\r\n                }                \r\n            }\r\n            \r\n            if( leftCounterMax >= rightCounterMin ) {\r\n                VerifyAgt( 0x80000009, i );            \r\n                return false;\r\n            }\r\n\r\n            min = leftCounterMin;\r\n            max = rightCounterMax;\r\n            \r\n            branchIndex = branchIndex / 2;\r\n        }\r\n\r\n        if( min != data.rootMin ) {\r\n            //VerifyAgt( \"min does not match root min\",min);\r\n            VerifyAgt( 0x80000003, min );                        \r\n            return false;\r\n        }\r\n        if( max != data.rootMax ) {\r\n            //VerifyAgt( \"max does not match root max\",max);\r\n            VerifyAgt( 0x80000004, max );                    \r\n            return false;\r\n        }\r\n        \r\n        if( currentHash != data.rootHash ) {\r\n            //VerifyAgt( \"hash does not match root hash\",currentHash);        \r\n            VerifyAgt( 0x80000005, currentHash );\r\n            return false;\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function verifyAgtDebugForTesting( uint rootHash,\r\n                                       uint rootMin,\r\n                                       uint rootMax,\r\n                                       uint leafHash,\r\n                                       uint leafCounter,\r\n                                       uint branchIndex,\r\n                                       uint[] countersBranch,\r\n                                       uint[] hashesBranch ) returns(bool) {\r\n                                       \r\n        VerifyAgtData memory data;\r\n        data.rootHash = rootHash;\r\n        data.rootMin = rootMin;\r\n        data.rootMax = rootMax;\r\n        data.leafHash = leafHash;\r\n        data.leafCounter = leafCounter;\r\n        \r\n        return verifyAgt( data, branchIndex, countersBranch, hashesBranch );\r\n    }         \r\n}\r\n\r\ncontract WeightedSubmission {\r\n    function WeightedSubmission(){}\r\n    \r\n    struct SingleSubmissionData {\r\n        uint128 numShares;\r\n        uint128 submissionValue;\r\n        uint128 totalPreviousSubmissionValue;\r\n        uint128 min;\r\n        uint128 max;\r\n        uint128 augRoot;\r\n    }\r\n    \r\n    struct SubmissionMetaData {\r\n        uint64  numPendingSubmissions;\r\n        uint32  readyForVerification; // suppose to be bool\r\n        uint32  lastSubmissionBlockNumber;\r\n        uint128 totalSubmissionValue;\r\n        uint128 difficulty;\r\n        uint128 lastCounter;\r\n        \r\n        uint    submissionSeed;\r\n        \r\n    }\r\n    \r\n    mapping(address=>SubmissionMetaData) submissionsMetaData;\r\n    \r\n    // (user, submission number)=>data\r\n    mapping(address=>mapping(uint=>SingleSubmissionData)) submissionsData;\r\n    \r\n    event SubmitClaim( address indexed sender, uint error, uint errorInfo );\r\n    function submitClaim( uint numShares, uint difficulty, uint min, uint max, uint augRoot, bool lastClaimBeforeVerification ) {\r\n        SubmissionMetaData memory metaData = submissionsMetaData[msg.sender];\r\n        \r\n        if( metaData.lastCounter >= min ) {\r\n            // miner cheated. min counter is too low\r\n            SubmitClaim( msg.sender, 0x81000001, metaData.lastCounter ); \r\n            return;        \r\n        }\r\n        \r\n        if( metaData.readyForVerification > 0 ) {\r\n            // miner cheated - should go verification first\r\n            SubmitClaim( msg.sender, 0x81000002, 0 ); \r\n            return;\r\n        }\r\n        \r\n        if( metaData.numPendingSubmissions > 0 ) {\r\n            if( metaData.difficulty != difficulty ) {\r\n                // could not change difficulty before verification\r\n                SubmitClaim( msg.sender, 0x81000003, metaData.difficulty ); \r\n                return;            \r\n            }\r\n        }\r\n        \r\n        SingleSubmissionData memory submissionData;\r\n        \r\n        submissionData.numShares = uint64(numShares);\r\n        uint blockDifficulty;\r\n        if( block.difficulty == 0 ) {\r\n            // testrpc - fake increasing difficulty\r\n            blockDifficulty = (900000000 * (metaData.numPendingSubmissions+1)); \r\n        }\r\n        else {\r\n            blockDifficulty = block.difficulty;\r\n        }\r\n        \r\n        submissionData.submissionValue = uint128((uint(numShares * difficulty) * (5 ether)) / blockDifficulty);\r\n        \r\n        submissionData.totalPreviousSubmissionValue = metaData.totalSubmissionValue;\r\n        submissionData.min = uint128(min);\r\n        submissionData.max = uint128(max);\r\n        submissionData.augRoot = uint128(augRoot);\r\n        \r\n        (submissionsData[msg.sender])[metaData.numPendingSubmissions] = submissionData;\r\n        \r\n        // update meta data\r\n        metaData.numPendingSubmissions++;\r\n        metaData.lastSubmissionBlockNumber = uint32(block.number);\r\n        metaData.difficulty = uint128(difficulty);\r\n        metaData.lastCounter = uint128(max);\r\n        metaData.readyForVerification = lastClaimBeforeVerification ? uint32(1) : uint32(0);\r\n\r\n        uint128 temp128;\r\n        \r\n        \r\n        temp128 = metaData.totalSubmissionValue; \r\n\r\n        metaData.totalSubmissionValue += submissionData.submissionValue;\r\n        \r\n        if( temp128 > metaData.totalSubmissionValue ) {\r\n            // overflow in calculation\r\n            // note that this code is reachable if user is dishonest and give false\r\n            // report on his submission. but even without\r\n            // this validation, user cannot benifit from the overflow\r\n            SubmitClaim( msg.sender, 0x81000005, 0 ); \r\n            return;                                \r\n        }\r\n                \r\n        \r\n        submissionsMetaData[msg.sender] = metaData;\r\n        \r\n        // everything is ok\r\n        SubmitClaim( msg.sender, 0, numShares * difficulty );\r\n    }\r\n\r\n    function getClaimSeed(address sender) constant returns(uint){\r\n        SubmissionMetaData memory metaData = submissionsMetaData[sender];\r\n        if( metaData.readyForVerification == 0 ) return 0;\r\n        \r\n        if( metaData.submissionSeed != 0 ) return metaData.submissionSeed; \r\n        \r\n        uint lastBlockNumber = uint(metaData.lastSubmissionBlockNumber);\r\n        \r\n        if( block.number > lastBlockNumber + 200 ) return 0;\r\n        if( block.number <= lastBlockNumber + 15 ) return 0;\r\n                \r\n        return uint(block.blockhash(lastBlockNumber + 10));\r\n    }\r\n    \r\n    event StoreClaimSeed( address indexed sender, uint error, uint errorInfo );\r\n    function storeClaimSeed( address miner ) {\r\n        // anyone who is willing to pay gas fees can call this function\r\n        uint seed = getClaimSeed( miner );\r\n        if( seed != 0 ) {\r\n            submissionsMetaData[miner].submissionSeed = seed;\r\n            StoreClaimSeed( msg.sender, 0, uint(miner) );\r\n            return;\r\n        }\r\n        \r\n        // else\r\n        SubmissionMetaData memory metaData = submissionsMetaData[miner];\r\n        uint lastBlockNumber = uint(metaData.lastSubmissionBlockNumber);\r\n                \r\n        if( metaData.readyForVerification == 0 ) {\r\n            // submission is not ready for verification\r\n            StoreClaimSeed( msg.sender, 0x8000000, uint(miner) );\r\n        }\r\n        else if( block.number > lastBlockNumber + 200 ) {\r\n            // submission is not ready for verification\r\n            StoreClaimSeed( msg.sender, 0x8000001, uint(miner) );\r\n        }\r\n        else if( block.number <= lastBlockNumber + 15 ) {\r\n            // it is too late to call store function\r\n            StoreClaimSeed( msg.sender, 0x8000002, uint(miner) );\r\n        }\r\n        else {\r\n            // unknown error\r\n            StoreClaimSeed( msg.sender, 0x8000003, uint(miner) );\r\n        }\r\n    }\r\n\r\n    function verifySubmissionIndex( address sender, uint seed, uint submissionNumber, uint shareIndex ) constant returns(bool) {\r\n        if( seed == 0 ) return false;\r\n    \r\n        uint totalValue = uint(submissionsMetaData[sender].totalSubmissionValue);\r\n        uint numPendingSubmissions = uint(submissionsMetaData[sender].numPendingSubmissions);\r\n\r\n        SingleSubmissionData memory submissionData = (submissionsData[sender])[submissionNumber];        \r\n        \r\n        if( submissionNumber >= numPendingSubmissions ) return false;\r\n        \r\n        uint seed1 = seed & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n        uint seed2 = seed / (2**128);\r\n        \r\n        uint selectedValue = seed1 % totalValue;\r\n        if( uint(submissionData.totalPreviousSubmissionValue) >= selectedValue ) return false;\r\n        if( uint(submissionData.totalPreviousSubmissionValue + submissionData.submissionValue) < selectedValue ) return false;  \r\n\r\n        uint expectedShareshareIndex = (seed2 % uint(submissionData.numShares));\r\n        if( expectedShareshareIndex != shareIndex ) return false;\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function calculateSubmissionIndex( address sender, uint seed ) constant returns(uint[2]) {\r\n        // this function should be executed off chain - hene, it is not optimized\r\n        uint seed1 = seed & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n        uint seed2 = seed / (2**128);\r\n\r\n        uint totalValue = uint(submissionsMetaData[sender].totalSubmissionValue);\r\n        uint numPendingSubmissions = uint(submissionsMetaData[sender].numPendingSubmissions);\r\n\r\n        uint selectedValue = seed1 % totalValue;\r\n        \r\n        SingleSubmissionData memory submissionData;        \r\n        \r\n        for( uint submissionInd = 0 ; submissionInd < numPendingSubmissions ; submissionInd++ ) {\r\n            submissionData = (submissionsData[sender])[submissionInd];        \r\n            if( uint(submissionData.totalPreviousSubmissionValue + submissionData.submissionValue) >= selectedValue ) break;  \r\n        }\r\n        \r\n        // unexpected error\r\n        if( submissionInd == numPendingSubmissions ) return [uint(0xFFFFFFFFFFFFFFFF),0xFFFFFFFFFFFFFFFF];\r\n\r\n        uint shareIndex = seed2 % uint(submissionData.numShares); \r\n        \r\n        return [submissionInd, shareIndex];\r\n    }\r\n    \r\n    // should be called only from verify claim\r\n    function closeSubmission( address sender ) internal {\r\n        SubmissionMetaData memory metaData = submissionsMetaData[sender];\r\n        metaData.numPendingSubmissions = 0;\r\n        metaData.totalSubmissionValue = 0;\r\n        metaData.readyForVerification = 0;\r\n        metaData.submissionSeed = 0;\r\n        \r\n        // last counter must not be reset\r\n        // last submission block number and difficulty are also kept, but it is not a must\r\n        // only to save some gas        \r\n        \r\n        submissionsMetaData[sender] = metaData;\r\n    }\r\n    \r\n    struct SubmissionDataForClaimVerification {\r\n        uint lastCounter;\r\n        uint shareDifficulty;\r\n        uint totalSubmissionValue;\r\n        uint min;\r\n        uint max;\r\n        uint augMerkle;\r\n        \r\n        bool indicesAreValid;\r\n        bool readyForVerification;\r\n    }\r\n    \r\n    function getClaimData( address sender, uint submissionIndex, uint shareIndex, uint seed )\r\n                           constant internal returns(SubmissionDataForClaimVerification){\r\n                           \r\n        SubmissionDataForClaimVerification memory output;\r\n\r\n        SubmissionMetaData memory metaData = submissionsMetaData[sender];\r\n        \r\n        output.lastCounter = uint(metaData.lastCounter);\r\n        output.shareDifficulty = uint(metaData.difficulty);\r\n        output.totalSubmissionValue = metaData.totalSubmissionValue;\r\n        \r\n\r\n        SingleSubmissionData memory submissionData = (submissionsData[sender])[submissionIndex];\r\n        \r\n        output.min = uint(submissionData.min);\r\n        output.max = uint(submissionData.max);\r\n        output.augMerkle = uint(submissionData.augRoot);\r\n        \r\n        output.indicesAreValid = verifySubmissionIndex( sender, seed, submissionIndex, shareIndex );\r\n        output.readyForVerification = (metaData.readyForVerification > 0);\r\n        \r\n        return output; \r\n    }\r\n    \r\n    function debugGetNumPendingSubmissions( address sender ) constant returns(uint) {\r\n        return uint(submissionsMetaData[sender].numPendingSubmissions);\r\n    }\r\n    \r\n    event DebugResetSubmissions( address indexed sender, uint error, uint errorInfo );\r\n    function debugResetSubmissions( ) {\r\n        // should be called only in emergency\r\n        // msg.sender will loose all its pending shares\r\n        closeSubmission(msg.sender);\r\n        DebugResetSubmissions( msg.sender, 0, 0 );\r\n    }    \r\n}\r\n\r\n\r\ncontract SmartPool is Agt, WeightedSubmission {    \r\n    string  public version = \"0.1.1\";\r\n    \r\n    Ethash  public ethashContract; \r\n    address public withdrawalAddress;\r\n    mapping(address=>bool) public owners; \r\n    \r\n    bool public newVersionReleased = false;\r\n        \r\n    struct MinerData {\r\n        bytes32        minerId;\r\n        address        paymentAddress;\r\n    }\r\n\r\n    mapping(address=>MinerData) minersData;\r\n    mapping(bytes32=>bool)      public existingIds;        \r\n    \r\n    bool public whiteListEnabled;\r\n    bool public blackListEnabled;\r\n    mapping(address=>bool) whiteList;\r\n    mapping(address=>bool) blackList;    \r\n    \r\n    function SmartPool( address[] _owners,\r\n                        Ethash _ethashContract,\r\n                        address _withdrawalAddress,\r\n                        bool _whiteListEnabeled,\r\n                        bool _blackListEnabled ) payable {\r\n                        \r\n        for( uint i = 0 ; i < _owners.length ; i++ ) {\r\n            owners[_owners[0]] = true; \r\n            owners[_owners[1]] = true;\r\n            owners[_owners[2]] = true;\r\n        }\r\n        \r\n        ethashContract = _ethashContract;\r\n        withdrawalAddress = _withdrawalAddress;\r\n        \r\n        whiteListEnabled = _whiteListEnabeled;\r\n        blackListEnabled = _blackListEnabled;               \r\n    }\r\n    \r\n    function declareNewerVersion() {\r\n        if( ! owners[msg.sender] ) throw;\r\n        \r\n        newVersionReleased = true;\r\n        \r\n        //if( ! msg.sender.send(this.balance) ) throw;\r\n    }\r\n    \r\n    event Withdraw( address indexed sender, uint error, uint errorInfo );\r\n    function withdraw( uint amount ) {\r\n        if( ! owners[msg.sender] ) {\r\n            // only ownder can withdraw\r\n            Withdraw( msg.sender, 0x80000000, amount );\r\n            return;\r\n        }\r\n        \r\n        if( ! withdrawalAddress.send( amount ) ) throw;\r\n        \r\n        Withdraw( msg.sender, 0, amount );            \r\n    }\r\n    \r\n    function to62Encoding( uint id, uint numChars ) constant returns(bytes32) {\r\n        if( id >= (26+26+10)**numChars ) throw;\r\n        uint result = 0;\r\n        for( uint i = 0 ; i < numChars ; i++ ) {\r\n            uint b = id % (26+26+10);\r\n            uint8 char;\r\n            if( b < 10 ) {\r\n                char = uint8(b + 0x30); // 0x30 = '0' \r\n            }\r\n            else if( b < 26 + 10 ) {\r\n                char = uint8(b + 0x61 - 10); //0x61 = 'a'\r\n            }\r\n            else {\r\n                char = uint8(b + 0x41 - 26 - 10); // 0x41 = 'A'         \r\n            }\r\n            \r\n            result = (result * 256) + char;\r\n            id /= (26+26+10);\r\n        }\r\n\r\n        return bytes32(result);\r\n    }\r\n        \r\n    event Register( address indexed sender, uint error, uint errorInfo );    \r\n    function register( address paymentAddress ) {\r\n        address minerAddress = msg.sender;\r\n        \r\n        // build id\r\n        uint id = uint(minerAddress) % (26+26+10)**11;        \r\n        bytes32 minerId = to62Encoding(id,11);\r\n        \r\n        if( existingIds[minersData[minerAddress].minerId] ) {\r\n            // miner id is already in use\r\n            Register( msg.sender, 0x80000000, uint(minerId) ); \r\n            return;\r\n        }\r\n        \r\n        if( paymentAddress == address(0) ) {\r\n            // payment address is 0\r\n            Register( msg.sender, 0x80000001, uint(paymentAddress) ); \r\n            return;\r\n        }\r\n        \r\n        if( whiteListEnabled ) {\r\n            if( ! whiteList[ msg.sender ] ) {\r\n                // miner not in white list\r\n                Register( msg.sender, 0x80000002, uint(minerId) );\r\n                return;                 \r\n            }\r\n        }\r\n        \r\n        if( blackListEnabled ) {\r\n            if( blackList[ msg.sender ] ) {\r\n                // miner on black list\r\n                Register( msg.sender, 0x80000003, uint(minerId) );\r\n                return;                 \r\n            }        \r\n        }\r\n        \r\n        \r\n        \r\n        // last counter is set to 0. \r\n        // It might be safer to change it to now.\r\n        //minersData[minerAddress].lastCounter = now * (2**64);\r\n        minersData[minerAddress].paymentAddress = paymentAddress;        \r\n        minersData[minerAddress].minerId = minerId;\r\n        existingIds[minersData[minerAddress].minerId] = true;\r\n        \r\n        // succesful registration\r\n        Register( msg.sender, 0, 0 ); \r\n    }\r\n\r\n    function canRegister(address sender) constant returns(bool) {\r\n        uint id = uint(sender) % (26+26+10)**11;\r\n        bytes32 expectedId = to62Encoding(id,11);\r\n        \r\n        if( whiteListEnabled ) {\r\n            if( ! whiteList[ sender ] ) return false; \r\n        }\r\n        if( blackListEnabled ) {\r\n            if( blackList[ sender ] ) return false;        \r\n        }\r\n        \r\n        return ! existingIds[expectedId];\r\n    }\r\n    \r\n    function isRegistered(address sender) constant returns(bool) {\r\n        return minersData[sender].paymentAddress != address(0);\r\n    }\r\n    \r\n    function getMinerId(address sender) constant returns(bytes32) {\r\n        return minersData[sender].minerId;\r\n    }\r\n\r\n    event UpdateWhiteList( address indexed miner, uint error, uint errorInfo, bool add );\r\n    event UpdateBlackList( address indexed miner, uint error, uint errorInfo, bool add );    \r\n\r\n    function unRegister( address miner ) internal {\r\n        minersData[miner].paymentAddress = address(0);\r\n        existingIds[minersData[miner].minerId] = false;            \r\n    }\r\n    \r\n    function updateWhiteList( address miner, bool add ) {\r\n        if( ! owners[ msg.sender ] ) {\r\n            // only owner can update list\r\n            UpdateWhiteList( msg.sender, 0x80000000, 0, add );\r\n            return;\r\n        }\r\n        if( ! whiteListEnabled ) {\r\n            // white list is not enabeled\r\n            UpdateWhiteList( msg.sender, 0x80000001, 0, add );        \r\n            return;\r\n        }\r\n        \r\n        whiteList[ miner ] = add;\r\n        if( ! add && isRegistered( miner ) ) {\r\n            // unregister\r\n            unRegister( miner );\r\n        }\r\n        \r\n        UpdateWhiteList( msg.sender, 0, uint(miner), add );\r\n    }\r\n\r\n    function updateBlackList( address miner, bool add ) {\r\n        if( ! owners[ msg.sender ] ) {\r\n            // only owner can update list\r\n            UpdateBlackList( msg.sender, 0x80000000, 0, add );\r\n            return;\r\n        }\r\n        if( ! blackListEnabled ) {\r\n            // white list is not enabeled\r\n            UpdateBlackList( msg.sender, 0x80000001, 0, add );        \r\n            return;\r\n        }\r\n        \r\n        blackList[ miner ] = add;\r\n        if( add && isRegistered( miner ) ) {\r\n            // unregister\r\n            unRegister( miner );\r\n        }\r\n        \r\n        UpdateBlackList( msg.sender, 0, uint(miner), add );\r\n    }\r\n    \r\n    event DisableBlackListForever( address indexed sender, uint error, uint errorInfo );    \r\n    function disableBlackListForever() {\r\n        if( ! owners[ msg.sender ] ) {\r\n            // only owner can update list\r\n            DisableBlackListForever( msg.sender, 0x80000000, 0 );\r\n            return;\r\n        }\r\n        \r\n        blackListEnabled = false;\r\n        \r\n        DisableBlackListForever( msg.sender, 0, 0 );        \r\n    }\r\n\r\n    event DisableWhiteListForever( address indexed sender, uint error, uint errorInfo );\r\n    function disableWhiteListForever() {\r\n        if( ! owners[ msg.sender ] ) {\r\n            // only owner can update list\r\n            DisableWhiteListForever( msg.sender, 0x80000000, 0 );\r\n            return;\r\n        }\r\n        \r\n        whiteListEnabled = false;\r\n        \r\n        DisableWhiteListForever( msg.sender, 0, 0 );            \r\n    }\r\n    \r\n    event VerifyExtraData( address indexed sender, uint error, uint errorInfo );    \r\n    function verifyExtraData( bytes32 extraData, bytes32 minerId, uint difficulty ) constant internal returns(bool) {\r\n        uint i;\r\n        // compare id\r\n        for( i = 0 ; i < 11 ; i++ ) {\r\n            if( extraData[10+i] != minerId[21+i] ) {\r\n                //ErrorLog( \"verifyExtraData: miner id not as expected\", 0 );\r\n                VerifyExtraData( msg.sender, 0x83000000, uint(minerId) );         \r\n                return false;            \r\n            }\r\n        }\r\n        \r\n        // compare difficulty\r\n        bytes32 encodedDiff = to62Encoding(difficulty,11);\r\n        for( i = 0 ; i < 11 ; i++ ) {\r\n            if(extraData[i+21] != encodedDiff[21+i]) {\r\n                //ErrorLog( \"verifyExtraData: difficulty is not as expected\", uint(encodedDiff) );\r\n                VerifyExtraData( msg.sender, 0x83000001, uint(encodedDiff) );\r\n                return false;            \r\n            }  \r\n        }\r\n                \r\n        return true;            \r\n    }    \r\n    \r\n    event VerifyClaim( address indexed sender, uint error, uint errorInfo );\r\n    \r\n        \r\n    function verifyClaim( bytes rlpHeader,\r\n                          uint  nonce,\r\n                          uint  submissionIndex,\r\n                          uint  shareIndex,\r\n                          uint[] dataSetLookup,\r\n                          uint[] witnessForLookup,\r\n                          uint[] augCountersBranch,\r\n                          uint[] augHashesBranch ) {\r\n\r\n        if( ! isRegistered(msg.sender) ) {\r\n            // miner is not registered\r\n            VerifyClaim( msg.sender, 0x8400000c, 0 );\r\n            return;         \r\n        }\r\n\r\n        SubmissionDataForClaimVerification memory submissionData = getClaimData( msg.sender,\r\n            submissionIndex, shareIndex, getClaimSeed( msg.sender ) ); \r\n                              \r\n        if( ! submissionData.readyForVerification ) {\r\n            //ErrorLog( \"there are no pending claims\", 0 );\r\n            VerifyClaim( msg.sender, 0x84000003, 0 );            \r\n            return;\r\n        }\r\n        \r\n        BlockHeader memory header = parseBlockHeader(rlpHeader);\r\n\r\n        // check extra data\r\n        if( ! verifyExtraData( header.extraData,\r\n                               minersData[ msg.sender ].minerId,\r\n                               submissionData.shareDifficulty ) ) {\r\n            //ErrorLog( \"extra data not as expected\", uint(header.extraData) );\r\n            VerifyClaim( msg.sender, 0x84000004, uint(header.extraData) );            \r\n            return;                               \r\n        }\r\n        \r\n        // check coinbase data\r\n        if( header.coinbase != uint(this) ) {\r\n            //ErrorLog( \"coinbase not as expected\", uint(header.coinbase) );\r\n            VerifyClaim( msg.sender, 0x84000005, uint(header.coinbase) );            \r\n            return;\r\n        }\r\n         \r\n        \r\n        // check counter\r\n        uint counter = header.timestamp * (2 ** 64) + nonce;\r\n        if( counter < submissionData.min ) {\r\n            //ErrorLog( \"counter is smaller than min\",counter);\r\n            VerifyClaim( msg.sender, 0x84000007, counter );            \r\n            return;                         \r\n        }\r\n        if( counter > submissionData.max ) {\r\n            //ErrorLog( \"counter is smaller than max\",counter);\r\n            VerifyClaim( msg.sender, 0x84000008, counter );            \r\n            return;                         \r\n        }\r\n        \r\n        // verify agt\r\n        uint leafHash = uint(sha3(rlpHeader));\r\n        VerifyAgtData memory agtData;\r\n        agtData.rootHash = submissionData.augMerkle;\r\n        agtData.rootMin = submissionData.min;\r\n        agtData.rootMax = submissionData.max;\r\n        agtData.leafHash = leafHash;\r\n        agtData.leafCounter = counter;\r\n                \r\n\r\n        if( ! verifyAgt( agtData,\r\n                         shareIndex,\r\n                         augCountersBranch,\r\n                         augHashesBranch ) ) {\r\n            //ErrorLog( \"verifyAgt failed\",0);\r\n            VerifyClaim( msg.sender, 0x84000009, 0 );            \r\n            return;\r\n        }\r\n                          \r\n        \r\n        /*\r\n        // check epoch data - done inside hashimoto\r\n        if( ! ethashContract.isEpochDataSet( header.blockNumber / 30000 ) ) {\r\n            //ErrorLog( \"epoch data was not set\",header.blockNumber / 30000);\r\n            VerifyClaim( msg.sender, 0x8400000a, header.blockNumber / 30000 );                        \r\n            return;        \r\n        }*/\r\n\r\n\r\n        // verify ethash\r\n        uint ethash = ethashContract.hashimoto( bytes32(leafHash),\r\n                                                bytes8(nonce),\r\n                                                dataSetLookup,\r\n                                                witnessForLookup,\r\n                                                header.blockNumber / 30000 );\r\n        if( ethash > ((2**256-1)/submissionData.shareDifficulty )) {\r\n            if( ethash == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE ) {\r\n                //ErrorLog( \"epoch data was not set\",header.blockNumber / 30000);\r\n                VerifyClaim( msg.sender, 0x8400000a, header.blockNumber / 30000 );                                        \r\n            }\r\n            else {\r\n                //ErrorLog( \"ethash difficulty too low\",ethash);\r\n                VerifyClaim( msg.sender, 0x8400000b, ethash );\r\n            }            \r\n            return;        \r\n        }\r\n        \r\n        if( getClaimSeed(msg.sender) == 0 ) {\r\n            //ErrorLog( \"claim seed is 0\", 0 );\r\n            VerifyClaim( msg.sender, 0x84000001, 0 );\r\n            return;        \r\n        }\r\n        \r\n        if( ! submissionData.indicesAreValid ) {\r\n            //ErrorLog( \"share index or submission are not as expected. should be:\", getShareIndex() );\r\n            VerifyClaim( msg.sender, 0x84000002, 0 );\r\n            return;                \r\n        } \r\n        \r\n        // recrusive attack is not possible as doPayment is using send and not call.\r\n        if( ! doPayment(submissionData.totalSubmissionValue,\r\n                        minersData[ msg.sender ].paymentAddress) ) {\r\n            // error msg is given in doPayment function\r\n            return;\r\n        }\r\n        \r\n        closeSubmission( msg.sender );\r\n        //minersData[ msg.sender ].pendingClaim = false;\r\n        \r\n        \r\n        VerifyClaim( msg.sender, 0, 0 );                        \r\n        \r\n        \r\n        return;\r\n    }    \r\n    \r\n\r\n    // 10000 = 100%\r\n    uint public uncleRate = 500; // 5%\r\n    // 10000 = 100%\r\n    uint public poolFees = 0;\r\n\r\n\r\n    event IncomingFunds( address sender, uint amountInWei );\r\n    function() payable {\r\n        IncomingFunds( msg.sender, msg.value );\r\n    }\r\n\r\n    event SetUnlceRateAndFees( address indexed sender, uint error, uint errorInfo );\r\n    function setUnlceRateAndFees( uint _uncleRate, uint _poolFees ) {\r\n        if( ! owners[msg.sender] ) {\r\n            // only owner should change rates\r\n            SetUnlceRateAndFees( msg.sender, 0x80000000, 0 );\r\n            return;\r\n        }\r\n        \r\n        uncleRate = _uncleRate;\r\n        poolFees = _poolFees;\r\n        \r\n        SetUnlceRateAndFees( msg.sender, 0, 0 );\r\n    }\r\n        \r\n    event DoPayment( address indexed sender, address paymentAddress, uint valueInWei );\r\n    function doPayment( uint submissionValue,\r\n                        address paymentAddress ) internal returns(bool) {\r\n\r\n        uint payment = submissionValue;\r\n        // take uncle rate into account\r\n        \r\n        // payment = payment * (1-0.25*uncleRate)\r\n        // uncleRate in [0,10000]\r\n        payment = (payment * (4*10000 - uncleRate)) / (4*10000);\r\n        \r\n        // fees\r\n        payment = (payment * (10000 - poolFees)) / 10000;\r\n\r\n        if( payment > this.balance ){\r\n            //ErrorLog( \"cannot afford to pay\", calcPayment( submissionData.numShares, submissionData.difficulty ) );\r\n            VerifyClaim( msg.sender, 0x84000000, payment );        \r\n            return false;\r\n        }\r\n                \r\n        if( ! paymentAddress.send( payment ) ) throw;\r\n        \r\n        DoPayment( msg.sender, paymentAddress, payment ); \r\n        \r\n        return true;\r\n    }\r\n    \r\n    function getPoolETHBalance( ) constant returns(uint) {\r\n        // debug function for testrpc\r\n        return this.balance;\r\n    }\r\n\r\n    event GetShareIndexDebugForTestRPCSubmissionIndex( uint index );    \r\n    event GetShareIndexDebugForTestRPCShareIndex( uint index );\r\n     \r\n    function getShareIndexDebugForTestRPC( address sender ) {\r\n        uint seed = getClaimSeed( sender );\r\n        uint[2] memory result = calculateSubmissionIndex( sender, seed );\r\n        \r\n        GetShareIndexDebugForTestRPCSubmissionIndex( result[0] );\r\n        GetShareIndexDebugForTestRPCShareIndex( result[1] );        \r\n            \r\n    }        \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newVersionReleased\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPoolETHBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uncleRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"debugGetNumPendingSubmissions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"canRegister\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"paymentAddress\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_uncleRate\",\"type\":\"uint256\"},{\"name\":\"_poolFees\",\"type\":\"uint256\"}],\"name\":\"setUnlceRateAndFees\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"debugResetSubmissions\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"seed\",\"type\":\"uint256\"}],\"name\":\"calculateSubmissionIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getClaimSeed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rootHash\",\"type\":\"uint256\"},{\"name\":\"rootMin\",\"type\":\"uint256\"},{\"name\":\"rootMax\",\"type\":\"uint256\"},{\"name\":\"leafHash\",\"type\":\"uint256\"},{\"name\":\"leafCounter\",\"type\":\"uint256\"},{\"name\":\"branchIndex\",\"type\":\"uint256\"},{\"name\":\"countersBranch\",\"type\":\"uint256[]\"},{\"name\":\"hashesBranch\",\"type\":\"uint256[]\"}],\"name\":\"verifyAgtDebugForTesting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethashContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableBlackListForever\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getShareIndexDebugForTestRPC\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"seed\",\"type\":\"uint256\"},{\"name\":\"submissionNumber\",\"type\":\"uint256\"},{\"name\":\"shareIndex\",\"type\":\"uint256\"}],\"name\":\"verifySubmissionIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"miner\",\"type\":\"address\"},{\"name\":\"add\",\"type\":\"bool\"}],\"name\":\"updateWhiteList\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blackListEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rlpHeader\",\"type\":\"bytes\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"submissionIndex\",\"type\":\"uint256\"},{\"name\":\"shareIndex\",\"type\":\"uint256\"},{\"name\":\"dataSetLookup\",\"type\":\"uint256[]\"},{\"name\":\"witnessForLookup\",\"type\":\"uint256[]\"},{\"name\":\"augCountersBranch\",\"type\":\"uint256[]\"},{\"name\":\"augHashesBranch\",\"type\":\"uint256[]\"}],\"name\":\"verifyClaim\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"isRegistered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"miner\",\"type\":\"address\"}],\"name\":\"storeClaimSeed\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"numShares\",\"type\":\"uint256\"},{\"name\":\"difficulty\",\"type\":\"uint256\"},{\"name\":\"min\",\"type\":\"uint256\"},{\"name\":\"max\",\"type\":\"uint256\"},{\"name\":\"augRoot\",\"type\":\"uint256\"},{\"name\":\"lastClaimBeforeVerification\",\"type\":\"bool\"}],\"name\":\"submitClaim\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getMinerId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whiteListEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableWhiteListForever\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"declareNewerVersion\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"existingIds\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawalAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"miner\",\"type\":\"address\"},{\"name\":\"add\",\"type\":\"bool\"}],\"name\":\"updateBlackList\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"numChars\",\"type\":\"uint256\"}],\"name\":\"to62Encoding\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_ethashContract\",\"type\":\"address\"},{\"name\":\"_withdrawalAddress\",\"type\":\"address\"},{\"name\":\"_whiteListEnabeled\",\"type\":\"bool\"},{\"name\":\"_blackListEnabled\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"errorInfo\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"errorInfo\",\"type\":\"uint256\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"miner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"errorInfo\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"add\",\"type\":\"bool\"}],\"name\":\"UpdateWhiteList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"miner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"errorInfo\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"add\",\"type\":\"bool\"}],\"name\":\"UpdateBlackList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"errorInfo\",\"type\":\"uint256\"}],\"name\":\"DisableBlackListForever\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"errorInfo\",\"type\":\"uint256\"}],\"name\":\"DisableWhiteListForever\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"errorInfo\",\"type\":\"uint256\"}],\"name\":\"VerifyExtraData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"errorInfo\",\"type\":\"uint256\"}],\"name\":\"VerifyClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"name\":\"IncomingFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"errorInfo\",\"type\":\"uint256\"}],\"name\":\"SetUnlceRateAndFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"paymentAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"valueInWei\",\"type\":\"uint256\"}],\"name\":\"DoPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"GetShareIndexDebugForTestRPCSubmissionIndex\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"GetShareIndexDebugForTestRPCShareIndex\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"errorInfo\",\"type\":\"uint256\"}],\"name\":\"SubmitClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"errorInfo\",\"type\":\"uint256\"}],\"name\":\"StoreClaimSeed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"errorInfo\",\"type\":\"uint256\"}],\"name\":\"DebugResetSubmissions\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"VerifyAgt\",\"type\":\"event\"}]","ContractName":"SmartPool","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000fbb8b91ffe0ee6b8f626f03e1378f5569432d406000000000000000000000000062d1816ea36366a714c34b9b283f4d377dc0191000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000003000000000000000000000000c8a1dab586dee8a30cb88c87b8a3614e0a391fc50000000000000000000000002be2f917397bacfb3c939f6db3bee80aa606ae31000000000000000000000000f214dde57f32f3f34492ba3148641693058d4a9e","Library":"","SwarmSource":"bzzr://7838aa74ec18e24ec9f066d5bab4042b322a456dc786b99c961d5576ddc4c4a7"}]}