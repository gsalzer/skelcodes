{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant returns (uint256);\r\n  function transfer(address to, uint256 value);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value);\r\n  function approve(address spender, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances. \r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n   * @dev Fix for the ERC20 short address attack.\r\n   */\r\n  modifier onlyPayloadSize(uint256 size) {\r\n     if(msg.data.length < size + 4) {\r\n       throw;\r\n     }\r\n     _;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of. \r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implemantation of the basic standart token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is BasicToken, ERC20 {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amout of tokens to be transfered\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // if (_value > _allowance) throw;\r\n\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n  }\r\n\r\n  /**\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifing the amount of tokens still avaible for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control \r\n * functions, this simplifies the implementation of \"user permissions\". \r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /** \r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner. \r\n   */\r\n  modifier onlyOwner() {\r\n    if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to. \r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n/** \r\n * @title Contracts that should not own Tokens\r\n * @author Remco Bloemen <remco@2π.com>\r\n * @dev This blocks incoming ERC23 tokens to prevent accidental loss of tokens.\r\n * Should tokens (any ERC20Basic compatible) end up in the contract, it allows the\r\n * owner to reclaim the tokens.\r\n */\r\ncontract HasNoTokens is Ownable {\r\n\r\n /** \r\n  * @dev Reject all ERC23 compatible tokens\r\n  * @param from_ address The address that is transferring the tokens\r\n  * @param value_ uint256 the amount of the specified token\r\n  * @param data_ Bytes The data passed from the caller.\r\n  */\r\n  function tokenFallback(address from_, uint256 value_, bytes data_) external {\r\n    throw;\r\n  }\r\n\r\n  /**\r\n   * @dev Reclaim all ERC20Basic compatible tokens\r\n   * @param tokenAddr address The address of the token contract\r\n   */\r\n  function reclaimToken(address tokenAddr) external onlyOwner {\r\n    ERC20Basic tokenInst = ERC20Basic(tokenAddr);\r\n    uint256 balance = tokenInst.balanceOf(this);\r\n    tokenInst.transfer(owner, balance);\r\n  }\r\n}\r\n\r\n/** \r\n * @title Contracts that should not own Contracts\r\n * @author Remco Bloemen <remco@2π.com>\r\n * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner\r\n * of this contract to reclaim ownership of the contracts.\r\n */\r\ncontract HasNoContracts is Ownable {\r\n\r\n  /**\r\n   * @dev Reclaim ownership of Ownable contracts\r\n   * @param contractAddr The address of the Ownable to be reclaimed.\r\n   */\r\n  function reclaimContract(address contractAddr) external onlyOwner {\r\n    Ownable contractInst = Ownable(contractAddr);\r\n    contractInst.transferOwnership(owner);\r\n  }\r\n}\r\n\r\n/**\r\n * MRV token, distributed by crowdsale. Token and crowdsale functionality are unified in a single\r\n * contract, to make clear and restrict the conditions under which tokens can be created or destroyed.\r\n * Derived from OpenZeppelin CrowdsaleToken template.\r\n *\r\n * Key Crowdsale Facts:\r\n * \r\n * * MRV tokens will be sold at a rate of 5,000 per ETH.\r\n *\r\n * * All MRV token sales are final. No refunds can be issued by the contract.\r\n *\r\n * * Unless adjusted later by the crowdsale operator, up to 100 million tokens will be available.\r\n *\r\n * * An additional 5,000 tokens are reserved. \r\n *\r\n * * Participate in the crowdsale by sending ETH to this contract, when the crowdsale is open.\r\n *\r\n * * Sending more ETH than required to purchase all the remaining tokens will fail.\r\n *\r\n * * Timers can be set to allow anyone to open/close the crowdsale at the proper time. The crowdsale\r\n *   operator reserves the right to set, unset, and reset these timers at any time, for any reason,\r\n *   and without notice.\r\n *\r\n * * The operator of the crowdsale has the ability to manually open it and close it, and reserves\r\n *   the right to do so at any time, for any reason, and without notice.\r\n *\r\n * * The crowdsale cannot be reopened, and no tokens can be created, after the crowdsale closes.\r\n *\r\n * * The crowdsale operator reserves the right to adjust the decimal places of the MRV token at\r\n *   any time after the crowdsale closes, for any reason, and without notice. MRV tokens are\r\n *   initially divisible to 18 decimal places.\r\n *\r\n * * The crowdsale operator reserves the right to not open or close the crowdsale, not set the\r\n *   open or close timer, and generally refrain from doing things that the contract would otherwise\r\n *   authorize them to do.\r\n *\r\n * * The crowdsale operator reserves the right to claim and keep any ETH or tokens that end up in\r\n *   the contract's account. During normal crowdsale operation, ETH is not stored in the contract's\r\n *   account, and is instead sent directly to the beneficiary.\r\n */\r\ncontract MRVToken is StandardToken, Ownable, HasNoTokens, HasNoContracts {\r\n\r\n    // Token Parameters\r\n\r\n    // From StandardToken we inherit balances and totalSupply.\r\n    \r\n    // What is the full name of the token?\r\n    string public constant name = \"Macroverse Token\";\r\n    // What is its suggested symbol?\r\n    string public constant symbol = \"MRV\";\r\n    // How many of the low base-10 digits are to the right of the decimal point?\r\n    // Note that this is not constant! After the crowdsale, the contract owner can\r\n    // adjust the decimal places, allowing for 10-to-1 splits and merges.\r\n    uint8 public decimals;\r\n    \r\n    // Crowdsale Parameters\r\n    \r\n    // Where will funds collected during the crowdsale be sent?\r\n    address beneficiary;\r\n    // How many MRV can be sold in the crowdsale?\r\n    uint public maxCrowdsaleSupplyInWholeTokens;\r\n    // How many whole tokens are reserved for the beneficiary?\r\n    uint public constant wholeTokensReserved = 5000;\r\n    // How many tokens per ETH during the crowdsale?\r\n    uint public constant wholeTokensPerEth = 5000;\r\n    \r\n    // Set to true when the crowdsale starts\r\n    // Internal flag. Use isCrowdsaleActive instead().\r\n    bool crowdsaleStarted;\r\n    // Set to true when the crowdsale ends\r\n    // Internal flag. Use isCrowdsaleActive instead().\r\n    bool crowdsaleEnded;\r\n    // We can also set some timers to open and close the crowdsale. 0 = timer is not set.\r\n    // After this time, the crowdsale will open with a call to checkOpenTimer().\r\n    uint public openTimer = 0;\r\n    // After this time, no contributions will be accepted, and the crowdsale will close with a call to checkCloseTimer().\r\n    uint public closeTimer = 0;\r\n    \r\n    ////////////\r\n    // Constructor\r\n    ////////////\r\n    \r\n    /**\r\n    * Deploy a new MRVToken contract, paying crowdsale proceeds to the given address,\r\n    * and awarding reserved tokens to the other given address.\r\n    */\r\n    function MRVToken(address sendProceedsTo, address sendTokensTo) {\r\n        // Proceeds of the crowdsale go here.\r\n        beneficiary = sendProceedsTo;\r\n        \r\n        // Start with 18 decimals, same as ETH\r\n        decimals = 18;\r\n        \r\n        // Initially, the reserved tokens belong to the given address.\r\n        totalSupply = wholeTokensReserved * 10 ** 18;\r\n        balances[sendTokensTo] = totalSupply;\r\n        \r\n        // Initially the crowdsale has not yet started or ended.\r\n        crowdsaleStarted = false;\r\n        crowdsaleEnded = false;\r\n        // Default to a max supply of 100 million tokens available.\r\n        maxCrowdsaleSupplyInWholeTokens = 100000000;\r\n    }\r\n    \r\n    ////////////\r\n    // Fallback function\r\n    ////////////\r\n    \r\n    /**\r\n    * This is the MAIN CROWDSALE ENTRY POINT. You participate in the crowdsale by \r\n    * sending ETH to this contract. That calls this function, which credits tokens\r\n    * to the address or contract that sent the ETH.\r\n    *\r\n    * Since MRV tokens are sold at a rate of more than one per ether, and since\r\n    * they, like ETH, have 18 decimal places (at the time of sale), any fractional\r\n    * amount of ETH should be handled safely.\r\n    *\r\n    * Note that all orders are fill-or-kill. If you send in more ether than there are\r\n    * tokens remaining to be bought, your transaction will be rolled back and you will\r\n    * get no tokens and waste your gas.\r\n    */\r\n    function() payable onlyDuringCrowdsale {\r\n        createTokens(msg.sender);\r\n    }\r\n    \r\n    ////////////\r\n    // Events\r\n    ////////////\r\n    \r\n    // Fired when the crowdsale is recorded as started.\r\n    event CrowdsaleOpen(uint time);\r\n    // Fired when someone contributes to the crowdsale and buys MRV\r\n    event TokenPurchase(uint time, uint etherAmount, address from);\r\n    // Fired when the crowdsale is recorded as ended.\r\n    event CrowdsaleClose(uint time);\r\n    // Fired when the decimal point moves\r\n    event DecimalChange(uint8 newDecimals);\r\n    \r\n    ////////////\r\n    // Modifiers (encoding important crowdsale logic)\r\n    ////////////\r\n    \r\n    /**\r\n     * Only allow some actions before the crowdsale closes, whether it's open or not.\r\n     */\r\n    modifier onlyBeforeClosed {\r\n        checkCloseTimer();\r\n        if (crowdsaleEnded) throw;\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * Only allow some actions after the crowdsale is over.\r\n     * Will set the crowdsale closed if it should be.\r\n     */\r\n    modifier onlyAfterClosed {\r\n        checkCloseTimer();\r\n        if (!crowdsaleEnded) throw;\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * Only allow some actions before the crowdsale starts.\r\n     */\r\n    modifier onlyBeforeOpened {\r\n        checkOpenTimer();\r\n        if (crowdsaleStarted) throw;\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * Only allow some actions while the crowdsale is active.\r\n     * Will set the crowdsale open if it should be.\r\n     */\r\n    modifier onlyDuringCrowdsale {\r\n        checkOpenTimer();\r\n        checkCloseTimer();\r\n        if (crowdsaleEnded) throw;\r\n        if (!crowdsaleStarted) throw;\r\n        _;\r\n    }\r\n\r\n    ////////////\r\n    // Status and utility functions\r\n    ////////////\r\n    \r\n    /**\r\n     * Determine if the crowdsale should open by timer.\r\n     */\r\n    function openTimerElapsed() constant returns (bool) {\r\n        return (openTimer != 0 && now > openTimer);\r\n    }\r\n    \r\n    /**\r\n     * Determine if the crowdsale should close by timer.\r\n     */\r\n    function closeTimerElapsed() constant returns (bool) {\r\n        return (closeTimer != 0 && now > closeTimer);\r\n    }\r\n    \r\n    /**\r\n     * If the open timer has elapsed, start the crowdsale.\r\n     * Can be called by people, but also gets called when people try to contribute.\r\n     */\r\n    function checkOpenTimer() {\r\n        if (openTimerElapsed()) {\r\n            crowdsaleStarted = true;\r\n            openTimer = 0;\r\n            CrowdsaleOpen(now);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * If the close timer has elapsed, stop the crowdsale.\r\n     */\r\n    function checkCloseTimer() {\r\n        if (closeTimerElapsed()) {\r\n            crowdsaleEnded = true;\r\n            closeTimer = 0;\r\n            CrowdsaleClose(now);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Determine if the crowdsale is currently happening.\r\n     */\r\n    function isCrowdsaleActive() constant returns (bool) {\r\n        // The crowdsale is happening if it is open or due to open, and it isn't closed or due to close.\r\n        return ((crowdsaleStarted || openTimerElapsed()) && !(crowdsaleEnded || closeTimerElapsed()));\r\n    }\r\n    \r\n    ////////////\r\n    // Before the crowdsale: configuration\r\n    ////////////\r\n    \r\n    /**\r\n     * Before the crowdsale opens, the max token count can be configured.\r\n     */\r\n    function setMaxSupply(uint newMaxInWholeTokens) onlyOwner onlyBeforeOpened {\r\n        maxCrowdsaleSupplyInWholeTokens = newMaxInWholeTokens;\r\n    }\r\n    \r\n    /**\r\n     * Allow the owner to start the crowdsale manually.\r\n     */\r\n    function openCrowdsale() onlyOwner onlyBeforeOpened {\r\n        crowdsaleStarted = true;\r\n        openTimer = 0;\r\n        CrowdsaleOpen(now);\r\n    }\r\n    \r\n    /**\r\n     * Let the owner start the timer for the crowdsale start. Without further owner intervention,\r\n     * anyone will be able to open the crowdsale when the timer expires.\r\n     * Further calls will re-set the timer to count from the time the transaction is processed.\r\n     * The timer can be re-set after it has tripped, unless someone has already opened the crowdsale.\r\n     */\r\n    function setCrowdsaleOpenTimerFor(uint minutesFromNow) onlyOwner onlyBeforeOpened {\r\n        openTimer = now + minutesFromNow * 1 minutes;\r\n    }\r\n    \r\n    /**\r\n     * Let the owner stop the crowdsale open timer, as long as the crowdsale has not yet opened.\r\n     */\r\n    function clearCrowdsaleOpenTimer() onlyOwner onlyBeforeOpened {\r\n        openTimer = 0;\r\n    }\r\n    \r\n    /**\r\n     * Let the owner start the timer for the crowdsale end. Counts from when the function is called,\r\n     * *not* from the start of the crowdsale.\r\n     * It is possible, but a bad idea, to set this before the open timer.\r\n     */\r\n    function setCrowdsaleCloseTimerFor(uint minutesFromNow) onlyOwner onlyBeforeClosed {\r\n        closeTimer = now + minutesFromNow * 1 minutes;\r\n    }\r\n    \r\n    /**\r\n     * Let the owner stop the crowdsale close timer, as long as it has not yet expired.\r\n     */\r\n    function clearCrowdsaleCloseTimer() onlyOwner onlyBeforeClosed {\r\n        closeTimer = 0;\r\n    }\r\n    \r\n    \r\n    ////////////\r\n    // During the crowdsale\r\n    ////////////\r\n    \r\n    /**\r\n     * Create tokens for the given address, in response to a payment.\r\n     * Cannot be called by outside callers; use the fallback function, which will create tokens for whoever pays it.\r\n     */\r\n    function createTokens(address recipient) internal onlyDuringCrowdsale {\r\n        if (msg.value == 0) {\r\n            throw;\r\n        }\r\n\r\n        uint tokens = msg.value.mul(wholeTokensPerEth); // Exploits the fact that we have 18 decimals, like ETH.\r\n        \r\n        var newTotalSupply = totalSupply.add(tokens);\r\n        \r\n        if (newTotalSupply > (wholeTokensReserved + maxCrowdsaleSupplyInWholeTokens) * 10 ** 18) {\r\n            // This would be too many tokens issued.\r\n            // Don't mess around with partial order fills.\r\n            throw;\r\n        }\r\n        \r\n        // Otherwise, we can fill the order entirely, so make the tokens and put them in the specified account.\r\n        totalSupply = newTotalSupply;\r\n        balances[recipient] = balances[recipient].add(tokens);\r\n        \r\n        // Announce the purchase\r\n        TokenPurchase(now, msg.value, recipient);\r\n\r\n        // Lastly (after all state changes), send the money to the crowdsale beneficiary.\r\n        // This allows the crowdsale contract itself not to hold any ETH.\r\n        // It also means that ALL SALES ARE FINAL!\r\n        if (!beneficiary.send(msg.value)) {\r\n            throw;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Allow the owner to end the crowdsale manually.\r\n     */\r\n    function closeCrowdsale() onlyOwner onlyDuringCrowdsale {\r\n        crowdsaleEnded = true;\r\n        closeTimer = 0;\r\n        CrowdsaleClose(now);\r\n    }  \r\n    \r\n    ////////////\r\n    // After the crowdsale: token maintainance\r\n    ////////////\r\n    \r\n    /**\r\n     * When the crowdsale is finished, the contract owner may adjust the decimal places for display purposes.\r\n     * This should work like a 10-to-1 split or reverse-split.\r\n     * The point of this mechanism is to keep the individual MRV tokens from getting inconveniently valuable or cheap.\r\n     * However, it relies on the contract owner taking the time to update the decimal place value.\r\n     * Note that this changes the decimals IMMEDIATELY with NO NOTICE to users.\r\n     */\r\n    function setDecimals(uint8 newDecimals) onlyOwner onlyAfterClosed {\r\n        decimals = newDecimals;\r\n        // Announce the change\r\n        DecimalChange(decimals);\r\n    }\r\n    \r\n    /**\r\n     * If Ether somehow manages to get into this contract, provide a way to get it out again.\r\n     * During normal crowdsale operation, ETH is immediately forwarded to the beneficiary.\r\n     */\r\n    function reclaimEther() external onlyOwner {\r\n        // Send the ETH. Make sure it worked.\r\n        assert(owner.send(this.balance));\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"isCrowdsaleActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"clearCrowdsaleCloseTimer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddr\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkCloseTimer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"openCrowdsale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractAddr\",\"type\":\"address\"}],\"name\":\"reclaimContract\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCrowdsaleSupplyInWholeTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wholeTokensPerEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closeTimer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"clearCrowdsaleOpenTimer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMaxInWholeTokens\",\"type\":\"uint256\"}],\"name\":\"setMaxSupply\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minutesFromNow\",\"type\":\"uint256\"}],\"name\":\"setCrowdsaleOpenTimerFor\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDecimals\",\"type\":\"uint8\"}],\"name\":\"setDecimals\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closeTimerElapsed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wholeTokensReserved\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openTimer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeCrowdsale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimEther\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from_\",\"type\":\"address\"},{\"name\":\"value_\",\"type\":\"uint256\"},{\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkOpenTimer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minutesFromNow\",\"type\":\"uint256\"}],\"name\":\"setCrowdsaleCloseTimerFor\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openTimerElapsed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"sendProceedsTo\",\"type\":\"address\"},{\"name\":\"sendTokensTo\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleClose\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newDecimals\",\"type\":\"uint8\"}],\"name\":\"DecimalChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"MRVToken","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"0000000000000000000000002fe5bdc68d73b1f570b97422021a0c9cdccae79f000000000000000000000000368651f6c2b3a7174ac30a5a062b65f2342fb6f1","Library":"","SwarmSource":"bzzr://a1d08cff3a53f7480b65b490dddab528eb3bafbfea76c8a1e26aa85bd6b36551"}]}