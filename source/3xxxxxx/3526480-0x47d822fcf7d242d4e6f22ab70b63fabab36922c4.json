{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\n\r\n//\r\n// FOR REFERENCE - INCLUDE  iE4RowEscrow  (interface) CONTRACT at the top .....\r\n//\r\n\r\ncontract iE4RowEscrow {\r\n        function getNumGamesStarted() constant returns (int ngames);\r\n}\r\n\r\n// Abstract contract for the full ERC 20 Token standard\r\n// https://github.com/ethereum/EIPs/issues/20\r\n\r\n// ---------------------------------\r\n// ABSTRACT standard token class\r\n// ---------------------------------\r\ncontract Token { \r\n    function totalSupply() constant returns (uint256 supply);\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n// --------------------------\r\n//  E4RowRewards - abstract e4 dividend contract\r\n// --------------------------\r\ncontract E4RowRewards\r\n{\r\n        function checkDividends(address _addr) constant returns(uint _amount);\r\n        function withdrawDividends() public returns (uint namount);\r\n}\r\n\r\n// --------------------------\r\n//  Finney Chip - token contract\r\n// --------------------------\r\ncontract E4Token is Token, E4RowRewards {\r\n        event StatEvent(string msg);\r\n        event StatEventI(string msg, uint val);\r\n\r\n        enum SettingStateValue  {debug, release, lockedRelease}\r\n        enum IcoStatusValue {anouncement, saleOpen, saleClosed, failed, succeeded}\r\n\r\n\r\n\r\n\r\n        struct tokenAccount {\r\n                bool alloced; // flag to ascert prior allocation\r\n                uint tokens; // num tokens\r\n                uint balance; // rewards balance\r\n        }\r\n// -----------------------------\r\n//  data storage\r\n// ----------------------------------------\r\n        address developers; // developers token holding address\r\n        address public owner; // deployer executor\r\n        address founderOrg; // founder orginaization contract\r\n        address auxPartner; // aux partner (pr/auditing) - 1 percent upon close\r\n        address e4_partner; // e4row  contract addresses\r\n\r\n\r\n        mapping (address => tokenAccount) holderAccounts ; // who holds how many tokens (high two bytes contain curPayId)\r\n        mapping (uint => address) holderIndexes ; // for iteration thru holder\r\n        uint numAccounts;\r\n\r\n        uint partnerCredits; // amount partner (e4row)  has paid\r\n        mapping (address => mapping (address => uint256)) allowed; // approvals\r\n\r\n\r\n        uint maxMintableTokens; // ...\r\n        uint minIcoTokenGoal;// token goal by sale end\r\n        uint minUsageGoal; //  num games goal by usage deadline\r\n        uint public  tokenPrice; // price per token\r\n        uint public payoutThreshold; // threshold till payout\r\n\r\n        uint totalTokenFundsReceived;   // running total of token funds received\r\n        uint public totalTokensMinted;  // total number of tokens minted\r\n        uint public holdoverBalance;            // hold this amount until threshhold before reward payout\r\n        int public payoutBalance;               // hold this amount until threshhold before reward payout\r\n        int prOrigPayoutBal;                    // original payout balance before run\r\n        uint prOrigTokensMint;                  // tokens minted at start of pay run\r\n        uint public curPayoutId;                // current payout id\r\n        uint public lastPayoutIndex;            // payout idx between run segments\r\n        uint public maxPaysPer;                 // num pays per segment\r\n        uint public minPayInterval;             // min interval between start pay run\r\n\r\n\r\n        uint fundingStart;              // funding start time immediately after anouncement\r\n        uint fundingDeadline;           // funding end time\r\n        uint usageDeadline;             // deadline where minimum usage needs to be met before considered success\r\n        uint public lastPayoutTime;     // timestamp of last payout time\r\n        uint vestTime;          // 1 year past sale vest developer tokens\r\n        uint numDevTokens;      // 10 per cent of tokens after close to developers\r\n        bool developersGranted;                 // flag\r\n        uint remunerationStage;         // 0 for not yet, 1 for 10 percent, 2 for remaining  upon succeeded.\r\n        uint public remunerationBalance;        // remuneration balance to release token funds\r\n        uint auxPartnerBalance;         // aux partner balance - 1 percent\r\n        uint rmGas; // remuneration gas\r\n        uint rwGas; // reward gas\r\n        uint rfGas; // refund gas\r\n\r\n        IcoStatusValue icoStatus;  // current status of ico\r\n        SettingStateValue public settingsState;\r\n\r\n\r\n        // --------------------\r\n        // contract constructor\r\n        // --------------------\r\n        function E4Token() \r\n        {\r\n                owner = msg.sender;\r\n                developers = msg.sender;\r\n        }\r\n\r\n        // -----------------------------------\r\n        // use this to reset everything, will never be called after lockRelease\r\n        // -----------------------------------\r\n        function applySettings(SettingStateValue qState, uint _saleStart, uint _saleEnd, uint _usageEnd, uint _minUsage, uint _tokGoal, uint  _maxMintable, uint _threshold, uint _price, uint _mpp, uint _mpi )\r\n        {\r\n                if (msg.sender != owner) \r\n                        return;\r\n\r\n                // these settings are permanently tweakable for performance adjustments\r\n                payoutThreshold = _threshold;\r\n                maxPaysPer = _mpp;\r\n                minPayInterval = _mpi;\r\n\r\n                if (settingsState == SettingStateValue.lockedRelease)\r\n                        return;\r\n\r\n                settingsState = qState;\r\n                icoStatus = IcoStatusValue.anouncement;\r\n\r\n                rmGas = 100000; // remuneration gas\r\n                rwGas = 10000; // reward gas\r\n                rfGas = 10000; // refund gas\r\n\r\n\r\n                // zero out all token holders.  \r\n                // leave alloced on, leave num accounts\r\n                // cant delete them anyways\r\n\r\n                if (totalTokensMinted > 0) {\r\n                        for (uint i = 0; i < numAccounts; i++ ) {\r\n                                address a = holderIndexes[i];\r\n                                if (a != address(0)) {\r\n                                        holderAccounts[a].tokens = 0;\r\n                                        holderAccounts[a].balance = 0;\r\n                                }\r\n                        }\r\n                }\r\n                // do not reset numAccounts!\r\n\r\n                totalTokensMinted = 0; // this will erase\r\n                totalTokenFundsReceived = 0; // this will erase.\r\n                e4_partner = address(0); // must be reset again\r\n\r\n                fundingStart =  _saleStart;\r\n                fundingDeadline = _saleEnd;\r\n                usageDeadline = _usageEnd;\r\n                minUsageGoal = _minUsage;\r\n                minIcoTokenGoal = _tokGoal;\r\n                maxMintableTokens = _maxMintable;\r\n                tokenPrice = _price;\r\n\r\n                vestTime = fundingStart + (365 days);\r\n                numDevTokens = 0;\r\n\r\n                holdoverBalance = 0;\r\n                payoutBalance = 0;\r\n                curPayoutId = 1;\r\n                lastPayoutIndex = 0;\r\n                remunerationStage = 0;\r\n                remunerationBalance = 0;\r\n                auxPartnerBalance = 0;\r\n                developersGranted = false;\r\n                lastPayoutTime = 0;\r\n\r\n                if (this.balance > 0) {\r\n                        if (!owner.call.gas(rfGas).value(this.balance)())\r\n                                StatEvent(\"ERROR!\");\r\n                }\r\n                StatEvent(\"ok\");\r\n\r\n        }\r\n\r\n\r\n        // ---------------------------------------------------\r\n        // tokens held reserve the top two bytes for the payid last paid.\r\n        // this is so holders at the top of the list dont transfer tokens \r\n        // to themselves on the bottom of the list thus scamming the \r\n        // system. this function deconstructs the tokenheld value.\r\n        // ---------------------------------------------------\r\n        function getPayIdAndHeld(uint _tokHeld) internal returns (uint _payId, uint _held)\r\n        {\r\n                _payId = (_tokHeld / (2 ** 48)) & 0xffff;\r\n                _held = _tokHeld & 0xffffffffffff;\r\n        }\r\n        function getHeld(uint _tokHeld) internal  returns (uint _held)\r\n        {\r\n                _held = _tokHeld & 0xffffffffffff;\r\n        }\r\n        // ---------------------------------------------------\r\n        // allocate a new account by setting alloc to true\r\n        // set the top to bytes of tokens to cur pay id to leave out of current round\r\n        // add holder index, bump the num accounts\r\n        // ---------------------------------------------------\r\n        function addAccount(address _addr) internal  {\r\n                holderAccounts[_addr].alloced = true;\r\n                holderAccounts[_addr].tokens = (curPayoutId * (2 ** 48));\r\n                holderIndexes[numAccounts++] = _addr;\r\n        }\r\n\r\n\r\n// --------------------------------------\r\n// BEGIN ERC-20 from StandardToken\r\n// --------------------------------------\r\n        function totalSupply() constant returns (uint256 supply)\r\n        {\r\n                if (icoStatus == IcoStatusValue.saleOpen\r\n                        || icoStatus == IcoStatusValue.anouncement)\r\n                        supply = maxMintableTokens;\r\n                else\r\n                        supply = totalTokensMinted;\r\n        }\r\n\r\n        function transfer(address _to, uint256 _value) returns (bool success) {\r\n\r\n                if ((msg.sender == developers) \r\n                        &&  (now < vestTime)) {\r\n                        //statEvent(\"Tokens not yet vested.\");\r\n                        return false;\r\n                }\r\n\r\n\r\n                //Default assumes totalSupply can't be over max (2^256 - 1).\r\n                //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n                //Replace the if with this one instead.\r\n                //if (holderAccounts[msg.sender] >= _value && balances[_to] + _value > holderAccounts[_to]) {\r\n\r\n                var (pidFrom, heldFrom) = getPayIdAndHeld(holderAccounts[msg.sender].tokens);\r\n                if (heldFrom >= _value && _value > 0) {\r\n\r\n                    holderAccounts[msg.sender].tokens -= _value;\r\n\r\n                    if (!holderAccounts[_to].alloced) {\r\n                        addAccount(_to);\r\n                    }\r\n\r\n                    uint newHeld = _value + getHeld(holderAccounts[_to].tokens);\r\n                    holderAccounts[_to].tokens = newHeld | (pidFrom * (2 ** 48));\r\n                    Transfer(msg.sender, _to, _value);\r\n                    return true;\r\n                } else { \r\n                        return false; \r\n                }\r\n        }\r\n\r\n        function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n\r\n                if ((_from == developers) \r\n                        &&  (now < vestTime)) {\r\n                        //statEvent(\"Tokens not yet vested.\");\r\n                        return false;\r\n                }\r\n\r\n\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n\r\n                var (pidFrom, heldFrom) = getPayIdAndHeld(holderAccounts[_from].tokens);\r\n                if (heldFrom >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n                    holderAccounts[_from].tokens -= _value;\r\n\r\n                    if (!holderAccounts[_to].alloced)\r\n                        addAccount(_to);\r\n\r\n                    uint newHeld = _value + getHeld(holderAccounts[_to].tokens);\r\n\r\n                    holderAccounts[_to].tokens = newHeld | (pidFrom * (2 ** 48));\r\n                    allowed[_from][msg.sender] -= _value;\r\n                    Transfer(_from, _to, _value);\r\n                    return true;\r\n                } else { \r\n                    return false; \r\n                }\r\n        }\r\n\r\n\r\n        function balanceOf(address _owner) constant returns (uint256 balance) {\r\n                // vars default to 0\r\n                if (holderAccounts[_owner].alloced) {\r\n                        balance = getHeld(holderAccounts[_owner].tokens);\r\n                } \r\n        }\r\n\r\n        function approve(address _spender, uint256 _value) returns (bool success) {\r\n                allowed[msg.sender][_spender] = _value;\r\n                Approval(msg.sender, _spender, _value);\r\n                return true;\r\n        }\r\n\r\n        function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n                return allowed[_owner][_spender];\r\n        }\r\n// ----------------------------------\r\n// END ERC20\r\n// ----------------------------------\r\n\r\n  \r\n        // -------------------------------------------\r\n        // check the alloced\r\n        // -------------------------------------------\r\n        function holderExists(address _addr) returns(bool _exist)\r\n        {\r\n                _exist = holderAccounts[_addr].alloced;\r\n        }\r\n\r\n\r\n\r\n        // -------------------------------------------\r\n        // default payable function.\r\n        // if sender is e4row  partner, this is a rake fee payment\r\n        // otherwise this is a token purchase.\r\n        // tokens only purchaseable between tokenfundingstart and end\r\n        // -------------------------------------------\r\n        function () payable {\r\n                if (msg.sender == e4_partner) {\r\n                     feePayment(); // from e4row game escrow contract\r\n                } else {\r\n                     purchaseToken();\r\n                }\r\n        }\r\n\r\n        // -----------------------------\r\n        // purchase token function - tokens only sold during sale period up until the max tokens\r\n        // purchase price is tokenPrice.  all units in wei.\r\n        // purchaser will not be included in current pay run\r\n        // -----------------------------\r\n        function purchaseToken() payable {\r\n\r\n                uint nvalue = msg.value; // being careful to preserve msg.value\r\n                address npurchaser = msg.sender;\r\n                if (nvalue < tokenPrice) \r\n                        throw;\r\n\r\n                uint qty = nvalue/tokenPrice;\r\n                updateIcoStatus();\r\n                if (icoStatus != IcoStatusValue.saleOpen) // purchase is closed\r\n                        throw;\r\n                if (totalTokensMinted + qty > maxMintableTokens)\r\n                        throw;\r\n                if (!holderAccounts[npurchaser].alloced)\r\n                        addAccount(npurchaser);\r\n\r\n                // purchaser waits for next payrun. otherwise can disrupt cur pay run\r\n                uint newHeld = qty + getHeld(holderAccounts[npurchaser].tokens);\r\n                holderAccounts[npurchaser].tokens = newHeld | (curPayoutId * (2 ** 48));\r\n\r\n                totalTokensMinted += qty;\r\n                totalTokenFundsReceived += nvalue;\r\n\r\n                if (totalTokensMinted == maxMintableTokens) {\r\n                        icoStatus = IcoStatusValue.saleClosed;\r\n                        //test unnecessary -  if (getNumTokensPurchased() >= minIcoTokenGoal)\r\n                        doDeveloperGrant();\r\n                        StatEventI(\"Purchased,Granted\", qty);\r\n                } else\r\n                        StatEventI(\"Purchased\", qty);\r\n\r\n        }\r\n\r\n\r\n        // ---------------------------\r\n        // accept payment from e4row contract\r\n        // ---------------------------\r\n        function feePayment() payable  \r\n        {\r\n                if (msg.sender != e4_partner) {\r\n                        StatEvent(\"forbidden\");\r\n                        return; // thank you\r\n                }\r\n                uint nfvalue = msg.value; // preserve value in case changed in dev grant\r\n\r\n                updateIcoStatus();\r\n\r\n                holdoverBalance += nfvalue;\r\n                partnerCredits += nfvalue;\r\n                StatEventI(\"Payment\", nfvalue);\r\n\r\n                if (holdoverBalance > payoutThreshold\r\n                        || payoutBalance > 0)\r\n                        doPayout();\r\n\r\n\r\n        }\r\n\r\n        // ---------------------------\r\n        // set the e4row partner, this is only done once\r\n        // ---------------------------\r\n        function setE4RowPartner(address _addr) public\r\n        {\r\n        // ONLY owner can set and ONLY ONCE! (unless \"unlocked\" debug)\r\n        // once its locked. ONLY ONCE!\r\n                if (msg.sender == owner) {\r\n                        if ((e4_partner == address(0)) || (settingsState == SettingStateValue.debug)) {\r\n                                e4_partner = _addr;\r\n                                partnerCredits = 0;\r\n                                //StatEventI(\"E4-Set\", 0);\r\n                        } else {\r\n                                StatEvent(\"Already Set\");\r\n                        }\r\n                }\r\n        }\r\n\r\n        // ----------------------------\r\n        // return the total tokens purchased\r\n        // ----------------------------\r\n        function getNumTokensPurchased() constant returns(uint _purchased)\r\n        {\r\n                _purchased = totalTokensMinted-numDevTokens;\r\n        }\r\n\r\n        // ----------------------------\r\n        // return the num games as reported from the e4row  contract\r\n        // ----------------------------\r\n        function getNumGames() constant returns(uint _games)\r\n        {\r\n                //_games = 0;\r\n                if (e4_partner != address(0)) {\r\n                        iE4RowEscrow pe4 = iE4RowEscrow(e4_partner);\r\n                        _games = uint(pe4.getNumGamesStarted());\r\n                } \r\n                //else\r\n                //StatEvent(\"Empty E4\");\r\n        }\r\n\r\n        // ------------------------------------------------\r\n        // get the founders, auxPartner, developer\r\n        // --------------------------------------------------\r\n        function getSpecialAddresses() constant returns (address _fndr, address _aux, address _dev, address _e4)\r\n        {\r\n                //if (_sender == owner) { // no msg.sender on constant functions at least in mew\r\n                        _fndr = founderOrg;\r\n                        _aux = auxPartner;\r\n                        _dev = developers;\r\n                        _e4  = e4_partner;\r\n                //}\r\n        }\r\n\r\n\r\n\r\n        // ----------------------------\r\n        // update the ico status\r\n        // ----------------------------\r\n        function updateIcoStatus() public\r\n        {\r\n                if (icoStatus == IcoStatusValue.succeeded \r\n                        || icoStatus == IcoStatusValue.failed)\r\n                        return;\r\n                else if (icoStatus == IcoStatusValue.anouncement) {\r\n                        if (now > fundingStart && now <= fundingDeadline) {\r\n                                icoStatus = IcoStatusValue.saleOpen;\r\n\r\n                        } else if (now > fundingDeadline) {\r\n                                // should not be here - this will eventually fail\r\n                                icoStatus = IcoStatusValue.saleClosed;\r\n                        }\r\n                } else {\r\n                        uint numP = getNumTokensPurchased();\r\n                        uint numG = getNumGames();\r\n                        if ((now > fundingDeadline && numP < minIcoTokenGoal)\r\n                                || (now > usageDeadline && numG < minUsageGoal)) {\r\n                                icoStatus = IcoStatusValue.failed;\r\n                        } else if ((now > fundingDeadline) // dont want to prevent more token sales\r\n                                && (numP >= minIcoTokenGoal)\r\n                                && (numG >= minUsageGoal)) {\r\n                                icoStatus = IcoStatusValue.succeeded; // hooray\r\n                        }\r\n                        if (icoStatus == IcoStatusValue.saleOpen\r\n                                && ((numP >= maxMintableTokens)\r\n                                || (now > fundingDeadline))) {\r\n                                        icoStatus = IcoStatusValue.saleClosed;\r\n                                }\r\n                }\r\n\r\n                if (!developersGranted\r\n                        && icoStatus != IcoStatusValue.saleOpen \r\n                        && icoStatus != IcoStatusValue.anouncement\r\n                        && getNumTokensPurchased() >= minIcoTokenGoal) {\r\n                                doDeveloperGrant(); // grant whenever status goes from open to anything...\r\n                }\r\n\r\n\r\n        }\r\n\r\n\r\n        // ----------------------------\r\n        // request refund. Caller must call to request and receive refund \r\n        // WARNING - withdraw rewards/dividends before calling.\r\n        // YOU HAVE BEEN WARNED\r\n        // ----------------------------\r\n        function requestRefund()\r\n        {\r\n                address nrequester = msg.sender;\r\n                updateIcoStatus();\r\n\r\n                uint ntokens = getHeld(holderAccounts[nrequester].tokens);\r\n                if (icoStatus != IcoStatusValue.failed)\r\n                        StatEvent(\"No Refund\");\r\n                else if (ntokens == 0)\r\n                        StatEvent(\"No Tokens\");\r\n                else {\r\n                        uint nrefund = ntokens * tokenPrice;\r\n                        if (getNumTokensPurchased() >= minIcoTokenGoal)\r\n                                nrefund -= (nrefund /10); // only 90 percent b/c 10 percent payout\r\n\r\n                        holderAccounts[developers].tokens += ntokens;\r\n                        holderAccounts[nrequester].tokens = 0;\r\n                        if (holderAccounts[nrequester].balance > 0) {\r\n                                // see above warning!!\r\n                                if (!holderAccounts[developers].alloced) \r\n                                        addAccount(developers);\r\n                                holderAccounts[developers].balance += holderAccounts[nrequester].balance;\r\n                                holderAccounts[nrequester].balance = 0;\r\n                        }\r\n\r\n                        if (!nrequester.call.gas(rfGas).value(nrefund)())\r\n                                throw;\r\n                        //StatEventI(\"Refunded\", nrefund);\r\n                }\r\n        }\r\n\r\n\r\n\r\n        // ---------------------------------------------------\r\n        // payout rewards to all token holders\r\n        // use a second holding variable called PayoutBalance to do \r\n        // the actual payout from b/c too much gas to iterate thru \r\n        // each payee. Only start a new run at most once per \"minpayinterval\".\r\n        // Its done in runs of \"maxPaysPer\"\r\n        // we use special coding for the holderAccounts to avoid a hack\r\n        // of getting paid at the top of the list then transfering tokens\r\n        // to another address at the bottom of the list.\r\n        // because of that each holderAccounts entry gets the payoutid stamped upon it (top two bytes)\r\n        // also a token transfer will transfer the payout id.\r\n        // ---------------------------------------------------\r\n        function doPayout()  internal\r\n        {\r\n                if (totalTokensMinted == 0)\r\n                        return;\r\n\r\n                if ((holdoverBalance > 0) \r\n                        && (payoutBalance == 0)\r\n                        && (now > (lastPayoutTime+minPayInterval))) {\r\n                        // start a new run\r\n                        curPayoutId++;\r\n                        if (curPayoutId >= 32768)\r\n                                curPayoutId = 1;\r\n                        lastPayoutTime = now;\r\n                        payoutBalance = int(holdoverBalance);\r\n                        prOrigPayoutBal = payoutBalance;\r\n                        prOrigTokensMint = totalTokensMinted;\r\n                        holdoverBalance = 0;\r\n                        lastPayoutIndex = 0;\r\n                        StatEventI(\"StartRun\", uint(curPayoutId));\r\n                } else if (payoutBalance > 0) {\r\n                        // work down the p.o.b\r\n                        uint nAmount;\r\n                        uint nPerTokDistrib = uint(prOrigPayoutBal)/prOrigTokensMint;\r\n                        uint paids = 0;\r\n                        uint i; // intentional\r\n                        for (i = lastPayoutIndex; (paids < maxPaysPer) && (i < numAccounts) && (payoutBalance > 0); i++ ) {\r\n                                address a = holderIndexes[i];\r\n                                if (a == address(0)) {\r\n                                        continue;\r\n                                }\r\n                                var (pid, held) = getPayIdAndHeld(holderAccounts[a].tokens);\r\n                                if ((held > 0) && (pid != curPayoutId)) {\r\n                                        nAmount = nPerTokDistrib * held;\r\n                                        if (int(nAmount) <= payoutBalance){\r\n                                                holderAccounts[a].balance += nAmount; \r\n                                                holderAccounts[a].tokens = (curPayoutId * (2 ** 48)) | held;\r\n                                                payoutBalance -= int(nAmount);\r\n                                                paids++;\r\n                                        }\r\n                                }\r\n                        }\r\n                        lastPayoutIndex = i;\r\n                        if (lastPayoutIndex >= numAccounts || payoutBalance <= 0) {\r\n                                lastPayoutIndex = 0;\r\n                                if (payoutBalance > 0)\r\n                                        holdoverBalance += uint(payoutBalance);// put back any leftovers\r\n                                payoutBalance = 0;\r\n                                StatEventI(\"RunComplete\", uint(prOrigPayoutBal) );\r\n\r\n                        } else {\r\n                                StatEventI(\"PayRun\", nPerTokDistrib );\r\n                        }\r\n                }\r\n\r\n        }\r\n\r\n\r\n        // ----------------------------\r\n        // sender withdraw entire rewards/dividends\r\n        // ----------------------------\r\n        function withdrawDividends() public returns (uint _amount)\r\n        {\r\n                if (holderAccounts[msg.sender].balance == 0) { \r\n                        //_amount = 0;\r\n                        StatEvent(\"0 Balance\");\r\n                        return;\r\n                } else {\r\n                        if ((msg.sender == developers) \r\n                                &&  (now < vestTime)) {\r\n                                //statEvent(\"Tokens not yet vested.\");\r\n                                //_amount = 0;\r\n                                return;\r\n                        }\r\n\r\n                        _amount = holderAccounts[msg.sender].balance; \r\n                        holderAccounts[msg.sender].balance = 0; \r\n                        if (!msg.sender.call.gas(rwGas).value(_amount)())\r\n                                throw;\r\n                        //StatEventI(\"Paid\", _amount);\r\n\r\n                }\r\n\r\n        }\r\n\r\n        // ----------------------------\r\n        // set gas for operations\r\n        // ----------------------------\r\n        function setOpGas(uint _rm, uint _rf, uint _rw)\r\n        {\r\n                if (msg.sender != owner && msg.sender != developers) {\r\n                        //StatEvent(\"only owner calls\");\r\n                        return;\r\n                } else {\r\n                        rmGas = _rm;\r\n                        rfGas = _rf;\r\n                        rwGas = _rw;\r\n                }\r\n        }\r\n\r\n        // ----------------------------\r\n        // get gas for operations\r\n        // ----------------------------\r\n        function getOpGas() constant returns (uint _rm, uint _rf, uint _rw)\r\n        {\r\n                _rm = rmGas;\r\n                _rf = rfGas;\r\n                _rw = rwGas;\r\n        }\r\n \r\n\r\n        // ----------------------------\r\n        // check rewards.  pass in address of token holder\r\n        // ----------------------------\r\n        function checkDividends(address _addr) constant returns(uint _amount)\r\n        {\r\n                if (holderAccounts[_addr].alloced)\r\n                        _amount = holderAccounts[_addr].balance;\r\n        }\r\n\r\n\r\n        // ------------------------------------------------\r\n        // icoCheckup - check up call for administrators\r\n        // after sale is closed if min ico tokens sold, 10 percent will be distributed to \r\n        // company to cover various operating expenses\r\n        // after sale and usage dealines have been met, remaining 90 percent will be distributed to\r\n        // company.\r\n        // ------------------------------------------------\r\n        function icoCheckup() public\r\n        {\r\n                if (msg.sender != owner && msg.sender != developers)\r\n                        throw;\r\n\r\n                uint nmsgmask;\r\n                //nmsgmask = 0;\r\n\r\n                if (icoStatus == IcoStatusValue.saleClosed) {\r\n                        if ((getNumTokensPurchased() >= minIcoTokenGoal)\r\n                                && (remunerationStage == 0 )) {\r\n                                remunerationStage = 1;\r\n                                remunerationBalance = (totalTokenFundsReceived/100)*9; // 9 percent\r\n                                auxPartnerBalance =  (totalTokenFundsReceived/100); // 1 percent\r\n                                nmsgmask |= 1;\r\n                        } \r\n                }\r\n                if (icoStatus == IcoStatusValue.succeeded) {\r\n\r\n                        if (remunerationStage == 0 ) {\r\n                                remunerationStage = 1;\r\n                                remunerationBalance = (totalTokenFundsReceived/100)*9; \r\n                                auxPartnerBalance =  (totalTokenFundsReceived/100);\r\n                                nmsgmask |= 4;\r\n                        }\r\n                        if (remunerationStage == 1) { // we have already suceeded\r\n                                remunerationStage = 2;\r\n                                remunerationBalance += totalTokenFundsReceived - (totalTokenFundsReceived/10); // 90 percent\r\n                                nmsgmask |= 8;\r\n                        }\r\n\r\n                }\r\n\r\n                uint ntmp;\r\n\r\n                if (remunerationBalance > 0) { \r\n                // only pay one entity per call, dont want to run out of gas\r\n                                ntmp = remunerationBalance;\r\n                                remunerationBalance = 0;\r\n                                if (!founderOrg.call.gas(rmGas).value(ntmp)()) {\r\n                                        remunerationBalance = ntmp;\r\n                                        nmsgmask |= 32;\r\n                                } else {\r\n                                        nmsgmask |= 64;\r\n                                }\r\n                } else  if (auxPartnerBalance > 0) {\r\n                // note the \"else\" only pay one entity per call, dont want to run out of gas\r\n                        ntmp = auxPartnerBalance;\r\n                        auxPartnerBalance = 0;\r\n                        if (!auxPartner.call.gas(rmGas).value(ntmp)()) {\r\n                                auxPartnerBalance = ntmp;\r\n                                nmsgmask |= 128;\r\n                        }  else {\r\n                                nmsgmask |= 256;\r\n                        }\r\n\r\n                } \r\n\r\n                StatEventI(\"ico-checkup\", nmsgmask);\r\n        }\r\n\r\n\r\n        // ----------------------------\r\n        // swap executor\r\n        // ----------------------------\r\n        function changeOwner(address _addr) \r\n        {\r\n                if (msg.sender != owner\r\n                        || settingsState == SettingStateValue.lockedRelease)\r\n                         throw;\r\n\r\n                owner = _addr;\r\n        }\r\n\r\n        // ----------------------------\r\n        // swap developers account\r\n        // ----------------------------\r\n        function changeDevevoperAccont(address _addr) \r\n        {\r\n                if (msg.sender != owner\r\n                        || settingsState == SettingStateValue.lockedRelease)\r\n                         throw;\r\n                developers = _addr;\r\n        }\r\n\r\n        // ----------------------------\r\n        // change founder\r\n        // ----------------------------\r\n        function changeFounder(address _addr) \r\n        {\r\n                if (msg.sender != owner\r\n                        || settingsState == SettingStateValue.lockedRelease)\r\n                         throw;\r\n                founderOrg = _addr;\r\n        }\r\n\r\n        // ----------------------------\r\n        // change auxPartner\r\n        // ----------------------------\r\n        function changeAuxPartner(address _aux) \r\n        {\r\n                if (msg.sender != owner\r\n                        || settingsState == SettingStateValue.lockedRelease)\r\n                         throw;\r\n                auxPartner = _aux;\r\n        }\r\n\r\n\r\n        // ----------------------------\r\n        // DEBUG ONLY - end this contract, suicide to developers\r\n        // ----------------------------\r\n        function haraKiri()\r\n        {\r\n                if (settingsState != SettingStateValue.debug)\r\n                        throw;\r\n                if (msg.sender != owner)\r\n                         throw;\r\n                suicide(developers);\r\n        }\r\n\r\n        // ----------------------------\r\n        // get all ico status, funding and usage info\r\n        // ----------------------------\r\n        function getIcoInfo() constant returns(IcoStatusValue _status, uint _saleStart, uint _saleEnd, uint _usageEnd, uint _saleGoal, uint _usageGoal, uint _sold, uint _used, uint _funds, uint _credits, uint _remuStage, uint _vest)\r\n        {\r\n                _status = icoStatus;\r\n                _saleStart = fundingStart;\r\n                _saleEnd = fundingDeadline;\r\n                _usageEnd = usageDeadline;\r\n                _vest = vestTime;\r\n                _saleGoal = minIcoTokenGoal;\r\n                _usageGoal = minUsageGoal;\r\n                _sold = getNumTokensPurchased();\r\n                _used = getNumGames();\r\n                _funds = totalTokenFundsReceived;\r\n                _credits = partnerCredits;\r\n                _remuStage = remunerationStage;\r\n        }\r\n\r\n        function flushDividends()\r\n        {\r\n                if ((msg.sender != owner) && (msg.sender != developers))\r\n                        return;\r\n                if (holdoverBalance > 0 || payoutBalance > 0)\r\n                        doPayout();\r\n        }\r\n\r\n        function doDeveloperGrant() internal\r\n        {\r\n                if (!developersGranted) {\r\n                        developersGranted = true;\r\n                        numDevTokens = totalTokensMinted/10;\r\n                        totalTokensMinted += numDevTokens;\r\n                        if (!holderAccounts[developers].alloced) \r\n                                addAccount(developers);\r\n                        uint newHeld = getHeld(holderAccounts[developers].tokens) + numDevTokens;\r\n                        holderAccounts[developers].tokens = newHeld |  (curPayoutId * (2 ** 48));\r\n\r\n                }\r\n        }\r\n\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"changeDevevoperAccont\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"flushDividends\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"supply\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remunerationBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkDividends\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPaysPer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateIcoStatus\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDividends\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"feePayment\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rm\",\"type\":\"uint256\"},{\"name\":\"_rf\",\"type\":\"uint256\"},{\"name\":\"_rw\",\"type\":\"uint256\"}],\"name\":\"setOpGas\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curPayoutId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPayoutTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settingsState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumGames\",\"outputs\":[{\"name\":\"_games\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"icoCheckup\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensMinted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getIcoInfo\",\"outputs\":[{\"name\":\"_status\",\"type\":\"uint8\"},{\"name\":\"_saleStart\",\"type\":\"uint256\"},{\"name\":\"_saleEnd\",\"type\":\"uint256\"},{\"name\":\"_usageEnd\",\"type\":\"uint256\"},{\"name\":\"_saleGoal\",\"type\":\"uint256\"},{\"name\":\"_usageGoal\",\"type\":\"uint256\"},{\"name\":\"_sold\",\"type\":\"uint256\"},{\"name\":\"_used\",\"type\":\"uint256\"},{\"name\":\"_funds\",\"type\":\"uint256\"},{\"name\":\"_credits\",\"type\":\"uint256\"},{\"name\":\"_remuStage\",\"type\":\"uint256\"},{\"name\":\"_vest\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setE4RowPartner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"qState\",\"type\":\"uint8\"},{\"name\":\"_saleStart\",\"type\":\"uint256\"},{\"name\":\"_saleEnd\",\"type\":\"uint256\"},{\"name\":\"_usageEnd\",\"type\":\"uint256\"},{\"name\":\"_minUsage\",\"type\":\"uint256\"},{\"name\":\"_tokGoal\",\"type\":\"uint256\"},{\"name\":\"_maxMintable\",\"type\":\"uint256\"},{\"name\":\"_threshold\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_mpp\",\"type\":\"uint256\"},{\"name\":\"_mpi\",\"type\":\"uint256\"}],\"name\":\"applySettings\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"changeFounder\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOpGas\",\"outputs\":[{\"name\":\"_rm\",\"type\":\"uint256\"},{\"name\":\"_rf\",\"type\":\"uint256\"},{\"name\":\"_rw\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"holderExists\",\"outputs\":[{\"name\":\"_exist\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_aux\",\"type\":\"address\"}],\"name\":\"changeAuxPartner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSpecialAddresses\",\"outputs\":[{\"name\":\"_fndr\",\"type\":\"address\"},{\"name\":\"_aux\",\"type\":\"address\"},{\"name\":\"_dev\",\"type\":\"address\"},{\"name\":\"_e4\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"purchaseToken\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumTokensPurchased\",\"outputs\":[{\"name\":\"_purchased\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"haraKiri\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minPayInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"requestRefund\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"holdoverBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPayoutIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"StatEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"StatEventI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"E4Token","CompilerVersion":"v0.4.10+commit.f0d539ae","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2ed119bc726a20ea62d8789ba880946fb9b037556ce17bff8f3a46923aeb05bb"}]}