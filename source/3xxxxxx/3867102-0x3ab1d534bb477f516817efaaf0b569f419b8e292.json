{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.10;\r\n\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n/*\r\n * Safe Math Smart Contract.  Copyright Â© 2016 by ABDK Consulting.\r\n */\r\n\r\n/**\r\n * Provides methods to safely add, subtract and multiply uint256 numbers.\r\n */\r\ncontract SafeMath {\r\n  uint256 constant private MAX_UINT256 =\r\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /**\r\n   * Add two uint256 values, throw in case of overflow.\r\n   *\r\n   * @param x first value to add\r\n   * @param y second value to add\r\n   * @return x + y\r\n   */\r\n  function safeAdd (uint256 x, uint256 y)\r\n  constant internal\r\n  returns (uint256 z) {\r\n    if (x > MAX_UINT256 - y) throw;\r\n    return x + y;\r\n  }\r\n\r\n  /**\r\n   * Subtract one uint256 value from another, throw in case of underflow.\r\n   *\r\n   * @param x value to subtract from\r\n   * @param y value to subtract\r\n   * @return x - y\r\n   */\r\n  function safeSub (uint256 x, uint256 y)\r\n  constant internal\r\n  returns (uint256 z) {\r\n    if (x < y) throw;\r\n    return x - y;\r\n  }\r\n\r\n  /**\r\n   * Multiply two uint256 values, throw in case of overflow.\r\n   *\r\n   * @param x first value to multiply\r\n   * @param y second value to multiply\r\n   * @return x * y\r\n   */\r\n  function safeMul (uint256 x, uint256 y)\r\n  constant internal\r\n  returns (uint256 z) {\r\n    if (y == 0) return 0; // Prevent division by zero at the next line\r\n    if (x > MAX_UINT256 / y) throw;\r\n    return x * y;\r\n  }\r\n}\r\n\r\ncontract Vote is ERC20, SafeMath{\r\n\r\n\tmapping (address => uint) balances;\r\n\tmapping (address => mapping (address => uint)) allowed;\r\n\r\n\tuint public totalSupply;\r\n\tuint public initialSupply;\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals;\r\n\r\n\tfunction Vote(){\r\n\t\tinitialSupply = 100000;\r\n\t\ttotalSupply = initialSupply;\r\n\t\tbalances[msg.sender] = initialSupply;\r\n\t\tname = \"EthTaipei Logo Vote\";\r\n\t\tsymbol = \"EthTaipei Logo\";\r\n\t\tdecimals = 0;\r\n\t}\r\n\r\n\tfunction transfer(address _to, uint _value) returns (bool) {\r\n\t    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n\t    balances[_to] = safeAdd(balances[_to], _value);\r\n\t    Transfer(msg.sender, _to, _value);\r\n\t    return true;\r\n  \t}\r\n\r\n  \tfunction transferFrom(address _from, address _to, uint _value) returns (bool) {\r\n\t    var _allowance = allowed[_from][msg.sender];\t    \r\n\t    balances[_to] = safeAdd(balances[_to], _value);\r\n\t    balances[_from] = safeSub(balances[_from], _value);\r\n\t    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n\t    Transfer(_from, _to, _value);\r\n\t    return true;\r\n  \t}\r\n\r\n  \tfunction approve(address _spender, uint _value) returns (bool) {\r\n    \tallowed[msg.sender][_spender] = _value;\r\n    \tApproval(msg.sender, _spender, _value);\r\n    \treturn true;\r\n  \t}\r\n\r\n  \tfunction balanceOf(address _address) constant returns (uint balance) {\r\n  \t\treturn balances[_address];\r\n  \t}\r\n\r\n  \tfunction allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    \treturn allowed[_owner][_spender];\r\n  \t}\r\n\r\n}\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    if (msg.sender == owner)\r\n      _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract wLogoVote {\r\n\tfunction claimReward(address _receiver);\r\n}\r\n\r\ncontract Logo is Ownable{\r\n\r\n\twLogoVote public logoVote;\r\n\r\n\taddress public author;\r\n\tstring public metadataUrl;\r\n\r\n\tevent ReceiveTips(address _from, uint _value);\r\n\r\n\tfunction Logo(address _owner, address _author, string _metadatUrl){\r\n\t\towner = _owner;\r\n\t\tauthor = _author;\r\n\t\tmetadataUrl = _metadatUrl;\r\n\t\tlogoVote = wLogoVote(msg.sender);\r\n\t}\r\n\r\n\tfunction tips() payable {\r\n\t\tReceiveTips(msg.sender, msg.value);\r\n\t\tif(!author.send(msg.value)) throw;\r\n\t}\r\n\r\n\tfunction claimReward() onlyOwner {\r\n\t\tlogoVote.claimReward(author);\r\n\t}\r\n\r\n\tfunction setMetadata(string _metadataUrl) onlyOwner {\r\n\t\tmetadataUrl = _metadataUrl;\r\n\t}\r\n\r\n\tfunction () payable {\r\n\t\ttips();\r\n\t}\r\n}\r\n/*\r\n * Pausable\r\n * Abstract contract that allows children to implement an\r\n * emergency stop mechanism.\r\n */\r\n\r\ncontract Pausable is Ownable {\r\n  bool public stopped;\r\n\r\n  modifier stopInEmergency {\r\n    if (stopped) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n  \r\n  modifier onlyInEmergency {\r\n    if (!stopped) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  // called by the owner on emergency, triggers stopped state\r\n  function emergencyStop() external onlyOwner {\r\n    stopped = true;\r\n  }\r\n\r\n  // called by the owner on end of emergency, returns to normal state\r\n  function release() external onlyOwner onlyInEmergency {\r\n    stopped = false;\r\n  }\r\n\r\n}\r\ncontract Token{\r\n\tfunction transfer(address to, uint value) returns (bool ok);\r\n}\r\n\r\ncontract Faucet {\r\n\r\n\taddress public tokenAddress;\r\n\tToken token;\r\n\r\n\tfunction Faucet(address _tokenAddress) {\r\n\t\ttokenAddress = _tokenAddress;\r\n\t\ttoken = Token(tokenAddress);\r\n\t}\r\n  \r\n\tfunction getToken() {\r\n\t\tif(!token.transfer(msg.sender, 1)) throw;\r\n\t}\r\n\r\n\tfunction () {\r\n\t\tgetToken();\r\n\t}\r\n\r\n}\r\n\r\ncontract LogoVote is Pausable, SafeMath{\r\n\r\n\tVote public vote;\r\n\tFaucet public faucet;\r\n\tLogo[] public logos;\r\n\r\n\tmapping (address => uint) backers;\r\n\tmapping (address => bool) rewards;\r\n\tuint rewardClaimed;\r\n\r\n\tuint public votePerETH;\r\n\tuint public totalReward;\r\n\tuint public startBlock;\r\n\tuint public endBlock;\r\n\taddress public winner;\r\n\r\n\tevent ReceiveDonate(address addr, uint value);\r\n\r\n\tmodifier respectTimeFrame() {\r\n\t\tif (!isRespectTimeFrame()) throw;\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier afterEnd() {\r\n\t\tif (!isAfterEnd()) throw;\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction LogoVote() {\r\n\t\tvote = new Vote();\r\n\t\tfaucet = new Faucet(vote);\r\n\t\tvotePerETH = 1000; // donate 0.001 ether to get 1 vote \r\n\t\ttotalReward = 0;\r\n\t\tstartBlock = getBlockNumber();\r\n\t\tendBlock = startBlock + ( 30 * 24 * 60 * 60 / 15 ); //end in 30 days\r\n\t\trewardClaimed = 0;\r\n\t}\r\n\r\n\t// functions only for owner \r\n\tfunction sendToFaucet(uint _amount) onlyOwner {\r\n\t\tif(!vote.transfer(faucet, _amount)) throw;\r\n\t}\r\n\r\n\tfunction registLogo(address _owner, address _author, string _metadatUrl) \r\n\t\t\t\t\t\tonlyOwner respectTimeFrame returns (address) {\r\n\t\tLogo logoAddress = new Logo(_owner, _author, _metadatUrl);\r\n\t\tlogos.push(logoAddress);\r\n\t\treturn logoAddress;\r\n\t}\r\n\r\n\tfunction claimWinner () onlyOwner afterEnd {\r\n\t\tif (isLogo(winner)) throw;\r\n\t\twinner = logos[0];\r\n\t\tfor (uint8 i = 1; i < logos.length; i++) {\r\n\t\t\tif (vote.balanceOf(logos[i]) > vote.balanceOf(winner))\r\n\t\t\t\twinner = logos[i];\r\n\t\t} \r\n\t}\r\n\r\n\tfunction cleanBalance () onlyOwner afterEnd {\r\n\t\tif (rewardClaimed >= logos.length || getBlockNumber() < endBlock + 43200) throw;\r\n\t\tif(!vote.transfer(owner, vote.balanceOf(this))) throw;\r\n\t\tif (!owner.send(this.balance)) throw;\r\n\t}\r\n\r\n\t// normal user can donate to get votes\r\n\tfunction donate(address beneficiary) internal stopInEmergency respectTimeFrame {\r\n\t\tuint voteToSend = safeMul(msg.value, votePerETH)/(1 ether);\r\n\t\tif (!vote.transfer(beneficiary, voteToSend)) throw; \r\n\t\tbackers[beneficiary] = safeAdd(backers[beneficiary], msg.value);\r\n\t\ttotalReward = safeAdd(totalReward, msg.value);\r\n\r\n\t\tReceiveDonate(beneficiary, msg.value);\r\n\t}\r\n\r\n\t// normal user can get back their funds if in emergency \r\n\tfunction getFunds() onlyInEmergency {\r\n\t\tif (backers[msg.sender] == 0) throw;\r\n\t\tuint amount = backers[msg.sender];\r\n\t\tbackers[msg.sender] = 0;\r\n\r\n\t\tif(!msg.sender.send(amount)) throw;\r\n\t}\r\n\r\n\t// logo's owner can claim their rewards after end \r\n\tfunction claimReward (address _receiver) stopInEmergency afterEnd {\r\n\t\tif (!isLogo(msg.sender)) throw;\r\n\t\tif (rewards[msg.sender]) throw;\r\n\t\tif (rewardClaimed == logos.length) throw;\r\n\t\tuint amount = totalReward / safeMul(2, logos.length); // all logos share the 50% of rewards\r\n\t\tif (msg.sender == winner) {\r\n\t\t\tamount = safeAdd(amount, totalReward/2);\r\n\t\t}\r\n\t\trewards[msg.sender] = true;\r\n\t\trewardClaimed = safeAdd(rewardClaimed, 1);\r\n\t\tif (!_receiver.send(amount)) throw;\r\n\t}\r\n\r\n\r\n\t// helper functions \r\n\tfunction isLogo (address _logoAddress) constant returns (bool) {\r\n\t\tfor (uint8 i = 0; i < logos.length; i++) {\r\n\t\t\tif (logos[i] == _logoAddress) return true;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getLogos() constant returns (Logo[]) {\r\n\t\treturn logos;\r\n\t}\r\n\r\n\tfunction getBlockNumber() constant returns (uint) {\r\n      return block.number;\r\n    }\r\n\r\n\tfunction isAfterEnd() constant returns (bool) {\r\n      return getBlockNumber() > endBlock;\r\n    }\r\n\r\n\tfunction isRespectTimeFrame() constant returns (bool) {\r\n\t\treturn getBlockNumber() < endBlock;\r\n\t}\r\n\r\n\tfunction () payable {\r\n\t\tif (isAfterEnd()) throw;\r\n\t\tdonate(msg.sender);\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isAfterEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLogos\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"logos\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_author\",\"type\":\"address\"},{\"name\":\"_metadatUrl\",\"type\":\"string\"}],\"name\":\"registLogo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimWinner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getFunds\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"votePerETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_logoAddress\",\"type\":\"address\"}],\"name\":\"isLogo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vote\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyStop\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sendToFaucet\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cleanBalance\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isRespectTimeFrame\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"claimReward\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"faucet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ReceiveDonate\",\"type\":\"event\"}]","ContractName":"LogoVote","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9d7942e50d4605d1a022548833fedd7884232c58d574cad18da3bb34351aa5c2"}]}