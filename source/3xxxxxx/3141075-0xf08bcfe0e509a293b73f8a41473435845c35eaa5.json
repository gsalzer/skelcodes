{"status":"1","message":"OK","result":[{"SourceCode":"library ArrayLib {\r\n  // Inserts to keep array sorted (assumes input array is sorted)\r\n\tfunction insertInPlace(uint8[] storage self, uint8 n) {\r\n\t\tuint8 insertingIndex = 0;\r\n\r\n\t\twhile (self.length > 0 && insertingIndex < self.length && self[insertingIndex] < n) {\r\n\t\t\tinsertingIndex += 1;\r\n\t\t}\r\n\r\n\t\tself.length += 1;\r\n\t\tfor (uint8 i = uint8(self.length) - 1; i > insertingIndex; i--) {\r\n\t\t\tself[i] = self[i - 1];\r\n\t\t}\r\n\r\n\t\tself[insertingIndex] = n;\r\n\t}\r\n}\r\n\r\n\r\nlibrary DeckLib {\r\n\tusing ArrayLib for uint8[];\r\n\r\n\tenum Suit { Spades, Hearts, Clubs, Diamonds }\r\n\tuint8 constant cardsPerSuit = 13;\r\n\tuint8 constant suits = 4;\r\n\tuint8 constant totalCards = cardsPerSuit * suits;\r\n\r\n\tstruct Deck {\r\n\t\tuint8[] usedCards; // always has to be sorted\r\n\t\taddress player;\r\n\t\tuint256 gameID;\r\n\t}\r\n\r\n\tfunction init(Deck storage self, uint256 gameID)  {\r\n\t\tself.usedCards = new uint8[](0);\r\n\t\tself.player = msg.sender;\r\n\t\tself.gameID = gameID;\r\n\t}\r\n\r\n\tfunction getCard(Deck storage self, uint256 blockNumber)  returns (uint8)  {\r\n\t\tuint cardIndex = self.usedCards.length;\r\n\t\tif (cardIndex >= totalCards) throw;\r\n\t\tuint8 r = uint8(getRandomNumber(blockNumber, self.player, self.gameID, cardIndex, totalCards - cardIndex));\r\n\r\n\t\tfor (uint8 i = 0; i < cardIndex; i++) {\r\n\t\t\tif (self.usedCards[i] <= r) r += 1;\r\n\t\t}\r\n\r\n\t\tself.usedCards.insertInPlace(r);\r\n\r\n\t\treturn r;\r\n\t}\r\n\r\n\tfunction cardDescription(uint8 self) constant returns (Suit, uint8) {\r\n\t\treturn (Suit(self / cardsPerSuit), cardFacevalue(self));\r\n\t}\r\n\r\n\tfunction cardEmojified(uint8 self) constant returns (uint8, string) {\r\n\t\tstring memory emojiSuit;\r\n\r\n\t\tvar (suit, number) = cardDescription(self);\r\n\t\tif (suit == Suit.Clubs) emojiSuit = \"♣️\";\r\n\t\telse if (suit == Suit.Diamonds) emojiSuit = \"♦️\";\r\n\t\telse if (suit == Suit.Hearts) emojiSuit = \"♥️\";\r\n\t\telse if (suit == Suit.Spades) emojiSuit = \"♠️\";\r\n\r\n\t\treturn (number, emojiSuit);\r\n\t}\r\n\r\n\tfunction cardFacevalue(uint8 self) constant returns (uint8) {\r\n\t\treturn 1 + self % cardsPerSuit;\r\n\t}\r\n\r\n\tfunction blackjackValue(uint8 self) constant returns (uint8) {\r\n\t\tuint8 cardValue = cardFacevalue(self);\r\n\t\treturn cardValue < 10 ? cardValue : 10;\r\n\t}\r\n\r\n\tfunction getRandomNumber(uint b, address player, uint256 gameID, uint n, uint m) constant returns (uint) {\r\n\t\t// Uses blockhash as randomness source.\r\n\t\t// Credits: https://github.com/Bunjin/Rouleth/blob/master/Provably_Fair_No_Cheating.md\r\n\t\tbytes32 blockHash = block.blockhash(b);\r\n\t\tif (blockHash == 0x0) throw;\r\n\t\treturn uint(uint256(keccak256(blockHash, player, gameID, n)) % m);\r\n\r\n\t}\r\n}\r\n\r\nlibrary GameLib {\r\n  using DeckLib for *;\r\n\r\n  uint8 constant houseLimit = 17;\r\n  uint8 constant target = 21;\r\n\r\n  enum ComparaisonResult { First, Second, Tie }\r\n  enum GameState { InitialCards, Waiting, Hit, Stand, Finished }\r\n  enum GameResult { Ongoing, House, Tie, Player, PlayerNatural }\r\n\r\n  struct Game {\r\n    address player;\r\n    uint256 bet;\r\n    uint256 payout;\r\n    uint256 gameID;\r\n\r\n    DeckLib.Deck deck;\r\n    uint8[] houseCards;\r\n    uint8[] playerCards;\r\n\r\n    uint256 actionBlock; // Block on which commitment to perform an action happens.\r\n\r\n    GameState state;\r\n    GameResult result;\r\n\r\n    bool closed;\r\n  }\r\n\r\n  function init(Game storage self, uint256 gameID) {\r\n    self.player = msg.sender;\r\n    self.bet = msg.value;\r\n    self.payout = 0;\r\n    self.houseCards = new uint8[](0);\r\n    self.playerCards = new uint8[](0);\r\n    self.actionBlock = block.number;\r\n    self.state = GameState.InitialCards;\r\n    self.result = GameResult.Ongoing;\r\n    self.closed = false;\r\n    self.gameID = gameID;\r\n\r\n    self.deck.init(gameID);\r\n  }\r\n\r\n  function tick(Game storage self)  returns (bool) {\r\n    if (block.number <= self.actionBlock) return false; // Can't tick yet\r\n    if (self.actionBlock + 255 < block.number) {\r\n      endGame(self, GameResult.House);\r\n      return true;\r\n    }\r\n    if (!needsTick(self)) return true; // not needed, everything is fine\r\n\r\n    if (self.state == GameState.InitialCards) dealInitialCards(self);\r\n    if (self.state == GameState.Hit) dealHitCard(self);\r\n\r\n    if (self.state == GameState.Stand) {\r\n      dealHouseCards(self);\r\n      checkGameResult(self);\r\n    } else {\r\n      checkGameContinues(self);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function needsTick(Game storage self) constant returns (bool) {\r\n    if (self.state == GameState.Waiting) return false;\r\n    if (self.state == GameState.Finished) return false;\r\n\r\n    return true;\r\n  }\r\n\r\n  function checkGameResult(Game storage self)  {\r\n    uint8 houseHand = countHand(self.houseCards);\r\n\r\n    if (houseHand == target && self.houseCards.length == 2) return endGame(self, GameResult.House); // House natural\r\n\r\n    ComparaisonResult result = compareHands(houseHand, countHand(self.playerCards));\r\n    if (result == ComparaisonResult.First) return endGame(self, GameResult.House);\r\n    if (result == ComparaisonResult.Second) return endGame(self, GameResult.Player);\r\n\r\n    endGame(self, GameResult.Tie);\r\n  }\r\n\r\n  function checkGameContinues(Game storage self)  {\r\n    uint8 playerHand = countHand(self.playerCards);\r\n    if (playerHand == target && self.playerCards.length == 2) return endGame(self, GameResult.PlayerNatural); // player natural\r\n    if (playerHand > target) return endGame(self, GameResult.House); // Player busted\r\n    if (playerHand == target) {\r\n      // Player is forced to stand with 21\r\n      uint256 currentActionBlock = self.actionBlock;\r\n      playerDecision(self, GameState.Stand);\r\n      self.actionBlock = currentActionBlock;\r\n      if (!tick(self)) throw; // Forces tick, commitment to play actually happened past block\r\n    }\r\n  }\r\n\r\n  function playerDecision(Game storage self, GameState decision)  {\r\n    if (self.state != GameState.Waiting) throw;\r\n    if (decision != GameState.Hit && decision != GameState.Stand) throw;\r\n\r\n    self.state = decision;\r\n    self.actionBlock = block.number;\r\n  }\r\n\r\n  function dealInitialCards(Game storage self) private {\r\n    self.playerCards.push(self.deck.getCard(self.actionBlock));\r\n    self.houseCards.push(self.deck.getCard(self.actionBlock));\r\n    self.playerCards.push(self.deck.getCard(self.actionBlock));\r\n\r\n    self.state = GameState.Waiting;\r\n  }\r\n\r\n  function dealHitCard(Game storage self) private {\r\n    self.playerCards.push(self.deck.getCard(self.actionBlock));\r\n\r\n    self.state = GameState.Waiting;\r\n  }\r\n\r\n  function dealHouseCards(Game storage self) private {\r\n    self.houseCards.push(self.deck.getCard(self.actionBlock));\r\n\r\n    if (countHand(self.houseCards) < houseLimit) dealHouseCards(self);\r\n  }\r\n\r\n  function endGame(Game storage self, GameResult result) {\r\n    self.result = result;\r\n    self.state = GameState.Finished;\r\n    self.payout = payoutForResult(self.result, self.bet);\r\n\r\n    closeGame(self);\r\n  }\r\n\r\n  function closeGame(Game storage self) private {\r\n    if (self.closed) throw; // cannot re-close\r\n    if (self.state != GameState.Finished) throw; // not closable\r\n\r\n    self.closed = true;\r\n\r\n    if (self.payout > 0) {\r\n      if (!self.player.send(self.payout)) throw;\r\n    }\r\n  }\r\n\r\n  function payoutForResult(GameResult result, uint256 bet) private returns (uint256) {\r\n    if (result == GameResult.PlayerNatural) return bet * 5 / 2; // bet + 1.5x bet\r\n    if (result == GameResult.Player) return bet * 2; // doubles bet\r\n    if (result == GameResult.Tie) return bet; // returns bet\r\n\r\n    return 0;\r\n  }\r\n\r\n  function countHand(uint8[] memory hand)  returns (uint8) {\r\n    uint8[] memory possibleSums = new uint8[](1);\r\n\r\n    for (uint i = 0; i < hand.length; i++) {\r\n      uint8 value = hand[i].blackjackValue();\r\n      uint l = possibleSums.length;\r\n      for (uint j = 0; j < l; j++) {\r\n        possibleSums[j] += value;\r\n        if (value == 1) { // is Ace\r\n          possibleSums = appendArray(possibleSums, possibleSums[j] + 10); // Fork possible sum with 11 as ace value.\r\n        }\r\n      }\r\n    }\r\n\r\n    return bestSum(possibleSums);\r\n  }\r\n\r\n  function bestSum(uint8[] possibleSums)  returns (uint8 bestSum) {\r\n    bestSum = 50; // very bad hand\r\n    for (uint i = 0; i < possibleSums.length; i++) {\r\n      if (compareHands(bestSum, possibleSums[i]) == ComparaisonResult.Second) {\r\n        bestSum = possibleSums[i];\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  function appendArray(uint8[] memory array, uint8 n)  returns (uint8[] memory) {\r\n    uint8[] memory newArray = new uint8[](array.length + 1);\r\n    for (uint8 i = 0; i < array.length; i++) {\r\n      newArray[i] = array[i];\r\n    }\r\n    newArray[array.length] = n;\r\n    return newArray;\r\n  }\r\n\r\n  function compareHands(uint8 a, uint8 b)  returns (ComparaisonResult) {\r\n    if (a <= target && b <= target) {\r\n      if (a > b) return ComparaisonResult.First;\r\n      if (a < b) return ComparaisonResult.Second;\r\n    }\r\n\r\n    if (a > target && b > target) {\r\n      if (a < b) return ComparaisonResult.First;\r\n      if (a > b) return ComparaisonResult.Second;\r\n    }\r\n\r\n    if (a > target) return ComparaisonResult.Second;\r\n    if (b > target) return ComparaisonResult.First;\r\n\r\n    return ComparaisonResult.Tie;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint8\"},{\"name\":\"b\",\"type\":\"uint8\"}],\"name\":\"compareHands\",\"outputs\":[{\"name\":\"\",\"type\":\"GameLib.ComparaisonResult\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"array\",\"type\":\"uint8[]\"},{\"name\":\"n\",\"type\":\"uint8\"}],\"name\":\"appendArray\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"GameLib.Game storage\"}],\"name\":\"tick\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"GameLib.Game storage\"},{\"name\":\"result\",\"type\":\"GameLib.GameResult\"}],\"name\":\"endGame\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"GameLib.Game storage\"}],\"name\":\"needsTick\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"GameLib.Game storage\"}],\"name\":\"checkGameResult\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"GameLib.Game storage\"},{\"name\":\"gameID\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"GameLib.Game storage\"}],\"name\":\"checkGameContinues\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"possibleSums\",\"type\":\"uint8[]\"}],\"name\":\"bestSum\",\"outputs\":[{\"name\":\"bestSum\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"GameLib.Game storage\"},{\"name\":\"decision\",\"type\":\"GameLib.GameState\"}],\"name\":\"playerDecision\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hand\",\"type\":\"uint8[]\"}],\"name\":\"countHand\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"}]","ContractName":"GameLib","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"DeckLib:8afe99cee656b11f514816db8b61ae9324a9f111","SwarmSource":"bzzr://4f84dbcde81b7a430469dd8479fb2cb1c7a704dbccdf62382e8a23f23dc1f950"}]}