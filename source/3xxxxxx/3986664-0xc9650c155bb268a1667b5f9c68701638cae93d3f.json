{"status":"1","message":"OK","result":[{"SourceCode":"{\"AccessControl.sol\":{\"content\":\"pragma solidity ^0.4.11;\\n\\n/**\\n * Interface for an access control strategy for Macrtoverse contracts.\\n * Can be asked if a certain query should be allowed, and will return true or false.\\n * Allows for different access control strategies (unrestricted, minimum balance, subscription, etc.) to be swapped in.\\n */\\ncontract AccessControl {\\n    /**\\n     * Should a query be allowed for this msg.sender (calling contract) and this tx.origin (calling user)?\\n     */\\n    function allowQuery(address sender, address origin) constant returns (bool);\\n}\"},\"ControlledAccess.sol\":{\"content\":\"pragma solidity ^0.4.11;\\n\\nimport \\\"./AccessControl.sol\\\";\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * Represents a contract that is Ownable, and which has methods that are to be protected by an AccessControl strategy selected by the owner.\\n */\\ncontract ControlledAccess is Ownable {\\n\\n    // This AccessControl contract determines who can run onlyControlledAccess methods.\\n    AccessControl accessControl;\\n    \\n    /**\\n     * Make a new ControlledAccess contract, controlling access with the given AccessControl strategy.\\n     */\\n    function ControlledAccess(address originalAccessControl) {\\n        accessControl = AccessControl(originalAccessControl);\\n    }\\n    \\n    /**\\n     * Change the access control strategy of the prototype.\\n     */\\n    function changeAccessControl(address newAccessControl) onlyOwner {\\n        accessControl = AccessControl(newAccessControl);\\n    }\\n    \\n    /**\\n     * Only allow queries approved by the access control contract.\\n     */\\n    modifier onlyControlledAccess {\\n        if (!accessControl.allowQuery(msg.sender, tx.origin)) throw;\\n        _;\\n    }\\n    \\n\\n}\\n\"},\"MacroverseStarGenerator.sol\":{\"content\":\"pragma solidity ^0.4.11;\\n\\nimport \\\"./RNG.sol\\\";\\nimport \\\"./RealMath.sol\\\";\\n\\nimport \\\"./AccessControl.sol\\\";\\nimport \\\"./ControlledAccess.sol\\\";\\n\\n/**\\n * Represents a prorotype Macroverse Generator for a galaxy.\\n *\\n * Permission to call methods on this contract is regulated by a configurable\\n * AccessControl contract. One such set of terms might be to require that the\\n * account initiating a transaction have a certain minimum MRV token balance.\\n *\\n * The owner of this contract reserves the right to supersede it with a new\\n * version, and to modify the terms for accessing this contract, at any time,\\n * for any reason, and without notice. This includes the right to indefinitely\\n * or permanently suspend or terminate access to this contract for any person,\\n * account, or other contract, or for all persons, accounts, or other\\n * contracts. The owner also reserves the right to not do any of the above.\\n */\\ncontract MacroverseStarGenerator is ControlledAccess {\\n    // TODO: RNG doesn\\u0027t get linked against because we can\\u0027t pass the struct to the library...\\n    using RNG for *;\\n    using RealMath for *;\\n    // No SafeMath or it might confuse RealMath\\n\\n    // How big is a sector on a side in LY?\\n    int16 constant SECTOR_SIZE = 25;\\n    // How far out dowes the sector system extend?\\n    int16 constant MAX_SECTOR = 10000;\\n    // How big is the galaxy?\\n    int16 constant DISK_RADIUS_IN_SECTORS = 6800;\\n    // How thick is its disk?\\n    int16 constant DISK_HALFHEIGHT_IN_SECTORS = 40;\\n    // How big is the central sphere?\\n    int16 constant CORE_RADIUS_IN_SECTORS = 1000;\\n    \\n    // There are kinds of stars.\\n    // We can add more later; these are from http://www.mit.edu/afs.new/sipb/user/sekullbe/furble/planet.txt\\n    //                 0           1      2             3           4            5\\n    enum ObjectClass { Supergiant, Giant, MainSequence, WhiteDwarf, NeutronStar, BlackHole }\\n    // Actual stars have a spectral type\\n    //                  0      1      2      3      4      5      6      7\\n    enum SpectralType { TypeO, TypeB, TypeA, TypeF, TypeG, TypeK, TypeM, NotApplicable }\\n    // Each type has subtypes 0-9, except O which only has 5-9\\n    \\n    // This root RandNode provides the seed for the universe.\\n    RNG.RandNode root;\\n    \\n    /**\\n     * Deploy a new copy of the Macroverse prototype contract. Use the given seed to generate a galaxy, down to the star level.\\n     * Use the contract at the given address to regulate access.\\n     */\\n    function MacroverseStarGenerator(bytes32 baseSeed, address accessControlAddress) ControlledAccess(AccessControl(accessControlAddress)) {\\n        root = RNG.RandNode(baseSeed);\\n    }\\n    \\n    /**\\n     * Get the density (between 0 and 1 as a fixed-point real88x40) of stars in the given sector. Sector 0,0,0 is centered on the galactic origin.\\n     * +Y is upwards.\\n     */\\n    function getGalaxyDensity(int16 sectorX, int16 sectorY, int16 sectorZ) constant onlyControlledAccess returns (int128 realDensity) {\\n        // For the prototype, we have a central sphere and a surrounding disk.\\n        \\n        // Enforce absolute bounds.\\n        if (sectorX \\u003e MAX_SECTOR) return 0;\\n        if (sectorY \\u003e MAX_SECTOR) return 0;\\n        if (sectorZ \\u003e MAX_SECTOR) return 0;\\n        if (sectorX \\u003c -MAX_SECTOR) return 0;\\n        if (sectorY \\u003c -MAX_SECTOR) return 0;\\n        if (sectorZ \\u003c -MAX_SECTOR) return 0;\\n        \\n        if (int(sectorX) * int(sectorX) + int(sectorY) * int(sectorY) + int(sectorZ) * int(sectorZ) \\u003c int(CORE_RADIUS_IN_SECTORS) * int(CORE_RADIUS_IN_SECTORS)) {\\n            // Central sphere\\n            return RealMath.fraction(9, 10);\\n        } else if (int(sectorX) * int(sectorX) + int(sectorZ) * int(sectorZ) \\u003c int(DISK_RADIUS_IN_SECTORS) * int(DISK_RADIUS_IN_SECTORS) \\u0026\\u0026 sectorY \\u003c DISK_HALFHEIGHT_IN_SECTORS \\u0026\\u0026 sectorY \\u003e -DISK_HALFHEIGHT_IN_SECTORS) {\\n            // Disk\\n            return RealMath.fraction(1, 2);\\n        } else {\\n            // General background object rate\\n            // Set so that some background sectors do indeed have an object in them.\\n            return RealMath.fraction(1, 60);\\n        }\\n    }\\n    \\n    /**\\n     * Get the number of objects in the sector at the given coordinates.\\n     */\\n    function getSectorObjectCount(int16 sectorX, int16 sectorY, int16 sectorZ) constant onlyControlledAccess returns (uint16) {\\n        // Decide on a base item count\\n        var sectorNode = root.derive(sectorX).derive(sectorY).derive(sectorZ);\\n        var maxObjects = sectorNode.derive(\\\"count\\\").d(3, 20, 0);\\n        \\n        // Multiply by the density function\\n        var presentObjects = RealMath.toReal(maxObjects).mul(getGalaxyDensity(sectorX, sectorY, sectorZ));\\n        \\n        return uint16(RealMath.fromReal(RealMath.round(presentObjects)));\\n    }\\n    \\n    /**\\n     * Get the seed for an object in a sector.\\n     */\\n    function getSectorObjectSeed(int16 sectorX, int16 sectorY, int16 sectorZ, uint16 object) constant onlyControlledAccess returns (bytes32) {\\n        return root.derive(sectorX).derive(sectorY).derive(sectorZ).derive(uint(object))._hash;\\n    }\\n    \\n    /**\\n     * Get the class of the star system with the given seed.\\n     */\\n    function getObjectClass(bytes32 seed) constant onlyControlledAccess returns (ObjectClass) {\\n        // Make a node for rolling for the class.\\n        var node = RNG.RandNode(seed).derive(\\\"class\\\");\\n        // Roll an impractical d10,000\\n        var roll = node.getIntBetween(1, 10000);\\n        \\n        if (roll == 1) {\\n            // Should be a black hole\\n            return ObjectClass.BlackHole;\\n        } else if (roll \\u003c= 3) {\\n            // Should be a neutron star\\n            return ObjectClass.NeutronStar;\\n        } else if (roll \\u003c= 700) {\\n            // Should be a white dwarf\\n            return ObjectClass.WhiteDwarf;\\n        } else if (roll \\u003c= 9900) {\\n            // Most things are main sequence\\n            return ObjectClass.MainSequence;\\n        } else if (roll \\u003c= 9990) {\\n            return ObjectClass.Giant;\\n        } else {\\n            return ObjectClass.Supergiant;\\n        }\\n    }\\n    \\n    /**\\n     * Get the spectral type for an object with the given seed of the given class.\\n     */\\n    function getObjectSpectralType(bytes32 seed, ObjectClass objectClass) constant onlyControlledAccess returns (SpectralType) {\\n        var node = RNG.RandNode(seed).derive(\\\"type\\\");\\n        var roll = node.getIntBetween(1, 10000000); // Even more implausible dice\\n\\n        if (objectClass == ObjectClass.MainSequence) {\\n            if (roll \\u003c= 3) {\\n                return SpectralType.TypeO;\\n            } else if (roll \\u003c= 13003) {\\n                return SpectralType.TypeB;\\n            } else if (roll \\u003c= 73003) {\\n                return SpectralType.TypeA;\\n            } else if (roll \\u003c= 373003) {\\n                return SpectralType.TypeF;\\n            } else if (roll \\u003c= 1133003) {\\n                return SpectralType.TypeG;\\n            } else if (roll \\u003c= 2343003) {\\n                return SpectralType.TypeK;\\n            } else {\\n                return SpectralType.TypeM;\\n            }\\n        } else if (objectClass == ObjectClass.Giant) {\\n            if (roll \\u003c= 500000) {\\n                return SpectralType.TypeF;\\n            } else if (roll \\u003c= 1000000) {\\n                return SpectralType.TypeG;\\n            } else if (roll \\u003c= 5500000) {\\n                return SpectralType.TypeK;\\n            } else {\\n                return SpectralType.TypeM;\\n            }\\n        } else if (objectClass == ObjectClass.Supergiant) {\\n            if (roll \\u003c= 1000000) {\\n                return SpectralType.TypeB;\\n            } else if (roll \\u003c= 2000000) {\\n                return SpectralType.TypeA;\\n            } else if (roll \\u003c= 4000000) {\\n                return SpectralType.TypeF;\\n            } else if (roll \\u003c= 6000000) {\\n                return SpectralType.TypeG;\\n            } else if (roll \\u003c= 8000000) {\\n                return SpectralType.TypeK;\\n            } else {\\n                return SpectralType.TypeM;\\n            }\\n        } else {\\n            // TODO: No spectral class for anyone else.\\n            return SpectralType.NotApplicable;\\n        }\\n        \\n    }\\n    \\n    /**\\n     * Get the position of a star within its sector, as reals from 0 to 25.\\n     * Note that stars may end up implausibly close together. Such is life in the Macroverse.\\n     */\\n    function getObjectPosition(bytes32 seed) constant onlyControlledAccess returns (int128 realX, int128 realY, int128 realZ) {\\n        var node = RNG.RandNode(seed).derive(\\\"position\\\");\\n        \\n        realX = node.derive(\\\"x\\\").getRealBetween(RealMath.toReal(0), RealMath.toReal(25));\\n        realY = node.derive(\\\"y\\\").getRealBetween(RealMath.toReal(0), RealMath.toReal(25));\\n        realZ = node.derive(\\\"z\\\").getRealBetween(RealMath.toReal(0), RealMath.toReal(25));\\n    }\\n    \\n    /**\\n     * Get the mass of a star, in solar masses as a real, given its seed and class and spectral type.\\n     */\\n    function getObjectMass(bytes32 seed, ObjectClass objectClass, SpectralType spectralType) constant onlyControlledAccess returns (int128) {\\n        var node = RNG.RandNode(seed).derive(\\\"mass\\\");\\n         \\n        if (objectClass == ObjectClass.BlackHole) {\\n            return node.getRealBetween(RealMath.toReal(5), RealMath.toReal(50));\\n        } else if (objectClass == ObjectClass.NeutronStar) {\\n            return node.getRealBetween(RealMath.fraction(11, 10), RealMath.toReal(2));\\n        } else if (objectClass == ObjectClass.WhiteDwarf) {\\n            return node.getRealBetween(RealMath.fraction(3, 10), RealMath.fraction(11, 10));\\n        } else if (objectClass == ObjectClass.MainSequence) {\\n            if (spectralType == SpectralType.TypeO) {\\n                return node.getRealBetween(RealMath.toReal(16), RealMath.toReal(40));\\n            } else if (spectralType == SpectralType.TypeB) {\\n                return node.getRealBetween(RealMath.fraction(21, 10), RealMath.toReal(16));\\n            } else if (spectralType == SpectralType.TypeA) {\\n                return node.getRealBetween(RealMath.fraction(14, 10), RealMath.fraction(21, 10));\\n            } else if (spectralType == SpectralType.TypeF) {\\n                return node.getRealBetween(RealMath.fraction(104, 100), RealMath.fraction(14, 10));\\n            } else if (spectralType == SpectralType.TypeG) {\\n                return node.getRealBetween(RealMath.fraction(80, 100), RealMath.fraction(104, 100));\\n            } else if (spectralType == SpectralType.TypeK) {\\n                return node.getRealBetween(RealMath.fraction(45, 100), RealMath.fraction(80, 100));\\n            } else if (spectralType == SpectralType.TypeM) {\\n                return node.getRealBetween(RealMath.fraction(8, 100), RealMath.fraction(45, 100));\\n            }\\n        } else if (objectClass == ObjectClass.Giant) {\\n            // Just make it really big\\n            return node.getRealBetween(RealMath.toReal(40), RealMath.toReal(50));\\n        } else if (objectClass == ObjectClass.Supergiant) {\\n            // Just make it really, really big\\n            return node.getRealBetween(RealMath.toReal(50), RealMath.toReal(70));\\n        }\\n    }\\n    \\n    /**\\n     * Determine if the given star has any orbiting planets or not.\\n     */\\n    function getObjectHasPlanets(bytes32 seed, ObjectClass objectClass, SpectralType spectralType) constant onlyControlledAccess returns (bool) {\\n        var node = RNG.RandNode(seed).derive(\\\"hasplanets\\\");\\n        var roll = node.getIntBetween(1, 1000);\\n\\n        if (objectClass == ObjectClass.MainSequence) {\\n            if (spectralType == SpectralType.TypeO || spectralType == SpectralType.TypeB) {\\n                return (roll \\u003c= 1);\\n            } else if (spectralType == SpectralType.TypeA) {\\n                return (roll \\u003c= 500);\\n            } else if (spectralType == SpectralType.TypeF || spectralType == SpectralType.TypeG || spectralType == SpectralType.TypeK) {\\n                return (roll \\u003c= 990);\\n            } else if (spectralType == SpectralType.TypeM) {\\n                return (roll \\u003c= 634);\\n            }\\n        } else if (objectClass == ObjectClass.Giant) {\\n            return (roll \\u003c= 90);\\n        } else if (objectClass == ObjectClass.Supergiant) {\\n            return (roll \\u003c= 50);\\n        } else {\\n           // Black hole, neutron star, or white dwarf\\n           return (roll \\u003c= 70);\\n        }\\n    }\\n    \\n\\n}\\n \"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.4.11;\\n\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control \\n * functions, this simplifies the implementation of \\\"user permissions\\\". \\n */\\ncontract Ownable {\\n  address public owner;\\n\\n\\n  /** \\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n   * account.\\n   */\\n  function Ownable() {\\n    owner = msg.sender;\\n  }\\n\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner. \\n   */\\n  modifier onlyOwner() {\\n    if (msg.sender != owner) {\\n      throw;\\n    }\\n    _;\\n  }\\n\\n\\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param newOwner The address to transfer ownership to. \\n   */\\n  function transferOwnership(address newOwner) onlyOwner {\\n    if (newOwner != address(0)) {\\n      owner = newOwner;\\n    }\\n  }\\n\\n}\\n\"},\"RealMath.sol\":{\"content\":\"pragma solidity ^0.4.11;\\n\\n/**\\n * RealMath: fixed-point math library, based on fractional and integer parts.\\n * Using int128 as real88x40, which isn\\u0027t in Solidity yet.\\n * 40 fractional bits gest us down to 1E-12 precision, while still letting us\\n * go up to galaxy scale counting in meters.\\n * Internally uses the wider int256 for some math.\\n */\\n\\nlibrary RealMath {\\n    \\n    /**\\n     * How many total bits are there?\\n     */\\n    int256 constant REAL_BITS = 128;\\n    \\n    /**\\n     * How many fractional bits are there?\\n     */\\n    int256 constant REAL_FBITS = 40;\\n    \\n    /**\\n     * How many integer bits are there?\\n     */\\n    int256 constant REAL_IBITS = REAL_BITS - REAL_FBITS;\\n    \\n    /**\\n     * What\\u0027s the first non-fractional bit\\n     */\\n    int128 constant REAL_ONE = int128(1) \\u003c\\u003c REAL_FBITS;\\n    \\n    /**\\n     * What\\u0027s the last fractional bit?\\n     */\\n    int128 constant REAL_HALF = REAL_ONE \\u003e\\u003e 1;\\n    \\n    /**\\n     * What\\u0027s the sign bit?\\n     */\\n    int128 constant SIGN_MASK = int128(1) \\u003c\\u003c 127;\\n    \\n\\n    /**\\n     * Convert an integer to a real. Preserves sign.\\n     */\\n    function toReal(int88 ipart) constant returns (int128) {\\n        return int128(ipart) * REAL_ONE;\\n    }\\n    \\n    /**\\n     * Convert a real to an integer. Preserves sign.\\n     */\\n    function fromReal(int128 real_value) constant returns (int88) {\\n        return int88(real_value / REAL_ONE);\\n    }\\n    \\n    /**\\n     * Round a real to the nearest integral real value.\\n     */\\n    function round(int128 real_value) constant returns (int128) {\\n        // First, truncate.\\n        int88 ipart = fromReal(real_value);\\n        if ((fractionalBits(real_value) \\u0026 (uint40(1) \\u003c\\u003c (REAL_FBITS - 1))) \\u003e 0) {\\n            // High fractional bit is set. Round up.\\n            if (real_value \\u003c int128(0)) {\\n                // Rounding up for a negative number is rounding down.\\n                ipart -= 1;\\n            } else {\\n                ipart += 1;\\n            }\\n        }\\n        return toReal(ipart);\\n    }\\n    \\n    /**\\n     * Get the absolute value of a real. Just the same as abs on a normal int128.\\n     */\\n    function abs(int128 real_value) constant returns (int128) {\\n        if (real_value \\u003e 0) {\\n            return real_value;\\n        } else {\\n            return -real_value;\\n        }\\n    }\\n    \\n    /**\\n     * Returns the fractional bits of a real. Ignores the sign of the real.\\n     */\\n    function fractionalBits(int128 real_value) constant returns (uint40) {\\n        return uint40(abs(real_value) % REAL_ONE);\\n    }\\n    \\n    /**\\n     * Get the fractional part of a real, as a real. Ignores sign (so fpart(-0.5) is 0.5).\\n     */\\n    function fpart(int128 real_value) constant returns (int128) {\\n        return abs(real_value) % REAL_ONE;\\n    }\\n    \\n    /**\\n     * Multiply one real by another. Truncates overflows.\\n     */\\n    function mul(int128 real_a, int128 real_b) constant returns (int128) {\\n        // When multiplying fixed point in x.y and z.w formats we get (x+z).(y+w) format.\\n        // So we just have to clip off the extra REAL_FBITS fractional bits.\\n        return int128((int256(real_a) * int256(real_b)) \\u003e\\u003e REAL_FBITS);\\n    }\\n    \\n    /**\\n     * Divide one real by another real. Truncates overflows.\\n     */\\n    function div(int128 real_numerator, int128 real_denominator) constant returns (int128) {\\n        // We use the reverse of the multiplication trick: convert numerator from\\n        // x.y to (x+z).(y+w) fixed point, then divide by denom in z.w fixed point.\\n        return int128((int256(real_numerator) * REAL_ONE) / int256(real_denominator));\\n    }\\n    \\n    /**\\n     * Create a real from a rational fraction.\\n     */\\n    function fraction(int88 numerator, int88 denominator) constant returns (int128) {\\n        return div(toReal(numerator), toReal(denominator));\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"},\"RNG.sol\":{\"content\":\"pragma solidity ^0.4.11;\\n\\nimport \\\"./RealMath.sol\\\";\\n\\nlibrary RNG {\\n    using RealMath for *;\\n\\n    /**\\n     * We are going to define a RandNode struct to allow for hash chaining.\\n     * You can extend a RandNode with a bunch of different stuff and get a new RandNode.\\n     * You can then use a RandNode to get a single, repeatable random value.\\n     * This eliminates the need for concatenating string selfs, which is a huge pain in Solidity.\\n     */\\n    struct RandNode {\\n        // We hash this together with whatever we\\u0027re mixing in to get the child hash.\\n        bytes32 _hash;\\n    }\\n    \\n    // All the functions that touch RandNodes need to be internal.\\n    // If you want to pass them in and out of contracts just use the bytes32.\\n    \\n    // You can get all these functions as methods on RandNodes by \\\"using RNG for *\\\" in your library/contract.\\n    \\n    /**\\n     * Mix string data into a RandNode. Returns a new RandNode.\\n     */\\n    function derive(RandNode self, string entropy) internal constant returns (RandNode) {\\n        // Hash what\\u0027s there now with the new stuff.\\n        return RandNode(sha256(self._hash, entropy));\\n    }\\n    \\n    /**\\n     * Mix signed int data into a RandNode. Returns a new RandNode.\\n     */\\n    function derive(RandNode self, int256 entropy) internal constant returns (RandNode) {\\n        return RandNode(sha256(self._hash, entropy));\\n    }\\n    \\n     /**\\n     * Mix unsigned int data into a RandNode. Returns a new RandNode.\\n     */\\n    function derive(RandNode self, uint256 entropy) internal constant returns (RandNode) {\\n        return RandNode(sha256(self._hash, entropy));\\n    }\\n\\n    /**\\n     * Returns the base RNG hash for the given RandNode.\\n     * Does another round of hashing in case you made a RandNode(\\\"Stuff\\\").\\n     */\\n    function getHash(RandNode self) internal constant returns (bytes32) {\\n        return sha256(self._hash);\\n    }\\n    \\n    /**\\n     * Return true or false with 50% probability.\\n     */\\n    function getBool(RandNode self) internal constant returns (bool) {\\n        return getHash(self) \\u0026 0x1 \\u003e 0;\\n    }\\n    \\n    /**\\n     * Get an int128 full of random bits.\\n     */\\n    function getInt128(RandNode self) internal constant returns (int128) {\\n        // Just cast to int and truncate\\n        return int128(int256(getHash(self)));\\n    }\\n    \\n    /**\\n     * Get a real88x40 between 0 (inclusive) and 1 (exclusive).\\n     */\\n    function getReal(RandNode self) internal constant returns (int128) {\\n        return getInt128(self).fpart();\\n    }\\n    \\n    /**\\n     * Get an integer between low, inclusive, and high, exclusive. Represented as a normal int, not a real.\\n     */\\n    function getIntBetween(RandNode self, int88 low, int88 high) internal constant returns (int88) {\\n        return RealMath.fromReal((getReal(self).mul(RealMath.toReal(high) - RealMath.toReal(low))) + RealMath.toReal(low));\\n    }\\n    \\n    /**\\n     * Get a real between realLow (inclusive) and realHigh (exclusive).\\n     * Only actually has the bits of entropy from getReal, so some values will not occur.\\n     */\\n    function getRealBetween(RandNode self, int128 realLow, int128 realHigh) internal constant returns (int128) {\\n        return getReal(self).mul(realHigh - realLow) + realLow;\\n    }\\n    \\n    /**\\n     * Roll a number of die of the given size, add/subtract a bonus, and return the result.\\n     * Max size is 100.\\n     */\\n    function d(RandNode self, int8 count, int8 size, int8 bonus) internal constant returns (int16) {\\n        if (count == 1) {\\n            // Base case\\n            return int16(getIntBetween(self, 1, size)) + bonus;\\n        } else {\\n            // Loop and sum\\n            int16 sum = bonus;\\n            for(int8 i = 0; i \\u003c count; i++) {\\n                // Roll each die with no bonus\\n                sum += d(derive(self, i), 1, size, 0);\\n            }\\n            return sum;\\n        }\\n    }\\n}\\n\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"seed\",\"type\":\"bytes32\"}],\"name\":\"getObjectClass\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"seed\",\"type\":\"bytes32\"},{\"name\":\"objectClass\",\"type\":\"uint8\"},{\"name\":\"spectralType\",\"type\":\"uint8\"}],\"name\":\"getObjectMass\",\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"seed\",\"type\":\"bytes32\"},{\"name\":\"objectClass\",\"type\":\"uint8\"}],\"name\":\"getObjectSpectralType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sectorX\",\"type\":\"int16\"},{\"name\":\"sectorY\",\"type\":\"int16\"},{\"name\":\"sectorZ\",\"type\":\"int16\"}],\"name\":\"getSectorObjectCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"seed\",\"type\":\"bytes32\"},{\"name\":\"objectClass\",\"type\":\"uint8\"},{\"name\":\"spectralType\",\"type\":\"uint8\"}],\"name\":\"getObjectHasPlanets\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sectorX\",\"type\":\"int16\"},{\"name\":\"sectorY\",\"type\":\"int16\"},{\"name\":\"sectorZ\",\"type\":\"int16\"}],\"name\":\"getGalaxyDensity\",\"outputs\":[{\"name\":\"realDensity\",\"type\":\"int128\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAccessControl\",\"type\":\"address\"}],\"name\":\"changeAccessControl\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"seed\",\"type\":\"bytes32\"}],\"name\":\"getObjectPosition\",\"outputs\":[{\"name\":\"realX\",\"type\":\"int128\"},{\"name\":\"realY\",\"type\":\"int128\"},{\"name\":\"realZ\",\"type\":\"int128\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sectorX\",\"type\":\"int16\"},{\"name\":\"sectorY\",\"type\":\"int16\"},{\"name\":\"sectorZ\",\"type\":\"int16\"},{\"name\":\"object\",\"type\":\"uint16\"}],\"name\":\"getSectorObjectSeed\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"baseSeed\",\"type\":\"bytes32\"},{\"name\":\"accessControlAddress\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"}]","ContractName":"MacroverseStarGenerator","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"46696174426c6f636b730000000000000000000000000000000000000000000000000000000000000000000074e43a8b712fef9f3387bfc2f7c5017b51fd8813","EVMVersion":"Default","Library":"RealMath:3c018100533af417f286331e0ba3b65a288fa848","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://fff0b9e71322f6e2f1749ba48bdcda6a7c3c4a7d5df006b79d1decf4fc6cd23a"}]}
