{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n/*\r\n\r\nP2PFuturesTrading\r\n\r\nTrustless trading of not already transferable tokens between two people\r\nAuthor: thestral.eth\r\n\r\n*/\r\n\r\n// ERC20 Interface: ethereum/EIPs#20\r\ncontract ERC20 {\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n}\r\n\r\ncontract P2PFuturesTrading {\r\n\r\n\tstruct Trade{\r\n\t\taddress tokenAddress;\r\n\t\tuint tokenAmount;\r\n\t\tuint etherAmount;\r\n\t\tuint etherCollateralAmount;\r\n\t\tuint endTradeBlock;\r\n\t\tbool initialized;\r\n\t\tbool finalized;\r\n\t}\r\n\r\n\r\n\t// Store the open trades\r\n\tmapping (address => mapping(address => Trade)) public trades;\r\n\r\n\t// The developer address.\r\n\taddress developerAddress = 0x335854eF79Fff47F9050ca853c7f3bA53eeEEE93;\r\n\r\n\r\n\r\n\tfunction startTrade(address tokenSellerAddress, address tokenAddress, uint tokenAmount, uint etherCollateralAmount, uint endTradeBlock) payable{\r\n\t\t//Variable validation. The endTradeBlock can't be smaller than the current one plus 220 (around 1 hour)\r\n\t\tif(msg.value == 0 || tokenAmount == 0 || endTradeBlock <= block.number + 220){\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\t\r\n\t\tTrade t1 = trades[msg.sender][tokenSellerAddress];\r\n\t\tTrade t2 = trades[tokenSellerAddress][msg.sender];\r\n\t\t\r\n\t\t//You can't have more than one trade at a time between the same two people. To close a non finalized trade and have you ether back, you need to call the function cancelTrade\r\n\t\tif(t1.initialized || t2.initialized){\r\n\t\t\tthrow;\r\n\t\t}\r\n\r\n\t\ttrades[msg.sender][tokenSellerAddress] = Trade(tokenAddress, tokenAmount, msg.value, etherCollateralAmount, endTradeBlock, true, false);\r\n\t}\r\n\r\n\r\n\r\n\tfunction finalizeTrade(address tokenBuyerAddress, uint etherAmount, address tokenAddress, uint tokenAmount, uint endTradeBlock) payable{\r\n\t\tTrade t = trades[tokenBuyerAddress][msg.sender];\r\n\t\t\r\n\t\t//It needs to exist already a trade between the two people and it hasn't have to be already finalized\r\n\t\tif(!t.initialized || t.finalized){\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\t\r\n\t\t//The trade condition specified by the two people must concide\r\n\t\tif(!(t.tokenAddress == tokenAddress && t.tokenAmount == tokenAmount && t.etherAmount == etherAmount && t.etherCollateralAmount == msg.value && t.endTradeBlock == endTradeBlock)){\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\t\r\n\t\tt.finalized = true;\r\n\t}\r\n\r\n\t \r\n\tfunction completeTrade(address otherPersonAddress){\r\n\t    Trade t;\r\n\t\taddress tokenBuyerAddress;\r\n\t\taddress tokenSellerAddress;\r\n\t\t\r\n\t\tTrade tokenBuyerTrade = trades[msg.sender][otherPersonAddress];\r\n\t\tTrade tokenSellerTrade = trades[otherPersonAddress][msg.sender];\r\n\t\t\r\n\t\t//It needs to exist already a trade between the two people and it has to be already finalized.\r\n\t\tif(tokenBuyerTrade.initialized && tokenBuyerTrade.finalized){\r\n\t\t\tt = tokenBuyerTrade;\r\n\t\t\ttokenBuyerAddress = msg.sender;\r\n\t\t\ttokenSellerAddress = otherPersonAddress;\r\n\t\t}\r\n\t\telse if(tokenSellerTrade.initialized && tokenSellerTrade.finalized){\r\n\t\t\tt = tokenSellerTrade;\r\n\t\t\ttokenBuyerAddress = otherPersonAddress;\r\n\t\t\ttokenSellerAddress = msg.sender;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\tERC20 token = ERC20(t.tokenAddress);\r\n\t\t\r\n\t\t//1% developer fee, 0.5% from the tokenSeller (in tokens) and 0.5% from the tokenBuyer (in ethers). In case the trade doesn't complete the fee is of 1% of the collateral.\r\n\t\tuint tokenSellerFee = t.tokenAmount * 5 / 1000;\r\n\t\tuint tokenBuyerFee = t.etherAmount * 5 / 1000;\r\n\t\tuint collateralFee = t.etherCollateralAmount / 100;\r\n\t\t\r\n\t\tt.initialized = false;\r\n\t\tt.finalized = false;\r\n\t\t\r\n\t\t//If the tokenSeller didn't allow this contract of the needed amount, one of the two following functions will return false\r\n\t\tif(!token.transferFrom(tokenSellerAddress, tokenBuyerAddress, t.tokenAmount - tokenSellerFee) || !token.transferFrom(tokenSellerAddress, developerAddress, tokenSellerFee)){\r\n\t\t\t//If the maximum time has passed, and the trade coudldn't be completed, the tokenBuyer will receive his ether plus the collateral. Otherwise no action is taken.\r\n\t\t\tif(t.endTradeBlock < block.number){\r\n\t\t\t\ttokenBuyerAddress.transfer(t.etherAmount + t.etherCollateralAmount - collateralFee);\r\n\t\t\t\tdeveloperAddress.transfer(collateralFee);\r\n\t\t\t\t\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tthrow;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t//Transfer to the tokenSeller the etherAmount plus his collateral\r\n\t\ttokenSellerAddress.transfer(t.etherAmount + t.etherCollateralAmount - tokenBuyerFee);\r\n\t\tdeveloperAddress.transfer(tokenBuyerFee);\r\n    }\r\n    \r\n    \r\n\tfunction cancelTrade(address tokenSellerAddress){\r\n\t\tTrade t = trades[msg.sender][tokenSellerAddress];\r\n\t\t\r\n\t\t//It needs to exist already a trade between the two people and it hasn't have to be already finalized\r\n\t\tif(!t.initialized || t.finalized){\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\t\r\n\t\t//Cancel the trade and give the sender his ether back\t\r\n\t\tt.initialized = false;\r\n\t\t\r\n\t\tmsg.sender.transfer(t.etherAmount);\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"tokenBuyerAddress\",\"type\":\"address\"},{\"name\":\"etherAmount\",\"type\":\"uint256\"},{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"endTradeBlock\",\"type\":\"uint256\"}],\"name\":\"finalizeTrade\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"trades\",\"outputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"etherAmount\",\"type\":\"uint256\"},{\"name\":\"etherCollateralAmount\",\"type\":\"uint256\"},{\"name\":\"endTradeBlock\",\"type\":\"uint256\"},{\"name\":\"initialized\",\"type\":\"bool\"},{\"name\":\"finalized\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"otherPersonAddress\",\"type\":\"address\"}],\"name\":\"completeTrade\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenSellerAddress\",\"type\":\"address\"},{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"etherCollateralAmount\",\"type\":\"uint256\"},{\"name\":\"endTradeBlock\",\"type\":\"uint256\"}],\"name\":\"startTrade\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenSellerAddress\",\"type\":\"address\"}],\"name\":\"cancelTrade\",\"outputs\":[],\"payable\":false,\"type\":\"function\"}]","ContractName":"P2PFuturesTrading","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4adfd775126eedf607795285c76834a4cfe5979cd5b0dbc016869b35949b8b03"}]}