{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\n// accepted from zeppelin-solidity https://github.com/OpenZeppelin/zeppelin-solidity\r\n/*\r\n * ERC20 interface\r\n * see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n// accepted from zeppelin-solidity https://github.com/OpenZeppelin/zeppelin-solidity\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\r\n/// @author Stefan George - <stefan.george@consensys.net>\r\ncontract MultiSigWallet {\r\n\r\n    // flag to determine if address is for a real contract or not\r\n    bool public isMultiSigWallet = false;\r\n\r\n    uint constant public MAX_OWNER_COUNT = 50;\r\n\r\n    event Confirmation(address indexed sender, uint indexed transactionId);\r\n    event Revocation(address indexed sender, uint indexed transactionId);\r\n    event Submission(uint indexed transactionId);\r\n    event Execution(uint indexed transactionId);\r\n    event ExecutionFailure(uint indexed transactionId);\r\n    event Deposit(address indexed sender, uint value);\r\n    event OwnerAddition(address indexed owner);\r\n    event OwnerRemoval(address indexed owner);\r\n    event RequirementChange(uint required);\r\n\r\n    mapping (uint => Transaction) public transactions;\r\n    mapping (uint => mapping (address => bool)) public confirmations;\r\n    mapping (address => bool) public isOwner;\r\n    address[] public owners;\r\n    uint public required;\r\n    uint public transactionCount;\r\n\r\n    struct Transaction {\r\n        address destination;\r\n        uint value;\r\n        bytes data;\r\n        bool executed;\r\n    }\r\n\r\n    modifier onlyWallet() {\r\n        if (msg.sender != address(this)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier ownerDoesNotExist(address owner) {\r\n        if (isOwner[owner]) throw;\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address owner) {\r\n        if (!isOwner[owner]) throw;\r\n        _;\r\n    }\r\n\r\n    modifier transactionExists(uint transactionId) {\r\n        if (transactions[transactionId].destination == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier confirmed(uint transactionId, address owner) {\r\n        if (!confirmations[transactionId][owner]) throw;\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmed(uint transactionId, address owner) {\r\n        if (confirmations[transactionId][owner]) throw;\r\n        _;\r\n    }\r\n\r\n    modifier notExecuted(uint transactionId) {\r\n        if (transactions[transactionId].executed) throw;\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address _address) {\r\n        if (_address == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier validRequirement(uint ownerCount, uint _required) {\r\n        if (ownerCount > MAX_OWNER_COUNT) throw;\r\n        if (_required > ownerCount) throw;\r\n        if (_required == 0) throw;\r\n        if (ownerCount == 0) throw;\r\n        _;\r\n    }\r\n\r\n    /// @dev Fallback function allows to deposit ether.\r\n    function()\r\n        payable\r\n    {\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\r\n    /// @param _owners List of initial owners.\r\n    /// @param _required Number of required confirmations.\r\n    function MultiSigWallet(address[] _owners, uint _required)\r\n        public\r\n        validRequirement(_owners.length, _required)\r\n    {\r\n        for (uint i=0; i<_owners.length; i++) {\r\n            if (isOwner[_owners[i]] || _owners[i] == 0) throw;\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n        isMultiSigWallet = true;\r\n        owners = _owners;\r\n        required = _required;\r\n    }\r\n\r\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of new owner.\r\n    function addOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerDoesNotExist(owner)\r\n        notNull(owner)\r\n        validRequirement(owners.length + 1, required)\r\n    {\r\n        isOwner[owner] = true;\r\n        owners.push(owner);\r\n        OwnerAddition(owner);\r\n    }\r\n\r\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner.\r\n    function removeOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n    {\r\n        isOwner[owner] = false;\r\n        for (uint i=0; i<owners.length - 1; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }\r\n        owners.length -= 1;\r\n        if (required > owners.length)\r\n            changeRequirement(owners.length);\r\n        OwnerRemoval(owner);\r\n    }\r\n\r\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner to be replaced.\r\n    /// @param newOwner Address of new owner.\r\n    /// @param index the indx of the owner to be replaced\r\n    function replaceOwnerIndexed(address owner, address newOwner, uint index)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n        ownerDoesNotExist(newOwner)\r\n    {\r\n        if (owners[index] != owner) throw;\r\n        owners[index] = newOwner;\r\n        isOwner[owner] = false;\r\n        isOwner[newOwner] = true;\r\n        OwnerRemoval(owner);\r\n        OwnerAddition(newOwner);\r\n    }\r\n\r\n\r\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\r\n    /// @param _required Number of required confirmations.\r\n    function changeRequirement(uint _required)\r\n        public\r\n        onlyWallet\r\n        validRequirement(owners.length, _required)\r\n    {\r\n        required = _required;\r\n        RequirementChange(_required);\r\n    }\r\n\r\n    /// @dev Allows an owner to submit and confirm a transaction.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function submitTransaction(address destination, uint value, bytes data)\r\n        public\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = addTransaction(destination, value, data);\r\n        confirmTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to confirm a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function confirmTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        transactionExists(transactionId)\r\n        notConfirmed(transactionId, msg.sender)\r\n    {\r\n        confirmations[transactionId][msg.sender] = true;\r\n        Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function revokeConfirmation(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        confirmations[transactionId][msg.sender] = false;\r\n        Revocation(msg.sender, transactionId);\r\n    }\r\n\r\n    /// @dev Returns the confirmation status of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Confirmation status.\r\n    function isConfirmed(uint transactionId)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        uint count = 0;\r\n        for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Internal functions\r\n     */\r\n\r\n    /// @dev Allows anyone to execute a confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function executeTransaction(uint transactionId)\r\n       internal\r\n       notExecuted(transactionId)\r\n    {\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction tx = transactions[transactionId];\r\n            tx.executed = true;\r\n            if (tx.destination.call.value(tx.value)(tx.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                tx.executed = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function addTransaction(address destination, uint value, bytes data)\r\n        internal\r\n        notNull(destination)\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = transactionCount;\r\n        transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        });\r\n        transactionCount += 1;\r\n        Submission(transactionId);\r\n    }\r\n\r\n    /*\r\n     * Web3 call functions\r\n     */\r\n    /// @dev Returns number of confirmations of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Number of confirmations.\r\n    function getConfirmationCount(uint transactionId)\r\n        public\r\n        constant\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns total number of transactions after filers are applied.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Total number of transactions after filters are applied.\r\n    function getTransactionCount(bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<transactionCount; i++)\r\n            if ((pending && !transactions[i].executed) ||\r\n                (executed && transactions[i].executed))\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns list of owners.\r\n    /// @return List of owner addresses.\r\n    function getOwners()\r\n        public\r\n        constant\r\n        returns (address[])\r\n    {\r\n        return owners;\r\n    }\r\n\r\n    /// @dev Returns array with owner addresses, which confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Returns array of owner addresses.\r\n    function getConfirmations(uint transactionId)\r\n        public\r\n        constant\r\n        returns (address[] _confirmations)\r\n    {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        _confirmations = new address[](count);\r\n        for (i=0; i<count; i++)\r\n            _confirmations[i] = confirmationsTemp[i];\r\n    }\r\n\r\n    /// @dev Returns list of transaction IDs in defined range.\r\n    /// @param from Index start position of transaction array.\r\n    /// @param to Index end position of transaction array.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Returns array of transaction IDs.\r\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint[] _transactionIds)\r\n    {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<transactionCount; i++)\r\n          if ((pending && !transactions[i].executed) ||\r\n              (executed && transactions[i].executed))\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        _transactionIds = new uint[](to - from);\r\n        for (i=from; i<to; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract NewToken is ERC20 {}\r\n\r\ncontract UpgradeAgent is SafeMath {\r\n  address public owner;\r\n  bool public isUpgradeAgent;\r\n  NewToken public newToken;\r\n  uint256 public originalSupply; // the original total supply of old tokens\r\n  bool public upgradeHasBegun;\r\n  function upgradeFrom(address _from, uint256 _value) public;\r\n}\r\n\r\n/// @title Time-locked vault of tokens allocated to Lunyr after 180 days\r\ncontract LUNVault is SafeMath {\r\n\r\n    // flag to determine if address is for a real contract or not\r\n    bool public isLUNVault = false;\r\n\r\n    LunyrToken lunyrToken;\r\n    address lunyrMultisig;\r\n    uint256 unlockedAtBlockNumber;\r\n    //uint256 public constant numBlocksLocked = 1110857;\r\n    // smaller lock for testing\r\n    uint256 public constant numBlocksLocked = 1110857;\r\n\r\n    /// @notice Constructor function sets the Lunyr Multisig address and\r\n    /// total number of locked tokens to transfer\r\n    function LUNVault(address _lunyrMultisig) internal {\r\n        if (_lunyrMultisig == 0x0) throw;\r\n        lunyrToken = LunyrToken(msg.sender);\r\n        lunyrMultisig = _lunyrMultisig;\r\n        isLUNVault = true;\r\n        unlockedAtBlockNumber = safeAdd(block.number, numBlocksLocked); // 180 days of blocks later\r\n    }\r\n\r\n    /// @notice Transfer locked tokens to Lunyr's multisig wallet\r\n    function unlock() external {\r\n        // Wait your turn!\r\n        if (block.number < unlockedAtBlockNumber) throw;\r\n        // Will fail if allocation (and therefore toTransfer) is 0.\r\n        if (!lunyrToken.transfer(lunyrMultisig, lunyrToken.balanceOf(this))) throw;\r\n    }\r\n\r\n    // disallow payment this is for LUN not ether\r\n    function () { throw; }\r\n\r\n}\r\n\r\n/// @title Lunyr crowdsale contract\r\ncontract LunyrToken is SafeMath, ERC20 {\r\n\r\n    // flag to determine if address is for a real contract or not\r\n    bool public isLunyrToken = false;\r\n\r\n    // State machine\r\n    enum State{PreFunding, Funding, Success, Failure}\r\n\r\n    // Token information\r\n    string public constant name = \"Lunyr Token\";\r\n    string public constant symbol = \"LUN\";\r\n    uint256 public constant decimals = 18;  // decimal places\r\n    uint256 public constant crowdfundPercentOfTotal = 78;\r\n    uint256 public constant vaultPercentOfTotal = 15;\r\n    uint256 public constant lunyrPercentOfTotal = 7;\r\n    uint256 public constant hundredPercent = 100;\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    // Upgrade information\r\n    address public upgradeMaster;\r\n    UpgradeAgent public upgradeAgent;\r\n    uint256 public totalUpgraded;\r\n\r\n    // Crowdsale information\r\n    bool public finalizedCrowdfunding = false;\r\n    uint256 public fundingStartBlock; // crowdsale start block\r\n    uint256 public fundingEndBlock; // crowdsale end block\r\n    uint256 public constant tokensPerEther = 44; // LUN:ETH exchange rate\r\n    uint256 public constant tokenCreationMax = safeMul(250000 ether, tokensPerEther);\r\n    uint256 public constant tokenCreationMin = safeMul(25000 ether, tokensPerEther);\r\n    // for testing on testnet\r\n    //uint256 public constant tokenCreationMax = safeMul(10 ether, tokensPerEther);\r\n    //uint256 public constant tokenCreationMin = safeMul(3 ether, tokensPerEther);\r\n\r\n    address public lunyrMultisig;\r\n    LUNVault public timeVault; // Lunyr's time-locked vault\r\n\r\n    event Upgrade(address indexed _from, address indexed _to, uint256 _value);\r\n    event Refund(address indexed _from, uint256 _value);\r\n    event UpgradeFinalized(address sender, address upgradeAgent);\r\n    event UpgradeAgentSet(address agent);\r\n\r\n    // For mainnet, startBlock = 3445888, endBlock = 3618688\r\n    function LunyrToken(address _lunyrMultisig,\r\n                        address _upgradeMaster,\r\n                        uint256 _fundingStartBlock,\r\n                        uint256 _fundingEndBlock) {\r\n\r\n        if (_lunyrMultisig == 0) throw;\r\n        if (_upgradeMaster == 0) throw;\r\n        if (_fundingStartBlock <= block.number) throw;\r\n        if (_fundingEndBlock   <= _fundingStartBlock) throw;\r\n        isLunyrToken = true;\r\n        upgradeMaster = _upgradeMaster;\r\n        fundingStartBlock = _fundingStartBlock;\r\n        fundingEndBlock = _fundingEndBlock;\r\n        timeVault = new LUNVault(_lunyrMultisig);\r\n        if (!timeVault.isLUNVault()) throw;\r\n        lunyrMultisig = _lunyrMultisig;\r\n        if (!MultiSigWallet(lunyrMultisig).isMultiSigWallet()) throw;\r\n    }\r\n\r\n    function balanceOf(address who) constant returns (uint) {\r\n        return balances[who];\r\n    }\r\n\r\n    /// @notice Transfer `value` LUN tokens from sender's account\r\n    /// `msg.sender` to provided account address `to`.\r\n    /// @notice This function is disabled during the funding.\r\n    /// @dev Required state: Success\r\n    /// @param to The address of the recipient\r\n    /// @param value The number of LUN to transfer\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address to, uint256 value) returns (bool ok) {\r\n        if (getState() != State.Success) throw; // Abort if crowdfunding was not a success.\r\n        if (to == 0x0) throw;\r\n        if (to == address(upgradeAgent)) throw;\r\n        //if (to == address(upgradeAgent.newToken())) throw;\r\n        uint256 senderBalance = balances[msg.sender];\r\n        if (senderBalance >= value && value > 0) {\r\n            senderBalance = safeSub(senderBalance, value);\r\n            balances[msg.sender] = senderBalance;\r\n            balances[to] = safeAdd(balances[to], value);\r\n            Transfer(msg.sender, to, value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @notice Transfer `value` LUN tokens from sender 'from'\r\n    /// to provided account address `to`.\r\n    /// @notice This function is disabled during the funding.\r\n    /// @dev Required state: Success\r\n    /// @param from The address of the sender\r\n    /// @param to The address of the recipient\r\n    /// @param value The number of LUN to transfer\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address from, address to, uint value) returns (bool ok) {\r\n        if (getState() != State.Success) throw; // Abort if not in Success state.\r\n        if (to == 0x0) throw;\r\n        if (to == address(upgradeAgent)) throw;\r\n        //if (to == address(upgradeAgent.newToken())) throw;\r\n        if (balances[from] >= value &&\r\n            allowed[from][msg.sender] >= value)\r\n        {\r\n            balances[to] = safeAdd(balances[to], value);\r\n            balances[from] = safeSub(balances[from], value);\r\n            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], value);\r\n            Transfer(from, to, value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `spender` to spend `value` tokens\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @param value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address spender, uint256 value) returns (bool ok) {\r\n        if (getState() != State.Success) throw; // Abort if not in Success state.\r\n        allowed[msg.sender][spender] = value;\r\n        Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /// @param owner The address of the account owning tokens\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address owner, address spender) constant returns (uint) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    // Token upgrade functionality\r\n\r\n    /// @notice Upgrade tokens to the new token contract.\r\n    /// @dev Required state: Success\r\n    /// @param value The number of tokens to upgrade\r\n    function upgrade(uint256 value) external {\r\n        if (getState() != State.Success) throw; // Abort if not in Success state.\r\n        if (upgradeAgent.owner() == 0x0) throw; // need a real upgradeAgent address\r\n\r\n        // Validate input value.\r\n        if (value == 0) throw;\r\n        if (value > balances[msg.sender]) throw;\r\n\r\n        // update the balances here first before calling out (reentrancy)\r\n        balances[msg.sender] = safeSub(balances[msg.sender], value);\r\n        totalSupply = safeSub(totalSupply, value);\r\n        totalUpgraded = safeAdd(totalUpgraded, value);\r\n        upgradeAgent.upgradeFrom(msg.sender, value);\r\n        Upgrade(msg.sender, upgradeAgent, value);\r\n    }\r\n\r\n    /// @notice Set address of upgrade target contract and enable upgrade\r\n    /// process.\r\n    /// @dev Required state: Success\r\n    /// @param agent The address of the UpgradeAgent contract\r\n    function setUpgradeAgent(address agent) external {\r\n        if (getState() != State.Success) throw; // Abort if not in Success state.\r\n        if (agent == 0x0) throw; // don't set agent to nothing\r\n        if (msg.sender != upgradeMaster) throw; // Only a master can designate the next agent\r\n        if (address(upgradeAgent) != 0x0 && upgradeAgent.upgradeHasBegun()) throw; // Don't change the upgrade agent\r\n        upgradeAgent = UpgradeAgent(agent);\r\n        // upgradeAgent must be created and linked to LunyrToken after crowdfunding is over\r\n        if (upgradeAgent.originalSupply() != totalSupply) throw;\r\n        UpgradeAgentSet(upgradeAgent);\r\n    }\r\n\r\n    /// @notice Set address of upgrade target contract and enable upgrade\r\n    /// process.\r\n    /// @dev Required state: Success\r\n    /// @param master The address that will manage upgrades, not the upgradeAgent contract address\r\n    function setUpgradeMaster(address master) external {\r\n        if (getState() != State.Success) throw; // Abort if not in Success state.\r\n        if (master == 0x0) throw;\r\n        if (msg.sender != upgradeMaster) throw; // Only a master can designate the next master\r\n        upgradeMaster = master;\r\n    }\r\n\r\n    function setMultiSigWallet(address newWallet) external {\r\n      if (msg.sender != lunyrMultisig) throw;\r\n      MultiSigWallet wallet = MultiSigWallet(newWallet);\r\n      if (!wallet.isMultiSigWallet()) throw;\r\n      lunyrMultisig = newWallet;\r\n    }\r\n\r\n    // Crowdfunding:\r\n\r\n    // don't just send ether to the contract expecting to get tokens\r\n    function() { throw; }\r\n\r\n\r\n    /// @notice Create tokens when funding is active.\r\n    /// @dev Required state: Funding\r\n    /// @dev State transition: -> Funding Success (only if cap reached)\r\n    function create() payable external {\r\n        // Abort if not in Funding Active state.\r\n        // The checks are split (instead of using or operator) because it is\r\n        // cheaper this way.\r\n        if (getState() != State.Funding) throw;\r\n\r\n        // Do not allow creating 0 or more than the cap tokens.\r\n        if (msg.value == 0) throw;\r\n\r\n        // multiply by exchange rate to get newly created token amount\r\n        uint256 createdTokens = safeMul(msg.value, tokensPerEther);\r\n\r\n        // we are creating tokens, so increase the totalSupply\r\n        totalSupply = safeAdd(totalSupply, createdTokens);\r\n\r\n        // don't go over the limit!\r\n        if (totalSupply > tokenCreationMax) throw;\r\n\r\n        // Assign new tokens to the sender\r\n        balances[msg.sender] = safeAdd(balances[msg.sender], createdTokens);\r\n\r\n        // Log token creation event\r\n        Transfer(0, msg.sender, createdTokens);\r\n    }\r\n\r\n    /// @notice Finalize crowdfunding\r\n    /// @dev If cap was reached or crowdfunding has ended then:\r\n    /// create LUN for the Lunyr Multisig and developer,\r\n    /// transfer ETH to the Lunyr Multisig address.\r\n    /// @dev Required state: Success\r\n    function finalizeCrowdfunding() external {\r\n        // Abort if not in Funding Success state.\r\n        if (getState() != State.Success) throw; // don't finalize unless we won\r\n        if (finalizedCrowdfunding) throw; // can't finalize twice (so sneaky!)\r\n\r\n        // prevent more creation of tokens\r\n        finalizedCrowdfunding = true;\r\n\r\n        // Endowment: 15% of total goes to vault, timelocked for 6 months\r\n        // uint256 vaultTokens = safeDiv(safeMul(totalSupply, vaultPercentOfTotal), hundredPercent);\r\n        uint256 vaultTokens = safeDiv(safeMul(totalSupply, vaultPercentOfTotal), crowdfundPercentOfTotal);\r\n        balances[timeVault] = safeAdd(balances[timeVault], vaultTokens);\r\n        Transfer(0, timeVault, vaultTokens);\r\n\r\n        // Endowment: 7% of total goes to lunyr for marketing and bug bounty\r\n        uint256 lunyrTokens = safeDiv(safeMul(totalSupply, lunyrPercentOfTotal), crowdfundPercentOfTotal);\r\n        balances[lunyrMultisig] = safeAdd(balances[lunyrMultisig], lunyrTokens);\r\n        Transfer(0, lunyrMultisig, lunyrTokens);\r\n\r\n        totalSupply = safeAdd(safeAdd(totalSupply, vaultTokens), lunyrTokens);\r\n\r\n        // Transfer ETH to the Lunyr Multisig address.\r\n        if (!lunyrMultisig.send(this.balance)) throw;\r\n    }\r\n\r\n    /// @notice Get back the ether sent during the funding in case the funding\r\n    /// has not reached the minimum level.\r\n    /// @dev Required state: Failure\r\n    function refund() external {\r\n        // Abort if not in Funding Failure state.\r\n        if (getState() != State.Failure) throw;\r\n\r\n        uint256 lunValue = balances[msg.sender];\r\n        if (lunValue == 0) throw;\r\n        balances[msg.sender] = 0;\r\n        totalSupply = safeSub(totalSupply, lunValue);\r\n\r\n        uint256 ethValue = safeDiv(lunValue, tokensPerEther); // lunValue % tokensPerEther == 0\r\n        Refund(msg.sender, ethValue);\r\n        if (!msg.sender.send(ethValue)) throw;\r\n    }\r\n\r\n    /// @notice This manages the crowdfunding state machine\r\n    /// We make it a function and do not assign the result to a variable\r\n    /// So there is no chance of the variable being stale\r\n    function getState() public constant returns (State){\r\n      // once we reach success, lock in the state\r\n      if (finalizedCrowdfunding) return State.Success;\r\n      if (block.number < fundingStartBlock) return State.PreFunding;\r\n      else if (block.number <= fundingEndBlock && totalSupply < tokenCreationMax) return State.Funding;\r\n      else if (totalSupply >= tokenCreationMin) return State.Success;\r\n      else return State.Failure;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vaultPercentOfTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdfundPercentOfTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeCrowdfunding\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lunyrPercentOfTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeMaster\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalizedCrowdfunding\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hundredPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLunyrToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lunyrMultisig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingEndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUpgraded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"setUpgradeAgent\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"create\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"setMultiSigWallet\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"master\",\"type\":\"address\"}],\"name\":\"setUpgradeMaster\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_lunyrMultisig\",\"type\":\"address\"},{\"name\":\"_upgradeMaster\",\"type\":\"address\"},{\"name\":\"_fundingStartBlock\",\"type\":\"uint256\"},{\"name\":\"_fundingEndBlock\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"upgradeAgent\",\"type\":\"address\"}],\"name\":\"UpgradeFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"UpgradeAgentSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"LunyrToken","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000083c54a35e72ae07c46fc8f8f172a13ba19ac3bed00000000000000000000000083c54a35e72ae07c46fc8f8f172a13ba19ac3bed00000000000000000000000000000000000000000000000000000000003480780000000000000000000000000000000000000000000000000000000000372378","Library":"","SwarmSource":"bzzr://559b1c66bc91160e531d05ea0b34b5cf1969408d1ba4f5a5eaa1866bfe2ef5f2"}]}