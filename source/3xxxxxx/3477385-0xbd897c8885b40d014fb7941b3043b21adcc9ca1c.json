{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.2;\r\n\r\npragma solidity ^0.4.2;\r\n\r\ncontract Owned {\r\n\r\n\taddress owner;\r\n\r\n\tfunction Owned() {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\tmodifier onlyOwner {\r\n        if (msg.sender != owner)\r\n            throw;\r\n        _;\r\n    }\r\n}\r\n\r\ncontract ImpactRegistry is Owned {\r\n\r\n  modifier onlyMaster {\r\n    if (msg.sender != owner && msg.sender != masterContract)\r\n        throw;\r\n    _;\r\n  }\r\n\r\n  address public masterContract;\r\n\r\n  /* This creates a map with donations per user */\r\n  mapping (address => uint) accountBalances;\r\n\r\n  /* Additional structure to help to iterate over donations */\r\n  address[] accountIndex;\r\n\r\n  uint public unit;\r\n\r\n  struct Impact {\r\n    uint value;\r\n    uint linked;\r\n    uint accountCursor;\r\n    uint count;\r\n    mapping(uint => address) addresses;\r\n    mapping(address => uint) values;\r\n  }\r\n\r\n  /* Structures that store a match between validated outcomes and donations */\r\n  mapping (string => Impact) impact;\r\n\r\n\r\n  function ImpactRegistry(address _masterContract, uint _unit) {\r\n    masterContract = _masterContract;\r\n    unit = _unit;\r\n  }\r\n\r\n  function registerDonation(address _from, uint _value) onlyMaster {\r\n    if (accountBalances[_from] == 0) {\r\n      accountIndex.push(_from);\r\n    }\r\n\r\n    if (accountBalances[_from] + _value < accountBalances[_from])\r\n      throw;\r\n\r\n    accountBalances[_from] += _value;\r\n  }\r\n\r\n  function setUnit(uint _value) onlyOwner {\r\n    unit = _value;\r\n  }\r\n\r\n  function setMasterContract(address _contractAddress) onlyOwner {\r\n      masterContract = _contractAddress;\r\n  }\r\n\r\n  function registerOutcome(string _name, uint _value) onlyMaster{\r\n    impact[_name] = Impact(_value, 0, 0, 0);\r\n  }\r\n\r\n  function linkImpact(string _name) onlyOwner {\r\n    uint left = impact[_name].value - impact[_name].linked;\r\n    if (left > 0) {\r\n\r\n      uint i = impact[_name].accountCursor;\r\n\r\n      if (accountBalances[accountIndex[i]] >= 0) {\r\n        /*Calculate shard */\r\n        uint shard = accountBalances[accountIndex[i]];\r\n        if (shard > left) {\r\n          shard = left;\r\n        }\r\n\r\n        if (shard > unit) {\r\n          shard = unit;\r\n        }\r\n\r\n        /* Update balances */\r\n        accountBalances[accountIndex[i]] -= shard;\r\n\r\n        /* Update impact */\r\n        if (impact[_name].values[accountIndex[i]] == 0) {\r\n          impact[_name].addresses[impact[_name].count++] = accountIndex[i];\r\n        }\r\n\r\n        impact[_name].values[accountIndex[i]] += shard;\r\n        impact[_name].linked += shard;\r\n\r\n        /* Move to next account removing empty ones */\r\n        if (accountBalances[accountIndex[i]] == 0) {\r\n          accountIndex[i] = accountIndex[accountIndex.length-1];\r\n          accountIndex.length = accountIndex.length - 1;\r\n          i--;\r\n        }\r\n      }\r\n\r\n      /* Update cursor */\r\n\r\n      if (accountIndex.length > 0) {\r\n        i = (i + 1) % accountIndex.length;\r\n      } else {\r\n        i = 0;\r\n      }\r\n\r\n      impact[_name].accountCursor = i;\r\n    }\r\n  }\r\n\r\n  function payBack(address _account) onlyMaster{\r\n    accountBalances[_account] = 0;\r\n  }\r\n\r\n  function getBalance(address _donorAddress) returns(uint) {\r\n    return accountBalances[_donorAddress];\r\n  }\r\n\r\n  function getImpactCount(string outcome) returns(uint) {\r\n    return impact[outcome].count;\r\n  }\r\n\r\n  function getImpactLinked(string outcome) returns(uint) {\r\n    return impact[outcome].linked;\r\n  }\r\n\r\n  function getImpactDonor(string outcome, uint index) returns(address) {\r\n    return impact[outcome].addresses[index];\r\n  }\r\n\r\n  function getImpactValue(string outcome, address addr) returns(uint) {\r\n    return impact[outcome].values[addr];\r\n  }\r\n\r\n  /* This unnamed function is called whenever someone tries to send ether to it */\r\n  function () {\r\n    throw;     // Prevents accidental sending of ether\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract ContractProvider {\r\n\tfunction contracts(bytes32 contractName) returns (address addr){}\r\n}\r\n\r\n\r\ncontract Token {function transfer(address _to, uint256 _value);}\r\n\r\ncontract Charity is Owned {\r\n    /* Public variables of the token */\r\n    string public name;\r\n    address public judgeAddress;\r\n    address public beneficiaryAddress;\r\n    address public IMPACT_REGISTRY_ADDRESS;\r\n    address public CONTRACT_PROVIDER_ADDRESS;\r\n\r\n\r\n    /* This creates a map with donations per user */\r\n    mapping (address => uint) accountBalances;\r\n\r\n    /* Additional structure to help to iterate over donations */\r\n    address[] accountIndex;\r\n\r\n    /* Total amount of all of the donations */\r\n    uint public total;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event OutcomeEvent(string name, uint value);\r\n    event DonationEvent(address indexed from, uint value);\r\n\r\n    function Charity(string _name) {\r\n        name = _name;\r\n    }\r\n\r\n    function setJudge(address _judgeAddress) onlyOwner {\r\n        judgeAddress = _judgeAddress;\r\n    }\r\n\r\n    function setBeneficiary(address _beneficiaryAddress) onlyOwner {\r\n        beneficiaryAddress = _beneficiaryAddress;\r\n    }\r\n\r\n    function setImpactRegistry(address impactRegistryAddress) onlyOwner {\r\n        IMPACT_REGISTRY_ADDRESS = impactRegistryAddress;\r\n    }\r\n\r\n    function setContractProvider(address _contractProvider) onlyOwner {\r\n        CONTRACT_PROVIDER_ADDRESS = _contractProvider;\r\n    }\r\n\r\n    function notify(address _from, uint _value) onlyOwner {\r\n        if (total + _value < total)\r\n          throw;\r\n\r\n        total += _value;\r\n        ImpactRegistry(IMPACT_REGISTRY_ADDRESS).registerDonation(_from, _value);\r\n        DonationEvent(_from, _value);\r\n    }\r\n\r\n    function fund(uint _value) onlyOwner {\r\n        if (total + _value < total)\r\n          throw;\r\n\r\n        total += _value;\r\n    }\r\n\r\n    function unlockOutcome(string _name, uint _value) {\r\n        if (msg.sender != judgeAddress) throw;\r\n        if (total < _value) throw;\r\n\r\n        address tokenAddress = ContractProvider(CONTRACT_PROVIDER_ADDRESS).contracts(\"digitalGBP\");\r\n        Token(tokenAddress).transfer(beneficiaryAddress, _value);\r\n        total -= _value;\r\n\r\n        ImpactRegistry(IMPACT_REGISTRY_ADDRESS).registerOutcome(_name, _value);\r\n\r\n        OutcomeEvent(_name, _value);\r\n    }\r\n\r\n    function payBack(address account) onlyOwner {\r\n        uint balance = getBalance(account);\r\n        if (balance > 0) {\r\n            address tokenAddress = ContractProvider(CONTRACT_PROVIDER_ADDRESS).contracts(\"digitalGBP\");\r\n            Token(tokenAddress).transfer(account, balance);\r\n            total -= accountBalances[account];\r\n            ImpactRegistry(IMPACT_REGISTRY_ADDRESS).payBack(account);\r\n        }\r\n    }\r\n\r\n    function getBalance(address donor) returns(uint) {\r\n        return ImpactRegistry(IMPACT_REGISTRY_ADDRESS).getBalance(donor);\r\n    }\r\n\r\n    /* Extra security measure to save funds in case of critical error or attack */\r\n    function escape(address escapeAddress) onlyOwner {\r\n        address tokenAddress = ContractProvider(CONTRACT_PROVIDER_ADDRESS).contracts(\"digitalGBP\");\r\n        Token(tokenAddress).transfer(escapeAddress, total);\r\n        total = 0;\r\n    }\r\n\r\n    /* This unnamed function is called whenever someone tries to send ether to it */\r\n    function () {\r\n        throw;     // Prevents accidental sending of ether\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaryAddress\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"notify\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"unlockOutcome\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"judgeAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"impactRegistryAddress\",\"type\":\"address\"}],\"name\":\"setImpactRegistry\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"payBack\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"escapeAddress\",\"type\":\"address\"}],\"name\":\"escape\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractProvider\",\"type\":\"address\"}],\"name\":\"setContractProvider\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_judgeAddress\",\"type\":\"address\"}],\"name\":\"setJudge\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_PROVIDER_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"fund\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"IMPACT_REGISTRY_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiaryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"donor\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"OutcomeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"DonationEvent\",\"type\":\"event\"}]","ContractName":"Charity","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000f4c6f6e646f6e20486f6d656c6573730000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://433c8a0014e8abbac48de2c20eb64993d8a6e0f8dc9f6de2d7b6d3cbf19137fa"}]}