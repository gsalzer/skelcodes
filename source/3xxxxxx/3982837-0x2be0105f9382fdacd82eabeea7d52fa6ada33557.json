{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n/*\r\n  Copyright 2017, Anton Egorov (Mothership Foundation)\r\n  Copyright 2017, Klaus Hott (BlockchainLabs.nz)\r\n  Copyright 2017, Jorge Izquierdo (Aragon Foundation)\r\n  Copyright 2017, Jordi Baylina (Giveth)\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n  it under the terms of the GNU General Public License as published by\r\n  the Free Software Foundation, either version 3 of the License, or\r\n  (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n  GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\ncontract Controlled {\r\n  /// @notice The address of the controller is the only address that can call\r\n  ///  a function with this modifier\r\n  modifier onlyController { if (msg.sender != controller) throw; _; }\r\n\r\n  address public controller;\r\n\r\n  function Controlled() { controller = msg.sender;}\r\n\r\n  /// @notice Changes the controller of the contract\r\n  /// @param _newController The new controller of the contract\r\n  function changeController(address _newController) onlyController {\r\n    controller = _newController;\r\n  }\r\n}\r\n\r\ncontract Refundable {\r\n  function refund(address th, uint amount) returns (bool);\r\n}\r\n\r\n/// @dev The token controller contract must implement these functions\r\ncontract TokenController {\r\n  /// @notice Called when `_owner` sends ether to the MiniMe Token contract\r\n  /// @param _owner The address that sent the ether to create tokens\r\n  /// @return True if the ether is accepted, false if it throws\r\n  function proxyPayment(address _owner) payable returns(bool);\r\n\r\n  /// @notice Notifies the controller about a token transfer allowing the\r\n  ///  controller to react if desired\r\n  /// @param _from The origin of the transfer\r\n  /// @param _to The destination of the transfer\r\n  /// @param _amount The amount of the transfer\r\n  /// @return False if the controller does not authorize the transfer\r\n  function onTransfer(address _from, address _to, uint _amount) returns(bool);\r\n\r\n  /// @notice Notifies the controller about an approval allowing the\r\n  ///  controller to react if desired\r\n  /// @param _owner The address that calls `approve()`\r\n  /// @param _spender The spender in the `approve()` call\r\n  /// @param _amount The amount in the `approve()` call\r\n  /// @return False if the controller does not authorize the approval\r\n  function onApprove(address _owner, address _spender, uint _amount)\r\n    returns(bool);\r\n}\r\n\r\ncontract ERC20Token {\r\n  /* This is a slight change to the ERC20 base standard.\r\n     function totalSupply() constant returns (uint256 supply);\r\n     is replaced with:\r\n     uint256 public totalSupply;\r\n     This automatically creates a getter function for the totalSupply.\r\n     This is moved to the base contract since public getter functions are not\r\n     currently recognised as an implementation of the matching abstract\r\n     function by the compiler.\r\n  */\r\n  /// total amount of tokens\r\n  function totalSupply() constant returns (uint256 balance);\r\n\r\n  /// @param _owner The address from which the balance will be retrieved\r\n  /// @return The balance\r\n  function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n  /// @notice send `_value` token to `_to` from `msg.sender`\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n  /// @param _from The address of the sender\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @param _value The amount of tokens to be approved for transfer\r\n  /// @return Whether the approval was successful or not\r\n  function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n  /// @param _owner The address of the account owning tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @return Amount of remaining tokens allowed to spent\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract Burnable is Controlled {\r\n  /// @notice The address of the controller is the only address that can call\r\n  ///  a function with this modifier, also the burner can call but also the\r\n  /// target of the function must be the burner\r\n  modifier onlyControllerOrBurner(address target) {\r\n    assert(msg.sender == controller || (msg.sender == burner && msg.sender == target));\r\n    _;\r\n  }\r\n\r\n  modifier onlyBurner {\r\n    assert(msg.sender == burner);\r\n    _;\r\n  }\r\n  address public burner;\r\n\r\n  function Burnable() { burner = msg.sender;}\r\n\r\n  /// @notice Changes the burner of the contract\r\n  /// @param _newBurner The new burner of the contract\r\n  function changeBurner(address _newBurner) onlyBurner {\r\n    burner = _newBurner;\r\n  }\r\n}\r\n\r\ncontract MiniMeTokenI is ERC20Token, Burnable {\r\n\r\n      string public name;                //The Token's name: e.g. DigixDAO Tokens\r\n      uint8 public decimals;             //Number of decimals of the smallest unit\r\n      string public symbol;              //An identifier: e.g. REP\r\n      string public version = 'MMT_0.1'; //An arbitrary versioning scheme\r\n\r\n///////////////////\r\n// ERC20 Methods\r\n///////////////////\r\n\r\n\r\n    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\r\n    ///  its behalf, and then a function is triggered in the contract that is\r\n    ///  being approved, `_spender`. This allows users to use their tokens to\r\n    ///  interact with contracts in one function call instead of two\r\n    /// @param _spender The address of the contract able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return True if the function call was successful\r\n    function approveAndCall(\r\n        address _spender,\r\n        uint256 _amount,\r\n        bytes _extraData\r\n    ) returns (bool success);\r\n\r\n////////////////\r\n// Query balance and totalSupply in History\r\n////////////////\r\n\r\n    /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @param _blockNumber The block number when the balance is queried\r\n    /// @return The balance at `_blockNumber`\r\n    function balanceOfAt(\r\n        address _owner,\r\n        uint _blockNumber\r\n    ) constant returns (uint);\r\n\r\n    /// @notice Total amount of tokens at a specific `_blockNumber`.\r\n    /// @param _blockNumber The block number when the totalSupply is queried\r\n    /// @return The total amount of tokens at `_blockNumber`\r\n    function totalSupplyAt(uint _blockNumber) constant returns(uint);\r\n\r\n////////////////\r\n// Clone Token Method\r\n////////////////\r\n\r\n    /// @notice Creates a new clone token with the initial distribution being\r\n    ///  this token at `_snapshotBlock`\r\n    /// @param _cloneTokenName Name of the clone token\r\n    /// @param _cloneDecimalUnits Number of decimals of the smallest unit\r\n    /// @param _cloneTokenSymbol Symbol of the clone token\r\n    /// @param _snapshotBlock Block when the distribution of the parent token is\r\n    ///  copied to set the initial distribution of the new clone token;\r\n    ///  if the block is zero than the actual block, the current block is used\r\n    /// @param _transfersEnabled True if transfers are allowed in the clone\r\n    /// @return The address of the new MiniMeToken Contract\r\n    function createCloneToken(\r\n        string _cloneTokenName,\r\n        uint8 _cloneDecimalUnits,\r\n        string _cloneTokenSymbol,\r\n        uint _snapshotBlock,\r\n        bool _transfersEnabled\r\n    ) returns(address);\r\n\r\n////////////////\r\n// Generate and destroy tokens\r\n////////////////\r\n\r\n    /// @notice Generates `_amount` tokens that are assigned to `_owner`\r\n    /// @param _owner The address that will be assigned the new tokens\r\n    /// @param _amount The quantity of tokens generated\r\n    /// @return True if the tokens are generated correctly\r\n    function generateTokens(address _owner, uint _amount) returns (bool);\r\n\r\n\r\n    /// @notice Burns `_amount` tokens from `_owner`\r\n    /// @param _owner The address that will lose the tokens\r\n    /// @param _amount The quantity of tokens to burn\r\n    /// @return True if the tokens are burned correctly\r\n    function destroyTokens(address _owner, uint _amount) returns (bool);\r\n\r\n////////////////\r\n// Enable tokens transfers\r\n////////////////\r\n\r\n    /// @notice Enables token holders to transfer their tokens freely if true\r\n    /// @param _transfersEnabled True if transfers are allowed in the clone\r\n    function enableTransfers(bool _transfersEnabled);\r\n\r\n//////////\r\n// Safety Methods\r\n//////////\r\n\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token);\r\n\r\n////////////////\r\n// Events\r\n////////////////\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\r\n    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\r\n}\r\n\r\ncontract Finalizable {\r\n  uint256 public finalizedBlock;\r\n  bool public goalMet;\r\n\r\n  function finalize();\r\n}\r\n\r\ncontract Contribution is Controlled, TokenController, Finalizable {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public totalSupplyCap; // Total MSP supply to be generated\r\n  uint256 public exchangeRate; // ETH-MSP exchange rate\r\n  uint256 public totalSold; // How much tokens sold\r\n  uint256 public totalSaleSupplyCap; // Token sale cap\r\n\r\n  MiniMeTokenI public sit;\r\n  MiniMeTokenI public msp;\r\n\r\n  uint256 public startBlock;\r\n  uint256 public endBlock;\r\n\r\n  address public destEthDevs;\r\n  address public destTokensSit;\r\n  address public destTokensTeam;\r\n  address public destTokensReferals;\r\n\r\n  address public mspController;\r\n\r\n  uint256 public initializedBlock;\r\n  uint256 public finalizedTime;\r\n\r\n  uint256 public minimum_investment;\r\n  uint256 public minimum_goal;\r\n\r\n  bool public paused;\r\n\r\n  modifier initialized() {\r\n    assert(address(msp) != 0x0);\r\n    _;\r\n  }\r\n\r\n  modifier contributionOpen() {\r\n    assert(getBlockNumber() >= startBlock &&\r\n            getBlockNumber() <= endBlock &&\r\n            finalizedBlock == 0 &&\r\n            address(msp) != 0x0);\r\n    _;\r\n  }\r\n\r\n  modifier notPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  function Contribution() {\r\n    // Booleans are false by default consider removing this\r\n    paused = false;\r\n  }\r\n\r\n  /// @notice This method should be called by the controller before the contribution\r\n  ///  period starts This initializes most of the parameters\r\n  /// @param _msp Address of the MSP token contract\r\n  /// @param _mspController Token controller for the MSP that will be transferred after\r\n  ///  the contribution finalizes.\r\n  /// @param _totalSupplyCap Maximum amount of tokens to generate during the contribution\r\n  /// @param _exchangeRate ETH to MSP rate for the token sale\r\n  /// @param _startBlock Block when the contribution period starts\r\n  /// @param _endBlock The last block that the contribution period is active\r\n  /// @param _destEthDevs Destination address where the contribution ether is sent\r\n  /// @param _destTokensSit Address of the exchanger SIT-MSP where the MSP are sent\r\n  ///  to be distributed to the SIT holders.\r\n  /// @param _destTokensTeam Address where the tokens for the team are sent\r\n  /// @param _destTokensReferals Address where the tokens for the referal system are sent\r\n  /// @param _sit Address of the SIT token contract\r\n  function initialize(\r\n      address _msp,\r\n      address _mspController,\r\n\r\n      uint256 _totalSupplyCap,\r\n      uint256 _exchangeRate,\r\n      uint256 _minimum_goal,\r\n\r\n      uint256 _startBlock,\r\n      uint256 _endBlock,\r\n\r\n      address _destEthDevs,\r\n      address _destTokensSit,\r\n      address _destTokensTeam,\r\n      address _destTokensReferals,\r\n\r\n      address _sit\r\n  ) public onlyController {\r\n    // Initialize only once\r\n    assert(address(msp) == 0x0);\r\n\r\n    msp = MiniMeTokenI(_msp);\r\n    assert(msp.totalSupply() == 0);\r\n    assert(msp.controller() == address(this));\r\n    assert(msp.decimals() == 18);  // Same amount of decimals as ETH\r\n\r\n    require(_mspController != 0x0);\r\n    mspController = _mspController;\r\n\r\n    require(_exchangeRate > 0);\r\n    exchangeRate = _exchangeRate;\r\n\r\n    assert(_startBlock >= getBlockNumber());\r\n    require(_startBlock < _endBlock);\r\n    startBlock = _startBlock;\r\n    endBlock = _endBlock;\r\n\r\n    require(_destEthDevs != 0x0);\r\n    destEthDevs = _destEthDevs;\r\n\r\n    require(_destTokensSit != 0x0);\r\n    destTokensSit = _destTokensSit;\r\n\r\n    require(_destTokensTeam != 0x0);\r\n    destTokensTeam = _destTokensTeam;\r\n\r\n    require(_destTokensReferals != 0x0);\r\n    destTokensReferals = _destTokensReferals;\r\n\r\n    require(_sit != 0x0);\r\n    sit = MiniMeTokenI(_sit);\r\n\r\n    initializedBlock = getBlockNumber();\r\n    // SIT amount should be no more than 20% of MSP total supply cap\r\n    assert(sit.totalSupplyAt(initializedBlock) * 5 <= _totalSupplyCap);\r\n    totalSupplyCap = _totalSupplyCap;\r\n\r\n    // We are going to sale 70% of total supply cap\r\n    totalSaleSupplyCap = percent(70).mul(_totalSupplyCap).div(percent(100));\r\n\r\n    minimum_goal = _minimum_goal;\r\n  }\r\n\r\n  function setMinimumInvestment(\r\n      uint _minimum_investment\r\n  ) public onlyController {\r\n    minimum_investment = _minimum_investment;\r\n  }\r\n\r\n  function setExchangeRate(\r\n      uint _exchangeRate\r\n  ) public onlyController {\r\n    assert(getBlockNumber() < startBlock);\r\n    exchangeRate = _exchangeRate;\r\n  }\r\n\r\n  /// @notice If anybody sends Ether directly to this contract, consider he is\r\n  ///  getting MSPs.\r\n  function () public payable notPaused {\r\n    proxyPayment(msg.sender);\r\n  }\r\n\r\n\r\n  //////////\r\n  // TokenController functions\r\n  //////////\r\n\r\n  /// @notice This method will generally be called by the MSP token contract to\r\n  ///  acquire MSPs. Or directly from third parties that want to acquire MSPs in\r\n  ///  behalf of a token holder.\r\n  /// @param _th MSP holder where the MSPs will be minted.\r\n  function proxyPayment(address _th) public payable notPaused initialized contributionOpen returns (bool) {\r\n    require(_th != 0x0);\r\n    doBuy(_th);\r\n    return true;\r\n  }\r\n\r\n  function onTransfer(address, address, uint256) public returns (bool) {\r\n    return false;\r\n  }\r\n\r\n  function onApprove(address, address, uint256) public returns (bool) {\r\n    return false;\r\n  }\r\n\r\n  function doBuy(address _th) internal {\r\n    require(msg.value >= minimum_investment);\r\n\r\n    // Antispam mechanism\r\n    address caller;\r\n    if (msg.sender == address(msp)) {\r\n      caller = _th;\r\n    } else {\r\n      caller = msg.sender;\r\n    }\r\n\r\n    // Do not allow contracts to game the system\r\n    assert(!isContract(caller));\r\n\r\n    uint256 toFund = msg.value;\r\n    uint256 leftForSale = tokensForSale();\r\n    if (toFund > 0) {\r\n      if (leftForSale > 0) {\r\n        uint256 tokensGenerated = toFund.mul(exchangeRate);\r\n\r\n        // Check total supply cap reached, sell the all remaining tokens\r\n        if (tokensGenerated > leftForSale) {\r\n          tokensGenerated = leftForSale;\r\n          toFund = leftForSale.div(exchangeRate);\r\n        }\r\n\r\n        assert(msp.generateTokens(_th, tokensGenerated));\r\n        totalSold = totalSold.add(tokensGenerated);\r\n        if (totalSold >= minimum_goal) {\r\n          goalMet = true;\r\n        }\r\n        destEthDevs.transfer(toFund);\r\n        NewSale(_th, toFund, tokensGenerated);\r\n      } else {\r\n        toFund = 0;\r\n      }\r\n    }\r\n\r\n    uint256 toReturn = msg.value.sub(toFund);\r\n    if (toReturn > 0) {\r\n      // If the call comes from the Token controller,\r\n      // then we return it to the token Holder.\r\n      // Otherwise we return to the sender.\r\n      if (msg.sender == address(msp)) {\r\n        _th.transfer(toReturn);\r\n      } else {\r\n        msg.sender.transfer(toReturn);\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Internal function to determine if an address is a contract\r\n  /// @param _addr The address being queried\r\n  /// @return True if `_addr` is a contract\r\n  function isContract(address _addr) constant internal returns (bool) {\r\n    if (_addr == 0) return false;\r\n    uint256 size;\r\n    assembly {\r\n      size := extcodesize(_addr)\r\n    }\r\n    return (size > 0);\r\n  }\r\n\r\n  function refund() public {\r\n    require(finalizedBlock != 0);\r\n    require(!goalMet);\r\n\r\n    uint256 amountTokens = msp.balanceOf(msg.sender);\r\n    require(amountTokens > 0);\r\n    uint256 amountEther = amountTokens.div(exchangeRate);\r\n    address th = msg.sender;\r\n\r\n    Refundable(mspController).refund(th, amountTokens);\r\n    Refundable(destEthDevs).refund(th, amountEther);\r\n\r\n    Refund(th, amountTokens, amountEther);\r\n  }\r\n\r\n  event Refund(address _token_holder, uint256 _amount_tokens, uint256 _amount_ether);\r\n\r\n  /// @notice This method will can be called by the controller before the contribution period\r\n  ///  end or by anybody after the `endBlock`. This method finalizes the contribution period\r\n  ///  by creating the remaining tokens and transferring the controller to the configured\r\n  ///  controller.\r\n  function finalize() public initialized {\r\n    assert(getBlockNumber() >= startBlock);\r\n    assert(msg.sender == controller || getBlockNumber() > endBlock || tokensForSale() == 0);\r\n    require(finalizedBlock == 0);\r\n\r\n    finalizedBlock = getBlockNumber();\r\n    finalizedTime = now;\r\n\r\n    if (goalMet) {\r\n      // Generate 5% for the team\r\n      assert(msp.generateTokens(\r\n        destTokensTeam,\r\n        percent(5).mul(totalSupplyCap).div(percent(100))));\r\n\r\n      // Generate 5% for the referal bonuses\r\n      assert(msp.generateTokens(\r\n        destTokensReferals,\r\n        percent(5).mul(totalSupplyCap).div(percent(100))));\r\n\r\n      // Generate tokens for SIT exchanger\r\n      assert(msp.generateTokens(\r\n        destTokensSit,\r\n        sit.totalSupplyAt(initializedBlock)));\r\n    }\r\n\r\n    msp.changeController(mspController);\r\n    Finalized();\r\n  }\r\n\r\n  function percent(uint256 p) internal returns (uint256) {\r\n    return p.mul(10**16);\r\n  }\r\n\r\n\r\n  //////////\r\n  // Constant functions\r\n  //////////\r\n\r\n  /// @return Total tokens issued in weis.\r\n  function tokensIssued() public constant returns (uint256) {\r\n    return msp.totalSupply();\r\n  }\r\n\r\n  /// @return Total tokens availale for the sale in weis.\r\n  function tokensForSale() public constant returns(uint256) {\r\n    return totalSaleSupplyCap > totalSold ? totalSaleSupplyCap - totalSold : 0;\r\n  }\r\n\r\n\r\n  //////////\r\n  // Testing specific methods\r\n  //////////\r\n\r\n  /// @notice This function is overridden by the test Mocks.\r\n  function getBlockNumber() internal constant returns (uint256) {\r\n    return block.number;\r\n  }\r\n\r\n\r\n  //////////\r\n  // Safety Methods\r\n  //////////\r\n\r\n  /// @notice This method can be used by the controller to extract mistakenly\r\n  ///  sent tokens to this contract.\r\n  /// @param _token The address of the token contract that you want to recover\r\n  ///  set to 0 in case you want to extract ether.\r\n  function claimTokens(address _token) public onlyController {\r\n    if (msp.controller() == address(this)) {\r\n      msp.claimTokens(_token);\r\n    }\r\n    if (_token == 0x0) {\r\n      controller.transfer(this.balance);\r\n      return;\r\n    }\r\n\r\n    ERC20Token token = ERC20Token(_token);\r\n    uint256 balance = token.balanceOf(this);\r\n    token.transfer(controller, balance);\r\n    ClaimedTokens(_token, controller, balance);\r\n  }\r\n\r\n\r\n  /// @notice Pauses the contribution if there is any issue\r\n  function pauseContribution() onlyController {\r\n    paused = true;\r\n  }\r\n\r\n  /// @notice Resumes the contribution\r\n  function resumeContribution() onlyController {\r\n    paused = false;\r\n  }\r\n\r\n  event ClaimedTokens(address indexed _token, address indexed _controller, uint256 _amount);\r\n  event NewSale(address indexed _th, uint256 _amount, uint256 _tokens);\r\n  event Finalized();\r\n}\r\n\r\n/// @title SITExchanger Contract\r\n/// @author Anton Egorov\r\n/// @dev This contract will be used to distribute MSP between SIT holders.\r\n///  SIT token is not transferable, and we just keep an accounting between all tokens\r\n///  deposited and the tokens collected.\r\n///  The controllerShip of SIT should be transferred to this contract before the\r\n///  contribution period starts.\r\n\r\ncontract SITExchanger is Controlled, TokenController {\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => uint256) public collected;\r\n  uint256 public totalCollected;\r\n  MiniMeTokenI public sit;\r\n  MiniMeTokenI public msp;\r\n  Contribution public contribution;\r\n\r\n  function SITExchanger(address _sit, address _msp, address _contribution) {\r\n    sit = MiniMeTokenI(_sit);\r\n    msp = MiniMeTokenI(_msp);\r\n    contribution = Contribution(_contribution);\r\n  }\r\n\r\n  /// @notice This method should be called by the SIT holders to collect their\r\n  ///  corresponding MSPs\r\n  function collect() public {\r\n    // SIT sholder could collect MSP right after contribution started\r\n    assert(getBlockNumber() > contribution.startBlock());\r\n\r\n    // Get current MSP ballance\r\n    uint256 balance = sit.balanceOfAt(msg.sender, contribution.initializedBlock());\r\n\r\n    // And then subtract the amount already collected\r\n    uint256 amount = balance.sub(collected[msg.sender]);\r\n\r\n    require(amount > 0);  // Notify the user that there are no tokens to exchange\r\n\r\n    totalCollected = totalCollected.add(amount);\r\n    collected[msg.sender] = collected[msg.sender].add(amount);\r\n\r\n    assert(msp.transfer(msg.sender, amount));\r\n\r\n    TokensCollected(msg.sender, amount);\r\n  }\r\n\r\n  function proxyPayment(address) public payable returns (bool) {\r\n    throw;\r\n  }\r\n\r\n  function onTransfer(address, address, uint256) public returns (bool) {\r\n    return false;\r\n  }\r\n\r\n  function onApprove(address, address, uint256) public returns (bool) {\r\n    return false;\r\n  }\r\n\r\n  //////////\r\n  // Testing specific methods\r\n  //////////\r\n\r\n  /// @notice This function is overridden by the test Mocks.\r\n  function getBlockNumber() internal constant returns (uint256) {\r\n    return block.number;\r\n  }\r\n\r\n  //////////\r\n  // Safety Method\r\n  //////////\r\n\r\n  /// @notice This method can be used by the controller to extract mistakenly\r\n  ///  sent tokens to this contract.\r\n  /// @param _token The address of the token contract that you want to recover\r\n  ///  set to 0 in case you want to extract ether.\r\n  function claimTokens(address _token) public onlyController {\r\n    assert(_token != address(msp));\r\n    if (_token == 0x0) {\r\n      controller.transfer(this.balance);\r\n      return;\r\n    }\r\n\r\n    ERC20Token token = ERC20Token(_token);\r\n    uint256 balance = token.balanceOf(this);\r\n    token.transfer(controller, balance);\r\n    ClaimedTokens(_token, controller, balance);\r\n  }\r\n\r\n  event ClaimedTokens(address indexed _token, address indexed _controller, uint256 _amount);\r\n  event TokensCollected(address indexed _holder, uint256 _amount);\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"collected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newController\",\"type\":\"address\"}],\"name\":\"changeController\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"onTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contribution\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sit\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"msp\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"onApprove\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collect\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"proxyPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_sit\",\"type\":\"address\"},{\"name\":\"_msp\",\"type\":\"address\"},{\"name\":\"_contribution\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_controller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokensCollected\",\"type\":\"event\"}]","ContractName":"SITExchanger","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000003698a26a6af930c76ee74a66eed6649fc511e6f00000000000000000000000068aa3f232da9bdc2343465545794ef3eea5209bd000000000000000000000000f5096917729885ef5b1a8c4ef238d3cf06028ee7","Library":"","SwarmSource":"bzzr://f840cf88c02487de15ecadc6f54d312e618851e1d74230babe6b0b110b9115c2"}]}