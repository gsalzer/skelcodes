{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\n/// auth.sol -- widely-used access control pattern for Ethereum\r\n\r\n// Copyright (C) 2015, 2016, 2017  Nexus Development, LLC\r\n\r\n// Licensed under the Apache License, Version 2.0 (the \"License\").\r\n// You may not use this file except in compliance with the License.\r\n\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) constant returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    function DSAuth() {\r\n        owner = msg.sender;\r\n        LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        assert(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    modifier authorized(bytes4 sig) {\r\n        assert(isAuthorized(msg.sender, sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal returns (bool) {\r\n        if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n\r\n    function assert(bool x) internal {\r\n        if (!x) throw;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    function totalSupply() constant returns (uint supply);\r\n    function balanceOf( address who ) constant returns (uint value);\r\n    function allowance( address owner, address spender ) constant returns (uint _allowance);\r\n\r\n    function transfer( address to, uint value) returns (bool ok);\r\n    function transferFrom( address from, address to, uint value) returns (bool ok);\r\n    function approve( address spender, uint value ) returns (bool ok);\r\n\r\n    event Transfer( address indexed from, address indexed to, uint value);\r\n    event Approval( address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract EventfulMarket {\r\n    event ItemUpdate( uint id );\r\n    event Trade( uint sell_how_much, address indexed sell_which_token,\r\n                 uint buy_how_much, address indexed buy_which_token );\r\n\r\n    event LogMake(\r\n        bytes32  indexed  id,\r\n        bytes32  indexed  pair,\r\n        address  indexed  maker,\r\n        ERC20             haveToken,\r\n        ERC20             wantToken,\r\n        uint128           haveAmount,\r\n        uint128           wantAmount,\r\n        uint64            timestamp\r\n    );\r\n\r\n    event LogBump(\r\n        bytes32  indexed  id,\r\n        bytes32  indexed  pair,\r\n        address  indexed  maker,\r\n        ERC20             haveToken,\r\n        ERC20             wantToken,\r\n        uint128           haveAmount,\r\n        uint128           wantAmount,\r\n        uint64            timestamp\r\n    );\r\n\r\n    event LogTake(\r\n        bytes32           id,\r\n        bytes32  indexed  pair,\r\n        address  indexed  maker,\r\n        ERC20             haveToken,\r\n        ERC20             wantToken,\r\n        address  indexed  taker,\r\n        uint128           takeAmount,\r\n        uint128           giveAmount,\r\n        uint64            timestamp\r\n    );\r\n\r\n    event LogKill(\r\n        bytes32  indexed  id,\r\n        bytes32  indexed  pair,\r\n        address  indexed  maker,\r\n        ERC20             haveToken,\r\n        ERC20             wantToken,\r\n        uint128           haveAmount,\r\n        uint128           wantAmount,\r\n        uint64            timestamp\r\n    );\r\n}\r\n\r\ncontract SimpleMarket is EventfulMarket {\r\n    bool locked;\r\n\r\n    modifier synchronized {\r\n        assert(!locked);\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    function assert(bool x) internal {\r\n        if (!x) throw;\r\n    }\r\n\r\n    struct OfferInfo {\r\n        uint     sell_how_much;\r\n        ERC20    sell_which_token;\r\n        uint     buy_how_much;\r\n        ERC20    buy_which_token;\r\n        address  owner;\r\n        bool     active;\r\n        uint64   timestamp;\r\n    }\r\n\r\n    mapping (uint => OfferInfo) public offers;\r\n\r\n    uint public last_offer_id;\r\n\r\n    function next_id() internal returns (uint) {\r\n        last_offer_id++; return last_offer_id;\r\n    }\r\n\r\n    modifier can_offer {\r\n        _;\r\n    }\r\n    modifier can_buy(uint id) {\r\n        assert(isActive(id));\r\n        _;\r\n    }\r\n    modifier can_cancel(uint id) {\r\n        assert(isActive(id));\r\n        assert(getOwner(id) == msg.sender);\r\n        _;\r\n    }\r\n    function isActive(uint id) constant returns (bool active) {\r\n        return offers[id].active;\r\n    }\r\n    function getOwner(uint id) constant returns (address owner) {\r\n        return offers[id].owner;\r\n    }\r\n    function getOffer( uint id ) constant returns (uint, ERC20, uint, ERC20) {\r\n      var offer = offers[id];\r\n      return (offer.sell_how_much, offer.sell_which_token,\r\n              offer.buy_how_much, offer.buy_which_token);\r\n    }\r\n\r\n    // non underflowing subtraction\r\n    function safeSub(uint a, uint b) internal returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    // non overflowing multiplication\r\n    function safeMul(uint a, uint b) internal returns (uint c) {\r\n        c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n    }\r\n\r\n    function trade( address seller, uint sell_how_much, ERC20 sell_which_token,\r\n                    address buyer,  uint buy_how_much,  ERC20 buy_which_token )\r\n        internal\r\n    {\r\n        var seller_paid_out = buy_which_token.transferFrom( buyer, seller, buy_how_much );\r\n        assert(seller_paid_out);\r\n        var buyer_paid_out = sell_which_token.transfer( buyer, sell_how_much );\r\n        assert(buyer_paid_out);\r\n        Trade( sell_how_much, sell_which_token, buy_how_much, buy_which_token );\r\n    }\r\n\r\n    // ---- Public entrypoints ---- //\r\n\r\n    function make(\r\n        ERC20    haveToken,\r\n        ERC20    wantToken,\r\n        uint128  haveAmount,\r\n        uint128  wantAmount\r\n    ) returns (bytes32 id) {\r\n        return bytes32(offer(haveAmount, haveToken, wantAmount, wantToken));\r\n    }\r\n\r\n    function take(bytes32 id, uint128 maxTakeAmount) {\r\n        assert(buy(uint256(id), maxTakeAmount));\r\n    }\r\n\r\n    function kill(bytes32 id) {\r\n        assert(cancel(uint256(id)));\r\n    }\r\n\r\n    // Make a new offer. Takes funds from the caller into market escrow.\r\n    function offer( uint sell_how_much, ERC20 sell_which_token\r\n                  , uint buy_how_much,  ERC20 buy_which_token )\r\n        can_offer\r\n        synchronized\r\n        returns (uint id)\r\n    {\r\n        assert(uint128(sell_how_much) == sell_how_much);\r\n        assert(uint128(buy_how_much) == buy_how_much);\r\n        assert(sell_how_much > 0);\r\n        assert(sell_which_token != ERC20(0x0));\r\n        assert(buy_how_much > 0);\r\n        assert(buy_which_token != ERC20(0x0));\r\n        assert(sell_which_token != buy_which_token);\r\n\r\n        OfferInfo memory info;\r\n        info.sell_how_much = sell_how_much;\r\n        info.sell_which_token = sell_which_token;\r\n        info.buy_how_much = buy_how_much;\r\n        info.buy_which_token = buy_which_token;\r\n        info.owner = msg.sender;\r\n        info.active = true;\r\n        info.timestamp = uint64(now);\r\n        id = next_id();\r\n        offers[id] = info;\r\n\r\n        var seller_paid = sell_which_token.transferFrom( msg.sender, this, sell_how_much );\r\n        assert(seller_paid);\r\n\r\n        ItemUpdate(id);\r\n        LogMake(\r\n            bytes32(id),\r\n            sha3(sell_which_token, buy_which_token),\r\n            msg.sender,\r\n            sell_which_token,\r\n            buy_which_token,\r\n            uint128(sell_how_much),\r\n            uint128(buy_how_much),\r\n            uint64(now)\r\n        );\r\n    }\r\n\r\n    function bump(bytes32 id_)\r\n        can_buy(uint256(id_))\r\n    {\r\n        var id = uint256(id_);\r\n        LogBump(\r\n            id_,\r\n            sha3(offers[id].sell_which_token, offers[id].buy_which_token),\r\n            offers[id].owner,\r\n            offers[id].sell_which_token,\r\n            offers[id].buy_which_token,\r\n            uint128(offers[id].sell_how_much),\r\n            uint128(offers[id].buy_how_much),\r\n            offers[id].timestamp\r\n        );\r\n    }\r\n\r\n    // Accept given `quantity` of an offer. Transfers funds from caller to\r\n    // offer maker, and from market to caller.\r\n    function buy( uint id, uint quantity )\r\n        can_buy(id)\r\n        synchronized\r\n        returns ( bool success )\r\n    {\r\n        assert(uint128(quantity) == quantity);\r\n\r\n        // read-only offer. Modify an offer by directly accessing offers[id]\r\n        OfferInfo memory offer = offers[id];\r\n\r\n        // inferred quantity that the buyer wishes to spend\r\n        uint spend = safeMul(quantity, offer.buy_how_much) / offer.sell_how_much;\r\n        assert(uint128(spend) == spend);\r\n\r\n        if ( spend > offer.buy_how_much || quantity > offer.sell_how_much ) {\r\n            // buyer wants more than is available\r\n            success = false;\r\n        } else if ( spend == offer.buy_how_much && quantity == offer.sell_how_much ) {\r\n            // buyer wants exactly what is available\r\n            delete offers[id];\r\n\r\n            trade( offer.owner, quantity, offer.sell_which_token,\r\n                   msg.sender, spend, offer.buy_which_token );\r\n\r\n            ItemUpdate(id);\r\n            LogTake(\r\n                bytes32(id),\r\n                sha3(offer.sell_which_token, offer.buy_which_token),\r\n                offer.owner,\r\n                offer.sell_which_token,\r\n                offer.buy_which_token,\r\n                msg.sender,\r\n                uint128(offer.sell_how_much),\r\n                uint128(offer.buy_how_much),\r\n                uint64(now)\r\n            );\r\n\r\n            success = true;\r\n        } else if ( spend > 0 && quantity > 0 ) {\r\n            // buyer wants a fraction of what is available\r\n            offers[id].sell_how_much = safeSub(offer.sell_how_much, quantity);\r\n            offers[id].buy_how_much = safeSub(offer.buy_how_much, spend);\r\n\r\n            trade( offer.owner, quantity, offer.sell_which_token,\r\n                    msg.sender, spend, offer.buy_which_token );\r\n\r\n            ItemUpdate(id);\r\n            LogTake(\r\n                bytes32(id),\r\n                sha3(offer.sell_which_token, offer.buy_which_token),\r\n                offer.owner,\r\n                offer.sell_which_token,\r\n                offer.buy_which_token,\r\n                msg.sender,\r\n                uint128(quantity),\r\n                uint128(spend),\r\n                uint64(now)\r\n            );\r\n\r\n            success = true;\r\n        } else {\r\n            // buyer wants an unsatisfiable amount (less than 1 integer)\r\n            success = false;\r\n        }\r\n    }\r\n\r\n    // Cancel an offer. Refunds offer maker.\r\n    function cancel( uint id )\r\n        can_cancel(id)\r\n        synchronized\r\n        returns ( bool success )\r\n    {\r\n        // read-only offer. Modify an offer by directly accessing offers[id]\r\n        OfferInfo memory offer = offers[id];\r\n        delete offers[id];\r\n\r\n        var seller_refunded = offer.sell_which_token.transfer( offer.owner , offer.sell_how_much );\r\n        assert(seller_refunded);\r\n\r\n        ItemUpdate(id);\r\n        LogKill(\r\n            bytes32(id),\r\n            sha3(offer.sell_which_token, offer.buy_which_token),\r\n            offer.owner,\r\n            offer.sell_which_token,\r\n            offer.buy_which_token,\r\n            uint128(offer.sell_how_much),\r\n            uint128(offer.buy_how_much),\r\n            uint64(now)\r\n        );\r\n\r\n        success = true;\r\n    }\r\n}\r\n\r\n// Simple Market with a market lifetime. When the lifetime has elapsed,\r\n// offers can only be cancelled (offer and buy will throw).\r\n\r\ncontract ExpiringMarket is DSAuth, SimpleMarket {\r\n    uint public lifetime;\r\n    uint public close_time;\r\n    bool public stopped;\r\n\r\n    function stop() auth {\r\n        stopped = true;\r\n    }\r\n\r\n    function ExpiringMarket(uint lifetime_) {\r\n        lifetime = lifetime_;\r\n        close_time = getTime() + lifetime_;\r\n    }\r\n\r\n    function getTime() constant returns (uint) {\r\n        return block.timestamp;\r\n    }\r\n    function isClosed() constant returns (bool closed) {\r\n        return stopped || (getTime() > close_time);\r\n    }\r\n\r\n    // after market lifetime has elapsed, no new offers are allowed\r\n    modifier can_offer {\r\n        assert(!isClosed());\r\n        _;\r\n    }\r\n    // after close, no new buys are allowed\r\n    modifier can_buy(uint id) {\r\n        assert(isActive(id));\r\n        assert(!isClosed());\r\n        _;\r\n    }\r\n    // after close, anyone can cancel an offer\r\n    modifier can_cancel(uint id) {\r\n        assert(isActive(id));\r\n        assert(isClosed() || (msg.sender == getOwner(id)));\r\n        _;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"haveToken\",\"type\":\"address\"},{\"name\":\"wantToken\",\"type\":\"address\"},{\"name\":\"haveAmount\",\"type\":\"uint128\"},{\"name\":\"wantAmount\",\"type\":\"uint128\"}],\"name\":\"make\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"last_offer_id\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getOffer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"maxTakeAmount\",\"type\":\"uint128\"}],\"name\":\"take\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"close_time\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lifetime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id_\",\"type\":\"bytes32\"}],\"name\":\"bump\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"isActive\",\"outputs\":[{\"name\":\"active\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"offers\",\"outputs\":[{\"name\":\"sell_how_much\",\"type\":\"uint256\"},{\"name\":\"sell_which_token\",\"type\":\"address\"},{\"name\":\"buy_how_much\",\"type\":\"uint256\"},{\"name\":\"buy_which_token\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"active\",\"type\":\"bool\"},{\"name\":\"timestamp\",\"type\":\"uint64\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isClosed\",\"outputs\":[{\"name\":\"closed\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sell_how_much\",\"type\":\"uint256\"},{\"name\":\"sell_which_token\",\"type\":\"address\"},{\"name\":\"buy_how_much\",\"type\":\"uint256\"},{\"name\":\"buy_which_token\",\"type\":\"address\"}],\"name\":\"offer\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"lifetime_\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ItemUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sell_how_much\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"sell_which_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buy_how_much\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buy_which_token\",\"type\":\"address\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"pair\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"haveToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wantToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"haveAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"wantAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"LogMake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"pair\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"haveToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wantToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"haveAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"wantAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"LogBump\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"pair\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"haveToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wantToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"takeAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"giveAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"LogTake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"pair\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"haveToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wantToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"haveAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"wantAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"LogKill\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"}]","ContractName":"ExpiringMarket","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000001e13380","Library":"","SwarmSource":"bzzr://4e5c06ed78b1ac49d24218b0fb808b908d9a106c2df9585fd25e1cc17a8632f6"}]}