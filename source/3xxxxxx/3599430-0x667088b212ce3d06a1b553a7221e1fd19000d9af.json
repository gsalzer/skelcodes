{"status":"1","message":"OK","result":[{"SourceCode":"contract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    if (msg.sender == owner)\r\n      _;\r\n  }\r\n\r\n  function transferOwner(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) throw;\r\n  }\r\n}\r\n\r\ncontract StandardToken is ERC20, SafeMath {\r\n\r\n  mapping(address => uint) balances;\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  function transfer(address _to, uint _value) returns (bool success) {\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n    \r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n/*\r\n  Wings ERC20 Token.\r\n  Added allocation for users who participiated in Wings Campaign.\r\n\r\n  Important!\r\n  We have to run pre-mine allocation first.\r\n  And only then rest of users.\r\n  Or it's not going to work due to whenAllocation logic.\r\n*/\r\ncontract Token is StandardToken, Ownable {\r\n  // Account allocation event\r\n  event ALLOCATION(address indexed account, uint amount);\r\n\r\n  /*\r\n    Premine events\r\n  */\r\n  event PREMINER_ADDED(address indexed owner, address account, uint amount);\r\n  event PREMINE_ALLOCATION_ADDED(address indexed account, uint time);\r\n  event PREMINE_RELEASE(address indexed account, uint timestamp, uint amount);\r\n  event PREMINER_CHANGED(address indexed oldPreminer, address newPreminer, address newRecipient);\r\n\r\n  /*\r\n    Premine structure\r\n  */\r\n  struct Preminer {\r\n    address account;\r\n    uint monthlyPayment;\r\n    uint latestAllocation;\r\n    bool disabled;\r\n\r\n    uint allocationsCount;\r\n    mapping(uint => uint) allocations;\r\n  }\r\n\r\n  /*\r\n    List of preminers\r\n  */\r\n  mapping(address => Preminer) preminers;\r\n\r\n  /*\r\n    Token Name & Token Symbol & Decimals\r\n  */\r\n  string public name = \"WINGS\";\r\n  string public symbol = \"WINGS\";\r\n  uint public decimals = 18;\r\n\r\n  /*\r\n    Total supply\r\n  */\r\n  uint public totalSupply = 10**26;//100000000000000000000000000;\r\n\r\n  /*\r\n    Premine allocation interval\r\n  */\r\n  uint public DAYS_28 = 2419200;\r\n  uint public DAYS_31 = 2678400;\r\n\r\n  /*\r\n    Maximum premine allocations count\r\n  */\r\n  uint public MAX_ALLOCATIONS_COUNT = 26;\r\n\r\n  /*\r\n    How many accounts allocated?\r\n  */\r\n  uint public accountsToAllocate;\r\n\r\n  /*\r\n    Multisignature\r\n  */\r\n  address public multisignature;\r\n\r\n  /*\r\n    Only multisignature\r\n  */\r\n  modifier onlyMultisignature() {\r\n    if (msg.sender != multisignature) {\r\n      throw;\r\n    }\r\n\r\n    _;\r\n  }\r\n\r\n  /*\r\n    When preminer is not disabled\r\n  */\r\n  modifier whenPreminerIsntDisabled(address _account) {\r\n    if (preminers[_account].disabled == true) {\r\n      throw;\r\n    }\r\n\r\n    _;\r\n  }\r\n\r\n  /*\r\n    Modifier for checking is allocation completed.\r\n    Maybe we should add here pre-mine accounts too.\r\n  */\r\n  modifier whenAllocation(bool value) {\r\n    if ((accountsToAllocate > 0) == value) {\r\n      _;\r\n    } else {\r\n      throw;\r\n    }\r\n  }\r\n\r\n  /*\r\n    Check if user already allocated\r\n  */\r\n  modifier whenAccountHasntAllocated(address user) {\r\n    if (balances[user] == 0) {\r\n      _;\r\n    } else {\r\n      throw;\r\n    }\r\n  }\r\n\r\n  /*\r\n    Check if preminer already added\r\n  */\r\n  modifier whenPremineHasntAllocated(address preminer) {\r\n    if (preminers[preminer].account == address(0)) {\r\n      _;\r\n    } else {\r\n      throw;\r\n    }\r\n  }\r\n\r\n  function Token(uint _accountsToAllocate, address _multisignature) {\r\n    /*\r\n      Maybe we should calculate it in allocation and pre-mine.\r\n      I mean total supply\r\n    */\r\n    owner = msg.sender;\r\n    accountsToAllocate = _accountsToAllocate;\r\n    multisignature = _multisignature;\r\n  }\r\n\r\n  /*\r\n    Allocate tokens for users.\r\n    Only owner and only while allocation active.\r\n\r\n    Should check if user allocated already (no double allocations)\r\n  */\r\n  function allocate(address user, uint balance) onlyOwner() whenAllocation(true) whenAccountHasntAllocated(user) {\r\n    balances[user] = balance;\r\n\r\n    accountsToAllocate--;\r\n    ALLOCATION(user, balance);\r\n  }\r\n\r\n  /*\r\n    Standard Token functional\r\n  */\r\n  function transfer(address _to, uint _value) whenAllocation(false) returns (bool success) {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) whenAllocation(false) returns (bool success) {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n  function approve(address _spender, uint _value) whenAllocation(false) returns (bool success) {\r\n    return super.approve(_spender, _value);\r\n  }\r\n\r\n  /*\r\n    Premine functionality\r\n  */\r\n\r\n  /*\r\n    Add pre-mine account\r\n  */\r\n  function addPreminer(address preminer, address recipient, uint initialBalance, uint monthlyPayment) onlyOwner() whenAllocation(true) whenPremineHasntAllocated(preminer) {\r\n    var premine = Preminer(\r\n        recipient,\r\n        monthlyPayment,\r\n        0,\r\n        false,\r\n        0\r\n      );\r\n\r\n\r\n    balances[recipient] = safeAdd(balances[recipient], initialBalance);\r\n    preminers[preminer] = premine;\r\n    accountsToAllocate--;\r\n    PREMINER_ADDED(preminer, premine.account, initialBalance);\r\n  }\r\n\r\n  /*\r\n    Disable pre-miner\r\n  */\r\n  function disablePreminer(address _preminer, address _newPreminer, address _newRecipient) onlyMultisignature() whenPreminerIsntDisabled(_preminer) {\r\n    var oldPreminer = preminers[_preminer];\r\n\r\n    if (oldPreminer.account == address(0) || preminers[_newPreminer].account != address(0)) {\r\n      throw;\r\n    }\r\n\r\n    preminers[_newPreminer] = oldPreminer;\r\n    preminers[_newPreminer].account = _newRecipient;\r\n    oldPreminer.disabled = true;\r\n\r\n    if(preminers[_newPreminer].disabled == true) {\r\n      throw;\r\n    }\r\n\r\n    for (uint i = 0; i < preminers[_newPreminer].allocationsCount; i++) {\r\n      preminers[_newPreminer].allocations[i] = oldPreminer.allocations[i];\r\n    }\r\n\r\n    PREMINER_CHANGED(_preminer, _newPreminer, _newRecipient);\r\n  }\r\n\r\n  /*\r\n    Add pre-mine allocation\r\n  */\r\n  function addPremineAllocation(address _preminer, uint _time) onlyOwner() whenAllocation(true) whenPreminerIsntDisabled(_preminer) {\r\n    var preminer = preminers[_preminer];\r\n\r\n    if (preminer.account == address(0) ||  _time == 0 || preminer.allocationsCount == MAX_ALLOCATIONS_COUNT) {\r\n      throw;\r\n    }\r\n\r\n    if (preminer.allocationsCount > 0) {\r\n      var previousAllocation = preminer.allocations[preminer.allocationsCount-1];\r\n\r\n      if (previousAllocation > _time) {\r\n        throw;\r\n      }\r\n\r\n      if (previousAllocation + DAYS_28 > _time) {\r\n        throw;\r\n      }\r\n\r\n      if (previousAllocation + DAYS_31 < _time) {\r\n        throw;\r\n      }\r\n    }\r\n\r\n    preminer.allocations[preminer.allocationsCount++] = _time;\r\n    PREMINE_ALLOCATION_ADDED(_preminer, _time);\r\n  }\r\n\r\n  /*\r\n    Get preminer\r\n  */\r\n  function getPreminer(address _preminer) constant returns (address, bool, uint, uint, uint) {\r\n    var preminer = preminers[_preminer];\r\n\r\n    return (preminer.account, preminer.disabled, preminer.monthlyPayment, preminer.latestAllocation, preminer.allocationsCount);\r\n  }\r\n\r\n  /*\r\n    Get preminer allocation time by index\r\n  */\r\n  function getPreminerAllocation(address _preminer, uint _index) constant returns (uint) {\r\n    return preminers[_preminer].allocations[_index];\r\n  }\r\n\r\n  /*\r\n    Release premine when preminer asking\r\n    Gas usage: 0x5786 or 22406 GAS.\r\n    Maximum is 26 months of pre-mine in case of Wings. So should be enough to execute it.\r\n  */\r\n  function releasePremine() whenAllocation(false) whenPreminerIsntDisabled(msg.sender) {\r\n    var preminer = preminers[msg.sender];\r\n\r\n    if (preminer.account == address(0)) {\r\n      throw;\r\n    }\r\n\r\n    for (uint i = preminer.latestAllocation; i < preminer.allocationsCount; i++) {\r\n      if (preminer.allocations[i] < block.timestamp) {\r\n        if (preminer.allocations[i] == 0) {\r\n          continue;\r\n        }\r\n\r\n        balances[preminer.account] = safeAdd(balances[preminer.account], preminer.monthlyPayment);\r\n        preminer.latestAllocation = i;\r\n\r\n        PREMINE_RELEASE(preminer.account, preminer.allocations[i], preminer.monthlyPayment);\r\n        preminer.allocations[i] = 0;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_ALLOCATIONS_COUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releasePremine\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAYS_28\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accountsToAllocate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_preminer\",\"type\":\"address\"},{\"name\":\"_newPreminer\",\"type\":\"address\"},{\"name\":\"_newRecipient\",\"type\":\"address\"}],\"name\":\"disablePreminer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_preminer\",\"type\":\"address\"},{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"addPremineAllocation\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_preminer\",\"type\":\"address\"}],\"name\":\"getPreminer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"allocate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisignature\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_preminer\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getPreminerAllocation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAYS_31\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"preminer\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"initialBalance\",\"type\":\"uint256\"},{\"name\":\"monthlyPayment\",\"type\":\"uint256\"}],\"name\":\"addPreminer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_accountsToAllocate\",\"type\":\"uint256\"},{\"name\":\"_multisignature\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ALLOCATION\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PREMINER_ADDED\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"PREMINE_ALLOCATION_ADDED\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PREMINE_RELEASE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldPreminer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newPreminer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newRecipient\",\"type\":\"address\"}],\"name\":\"PREMINER_CHANGED\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Token","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000001657000000000000000000000000f64b584972fe6055a770477670208d737fff282f","Library":"","SwarmSource":"bzzr://f7fedc0ebb37416b7d382b1eac4dca98aeb05b286acc175a12ba86f6c8f6c581"}]}