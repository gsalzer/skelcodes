{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n/**\r\n * Copyright (c) 2016 Smart Contract Solutions, Inc.\r\n * Math operations with safety checks\r\n */\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n/*\r\n * Copyright (c) 2016 Smart Contract Solutions, Inc.\r\n * ERC20 interface\r\n * see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n/**\r\n * Copyright (c) 2016 Smart Contract Solutions, Inc.\r\n * Standard ERC20 token\r\n *\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, SafeMath {\r\n\r\n  mapping (address => uint) balances;\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  function transfer(address _to, uint _value) returns (bool success) {\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\r\n    // if (_value > _allowance) throw;\r\n\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n/*\r\n * Copyright (c) 2016 Smart Contract Solutions, Inc.\r\n * Ownable\r\n *\r\n * Base contract with an owner.\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n/// @title Moeda Loaylty Points token contract\r\ncontract MoedaToken is StandardToken, Ownable {\r\n    string public constant name = \"Moeda Loyalty Points\";\r\n    string public constant symbol = \"MLO\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    // don't allow creation of more than this number of tokens\r\n    uint public constant MAX_TOKENS = 20000000 ether;\r\n    \r\n    // transfers are locked during the sale\r\n    bool public saleActive;\r\n\r\n    // only emitted during the crowdsale\r\n    event Created(address indexed donor, uint256 tokensReceived);\r\n\r\n    // determine whether transfers can be made\r\n    modifier onlyAfterSale() {\r\n        if (saleActive) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyDuringSale() {\r\n        if (!saleActive) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @dev Create moeda token and lock transfers\r\n    function MoedaToken() {\r\n        saleActive = true;\r\n    }\r\n\r\n    /// @dev unlock transfers\r\n    function unlock() onlyOwner {\r\n        saleActive = false;\r\n    }\r\n\r\n    /// @dev create tokens, only usable while saleActive\r\n    /// @param recipient address that will receive the created tokens\r\n    /// @param amount the number of tokens to create\r\n    function create(address recipient, uint256 amount)\r\n    onlyOwner onlyDuringSale {\r\n        if (amount == 0) throw;\r\n        if (safeAdd(totalSupply, amount) > MAX_TOKENS) throw;\r\n\r\n        balances[recipient] = safeAdd(balances[recipient], amount);\r\n        totalSupply = safeAdd(totalSupply, amount);\r\n\r\n        Created(recipient, amount);\r\n    }\r\n\r\n    // transfer tokens\r\n    // only allowed after sale has ended\r\n    function transfer(address _to, uint _value) onlyAfterSale returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    // transfer tokens\r\n    // only allowed after sale has ended\r\n    function transferFrom(address from, address to, uint value) onlyAfterSale \r\n    returns (bool)\r\n    {\r\n        return super.transferFrom(from, to, value);\r\n    }\r\n}\r\n\r\n/// @title Moeda crowdsale\r\ncontract Crowdsale is Ownable, SafeMath {\r\n    bool public crowdsaleClosed;        // whether the crowdsale has been closed \r\n                                        // manually\r\n    address public wallet;              // recipient of all crowdsale funds\r\n    MoedaToken public moedaToken;       // token that will be sold during sale\r\n    uint256 public etherReceived;       // total ether received\r\n    uint256 public totalTokensSold;     // number of tokens sold\r\n    uint256 public startBlock;          // block where sale starts\r\n    uint256 public endBlock;            // block where sale ends\r\n\r\n    // used to scale token amounts to 18 decimals\r\n    uint256 public constant TOKEN_MULTIPLIER = 10 ** 18;\r\n\r\n    // number of tokens allocated to presale (prior to crowdsale)\r\n    uint256 public constant PRESALE_TOKEN_ALLOCATION = 5000000 * TOKEN_MULTIPLIER;\r\n\r\n    // recipient of presale tokens\r\n    address public PRESALE_WALLET = \"0x30B3C64d43e7A1E8965D934Fa96a3bFB33Eee0d2\";\r\n    \r\n    // smallest possible donation\r\n    uint256 public constant DUST_LIMIT = 1 finney;\r\n\r\n    // token generation rates (tokens per eth)\r\n    uint256 public constant TIER1_RATE = 160;\r\n    uint256 public constant TIER2_RATE = 125;\r\n    uint256 public constant TIER3_RATE = 80;\r\n\r\n    // limits for each pricing tier (how much can be bought)\r\n    uint256 public constant TIER1_CAP =  31250 ether;\r\n    uint256 public constant TIER2_CAP =  71250 ether;\r\n    uint256 public constant TIER3_CAP = 133750 ether; // Total ether cap\r\n\r\n    // Log a purchase\r\n    event Purchase(address indexed donor, uint256 amount, uint256 tokenAmount);\r\n\r\n    // Log transfer of tokens that were sent to this contract by mistake\r\n    event TokenDrain(address token, address to, uint256 amount);\r\n\r\n    modifier onlyDuringSale() {\r\n        if (crowdsaleClosed) {\r\n            throw;\r\n        }\r\n\r\n        if (block.number < startBlock) {\r\n            throw;\r\n        }\r\n\r\n        if (block.number >= endBlock) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @dev Initialize a new Crowdsale contract\r\n    /// @param _wallet address of multisig wallet that will store received ether\r\n    /// @param _startBlock block at which to start the sale\r\n    /// @param _endBlock block at which to end the sale\r\n    function Crowdsale(address _wallet, uint _startBlock, uint _endBlock) {\r\n        if (_wallet == address(0)) throw;\r\n        if (_startBlock <= block.number) throw;\r\n        if (_endBlock <= _startBlock) throw;\r\n        \r\n        crowdsaleClosed = false;\r\n        wallet = _wallet;\r\n        moedaToken = new MoedaToken();\r\n        startBlock = _startBlock;\r\n        endBlock = _endBlock;\r\n    }\r\n\r\n    /// @dev Determine the lowest rate to acquire tokens given an amount of \r\n    /// donated ethers\r\n    /// @param totalReceived amount of ether that has been received\r\n    /// @return pair of the current tier's donation limit and a token creation rate\r\n    function getLimitAndPrice(uint256 totalReceived)\r\n    constant returns (uint256, uint256) {\r\n        uint256 limit = 0;\r\n        uint256 price = 0;\r\n\r\n        if (totalReceived < TIER1_CAP) {\r\n            limit = TIER1_CAP;\r\n            price = TIER1_RATE;\r\n        }\r\n        else if (totalReceived < TIER2_CAP) {\r\n            limit = TIER2_CAP;\r\n            price = TIER2_RATE;\r\n        }\r\n        else if (totalReceived < TIER3_CAP) {\r\n            limit = TIER3_CAP;\r\n            price = TIER3_RATE;\r\n        } else {\r\n            throw; // this shouldn't happen\r\n        }\r\n\r\n        return (limit, price);\r\n    }\r\n\r\n    /// @dev Determine how many tokens we can get from each pricing tier, in\r\n    /// case a donation's amount overlaps multiple pricing tiers.\r\n    ///\r\n    /// @param totalReceived ether received by contract plus spent by this donation\r\n    /// @param requestedAmount total ether to spend on tokens in a donation\r\n    /// @return amount of tokens to get for the requested ether donation\r\n    function getTokenAmount(uint256 totalReceived, uint256 requestedAmount) \r\n    constant returns (uint256) {\r\n\r\n        // base case, we've spent the entire donation and can stop\r\n        if (requestedAmount == 0) return 0;\r\n        uint256 limit = 0;\r\n        uint256 price = 0;\r\n        \r\n        // 1. Determine cheapest token price\r\n        (limit, price) = getLimitAndPrice(totalReceived);\r\n\r\n        // 2. Since there are multiple pricing levels based on how much has been\r\n        // received so far, we need to determine how much can be spent at\r\n        // any given tier. This in case a donation will overlap more than one \r\n        // tier\r\n        uint256 maxETHSpendableInTier = safeSub(limit, totalReceived);\r\n        uint256 amountToSpend = min256(maxETHSpendableInTier, requestedAmount);\r\n\r\n        // 3. Given a price determine how many tokens the unspent ether in this \r\n        // donation will get you\r\n        uint256 tokensToReceiveAtCurrentPrice = safeMul(amountToSpend, price);\r\n\r\n        // You've spent everything you could at this level, continue to the next\r\n        // one, in case there is some ETH left unspent in this donation.\r\n        uint256 additionalTokens = getTokenAmount(\r\n            safeAdd(totalReceived, amountToSpend),\r\n            safeSub(requestedAmount, amountToSpend));\r\n\r\n        return safeAdd(tokensToReceiveAtCurrentPrice, additionalTokens);\r\n    }\r\n\r\n    /// grant tokens to buyer when we receive ether\r\n    /// @dev buy tokens, only usable while crowdsale is active\r\n    function () payable onlyDuringSale {\r\n        if (msg.value < DUST_LIMIT) throw;\r\n        if (safeAdd(etherReceived, msg.value) > TIER3_CAP) throw;\r\n\r\n        uint256 tokenAmount = getTokenAmount(etherReceived, msg.value);\r\n\r\n        moedaToken.create(msg.sender, tokenAmount);\r\n        etherReceived = safeAdd(etherReceived, msg.value);\r\n        totalTokensSold = safeAdd(totalTokensSold, tokenAmount);\r\n        Purchase(msg.sender, msg.value, tokenAmount);\r\n\r\n        if (!wallet.send(msg.value)) throw;\r\n    }\r\n\r\n    /// @dev close the crowdsale manually and unlock the tokens\r\n    /// this will only be successful if not already executed,\r\n    /// if endBlock has been reached, or if the cap has been reached\r\n    function finalize() onlyOwner {\r\n        if (block.number < startBlock) throw;\r\n        if (crowdsaleClosed) throw;\r\n\r\n        // if amount remaining is too small we can allow sale to end earlier\r\n        uint256 amountRemaining = safeSub(TIER3_CAP, etherReceived);\r\n        if (block.number < endBlock && amountRemaining >= DUST_LIMIT) throw;\r\n\r\n        // create and assign presale tokens to presale wallet\r\n        moedaToken.create(PRESALE_WALLET, PRESALE_TOKEN_ALLOCATION);\r\n\r\n        // unlock tokens for spending\r\n        moedaToken.unlock();\r\n        crowdsaleClosed = true;\r\n    }\r\n\r\n    /// @dev Drain tokens that were sent here by mistake\r\n    /// because people will.\r\n    /// @param _token address of token to transfer\r\n    /// @param _to address where tokens will be transferred\r\n    function drainToken(address _token, address _to) onlyOwner {\r\n        if (_token == address(0)) throw;\r\n        if (_to == address(0)) throw;\r\n        ERC20 token = ERC20(_token);\r\n        uint256 balance = token.balanceOf(this);\r\n        token.transfer(_to, balance);\r\n        TokenDrain(_token, _to, balance);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"totalReceived\",\"type\":\"uint256\"},{\"name\":\"requestedAmount\",\"type\":\"uint256\"}],\"name\":\"getTokenAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIER1_RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_MULTIPLIER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIER3_RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DUST_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRESALE_WALLET\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIER3_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRESALE_TOKEN_ALLOCATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIER1_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"moedaToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"totalReceived\",\"type\":\"uint256\"}],\"name\":\"getLimitAndPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"drainToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIER2_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIER2_RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"name\":\"_endBlock\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"donor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Purchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenDrain\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ed1475eee0c969d4877bd05ffdd6bfdc84b821da000000000000000000000000000000000000000000000000000000000039b71000000000000000000000000000000000000000000000000000000000003ebcc5","Library":"","SwarmSource":"bzzr://990e2d0ce7165fb5828145db499798d23ed3c9a325db60a59f80e75b27dd7066"}]}