{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;                                                                                                           \r\n                                                                                                                                   \r\n// VERSION LAVA(J)                                                                                                                 \r\n                                                                                                                                   \r\n                                                                                                                                   \r\n// --------------------------                                                                                                      \r\n// here's how this works:                                                                                                          \r\n// the current amount of dividends due to each token-holder's  is:                                                                 \r\n//   previous_due + [ p(x) * t(x)/N ] + [ p(x+1) * t(x+1)/N ] + ...                                                                \r\n//   where p(x) is the x'th payment received by the contract                                                                       \r\n//         t(x) is the number of tokens held by the token-holder at the time of p(x)                                               \r\n//         N    is the total number of tokens, which never changes                                                                 \r\n//                                                                                                                                 \r\n// assume that t(x) takes on 3 values, t(a), t(b) and t(c), during periods a, b, and c. then:\r\n// factoring:\r\n//   current_due = { (t(a) * [p(x) + p(x+1)] ...) +\r\n//                   (t(b) * [p(y) + p(y+1)] ...) +\r\n//                   (t(c) * [p(z) + p(z+1)] ...) } / N\r\n//\r\n// or\r\n//\r\n//   current_due = { (t(a) * period_a_fees) +\r\n//                   (t(b) * period_b_fees) +\r\n//                   (t(c) * period_c_fees) } / N\r\n//\r\n// if we designate current_due * N as current-points, then\r\n//\r\n//   currentPoints = {  (t(a) * period_a_fees) +\r\n//                      (t(b) * period_b_fees) +\r\n//                      (t(c) * period_c_fees) }\r\n//\r\n// or more succictly, if we recompute current points before a token-holder's number of\r\n// tokens, T, is about to change:\r\n//\r\n//   currentPoints = previous_points + (T * current-period-fees)\r\n//\r\n// when we want to do a payout, we'll calculate:\r\n//  current_due = current-points / N\r\n//\r\n// we'll keep track of a token-holder's current-period-points, which is:\r\n//   T * current-period-fees\r\n// by taking a snapshot of fees collected exactly when the current period began; that is, the when the\r\n// number of tokens last changed. that is, we keep a running count of total fees received\r\n//\r\n//   TotalFeesReceived = p(x) + p(x+1) + p(x+2)\r\n//\r\n// (which happily is the same for all token holders) then, before any token holder changes their number of\r\n// tokens we compute (for that token holder):\r\n//\r\n//  function calcCurPointsForAcct(acct) {\r\n//    currentPoints[acct] += (TotalFeesReceived - lastSnapshot[acct]) * T[acct]\r\n//    lastSnapshot[acct] = TotalFeesReceived\r\n//  }\r\n//\r\n// in the withdraw fcn, all we need is:\r\n//\r\n//  function withdraw(acct) {\r\n//    calcCurPointsForAcct(acct);\r\n//    current_amount_due = currentPoints[acct] / N\r\n//    currentPoints[acct] = 0;\r\n//    send(current_amount_due);\r\n//  }\r\n//\r\n//\r\n// special provisions for transfers from the old e4row contract (token-split transfers)\r\n// -------------------------------------------------------------------------------------\r\n// normally when a new acct is created, eg cuz tokens are transferred from one acct to another, we first call\r\n// calcCurPointsForAcct(acct) on the old acct; on the new acct we set:\r\n//  currentPoints[acct] = 0;\r\n//  lastSnapshot[acct] = TotalFeesReceived;\r\n//\r\n// this starts the new account with no credits for any dividends that have been collected so far, which is what\r\n// you would generally want. however, there is a case in which tokens are transferred from the old e4row contract.\r\n// in that case the tokens were reserved on this contract all along, and they earn dividends even before they are\r\n// assigned to an account. so for token-split transfers:\r\n//  currentPoints[acct] = 0;\r\n//  lastSnapshot[acct] = 0;\r\n//\r\n// then immediately call calcCurPointsForAcct(acct) for the new token-split account. he will get credit\r\n// for all the accumulated points, from the beginning of time.\r\n//\r\n// --------------------------\r\n\r\n\r\n// Abstract contract for the full ERC 20 Token standard\r\n// https://github.com/ethereum/EIPs/issues/20\r\n\r\n// ---------------------------------\r\n// ABSTRACT standard token class\r\n// ---------------------------------\r\ncontract Token {\r\n    function totalSupply() constant returns (uint256 supply);\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n// --------------------------\r\n//  E4RowRewards - abstract e4 dividend contract\r\n// --------------------------\r\ncontract E4LavaRewards\r\n{\r\n        function checkDividends(address _addr) constant returns(uint _amount);\r\n        function withdrawDividends() public returns (uint namount);\r\n        function transferDividends(address _to) returns (bool success);\r\n        function getAccountInfo(address _addr) constant returns(uint _tokens, uint _snapshot, uint _points);\r\n\r\n}\r\n\r\n// --------------------------\r\n//  E4LavaOptin - abstract e4 optin contract\r\n// --------------------------\r\ncontract E4LavaOptIn\r\n{\r\n        function optInFromClassic() public;\r\n}\r\n\r\n\r\n// --------------------------\r\n//  E4ROW (LAVA) - token contract\r\n// --------------------------\r\ncontract E4Lava is Token, E4LavaRewards, E4LavaOptIn {\r\n        event StatEvent(string msg);\r\n        event StatEventI(string msg, uint val);\r\n\r\n        enum SettingStateValue  {debug, lockedRelease}\r\n\r\n        struct tokenAccount {\r\n                bool alloced;       // flag to ascert prior allocation\r\n                uint tokens;        // num tokens currently held in this acct\r\n                uint currentPoints; // updated before token balance changes, or before a withdrawal. credit for owning tokens\r\n                uint lastSnapshot;  // snapshot of global TotalPoints, last time we updated this acct's currentPoints\r\n        }\r\n\r\n// -----------------------------\r\n//  data storage\r\n// ----------------------------------------\r\n        uint constant NumOrigTokens         = 5762;   // number of old tokens, from original token contract\r\n        uint constant NewTokensPerOrigToken = 100000; // how many new tokens are created for each from original token\r\n        uint constant NewTokenSupply        = 5762 * 100000;\r\n        uint public numToksSwitchedOver;              // count old tokens that have been converted\r\n        uint public holdoverBalance;                  // funds received, but not yet distributed\r\n        uint public TotalFeesReceived;                // total fees received from partner contract(s)\r\n\r\n        address public developers;                    // developers token holding address\r\n        address public owner;                         // deployer executor\r\n        address public oldE4;                         // addr of old e4 token contract\r\n        address public oldE4RecycleBin;               // addr to transfer old tokens\r\n\r\n        uint public decimals;\r\n        string public symbol;\r\n\r\n        mapping (address => tokenAccount) holderAccounts;          // who holds how many tokens (high two bytes contain curPayId)\r\n        mapping (uint => address) holderIndexes;                   // for iteration thru holder\r\n        mapping (address => mapping (address => uint256)) allowed; // approvals\r\n        uint public numAccounts;\r\n\r\n        uint public payoutThreshold;                  // no withdrawals less than this amount, to avoid remainders\r\n        uint public rwGas;                            // reward gas\r\n        uint public optInXferGas;                     // gas used when optInFromClassic calls xfer on old contract\r\n        uint public optInFcnMinGas;                   // gas we need for the optInFromClassic fcn, *excluding* optInXferGas\r\n        uint public vestTime = 1525219201;            // 1 year past sale vest developer tokens\r\n\r\n        SettingStateValue public settingsState;\r\n\r\n\r\n        // --------------------\r\n        // contract constructor\r\n        // --------------------\r\n        function E4Lava()\r\n        {\r\n                owner = msg.sender;\r\n                developers = msg.sender;\r\n                decimals = 2;\r\n                symbol = \"E4ROW\";\r\n        }\r\n\r\n        // -----------------------------------\r\n        // use this to reset everything, will never be called after lockRelease\r\n        // -----------------------------------\r\n        function applySettings(SettingStateValue qState, uint _threshold, uint _rw, uint _optXferGas, uint _optFcnGas )\r\n        {\r\n                if (msg.sender != owner)\r\n                        return;\r\n\r\n                // these settings are permanently tweakable for performance adjustments\r\n                payoutThreshold = _threshold;\r\n                rwGas = _rw;\r\n                optInXferGas = _optXferGas;\r\n                optInFcnMinGas = _optFcnGas;\r\n\r\n                // this first test checks if already locked\r\n                if (settingsState == SettingStateValue.lockedRelease)\r\n                        return;\r\n\r\n                settingsState = qState;\r\n\r\n                // this second test allows locking without changing other permanent settings\r\n                // WARNING, MAKE SURE YOUR'RE HAPPY WITH ALL SETTINGS\r\n                // BEFORE LOCKING\r\n\r\n                if (qState == SettingStateValue.lockedRelease) {\r\n                        StatEvent(\"Locking!\");\r\n                        return;\r\n                }\r\n\r\n                // zero out all token holders.\r\n                // leave alloced on, leave num accounts\r\n                // cant delete them anyways\r\n\r\n                for (uint i = 0; i < numAccounts; i++ ) {\r\n                        address a = holderIndexes[i];\r\n                        if (a != address(0)) {\r\n                                holderAccounts[a].tokens = 0;\r\n                                holderAccounts[a].currentPoints = 0;\r\n                                holderAccounts[a].lastSnapshot = 0;\r\n                        }\r\n                }\r\n\r\n                numToksSwitchedOver = 0;\r\n                holdoverBalance = 0;\r\n                TotalFeesReceived = 0;\r\n\r\n                if (this.balance > 0) {\r\n                        if (!owner.call.gas(rwGas).value(this.balance)())\r\n                                StatEvent(\"ERROR!\");\r\n                }\r\n                StatEvent(\"ok\");\r\n\r\n        }\r\n\r\n\r\n        // ---------------------------------------------------\r\n        // allocate a new account by setting alloc to true\r\n        // add holder index, bump the num accounts\r\n        // ---------------------------------------------------\r\n        function addAccount(address _addr) internal  {\r\n                holderAccounts[_addr].alloced = true;\r\n                holderAccounts[_addr].tokens = 0;\r\n                holderAccounts[_addr].currentPoints = 0;\r\n                holderAccounts[_addr].lastSnapshot = TotalFeesReceived;\r\n                holderIndexes[numAccounts++] = _addr;\r\n        }\r\n\r\n\r\n// --------------------------------------\r\n// BEGIN ERC-20 from StandardToken\r\n// --------------------------------------\r\n\r\n        function totalSupply() constant returns (uint256 supply)\r\n        {\r\n                supply = NewTokenSupply;\r\n        }\r\n\r\n        // ----------------------------\r\n        // sender transfers tokens to a new acct\r\n        // do not use this fcn for a token-split transfer from the old token contract!\r\n        // ----------------------------\r\n        function transfer(address _to, uint256 _value) returns (bool success)\r\n        {\r\n                if ((msg.sender == developers)\r\n                        &&  (now < vestTime)) {\r\n                        //statEvent(\"Tokens not yet vested.\");\r\n                        return false;\r\n                }\r\n\r\n                //Default assumes totalSupply can't be over max (2^256 - 1).\r\n                //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n                //Replace the if with this one instead.\r\n                //if (holderAccounts[msg.sender].tokens >= _value && balances[_to] + _value > holderAccounts[_to]) {\r\n                if (holderAccounts[msg.sender].tokens >= _value && _value > 0) {\r\n                    //first credit sender with points accrued so far.. must do this before number of held tokens changes\r\n                    calcCurPointsForAcct(msg.sender);\r\n                    holderAccounts[msg.sender].tokens -= _value;\r\n\r\n                    if (!holderAccounts[_to].alloced) {\r\n                        addAccount(_to);\r\n                    }\r\n                    //credit destination acct with points accrued so far.. must do this before number of held tokens changes\r\n                    calcCurPointsForAcct(_to);\r\n                    holderAccounts[_to].tokens += _value;\r\n\r\n                    Transfer(msg.sender, _to, _value);\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n        }\r\n\r\n\r\n        function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n                if ((_from == developers)\r\n                        &&  (now < vestTime)) {\r\n                        //statEvent(\"Tokens not yet vested.\");\r\n                        return false;\r\n                }\r\n\r\n                //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n                //if (holderAccounts[_from].tokens >= _value && allowed[_from][msg.sender] >= _value && holderAccounts[_to].tokens + _value > holderAccounts[_to].tokens) {\r\n                if (holderAccounts[_from].tokens >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n\r\n                    calcCurPointsForAcct(_from);\r\n                    holderAccounts[_from].tokens -= _value;\r\n\r\n                    if (!holderAccounts[_to].alloced) {\r\n                        addAccount(_to);\r\n                    }\r\n                    //credit destination acct with points accrued so far.. must do this before number of held tokens changes\r\n                    calcCurPointsForAcct(_to);\r\n                    holderAccounts[_to].tokens += _value;\r\n\r\n                    allowed[_from][msg.sender] -= _value;\r\n                    Transfer(_from, _to, _value);\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n        }\r\n\r\n\r\n        function balanceOf(address _owner) constant returns (uint256 balance) {\r\n                balance = holderAccounts[_owner].tokens;\r\n        }\r\n\r\n        function approve(address _spender, uint256 _value) returns (bool success) {\r\n                allowed[msg.sender][_spender] = _value;\r\n                Approval(msg.sender, _spender, _value);\r\n                return true;\r\n        }\r\n\r\n        function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n                return allowed[_owner][_spender];\r\n        }\r\n// ----------------------------------\r\n// END ERC20\r\n// ----------------------------------\r\n\r\n        // ----------------------------\r\n        // calc current points for a token holder; that is, points that are due to this token holder for all dividends\r\n        // received by the contract during the current \"period\". the period began the last time this fcn was called, at which\r\n        // time we updated the account's snapshot of the running point count, TotalFeesReceived. during the period the account's\r\n        // number of tokens must not have changed. so always call this fcn before changing the number of tokens.\r\n        // ----------------------------\r\n        function calcCurPointsForAcct(address _acct) internal {\r\n              holderAccounts[_acct].currentPoints += (TotalFeesReceived - holderAccounts[_acct].lastSnapshot) * holderAccounts[_acct].tokens;\r\n              holderAccounts[_acct].lastSnapshot = TotalFeesReceived;\r\n        }\r\n\r\n\r\n        // ---------------------------\r\n        // accept payment from a partner contract\r\n        // funds sent here are added to TotalFeesReceived\r\n        // WARNING! DO NOT CALL THIS FUNCTION LEST YOU LOSE YOUR MONEY\r\n        // ---------------------------\r\n        function () payable {\r\n                holdoverBalance += msg.value;\r\n                TotalFeesReceived += msg.value;\r\n                StatEventI(\"Payment\", msg.value);\r\n        }\r\n\r\n        // ---------------------------\r\n        // one never knows if this will come in handy.\r\n        // ---------------------------\r\n        function blackHole() payable {\r\n                StatEventI(\"adjusted\", msg.value);\r\n        }\r\n\r\n        // ----------------------------\r\n        // sender withdraw entire rewards/dividends\r\n        // ----------------------------\r\n        function withdrawDividends() public returns (uint _amount)\r\n        {\r\n                calcCurPointsForAcct(msg.sender);\r\n\r\n                _amount = holderAccounts[msg.sender].currentPoints / NewTokenSupply;\r\n                if (_amount <= payoutThreshold) {\r\n                        StatEventI(\"low Balance\", _amount);\r\n                        return;\r\n                } else {\r\n                        if ((msg.sender == developers)\r\n                                &&  (now < vestTime)) {\r\n                                StatEvent(\"Tokens not yet vested.\");\r\n                                _amount = 0;\r\n                                return;\r\n                        }\r\n\r\n                        uint _pointsUsed = _amount * NewTokenSupply;\r\n                        holderAccounts[msg.sender].currentPoints -= _pointsUsed;\r\n                        holdoverBalance -= _amount;\r\n                        if (!msg.sender.call.gas(rwGas).value(_amount)())\r\n                                throw;\r\n                }\r\n        }\r\n\r\n        // ----------------------------\r\n        // allow sender to transfer dividends\r\n        // ----------------------------\r\n        function transferDividends(address _to) returns (bool success)\r\n        {\r\n                if ((msg.sender == developers)\r\n                        &&  (now < vestTime)) {\r\n                        //statEvent(\"Tokens not yet vested.\");\r\n                        return false;\r\n                }\r\n                calcCurPointsForAcct(msg.sender);\r\n                if (holderAccounts[msg.sender].currentPoints == 0) {\r\n                        StatEvent(\"Zero balance\");\r\n                        return false;\r\n                }\r\n                if (!holderAccounts[_to].alloced) {\r\n                        addAccount(_to);\r\n                }\r\n                calcCurPointsForAcct(_to);\r\n                holderAccounts[_to].currentPoints += holderAccounts[msg.sender].currentPoints;\r\n                holderAccounts[msg.sender].currentPoints = 0;\r\n                StatEvent(\"Trasnfered Dividends\");\r\n                return true;\r\n        }\r\n\r\n\r\n\r\n        // ----------------------------\r\n        // set gas for operations\r\n        // ----------------------------\r\n        function setOpGas(uint _rw, uint _optXferGas, uint _optFcnGas)\r\n        {\r\n                if (msg.sender != owner && msg.sender != developers) {\r\n                        //StatEvent(\"only owner calls\");\r\n                        return;\r\n                } else {\r\n                        rwGas = _rw;\r\n                        optInXferGas = _optXferGas;\r\n                        optInFcnMinGas = _optFcnGas;\r\n                }\r\n        }\r\n\r\n\r\n        // ----------------------------\r\n        // check rewards.  pass in address of token holder\r\n        // ----------------------------\r\n        function checkDividends(address _addr) constant returns(uint _amount)\r\n        {\r\n                if (holderAccounts[_addr].alloced) {\r\n                   //don't call calcCurPointsForAcct here, cuz this is a constant fcn\r\n                   uint _currentPoints = holderAccounts[_addr].currentPoints +\r\n                        ((TotalFeesReceived - holderAccounts[_addr].lastSnapshot) * holderAccounts[_addr].tokens);\r\n                   _amount = _currentPoints / NewTokenSupply;\r\n\r\n                // low balance? let him see it -Etansky\r\n                  // if (_amount <= payoutThreshold) {\r\n                  //    _amount = 0;\r\n                  // }\r\n\r\n                }\r\n        }\r\n\r\n\r\n\r\n        // ----------------------------\r\n        // swap executor\r\n        // ----------------------------\r\n        function changeOwner(address _addr)\r\n        {\r\n                if (msg.sender != owner\r\n                        || settingsState == SettingStateValue.lockedRelease)\r\n                         throw;\r\n                owner = _addr;\r\n        }\r\n\r\n        // ----------------------------\r\n        // set developers account\r\n        // ----------------------------\r\n        function setDeveloper(address _addr)\r\n        {\r\n                if (msg.sender != owner\r\n                        || settingsState == SettingStateValue.lockedRelease)\r\n                         throw;\r\n                developers = _addr;\r\n        }\r\n\r\n        // ----------------------------\r\n        // set oldE4 Addresses\r\n        // ----------------------------\r\n        function setOldE4(address _oldE4, address _oldE4Recyle)\r\n        {\r\n                if (msg.sender != owner\r\n                        || settingsState == SettingStateValue.lockedRelease)\r\n                         throw;\r\n                oldE4 = _oldE4;\r\n                oldE4RecycleBin = _oldE4Recyle;\r\n        }\r\n\r\n        // ----------------------------\r\n        // get account info\r\n        // ----------------------------\r\n        function getAccountInfo(address _addr) constant returns(uint _tokens, uint _snapshot, uint _points)\r\n        {\r\n                _tokens = holderAccounts[_addr].tokens;\r\n                _snapshot = holderAccounts[_addr].lastSnapshot;\r\n                _points = holderAccounts[_addr].currentPoints;\r\n        }\r\n\r\n\r\n        // ----------------------------\r\n        // DEBUG ONLY - end this contract, suicide to developers\r\n        // ----------------------------\r\n        function haraKiri()\r\n        {\r\n                if (settingsState != SettingStateValue.debug)\r\n                        throw;\r\n                if (msg.sender != owner)\r\n                         throw;\r\n                suicide(developers);\r\n        }\r\n\r\n\r\n        // ----------------------------\r\n        // OPT IN FROM CLASSIC.\r\n        // All old token holders can opt into this new contract by calling this function.\r\n        // This \"transferFrom\"s tokens from the old addresses to the new recycleBin address\r\n        // which is a new address set up on the old contract.  Afterwhich new tokens\r\n        // are credited to the old holder.  Also the lastSnapShot is set to 0 then\r\n        // calcCredited points are called setting up the new signatoree all of his\r\n        // accrued dividends.\r\n        // ----------------------------\r\n        function optInFromClassic() public\r\n        {\r\n                if (oldE4 == address(0)) {\r\n                        StatEvent(\"config err\");\r\n                        return;\r\n                }\r\n                // 1. check balance of msg.sender in old contract.\r\n                address nrequester = msg.sender;\r\n\r\n                // 2. make sure account not already allocd (in fact, it's ok if it's allocd, so long\r\n                // as it is empty now. the reason for this check is cuz we are going to credit him with\r\n                // dividends, according to his token count, from the begin of time.\r\n                if (holderAccounts[nrequester].tokens != 0) {\r\n                        StatEvent(\"Account has already has tokens!\");\r\n                        return;\r\n                }\r\n\r\n                // 3. check his tok balance\r\n                Token iclassic = Token(oldE4);\r\n                uint _toks = iclassic.balanceOf(nrequester);\r\n                if (_toks == 0) {\r\n                        StatEvent(\"Nothing to do\");\r\n                        return;\r\n                }\r\n\r\n                // must be 100 percent of holdings\r\n                if (iclassic.allowance(nrequester, address(this)) < _toks) {\r\n                        StatEvent(\"Please approve this contract to transfer\");\r\n                        return;\r\n                }\r\n\r\n                // 4. before we do the transfer, make sure that we have at least enough gas for the\r\n                // transfer plus the remainder of this fcn.\r\n                if (msg.gas < optInXferGas + optInFcnMinGas)\r\n                        throw;\r\n\r\n                // 5. transfer his old toks to recyle bin\r\n                iclassic.transferFrom.gas(optInXferGas)(nrequester, oldE4RecycleBin, _toks);\r\n\r\n                // todo, error check?\r\n                if (iclassic.balanceOf(nrequester) == 0) {\r\n                        // success, add the account, set the tokens, set snapshot to zero\r\n                        if (!holderAccounts[nrequester].alloced)\r\n                                addAccount(nrequester);\r\n                        holderAccounts[nrequester].tokens = _toks * NewTokensPerOrigToken;\r\n                        holderAccounts[nrequester].lastSnapshot = 0;\r\n                        calcCurPointsForAcct(nrequester);\r\n                        numToksSwitchedOver += _toks;\r\n                        // no need to decrement points from a \"holding account\"\r\n                        // b/c there is no need to keep it.\r\n                        StatEvent(\"Success Switched Over\");\r\n                } else\r\n                        StatEvent(\"Transfer Error! please contact Dev team!\");\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"qState\",\"type\":\"uint8\"},{\"name\":\"_threshold\",\"type\":\"uint256\"},{\"name\":\"_rw\",\"type\":\"uint256\"},{\"name\":\"_optXferGas\",\"type\":\"uint256\"},{\"name\":\"_optFcnGas\",\"type\":\"uint256\"}],\"name\":\"applySettings\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"supply\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numToksSwitchedOver\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkDividends\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"developers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDividends\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rw\",\"type\":\"uint256\"},{\"name\":\"_optXferGas\",\"type\":\"uint256\"},{\"name\":\"_optFcnGas\",\"type\":\"uint256\"}],\"name\":\"setOpGas\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TotalFeesReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vestTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rwGas\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settingsState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"optInXferGas\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getAccountInfo\",\"outputs\":[{\"name\":\"_tokens\",\"type\":\"uint256\"},{\"name\":\"_snapshot\",\"type\":\"uint256\"},{\"name\":\"_points\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numAccounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"blackHole\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oldE4\",\"type\":\"address\"},{\"name\":\"_oldE4Recyle\",\"type\":\"address\"}],\"name\":\"setOldE4\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"haraKiri\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oldE4\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"optInFcnMinGas\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferDividends\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oldE4RecycleBin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"holdoverBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"optInFromClassic\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setDeveloper\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"StatEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"StatEventI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"E4Lava","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8f9ecb66d84a15962dea7676fcf8ba9cea6e8f5e666ac5a2c5649445feabf880"}]}