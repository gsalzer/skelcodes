{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.9;\r\n\r\ncontract SportsBet {\r\n    enum GameStatus { Open, Locked, Scored }\r\n    enum BookType { Spread, MoneyLine, OverUnder }\r\n    enum BetStatus { Open, Paid }\r\n\r\n    // indexing on a string causes issues with web3, so category has to be an int\r\n    event GameCreated(bytes32 indexed id, string home, \r\n        string away, uint16 indexed category, uint64 locktime);\r\n    event BidPlaced(bytes32 indexed game_id, BookType book, \r\n        address bidder, uint amount, bool home, int32 line);\r\n    event BetPlaced(bytes32 indexed game_id, BookType indexed book, \r\n        address indexed user, bool home, uint amount, int32 line);\r\n    event GameScored(bytes32 indexed game_id, int homeScore, int awayScore);\r\n    event Withdrawal(address indexed user, uint amount, uint timestamp);\r\n\r\n    struct Bid {\r\n        address bidder;\r\n        uint amount; /* in wei */\r\n        bool home; /* true=home, false=away */\r\n        int32 line;\r\n    }\r\n\r\n    struct Bet {\r\n        address home;\r\n        address away;\r\n        uint amount; /* in wei */\r\n        int32 line;\r\n        BetStatus status;\r\n    }\r\n\r\n    struct Book {\r\n        Bid[] homeBids;\r\n        Bid[] awayBids;\r\n        Bet[] bets;\r\n    }\r\n\r\n    struct GameResult {\r\n        int home;\r\n        int away;\r\n    }\r\n\r\n    struct Game {\r\n        bytes32 id;\r\n        string home;\r\n        string away;\r\n        uint16 category;\r\n        uint64 locktime;\r\n        GameStatus status;\r\n        mapping(uint => Book) books;\r\n        GameResult result;\r\n    }\r\n\r\n    address public owner;\r\n    Game[] games;\r\n    mapping(address => uint) public balances;\r\n\r\n    function SportsBet() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\tfunction createGame (string home, string away, uint16 category, uint64 locktime) returns (int) {\r\n        if (msg.sender != owner) return 1;\r\n        bytes32 id = getGameId(home, away, category, locktime);\r\n        mapping(uint => Book) books;\r\n        Bid[] memory homeBids;\r\n        Bid[] memory awayBids;\r\n        Bet[] memory bets;\r\n        GameResult memory result = GameResult(0,0);\r\n        Game memory game = Game(id, home, away, category, locktime, GameStatus.Open, result);\r\n        games.push(game);\r\n        GameCreated(id, home, away, category, locktime);\r\n        return -1;\r\n    }\r\n    \r\n    function cancelOpenBids(bytes32 game_id) private returns (int) {\r\n        Game game = getGameById(game_id);\r\n        Book book = game.books[uint(BookType.Spread)];\r\n\r\n        for (uint i=0; i < book.homeBids.length; i++) {\r\n            Bid bid = book.homeBids[i];\r\n            if (bid.amount == 0)\r\n                continue;\r\n            balances[bid.bidder] += bid.amount;\r\n            delete book.homeBids[i];\r\n        }\r\n        for (i=0; i < book.awayBids.length; i++) {\r\n            bid = book.awayBids[i];\r\n            if (bid.amount == 0)\r\n                continue;\r\n            balances[bid.bidder] += bid.amount;\r\n            delete book.awayBids[i];\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    function setGameResult (bytes32 game_id, int homeScore, int awayScore) returns (int) {\r\n        if (msg.sender != owner) return 1;\r\n\r\n        Game game = getGameById(game_id);\r\n        if (game.locktime > now) return 2;\r\n        if (game.status == GameStatus.Scored) return 3;\r\n\r\n        cancelOpenBids(game_id);\r\n\r\n        game.result.home = homeScore;\r\n        game.result.away = awayScore;\r\n        game.status = GameStatus.Scored;\r\n        GameScored(game_id, homeScore, awayScore);\r\n\r\n        // Currently only handles spread bets\r\n        Bet[] bets = game.books[uint(BookType.Spread)].bets;\r\n        int resultSpread = awayScore - homeScore;\r\n        resultSpread *= 10; // because bet.line is 10x the actual line\r\n        for (uint i = 0; i < bets.length; i++) {\r\n            Bet bet = bets[i];\r\n            if (resultSpread > bet.line) \r\n                balances[bet.away] += bet.amount * 2;\r\n            else if (resultSpread < bet.line)\r\n                balances[bet.home] += bet.amount * 2;\r\n            else { // draw\r\n                balances[bet.away] += bet.amount;\r\n                balances[bet.home] += bet.amount;\r\n            }\r\n            bet.status = BetStatus.Paid;\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    // This will eventually be expanded to include MoneyLine and OverUnder bets\r\n    // line is actually 10x the line to allow for half-point spreads\r\n    function bidSpread(bytes32 game_id, bool home, int32 line) payable returns (int) {\r\n        Game game = getGameById(game_id);\r\n        Book book = game.books[uint(BookType.Spread)];\r\n        Bid memory bid = Bid(msg.sender, msg.value, home, line);\r\n\r\n        // validate inputs: game status, gametime, line amount\r\n        if (game.status == GameStatus.Locked)\r\n            return 1;\r\n        if (now > game.locktime) {\r\n            game.status = GameStatus.Locked;    \r\n            cancelOpenBids(game_id);\r\n            return 2;\r\n        }\r\n        if (line % 5 != 0)\r\n            return 3;\r\n\r\n        Bid memory remainingBid = matchExistingBids(bid, book, home, game_id);\r\n\r\n        // Use leftover funds to place open bids (maker)\r\n        if (bid.amount > 0) {\r\n            Bid[] bidStack = home ? book.homeBids : book.awayBids;\r\n            addBidToStack(remainingBid, bidStack);\r\n            BidPlaced(game_id, BookType.Spread, remainingBid.bidder, remainingBid.amount, home, line);\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    // returning an array of structs is not allowed, so its time for a hackjob\r\n    // that returns a raw bytes dump of the combined home and away bids\r\n    // clients will have to parse the hex dump to get the bids out\r\n    // This function is for DEBUGGING PURPOSES ONLY. Using it in a production\r\n    // setting will return very large byte arrays that will consume your bandwidth\r\n    // if you are using Metamask or not running a full node  \r\n    function getOpenBids(bytes32 game_id) constant returns (bytes) {\r\n        Game game = getGameById(game_id);\r\n        Book book = game.books[uint(BookType.Spread)];\r\n        uint nBids = book.homeBids.length + book.awayBids.length;\r\n        bytes memory s = new bytes(57 * nBids);\r\n        uint k = 0;\r\n        for (uint i=0; i < nBids; i++) {\r\n            Bid bid;\r\n            if (i < book.homeBids.length)\r\n                bid = book.homeBids[i];\r\n            else\r\n                bid = book.awayBids[i - book.homeBids.length];\r\n            bytes20 bidder = bytes20(bid.bidder);\r\n            bytes32 amount = bytes32(bid.amount);\r\n            byte home = bid.home ? byte(1) : byte(0);\r\n            bytes4 line = bytes4(bid.line);\r\n\r\n            for (uint j=0; j < 20; j++) { s[k] = bidder[j]; k++; }\r\n            for (j=0; j < 32; j++) { s[k] = amount[j]; k++; }\r\n            s[k] = home; k++;\r\n            for (j=0; j < 4; j++) { s[k] = line[j]; k++; }\r\n\r\n        }\r\n\r\n        return s;\r\n    }\r\n\r\n    // Unfortunately this function had too many local variables, so a \r\n    // bunch of unruly code had to be used to eliminate some variables\r\n    function getOpenBidsByLine(bytes32 game_id) constant returns (bytes) {\r\n        Book book = getBook(game_id, BookType.Spread);\r\n\r\n        uint away_lines_length = getUniqueLineCount(book.awayBids);\r\n        uint home_lines_length = getUniqueLineCount(book.homeBids);\r\n\r\n        // group bid amounts by line\r\n        mapping(int32 => uint)[2] line_amounts;\r\n        int32[] memory away_lines = new int32[](away_lines_length);\r\n        int32[] memory home_lines = new int32[](home_lines_length);\r\n\r\n        uint k = 0;\r\n        for (uint i=0; i < book.homeBids.length; i++) {\r\n            Bid bid = book.homeBids[i]; \r\n            if (bid.amount == 0) // ignore deleted bids\r\n                continue;\r\n            if (line_amounts[0][bid.line] == 0) {\r\n                home_lines[k] = bid.line;\r\n                k++;\r\n            }\r\n            line_amounts[0][bid.line] += bid.amount;\r\n        }\r\n        k = 0;\r\n        for (i=0; i < book.awayBids.length; i++) {\r\n            bid = book.awayBids[i]; \r\n            if (bid.amount == 0) // ignore deleted bids\r\n                continue;\r\n            if (line_amounts[1][bid.line] == 0) {\r\n                away_lines[k] = bid.line;\r\n                k++;\r\n            }\r\n            line_amounts[1][bid.line] += bid.amount;\r\n        }\r\n\r\n        bytes memory s = new bytes(37 * (home_lines_length + away_lines_length));\r\n        k = 0;\r\n        for (i=0; i < home_lines_length; i++) {\r\n            bytes4 line = bytes4(home_lines[i]);\r\n            bytes32 amount = bytes32(line_amounts[0][home_lines[i]]);\r\n            for (uint j=0; j < 32; j++) { s[k] = amount[j]; k++; }\r\n            s[k] = byte(1); k++;\r\n            for (j=0; j < 4; j++) { s[k] = line[j]; k++; }\r\n        }\r\n        for (i=0; i < away_lines_length; i++) {\r\n            line = bytes4(away_lines[i]);\r\n            amount = bytes32(line_amounts[1][away_lines[i]]);\r\n            for (j=0; j < 32; j++) { s[k] = amount[j]; k++; }\r\n            s[k] = byte(0); k++;\r\n            for (j=0; j < 4; j++) { s[k] = line[j]; k++; }\r\n        }\r\n        \r\n        return s;\r\n    }\r\n\r\n    function getUniqueLineCount(Bid[] stack) private constant returns (uint) {\r\n        uint line_count = 0;\r\n        int lastIndex = -1;\r\n        for (uint i=0; i < stack.length; i++) {\r\n            if (stack[i].amount == 0) // ignore deleted bids\r\n                continue;\r\n            if (lastIndex == -1)\r\n                line_count++;\r\n            else if (stack[i].line != stack[uint(lastIndex)].line)\r\n                line_count++;\r\n            lastIndex = int(i);\r\n        }\r\n        return line_count;\r\n    }\r\n\r\n    function getOpenBidsByBidder(bytes32 game_id, address bidder) constant returns (bytes) {\r\n        Game game = getGameById(game_id);\r\n        Book book = game.books[uint(BookType.Spread)];\r\n        uint nBids = book.homeBids.length + book.awayBids.length;\r\n        uint myBids = 0;\r\n\r\n        // count number of bids by bidder\r\n        for (uint i=0; i < nBids; i++) {\r\n            Bid bid = i < book.homeBids.length ? book.homeBids[i] : book.awayBids[i - book.homeBids.length];\r\n            if (bid.bidder == bidder)\r\n                myBids += 1;\r\n        }\r\n\r\n        bytes memory s = new bytes(37 * myBids);\r\n        uint k = 0;\r\n        for (i=0; i < nBids; i++) {\r\n            bid = i < book.homeBids.length ? book.homeBids[i] : book.awayBids[i - book.homeBids.length];\r\n            if (bid.bidder != bidder) // ignore other people's bids\r\n                continue; \r\n            bytes32 amount = bytes32(bid.amount);\r\n            byte home = bid.home ? byte(1) : byte(0);\r\n            bytes4 line = bytes4(bid.line);\r\n\r\n            for (uint j=0; j < 32; j++) { s[k] = amount[j]; k++; }\r\n            s[k] = home; k++;\r\n            for (j=0; j < 4; j++) { s[k] = line[j]; k++; }\r\n        }\r\n        return s;\r\n    }\r\n        \r\n\r\n    // for functions throwing a stack too deep error, this helper will free up 2 local variable spots\r\n    function getBook(bytes32 game_id, BookType book_type) constant private returns (Book storage) {\r\n        Game game = getGameById(game_id);\r\n        Book book = game.books[uint(book_type)];\r\n        return book;\r\n    }\r\n    \r\n    function matchExistingBids(Bid bid, Book storage book, bool home, bytes32 game_id) private returns (Bid) {\r\n        Bid[] matchStack = home ?  book.awayBids : book.homeBids;\r\n        int i = int(matchStack.length) - 1;\r\n        while (i >= 0 && bid.amount > 0) {\r\n            uint j = uint(i);\r\n            if (matchStack[j].amount == 0) { // deleted bids\r\n                i--;\r\n                continue;\r\n            }\r\n            if (-bid.line < matchStack[j].line)\r\n                break;\r\n\r\n            address homeAddress = home ? bid.bidder : matchStack[j].bidder;\r\n            address awayAddress = home ? matchStack[j].bidder : bid.bidder;\r\n            int32 betLine = home ? -matchStack[j].line : matchStack[j].line;\r\n            uint betAmount;\r\n            if (bid.amount < matchStack[j].amount) {\r\n                betAmount = bid.amount;\r\n                matchStack[j].amount -= betAmount;\r\n            }\r\n            else {\r\n                betAmount = matchStack[j].amount;\r\n                delete matchStack[j];\r\n            }\r\n            bid.amount -= betAmount;\r\n\r\n            Bet memory bet = Bet(homeAddress, awayAddress, betAmount, betLine, BetStatus.Open);\r\n            book.bets.push(bet);\r\n            BetPlaced(game_id, BookType.Spread, homeAddress, true, betAmount, betLine);\r\n            BetPlaced(game_id, BookType.Spread, awayAddress, false, betAmount, -betLine);\r\n            i--;\r\n        }\r\n        return bid;\r\n    }\r\n\r\n    function cancelBid(address bidder, bytes32 game_id, int32 line, bool home) returns (bool) {\r\n        Game game = getGameById(game_id);\r\n        Book book = game.books[uint(BookType.Spread)];\r\n        Bid[] stack = home ? book.homeBids : book.awayBids;\r\n\r\n        // Delete bid in stack, refund amount to user\r\n        bool found = false;\r\n        for (uint i=0; i < stack.length; i++) {\r\n            if (stack[i].bidder == bidder && stack[i].line == line) {\r\n                balances[bidder] += stack[i].amount;\r\n                delete stack[i];\r\n                found = true;\r\n            }\r\n        }\r\n        return found;\r\n    }\r\n\r\n    function kill () {\r\n        if (msg.sender == owner) selfdestruct(owner);\r\n    }\r\n\r\n    function getGameId (string home, string away, uint16 category, uint64 locktime) constant returns (bytes32) {\r\n        uint i = 0;\r\n        bytes memory a = bytes(home);\r\n        bytes memory b = bytes(away);\r\n        bytes2 c = bytes2(category);\r\n        bytes8 d = bytes8(locktime);\r\n\r\n        uint length = a.length + b.length + c.length + d.length;\r\n        bytes memory toHash = new bytes(length);\r\n        uint k = 0;\r\n        for (i = 0; i < a.length; i++) { toHash[k] = a[i]; k++; }\r\n        for (i = 0; i < b.length; i++) { toHash[k] = b[i]; k++; }\r\n        for (i = 0; i < c.length; i++) { toHash[k] = c[i]; k++; }\r\n        for (i = 0; i < d.length; i++) { toHash[k] = d[i]; k++; }\r\n        return keccak256(toHash);\r\n        \r\n    }\r\n    \r\n    function getActiveGames () constant returns (bytes32[]) {\r\n        bytes32[] memory game_ids = new bytes32[](games.length);\r\n        for (uint i=0; i < games.length; i++) {\r\n            game_ids[i] = (games[i].id);\r\n        }\r\n        return game_ids;\r\n    }\r\n        \r\n    function addBidToStack(Bid bid, Bid[] storage stack) private returns (int) {\r\n        stack.push(bid); // make stack one item larger\r\n\r\n        if (stack.length <= 1)\r\n            return 0;\r\n\r\n        // insert into sorted stack\r\n        uint i = stack.length - 2;\r\n        uint lastIndex = stack.length - 1;\r\n        while (true) {\r\n            if (stack[i].amount == 0) { // ignore deleted bids\r\n                if (i == 0)\r\n                    break;\r\n                i--;\r\n                continue;\r\n            }\r\n            if (stack[i].line > bid.line)\r\n                break;\r\n            stack[lastIndex] = stack[i];\r\n            lastIndex = i;\r\n\r\n            // uint exhibits undefined behavior when you take it negative\r\n            // so we have to break manually\r\n            if (i == 0) \r\n                break;\r\n            i--;\r\n        }\r\n        stack[lastIndex] = bid;\r\n        return -1;\r\n    }\r\n    \r\n    function getGameById(bytes32 game_id) private returns (Game storage) {\r\n        bool game_exists = false;\r\n        for (uint i = 0; i < games.length; i++) {\r\n            if (games[i].id == game_id) {\r\n                Game game = games[i];\r\n                game_exists = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!game_exists)\r\n            throw;\r\n        return game;\r\n    }\r\n\r\n\r\n    function withdraw() returns (int) {\r\n        var balance = balances[msg.sender];\r\n        balances[msg.sender] = 0;\r\n        if (!msg.sender.send(balance)) {\r\n            balances[msg.sender] = balance;\r\n            return 1;\r\n        }\r\n        Withdrawal(msg.sender, balance, now);\r\n        return -1;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getActiveGames\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"game_id\",\"type\":\"bytes32\"}],\"name\":\"getOpenBids\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"game_id\",\"type\":\"bytes32\"}],\"name\":\"getOpenBidsByLine\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"game_id\",\"type\":\"bytes32\"},{\"name\":\"home\",\"type\":\"bool\"},{\"name\":\"line\",\"type\":\"int32\"}],\"name\":\"bidSpread\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"home\",\"type\":\"string\"},{\"name\":\"away\",\"type\":\"string\"},{\"name\":\"category\",\"type\":\"uint16\"},{\"name\":\"locktime\",\"type\":\"uint64\"}],\"name\":\"getGameId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"game_id\",\"type\":\"bytes32\"},{\"name\":\"bidder\",\"type\":\"address\"}],\"name\":\"getOpenBidsByBidder\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"home\",\"type\":\"string\"},{\"name\":\"away\",\"type\":\"string\"},{\"name\":\"category\",\"type\":\"uint16\"},{\"name\":\"locktime\",\"type\":\"uint64\"}],\"name\":\"createGame\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bidder\",\"type\":\"address\"},{\"name\":\"game_id\",\"type\":\"bytes32\"},{\"name\":\"line\",\"type\":\"int32\"},{\"name\":\"home\",\"type\":\"bool\"}],\"name\":\"cancelBid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"game_id\",\"type\":\"bytes32\"},{\"name\":\"homeScore\",\"type\":\"int256\"},{\"name\":\"awayScore\",\"type\":\"int256\"}],\"name\":\"setGameResult\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"home\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"away\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"category\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"locktime\",\"type\":\"uint64\"}],\"name\":\"GameCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"game_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"book\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"home\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"line\",\"type\":\"int32\"}],\"name\":\"BidPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"game_id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"book\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"home\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"line\",\"type\":\"int32\"}],\"name\":\"BetPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"game_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"homeScore\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"awayScore\",\"type\":\"int256\"}],\"name\":\"GameScored\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"}]","ContractName":"SportsBet","CompilerVersion":"v0.4.9+commit.364da425","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d2fa93b3e4c7633966ea571a246afad27ef6d05eb8f62b223508849259bfc91b"}]}