{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11; // optimization runs: 200, evm version: petersburg\r\n\r\n\r\ninterface DharmaSmartWalletFactoryV1Interface {\r\n  // Fires an event when a new smart wallet is deployed and initialized.\r\n  event SmartWalletDeployed(address wallet, address userSigningKey);\r\n\r\n  function newSmartWallet(\r\n    address userSigningKey\r\n  ) external returns (address wallet);\r\n  \r\n  function getNextSmartWallet(\r\n    address userSigningKey\r\n  ) external view returns (address wallet);\r\n}\r\n\r\n\r\ninterface DharmaSmartWalletInitializer {\r\n  function initialize(address userSigningKey) external;\r\n}\r\n\r\n\r\n/**\r\n * @title UpgradeBeaconProxyV1Prototype\r\n * @author 0age\r\n * @notice This contract delegates all logic, including initialization, to an\r\n * implementation contract specified by a hard-coded \"upgrade beacon\" contract.\r\n * Note that this implementation can be reduced in size by stripping out the\r\n * metadata hash, or even more significantly by using a minimal upgrade beacon\r\n * proxy implemented using raw EVM opcodes.\r\n */\r\ncontract UpgradeBeaconProxyV1Prototype {\r\n  // Set upgrade beacon address as a constant (i.e. not in contract storage).\r\n  address private constant _UPGRADE_BEACON = address(\r\n    0x5BF07ceDF1296B1C11966832c3e75895ad6E1E2a\r\n  );\r\n\r\n  /**\r\n   * @notice In the constructor, perform initialization via delegatecall to the\r\n   * implementation set on the upgrade beacon, supplying initialization calldata\r\n   * as a constructor argument. The deployment will revert and pass along the\r\n   * revert reason in the event that this initialization delegatecall reverts.\r\n   * @param initializationCalldata Calldata to supply when performing the\r\n   * initialization delegatecall.\r\n   */\r\n  constructor(bytes memory initializationCalldata) public payable {\r\n    // Delegatecall into the implementation, supplying initialization calldata.\r\n    (bool ok, ) = _implementation().delegatecall(initializationCalldata);\r\n    \r\n    // Revert and include revert data if delegatecall to implementation reverts.\r\n    if (!ok) {\r\n      assembly {\r\n        returndatacopy(0, 0, returndatasize)\r\n        revert(0, returndatasize)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice In the fallback, delegate execution to the implementation set on\r\n   * the upgrade beacon.\r\n   */\r\n  function () external payable {\r\n    // Delegate execution to implementation contract provided by upgrade beacon.\r\n    _delegate(_implementation());\r\n  }\r\n\r\n  /**\r\n   * @notice Private view function to get the current implementation from the\r\n   * upgrade beacon. This is accomplished via a staticcall to the beacon with no\r\n   * data, and the beacon will return an abi-encoded implementation address.\r\n   * @return implementation Address of the implementation.\r\n   */\r\n  function _implementation() private view returns (address implementation) {\r\n    // Get the current implementation address from the upgrade beacon.\r\n    (bool ok, bytes memory returnData) = _UPGRADE_BEACON.staticcall(\"\");\r\n    \r\n    // Revert and pass along revert message if call to upgrade beacon reverts.\r\n    require(ok, string(returnData));\r\n\r\n    // Set the implementation to the address returned from the upgrade beacon.\r\n    implementation = abi.decode(returnData, (address));\r\n  }\r\n\r\n  /**\r\n   * @notice Private function that delegates execution to an implementation\r\n   * contract. This is a low level function that doesn't return to its internal\r\n   * call site. It will return whatever is returned by the implementation to the\r\n   * external caller, reverting and returning the revert data if implementation\r\n   * reverts.\r\n   * @param implementation Address to delegate.\r\n   */\r\n  function _delegate(address implementation) private {\r\n    assembly {\r\n      // Copy msg.data. We take full control of memory in this inline assembly\r\n      // block because it will not return to Solidity code. We overwrite the\r\n      // Solidity scratch pad at memory position 0.\r\n      calldatacopy(0, 0, calldatasize)\r\n\r\n      // Delegatecall to the implementation, supplying calldata and gas.\r\n      // Out and outsize are set to zero - instead, use the return buffer.\r\n      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\r\n\r\n      // Copy the returned data from the return buffer.\r\n      returndatacopy(0, 0, returndatasize)\r\n\r\n      switch result\r\n      // Delegatecall returns 0 on error.\r\n      case 0 { revert(0, returndatasize) }\r\n      default { return(0, returndatasize) }\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title DharmaSmartWalletFactoryV1Prototype\r\n * @author 0age\r\n * @notice This contract deploys new Dharma Smart Wallet instances as \"Upgrade\r\n * Beacon\" proxies that reference a shared implementation contract specified by\r\n * the Dharma Upgrade Beacon contract.\r\n */\r\ncontract DharmaSmartWalletFactoryV1Prototype is DharmaSmartWalletFactoryV1Interface {\r\n  // Use Dharma Smart Wallet initializer to construct initialization calldata.\r\n  DharmaSmartWalletInitializer private _INITIALIZER;\r\n\r\n  /**\r\n   * @notice Deploy a new smart wallet address using the provided user signing\r\n   * key.\r\n   * @param userSigningKey address The user signing key, supplied as a\r\n   * constructor argument.\r\n   * @return The address of the new smart wallet.\r\n   */\r\n  function newSmartWallet(\r\n    address userSigningKey\r\n  ) external returns (address wallet) {\r\n    // Get initialization calldata from initialize selector & user signing key.\r\n    bytes memory initializationCalldata = abi.encodeWithSelector(\r\n      _INITIALIZER.initialize.selector,\r\n      userSigningKey\r\n    );\r\n    \r\n    // Initialize and deploy new user smart wallet as an Upgrade Beacon proxy.\r\n    wallet = _deployUpgradeBeaconProxyInstance(initializationCalldata);\r\n\r\n    // Emit an event to signal the creation of the new smart wallet.\r\n    emit SmartWalletDeployed(wallet, userSigningKey);\r\n  }\r\n\r\n  /**\r\n   * @notice View function to find the address of the next smart wallet address\r\n   * that will be deployed for a given user signing key. Note that a new value\r\n   * will be returned if a particular user signing key has been used before.\r\n   * @param userSigningKey address The user signing key, supplied as a\r\n   * constructor argument.\r\n   * @return The future address of the next smart wallet.\r\n   */\r\n  function getNextSmartWallet(\r\n    address userSigningKey\r\n  ) external view returns (address wallet) {\r\n    // Get initialization calldata from initialize selector & user signing key.\r\n    bytes memory initializationCalldata = abi.encodeWithSelector(\r\n      _INITIALIZER.initialize.selector,\r\n      userSigningKey\r\n    );\r\n    \r\n    // Determine the user's smart wallet address based on the user signing key.\r\n    wallet = _computeNextAddress(initializationCalldata);\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to deploy an upgrade beacon proxy via `CREATE2`.\r\n   * @param initializationCalldata bytes The calldata that will be supplied to\r\n   * the `DELEGATECALL` from the deployed contract to the implementation set on\r\n   * the upgrade beacon during contract creation.\r\n   * @return The address of the newly-deployed upgrade beacon proxy.\r\n   */\r\n  function _deployUpgradeBeaconProxyInstance(\r\n    bytes memory initializationCalldata\r\n  ) private returns (address upgradeBeaconProxyInstance) {\r\n    // Place creation code and constructor args of new proxy instance in memory.\r\n    bytes memory initCode = abi.encodePacked(\r\n      type(UpgradeBeaconProxyV1Prototype).creationCode,\r\n      abi.encode(initializationCalldata)\r\n    );\r\n\r\n    // Get salt to use during deployment using the supplied initialization code.\r\n    (uint256 salt, ) = _getSaltAndTarget(initCode);\r\n\r\n    // Deploy the new upgrade beacon proxy contract using `CREATE2`.\r\n    assembly {\r\n      let encoded_data := add(0x20, initCode) // load initialization code.\r\n      let encoded_size := mload(initCode)     // load the init code's length.\r\n      upgradeBeaconProxyInstance := create2(  // call `CREATE2` w/ 4 arguments.\r\n        callvalue,                            // forward any supplied endowment.\r\n        encoded_data,                         // pass in initialization code.\r\n        encoded_size,                         // pass in init code's length.\r\n        salt                                  // pass in the salt value.\r\n      )\r\n\r\n      // Pass along failure message and revert if contract deployment fails.\r\n      if iszero(upgradeBeaconProxyInstance) {\r\n        returndatacopy(0, 0, returndatasize)\r\n        revert(0, returndatasize)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Private view function for finding the address of the next upgrade\r\n   * beacon proxy that will be deployed, given a particular initialization\r\n   * calldata payload.\r\n   * @param initializationCalldata bytes The calldata that will be supplied to\r\n   * the `DELEGATECALL` from the deployed contract to the implementation set on\r\n   * the upgrade beacon during contract creation.\r\n   * @return The address of the next upgrade beacon proxy contract with the\r\n   * given initialization calldata.\r\n   */\r\n  function _computeNextAddress(\r\n    bytes memory initializationCalldata\r\n  ) private view returns (address target) {\r\n    // Place creation code and constructor args of the proxy instance in memory.\r\n    bytes memory initCode = abi.encodePacked(\r\n      type(UpgradeBeaconProxyV1Prototype).creationCode,\r\n      abi.encode(initializationCalldata)\r\n    );\r\n\r\n    // Get target address using the constructed initialization code.\r\n    (, target) = _getSaltAndTarget(initCode);\r\n  }\r\n\r\n  /**\r\n   * @notice Private function for determining the salt and the target deployment\r\n   * address for the next deployed contract (using `CREATE2`) based on the\r\n   * contract creation code.\r\n   */\r\n  function _getSaltAndTarget(\r\n    bytes memory initCode\r\n  ) private view returns (uint256 nonce, address target) {\r\n    // Get the keccak256 hash of the init code for address derivation.\r\n    bytes32 initCodeHash = keccak256(initCode);\r\n\r\n    // Set the initial nonce to be provided when constructing the salt.\r\n    nonce = 0;\r\n    \r\n    // Declare variable for code size of derived address.\r\n    uint256 codeSize;\r\n\r\n    // Loop until an contract deployment address with no code has been found.\r\n    while (true) {\r\n      target = address(            // derive the target deployment address.\r\n        uint160(                   // downcast to match the address type.\r\n          uint256(                 // cast to uint to truncate upper digits.\r\n            keccak256(             // compute CREATE2 hash using 4 inputs.\r\n              abi.encodePacked(    // pack all inputs to the hash together.\r\n                bytes1(0xff),      // pass in the control character.\r\n                address(this),     // pass in the address of this contract.\r\n                nonce,              // pass in the salt from above.\r\n                initCodeHash       // pass in hash of contract creation code.\r\n              )\r\n            )\r\n          )\r\n        )\r\n      );\r\n\r\n      // Determine if a contract is already deployed to the target address.\r\n      assembly { codeSize := extcodesize(target) }\r\n\r\n      // Exit the loop if no contract is deployed to the target address.\r\n      if (codeSize == 0) {\r\n        break;\r\n      }\r\n\r\n      // Otherwise, increment the nonce and derive a new salt.\r\n      nonce++;\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userSigningKey\",\"type\":\"address\"}],\"name\":\"newSmartWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userSigningKey\",\"type\":\"address\"}],\"name\":\"getNextSmartWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userSigningKey\",\"type\":\"address\"}],\"name\":\"SmartWalletDeployed\",\"type\":\"event\"}]","ContractName":"DharmaSmartWalletFactoryV1Prototype","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://e8fb4bfe10d5dfdd15c43841fd6bb45ed99b206f55fc0a1b6686d53d1d3e4920"}]}