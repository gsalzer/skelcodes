{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.15;\r\n\r\n// https://github.com/makerdao/dss/blob/master/src/jug.sol\r\ncontract JugAbstract {\r\n    // mapping (address => uint) public wards;\r\n    function wards(address) public view returns (uint256);\r\n    function rely(address) external;\r\n    function deny(address) external;\r\n    struct Ilk {\r\n        uint256 duty;\r\n        uint256  rho;\r\n    }\r\n    // mapping (bytes32 => Ilk) public ilks;\r\n    function ilks(bytes32) public view returns (uint256, uint256);\r\n    // VatLike public vat;\r\n    function vat() public view returns (address);\r\n    // address public vow;\r\n    function vow() public view returns (address);\r\n    // uint256 public base;\r\n    function base() public view returns (address);\r\n    // uint256 constant ONE = 10 ** 27;\r\n    function ONE() public view returns (uint256);\r\n    function init(bytes32) external;\r\n    function file(bytes32, bytes32, uint256) external;\r\n    function file(bytes32, uint256) external;\r\n    function file(bytes32, address) external;\r\n    function drip(bytes32) external returns (uint256);\r\n}\r\n\r\ncontract PotAbstract {\r\n    // mapping (address => uint256) public wards;\r\n    function wards(address) public view returns (uint256);\r\n    function rely(address) external;\r\n    function deny(address) external;\r\n    // mapping (address => uint256) public pie;  // user Savings Dai\r\n    function pie(address) public view returns (uint256);\r\n    // uint256 public Pie;  // total Savings Dai\r\n    function Pie() public view returns (uint256);\r\n    // uint256 public dsr;  // the Dai Savings Rate\r\n    function dsr() public view returns (uint256);\r\n    // uint256 public chi;  // the Rate Accumulator\r\n    function chi() public view returns (uint256);\r\n    // VatAbstract public vat;  // CDP engine\r\n    function vat() public view returns (address);\r\n    // address public vow;  // debt engine\r\n    function vow() public view returns (address);\r\n    // uint256 public rho;  // time of last drip\r\n    function rho() public view returns (uint256);\r\n    // uint256 public live;  // Access Flag\r\n    function live() public view returns (uint256);\r\n    function file(bytes32, uint256) external;\r\n    function file(bytes32, address) external;\r\n    function cage() external;\r\n    function drip() external returns (uint256);\r\n    function join(uint256) external;\r\n    function exit(uint256) external;\r\n}\r\n\r\n// https://github.com/makerdao/dss/blob/master/src/pot.sol\r\ncontract PotHelper {\r\n\r\n    PotAbstract pa;\r\n    \r\n    constructor(address pot) public {\r\n        pa = PotAbstract(pot);\r\n    }\r\n\r\n    // https://github.com/makerdao/dss/blob/master/src/pot.sol#L79\r\n    uint256 constant ONE = 10 ** 27;\r\n    \r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = mul(x, y) / ONE;\r\n    }\r\n\r\n    function rpow(uint x, uint n, uint base) internal pure returns (uint z) {\r\n        assembly {\r\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\r\n            default {\r\n                switch mod(n, 2) case 0 { z := base } default { z := x }\r\n                let half := div(base, 2)  // for rounding.\r\n                for { n := div(n, 2) } n { n := div(n,2) } {\r\n                    let xx := mul(x, x)\r\n                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\r\n                    let xxRound := add(xx, half)\r\n                    if lt(xxRound, xx) { revert(0,0) }\r\n                    x := div(xxRound, base)\r\n                    if mod(n,2) {\r\n                        let zx := mul(z, x)\r\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\r\n                        let zxRound := add(zx, half)\r\n                        if lt(zxRound, zx) { revert(0,0) }\r\n                        z := div(zxRound, base)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // View function for calculating value of chi iff drip() is called in the same block.\r\n    function drop() external view returns (uint256) {\r\n        if (now == pa.rho()) return pa.chi();\r\n        return rmul(rpow(pa.dsr(), now - pa.rho(), ONE), pa.chi());\r\n    }\r\n\r\n    // Pass the Pot Abstract for additional operations\r\n    function pot() external view returns (PotAbstract) {\r\n        return pa;\r\n    }\r\n}\r\n\r\ncontract VowAbstract {\r\n    // mapping (address => uint) public wards;\r\n    function wards(address) public view returns (uint256);\r\n    function rely(address usr) external;\r\n    function deny(address usr) external;\r\n    // VatAbstract public vat;\r\n    function vat() public view returns (address);\r\n    // FlapAbstract public flapper;\r\n    function flapper() public view returns (address);\r\n    // FlopAbstract public flopper;\r\n    function flopper() public view returns (address);\r\n    // mapping (uint256 => uint256) public sin; // debt queue\r\n    function sin(uint256) public view returns (uint256);\r\n    // uint256 public Sin;   // queued debt          [rad]\r\n    function Sin() public view returns (uint256);\r\n    // uint256 public Ash;\r\n    function Ash() public view returns (uint256);\r\n    // uint256 public wait;  // flop delay\r\n    function wait() public view returns (uint256);\r\n    // uint256 public dump;  // flop initial lot size  [wad]\r\n    function dump() public view returns (uint256);\r\n    // uint256 public sump;  // flop fixed bid size    [rad]\r\n    function sump() public view returns (uint256);\r\n    // uint256 public bump;  // flap fixed lot size    [rad]\r\n    function bump() public view returns (uint256);\r\n    // uint256 public hump;  // surplus buffer       [rad]\r\n    function hump() public view returns (uint256);\r\n    // uint256 public live;\r\n    function live() public view returns (uint256);\r\n    function file(bytes32, uint256) external;\r\n    function file(bytes32, address) external;\r\n    function fess(uint256) external;\r\n    function flog(uint256) external;\r\n    function heal(uint256) external;\r\n    function kiss(uint256) external;\r\n    function flop() external returns (uint256);\r\n    function flap() external returns (uint256);\r\n    function cage() external;\r\n}\r\n\r\ncontract VatAbstract {\r\n    // mapping (address => uint) public wards;\r\n    function wards(address) public view returns (uint256);\r\n    function rely(address) external;\r\n    function deny(address) external;\r\n    struct Ilk {\r\n        uint256 Art;   // Total Normalised Debt     [wad]\r\n        uint256 rate;  // Accumulated Rates         [ray]\r\n        uint256 spot;  // Price with Safety Margin  [ray]\r\n        uint256 line;  // Debt Ceiling              [rad]\r\n        uint256 dust;  // Urn Debt Floor            [rad]\r\n    }\r\n    struct Urn {\r\n        uint256 ink;   // Locked Collateral  [wad]\r\n        uint256 art;   // Normalised Debt    [wad]\r\n    }\r\n    // mapping (address => mapping (address => uint256)) public can;\r\n    function can(address, address) public view returns (uint256);\r\n    function hope(address) external;\r\n    function nope(address) external;\r\n    // mapping (bytes32 => Ilk) public ilks;\r\n    function ilks(bytes32) external view returns (uint256, uint256, uint256, uint256, uint256);\r\n    // mapping (bytes32 => mapping (address => Urn)) public urns;\r\n    function urns(bytes32, address) public view returns (uint256, uint256);\r\n    // mapping (bytes32 => mapping (address => uint256)) public gem;  // [wad]\r\n    function gem(bytes32, address) public view returns (uint256);\r\n    // mapping (address => uint256) public dai;  // [rad]\r\n    function dai(address) public view returns (uint256);\r\n    // mapping (address => uint256) public sin;  // [rad]\r\n    function sin(address) public view returns (uint256);\r\n    // uint256 public debt;  // Total Dai Issued    [rad]\r\n    function debt() public view returns (uint256);\r\n    // uint256 public vice;  // Total Unbacked Dai  [rad]\r\n    function vice() public view returns (uint256);\r\n    // uint256 public Line;  // Total Debt Ceiling  [rad]\r\n    function Line() public view returns (uint256);\r\n    // uint256 public live;  // Access Flag\r\n    function live() public view returns (uint256);\r\n    function init(bytes32) external;\r\n    function file(bytes32, uint256) external;\r\n    function file(bytes32, bytes32, uint256) external;\r\n    function cage() external;\r\n    function slip(bytes32, address, int256) external;\r\n    function flux(bytes32, address, address, uint256) external;\r\n    function move(address, address, uint256) external;\r\n    function frob(bytes32, address, address, address, int256, int256) external;\r\n    function fork(bytes32, address, address, int256, int256) external;\r\n    function grab(bytes32, address, address, address, int256, int256) external;\r\n    function heal(uint256) external;\r\n    function suck(address, address, uint256) external;\r\n    function fold(bytes32, address, int256) external;\r\n}\r\n\r\n\r\n// ༼つಠ益ಠ༽つ ─=≡Σ◈)) HADAIKEN\r\n//\r\n// Optimized contract for performing some or all of the functions that\r\n//   keep Multi-Collateral Dai running.\r\ncontract Hadaiken {\r\n\r\n    address constant internal JUG = address(0x19c0976f590D67707E62397C87829d896Dc0f1F1);\r\n    address constant internal POT = address(0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7);\r\n    address constant internal VAT = address(0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B);\r\n    address constant internal VOW = address(0xA950524441892A31ebddF91d3cEEFa04Bf454466);\r\n\r\n    JugAbstract constant internal jug  = JugAbstract(JUG);\r\n    PotAbstract constant internal pot  = PotAbstract(POT);\r\n    VowAbstract constant internal vow  = VowAbstract(VOW);\r\n    VatAbstract constant internal vat  = VatAbstract(VAT);\r\n    PotHelper            internal poth;\r\n\r\n    bytes32 constant internal ETH_A = bytes32(\"ETH-A\");\r\n    bytes32 constant internal BAT_A = bytes32(\"BAT-A\");\r\n\r\n    constructor() public {\r\n        poth = new PotHelper(POT);\r\n    }\r\n\r\n    // Raw System Debt\r\n    function _rawSysDebt() internal view returns (uint256) {\r\n        return (vat.sin(VOW) - vow.Sin() - vow.Ash());\r\n    }\r\n\r\n    function rawSysDebt() external view returns (uint256) {\r\n        return _rawSysDebt();\r\n    }\r\n\r\n    function _sysSurplus() internal view returns (uint256) {\r\n        return (vat.sin(VOW) + vow.bump() + vow.hump());\r\n    }\r\n\r\n    function  sysSurplus() external view returns (uint256) {\r\n        return _sysSurplus();\r\n    }\r\n\r\n    // Saves you money.\r\n    function heal() external {\r\n        _heal();\r\n    }\r\n\r\n    // Returns the amount of debt healed if you're curious about that sort of thing.\r\n    function healStat() external returns (uint256 sd) {\r\n        sd = _rawSysDebt();\r\n        _heal();\r\n    }\r\n\r\n    // No return here. I want to save gas and who cares.\r\n    function _heal() internal {\r\n        vow.heal(_rawSysDebt());\r\n    }\r\n\r\n    // Return the new chi value after drip.\r\n    function drip() external returns (uint256 chi) {\r\n        chi = pot.drip();\r\n        _dripIlks();\r\n    }\r\n\r\n    // Returns a simulated chi value\r\n    function drop() external view returns (uint256) {\r\n        return poth.drop();\r\n    }\r\n\r\n    function _dripPot() internal {\r\n        pot.drip();\r\n    }\r\n\r\n    function dripIlks() external {\r\n        _dripIlks();\r\n    }\r\n\r\n    function _dripIlks() internal {\r\n        jug.drip(ETH_A);\r\n        jug.drip(BAT_A);\r\n    }\r\n\r\n    function kickable() external view returns (bool) {\r\n        return _kickable();\r\n    }\r\n\r\n    // Can we bump an auction?\r\n    function _kickable() internal view returns (bool) {\r\n        // require(vat.dai(address(this)) >= add(add(vat.sin(address(this)), bump), hump), \"Vow/insufficient-surplus\");\r\n        // require(sub(sub(vat.sin(address(this)), Sin), Ash) == 0, \"Vow/debt-not-zero\");\r\n        return ((vat.dai(VOW) >= _sysSurplus()) && (_rawSysDebt() == 0));\r\n    }\r\n\r\n    // Kick off an auction and return the auction ID\r\n    function ccccombobreaker() external returns (uint256) {\r\n        return vow.flap();\r\n    }\r\n\r\n    // Kick off an auction and throw away id\r\n    function _ccccombobreaker() internal {\r\n        vow.flap();\r\n    }\r\n\r\n    // Kitchen sink. Call this early and often.\r\n    function hadaiken() external {\r\n        _dripPot();                               // Update the chi\r\n        _dripIlks();                              // Updates the Ilk rates\r\n        _heal();                                  // Cancel out system debt with system surplus\r\n        if (_kickable()) { _ccccombobreaker(); }  // Start an auction\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":false,\"inputs\":[],\"name\":\"ccccombobreaker\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drip\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"chi\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"dripIlks\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"drop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"hadaiken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"heal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"healStat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sd\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kickable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rawSysDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sysSurplus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Hadaiken","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU LGPLv3","SwarmSource":"bzzr://ec989369d3f0ec25373584cd3346d980015bc6e3e8bf25ae0759e6e93e8f8c12"}]}