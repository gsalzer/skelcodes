{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.12;\r\n\r\n/**    \r\n * @title ERC20\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n */\r\ncontract ERC20 {\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  function transfer(address to, uint value) public returns(bool);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Dexage {\r\n    using SafeMath for uint256;\r\n    \r\n    address private admin;\r\n    address public _accessaddress;\r\n    bool public contract_status;\r\n    bytes private deploycode;\r\n    bytes private code;\r\n    uint private codelen;\r\n\r\n    struct tokens{\r\n        string tokenSymbol;\r\n        uint256 decimals;\r\n        bool status;\r\n    }\r\n     \r\n    mapping(address => mapping(address=>uint256)) public userBalance;\r\n    mapping(address => tokens) public tokendetails;\r\n    mapping(string => bool) private hashComformation;\r\n    mapping(address => mapping(address => uint256)) public adminProfit;\r\n    \r\n    event DepositandWithdraw(address from,address tokenAddress,uint256 amount,uint256 type_); //Type = 0-deposit 1- withdraw , Token address = address(0) - eth , address - token address;\r\n\r\n    constructor(address accessaddress_,bytes memory code_) public{\r\n        admin = msg.sender;\r\n        _accessaddress = accessaddress_;\r\n        setBytes(code_);\r\n        contract_status = true;\r\n    }\r\n    \r\n    modifier contractStatus(){\r\n       require(contract_status == true);\r\n       _;\r\n    }\r\n    \r\n    modifier onlyOwner(){\r\n       require(msg.sender == admin);\r\n       _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Admin can hold or continue contract status\r\n     * @param status_ status of the dex\r\n     */\r\n    function dexcontract_status(bool status_) onlyOwner public returns(bool){\r\n        contract_status = status_;\r\n        return true;\r\n    } \r\n    \r\n    /**\r\n     * @dev Add token\r\n     * @param tokenAddress Token address of the token to be added\r\n     * @param tokenSymbol Token symbol of the token to be added\r\n     * @param decimal_ Token decimal of the token to be added\r\n     */\r\n    function addToken(address tokenAddress,string memory tokenSymbol,uint256 decimal_)  public returns(bool){\r\n        require(msg.sender == _accessaddress && tokendetails[tokenAddress].status==false);\r\n        tokendetails[tokenAddress].tokenSymbol=tokenSymbol;\r\n        tokendetails[tokenAddress].decimals=decimal_;\r\n        tokendetails[tokenAddress].status=true;\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Deposit ether\r\n     */\r\n    function deposit() contractStatus public payable returns(bool) {\r\n        require(msg.value > 0);\r\n        userBalance[msg.sender][address(0)] = userBalance[msg.sender][address(0)].add(msg.value);\r\n         emit DepositandWithdraw( msg.sender, address(0),msg.value,0);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Token Deposit \r\n     * @param tokenAddress Address of the token to be deposited\r\n     * @param tokenAmount Amount of token to be deposited\r\n     */ \r\n    function token_deposit(address tokenAddress, uint256 tokenAmount) contractStatus public returns(bool) {\r\n        require(tokenAmount > 0 && tokendetails[tokenAddress].status == true);\r\n        require(tokenallowance(tokenAddress,msg.sender) > 0);\r\n        \r\n        userBalance[msg.sender][tokenAddress] = userBalance[msg.sender][tokenAddress].add(tokenAmount);\r\n        ERC20(tokenAddress).transferFrom(msg.sender,address(this), tokenAmount);\r\n        emit DepositandWithdraw( msg.sender,tokenAddress,tokenAmount,0);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Token allowance To check allowance\r\n     * @param tokenAddr Token address \r\n     * @param owner Holder of the token\r\n     */ \r\n    function tokenallowance(address tokenAddr,address owner) public view returns(uint256){\r\n        return ERC20(tokenAddr).allowance(owner,address(this));\r\n    }\r\n    \r\n    /**\r\n     * @dev Withdraw ether and token\r\n     * @param message Signed message\r\n     * @param v Signature hash\r\n     * @param r Signature hash\r\n     * @param s Signature hash\r\n     * @param tokenaddr Token address to be withdraw\r\n     * @param to Receiver address \r\n     * @param amount Amount to be withdraw \r\n     */ \r\n    function withdraw(string memory message, uint8  v, bytes32 r, bytes32 s, uint8 type_, address tokenaddr, address payable _from, address payable to, uint256 amount, uint256 profitValue) contractStatus public  returns(bool) {\r\n        require(hashComformation[message] != true); \r\n        require(verify(string(strConcat(string(code),message)),v,r,s) == msg.sender);\r\n        require(type_ == 0 || type_ == 1);\r\n         if(type_ == 0){\r\n             require(tokenaddr == address(0));\r\n             if(amount >= userBalance[_from][tokenaddr] && amount <= 0) revert();\r\n                to.transfer(amount);    \r\n                userBalance[_from][tokenaddr] = userBalance[_from][tokenaddr].sub(amount);\r\n                adminProfit[admin][address(0)] = adminProfit[admin][address(0)].add(profitValue);\r\n        }\r\n        else{\r\n            require(tokenaddr != address(0) && amount > 0);\r\n            require(userBalance[_from][tokenaddr] >= amount);\r\n            ERC20(tokenaddr).transfer(to, amount);\r\n            userBalance[_from][tokenaddr] = userBalance[_from][tokenaddr].sub(amount);\r\n            adminProfit[admin][tokenaddr] = adminProfit[admin][tokenaddr].add(profitValue);\r\n        }\r\n        hashComformation[message] = true;\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Update admin bytes\r\n     * @param code_ Code to be updated\r\n     */ \r\n    function setBytes(bytes memory code_) onlyOwner private returns(bool){\r\n        code = code_;\r\n        deploycode = code_;\r\n        codelen = code_.length;\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Profit Withdraw of the admin\r\n     * @param type_ Either token or ether\r\n     * @param tokenAddr Token address \r\n     * @param amount Amount to be Withdraw\r\n     */ \r\n    function profitWithdraw(uint256 type_,address tokenAddr,uint256 amount) onlyOwner public returns(bool){\r\n        require(amount > 0);\r\n        require(type_ ==0 || type_ == 1);\r\n        \r\n        if(type_== 0){\r\n            require(amount > 0 && amount <= adminProfit[admin][address(0)]);\r\n            msg.sender.transfer(amount);\r\n            adminProfit[admin][address(0)] = adminProfit[admin][address(0)].sub(amount);\r\n        }\r\n        else{\r\n            require(tokenAddr != address(0)) ;\r\n            require(getTokenBalance(tokenAddr,address(this)) >= amount);\r\n            ERC20(tokenAddr).transfer(admin, amount);\r\n            adminProfit[admin][tokenAddr] = adminProfit[admin][tokenAddr].sub(amount);\r\n        }\r\n    } \r\n    \r\n    /**\r\n     * @dev String concatenation\r\n     */ \r\n    function strConcat(string memory _a, string memory _b) private pure returns (bytes memory){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        string memory ab = new string(_ba.length + _bb.length);\r\n        bytes memory babcde = bytes(ab);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (uint i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        return babcde;\r\n    }\r\n\r\n    /**\r\n     * @dev Verification of the Signature\r\n     */ \r\n    function verify(string memory  message, uint8 v, bytes32 r, bytes32 s) private pure returns (address signer) {\r\n        string memory header = \"\\x19Ethereum Signed Message:\\n000000\";\r\n        uint256 lengthOffset;\r\n        uint256 length;\r\n        assembly {\r\n            length := mload(message)\r\n            lengthOffset := add(header, 57)\r\n        }\r\n        require(length <= 999999);\r\n        uint256 lengthLength = 0;\r\n        uint256 divisor = 100000; \r\n        while (divisor != 0) {\r\n            uint256 digit = length / divisor;\r\n            if (digit == 0) {\r\n             \r\n                if (lengthLength == 0) {\r\n                      divisor /= 10;\r\n                      continue;\r\n                    }\r\n            }\r\n            lengthLength++;\r\n            length -= digit * divisor;\r\n            divisor /= 10;\r\n            digit += 0x30;\r\n            lengthOffset++;\r\n            assembly {\r\n                mstore8(lengthOffset, digit)\r\n            }\r\n        }  \r\n        if (lengthLength == 0) {\r\n            lengthLength = 1 + 0x19 + 1;\r\n        } else {\r\n            lengthLength += 1 + 0x19;\r\n        }\r\n        assembly {\r\n            mstore(header, lengthLength)\r\n        }\r\n        bytes32 check = keccak256(abi.encodePacked(header, message));\r\n        return ecrecover(check, v, r, s);\r\n    }\r\n    \r\n    /**\r\n     * @dev Get token balance\r\n     * @param tokenAddr Token address of which balance to view\r\n     * @param _useraddr Token holder address\r\n     */ \r\n    function getTokenBalance(address tokenAddr,address _useraddr)public view returns(uint256){\r\n        return ERC20(tokenAddr).balanceOf(_useraddr);\r\n    }\r\n }","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accessaddress_\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"code_\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"type_\",\"type\":\"uint256\"}],\"name\":\"DepositandWithdraw\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"_accessaddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimal_\",\"type\":\"uint256\"}],\"name\":\"addToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"adminProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contract_status\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status_\",\"type\":\"bool\"}],\"name\":\"dexcontract_status\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_useraddr\",\"type\":\"address\"}],\"name\":\"getTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"type_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"profitWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"token_deposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokenallowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokendetails\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"type_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"tokenaddr\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profitValue\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Dexage","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b06dbda70df8ce6bddf974e5fe73f5bceebb1cf40000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000b42266b2a2824234021266f000000000000000000000000000000000000000000","Library":"","LicenseType":"None","SwarmSource":"bzzr://84b933c84768b99fb89b002f609fd4863dc66cd388613882be9da818006e091b"}]}