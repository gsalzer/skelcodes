{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.12;\r\n\r\ncontract Token {\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender)external view returns(uint256);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n    \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ncontract Future1exchange {\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    address public owner;\r\n    address public feeAddress;\r\n    uint32 public requestCancelMinimumTime;\r\n    uint256 public referPercent;\r\n    \r\n    // events ---\r\n    event Created(bytes32 _tradeHash);\r\n    event SellerCancelDisabled(bytes32 _tradeHash);\r\n    event SellerRequestedCancel(bytes32 _tradeHash);\r\n    event CancelledBySeller(bytes32 _tradeHash);\r\n    event CancelledByBuyer(bytes32 _tradeHash);\r\n    event Released(bytes32 _tradeHash);\r\n    event DisputeResolved(bytes32 _tradeHash);\r\n\r\n    constructor (address feeadd) public {\r\n        owner = msg.sender;\r\n        feeAddress = feeadd;\r\n        requestCancelMinimumTime = 2 hours;\r\n    }\r\n\r\n    struct Escrow {\r\n        bool escrowStatus;\r\n        uint256 setTimeSellerCancel;\r\n        uint256 sellerFee;\r\n        uint256 buyerFee;\r\n        uint256 eType;\r\n        bool sellerDispute;\r\n        bool buyerDispute;\r\n    }\r\n    \r\n     struct User{\r\n        address userAddr;\r\n        address referralAddr;\r\n        address referralTokenAddr;\r\n        uint256 referralType;\r\n        bool registerStatus;\r\n    }\r\n    \r\n    mapping(address => User) public referral_map;\r\n    mapping(bytes32 => Escrow) public escrow_map;\r\n    mapping (address => mapping(address => uint256)) public _token;\r\n    mapping(address => mapping(address => uint256)) public _referralFee;\r\n    \r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"This function is  only called by Owner..\");\r\n        _;\r\n    }\r\n    \r\n    /** @dev external - Set the new owner address, only called by current owner.\r\n     * @param _newOwner - The new owner address.\r\n     */\r\n    function setOwner(address _newOwner) onlyOwner external {\r\n        require(_newOwner != address(0), \"Invalid Address\");\r\n        owner = _newOwner;\r\n    }\r\n    \r\n    /** @dev external - Set the new fee address, only called by  owner.\r\n     * @param _newFeeAddress - The new fee address.\r\n     */\r\n    function setFeeAddress(address _newFeeAddress) onlyOwner external {\r\n        require(_newFeeAddress != address(0), \"Invalid Address\");\r\n        feeAddress = _newFeeAddress;\r\n    }\r\n    \r\n    /** @dev external - Set the new owner address, only called by  owner.\r\n     * @param _newRequestCancelMinimumTime - The new time for requestCancel.\r\n     */\r\n    function setRequestCancellationMinimumTime(uint32 _newRequestCancelMinimumTime) onlyOwner external {\r\n        requestCancelMinimumTime = _newRequestCancelMinimumTime;\r\n    }\r\n    \r\n    /** @dev external - Set the new owner address, only called by  owner.\r\n     * @param _feePercent - The new fee percent.\r\n     */\r\n    function setFeePercent(uint256 _feePercent) onlyOwner external {\r\n        require(_feePercent > 0, \"Invalid Fee Percent\");\r\n        referPercent = _feePercent;\r\n    }\r\n    \r\n    /** @dev external - Collect the referral fee from user.\r\n     * @param _from - The Address who send the fee to the contract for referral.\r\n     * @param _tokenContract - The Token Contract Address which is selected for referrance by _from.\r\n     * @param _amount - The Fee Amount\r\n     * @return bool - true.\r\n     */\r\n    function feeCollect(address _from,address _tokenContract, uint256 _amount) external returns(bool) {\r\n        require(_from != address(0) && _tokenContract != address(0), \"Empty Address\");\r\n        require(tokenallowance(_tokenContract,_from,address(this)) >= _amount, \"Insufficient Allowance\");\r\n        Token(_tokenContract).transferFrom(_from,address(this),_amount);\r\n        _referralFee[_from][_tokenContract] = _referralFee[_from][_tokenContract].add(_amount);\r\n        return true;\r\n    }\r\n\r\n    /** @dev external - Create the escrow process only call by seller.\r\n     * @param _tradeId - The unique id for particular trade.\r\n     * @param _seller - The seller address of particular trade.\r\n     * @param _buyer - The buyer address of particular trade.\r\n     * @param _amount - The escrow amount of particular trade is ether/token.\r\n     * @param _tokenContract - The token contract address for token  (or) give address(0) for ether.\r\n     * @param _sellerFee - The seller transaction/admin fee .\r\n     * @param _buyerFee - The buyer transaction/admin fee.\r\n     * @param _type - If the amount is ether it is 1 otherwise it is 2.\r\n     * @param _sellerCancelInSeconds - To time for cancel the trade by seller.\r\n     * @param _Ref[0] - The referral address for seller, _Ref[1] -  The referral address for buyer.\r\n     * @param _Tokens[0] -  The referral token address for seller, _Tokens[1] - The referral token address for buyer.\r\n     * @param _Type[0] - The referral type for seller is 0 - ether / 1 - token, _Type[1] - The referral type for buyer 0 - ether / 1 - token.\r\n     * @return bool - true.\r\n     */\r\n    function createEscrow(uint16 _tradeId, address _seller, address _buyer, uint256 _amount, address _tokenContract, uint256 _sellerFee, uint256 _buyerFee,uint16 _type,uint32 _sellerCancelInSeconds, address[2] calldata _Ref, address[2] calldata _Tokens, uint256[2] calldata _Type)  payable external returns(bool) {\r\n        bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeId,_seller,_buyer,_amount));\r\n        \r\n        registerUser(_seller,_buyer,_Ref[0],_Ref[1],_Tokens[0],_Tokens[1],_Type[0],_Type[1]); //register\r\n        \r\n        require (msg.sender == _seller,\"Invalid User..\");\r\n        require (_type==1 || _type == 2, \"Invalid Type.. \");\r\n        require(escrow_map[_tradeHash].escrowStatus==false, \"Status Checking Failed.. \");\r\n        \r\n        \r\n        if(_Tokens[0] !=  address(0)) {// checking seller referral_token \r\n            require(_Type[0]==1 && _referralFee[_seller][_Tokens[0]]>0,\"Insufficient Fee Balance or type mismatch\" );\r\n            \r\n        }\r\n        if(_Tokens[0] ==  address(0) && _type == 2){\r\n            require( _Type[0]==0 && msg.value >= _sellerFee, \"Type mismatch or msg.value less then sellerfee\"); \r\n            _referralFee[_seller][_Tokens[0]] += msg.value; //_referralFee[_seller][_Tokens[0]].add(msg.value);\r\n        }\r\n         \r\n        if(_Tokens[0] ==  address(0) && _type == 1){\r\n            require( _Type[0]==0 && msg.value >= _amount.add(_sellerFee), \"Type mismatch or msg.value less then sellerfee\"); \r\n            _referralFee[_seller][_Tokens[0]] += _sellerFee; //_referralFee[_seller][_Tokens[0]].add(msg.value);\r\n        }\r\n    \r\n        require(_referralFee[_seller][_Tokens[0]] >= _sellerFee, \"Insufficient Fee for this Trade\");\r\n        \r\n        if(_type == 1){\r\n            require(_tokenContract == address(0), \"Invalid Token Address For this Type\");\r\n            require(_amount<=msg.value && msg.value >0, \"Invalid Amount..\");                  \r\n        }\r\n        \r\n        if(_type == 2){\r\n            Token(_tokenContract).transferFrom(_seller,address(this), _amount);\r\n            \r\n            \r\n        }\r\n        \r\n        uint256 _sellerCancelAfter = _sellerCancelInSeconds == 0 ? 1 : ((now).add(_sellerCancelInSeconds));\r\n        \r\n        escrow_map[_tradeHash].escrowStatus = true;\r\n        escrow_map[_tradeHash].setTimeSellerCancel = _sellerCancelAfter;\r\n        escrow_map[_tradeHash].sellerFee = _sellerFee;\r\n        escrow_map[_tradeHash].buyerFee = _buyerFee;\r\n        escrow_map[_tradeHash].eType = _type;\r\n        \r\n        emit Created(_tradeHash); //event\r\n        return true;\r\n    }\r\n    \r\n    /** @dev private - Register the User for referral process.\r\n     * @param _seller - The seller address of particular trade.\r\n     * @param _buyer - The buyer address of particular trade.\r\n     * @param _sellrefer - The referral address for seller.\r\n     * @param _buyrefer -  The referral address for buyer.\r\n     * @param _sellerToken -  The referral token address for seller. \r\n     * @param _buyerToken - The referral token address for buyer.\r\n     * @param _sellerFeeType - The referral type for seller is 0 - ether / 1 - token.\r\n     * @param _buyerFeeType - The referral type for buyer 0 - ether / 1 - token.\r\n     * @return bool - true.\r\n     */\r\n    function registerUser(address _seller, address _buyer,address _sellrefer,address _buyrefer, address _sellerToken, address _buyerToken, uint256 _sellerFeeType, uint256 _buyerFeeType)  private returns(bool) {\r\n        \r\n        //seller\r\n        if(_sellrefer!= address(0)) { // referralAddr checking for referral fee \r\n            referral_map[_seller].referralAddr =_sellrefer;\r\n            referral_map[_seller].registerStatus =true;\r\n        }\r\n       \r\n        if(_sellerFeeType == 1) {// referral token for admin fee/referral fee\r\n            referral_map[_seller].userAddr = _seller;\r\n            referral_map[_seller].referralTokenAddr = _sellerToken;\r\n            referral_map[_seller].referralType = _sellerFeeType;\r\n        }\r\n        \r\n        else if(_sellerFeeType == 0) {// referral ether for admin fee/referral fee\r\n            referral_map[_seller].userAddr = _seller;\r\n            referral_map[_seller].referralTokenAddr = address(0);\r\n            referral_map[_seller].referralType = _sellerFeeType;\r\n        }\r\n\r\n        //buyer\r\n        if(_buyrefer != address(0)) { // referralAddr checking for referral fee\r\n            referral_map[_buyer].referralAddr = _buyrefer;\r\n            referral_map[_buyer].registerStatus =true;\r\n        }\r\n        \r\n        if(_buyerFeeType ==1) {// referral token for admin fee/referral fee\r\n            referral_map[_buyer].userAddr = _buyer;\r\n            referral_map[_buyer].referralTokenAddr = _buyerToken;\r\n            referral_map[_buyer].referralType = _buyerFeeType;\r\n        }\r\n        \r\n        else if(_buyerFeeType == 0) { // referral ether for admin fee/referral fee\r\n            referral_map[_buyer].userAddr = _buyer;\r\n            referral_map[_buyer].referralTokenAddr = address(0);\r\n            referral_map[_buyer].referralType = _buyerFeeType;\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n\r\n    /** @dev external - Withdraw the admin fees collected by the contract. Only the owner can call this .\r\n     * @param _to - The withdrawal address.\r\n     * @param _amount - The withdrawal amount.\r\n     * @param _type - If Ether __type = 1, else _type = 2.\r\n     * @param _tokenContract -  The withdrawal token address.\r\n     */\r\n    function withdrawFees(address payable _to, uint256 _amount,uint16 _type, address _tokenContract) onlyOwner external {\r\n        if(_type == 1) {\r\n            require(_amount <= _token[address(this)][address(0)],\"Insufficient ether balance\"); \r\n            _token[address(this)][address(0)] = _token[address(this)][address(0)].sub(_amount);\r\n            _to.transfer(_amount);\r\n        }\r\n        \r\n        else if(_type == 2) {\r\n            require(_amount <= _token[address(this)][_tokenContract],\"Insufficient token balance\");\r\n            _token[address(this)][_tokenContract] = _token[address(this)][_tokenContract].sub(_amount);\r\n            Token(_tokenContract).transfer(_to,_amount);\r\n        }\r\n    }\r\n\r\n    /** @dev external - Withdraw the referral fees  by the seller/buyer/referral address.\r\n     * @param _amount - The withdrawal amount.\r\n     * @param _type - If Ether __type = 1, else _type = 2.\r\n     * @param _tokenContract -  The withdrawal token address.\r\n     * @param _refType - if the new referral token  _refType = 0, if already registered referraltoken _refType = 1\r\n     */\r\n    function withdrawReferral(uint256 _amount,uint16 _type, address _tokenContract, uint256 _refType) external {\r\n        if(_type == 1) { //ether \r\n            require(_amount <= _referralFee[msg.sender][address(0)], \"Insufficient ether balance\"); \r\n            _referralFee[msg.sender][address(0)] =  _referralFee[msg.sender][address(0)].sub(_amount);\r\n            msg.sender.transfer(_amount);\r\n        }\r\n        else if(_type == 2) { //token \r\n            if(_refType == 0) { // Any user can withdraw their particular token amount \r\n                require(_amount <=  _referralFee[msg.sender][_tokenContract], \"Insufficient token balance\");\r\n                _referralFee[ msg.sender][_tokenContract] = _referralFee[ msg.sender][_tokenContract].sub(_amount);\r\n                Token(_tokenContract).transfer( msg.sender,_amount);\r\n                \r\n            }\r\n            else if(_refType == 1) {  // If seller/ buyer comes, withdraw their referral token amount \r\n                require(_amount <=  _referralFee[msg.sender][referral_map[msg.sender].referralTokenAddr], \"Insufficient token balance\");\r\n                _referralFee[ msg.sender][referral_map[msg.sender].referralTokenAddr] = _referralFee[ msg.sender][referral_map[msg.sender].referralTokenAddr].sub(_amount);\r\n                Token(referral_map[msg.sender].referralTokenAddr).transfer(msg.sender,_amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @dev payable -  After the payment successfull, the buyer clicks mark as paid on that time this function calls.\r\n     * @param _tradeId - The unique id for particular trade.\r\n     * @param _seller - The seller address of particular trade.\r\n     * @param _buyer - The buyer address of particular trade.\r\n     * @param _amount - The escrow amount of particular trade is ether/token.\r\n     * @return bool - true.\r\n     */\r\n    function disableSellerCancel(uint16 _tradeId, address payable _seller, address payable _buyer, uint256 _amount) payable public returns(bool) {\r\n        bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeId,_seller,_buyer,_amount));\r\n        require(escrow_map[_tradeHash].escrowStatus == true, \"Status Checking Failed.. \");\r\n        require(escrow_map[_tradeHash].setTimeSellerCancel !=0,  \"Seller Cancel time is Differ.. \");\r\n        require(msg.sender == _buyer, \"Invalid User.. \");\r\n        \r\n        if(referral_map[_buyer].referralTokenAddr !=  address(0)) { // checking buyer referral_token \r\n            require(_referralFee[_buyer][referral_map[_buyer].referralTokenAddr]>0,\"Insufficient Fee Balance..\" );\r\n        }\r\n        \r\n        if(referral_map[_buyer].referralTokenAddr ==  address(0) && (escrow_map[_tradeHash].eType == 2)) {\r\n            require(msg.value >= escrow_map[_tradeHash].buyerFee, \"Need more deposit amount for fee\");\r\n            _referralFee[_buyer][referral_map[_buyer].referralTokenAddr] = _referralFee[_buyer][referral_map[_buyer].referralTokenAddr].add(msg.value);\r\n        }\r\n        \r\n        if(referral_map[_buyer].referralTokenAddr ==  address(0) && (escrow_map[_tradeHash].eType == 1)) {\r\n            _referralFee[_buyer][referral_map[_buyer].referralTokenAddr] = _referralFee[_buyer][referral_map[_buyer].referralTokenAddr].add(escrow_map[_tradeHash].buyerFee);\r\n        }\r\n        \r\n        \r\n        require(_referralFee[_buyer][referral_map[_buyer].referralTokenAddr] >= escrow_map[_tradeHash].buyerFee, \"Insufficient Fee for this Trade\");\r\n        \r\n       escrow_map[_tradeHash].setTimeSellerCancel = 0;\r\n       \r\n       emit SellerCancelDisabled(_tradeHash); // Event\r\n       return true;\r\n    }\r\n \r\n    /** @dev external -  If the buyer wants to cancel the trade, the escrow send back ether to seller.\r\n     * @param _tradeId - The unique id for particular trade.\r\n     * @param _seller - The seller address of particular trade.\r\n     * @param _buyer - The buyer address of particular trade.\r\n     * @param _amount - The escrow amount of particular trade is ether/token.\r\n     * @param tokenadd - The token address which is escrowed by seller.\r\n     * @return bool - true.\r\n     */\r\n    function buyerCancel(uint16 _tradeId, address payable _seller, address payable _buyer, uint256 _amount,address tokenadd) external returns(bool) {\r\n       bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeId,_seller,_buyer,_amount));\r\n       require(escrow_map[_tradeHash].escrowStatus == true && msg.sender==feeAddress, \"Invalid Escrow status or This user not allowed to call\");\r\n       require(escrow_map[_tradeHash].setTimeSellerCancel > now, \"Time  Expired Issue..\");\r\n\r\n        if(escrow_map[_tradeHash].eType == 1 ) {\r\n            _seller.transfer(_amount);\r\n        }\r\n        if (escrow_map[_tradeHash].eType== 2) {\r\n            Token(tokenadd).transfer(_seller,_amount);\r\n        }\r\n        \r\n       delete escrow_map[_tradeHash];\r\n       emit CancelledByBuyer(_tradeHash); //Event\r\n       return true;\r\n    }\r\n\r\n    /** @dev external - If the seller wants to cancel the trade, the escrow send back ether to seller, Its only called if the buyer missed to pay the amount \r\n     * @param _tradeId - The unique id for particular trade.\r\n     * @param _seller - The seller address of particular trade.\r\n     * @param _buyer - The buyer address of particular trade.\r\n     * @param _amount - The escrow amount of particular trade is ether/token.\r\n     * @param tokenadd - The token address which is escrowed by seller.\r\n     * @return bool - true.\r\n     */\r\n    function sellerCancel(uint16 _tradeId, address payable _seller, address payable _buyer, uint256 _amount, address tokenadd) external returns(bool) {\r\n       bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeId,_seller,_buyer,_amount));\r\n        \r\n       require(escrow_map[_tradeHash].escrowStatus == true && msg.sender==feeAddress, \"Invalid Escrow status or This user not allowed to call\");\r\n       \r\n       if(escrow_map[_tradeHash].setTimeSellerCancel <= 1 || escrow_map[_tradeHash].setTimeSellerCancel > now) revert();\r\n       \r\n       if(escrow_map[_tradeHash].eType == 1 ) {\r\n            _seller.transfer(_amount);\r\n        }\r\n        \r\n        if (escrow_map[_tradeHash].eType == 2) {\r\n            Token(tokenadd).transfer(_seller,_amount);\r\n        }\r\n        \r\n       delete escrow_map[_tradeHash];\r\n       emit CancelledBySeller(_tradeHash); // Event \r\n       return true;\r\n    }\r\n    \r\n    /** @dev external - If the seller wants to cancel the request, seller calls, If the sellet set time for cancel = 1 and Its only called if the buyer is unresponsive.\r\n     * @param _tradeId - The unique id for particular trade.\r\n     * @param _seller - The seller address of particular trade.\r\n     * @param _buyer - The buyer address of particular trade.\r\n     * @param _amount - The escrow amount of particular trade is ether/token.\r\n     * @return bool - true.\r\n     */\r\n    function sellerRequestCancel(uint16 _tradeId, address payable _seller, address payable _buyer, uint256 _amount) external returns(bool) {\r\n       bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeId,_seller,_buyer,_amount));\r\n       \r\n       require(feeAddress==msg.sender, \"This user not allowed to call this function\");\r\n         \r\n       require(escrow_map[_tradeHash].escrowStatus == true, \"Status Checking Failed.. \");\r\n       \r\n       require (escrow_map[_tradeHash].setTimeSellerCancel == 1,  \"Seller Cancel time is Differ.. \");\r\n       \r\n       escrow_map[_tradeHash].setTimeSellerCancel = (now).add(requestCancelMinimumTime);\r\n       \r\n       emit SellerRequestedCancel(_tradeHash); // Event\r\n       \r\n       return true;\r\n        \r\n    }\r\n\r\n    /** @dev external - Call for dispute if the clashes between seller or buyer.\r\n     * @param _tradeId - The unique id for particular trade.\r\n     * @param _seller - The seller address of particular trade.\r\n     * @param _buyer - The buyer address of particular trade.\r\n     * @param _amount - The escrow amount of particular trade is ether/token.\r\n     * @param disputetype - if seller disputes disputetype = 1 and if buyer disputes disputetype = 2.\r\n     * @return bool - true.\r\n     */\r\n    function consumeDispute(uint16 _tradeId, address payable _seller, address payable _buyer, uint256 _amount, uint16 disputetype) external returns (bool) {\r\n        bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeId,_seller,_buyer,_amount));\r\n         \r\n        require(msg.sender == feeAddress, \"This user not allowed to call this function\");\r\n         \r\n        require(escrow_map[_tradeHash].escrowStatus == true, \" Status Failed.. \");\r\n         \r\n        if(disputetype == 1) {// seller\r\n            escrow_map[_tradeHash].sellerDispute = true;\r\n            return true;\r\n        }\r\n        else if(disputetype == 2) {// buyer\r\n            escrow_map[_tradeHash].buyerDispute = true;\r\n             return true;\r\n        }\r\n    }\r\n\r\n    /** @dev external - After Confirm Payment Call By Seller, release the funds.\r\n     * @param _tradeId - The unique id for particular trade.\r\n     * @param _seller - The seller address of particular trade.\r\n     * @param _buyer - The buyer address of particular trade.\r\n     * @param _amount - The escrow amount of particular trade is ether/token.\r\n     * @param _tokenContract - The token address which is escrowed by seller.\r\n     * @return bool - true.\r\n     */\r\n    function releseFunds(uint16 _tradeId, address payable _seller, address payable _buyer, uint256 _amount,address _tokenContract) external  returns(bool)\r\n    {\r\n        require(msg.sender == feeAddress, \"This user not allowed to call this function\");\r\n        bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeId,_seller,_buyer,_amount));\r\n        require(escrow_map[_tradeHash].escrowStatus == true, \"Status Failed.. \");\r\n        uint256[2] memory _reffee; \r\n        uint256 percDiv =uint256((100)).mul(10**18);\r\n        _reffee[0] = (escrow_map[_tradeHash].sellerFee.mul(referPercent)).div(percDiv);  // seller Referral Fee \r\n        _reffee[1] = (escrow_map[_tradeHash].buyerFee.mul(referPercent)).div(percDiv); // buyer Referral Fee\r\n       \r\n       \r\n\r\n        // seller referral process\r\n            if(referral_map[_seller]. registerStatus == true) {\r\n                require(_referralFee[_seller][referral_map[_seller].referralTokenAddr] >= escrow_map[_tradeHash].sellerFee, \"Insufficient Referral Fee Balance for seller\");\r\n                _token[address(this)][referral_map[_seller].referralTokenAddr] = _token[address(this)][referral_map[_seller].referralTokenAddr].add(escrow_map[_tradeHash].sellerFee);\r\n                _referralFee[referral_map[_seller].referralAddr][referral_map[_seller].referralTokenAddr] = _referralFee[referral_map[_seller].referralAddr][referral_map[_seller].referralTokenAddr].add(_reffee[0]);  // seller Referral\r\n                _token[address(this)][referral_map[_seller].referralTokenAddr] = _token[address(this)][referral_map[_seller].referralTokenAddr].sub(_reffee[0]);\r\n                _referralFee[_seller][referral_map[_seller].referralTokenAddr] = _referralFee[_seller][referral_map[_seller].referralTokenAddr].sub(escrow_map[_tradeHash].sellerFee);\r\n            }\r\n                \r\n            else  // seller not registered the referral address, so only admin fee\r\n            {\r\n                _reffee[0] = 0;\r\n                require(_referralFee[_seller][referral_map[_seller].referralTokenAddr] >= escrow_map[_tradeHash].sellerFee, \"Insufficient Referral Fee Balance for seller\");\r\n                _token[address(this)][referral_map[_seller].referralTokenAddr] =  _token[address(this)][referral_map[_seller].referralTokenAddr].add(escrow_map[_tradeHash].sellerFee);\r\n                _token[address(this)][referral_map[_seller].referralTokenAddr] =  _token[address(this)][referral_map[_seller].referralTokenAddr].sub(_reffee[0]);\r\n                _referralFee[_seller][referral_map[_seller].referralTokenAddr] =  _referralFee[_seller][referral_map[_seller].referralTokenAddr].sub(escrow_map[_tradeHash].sellerFee);\r\n            }\r\n    \r\n            //buyer referral process\r\n            if(referral_map[_buyer]. registerStatus == true) {\r\n                 require(_referralFee[_buyer][referral_map[_buyer].referralTokenAddr] >= escrow_map[_tradeHash].buyerFee , \"Insufficient Referral Fee Balance for buyer\");\r\n                _token[address(this)][referral_map[_buyer].referralTokenAddr] = _token[address(this)][referral_map[_buyer].referralTokenAddr].add(escrow_map[_tradeHash].buyerFee);\r\n                _referralFee[referral_map[_buyer].referralAddr][referral_map[_buyer].referralTokenAddr] = _referralFee[referral_map[_buyer].referralAddr][referral_map[_buyer].referralTokenAddr].add(_reffee[1]);  // buyer Referral\r\n                _token[address(this)][referral_map[_buyer].referralTokenAddr] = _token[address(this)][referral_map[_buyer].referralTokenAddr].sub(_reffee[1]);\r\n                _referralFee[_buyer][referral_map[_buyer].referralTokenAddr] =  _referralFee[_buyer][referral_map[_buyer].referralTokenAddr].sub(escrow_map[_tradeHash].buyerFee);\r\n           }\r\n                \r\n           else //buyer not registered the referral address, so only admin fee\r\n           {\r\n                _reffee[1] =0;\r\n                require(_referralFee[_buyer][referral_map[_buyer].referralTokenAddr] >= escrow_map[_tradeHash].buyerFee,  \"Insufficient Referral Fee Balance for buyer\");\r\n                _token[address(this)][referral_map[_buyer].referralTokenAddr] =  _token[address(this)][referral_map[_buyer].referralTokenAddr].add(escrow_map[_tradeHash].buyerFee);\r\n                _token[address(this)][referral_map[_buyer].referralTokenAddr] =  _token[address(this)][referral_map[_buyer].referralTokenAddr].sub(_reffee[1]);\r\n                _referralFee[_buyer][referral_map[_buyer].referralTokenAddr] = _referralFee[_buyer][referral_map[_buyer].referralTokenAddr].sub(escrow_map[_tradeHash].buyerFee);\r\n           }\r\n\r\n            if(escrow_map[_tradeHash].eType == 1 ) {//ether \r\n                 _buyer.transfer(_amount.sub(escrow_map[_tradeHash].buyerFee));\r\n            }\r\n        \r\n            if (escrow_map[_tradeHash].eType == 2)  {//token \r\n                Token(_tokenContract).transfer(_buyer,(_amount));\r\n            }\r\n        \r\n        delete escrow_map[_tradeHash];\r\n        emit Released(_tradeHash);\r\n        return true;\r\n    }  \r\n\r\n    /** @dev external - Its only called by Mediator, because of any issues between seller and buyer (vanish), If the sellerDispute or buyerDispute is true for this trade.\r\n     * @param _tradeId - The unique id for particular trade.\r\n     * @param _seller - The seller address of particular trade.\r\n     * @param _buyer - The buyer address of particular trade.\r\n     * @param _amount - The escrow amount of particular trade is ether/token.\r\n     * @param _favour - If the mediator is favour for seller then _favour = 1, if the mediator is favour for buyer then _favour = 2.\r\n     * @param _tokenContract - The token address which is escrowed by seller.\r\n     * @return bool - true.\r\n     */\r\n    function disputeByMediator(uint16 _tradeId, address payable _seller, address payable _buyer, uint256 _amount, uint16 _favour, address _tokenContract) external  returns(bool) {\r\n        require(msg.sender == feeAddress,\"This user not allowed to call this function\");\r\n        \r\n        bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeId,_seller,_buyer,_amount));\r\n         \r\n        require(escrow_map[_tradeHash].sellerDispute == true || escrow_map[_tradeHash].buyerDispute == true, \" Seller or Buyer Doesn't Call Dispute\");\r\n         \r\n        require(escrow_map[_tradeHash].escrowStatus == true, \" Status Failed..\");\r\n         \r\n        require(_favour == 1 || _favour == 2,  \"Invalid Favour Type\");\r\n         \r\n        uint256[2] memory _reffee;\r\n        uint256 percDiv =uint256((100)).mul(10**18);\r\n        _reffee[0] = (escrow_map[_tradeHash].sellerFee.mul(referPercent)).div(percDiv);  // seller Referral Fee \r\n        _reffee[1] = (escrow_map[_tradeHash].buyerFee.mul(referPercent)).div(percDiv); // buyer Referral Fee\r\n       \r\n\r\n        // seller referral process\r\n            if(referral_map[_seller]. registerStatus == true) {\r\n                require(_referralFee[_seller][referral_map[_seller].referralTokenAddr] >= escrow_map[_tradeHash].sellerFee, \"Insufficient Referral Fee Balance for seller\");\r\n                _token[address(this)][referral_map[_seller].referralTokenAddr] = _token[address(this)][referral_map[_seller].referralTokenAddr].add(escrow_map[_tradeHash].sellerFee);\r\n                _referralFee[referral_map[_seller].referralAddr][referral_map[_seller].referralTokenAddr] = _referralFee[referral_map[_seller].referralAddr][referral_map[_seller].referralTokenAddr].add(_reffee[0]);  // seller Referral\r\n                _token[address(this)][referral_map[_seller].referralTokenAddr] = _token[address(this)][referral_map[_seller].referralTokenAddr].sub(_reffee[0]);\r\n                _referralFee[_seller][referral_map[_seller].referralTokenAddr] = _referralFee[_seller][referral_map[_seller].referralTokenAddr].sub(escrow_map[_tradeHash].sellerFee);\r\n            }\r\n                \r\n            else  // seller not registered the referral address, so only admin fee\r\n            {\r\n                _reffee[0] = 0;\r\n                require(_referralFee[_seller][referral_map[_seller].referralTokenAddr] >= escrow_map[_tradeHash].sellerFee, \"Insufficient Referral Fee Balance for seller\");\r\n                _token[address(this)][referral_map[_seller].referralTokenAddr] =  _token[address(this)][referral_map[_seller].referralTokenAddr].add(escrow_map[_tradeHash].sellerFee);\r\n                _token[address(this)][referral_map[_seller].referralTokenAddr] =  _token[address(this)][referral_map[_seller].referralTokenAddr].sub(_reffee[0]);\r\n                _referralFee[_seller][referral_map[_seller].referralTokenAddr] =  _referralFee[_seller][referral_map[_seller].referralTokenAddr].sub(escrow_map[_tradeHash].sellerFee);\r\n            }\r\n    \r\n            //buyer referral process\r\n            if(referral_map[_buyer]. registerStatus == true) {\r\n                 require(_referralFee[_buyer][referral_map[_buyer].referralTokenAddr] >= escrow_map[_tradeHash].buyerFee , \"Insufficient Referral Fee Balance for buyer\");\r\n                _token[address(this)][referral_map[_buyer].referralTokenAddr] = _token[address(this)][referral_map[_buyer].referralTokenAddr].add(escrow_map[_tradeHash].buyerFee);\r\n                _referralFee[referral_map[_buyer].referralAddr][referral_map[_buyer].referralTokenAddr] = _referralFee[referral_map[_buyer].referralAddr][referral_map[_buyer].referralTokenAddr].add(_reffee[1]);  // buyer Referral\r\n                _token[address(this)][referral_map[_buyer].referralTokenAddr] = _token[address(this)][referral_map[_buyer].referralTokenAddr].sub(_reffee[1]);\r\n                _referralFee[_buyer][referral_map[_buyer].referralTokenAddr] =  _referralFee[_buyer][referral_map[_buyer].referralTokenAddr].sub(escrow_map[_tradeHash].buyerFee);\r\n           }\r\n                \r\n           else //buyer not registered the referral address, so only admin fee\r\n           {\r\n                _reffee[1] =0;\r\n                require(_referralFee[_buyer][referral_map[_buyer].referralTokenAddr] >= escrow_map[_tradeHash].buyerFee,  \"Insufficient Referral Fee Balance for buyer\");\r\n                _token[address(this)][referral_map[_buyer].referralTokenAddr] =  _token[address(this)][referral_map[_buyer].referralTokenAddr].add(escrow_map[_tradeHash].buyerFee);\r\n                _token[address(this)][referral_map[_buyer].referralTokenAddr] =  _token[address(this)][referral_map[_buyer].referralTokenAddr].sub(_reffee[1]);\r\n                _referralFee[_buyer][referral_map[_buyer].referralTokenAddr] = _referralFee[_buyer][referral_map[_buyer].referralTokenAddr].sub(escrow_map[_tradeHash].buyerFee);\r\n           }\r\n\r\n           \r\n         if(escrow_map[_tradeHash].eType == 1) {//ether\r\n             if(_favour == 1) {//seller\r\n                  _seller.transfer(_amount);\r\n             }\r\n             else if (_favour == 2) {//buyer\r\n                _buyer.transfer(_amount.sub(escrow_map[_tradeHash].buyerFee));\r\n             }\r\n         }\r\n         if(escrow_map[_tradeHash].eType == 2) {//token\r\n              if(_favour == 1) { //seller\r\n                  Token(_tokenContract).transfer(_seller,_amount);\r\n             }\r\n             else if (_favour == 2) {//buyer\r\n                 Token(_tokenContract).transfer(_buyer,(_amount));\r\n            }\r\n         }\r\n\r\n         delete escrow_map[_tradeHash];\r\n         emit DisputeResolved(_tradeHash); // Event\r\n         return true;\r\n        \r\n    }\r\n    \r\n    function tokenallowance(address tokenAddr,address _owner,address _spender) public view returns(uint256){ // to check token allowance to contract\r\n        return Token(tokenAddr).allowance(_owner,_spender);\r\n    }\r\n        \r\n }","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeadd\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"CancelledByBuyer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"CancelledBySeller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"DisputeResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"Released\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"SellerCancelDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"SellerRequestedCancel\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_referralFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_token\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_tradeId\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"_seller\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenadd\",\"type\":\"address\"}],\"name\":\"buyerCancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_tradeId\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"_seller\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"disputetype\",\"type\":\"uint16\"}],\"name\":\"consumeDispute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_tradeId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sellerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_type\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"_sellerCancelInSeconds\",\"type\":\"uint32\"},{\"internalType\":\"address[2]\",\"name\":\"_Ref\",\"type\":\"address[2]\"},{\"internalType\":\"address[2]\",\"name\":\"_Tokens\",\"type\":\"address[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"_Type\",\"type\":\"uint256[2]\"}],\"name\":\"createEscrow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_tradeId\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"_seller\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"disableSellerCancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_tradeId\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"_seller\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_favour\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"disputeByMediator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"escrow_map\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"escrowStatus\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"setTimeSellerCancel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eType\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sellerDispute\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"buyerDispute\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"feeCollect\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referral_map\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referralAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referralTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referralType\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"registerStatus\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_tradeId\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"_seller\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"releseFunds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requestCancelMinimumTime\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_tradeId\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"_seller\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenadd\",\"type\":\"address\"}],\"name\":\"sellerCancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_tradeId\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"_seller\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellerRequestCancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newFeeAddress\",\"type\":\"address\"}],\"name\":\"setFeeAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feePercent\",\"type\":\"uint256\"}],\"name\":\"setFeePercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_newRequestCancelMinimumTime\",\"type\":\"uint32\"}],\"name\":\"setRequestCancellationMinimumTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"tokenallowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_type\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_type\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_refType\",\"type\":\"uint256\"}],\"name\":\"withdrawReferral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Future1exchange","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008b29cfb173abb7a7fe0a9dac4f5ede8da94872f3","Library":"","LicenseType":"None","SwarmSource":"bzzr://785c56ea73665a828dbd4fcad31e45cae7a12683041945cffa6fffb132fdc486"}]}