{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\ncontract PoolPortalInterface {\r\n  function buyPool\r\n  (\r\n    uint256 _amount,\r\n    uint _type,\r\n    ERC20 _poolToken\r\n  )\r\n  external\r\n  payable;\r\n\r\n  function sellPool\r\n  (\r\n    uint256 _amount,\r\n    uint _type,\r\n    ERC20 _poolToken\r\n  )\r\n  external\r\n  payable;\r\n\r\n  function getBacorConverterAddressByRelay(address relay)\r\n  public\r\n  view\r\n  returns(address converter);\r\n\r\n  function getBancorConnectorsAmountByRelayAmount\r\n  (\r\n    uint256 _amount,\r\n    ERC20 _relay\r\n  )\r\n  public view returns(uint256 bancorAmount, uint256 connectorAmount);\r\n\r\n  function getBancorConnectorsByRelay(address relay)\r\n  public\r\n  view\r\n  returns(\r\n    ERC20 BNTConnector,\r\n    ERC20 ERCConnector\r\n  );\r\n\r\n  function getBancorRatio(address _from, address _to, uint256 _amount)\r\n  public\r\n  view\r\n  returns(uint256);\r\n\r\n  function getUniswapConnectorsAmountByPoolAmount(\r\n    uint256 _amount,\r\n    address _exchange\r\n  )\r\n  public\r\n  view\r\n  returns(uint256 ethAmount, uint256 ercAmount);\r\n\r\n  function getUniswapTokenAmountByETH(address _token, uint256 _amount)\r\n  public\r\n  view\r\n  returns(uint256);\r\n\r\n  function getTokenByUniswapExchange(address _exchange)\r\n  public\r\n  view\r\n  returns(address);\r\n}\r\ncontract PermittedStabelsInterface {\r\n  mapping (address => bool) public permittedAddresses;\r\n}\r\n\r\n\r\ncontract ExchangePortalInterface {\r\n\r\n  event Trade(address src, uint256 srcAmount, address dest, uint256 destReceived);\r\n\r\n  function trade(\r\n    ERC20 _source,\r\n    uint256 _sourceAmount,\r\n    ERC20 _destination,\r\n    uint256 _type,\r\n    bytes32[] _additionalArgs,\r\n    bytes _additionalData\r\n  )\r\n    external\r\n    payable\r\n    returns (uint256);\r\n\r\n  function getValue(address _from, address _to, uint256 _amount) public view returns (uint256);\r\n  function getTotalValue(address[] _fromAddresses, uint256[] _amounts, address _to) public view returns (uint256);\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract IOneSplitAudit {\r\n  function swap(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 amount,\r\n        uint256 minReturn,\r\n        uint256[] memory distribution,\r\n        uint256 disableFlags\r\n    ) public payable;\r\n\r\n  function getExpectedReturn(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 amount,\r\n        uint256 parts,\r\n        uint256 featureFlags // See contants in IOneSplit.sol\r\n    )\r\n      public\r\n      view\r\n      returns(\r\n          uint256 returnAmount,\r\n          uint256[] memory distribution\r\n      );\r\n}\r\n\r\n\r\ncontract PathFinderInterface {\r\n function generatePath(address _sourceToken, address _targetToken) public view returns (address[] memory);\r\n}\r\n\r\n\r\n\r\n/*\r\n    Bancor Network interface\r\n*/\r\ncontract BancorNetworkInterface {\r\n   function getReturnByPath(ERC20[] _path, uint256 _amount) public view returns (uint256, uint256);\r\n\r\n    function convert(\r\n        ERC20[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn\r\n    ) public payable returns (uint256);\r\n\r\n    function claimAndConvert(\r\n        ERC20[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn\r\n    ) public returns (uint256);\r\n\r\n    function convertFor(\r\n        ERC20[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for\r\n    ) public payable returns (uint256);\r\n\r\n    function claimAndConvertFor(\r\n        ERC20[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for\r\n    ) public returns (uint256);\r\n\r\n}\r\n\r\n\r\ncontract IGetBancorAddressFromRegistry{\r\n  function getBancorContractAddresByName(string _name) public view returns (address result);\r\n}\r\n\r\n\r\ncontract IParaswapParams{\r\n  function getParaswapParamsFromBytes32Array(bytes32[] memory _additionalArgs)\r\n  public pure returns\r\n  (\r\n    uint256 minDestinationAmount,\r\n    address[] memory callees,\r\n    uint256[] memory startIndexes,\r\n    uint256[] memory values,\r\n    uint256 mintPrice\r\n  );\r\n}\r\n\r\n\r\ncontract IPriceFeed{\r\n  function getBestPriceSimple(address _from, address _to, uint256 _amount) public view returns (uint256 result);\r\n}\r\n\r\n\r\ncontract ParaswapInterface{\r\n  function swap(\r\n     address sourceToken,\r\n     address destinationToken,\r\n     uint256 sourceAmount,\r\n     uint256 minDestinationAmount,\r\n     address[] memory callees,\r\n     bytes memory exchangeData,\r\n     uint256[] memory startIndexes,\r\n     uint256[] memory values,\r\n     string memory referrer,\r\n     uint256 mintPrice\r\n   )\r\n   public\r\n   payable;\r\n\r\n   function getTokenTransferProxy() external view returns (address);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/*\r\n* This contract do trade via Paraswap, Bancor and Uniswap, and then return assets to smart funds\r\n* and also allow get ratio between smart fund assets\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title DetailedERC20 token\r\n * @dev The decimals are only for visualization purposes.\r\n * All the operations are done using the smallest and indivisible token unit,\r\n * just as on Ethereum all the operations are done in wei.\r\n */\r\ncontract DetailedERC20 is ERC20 {\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n\r\n  constructor(string _name, string _symbol, uint8 _decimals) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ExchangePortal is ExchangePortalInterface, Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  uint public version = 2;\r\n\r\n  // PARASWAP\r\n  address public paraswap;\r\n  ParaswapInterface public paraswapInterface;\r\n  IPriceFeed public priceFeedInterface;\r\n  IParaswapParams public paraswapParams;\r\n  address public paraswapSpender;\r\n\r\n  // 1INCH\r\n  IOneSplitAudit public oneInch;\r\n\r\n  // BANCOR\r\n  address public BancorEtherToken;\r\n  IGetBancorAddressFromRegistry public bancorRegistry;\r\n\r\n  // CoTrader additional\r\n  PoolPortalInterface public poolPortal;\r\n  PermittedStabelsInterface public permitedStable;\r\n\r\n  // Enum\r\n  enum ExchangeType { Paraswap, Bancor, OneInch}\r\n\r\n  // This contract recognizes ETH by this address\r\n  ERC20 constant private ETH_TOKEN_ADDRESS = ERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n\r\n  // Trade event\r\n  event Trade(\r\n     address trader,\r\n     address src,\r\n     uint256 srcAmount,\r\n     address dest,\r\n     uint256 destReceived,\r\n     uint8 exchangeType);\r\n\r\n  // black list for non trade able tokens\r\n  mapping (address => bool) disabledTokens;\r\n\r\n  // Modifier to check that trading this token is not disabled\r\n  modifier tokenEnabled(ERC20 _token) {\r\n    require(!disabledTokens[address(_token)]);\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev contructor\r\n  *\r\n  * @param _paraswap               paraswap main address\r\n  * @param _paraswapPrice          paraswap price feed address\r\n  * @param _paraswapParams         helper contract for convert params from bytes32\r\n  * @param _bancorRegistryWrapper  address of Bancor Registry Wrapper\r\n  * @param _BancorEtherToken       address of Bancor ETH wrapper\r\n  * @param _permitedStable         address of permitedStable contract\r\n  * @param _poolPortal             address of pool portal\r\n  * @param _oneInch                address of OneSplitAudit contract\r\n  */\r\n  constructor(\r\n    address _paraswap,\r\n    address _paraswapPrice,\r\n    address _paraswapParams,\r\n    address _bancorRegistryWrapper,\r\n    address _BancorEtherToken,\r\n    address _permitedStable,\r\n    address _poolPortal,\r\n    address _oneInch\r\n    )\r\n    public\r\n    {\r\n    paraswap = _paraswap;\r\n    paraswapInterface = ParaswapInterface(_paraswap);\r\n    priceFeedInterface = IPriceFeed(_paraswapPrice);\r\n    paraswapParams = IParaswapParams(_paraswapParams);\r\n    paraswapSpender = paraswapInterface.getTokenTransferProxy();\r\n    bancorRegistry = IGetBancorAddressFromRegistry(_bancorRegistryWrapper);\r\n    BancorEtherToken = _BancorEtherToken;\r\n    permitedStable = PermittedStabelsInterface(_permitedStable);\r\n    poolPortal = PoolPortalInterface(_poolPortal);\r\n    oneInch = IOneSplitAudit(_oneInch);\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev Facilitates a trade for a SmartFund\r\n  *\r\n  * @param _source            ERC20 token to convert from\r\n  * @param _sourceAmount      Amount to convert from (in _source token)\r\n  * @param _destination       ERC20 token to convert to\r\n  * @param _type              The type of exchange to trade with (For now 0 - because only paraswap)\r\n  * @param _additionalArgs    Array of bytes32 additional arguments (For fixed size items and for different types items in array )\r\n  * @param _additionalData    For any size data (if not used set just 0x0)\r\n  *\r\n  * @return The amount of _destination received from the trade\r\n  */\r\n  function trade(\r\n    ERC20 _source,\r\n    uint256 _sourceAmount,\r\n    ERC20 _destination,\r\n    uint256 _type,\r\n    bytes32[] _additionalArgs,\r\n    bytes _additionalData\r\n  )\r\n    external\r\n    payable\r\n    tokenEnabled(_destination)\r\n    returns (uint256)\r\n  {\r\n\r\n    require(_source != _destination);\r\n\r\n    uint256 receivedAmount;\r\n\r\n    if (_source == ETH_TOKEN_ADDRESS) {\r\n      require(msg.value == _sourceAmount);\r\n    } else {\r\n      require(msg.value == 0);\r\n    }\r\n\r\n    // SHOULD TRADE PARASWAP HERE\r\n    if (_type == uint(ExchangeType.Paraswap)) {\r\n      // call paraswap\r\n      receivedAmount = _tradeViaParaswap(\r\n          _source,\r\n          _destination,\r\n          _sourceAmount,\r\n          _additionalData,\r\n          _additionalArgs\r\n      );\r\n    }\r\n    // SHOULD TRADE BANCOR HERE\r\n    else if (_type == uint(ExchangeType.Bancor)){\r\n      receivedAmount = _tradeViaBancorNewtork(\r\n          _source,\r\n          _destination,\r\n          _sourceAmount\r\n      );\r\n    }\r\n    // SHOULD TRADE 1INCH HERE\r\n    else if (_type == uint(ExchangeType.OneInch)){\r\n      receivedAmount = _tradeViaOneInch(\r\n          _source,\r\n          _destination,\r\n          _sourceAmount\r\n      );\r\n    }\r\n\r\n    else {\r\n      // unknown exchange type\r\n      revert();\r\n    }\r\n\r\n    // Check if Ether was received\r\n    if (_destination == ETH_TOKEN_ADDRESS) {\r\n      (msg.sender).transfer(receivedAmount);\r\n    } else {\r\n      // transfer tokens received to sender\r\n      _destination.transfer(msg.sender, receivedAmount);\r\n    }\r\n\r\n    // After the trade, any _source that exchangePortal holds will be sent back to msg.sender\r\n    uint256 endAmount = (_source == ETH_TOKEN_ADDRESS) ? address(this).balance : _source.balanceOf(address(this));\r\n\r\n    // Check if we hold a positive amount of _source\r\n    if (endAmount > 0) {\r\n      if (_source == ETH_TOKEN_ADDRESS) {\r\n        (msg.sender).transfer(endAmount);\r\n      } else {\r\n        _source.transfer(msg.sender, endAmount);\r\n      }\r\n    }\r\n\r\n    emit Trade(msg.sender, _source, _sourceAmount, _destination, receivedAmount, uint8(_type));\r\n\r\n    return receivedAmount;\r\n  }\r\n\r\n\r\n  // Facilitates trade with Paraswap\r\n  function _tradeViaParaswap(\r\n    address sourceToken,\r\n    address destinationToken,\r\n    uint256 sourceAmount,\r\n    bytes   exchangeData,\r\n    bytes32[] _additionalArgs\r\n )\r\n   private\r\n   returns (uint256 destinationReceived)\r\n {\r\n   (uint256 minDestinationAmount,\r\n    address[] memory callees,\r\n    uint256[] memory startIndexes,\r\n    uint256[] memory values,\r\n    uint256 mintPrice) = paraswapParams.getParaswapParamsFromBytes32Array(_additionalArgs);\r\n\r\n   if (ERC20(sourceToken) == ETH_TOKEN_ADDRESS) {\r\n     paraswapInterface.swap.value(sourceAmount)(\r\n       sourceToken,\r\n       destinationToken,\r\n       sourceAmount,\r\n       minDestinationAmount,\r\n       callees,\r\n       exchangeData,\r\n       startIndexes,\r\n       values,\r\n       \"CoTrader\", // referrer\r\n       mintPrice\r\n     );\r\n   } else {\r\n     _transferFromSenderAndApproveTo(ERC20(sourceToken), sourceAmount, paraswapSpender);\r\n     paraswapInterface.swap(\r\n       sourceToken,\r\n       destinationToken,\r\n       sourceAmount,\r\n       minDestinationAmount,\r\n       callees,\r\n       exchangeData,\r\n       startIndexes,\r\n       values,\r\n       \"CoTrader\", // referrer\r\n       mintPrice\r\n     );\r\n   }\r\n\r\n   destinationReceived = tokenBalance(ERC20(destinationToken));\r\n }\r\n\r\n // Facilitates trade with 1inch\r\n function _tradeViaOneInch(\r\n   address sourceToken,\r\n   address destinationToken,\r\n   uint256 sourceAmount\r\n   )\r\n   private\r\n   returns(uint256 destinationReceived)\r\n {\r\n    (, uint256[] memory distribution) = oneInch.getExpectedReturn(\r\n      IERC20(sourceToken),\r\n      IERC20(destinationToken),\r\n      sourceAmount,\r\n      10,\r\n      0);\r\n\r\n    if(ERC20(sourceToken) == ETH_TOKEN_ADDRESS) {\r\n      oneInch.swap.value(sourceAmount)(\r\n        IERC20(sourceToken),\r\n        IERC20(destinationToken),\r\n        sourceAmount,\r\n        1,\r\n        distribution,\r\n        0\r\n        );\r\n    } else {\r\n      oneInch.swap(\r\n        IERC20(sourceToken),\r\n        IERC20(destinationToken),\r\n        sourceAmount,\r\n        1,\r\n        distribution,\r\n        0\r\n        );\r\n    }\r\n\r\n    destinationReceived = tokenBalance(ERC20(destinationToken));\r\n }\r\n\r\n\r\n // Facilitates trade with Bancor\r\n function _tradeViaBancorNewtork(\r\n   address sourceToken,\r\n   address destinationToken,\r\n   uint256 sourceAmount\r\n   )\r\n   private\r\n   returns(uint256 returnAmount)\r\n {\r\n    // get latest bancor contracts\r\n    BancorNetworkInterface bancorNetwork = BancorNetworkInterface(\r\n      bancorRegistry.getBancorContractAddresByName(\"BancorNetwork\")\r\n    );\r\n\r\n    PathFinderInterface pathFinder = PathFinderInterface(\r\n      bancorRegistry.getBancorContractAddresByName(\"BancorNetworkPathFinder\")\r\n    );\r\n\r\n    // Change source and destination to Bancor ETH wrapper\r\n    address source = ERC20(sourceToken) == ETH_TOKEN_ADDRESS ? BancorEtherToken : sourceToken;\r\n    address destination = ERC20(destinationToken) == ETH_TOKEN_ADDRESS ? BancorEtherToken : destinationToken;\r\n\r\n    // Get Bancor tokens path\r\n    address[] memory path = pathFinder.generatePath(source, destination);\r\n\r\n    // Convert addresses to ERC20\r\n    ERC20[] memory pathInERC20 = new ERC20[](path.length);\r\n    for(uint i=0; i<path.length; i++){\r\n        pathInERC20[i] = ERC20(path[i]);\r\n    }\r\n\r\n    // trade\r\n    if (ERC20(sourceToken) == ETH_TOKEN_ADDRESS) {\r\n      returnAmount = bancorNetwork.convert.value(sourceAmount)(pathInERC20, sourceAmount, 1);\r\n    }\r\n    else {\r\n      _transferFromSenderAndApproveTo(ERC20(sourceToken), sourceAmount, address(bancorNetwork));\r\n      returnAmount = bancorNetwork.claimAndConvert(pathInERC20, sourceAmount, 1);\r\n    }\r\n }\r\n\r\n\r\n function tokenBalance(ERC20 _token) private view returns (uint256) {\r\n   if (_token == ETH_TOKEN_ADDRESS)\r\n     return address(this).balance;\r\n   return _token.balanceOf(address(this));\r\n }\r\n\r\n  /**\r\n  * @dev Transfers tokens to this contract and approves them to another address\r\n  *\r\n  * @param _source          Token to transfer and approve\r\n  * @param _sourceAmount    The amount to transfer and approve (in _source token)\r\n  * @param _to              Address to approve to\r\n  */\r\n  function _transferFromSenderAndApproveTo(ERC20 _source, uint256 _sourceAmount, address _to) private {\r\n    require(_source.transferFrom(msg.sender, address(this), _sourceAmount));\r\n\r\n    _source.approve(_to, _sourceAmount);\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev Gets the ratio by amount of token _from in token _to\r\n  *\r\n  * @param _from      Address of token we're converting from\r\n  * @param _to        Address of token we're getting the value in\r\n  * @param _amount    The amount of _from\r\n  *\r\n  * @return best price from Paraswap or 1inch for ERC20, or ratio for Uniswap and Bancor pools\r\n  */\r\n  function getValue(address _from, address _to, uint256 _amount) public view returns (uint256) {\r\n     if(_amount > 0){\r\n       // If Paraswap return 0, check from 1inch for ensure\r\n       uint256 paraswapResult = getValueViaParaswap(_from, _to, _amount);\r\n       if(paraswapResult > 0)\r\n         return paraswapResult;\r\n\r\n       // If 1inch return 0, check from Bancor network for ensure this is not a Bancor pool\r\n       uint256 oneInchResult = getValueViaOneInch(_from, _to, _amount);\r\n       if(oneInchResult > 0)\r\n         return oneInchResult;\r\n\r\n       // If Bancor return 0, check from Uniswap pools for ensure this is not Uniswap pool\r\n       uint256 bancorResult = getValueViaBancor(_from, _to, _amount);\r\n       if(bancorResult > 0)\r\n          return bancorResult;\r\n\r\n       // Uniswap pools return 0 if these are not Uniswap assets\r\n       return getValueForUniswapPools(_from, _to, _amount);\r\n     }else{\r\n       return 0;\r\n     }\r\n  }\r\n\r\n  // helper for get ratio between assets in Paraswap platform\r\n  function getValueViaParaswap(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount\r\n  ) public view returns (uint256 value) {\r\n    // Check call Paraswap (Because Paraswap can return error for some not supported  assets)\r\n    (bool success) = address(priceFeedInterface).call(\r\n    abi.encodeWithSelector(priceFeedInterface.getBestPriceSimple.selector, _from, _to, _amount));\r\n    // if Paraswap can get rate for this assets, use Paraswap\r\n    if(success){\r\n      value = priceFeedInterface.getBestPriceSimple(_from, _to, _amount);\r\n    }else{\r\n      value = 0;\r\n    }\r\n  }\r\n\r\n  // helper for get ratio between assets in 1inch platform\r\n  function getValueViaOneInch(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount\r\n  ) public view returns (uint256 value) {\r\n    // Check call 1inch\r\n    (bool success) = address(oneInch).call(\r\n    abi.encodeWithSelector(oneInch.getExpectedReturn.selector, IERC20(_from), IERC20(_to), _amount));\r\n    // if 1inch can get rate for this assets, use 1inch\r\n    if(success){\r\n      (uint256 returnAmount, ) = oneInch.getExpectedReturn(\r\n        IERC20(_from),\r\n        IERC20(_to),\r\n        _amount,\r\n        10,\r\n        0);\r\n      value = returnAmount;\r\n    }else{\r\n      value = 0;\r\n    }\r\n  }\r\n\r\n  // helper for get ratio between assets in Bancor network\r\n  function getValueViaBancor(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount\r\n  )\r\n  public\r\n  view\r\n  returns (uint256 value)\r\n  {\r\n    // Check call Bancor (Because Bancor can return error for some not supported assets)\r\n    (bool success) = address(poolPortal).call(\r\n    abi.encodeWithSelector(poolPortal.getBancorRatio.selector, _from, _to, _amount));\r\n    // if Bancor can get rate for this assets use Bancor\r\n    if(success){\r\n      value = poolPortal.getBancorRatio(_from, _to, _amount);\r\n    }else{\r\n      value = 0;\r\n    }\r\n  }\r\n\r\n  // helper for get ratio between pools in Uniswap network\r\n  // _from - uniswap pool address\r\n  function getValueForUniswapPools(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount\r\n  )\r\n  public\r\n  view\r\n  returns (uint256)\r\n  {\r\n    // get connectors amount\r\n    (uint256 ethAmount,\r\n     uint256 ercAmount) = poolPortal.getUniswapConnectorsAmountByPoolAmount(\r\n      _amount,\r\n      _from\r\n    );\r\n    // get ERC amount in ETH\r\n    address token = poolPortal.getTokenByUniswapExchange(_from);\r\n    uint256 ercAmountInETH = getValueViaParaswap(token, ETH_TOKEN_ADDRESS, ercAmount);\r\n    // sum ETH with ERC amount in ETH\r\n    uint256 totalETH = ethAmount.add(ercAmountInETH);\r\n\r\n    // if no USD based fund return just ETH\r\n    if(!permitedStable.permittedAddresses(_to))\r\n       return totalETH;\r\n    // else convert ETH result to USD and return value in USD\r\n    return getValueViaParaswap(ETH_TOKEN_ADDRESS, _to, totalETH);\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the total value of array of tokens and amounts\r\n  *\r\n  * @param _fromAddresses    Addresses of all the tokens we're converting from\r\n  * @param _amounts          The amounts of all the tokens\r\n  * @param _to               The token who's value we're converting to\r\n  *\r\n  * @return The total value of _fromAddresses and _amounts in terms of _to\r\n  */\r\n  function getTotalValue(address[] _fromAddresses, uint256[] _amounts, address _to) public view returns (uint256) {\r\n    uint256 sum = 0;\r\n    for (uint256 i = 0; i < _fromAddresses.length; i++) {\r\n      sum = sum.add(getValue(_fromAddresses[i], _to, _amounts[i]));\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n  * @dev Allows the owner to disable/enable the buying of a token\r\n  *\r\n  * @param _token      Token address whos trading permission is to be set\r\n  * @param _enabled    New token permission\r\n  */\r\n  function setToken(address _token, bool _enabled) external onlyOwner {\r\n    disabledTokens[_token] = _enabled;\r\n  }\r\n\r\n  // owner can change IFeed\r\n  function setNewIFeed(address _paraswapPrice) external onlyOwner {\r\n    priceFeedInterface = IPriceFeed(_paraswapPrice);\r\n  }\r\n\r\n  // owner can change paraswap spender address\r\n  function setNewParaswapSpender(address _paraswapSpender) external onlyOwner {\r\n    paraswapSpender = _paraswapSpender;\r\n  }\r\n\r\n  // owner can change paraswap Augustus\r\n  function setNewParaswapMain(address _paraswap) external onlyOwner {\r\n    paraswapInterface = ParaswapInterface(_paraswap);\r\n  }\r\n\r\n  // owner can change oneInch\r\n  function setNewOneInch(address _oneInch) external onlyOwner {\r\n    oneInch = IOneSplitAudit(_oneInch);\r\n  }\r\n\r\n  // fallback payable function to receive ether from other contract addresses\r\n  function() public payable {}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"oneInch\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paraswapPrice\",\"type\":\"address\"}],\"name\":\"setNewIFeed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oneInch\",\"type\":\"address\"}],\"name\":\"setNewOneInch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bancorRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getValueForUniswapPools\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getValueViaParaswap\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolPortal\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceFeedInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getValueViaBancor\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"permitedStable\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paraswapInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_source\",\"type\":\"address\"},{\"name\":\"_sourceAmount\",\"type\":\"uint256\"},{\"name\":\"_destination\",\"type\":\"address\"},{\"name\":\"_type\",\"type\":\"uint256\"},{\"name\":\"_additionalArgs\",\"type\":\"bytes32[]\"},{\"name\":\"_additionalData\",\"type\":\"bytes\"}],\"name\":\"trade\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paraswap\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paraswap\",\"type\":\"address\"}],\"name\":\"setNewParaswapMain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paraswapSpender\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getValueViaOneInch\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paraswapSpender\",\"type\":\"address\"}],\"name\":\"setNewParaswapSpender\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BancorEtherToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paraswapParams\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fromAddresses\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"getTotalValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_paraswap\",\"type\":\"address\"},{\"name\":\"_paraswapPrice\",\"type\":\"address\"},{\"name\":\"_paraswapParams\",\"type\":\"address\"},{\"name\":\"_bancorRegistryWrapper\",\"type\":\"address\"},{\"name\":\"_BancorEtherToken\",\"type\":\"address\"},{\"name\":\"_permitedStable\",\"type\":\"address\"},{\"name\":\"_poolPortal\",\"type\":\"address\"},{\"name\":\"_oneInch\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"destReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"exchangeType\",\"type\":\"uint8\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"destReceived\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"}]","ContractName":"ExchangePortal","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000f92c1ad75005e6436b4ee84e88cb23ed8a290988000000000000000000000000c6a3ec2e62a932b94bac51b6b9511a4cb623e2e50000000000000000000000000595aaa68ad0fbeacdeeaa7b7d78f22717ade957000000000000000000000000178c68aefdcae5c9818e43addf6a2b66df534ed5000000000000000000000000c0829421c1d260bd3cb3e0f06cfe2d52db2ce315000000000000000000000000ad3d707c4e20931d83aff95d1c69b9086fa37d2b0000000000000000000000003f49feddb3c63e36552679bc972857312dc8b4b7000000000000000000000000c586bef4a0992c495cf22e1aeee4e446cecdee0e","Library":"","LicenseType":"None","SwarmSource":"bzzr://fe1969d84408fb3952b471a579d30f6767740af9869f334cef20f7339598e233"}]}