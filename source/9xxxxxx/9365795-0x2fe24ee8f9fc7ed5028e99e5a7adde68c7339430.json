{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11;\r\n\r\n//Safe math libarry.\r\nlibrary SafeMath {\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n}\r\n\r\n//Main contract.\r\ncontract Syndicate {\r\n\r\n\tusing SafeMath for uint;   //decrlare safe math library usage\r\n    \r\n    //stablecoin reference.\r\n    address public eursAddress = 0xdB25f211AB05b1c97D595516F45794528a807ad8;   //EURS stablecoin for EUR currency\r\n    address public bgbpAddress = 0xC9a2C4868F0f96fAaa739b59934Dc9cB304112ec;   //BGBP stablecoin for GBP currency\r\n    address public usdtAddress = 0xdAC17F958D2ee523a2206206994597C13D831ec7;   //USDT stablecoin for USD currency\r\n    address public stablecoin;   //type of stablecoin used in smart contract where options are EURS, BGBP and USDT\r\n    uint256 public decimalCorrection;   //additional decimals (beyond cents/pennies) used in stablecoin, options = 1 (EURS), 1000000 (BGBP), 10000 (USDT)\r\n\r\n    //Admin data.\r\n    address public admin;   //admin's address\r\n    uint256 public adminShare = 40;   //admin's share percent from profit generated by syndicate\r\n    uint256 public adminProfit;   //total net profit which belongs to admin\r\n    \r\n    //Angel data.\r\n    address public angel;   //angel's (syndicate owner's) address\r\n    uint256 public angelInvestment;   //total amount of money angel has invested\r\n    uint256 public angelProfit;   //total net profit which belongs to angel\r\n\r\n    //Syndicate data.\r\n    uint256 public syndicateBalance = 0;   //current value of syndicate's balance\r\n    int256 public syndicateProfit = 0;   //syndicate's current profit\r\n    uint256 public distributionWaitTime;   //time (30 days) which needs to pass before monthly earnings are distributed among angel and admin\r\n    uint256 public closureWaitTime;   //time (48h) which angel needs to wait before he/she can close syndicate\r\n    \r\n    //User data.\r\n    struct Agreement {\r\n        uint256 lsBalance;   //user's current, contract enforced LoopSyndicate balance\r\n        uint256 lsInplay;   //user's current, contract enforced LoopSyndicate inplay balance\r\n        uint256 bookieBalance;   //user's bookmakers current, contract enforced total balance\r\n        uint256 bookieInplay;   //user's bookmakers current, contract enforced total inplay balance\r\n        uint256 userBankroll;   //user's current, contract enforced total capital\r\n        uint256 userProfit;   //total guaranteed profit user generated from placing bets and enforced by contract\r\n    }\r\n    mapping(address => Agreement) public userAgreements;\r\n    \r\n    //Betting data.\r\n    struct Betting {\r\n        uint256 lsBalance;   //user's LoopSyndicate new balance after settling latest bets placed by user\r\n        uint256 lsInplay;   //user's LoopSyndicate new inplay balance after settling latest bets placed by user\r\n        uint256 bookieBalance;   //user's bookmakers new total balance after settling latest bets placed by user\r\n        uint256 bookieInplay;   //user's bookmakers new total inplay balance after settling latest bets placed by user\r\n        uint256 userBankroll;   //user's new total capital after settling latest bets placed by user\r\n        uint256 userProfit;   //user's new guaranteed profit after settling latest bets placed by user\r\n        uint256 pubTime;   //publishing time of latest betting data\r\n    }\r\n    mapping(address => Betting) public bettingResults;\r\n\r\n    /*!new betting result's won't take actual effect, i.e. being set in \"Agreement\" data, if either user or angel \r\n    rejects this new betting result's data proposed by admin!*/\r\n    \r\n    //Insurance agreements status data.\r\n    bool public insuranceActive = true;   //angel's consent to insure users' value bets and provide guaranteed profit to them\r\n    mapping(address => bool) public brokenAgreements;   //list of users who rejected latest betting result's data proposed by admin\r\n    \r\n    //Set admin and angel addresses as well as currency choice on smart contract deployment.\r\n    constructor(address _angel, uint256 _currency) public {\r\n        //Admin and angel addresses.\r\n        admin = msg.sender;\r\n        angel = _angel;\r\n        //EUR\r\n        if (_currency == 1) {\r\n            stablecoin = eursAddress;\r\n            decimalCorrection = 1;\r\n        }\r\n        //GBP\r\n        else if (_currency == 2) {\r\n            stablecoin = bgbpAddress;\r\n            decimalCorrection = 1000000;\r\n        }\r\n        //USD\r\n        else if (_currency == 3) {\r\n            stablecoin = usdtAddress;\r\n            decimalCorrection = 10000;\r\n        }\r\n    }\r\n\r\n    //Create admin modifier to ensure that only admin can call certain functions.\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"only admin allowed to call this function\");\r\n        _;\r\n    }\r\n\r\n    //Event which is being emitted when user or angel breaks insurance agreement.\r\n    event AgreementBreak (\r\n        address _from\r\n    );\r\n\r\n    //Event which is being emitted when angel announces his/her syndicate closure.\r\n    event ClosureAnnouncement (\r\n        address _from\r\n    );\r\n    \r\n    //Allow angel to deposit into syndicate.\r\n    function angelDeposit(address _from, uint256 _value) public {\r\n        //Make sure angel's deposit value is at least 100 units (cents/pennies).\r\n        require(_value >= 100, \"deposit value less than minimum (100 cents/pennies)\");\r\n        //Make sure angel address matches.\r\n        require(_from == angel, \"from address does not match angel address\");\r\n        //Convert cents/pennies into coins.\r\n        uint256 _coins = decimalCorrection.mul(_value);\r\n        //Make transfer from angel's private wallet into Syndicate contract and make sure transfer was successful.\r\n        address _to = address(this);\r\n        (bool _success,) = stablecoin.call(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", _from, _to, _coins));\r\n        require(_success, \"error at stablecoin transferFrom function\");\r\n        //Update syndicate's balance value.\r\n        syndicateBalance += _value;\r\n        //Update angel's investment value.\r\n        angelInvestment += _value;\r\n    }\r\n    \r\n    //Allow user to make deposit.\r\n    function userDeposit(address _from, uint256 _value) public {\r\n        //Make sure angel has active insurance agreement.\r\n        require(insuranceActive, \"angel has closed this syndicate\");\r\n        //Make sure user's deposit value is at least 100 units (cents/pennies).\r\n        require(_value >= 100, \"deposit value must be minimum 100 cents/pennies\");\r\n        //Convert cents/pennies into coins.\r\n        uint256 _coins = decimalCorrection.mul(_value);\r\n        //Make deposit and make sure it was successful.\r\n        address _to = address(this);\r\n        (bool _success,) = stablecoin.call(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", _from, _to, _coins));\r\n        require(_success, \"error at stablecoin transferFrom function\");\r\n        //Update user's balance.\r\n        Agreement memory _agreement = userAgreements[_from];\r\n        _agreement.lsBalance = _agreement.lsBalance + _value;\r\n        userAgreements[_from] = _agreement;\r\n        //Update user's betting results because of new deposit.\r\n        Betting memory _result = bettingResults[_from];\r\n        _result.lsBalance = _result.lsBalance + _value;\r\n        bettingResults[_from] = _result;\r\n    }\r\n    \r\n    //Display user's latest betting results.\r\n    function displayResults(address _user, uint256 _lsBalance, uint256 _lsInplay, uint256 _bookieBalance, uint256 _bookieInplay, uint256 _userBankroll, uint256 _userProfit) public onlyAdmin {\r\n        //Make sure angel has active insurance agreement.\r\n        require(insuranceActive, \"angel has closed this syndicate\");\r\n        //Make sure user has active insurance agreement.\r\n        require(!(brokenAgreements[_user]), \"user has broken agreement\");\r\n        //Make sure user has balance (if user does not have balance then betting was not possible).\r\n        Agreement memory _agreement = userAgreements[_user];\r\n        require(_agreement.lsBalance > 0 || _agreement.lsInplay > 0, \"user does not have balance\");\r\n        //Make sure previous betting results were applied.\r\n        Betting memory _result = bettingResults[_user];\r\n        require(_result.pubTime == 0, \"previous betting results were not applied\");\r\n        //Set new betting results data.\r\n        _result.lsBalance = _lsBalance;\r\n        _result.lsInplay = _lsInplay;\r\n        _result.bookieBalance = _bookieBalance;\r\n        _result.bookieInplay = _bookieInplay;\r\n        _result.userBankroll = _userBankroll;\r\n        _result.userProfit = _userProfit;\r\n        _result.pubTime = block.timestamp;\r\n        bettingResults[_user] = _result;\r\n    }\r\n\r\n    //Allow angel to break insurance agreement.\r\n    function disableInsurance() public {\r\n        //Make sure angel is calling this function.\r\n        require(msg.sender == angel, \"msg sender address does not match angel address\");\r\n        /*By breaking insurance agreement angel rejects any changes to be made to syndicate's balance value but in exchange all \r\n        profit angel generated will be wiped out as a punishment and 10000 cents/pennies will be payed by angel as \r\n        a fine. Admin's profit share is also wiped out.*/\r\n        insuranceActive = false;\r\n        //Apply 10000 cents/pennies fine to angel.\r\n        if (syndicateBalance >= 10000) {\r\n            syndicateBalance -= 10000;\r\n            syndicateProfit -= 10000;\r\n        }\r\n        else {\r\n            syndicateBalance = 0;\r\n            syndicateProfit = 0;\r\n        }\r\n        //Wipe out all profit if such exists.\r\n        if (syndicateProfit > 0) {\r\n            syndicateBalance -= uint(syndicateProfit);\r\n            syndicateProfit = 0;\r\n        }\r\n        //Emit signal when angel breaks agreement.\r\n        emit AgreementBreak(msg.sender);\r\n    }\r\n    \r\n    //Allow user to break insurance agreement.\r\n    function breakAgreement() public {\r\n        /*By setting broken agreements to true user rejects any changes to be made to his/her current Agreement \r\n        data and stops receiving Angel insurance service and guaranteed profit.*/\r\n        brokenAgreements[msg.sender] = true;\r\n        //Emit signal when user breaks agreement.\r\n        emit AgreementBreak(msg.sender);\r\n    }\r\n    \r\n    //Confirm latest user betting results as new agreement.\r\n    function setNewAgreement(address _user) public onlyAdmin returns(bool) {\r\n        //Make sure angel has active insurance agreement.\r\n        require(insuranceActive, \"angel has closed this syndicate\");\r\n        //Make sure user has active insurance agreement.\r\n        require(!(brokenAgreements[_user]), \"user has broken agreement\");\r\n        //Make sure user has balance (if user does not have balance then betting was not possible).\r\n        Agreement memory _agreement = userAgreements[_user];\r\n        require(_agreement.lsBalance > 0 || _agreement.lsInplay > 0, \"user does not have balance\");\r\n        /*Make sure 23h passed since betting results were displayed where user had enough time to reject betting \r\n        results and break agreement.*/\r\n        Betting memory _result = bettingResults[_user];\r\n        uint256 _waitLimit = _result.pubTime + 82800;   //there are 82,800 seconds in 23h\r\n        if (_result.pubTime == 0 || block.timestamp < _waitLimit) {\r\n            return false;\r\n        }\r\n        //Calculate syndicate's profit or loss based on new betting results.\r\n       \tuint256 _prevTotalLoopBalance = _agreement.lsBalance + _agreement.lsInplay;\r\n       \tuint256 _newTotalLoopBalance = _result.lsBalance + _result.lsInplay;\r\n        int256 _profit = int(_prevTotalLoopBalance) - int(_newTotalLoopBalance);\r\n        //Update syndicate's balance and profit.\r\n        if (_profit < 0) {\r\n            syndicateBalance -= uint(_profit);\r\n        }\r\n        else {\r\n            syndicateBalance += uint(_profit);\r\n        }\r\n        syndicateProfit += _profit;\r\n        //Set user's new accepted agreement data.\r\n        _agreement.lsBalance = _result.lsBalance;\r\n        _agreement.lsInplay = _result.lsInplay;\r\n        _agreement.bookieBalance = _result.bookieBalance;\r\n        _agreement.bookieInplay = _result.bookieInplay;\r\n        _agreement.userBankroll = _result.userBankroll;\r\n        _agreement.userProfit = _result.userProfit;\r\n        userAgreements[_user] = _agreement;\r\n        //Reset user's latest betting results.\r\n        bettingResults[_user] = Betting(0, 0, 0, 0, 0, 0, 0);\r\n        return true;\r\n    }\r\n    \r\n    //Allow user to withdraw his/her balance.\r\n    function userWithdraw(uint256 _value) public {\r\n        Agreement memory _agreement = userAgreements[msg.sender];\r\n        Betting memory _result = bettingResults[msg.sender];\r\n        /*If user broke insurance agreement then voild all active bets and allow him/her to withdraw balance as \r\n        recorded in last valid agreement.*/\r\n        if (brokenAgreements[msg.sender]) {\r\n            _value = _agreement.lsBalance + _agreement.lsInplay;\r\n            _agreement.lsBalance = _agreement.lsBalance + _agreement.lsInplay;\r\n            _agreement.lsInplay = 0;\r\n        }\r\n        //Otherwise validate withdrawal request.\r\n        else {\r\n            /*By making withdrawal user accepts last betting results to be enforced in contract as new agreement.*/\r\n            //Make sure user has enough balance.\r\n            require(_result.lsBalance >= _value, \"user balance is less than withdrawal value\");\r\n            //Calculate syndicate's profit or loss based on new betting results.\r\n\t       \tuint256 _prevTotalLoopBalance = _agreement.lsBalance + _agreement.lsInplay;\r\n\t       \tuint256 _newTotalLoopBalance = _result.lsBalance + _result.lsInplay;\r\n\t        int256 _profit = int(_prevTotalLoopBalance) - int(_newTotalLoopBalance);\r\n\t        //Update syndicate's balance and profit.\r\n\t        if (_profit < 0) {\r\n\t            syndicateBalance -= uint(_profit);\r\n\t        }\r\n\t        else {\r\n\t            syndicateBalance += uint(_profit);\r\n\t        }\r\n\t        syndicateProfit += _profit;\r\n            //Set user's new accepted agreement data.\r\n            _agreement.lsBalance = _result.lsBalance;\r\n            _agreement.lsInplay = _result.lsInplay;\r\n            _agreement.bookieBalance = _result.bookieBalance;\r\n            _agreement.bookieInplay = _result.bookieInplay;\r\n            _agreement.userBankroll = _result.userBankroll;\r\n            _agreement.userProfit = _result.userProfit;\r\n        }\r\n        //Convert cents/pennies into coins.\r\n        uint256 _coins = decimalCorrection.mul(_value);\r\n        //Make transfer from contract into user's private wallet and make sure it was successful.\r\n        (bool _success,) = stablecoin.call(abi.encodeWithSignature(\"transfer(address,uint256)\", msg.sender, _coins));\r\n        require(_success, \"error at stablecoin transfer function\");\r\n        //Update user's balance.\r\n        _agreement.lsBalance = _agreement.lsBalance - _value;\r\n        userAgreements[msg.sender] = _agreement;\r\n        //Set user's latest betting result's data same as agreement data because of new withdrawal.\r\n        _result.lsBalance = _agreement.lsBalance;\r\n        bettingResults[msg.sender] = _result;\r\n    }\r\n    \r\n    //Distribute monthly earnings.\r\n    function distributeEarnings() public returns(bool) {\r\n        //Make sure 30 days passed since last earnings distribution time.\r\n        require(block.timestamp > distributionWaitTime, \"month did not pass since last earnings distribution\");\r\n        //Make sure profit is at least 100 cents/pennies, otherwise don't bother to distribute earnings.\r\n        if (syndicateProfit < 100) {\r\n            return false;\r\n        }\r\n        //Let admin receive his share.\r\n        uint256 _share = uint(syndicateProfit) * adminShare / 100;\r\n        adminProfit += _share;\r\n        syndicateBalance -= _share;\r\n        syndicateProfit -= int(_share);\r\n        //Let angel to receive the rest.\r\n        angelProfit += uint(syndicateProfit);\r\n        syndicateBalance -= uint(syndicateProfit);\r\n        syndicateProfit = 0;\r\n        //Reset distribution wait time.\r\n        distributionWaitTime = block.timestamp + 2592000;   //there are 2,592,000 seconds in 30 days\r\n        return true;\r\n    }\r\n    \r\n    //Allow angel to withdraw profit.\r\n    function angelWithdraw() public {\r\n        //Make sure angel is making withdrawal.\r\n        require(msg.sender == angel, \"msg sender address does not match angel address\");\r\n        //Make sure angel has profit.\r\n        require(angelProfit > 0, \"angel does not have profit to withdraw\");\r\n        //Convert cents/pennies into coins.\r\n        uint256 _coins = decimalCorrection * angelProfit;\r\n        //Make transfer and update angel's profit value.\r\n        (bool _success,) = stablecoin.call(abi.encodeWithSignature(\"transfer(address,uint256)\", angel, _coins));\r\n        require(_success, \"error at stablecoin transfer function\");\r\n        angelProfit = 0;\r\n    }\r\n    \r\n    //Allow angel to reinvest profit back into syndicate.\r\n    function angelReinvest() public {\r\n        //Make sure angel is reinvesting profit.\r\n        require(msg.sender == angel, \"msg sender address does not match angel address\");\r\n        //Make sure angel has profit.\r\n        require(angelProfit > 0, \"angel does not have profit to reinvest\");\r\n        //Update syndicate balance value.\r\n        syndicateBalance += angelProfit;\r\n        //Set angel profit to zero.\r\n        angelProfit = 0;\r\n    }\r\n    \r\n    //Allow admin to withdraw profit.\r\n    function adminWithdraw(address _to) public onlyAdmin {\r\n        //Make sure admin has profit.\r\n        require(adminProfit > 0, \"admin does not have profit share\");\r\n        //Convert cents/pennies into coins.\r\n        uint256 _coins = decimalCorrection * adminProfit;\r\n        //Make transfer and update admin's profit value.\r\n        (bool _success,) = stablecoin.call(abi.encodeWithSignature(\"transfer(address,uint256)\", _to, _coins));\r\n        require(_success, \"error at stablecoin transfer function\");\r\n        adminProfit = 0;\r\n    }\r\n\r\n    //Announce syndicate closure.\r\n    function announceClosure() public {\r\n        //Make sure angel is making announcement.\r\n        require(msg.sender == angel, \"msg sender address does not match angel address\");\r\n        //Allow closure after 48 hours from current time.\r\n        closureWaitTime = block.timestamp + 172800;   //there are 172,800 seconds in 48 hours\r\n        //Emit signal when angel announces sydicate closure.\r\n        emit ClosureAnnouncement(msg.sender);\r\n    }\r\n\r\n    //Close angel's syndicate.\r\n    function closeSyndicate() public {\r\n        //Make sure 2 days passed since closure announcement.\r\n        require(block.timestamp > closureWaitTime && closureWaitTime != 0, \"2 days did not pass since closure announcement\");\r\n        //Subtract admin share from profit, if such exists.\r\n        if (syndicateProfit >= 100) {\r\n            uint256 _share = uint(syndicateProfit) * adminShare / 100;\r\n            adminProfit += _share;\r\n            syndicateBalance -= _share;\r\n            syndicateProfit = 0;\r\n        }\r\n        //Convert cents/pennies into coins.\r\n        uint256 _coins = decimalCorrection * syndicateBalance;\r\n        //Make transfer from contract into angel's private wallet and make sure it was successful.\r\n        (bool _success,) = stablecoin.call(abi.encodeWithSignature(\"transfer(address,uint256)\", angel, _coins));\r\n        require(_success, \"error at stablecoin transfer function\");\r\n        //Update syndicate's balance value.\r\n        syndicateBalance = 0;\r\n        //Reset angel investment value and disable insurance.\r\n        angelInvestment = 0;\r\n        insuranceActive = false;\r\n        //Reset closure wait time.\r\n        closureWaitTime = 0;\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"distributionWaitTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"breakAgreement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"angelDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"userWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"angel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimalCorrection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bgbpAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"insuranceActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"distributeEarnings\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeSyndicate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userAgreements\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lsBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lsInplay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bookieBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bookieInplay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userBankroll\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userProfit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"syndicateBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closureWaitTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usdtAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bettingResults\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lsBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lsInplay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bookieBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bookieInplay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userBankroll\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userProfit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pubTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"adminWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"setNewAgreement\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"angelProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"syndicateProfit\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"userDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableInsurance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"brokenAgreements\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eursAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"angelWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"angelInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"announceClosure\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stablecoin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"angelReinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lsBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lsInplay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bookieBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bookieInplay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_userBankroll\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_userProfit\",\"type\":\"uint256\"}],\"name\":\"displayResults\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_angel\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_currency\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"AgreementBreak\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"ClosureAnnouncement\",\"type\":\"event\"}]","ContractName":"Syndicate","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000f6bd4987b2f0cf23af2d15d03880b3dfe76c2d690000000000000000000000000000000000000000000000000000000000000001","Library":"","LicenseType":"None","SwarmSource":"bzzr://27add72adff86ce584ce5a365a5326f9e0fb3a09e7ec2c31851806350a943650"}]}