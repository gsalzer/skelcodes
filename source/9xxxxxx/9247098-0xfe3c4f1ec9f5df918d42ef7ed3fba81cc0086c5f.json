{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract EncryptedSender {\r\n    struct TopicData {\r\n        // An (optional) public key used to encrypt messages for this topic. This is only necessary if the sender will\r\n        // not have access to the public key offchain.\r\n        bytes publicKey;\r\n\r\n        // The encrypted message.\r\n        bytes message;\r\n    }\r\n\r\n    struct Recipient {\r\n        // This maps from a hash to the data for this topic.\r\n        // Note: the hash is a hash of the \"subject\" or \"topic\" of the message.\r\n        mapping(bytes32 => TopicData) topics;\r\n\r\n        // This contains the set of all authorized senders for this recipient.\r\n        mapping(address => bool) authorizedSenders;\r\n    }\r\n\r\n    mapping(address => Recipient) private recipients;\r\n\r\n    /**\r\n     * @notice Authorizes `sender` to send messages to the caller.\r\n     */\r\n    function addAuthorizedSender(address sender) external {\r\n        recipients[msg.sender].authorizedSenders[sender] = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Revokes `sender`'s authorization to send messages to the caller.\r\n     */\r\n    function removeAuthorizedSender(address sender) external {\r\n        recipients[msg.sender].authorizedSenders[sender] = false;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current stored message corresponding to `recipient` and `topicHash`.\r\n     * @dev To decrypt messages (this requires access to the recipient's private keys), use the decryptMessage()\r\n     * function in common/Crypto.js.\r\n     */\r\n    function getMessage(address recipient, bytes32 topicHash) external view returns (bytes memory) {\r\n        return recipients[recipient].topics[topicHash].message;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the stored public key for a particular `recipient` and `topicHash`. Return value will be 0 length\r\n     * if no public key has been set.\r\n     * @dev Senders may need this public key to encrypt messages that only the `recipient` can read. If the public key\r\n     * is communicated offchain, this field may be left empty.\r\n     */\r\n    function getPublicKey(address recipient, bytes32 topicHash) external view returns (bytes memory) {\r\n        return recipients[recipient].topics[topicHash].publicKey;\r\n    }\r\n\r\n    /**\r\n     * @notice Sends `message` to `recipient_` categorized by a particular `topicHash`. This will overwrite any\r\n     * previous messages sent to this `recipient` with this `topicHash`.\r\n     * @dev To construct an encrypted message, use the encryptMessage() in common/Crypto.js.\r\n     * The public key for the recipient can be obtained using the getPublicKey() method.\r\n     */\r\n    function sendMessage(address recipient_, bytes32 topicHash, bytes memory message) public {\r\n        Recipient storage recipient = recipients[recipient_];\r\n        require(isAuthorizedSender(msg.sender, recipient_), \"Not authorized to send to this recipient\");\r\n        recipient.topics[topicHash].message = message;\r\n    }\r\n\r\n    function removeMessage(address recipient_, bytes32 topicHash) public {\r\n        Recipient storage recipient = recipients[recipient_];\r\n        require(isAuthorizedSender(msg.sender, recipient_), \"Not authorized to remove message\");\r\n        delete recipient.topics[topicHash].message;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the public key for this caller and topicHash.\r\n     * @dev Note: setting the public key is optional - if the publicKey is communicated or can be derived offchain by\r\n     * the sender, there is no need to set it here. Because there are no specific requirements for the publicKey, there\r\n     * is also no verification of its validity other than its length.\r\n     */\r\n    function setPublicKey(bytes memory publicKey, bytes32 topicHash) public {\r\n        require(publicKey.length == 64, \"Public key is the wrong length\");\r\n        recipients[msg.sender].topics[topicHash].publicKey = publicKey;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns true if the `sender` is authorized to send to the `recipient`.\r\n     */\r\n    function isAuthorizedSender(address sender, address recipient) public view returns (bool) {\r\n        // Note: the recipient is always authorized to send messages to themselves.\r\n        return recipients[recipient].authorizedSenders[sender] || recipient == sender;\r\n    }\r\n}\r\n\r\nlibrary FixedPoint {\r\n\r\n    using SafeMath for uint;\r\n\r\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\r\n    // Can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint 10^77.\r\n    uint private constant FP_SCALING_FACTOR = 10**18;\r\n\r\n    struct Unsigned {\r\n        uint rawValue;\r\n    }\r\n\r\n    /** @dev Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5**18`. */\r\n    function fromUnscaledUint(uint a) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.mul(FP_SCALING_FACTOR));\r\n    }\r\n\r\n    /** @dev Whether `a` is greater than `b`. */\r\n    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\r\n        return a.rawValue > b.rawValue;\r\n    }\r\n\r\n    /** @dev Whether `a` is greater than `b`. */\r\n    function isGreaterThan(Unsigned memory a, uint b) internal pure returns (bool) {\r\n        return a.rawValue > fromUnscaledUint(b).rawValue;\r\n    }\r\n\r\n    /** @dev Whether `a` is greater than `b`. */\r\n    function isGreaterThan(uint a, Unsigned memory b) internal pure returns (bool) {\r\n        return fromUnscaledUint(a).rawValue > b.rawValue;\r\n    }\r\n\r\n    /** @dev Whether `a` is less than `b`. */\r\n    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\r\n        return a.rawValue < b.rawValue;\r\n    }\r\n\r\n    /** @dev Whether `a` is less than `b`. */\r\n    function isLessThan(Unsigned memory a, uint b) internal pure returns (bool) {\r\n        return a.rawValue < fromUnscaledUint(b).rawValue;\r\n    }\r\n\r\n    /** @dev Whether `a` is less than `b`. */\r\n    function isLessThan(uint a, Unsigned memory b) internal pure returns (bool) {\r\n        return fromUnscaledUint(a).rawValue < b.rawValue;\r\n    }\r\n\r\n    /** @dev Adds two `Unsigned`s, reverting on overflow. */\r\n    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.rawValue.add(b.rawValue));\r\n    }\r\n\r\n    /** @dev Adds an `Unsigned` to an unscaled uint, reverting on overflow. */\r\n    function add(Unsigned memory a, uint b) internal pure returns (Unsigned memory) {\r\n        return add(a, fromUnscaledUint(b));\r\n    }\r\n\r\n    /** @dev Subtracts two `Unsigned`s, reverting on underflow. */\r\n    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.rawValue.sub(b.rawValue));\r\n    }\r\n\r\n    /** @dev Subtracts an unscaled uint from an `Unsigned`, reverting on underflow. */\r\n    function sub(Unsigned memory a, uint b) internal pure returns (Unsigned memory) {\r\n        return sub(a, fromUnscaledUint(b));\r\n    }\r\n\r\n    /** @dev Subtracts an `Unsigned` from an unscaled uint, reverting on underflow. */\r\n    function sub(uint a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return sub(fromUnscaledUint(a), b);\r\n    }\r\n\r\n    /** @dev Multiplies two `Unsigned`s, reverting on overflow. */\r\n    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        // There are two caveats with this computation:\r\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\r\n        // stored internally as a uint ~10^59.\r\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\r\n        // would round to 3, but this computation produces the result 2.\r\n        // No need to use SafeMath because FP_SCALING_FACTOR != 0.\r\n        return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\r\n    }\r\n\r\n    /** @dev Multiplies an `Unsigned` by an unscaled uint, reverting on overflow. */\r\n    function mul(Unsigned memory a, uint b) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.rawValue.mul(b));\r\n    }\r\n\r\n    /** @dev Divides with truncation two `Unsigned`s, reverting on overflow or division by 0. */\r\n    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        // There are two caveats with this computation:\r\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\r\n        // 10^41 is stored internally as a uint 10^59.\r\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\r\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\r\n        return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\r\n    }\r\n\r\n    /** @dev Divides with truncation an `Unsigned` by an unscaled uint, reverting on division by 0. */\r\n    function div(Unsigned memory a, uint b) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.rawValue.div(b));\r\n    }\r\n\r\n    /** @dev Divides with truncation an unscaled uint by an `Unsigned`, reverting on overflow or division by 0. */\r\n    function div(uint a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return div(fromUnscaledUint(a), b);\r\n    }\r\n\r\n    /** @dev Raises an `Unsigned` to the power of an unscaled uint, reverting on overflow. E.g., `b=2` squares `a`. */\r\n    function pow(Unsigned memory a, uint b) internal pure returns (Unsigned memory output) {\r\n        // TODO(ptare): Consider using the exponentiation by squaring technique instead:\r\n        // https://en.wikipedia.org/wiki/Exponentiation_by_squaring\r\n        output = fromUnscaledUint(1);\r\n        for (uint i = 0; i < b; i = i.add(1)) {\r\n            output = mul(output, a);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary Exclusive {\r\n    struct RoleMembership {\r\n        address member;\r\n    }\r\n\r\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\r\n        return roleMembership.member == memberToCheck;\r\n    }\r\n\r\n    function resetMember(RoleMembership storage roleMembership, address newMember) internal {\r\n        require(newMember != address(0x0), \"Cannot set an exclusive role to 0x0\");\r\n        roleMembership.member = newMember;\r\n    }\r\n\r\n    function getMember(RoleMembership storage roleMembership) internal view returns (address) {\r\n        return roleMembership.member;\r\n    }\r\n\r\n    function init(RoleMembership storage roleMembership, address initialMember) internal {\r\n        resetMember(roleMembership, initialMember);\r\n    }\r\n}\r\n\r\nlibrary Shared {\r\n    struct RoleMembership {\r\n        mapping(address => bool) members;\r\n    }\r\n\r\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\r\n        return roleMembership.members[memberToCheck];\r\n    }\r\n\r\n    function addMember(RoleMembership storage roleMembership, address memberToAdd) internal {\r\n        roleMembership.members[memberToAdd] = true;\r\n    }\r\n\r\n    function removeMember(RoleMembership storage roleMembership, address memberToRemove) internal {\r\n        roleMembership.members[memberToRemove] = false;\r\n    }\r\n\r\n    function init(RoleMembership storage roleMembership, address[] memory initialMembers) internal {\r\n        for (uint i = 0; i < initialMembers.length; i++) {\r\n            addMember(roleMembership, initialMembers[i]);\r\n        }\r\n    }\r\n}\r\n\r\ncontract MultiRole {\r\n    using Exclusive for Exclusive.RoleMembership;\r\n    using Shared for Shared.RoleMembership;\r\n\r\n    enum RoleType { Invalid, Exclusive, Shared }\r\n\r\n    struct Role {\r\n        uint managingRole;\r\n        RoleType roleType;\r\n        Exclusive.RoleMembership exclusiveRoleMembership;\r\n        Shared.RoleMembership sharedRoleMembership;\r\n    }\r\n\r\n    mapping(uint => Role) private roles;\r\n\r\n    /**\r\n     * @notice Reverts unless the caller is a member of the specified roleId.\r\n     */\r\n    modifier onlyRoleHolder(uint roleId) {\r\n        require(holdsRole(roleId, msg.sender), \"Sender does not hold required role\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts unless the caller is a member of the manager role for the specified roleId.\r\n     */\r\n    modifier onlyRoleManager(uint roleId) {\r\n        require(holdsRole(roles[roleId].managingRole, msg.sender), \"Can only be called by a role manager\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts unless the roleId represents an initialized, exclusive roleId.\r\n     */\r\n    modifier onlyExclusive(uint roleId) {\r\n        require(roles[roleId].roleType == RoleType.Exclusive, \"Must be called on an initialized Exclusive role\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts unless the roleId represents an initialized, shared roleId.\r\n     */\r\n    modifier onlyShared(uint roleId) {\r\n        require(roles[roleId].roleType == RoleType.Shared, \"Must be called on an initialized Shared role\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `memberToCheck` is a member of roleId.\r\n     * @dev Reverts if roleId does not correspond to an initialized role.\r\n     */\r\n    function holdsRole(uint roleId, address memberToCheck) public view returns (bool) {\r\n        Role storage role = roles[roleId];\r\n        if (role.roleType == RoleType.Exclusive) {\r\n            return role.exclusiveRoleMembership.isMember(memberToCheck);\r\n        } else if (role.roleType == RoleType.Shared) {\r\n            return role.sharedRoleMembership.isMember(memberToCheck);\r\n        }\r\n        require(false, \"Invalid roleId\");\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the exclusive role holder of `roleId` to `newMember`.\r\n     * @dev Reverts if the caller is not a member of the managing role for `roleId` or if `roleId` is not an\r\n     * initialized, exclusive role.\r\n     */\r\n    function resetMember(uint roleId, address newMember) public onlyExclusive(roleId) onlyRoleManager(roleId) {\r\n        roles[roleId].exclusiveRoleMembership.resetMember(newMember);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current holder of the exclusive role, `roleId`.\r\n     * @dev Reverts if `roleId` does not represent an initialized, exclusive role.\r\n     */\r\n    function getMember(uint roleId) public view onlyExclusive(roleId) returns (address) {\r\n        return roles[roleId].exclusiveRoleMembership.getMember();\r\n    }\r\n\r\n    /**\r\n     * @notice Adds `newMember` to the shared role, `roleId`.\r\n     * @dev Reverts if `roleId` does not represent an initialized, shared role or if the caller is not a member of the\r\n     * managing role for `roleId`.\r\n     */\r\n    function addMember(uint roleId, address newMember) public onlyShared(roleId) onlyRoleManager(roleId) {\r\n        roles[roleId].sharedRoleMembership.addMember(newMember);\r\n    }\r\n\r\n    /**\r\n     * @notice Removes `memberToRemove` from the shared role, `roleId`.\r\n     * @dev Reverts if `roleId` does not represent an initialized, shared role or if the caller is not a member of the\r\n     * managing role for `roleId`.\r\n     */\r\n    function removeMember(uint roleId, address memberToRemove) public onlyShared(roleId) onlyRoleManager(roleId) {\r\n        roles[roleId].sharedRoleMembership.removeMember(memberToRemove);\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if `roleId` is not initialized.\r\n     */\r\n    modifier onlyValidRole(uint roleId) {\r\n        require(roles[roleId].roleType != RoleType.Invalid, \"Attempted to use an invalid roleId\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if `roleId` is initialized.\r\n     */\r\n    modifier onlyInvalidRole(uint roleId) {\r\n        require(roles[roleId].roleType == RoleType.Invalid, \"Cannot use a pre-existing role\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Internal method to initialize a shared role, `roleId`, which will be managed by `managingRoleId`.\r\n     * `initialMembers` will be immediately added to the role.\r\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\r\n     * initialized.\r\n     */\r\n    function _createSharedRole(uint roleId, uint managingRoleId, address[] memory initialMembers)\r\n        internal\r\n        onlyInvalidRole(roleId)\r\n    {\r\n        Role storage role = roles[roleId];\r\n        role.roleType = RoleType.Shared;\r\n        role.managingRole = managingRoleId;\r\n        role.sharedRoleMembership.init(initialMembers);\r\n        require(roles[managingRoleId].roleType != RoleType.Invalid,\r\n            \"Attempted to use an invalid role to manage a shared role\");\r\n    }\r\n\r\n    /**\r\n     * @notice Internal method to initialize a exclusive role, `roleId`, which will be managed by `managingRoleId`.\r\n     * `initialMembers` will be immediately added to the role.\r\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\r\n     * initialized.\r\n     */\r\n    function _createExclusiveRole(uint roleId, uint managingRoleId, address initialMember)\r\n        internal\r\n        onlyInvalidRole(roleId)\r\n    {\r\n        Role storage role = roles[roleId];\r\n        role.roleType = RoleType.Exclusive;\r\n        role.managingRole = managingRoleId;\r\n        role.exclusiveRoleMembership.init(initialMember);\r\n        require(roles[managingRoleId].roleType != RoleType.Invalid,\r\n            \"Attempted to use an invalid role to manage an exclusive role\");\r\n    }\r\n}\r\n\r\ninterface OracleInterface {\r\n\r\n    /**\r\n     * @notice Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.\r\n     * @dev Returns the time at which the user should expect the price to be resolved. 0 means the price has already\r\n     * been resolved.\r\n     */\r\n    function requestPrice(bytes32 identifier, uint time) external returns (uint expectedTime);\r\n\r\n    /**\r\n     * @notice Whether the Oracle provides prices for this identifier.\r\n     */\r\n    function isIdentifierSupported(bytes32 identifier) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Whether the price for `identifier` and `time` is available.\r\n     */\r\n    function hasPrice(bytes32 identifier, uint time) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Gets the price for `identifier` and `time` if it has already been requested and resolved.\r\n     * @dev If the price is not available, the method reverts.\r\n     */\r\n    function getPrice(bytes32 identifier, uint time) external view returns (int price);\r\n}\r\n\r\ninterface RegistryInterface {\r\n    /**\r\n     * @dev Registers a new derivative. Only authorized derivative creators can call this method.\r\n     */\r\n    function registerDerivative(address[] calldata counterparties, address derivativeAddress) external;\r\n\r\n    /**\r\n     * @dev Returns whether the derivative has been registered with the registry (and is therefore an authorized.\r\n     * participant in the UMA system).\r\n     */\r\n    function isDerivativeRegistered(address derivative) external view returns (bool isRegistered);\r\n\r\n    /**\r\n     * @dev Returns a list of all derivatives that are associated with a particular party.\r\n     */\r\n    function getRegisteredDerivatives(address party) external view returns (address[] memory derivatives);\r\n\r\n    /**\r\n     * @dev Returns all registered derivatives.\r\n     */\r\n    function getAllRegisteredDerivatives() external view returns (address[] memory derivatives);\r\n}\r\n\r\ncontract Registry is RegistryInterface, MultiRole {\r\n\r\n    using SafeMath for uint;\r\n\r\n    enum Roles {\r\n        // The owner manages the set of DerivativeCreators.\r\n        Owner,\r\n        // Can register derivatives.\r\n        DerivativeCreator\r\n    }\r\n\r\n    // Array of all derivatives that are approved to use the UMA Oracle.\r\n    address[] private registeredDerivatives;\r\n\r\n    // This enum is required because a WasValid state is required to ensure that derivatives cannot be re-registered.\r\n    enum PointerValidity {\r\n        Invalid,\r\n        Valid\r\n    }\r\n\r\n    struct Pointer {\r\n        PointerValidity valid;\r\n        uint128 index;\r\n    }\r\n\r\n    // Maps from derivative address to a pointer that refers to that registered derivative in `registeredDerivatives`.\r\n    mapping(address => Pointer) private derivativePointers;\r\n\r\n    // Note: this must be stored outside of `registeredDerivatives` because mappings cannot be deleted and copied\r\n    // like normal data. This could be stored in the Pointer struct, but storing it there would muddy the purpose\r\n    // of the Pointer struct and break separation of concern between referential data and data.\r\n    struct PartiesMap {\r\n        mapping(address => bool) parties;\r\n    }\r\n\r\n    // Maps from derivative address to the set of parties that are involved in that derivative.\r\n    mapping(address => PartiesMap) private derivativesToParties;\r\n\r\n    event NewDerivativeRegistered(address indexed derivativeAddress, address indexed creator, address[] parties);\r\n\r\n    constructor() public {\r\n        _createExclusiveRole(uint(Roles.Owner), uint(Roles.Owner), msg.sender);\r\n        // Start with no derivative creators registered.\r\n        _createSharedRole(uint(Roles.DerivativeCreator), uint(Roles.Owner), new address[](0));\r\n    }\r\n\r\n    function registerDerivative(address[] calldata parties, address derivativeAddress)\r\n        external\r\n        onlyRoleHolder(uint(Roles.DerivativeCreator))\r\n    {\r\n        // Create derivative pointer.\r\n        Pointer storage pointer = derivativePointers[derivativeAddress];\r\n\r\n        // Ensure that the pointer was not valid in the past (derivatives cannot be re-registered or double\r\n        // registered).\r\n        require(pointer.valid == PointerValidity.Invalid);\r\n        pointer.valid = PointerValidity.Valid;\r\n\r\n        registeredDerivatives.push(derivativeAddress);\r\n\r\n        // No length check necessary because we should never hit (2^127 - 1) derivatives.\r\n        pointer.index = uint128(registeredDerivatives.length.sub(1));\r\n\r\n        // Set up PartiesMap for this derivative.\r\n        PartiesMap storage partiesMap = derivativesToParties[derivativeAddress];\r\n        for (uint i = 0; i < parties.length; i = i.add(1)) {\r\n            partiesMap.parties[parties[i]] = true;\r\n        }\r\n\r\n        address[] memory partiesForEvent = parties;\r\n        emit NewDerivativeRegistered(derivativeAddress, msg.sender, partiesForEvent);\r\n    }\r\n\r\n    function isDerivativeRegistered(address derivative) external view returns (bool isRegistered) {\r\n        return derivativePointers[derivative].valid == PointerValidity.Valid;\r\n    }\r\n\r\n    function getRegisteredDerivatives(address party) external view returns (address[] memory derivatives) {\r\n        // This is not ideal - we must statically allocate memory arrays. To be safe, we make a temporary array as long\r\n        // as registeredDerivatives. We populate it with any derivatives that involve the provided party. Then, we copy\r\n        // the array over to the return array, which is allocated using the correct size. Note: this is done by double\r\n        // copying each value rather than storing some referential info (like indices) in memory to reduce the number\r\n        // of storage reads. This is because storage reads are far more expensive than extra memory space (~100:1).\r\n        address[] memory tmpDerivativeArray = new address[](registeredDerivatives.length);\r\n        uint outputIndex = 0;\r\n        for (uint i = 0; i < registeredDerivatives.length; i = i.add(1)) {\r\n            address derivative = registeredDerivatives[i];\r\n            if (derivativesToParties[derivative].parties[party]) {\r\n                // Copy selected derivative to the temporary array.\r\n                tmpDerivativeArray[outputIndex] = derivative;\r\n                outputIndex = outputIndex.add(1);\r\n            }\r\n        }\r\n\r\n        // Copy the temp array to the return array that is set to the correct size.\r\n        derivatives = new address[](outputIndex);\r\n        for (uint j = 0; j < outputIndex; j = j.add(1)) {\r\n            derivatives[j] = tmpDerivativeArray[j];\r\n        }\r\n    }\r\n\r\n    function getAllRegisteredDerivatives() external view returns (address[] memory derivatives) {\r\n        return registeredDerivatives;\r\n    }\r\n}\r\n\r\nlibrary ResultComputation {\r\n\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n\r\n    struct Data {\r\n        // Maps price to number of tokens that voted for that price.\r\n        mapping(int => FixedPoint.Unsigned) voteFrequency;\r\n        // The total votes that have been added.\r\n        FixedPoint.Unsigned totalVotes;\r\n        // The price that is the current mode, i.e., the price with the highest frequency in `voteFrequency`.\r\n        int currentMode;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the result is resolved, and if so, what value it resolved to. `price` should be ignored if\r\n     * `isResolved` is false.\r\n     * @param minVoteThreshold Minimum number of tokens that must have been voted for the result to be valid. Can be\r\n     * used to enforce a minimum voter participation rate, regardless of how the votes are distributed.\r\n     */\r\n    function getResolvedPrice(Data storage data, FixedPoint.Unsigned memory minVoteThreshold)\r\n        internal\r\n        view\r\n        returns (bool isResolved, int price)\r\n    {\r\n        // TODO(ptare): Figure out where this parameter is supposed to come from.\r\n        FixedPoint.Unsigned memory modeThreshold = FixedPoint.fromUnscaledUint(50).div(100);\r\n\r\n        if (data.totalVotes.isGreaterThan(minVoteThreshold) &&\r\n            data.voteFrequency[data.currentMode].div(data.totalVotes).isGreaterThan(modeThreshold)) {\r\n            // `modeThreshold` and `minVoteThreshold` are met, so the current mode is the resolved price.\r\n            isResolved = true;\r\n            price = data.currentMode;\r\n        } else {\r\n            isResolved = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a new vote to be used when computing the result.\r\n     */\r\n    function addVote(Data storage data, int votePrice, FixedPoint.Unsigned memory numberTokens)\r\n        internal\r\n    {\r\n        data.totalVotes = data.totalVotes.add(numberTokens);\r\n        data.voteFrequency[votePrice] = data.voteFrequency[votePrice].add(numberTokens);\r\n        if (votePrice != data.currentMode\r\n            && data.voteFrequency[votePrice].isGreaterThan(data.voteFrequency[data.currentMode])) {\r\n            data.currentMode = votePrice;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Checks whether a `voteHash` is considered correct. Should only be called after a vote is resolved, i.e.,\r\n     * via `getResolvedPrice`.\r\n     */\r\n    function wasVoteCorrect(Data storage data, bytes32 voteHash) internal view returns (bool) {\r\n        return voteHash == keccak256(abi.encode(data.currentMode));\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total number of tokens whose votes are considered correct. Should only be called after a vote is\r\n     * resolved, i.e., via `getResolvedPrice`.\r\n     */\r\n    function getTotalCorrectlyVotedTokens(Data storage data)\r\n        internal\r\n        view\r\n        returns (FixedPoint.Unsigned memory)\r\n    {\r\n        return data.voteFrequency[data.currentMode];\r\n    }\r\n}\r\n\r\ncontract Testable {\r\n    // Is the contract being run on the test network. Note: this variable should be set on construction and never\r\n    // modified.\r\n    bool public isTest;\r\n\r\n    uint private currentTime;\r\n\r\n    constructor(bool _isTest) internal {\r\n        isTest = _isTest;\r\n        if (_isTest) {\r\n            currentTime = now; // solhint-disable-line not-rely-on-time\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if not running in test mode.\r\n     */\r\n    modifier onlyIfTest {\r\n        require(isTest);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the current time.\r\n     * @dev Will revert if not running in test mode.\r\n     */\r\n    function setCurrentTime(uint _time) external onlyIfTest {\r\n        currentTime = _time;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\r\n     * Otherwise, it will return the block timestamp.\r\n     */\r\n    function getCurrentTime() public view returns (uint) {\r\n        if (isTest) {\r\n            return currentTime;\r\n        } else {\r\n            return now; // solhint-disable-line not-rely-on-time\r\n        }\r\n    }\r\n}\r\n\r\nlibrary VoteTiming {\r\n    using SafeMath for uint;\r\n\r\n    // Note: the phases must be in order. Meaning the first enum value must be the first phase, etc.\r\n    enum Phase {\r\n        Commit,\r\n        Reveal\r\n    }\r\n\r\n    // Note: this MUST match the number of values in the enum above.\r\n    uint private constant NUM_PHASES = 2;\r\n\r\n    struct Data {\r\n        uint roundId;\r\n        uint roundStartTime;\r\n        uint phaseLength;\r\n    }\r\n\r\n    /**\r\n     * @notice Initializes the data object. Sets the phase length based on the input and resets the round id and round\r\n     * start time to 1 and 0 respectively.\r\n     * @dev This method should generally only be run once, but it can also be used to reset the data structure to its\r\n     * initial values.\r\n     */\r\n    function init(Data storage data, uint phaseLength) internal {\r\n        data.phaseLength = phaseLength;\r\n        data.roundId = 1;\r\n        data.roundStartTime = 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the most recently stored round ID set by updateRoundId().\r\n     */\r\n    function getLastUpdatedRoundId(Data storage data) internal view returns (uint) {\r\n        return data.roundId;\r\n    }\r\n\r\n    /**\r\n     * @notice Determines whether time has advanced far enough to advance to the next voting round and update the\r\n     * stored round id.\r\n     */\r\n    function shouldUpdateRoundId(Data storage data, uint currentTime) internal view returns (bool) {\r\n        (uint roundId,) = _getCurrentRoundIdAndStartTime(data, currentTime);\r\n        return data.roundId != roundId;\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the round id. Note: if shouldUpdateRoundId() returns false, this method will have no effect.\r\n     */\r\n    function updateRoundId(Data storage data, uint currentTime) internal {\r\n        (data.roundId, data.roundStartTime) = _getCurrentRoundIdAndStartTime(data, currentTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Computes what the stored round id would be if it were updated right now, but this method does not\r\n     * commit the update.\r\n     */\r\n    function computeCurrentRoundId(Data storage data, uint currentTime) internal view returns (uint roundId) {\r\n        (roundId,) = _getCurrentRoundIdAndStartTime(data, currentTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Computes the current phase based only on the current time.\r\n     */\r\n    function computeCurrentPhase(Data storage data, uint currentTime) internal view returns (Phase) {\r\n        // This employs some hacky casting. We could make this an if-statement if we're worried about type safety.\r\n        return Phase(currentTime.div(data.phaseLength).mod(NUM_PHASES));\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the end time of the current round or any round in the future. Note: this method will revert if\r\n     * the roundId < getLastUpdatedRoundId().\r\n     */\r\n    function computeEstimatedRoundEndTime(Data storage data, uint roundId) internal view returns (uint) {\r\n        // The add(1) is because we want the round end time rather than the start time, so it's really the start of\r\n        // the next round.\r\n        uint roundDiff = roundId.sub(data.roundId).add(1);\r\n        uint roundLength = data.phaseLength.mul(NUM_PHASES);\r\n        return data.roundStartTime.add(roundDiff.mul(roundLength));\r\n    }\r\n\r\n    /**\r\n     * @dev Computes an updated round id and round start time based on the current time.\r\n     */\r\n    function _getCurrentRoundIdAndStartTime(Data storage data, uint currentTime)\r\n        private\r\n        view\r\n        returns (uint roundId, uint startTime)\r\n    {\r\n        uint currentStartTime = data.roundStartTime;\r\n        // Return current data if time has moved backwards.\r\n        if (currentTime <= data.roundStartTime) {\r\n            return (data.roundId, data.roundStartTime);\r\n        }\r\n\r\n        // Get the start of the round that currentTime would be a part of by flooring by roundLength.\r\n        uint roundLength = data.phaseLength.mul(NUM_PHASES);\r\n        startTime = currentTime.div(roundLength).mul(roundLength);\r\n\r\n        // Only increment the round ID if the start time has changed.\r\n        if (startTime > currentStartTime) {\r\n            roundId = data.roundId.add(1);\r\n        } else {\r\n            roundId = data.roundId;\r\n        }\r\n    }\r\n}\r\n\r\ncontract VotingInterface {\r\n    struct PendingRequest {\r\n        bytes32 identifier;\r\n        uint time;\r\n    }\r\n\r\n    /**\r\n     * @notice Commit your vote for a price request for `identifier` at `time`.\r\n     * @dev (`identifier`, `time`) must correspond to a price request that's currently in the commit phase. `hash`\r\n     * should be the keccak256 hash of the price you want to vote for and a `int salt`. Commits can be changed.\r\n     */\r\n    function commitVote(bytes32 identifier, uint time, bytes32 hash) external;\r\n\r\n    /**\r\n     * @notice Reveal a previously committed vote for `identifier` at `time`.\r\n     * @dev The revealed `price` and `salt` must match the latest `hash` that `commitVote()` was called with. Only the\r\n     * committer can reveal their vote.\r\n     */\r\n    function revealVote(bytes32 identifier, uint time, int price, int salt) external;\r\n\r\n    /**\r\n     * @notice Gets the queries that are being voted on this round.\r\n     */\r\n    function getPendingRequests() external view returns (PendingRequest[] memory);\r\n\r\n    /**\r\n     * @notice Gets the current vote phase (commit or reveal) based on the current block time.\r\n     */\r\n    function getVotePhase() external view returns (VoteTiming.Phase);\r\n\r\n    /**\r\n     * @notice Gets the current vote round id based on the current block time.\r\n     */\r\n    function getCurrentRoundId() external view returns (uint);\r\n\r\n    /**\r\n     * @notice Retrieves rewards owed for a set of resolved price requests.\r\n     */\r\n    function retrieveRewards(address voterAddress, uint roundId, PendingRequest[] memory) public returns\r\n    (FixedPoint.Unsigned memory);\r\n}\r\n\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        counter._value += 1;\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        counter._value = counter._value.sub(1);\r\n    }\r\n}\r\n\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = _msgSender();\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Finder is Ownable {\r\n\r\n    mapping(bytes32 => address) public interfacesImplemented;\r\n\r\n    event InterfaceImplementationChanged(bytes32 indexed interfaceName, address indexed newImplementationAddress);\r\n\r\n    /**\r\n     * @dev Updates the address of the contract that implements `interfaceName`.\r\n     */\r\n    function changeImplementationAddress(bytes32 interfaceName, address implementationAddress)\r\n        external\r\n        onlyOwner\r\n    {\r\n        interfacesImplemented[interfaceName] = implementationAddress;\r\n        emit InterfaceImplementationChanged(interfaceName, implementationAddress);\r\n    }\r\n    \r\n    /**\r\n     * @dev Gets the address of the contract that implements the given `interfaceName`.\r\n     */\r\n    function getImplementationAddress(bytes32 interfaceName)\r\n        external\r\n        view\r\n        returns (address implementationAddress)\r\n    {\r\n        implementationAddress = interfacesImplemented[interfaceName];\r\n        require(implementationAddress != address(0x0), \"No implementation for interface found\");\r\n    }\r\n}\r\n\r\ncontract Voting is Testable, Ownable, OracleInterface, VotingInterface, EncryptedSender {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n    using SafeMath for uint;\r\n    using VoteTiming for VoteTiming.Data;\r\n    using ResultComputation for ResultComputation.Data;\r\n\r\n    // Identifies a unique price request for which the Oracle will always return the same value.\r\n    // Tracks ongoing votes as well as the result of the vote.\r\n    struct PriceRequest {\r\n        bytes32 identifier;\r\n        uint time;\r\n\r\n        // A map containing all votes for this price in various rounds.\r\n        mapping(uint => VoteInstance) voteInstances;\r\n\r\n        // If in the past, this was the voting round where this price was resolved. If current or the upcoming round,\r\n        // this is the voting round where this price will be voted on, but not necessarily resolved.\r\n        uint lastVotingRound;\r\n\r\n        // The index in the `pendingPriceRequests` that references this PriceRequest. A value of UINT_MAX means that\r\n        // this PriceRequest is resolved and has been cleaned up from `pendingPriceRequests`.\r\n        uint index;\r\n    }\r\n\r\n    struct VoteInstance {\r\n        // Maps (voterAddress) to their submission.\r\n        mapping(address => VoteSubmission) voteSubmissions;\r\n\r\n        // The data structure containing the computed voting results.\r\n        ResultComputation.Data resultComputation;\r\n    }\r\n\r\n    struct VoteSubmission {\r\n        // A bytes32 of `0` indicates no commit or a commit that was already revealed.\r\n        bytes32 commit;\r\n\r\n        // The hash of the value that was revealed.\r\n        // Note: this is only used for computation of rewards.\r\n        bytes32 revealHash;\r\n    }\r\n\r\n    // Captures the necessary data for making a commitment.\r\n    // Used as a parameter when making batch commitments.\r\n    // Not used as a data structure for storage.\r\n    struct Commitment {\r\n        bytes32 identifier;\r\n\r\n        uint time;\r\n\r\n        bytes32 hash;\r\n\r\n        bytes encryptedVote;\r\n    }\r\n\r\n    // Captures the necessary data for revealing a vote.\r\n    // Used as a parameter when making batch reveals.\r\n    // Not used as a data structure for storage.\r\n    struct Reveal {\r\n        bytes32 identifier;\r\n\r\n        uint time;\r\n\r\n        int price;\r\n\r\n        int salt;\r\n    }\r\n\r\n    struct Round {\r\n        // Voting token snapshot ID for this round. If this is 0, no snapshot has been taken.\r\n        uint snapshotId;\r\n\r\n        // Inflation rate set for this round.\r\n        FixedPoint.Unsigned inflationRate;\r\n    }\r\n\r\n    // Represents the status a price request has.\r\n    enum RequestStatus {\r\n        // Was never requested.\r\n        NotRequested,\r\n        // Is being voted on in the current round.\r\n        Active,\r\n        // Was resolved in a previous round.\r\n        Resolved,\r\n        // Is scheduled to be voted on in a future round.\r\n        Future\r\n    }\r\n\r\n    // Maps round numbers to the rounds.\r\n    mapping(uint => Round) private rounds;\r\n\r\n    // Maps price request IDs to the PriceRequest struct.\r\n    mapping(bytes32 => PriceRequest) private priceRequests;\r\n\r\n    // Price request ids for price requests that haven't yet been marked as resolved. These requests may be for future\r\n    // rounds.\r\n    bytes32[] private pendingPriceRequests;\r\n\r\n    VoteTiming.Data private voteTiming;\r\n\r\n    // The set of identifiers the oracle can provide verified prices for.\r\n    mapping(bytes32 => bool) private supportedIdentifiers;\r\n\r\n    // Percentage of the total token supply that must be used in a vote to create a valid price resolution.\r\n    // 1 == 100%.\r\n    FixedPoint.Unsigned private gatPercentage;\r\n\r\n    // Global setting for the rate of inflation per vote. This is the percentage of the snapshotted total supply that\r\n    // should be split among the correct voters. Note: this value is used to set per-round inflation at the beginning\r\n    // of each round.\r\n    // 1 = 100%\r\n    FixedPoint.Unsigned private inflationRate;\r\n\r\n    // Reference to the voting token.\r\n    VotingToken private votingToken;\r\n\r\n    // Reference to the Finder.\r\n    Finder private finder;\r\n\r\n    // If non-zero, this contract has been migrated to this address. All voters and financial contracts should query the\r\n    // new address only.\r\n    address private migratedAddress;\r\n\r\n    // Max value of an unsigned integer.\r\n    uint constant private UINT_MAX = ~uint(0);\r\n\r\n    event VoteCommitted(address indexed voter, uint indexed roundId, bytes32 indexed identifier, uint time);\r\n\r\n    event VoteRevealed(\r\n        address indexed voter,\r\n        uint indexed roundId,\r\n        bytes32 indexed identifier,\r\n        uint time,\r\n        int price,\r\n        uint numTokens\r\n    );\r\n\r\n    event RewardsRetrieved(address indexed voter, uint indexed roundId, bytes32 indexed identifier, uint time,\r\n        uint numTokens);\r\n\r\n    event PriceRequestAdded(uint indexed votingRoundId, bytes32 indexed identifier, uint time);\r\n\r\n    event PriceResolved(uint indexed resolutionRoundId, bytes32 indexed identifier, uint time, int price);\r\n\r\n    event SupportedIdentifierAdded(bytes32 indexed identifier);\r\n\r\n    event SupportedIdentifierRemoved(bytes32 indexed identifier);\r\n\r\n    /**\r\n     * @notice Construct the Voting contract.\r\n     * @param phaseLength length of the commit and reveal phases in seconds.\r\n     * @param _gatPercentage percentage of the total token supply that must be used in a vote to create a valid price\r\n     * resolution.\r\n     * @param _isTest whether this contract is being constructed for the purpose of running automated tests.\r\n     */\r\n    constructor(\r\n        uint phaseLength,\r\n        FixedPoint.Unsigned memory _gatPercentage,\r\n        FixedPoint.Unsigned memory _inflationRate,\r\n        address _votingToken,\r\n        address _finder,\r\n        bool _isTest\r\n    ) public Testable(_isTest) {\r\n        voteTiming.init(phaseLength);\r\n        // TODO(#779): GAT percentage must be < 100%\r\n        require(_gatPercentage.isLessThan(1));\r\n        gatPercentage = _gatPercentage;\r\n        inflationRate = _inflationRate;\r\n        votingToken = VotingToken(_votingToken);\r\n        finder = Finder(_finder);\r\n    }\r\n\r\n    modifier onlyRegisteredDerivative() {\r\n        if (migratedAddress != address(0)) {\r\n            require(msg.sender == migratedAddress);\r\n        } else {\r\n            Registry registry = Registry(finder.getImplementationAddress(\"Registry\"));\r\n            // TODO(#779): Must be registered derivative\r\n            require(registry.isDerivativeRegistered(msg.sender));\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfNotMigrated() {\r\n        require(migratedAddress == address(0));\r\n        _;\r\n    }\r\n\r\n    function requestPrice(bytes32 identifier, uint time)\r\n        external\r\n        onlyRegisteredDerivative()\r\n        returns (uint expectedTime)\r\n    {\r\n        uint blockTime = getCurrentTime();\r\n        // TODO(#779): Price request must be for a time in the past\r\n        require(time <= blockTime);\r\n        // TODO(#779): Price request for unsupported identifier\r\n        require(supportedIdentifiers[identifier]);\r\n\r\n        // Must ensure the round is updated here so the requested price will be voted on in the next commit cycle.\r\n        _updateRound(blockTime);\r\n\r\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time);\r\n        PriceRequest storage priceRequest = priceRequests[priceRequestId];\r\n        uint currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\r\n\r\n        RequestStatus requestStatus = _getRequestStatus(priceRequest, currentRoundId);\r\n        if (requestStatus == RequestStatus.Active) {\r\n            return voteTiming.computeEstimatedRoundEndTime(currentRoundId);\r\n        } else if (requestStatus == RequestStatus.Resolved) {\r\n            return 0;\r\n        } else if (requestStatus == RequestStatus.Future) {\r\n            return voteTiming.computeEstimatedRoundEndTime(priceRequest.lastVotingRound);\r\n        }\r\n\r\n        // Price has never been requested.\r\n        // Price requests always go in the next round, so add 1 to the computed current round.\r\n        uint nextRoundId = currentRoundId.add(1);\r\n\r\n        priceRequests[priceRequestId] = PriceRequest({\r\n            identifier: identifier,\r\n            time: time,\r\n            lastVotingRound: nextRoundId,\r\n            index: pendingPriceRequests.length\r\n        });\r\n        pendingPriceRequests.push(priceRequestId);\r\n        emit PriceRequestAdded(nextRoundId, identifier, time);\r\n\r\n        // Estimate the end of next round and return the time.\r\n        return voteTiming.computeEstimatedRoundEndTime(nextRoundId);\r\n    }\r\n\r\n    function batchCommit(Commitment[] calldata commits) external {\r\n        for (uint i = 0; i < commits.length; i++) {\r\n            if (commits[i].encryptedVote.length == 0) {\r\n                commitVote(commits[i].identifier, commits[i].time, commits[i].hash);\r\n            } else {\r\n                commitAndPersistEncryptedVote(\r\n                    commits[i].identifier,\r\n                    commits[i].time,\r\n                    commits[i].hash,\r\n                    commits[i].encryptedVote);\r\n            }\r\n        }\r\n    }\r\n\r\n    function batchReveal(Reveal[] calldata reveals) external {\r\n        for (uint i = 0; i < reveals.length; i++) {\r\n            revealVote(reveals[i].identifier, reveals[i].time, reveals[i].price, reveals[i].salt);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Disables this Voting contract in favor of the migrated one.\r\n     */\r\n    function setMigrated(address newVotingAddress) external onlyOwner {\r\n        migratedAddress = newVotingAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Adds the provided identifier as a supported identifier. Price requests using this identifier will be\r\n     * succeed after this call.\r\n     */\r\n    function addSupportedIdentifier(bytes32 identifier) external onlyOwner {\r\n        if (!supportedIdentifiers[identifier]) {\r\n            supportedIdentifiers[identifier] = true;\r\n            emit SupportedIdentifierAdded(identifier);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Removes the identifier from the whitelist. Price requests using this identifier will no longer succeed\r\n     * after this call.\r\n     */\r\n    function removeSupportedIdentifier(bytes32 identifier) external onlyOwner {\r\n        if (supportedIdentifiers[identifier]) {\r\n            supportedIdentifiers[identifier] = false;\r\n            emit SupportedIdentifierRemoved(identifier);\r\n        }\r\n    }\r\n\r\n    function isIdentifierSupported(bytes32 identifier) external view returns (bool) {\r\n        return supportedIdentifiers[identifier];\r\n    }\r\n\r\n    function hasPrice(bytes32 identifier, uint time) external view onlyRegisteredDerivative() returns (bool _hasPrice) {\r\n        (_hasPrice, ,) = _getPriceOrError(identifier, time);\r\n    }\r\n\r\n    function getPrice(bytes32 identifier, uint time) external view onlyRegisteredDerivative() returns (int) {\r\n        (bool _hasPrice, int price, string memory message) = _getPriceOrError(identifier, time);\r\n\r\n        // TODO(#779): If the price wasn't available, revert with the provided message.\r\n        require(_hasPrice, message);\r\n        return price;\r\n    }\r\n\r\n    function getPendingRequests() external view returns (PendingRequest[] memory pendingRequests) {\r\n        uint blockTime = getCurrentTime();\r\n        uint currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\r\n\r\n        // Solidity memory arrays aren't resizable (and reading storage is expensive). Hence this hackery to filter\r\n        // `pendingPriceRequests` only to those requests that `isActive()`.\r\n        PendingRequest[] memory unresolved = new PendingRequest[](pendingPriceRequests.length);\r\n        uint numUnresolved = 0;\r\n\r\n        for (uint i = 0; i < pendingPriceRequests.length; i++) {\r\n            PriceRequest storage priceRequest = priceRequests[pendingPriceRequests[i]];\r\n            if (_getRequestStatus(priceRequest, currentRoundId) == RequestStatus.Active) {\r\n                unresolved[numUnresolved] = PendingRequest(\r\n                    { identifier: priceRequest.identifier, time: priceRequest.time });\r\n                numUnresolved++;\r\n            }\r\n        }\r\n\r\n        pendingRequests = new PendingRequest[](numUnresolved);\r\n        for (uint i = 0; i < numUnresolved; i++) {\r\n            pendingRequests[i] = unresolved[i];\r\n        }\r\n    }\r\n\r\n    function getVotePhase() external view returns (VoteTiming.Phase) {\r\n        return voteTiming.computeCurrentPhase(getCurrentTime());\r\n    }\r\n\r\n    function getCurrentRoundId() external view returns (uint) {\r\n        return voteTiming.computeCurrentRoundId(getCurrentTime());\r\n    }\r\n\r\n    function commitVote(bytes32 identifier, uint time, bytes32 hash) public onlyIfNotMigrated() {\r\n        // TODO(#779): Committed hash of 0 is disallowed, choose a different salt\r\n        require(hash != bytes32(0));\r\n\r\n        // Current time is required for all vote timing queries.\r\n        uint blockTime = getCurrentTime();\r\n        // TODO(#779): Cannot commit while in the reveal phase\r\n        require(voteTiming.computeCurrentPhase(blockTime) == VoteTiming.Phase.Commit);\r\n\r\n        // Should only update the round in the commit phase because a new round that's already in the reveal phase\r\n        // would be wasted.\r\n        _updateRound(blockTime);\r\n\r\n        // At this point, the computed and last updated round ID should be equal.\r\n        uint currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\r\n\r\n        PriceRequest storage priceRequest = _getPriceRequest(identifier, time);\r\n        // TODO(#779): Cannot commit on inactive request\r\n        require(_getRequestStatus(priceRequest, currentRoundId) == RequestStatus.Active);\r\n\r\n        priceRequest.lastVotingRound = currentRoundId;\r\n        VoteInstance storage voteInstance = priceRequest.voteInstances[currentRoundId];\r\n        voteInstance.voteSubmissions[msg.sender].commit = hash;\r\n\r\n        emit VoteCommitted(msg.sender, currentRoundId, identifier, time);\r\n    }\r\n\r\n    function revealVote(bytes32 identifier, uint time, int price, int salt) public onlyIfNotMigrated() {\r\n        uint blockTime = getCurrentTime();\r\n        require(voteTiming.computeCurrentPhase(blockTime) == VoteTiming.Phase.Reveal,\r\n            \"Cannot reveal while in the commit phase\");\r\n\r\n        // Note: computing the current round is required to disallow people from revealing an old commit after the\r\n        // round is over.\r\n        uint roundId = voteTiming.computeCurrentRoundId(blockTime);\r\n\r\n        PriceRequest storage priceRequest = _getPriceRequest(identifier, time);\r\n        VoteInstance storage voteInstance = priceRequest.voteInstances[roundId];\r\n        VoteSubmission storage voteSubmission = voteInstance.voteSubmissions[msg.sender];\r\n\r\n        // 0 hashes are disallowed in the commit phase, so they indicate a different error.\r\n        require(voteSubmission.commit != bytes32(0), \"Cannot reveal an uncommitted or previously revealed hash\");\r\n        require(keccak256(abi.encode(price, salt)) == voteSubmission.commit,\r\n                \"Committed hash doesn't match revealed price and salt\");\r\n        delete voteSubmission.commit;\r\n\r\n        // Get or create a snapshot for this round.\r\n        uint snapshotId = _getOrCreateSnapshotId(roundId);\r\n\r\n        // Get the voter's snapshotted balance. Since balances are returned pre-scaled by 10**18, we can directly\r\n        // initialize the Unsigned value with the returned uint.\r\n        FixedPoint.Unsigned memory balance = FixedPoint.Unsigned(votingToken.balanceOfAt(msg.sender, snapshotId));\r\n\r\n        // Set the voter's submission.\r\n        voteSubmission.revealHash = keccak256(abi.encode(price));\r\n\r\n        // Add vote to the results.\r\n        voteInstance.resultComputation.addVote(price, balance);\r\n\r\n        // Remove the stored message for this price request, if it exists.\r\n        bytes32 topicHash = keccak256(abi.encode(identifier, time, roundId));\r\n        removeMessage(msg.sender, topicHash);\r\n\r\n        emit VoteRevealed(msg.sender, roundId, identifier, time, price, balance.rawValue);\r\n    }\r\n\r\n    function commitAndPersistEncryptedVote(\r\n        bytes32 identifier,\r\n        uint time,\r\n        bytes32 hash,\r\n        bytes memory encryptedVote\r\n    ) public {\r\n        commitVote(identifier, time, hash);\r\n\r\n        uint roundId = voteTiming.computeCurrentRoundId(getCurrentTime());\r\n        bytes32 topicHash = keccak256(abi.encode(identifier, time, roundId));\r\n        sendMessage(msg.sender, topicHash, encryptedVote);\r\n    }\r\n\r\n    /**\r\n     * @notice Resets the inflation rate. Note: this change only applies to rounds that have not yet begun.\r\n     * @dev This method is public because calldata structs are not currently supported by solidity.\r\n     */\r\n    function setInflationRate(FixedPoint.Unsigned memory _inflationRate) public onlyOwner {\r\n        inflationRate = _inflationRate;\r\n    }\r\n\r\n    function retrieveRewards(address voterAddress, uint roundId, PendingRequest[] memory toRetrieve)\r\n        public\r\n        returns (FixedPoint.Unsigned memory totalRewardToIssue)\r\n    {\r\n        if (migratedAddress != address(0)) {\r\n            require(msg.sender == migratedAddress);\r\n        }\r\n        uint blockTime = getCurrentTime();\r\n        _updateRound(blockTime);\r\n        require(roundId < voteTiming.computeCurrentRoundId(blockTime));\r\n\r\n        Round storage round = rounds[roundId];\r\n        FixedPoint.Unsigned memory snapshotBalance = FixedPoint.Unsigned(\r\n            votingToken.balanceOfAt(voterAddress, round.snapshotId));\r\n\r\n        // Compute the total amount of reward that will be issued for each of the votes in the round.\r\n        FixedPoint.Unsigned memory snapshotTotalSupply = FixedPoint.Unsigned(\r\n            votingToken.totalSupplyAt(round.snapshotId));\r\n        FixedPoint.Unsigned memory totalRewardPerVote = round.inflationRate.mul(snapshotTotalSupply);\r\n\r\n        // Keep track of the voter's accumulated token reward.\r\n        totalRewardToIssue = FixedPoint.Unsigned(0);\r\n\r\n        for (uint i = 0; i < toRetrieve.length; i++) {\r\n            PriceRequest storage priceRequest = _getPriceRequest(toRetrieve[i].identifier, toRetrieve[i].time);\r\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\r\n\r\n            require(priceRequest.lastVotingRound == roundId, \"Only retrieve rewards for votes resolved in same round\");\r\n\r\n            _resolvePriceRequest(priceRequest, voteInstance);\r\n\r\n            if (voteInstance.resultComputation.wasVoteCorrect(voteInstance.voteSubmissions[voterAddress].revealHash)) {\r\n                // The price was successfully resolved during the voter's last voting round, the voter revealed and was\r\n                // correct, so they are elgible for a reward.\r\n                FixedPoint.Unsigned memory correctTokens = voteInstance.resultComputation.\r\n                    getTotalCorrectlyVotedTokens();\r\n\r\n                // Compute the reward and add to the cumulative reward.\r\n                FixedPoint.Unsigned memory reward = snapshotBalance.mul(totalRewardPerVote).div(correctTokens);\r\n                totalRewardToIssue = totalRewardToIssue.add(reward);\r\n\r\n                // Emit reward retrieval for this vote.\r\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time,\r\n                    reward.rawValue);\r\n            } else {\r\n                // Emit a 0 token retrieval on incorrect votes.\r\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time, 0);\r\n            }\r\n\r\n            // Delete the submission to capture any refund and clean up storage.\r\n            delete voteInstance.voteSubmissions[voterAddress].revealHash;\r\n        }\r\n\r\n        // Issue any accumulated rewards.\r\n        if (totalRewardToIssue.isGreaterThan(0)) {\r\n            require(votingToken.mint(voterAddress, totalRewardToIssue.rawValue));\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Checks to see if there is a price that has or can be resolved for an (identifier, time) pair.\r\n     * @returns a boolean noting whether a price is resolved, the price, and an error string if necessary.\r\n     */\r\n    function _getPriceOrError(bytes32 identifier, uint time)\r\n        private\r\n        view\r\n        returns (bool _hasPrice, int price, string memory err)\r\n    {\r\n        PriceRequest storage priceRequest = _getPriceRequest(identifier, time);\r\n        uint currentRoundId = voteTiming.computeCurrentRoundId(getCurrentTime());\r\n\r\n        RequestStatus requestStatus = _getRequestStatus(priceRequest, currentRoundId);\r\n        if (requestStatus == RequestStatus.Active) {\r\n            return (false, 0, \"The current voting round has not ended\");\r\n        } else if (requestStatus == RequestStatus.Resolved) {\r\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\r\n            (, int resolvedPrice) = voteInstance.resultComputation.getResolvedPrice(\r\n                _computeGat(priceRequest.lastVotingRound));\r\n            return (true, resolvedPrice, \"\");\r\n        } else if (requestStatus == RequestStatus.Future) {\r\n            return (false, 0, \"Price will be voted on in the future\");\r\n        } else {\r\n            return (false, 0, \"Price was never requested\");\r\n        }\r\n    }\r\n\r\n    function _getPriceRequest(bytes32 identifier, uint time) private view returns (PriceRequest storage) {\r\n        return priceRequests[_encodePriceRequest(identifier, time)];\r\n    }\r\n\r\n    function _encodePriceRequest(bytes32 identifier, uint time) private pure returns (bytes32) {\r\n        return keccak256(abi.encode(identifier, time));\r\n    }\r\n\r\n    function _getOrCreateSnapshotId(uint roundId) private returns (uint) {\r\n        Round storage round = rounds[roundId];\r\n        if (round.snapshotId == 0) {\r\n            // There is no snapshot ID set, so create one.\r\n            round.snapshotId = votingToken.snapshot();\r\n        }\r\n\r\n        return round.snapshotId;\r\n    }\r\n\r\n    function _resolvePriceRequest(PriceRequest storage priceRequest, VoteInstance storage voteInstance) private {\r\n        if (priceRequest.index == UINT_MAX) {\r\n            return;\r\n        }\r\n        (bool isResolved, int resolvedPrice) = voteInstance.resultComputation.getResolvedPrice(\r\n            _computeGat(priceRequest.lastVotingRound));\r\n        require(isResolved, \"Can't resolve an unresolved price request\");\r\n\r\n        // Delete the resolved price request from pendingPriceRequests.\r\n        uint lastIndex = pendingPriceRequests.length - 1;\r\n        PriceRequest storage lastPriceRequest = priceRequests[pendingPriceRequests[lastIndex]];\r\n        lastPriceRequest.index = priceRequest.index;\r\n        pendingPriceRequests[priceRequest.index] = pendingPriceRequests[lastIndex];\r\n        delete pendingPriceRequests[lastIndex];\r\n\r\n        priceRequest.index = UINT_MAX;\r\n        emit PriceResolved(priceRequest.lastVotingRound, priceRequest.identifier, priceRequest.time, resolvedPrice);\r\n    }\r\n\r\n    function _updateRound(uint blockTime) private {\r\n        if (!voteTiming.shouldUpdateRoundId(blockTime)) {\r\n            return;\r\n        }\r\n        uint nextVotingRoundId = voteTiming.computeCurrentRoundId(blockTime);\r\n\r\n        // Set the round inflation rate to the current global inflation rate.\r\n        rounds[nextVotingRoundId].inflationRate = inflationRate;\r\n\r\n        // Update the stored round to the current one.\r\n        voteTiming.updateRoundId(blockTime);\r\n    }\r\n\r\n    function _computeGat(uint roundId) private view returns (FixedPoint.Unsigned memory) {\r\n        uint snapshotId = rounds[roundId].snapshotId;\r\n        if (snapshotId == 0) {\r\n            // No snapshot - return max value to err on the side of caution.\r\n            return FixedPoint.Unsigned(UINT_MAX);\r\n        }\r\n\r\n        // Grab the snaphotted supply from the voting token. It's already scaled by 10**18, so we can directly\r\n        // initialize the Unsigned value with the returned uint.\r\n        FixedPoint.Unsigned memory snapshottedSupply = FixedPoint.Unsigned(votingToken.totalSupplyAt(snapshotId));\r\n\r\n        // Multiply the total supply at the snapshot by the gatPercentage to get the GAT in number of tokens.\r\n        return snapshottedSupply.mul(gatPercentage);\r\n    }\r\n\r\n    function _getRequestStatus(PriceRequest storage priceRequest, uint currentRoundId)\r\n        private\r\n        view\r\n        returns (RequestStatus)\r\n    {\r\n        if (priceRequest.lastVotingRound == 0) {\r\n            return RequestStatus.NotRequested;\r\n        } else if (priceRequest.lastVotingRound < currentRoundId) {\r\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\r\n            (bool isResolved, ) = voteInstance.resultComputation.getResolvedPrice(\r\n                _computeGat(priceRequest.lastVotingRound));\r\n            return isResolved ? RequestStatus.Resolved : RequestStatus.Active;\r\n        } else if (priceRequest.lastVotingRound == currentRoundId) {\r\n            return RequestStatus.Active;\r\n        } else {\r\n            // Means than priceRequest.lastVotingRound > currentRoundId\r\n            return RequestStatus.Future;\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ExpandedIERC20 is IERC20 {\r\n    /**\r\n     * @notice Burns a specific amount of the caller's tokens.\r\n     * @dev Only burns the caller's tokens, so it is safe to leave this method permissionless.\r\n     */\r\n    function burn(uint value) external;\r\n\r\n    /**\r\n     * @notice Mints tokens and adds them to the balance of the `to` address.\r\n     * @dev This method should be permissioned to only allow designated parties to mint tokens.\r\n     */\r\n    function mint(address to, uint value) external returns (bool);\r\n}\r\n\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n}\r\n\r\ncontract ERC20Snapshot is ERC20 {\r\n    using SafeMath for uint256;\r\n    using Arrays for uint256[];\r\n    using Counters for Counters.Counter;\r\n\r\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\r\n    // Snapshot struct, but that would impede usage of functions that work on an array.\r\n    struct Snapshots {\r\n        uint256[] ids;\r\n        uint256[] values;\r\n    }\r\n\r\n    mapping (address => Snapshots) private _accountBalanceSnapshots;\r\n    Snapshots private _totalSupplySnapshots;\r\n\r\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\r\n    Counters.Counter private _currentSnapshotId;\r\n\r\n    event Snapshot(uint256 id);\r\n\r\n    // Creates a new snapshot id. Balances are only stored in snapshots on demand: unless a snapshot was taken, a\r\n    // balance change will not be recorded. This means the extra added cost of storing snapshotted balances is only paid\r\n    // when required, but is also flexible enough that it allows for e.g. daily snapshots.\r\n    function snapshot() public returns (uint256) {\r\n        _currentSnapshotId.increment();\r\n\r\n        uint256 currentId = _currentSnapshotId.current();\r\n        emit Snapshot(currentId);\r\n        return currentId;\r\n    }\r\n\r\n    function balanceOfAt(address account, uint256 snapshotId) public view returns (uint256) {\r\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\r\n\r\n        return snapshotted ? value : balanceOf(account);\r\n    }\r\n\r\n    function totalSupplyAt(uint256 snapshotId) public view returns(uint256) {\r\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\r\n\r\n        return snapshotted ? value : totalSupply();\r\n    }\r\n\r\n    // _transfer, _mint and _burn are the only functions where the balances are modified, so it is there that the\r\n    // snapshots are updated. Note that the update happens _before_ the balance change, with the pre-modified value.\r\n    // The same is true for the total supply and _mint and _burn.\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        _updateAccountSnapshot(from);\r\n        _updateAccountSnapshot(to);\r\n\r\n        super._transfer(from, to, value);\r\n    }\r\n\r\n    function _mint(address account, uint256 value) internal {\r\n        _updateAccountSnapshot(account);\r\n        _updateTotalSupplySnapshot();\r\n\r\n        super._mint(account, value);\r\n    }\r\n\r\n    function _burn(address account, uint256 value) internal {\r\n        _updateAccountSnapshot(account);\r\n        _updateTotalSupplySnapshot();\r\n\r\n        super._burn(account, value);\r\n    }\r\n\r\n    // When a valid snapshot is queried, there are three possibilities:\r\n    //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\r\n    //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\r\n    //  to this id is the current one.\r\n    //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\r\n    //  requested id, and its value is the one to return.\r\n    //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\r\n    //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\r\n    //  larger than the requested one.\r\n    //\r\n    // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\r\n    // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\r\n    // exactly this.\r\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots)\r\n        private view returns (bool, uint256)\r\n    {\r\n        require(snapshotId > 0, \"ERC20Snapshot: id is 0\");\r\n        // solhint-disable-next-line max-line-length\r\n        require(snapshotId <= _currentSnapshotId.current(), \"ERC20Snapshot: nonexistent id\");\r\n\r\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\r\n\r\n        if (index == snapshots.ids.length) {\r\n            return (false, 0);\r\n        } else {\r\n            return (true, snapshots.values[index]);\r\n        }\r\n    }\r\n\r\n    function _updateAccountSnapshot(address account) private {\r\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\r\n    }\r\n\r\n    function _updateTotalSupplySnapshot() private {\r\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\r\n    }\r\n\r\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\r\n        uint256 currentId = _currentSnapshotId.current();\r\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\r\n            snapshots.ids.push(currentId);\r\n            snapshots.values.push(currentValue);\r\n        }\r\n    }\r\n\r\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\r\n        if (ids.length == 0) {\r\n            return 0;\r\n        } else {\r\n            return ids[ids.length - 1];\r\n        }\r\n    }\r\n}\r\n\r\ncontract VotingToken is ExpandedIERC20, ERC20Snapshot, MultiRole {\r\n\r\n    enum Roles {\r\n        // Can set the minter and burner.\r\n        Owner,\r\n        // Addresses that can mint new tokens.\r\n        Minter,\r\n        // Addresses that can burn tokens that address owns.\r\n        Burner\r\n    }\r\n\r\n    // Standard ERC20 metadata.\r\n    string public constant name = \"UMA Voting Token v1\"; // solhint-disable-line const-name-snakecase\r\n    string public constant symbol = \"UMA\"; // solhint-disable-line const-name-snakecase\r\n    uint8 public constant decimals = 18; // solhint-disable-line const-name-snakecase\r\n\r\n    constructor() public {\r\n        _createExclusiveRole(uint(Roles.Owner), uint(Roles.Owner), msg.sender);\r\n        _createSharedRole(uint(Roles.Minter), uint(Roles.Owner), new address[](0));\r\n        _createSharedRole(uint(Roles.Burner), uint(Roles.Owner), new address[](0));\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `value` tokens to `recipient`, returning true on success.\r\n     */\r\n    function mint(address recipient, uint value) external onlyRoleHolder(uint(Roles.Minter)) returns (bool) {\r\n        _mint(recipient, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Burns `value` tokens owned by `msg.sender`.\r\n     */\r\n    function burn(uint value) external onlyRoleHolder(uint(Roles.Burner)) {\r\n        _burn(msg.sender, value);\r\n    }\r\n}\r\n\r\nlibrary Arrays {\r\n   /**\r\n     * @dev Searches a sorted `array` and returns the first index that contains\r\n     * a value greater or equal to `element`. If no such index exists (i.e. all\r\n     * values in the array are strictly less than `element`), the array length is\r\n     * returned. Time complexity O(log n).\r\n     *\r\n     * `array` is expected to be sorted in ascending order, and to contain no\r\n     * repeated elements.\r\n     */\r\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\r\n        if (array.length == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 low = 0;\r\n        uint256 high = array.length;\r\n\r\n        while (low < high) {\r\n            uint256 mid = Math.average(low, high);\r\n\r\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\r\n            // because Math.average rounds down (it does integer division with truncation).\r\n            if (array[mid] > element) {\r\n                high = mid;\r\n            } else {\r\n                low = mid + 1;\r\n            }\r\n        }\r\n\r\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\r\n        if (low > 0 && array[low - 1] == element) {\r\n            return low - 1;\r\n        } else {\r\n            return low;\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"phaseLength\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"_gatPercentage\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"_inflationRate\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_votingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_finder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isTest\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"votingRoundId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"PriceRequestAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"resolutionRoundId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"price\",\"type\":\"int256\"}],\"name\":\"PriceResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"RewardsRetrieved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"}],\"name\":\"SupportedIdentifierAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"}],\"name\":\"SupportedIdentifierRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"VoteCommitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"price\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"VoteRevealed\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"addAuthorizedSender\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"}],\"name\":\"addSupportedIdentifier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"encryptedVote\",\"type\":\"bytes\"}],\"internalType\":\"struct Voting.Commitment[]\",\"name\":\"commits\",\"type\":\"tuple[]\"}],\"name\":\"batchCommit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"price\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"salt\",\"type\":\"int256\"}],\"internalType\":\"struct Voting.Reveal[]\",\"name\":\"reveals\",\"type\":\"tuple[]\"}],\"name\":\"batchReveal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"encryptedVote\",\"type\":\"bytes\"}],\"name\":\"commitAndPersistEncryptedVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"commitVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"topicHash\",\"type\":\"bytes32\"}],\"name\":\"getMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPendingRequests\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct VotingInterface.PendingRequest[]\",\"name\":\"pendingRequests\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"topicHash\",\"type\":\"bytes32\"}],\"name\":\"getPublicKey\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVotePhase\",\"outputs\":[{\"internalType\":\"enum VoteTiming.Phase\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"hasPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_hasPrice\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"isAuthorizedSender\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"}],\"name\":\"isIdentifierSupported\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isTest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"removeAuthorizedSender\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"topicHash\",\"type\":\"bytes32\"}],\"name\":\"removeMessage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"}],\"name\":\"removeSupportedIdentifier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"requestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"expectedTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"voterAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct VotingInterface.PendingRequest[]\",\"name\":\"toRetrieve\",\"type\":\"tuple[]\"}],\"name\":\"retrieveRewards\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"totalRewardToIssue\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"price\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"salt\",\"type\":\"int256\"}],\"name\":\"revealVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"topicHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"sendMessage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"setCurrentTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"_inflationRate\",\"type\":\"tuple\"}],\"name\":\"setInflationRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newVotingAddress\",\"type\":\"address\"}],\"name\":\"setMigrated\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"publicKey\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"topicHash\",\"type\":\"bytes32\"}],\"name\":\"setPublicKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Voting","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000001518000000000000000000000000000000000000000000000000000b1a2bc2ec5000000000000000000000000000000000000000000000000000000b1a2bc2ec5000000000000000000000000000004fa0d235c4abf4bcf4787af4cf447de572ef82800000000000000000000000040f941e48a552bf496b154af6bf55725f18d77c30000000000000000000000000000000000000000000000000000000000000000","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://ec1cd6c2365ccf2c2200cf5a30c456542686f0a4bef87faaab97b01aba94f5a5"}]}