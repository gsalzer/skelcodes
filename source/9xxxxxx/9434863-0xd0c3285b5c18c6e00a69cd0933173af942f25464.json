{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >0.4.99 <0.6.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0);\r\n        // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address payable private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor(address payable newOwner) public {\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address payable) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address payable newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address payable newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract IReferStorage {\r\n    function checkReferralLink(address _contract, address _referral, uint256 _amount, bytes memory _referrer) public;\r\n    function getReferrerPercent(address _contractAddress) public view returns(uint);\r\n    function depositFunds(address _contract) payable public;\r\n}\r\n\r\ncontract IFundsStorage {\r\n    function getPercentFund(address _contractAddress, uint _typeFund) public view returns(uint);\r\n    function depositFunds(uint _typeFund, address _contract, address payable _player) payable public;\r\n}\r\n\r\ncontract ITicketsStorage {\r\n    function findHappyNumber(uint step) public returns (uint);\r\n    function numberTicketFromHash(address _contract, bytes32 _hash) public view returns (uint);\r\n    function save(address _contract, uint _round, address payable _wallet, uint _investment, uint _stake) public;\r\n    function saveHash(address _contract, bytes32 _hash, uint _round) public;\r\n    function setWhitelist(address _contract, bool _status) public;\r\n    function update(address _contract, uint _round, uint _stakeAmount, uint _happyNumber) public;\r\n\r\n    function ticketInfo(address _contract, uint round) public view returns (\r\n        address payable _wallet,\r\n        uint _investment,\r\n        uint _stakeAmount,\r\n        uint _stake,\r\n        uint _happyNumber\r\n    );\r\n}\r\n\r\ncontract SundayLottery is Ownable {\r\n    using SafeMath for uint;\r\n\r\n    uint public constant MIN_BALANCE = 0.1 ether;\r\n    uint public minPriceOfToken = 0.01 ether;\r\n    uint private botComission = 0.002 ether;\r\n\r\n    ITicketsStorage private m_tickets;\r\n    IReferStorage private referStorage;\r\n    IFundsStorage private fundsStorage;\r\n\r\n    uint public contractOwnerPercent;\r\n    uint public systemOwnerPercent;\r\n    uint private lastBlock;\r\n\r\n    address payable public contractOwnerWallet;\r\n    address payable public systemOwnerWallet = 0xb43c6dCe7837eb67c058eD7BFA06A850B2a15B06;\r\n    address public parentContract;\r\n    address payable public botCroupier;\r\n\r\n    address public myAccountToJpFund;\r\n    address public myAccountToReferFund;\r\n    address private controllerContract;\r\n\r\n    uint private _currentNumberTicket;\r\n\r\n    event LogBalanceChanged(uint when, uint balance);\r\n    event LogWinnerDefine(uint round, address indexed wallet, uint amount, uint stake, uint happyNumber);\r\n    event ChangeAddressWallet(address indexed owner, address indexed newAddress, address indexed oldAddress);\r\n    event Payment(uint amount, address indexed wallet);\r\n    event FailedPayment(uint amount, address indexed wallet);\r\n    event WithdrawOwnerContract(uint amount, address beneficiary);\r\n    event ChangeValue(address indexed sender, uint newMinPrice, uint oldMinPrice);\r\n\r\n    modifier balanceChanged {\r\n        _;\r\n        emit LogBalanceChanged(now, address(this).balance);\r\n    }\r\n\r\n    modifier onlyParentContract {\r\n        require(msg.sender == parentContract, \"onlyParentContract methods called by non - parent of contract.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyControllerContract {\r\n        require(msg.sender == controllerContract, \"only controller contract methods called by non - parent of contract.\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address payable _owner,\r\n        address payable _contractOwnerWallet,\r\n        uint _systemOwnerPercent,\r\n        uint _contractOwnerPercent,\r\n        address _addressReferStorage,\r\n        address _addressFundStorage,\r\n        address _addressTicketsStorage,\r\n        address _myAccountToJpFund,\r\n        address _myAccountToReferFund,\r\n        address payable _botCroupier\r\n    ) public\r\n    Ownable(_owner)\r\n    {\r\n        require(_contractOwnerWallet != address(0) && _addressFundStorage != address(0)\r\n        && _addressReferStorage != address(0) && _botCroupier != address(0));\r\n        contractOwnerWallet = _contractOwnerWallet;\r\n        systemOwnerPercent = _systemOwnerPercent < 10 ? 10 : _systemOwnerPercent;\r\n        contractOwnerPercent = _contractOwnerPercent;\r\n        parentContract = msg.sender;\r\n\r\n        referStorage = IReferStorage(_addressReferStorage);\r\n        fundsStorage = IFundsStorage(_addressFundStorage);\r\n        m_tickets = ITicketsStorage(_addressTicketsStorage);\r\n\r\n        if (_myAccountToJpFund != address(0)) {\r\n            myAccountToJpFund = _myAccountToJpFund;\r\n        } else {\r\n            myAccountToJpFund = address(this);\r\n        }\r\n        if (_myAccountToReferFund != address(0)) {\r\n            myAccountToReferFund = _myAccountToReferFund;\r\n        } else {\r\n            myAccountToReferFund = address(this);\r\n        }\r\n\r\n        _currentNumberTicket = 1;\r\n        botCroupier = _botCroupier;\r\n    }\r\n\r\n    function() external payable {\r\n    }\r\n\r\n    function currentRound() public view returns (uint) {\r\n        return _currentNumberTicket;\r\n    }\r\n\r\n    function getFundsAccounts() public view returns (address jpFundAddress, address referFundAddress) {\r\n        jpFundAddress = myAccountToJpFund;\r\n        referFundAddress = myAccountToReferFund;\r\n    }\r\n\r\n    function buyTicket(\r\n        address _contract,\r\n        address payable _wallet,\r\n        uint _stake,\r\n        bytes memory _referrerLink,\r\n        bytes32 _hash\r\n    ) public payable balanceChanged {\r\n        uint currentBlock = block.number;\r\n        uint investment = msg.value;\r\n        require(_stake == 1 || _stake == 2);\r\n        require(lastBlock < currentBlock);\r\n        require(minPriceOfToken <= investment);\r\n        require(balanceAll() >= MIN_BALANCE);\r\n\r\n        referStorage.checkReferralLink(myAccountToReferFund, _wallet, investment, _referrerLink);\r\n        m_tickets.save(_contract, _currentNumberTicket, _wallet, investment, _stake);\r\n        m_tickets.saveHash(_contract, _hash, _currentNumberTicket);\r\n        lastBlock = currentBlock;\r\n        _currentNumberTicket++;\r\n    }\r\n\r\n    function makeTwist(address _contract, uint _numberReveal, address _playerWallet) public onlyControllerContract {\r\n        uint numberTicket = _getNumberTicket(_contract, _numberReveal, _playerWallet);\r\n        (address payable _wallet, uint _investment, bool _notMaked, bool _status, uint _stakeAmount\r\n        ) = _defineWinner(_contract, numberTicket, _playerWallet);\r\n        if (_notMaked) {\r\n            _sendPrize(_wallet, _investment, _status, _stakeAmount);\r\n        }\r\n        botCroupier.transfer(botComission);\r\n    }\r\n\r\n    function _defineWinner(address _contract, uint numberTicket, address _playerWallet) internal returns (\r\n        address payable _wallet, uint _investment, bool _notMaked, bool _status, uint _stakeAmount\r\n    ) {\r\n        (address payable wallet, uint investment, uint stakeAmount, uint stake, uint happyNumber) = getTicketInfo(_contract, numberTicket);\r\n        if (happyNumber == 0) {\r\n            _notMaked = true;\r\n            _wallet = wallet;\r\n            require(_wallet == _playerWallet);\r\n            _investment = investment;\r\n            happyNumber = m_tickets.findHappyNumber(2);\r\n            if (happyNumber == stake) {\r\n                _status = true;\r\n                _stakeAmount = calcStake(_investment);\r\n            } else {\r\n                _status = false;\r\n                _stakeAmount = stakeAmount;\r\n            }\r\n            emit LogWinnerDefine(numberTicket, wallet, _stakeAmount, stake, happyNumber);\r\n            m_tickets.update(_contract, numberTicket, _stakeAmount, happyNumber);\r\n        } else {\r\n            _notMaked = false;\r\n        }\r\n    }\r\n    function _getNumberTicket(address _contract, uint _number, address _playerWallet) internal view returns (uint numberTicket) {\r\n        bytes32 hash = keccak256(abi.encodePacked(bytes32(_number), _playerWallet));\r\n        numberTicket = m_tickets.numberTicketFromHash(_contract, hash);\r\n    }\r\n\r\n\r\n    function _sendPrize(\r\n        address payable _wallet, uint _investment, bool _status, uint _stakeAmount\r\n    ) internal {\r\n        uint fullPercent = 1000;\r\n        if (_status) {\r\n            _sendToWallet(_stakeAmount, _wallet);\r\n        }\r\n\r\n        uint referPercent = referStorage.getReferrerPercent(myAccountToReferFund);\r\n        referStorage.depositFunds.value(_investment.mul(referPercent).div(fullPercent))(myAccountToReferFund);\r\n\r\n        fundsStorage.depositFunds.value(_investment.mul(fundsStorage.getPercentFund(myAccountToJpFund, 0)).div(fullPercent))(0, myAccountToJpFund, _wallet);\r\n        fundsStorage.depositFunds.value(_investment.mul(fundsStorage.getPercentFund(myAccountToJpFund, 1)).div(fullPercent))(1, myAccountToJpFund, _wallet);\r\n        fundsStorage.depositFunds.value(_investment.mul(fundsStorage.getPercentFund(myAccountToJpFund, 2)).div(fullPercent))(2, myAccountToJpFund, _wallet);\r\n        fundsStorage.depositFunds.value(_investment.mul(fundsStorage.getPercentFund(myAccountToJpFund, 3)).div(fullPercent))(3, myAccountToJpFund, _wallet);\r\n\r\n        if (contractOwnerPercent > referPercent) {\r\n            _sendToWallet(_investment.mul(contractOwnerPercent.sub(referPercent)).div(fullPercent), contractOwnerWallet);\r\n        }\r\n        _sendToWallet(_investment.mul(systemOwnerPercent).div(fullPercent), systemOwnerWallet);\r\n    }\r\n\r\n    function _sendToWallet(uint _amount, address payable _wallet) internal {\r\n        if (0 < _amount && _amount <= balanceAll()) {\r\n            if (_wallet.send(_amount)) {\r\n                emit Payment(_amount, _wallet);\r\n            } else {\r\n                emit FailedPayment(_amount, _wallet);\r\n            }\r\n        }\r\n    }\r\n\r\n    function payToMyGameContract(address payable _wallet) external onlyControllerContract {\r\n        require(balanceAll() >= MIN_BALANCE*2);\r\n        uint _amount = MIN_BALANCE + 4*minPriceOfToken;\r\n        _sendToWallet(_amount, _wallet);\r\n    }\r\n\r\n    function withdrawFunds(uint _amount, address payable _beneficiary) public onlyControllerContract {\r\n        emit WithdrawOwnerContract(_amount, _beneficiary);\r\n        _sendToWallet(_amount, _beneficiary);\r\n    }\r\n\r\n    function getTicketInfo(address _contract, uint round) public view returns (\r\n        address payable _wallet, uint _investment, uint _stakeAmount, uint _stake, uint _happyNumber\r\n    ) {\r\n        (_wallet, _investment, _stakeAmount, _stake, _happyNumber) = m_tickets.ticketInfo(_contract, round);\r\n    }\r\n\r\n    function calcMaxStake() public view returns (uint _availableFunds) {\r\n        if (balanceAll() >= MIN_BALANCE) {\r\n            uint percentFull = 1000;\r\n            uint percentAll = getPercentComission();\r\n            _availableFunds = balanceAll().div(2);\r\n            _availableFunds = _availableFunds.mul(percentFull.sub(percentAll)).div(percentFull);\r\n            _availableFunds = _availableFunds.sub(botComission);\r\n        } else {\r\n            _availableFunds = 0;\r\n        }\r\n    }\r\n\r\n    function calcStake(uint _amount) public view returns (uint _availableFunds) {\r\n        if (calcMaxStake() >= _amount && _amount > botComission && minPriceOfToken <= _amount && balanceAll() >= MIN_BALANCE) {\r\n            uint percentFull = 1000;\r\n            uint percentAll = getPercentComission();\r\n            _availableFunds = _amount.mul(percentFull.sub(percentAll)).div(percentFull);\r\n            _availableFunds = _availableFunds.add(_amount).sub(botComission);\r\n        } else {\r\n            _availableFunds = 0;\r\n        }\r\n    }\r\n\r\n    function getPercentComission() public view returns (uint _percentAll) {\r\n        uint percentFund = fundsStorage.getPercentFund(myAccountToJpFund, 0).add(fundsStorage.getPercentFund(myAccountToJpFund, 1));\r\n        percentFund = percentFund.add(fundsStorage.getPercentFund(myAccountToJpFund, 2)).add(fundsStorage.getPercentFund(myAccountToJpFund, 3));\r\n        _percentAll = percentFund.add(contractOwnerPercent).add(systemOwnerPercent);\r\n    }\r\n\r\n    function balanceAll() public view returns (uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function setContractOwnerWallet(address payable _newWallet) external onlyOwner {\r\n        require(_newWallet != address(0));\r\n        address payable _oldWallet = contractOwnerWallet;\r\n        contractOwnerWallet = _newWallet;\r\n        emit ChangeAddressWallet(msg.sender, _newWallet, _oldWallet);\r\n    }\r\n\r\n    function setControllerContract(address _newWallet) external onlyParentContract {\r\n        require(_newWallet != address(0));\r\n        address _oldWallet = controllerContract;\r\n        controllerContract = _newWallet;\r\n        emit ChangeAddressWallet(msg.sender, _newWallet, _oldWallet);\r\n    }\r\n\r\n    function setMinPriceOfToken(uint _newMinPrice) external onlyOwner {\r\n        require(_newMinPrice > 0);\r\n        uint _oldMinPrice = minPriceOfToken;\r\n        minPriceOfToken = _newMinPrice;\r\n        emit ChangeValue(msg.sender, _newMinPrice, _oldMinPrice);\r\n    }\r\n\r\n    function setBotComission(uint _newValue) external onlyControllerContract {\r\n        require(_newValue > 0);\r\n        uint _oldValue = botComission;\r\n        botComission = _newValue;\r\n        emit ChangeValue(msg.sender, _newValue, _oldValue);\r\n    }\r\n\r\n    function setsystemOwnerPercent(uint _newValue) external onlyControllerContract {\r\n        require(_newValue > 0);\r\n        systemOwnerPercent = _newValue;\r\n    }\r\n\r\n    function updateAddress(address payable _newWallet, uint _number) external onlyControllerContract {\r\n        require(_newWallet != address(0));\r\n        address _oldWallet = address(0);\r\n        if (_number == 1) {\r\n            _oldWallet = address(referStorage);\r\n            referStorage = IReferStorage(_newWallet);\r\n        }\r\n        if (_number == 2) {\r\n            _oldWallet = address(fundsStorage);\r\n            fundsStorage = IFundsStorage(_newWallet);\r\n        }\r\n        if (_number == 3) {\r\n            _oldWallet = address(m_tickets);\r\n            m_tickets = ITicketsStorage(_newWallet);\r\n        }\r\n        if (_number == 4) {\r\n            _oldWallet = botCroupier;\r\n            botCroupier = _newWallet;\r\n        }\r\n        if (_number == 5) {\r\n            _oldWallet = controllerContract;\r\n            controllerContract = _newWallet;\r\n        }\r\n        if (_number == 6) {\r\n            _oldWallet = systemOwnerWallet;\r\n            systemOwnerWallet = _newWallet;\r\n        }\r\n        emit ChangeAddressWallet(msg.sender, _newWallet, _oldWallet);\r\n    }\r\n\r\n}\r\n\r\ncontract HeadsOrTails {\r\n    using SafeMath for uint;\r\n\r\n    address payable public ownerContract;\r\n    mapping(address => bool) private parentContract;\r\n\r\n    address private addressReferStorage;\r\n    address private addressFundStorage;\r\n    address private addressTicketsStorage;\r\n    address payable private botCroupier;\r\n\r\n    uint public countContract;\r\n\r\n    event MakeNewGameContract(address indexed owner, address indexed addressContract);\r\n    event ChangeAddressWallet(address indexed owner, address indexed newAddress, address indexed oldAddress);\r\n    event WithdrawFund(uint amount, address indexed sender);\r\n\r\n    modifier onlyOwnerContract() {\r\n        require(msg.sender == ownerContract, \"caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyParentContract {\r\n        require(parentContract[msg.sender] || ownerContract == msg.sender, \"onlyParentContract methods called by non - parent of contract.\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address payable _ownerContract,\r\n        address payable _botCroupier\r\n    ) public {\r\n        ownerContract = _ownerContract;\r\n        //ownerContract = msg.sender; //For test's\r\n        botCroupier = _botCroupier;\r\n    }\r\n\r\n    function setParentContract(address _contract, bool _status) onlyOwnerContract public {\r\n        parentContract[_contract] = _status;\r\n    }\r\n\r\n    function makeNewGame(\r\n        address payable _ownerWallet,\r\n        address payable _contractOwnerWallet,\r\n        uint _systemOwnerPercent,\r\n        uint _contractOwnerPercent,\r\n        address _myAccountToJpFund, address _myAccountToReferFund\r\n    ) onlyParentContract public returns(address payable) {\r\n        require(_contractOwnerWallet != address(0));\r\n        SundayLottery sundayLottery = new SundayLottery(\r\n            _ownerWallet, _contractOwnerWallet, _systemOwnerPercent, _contractOwnerPercent,\r\n            addressReferStorage, addressFundStorage, addressTicketsStorage,\r\n            _myAccountToJpFund, _myAccountToReferFund, botCroupier);\r\n        emit MakeNewGameContract(msg.sender, address(sundayLottery));\r\n        countContract++;\r\n        ITicketsStorage ticketStorage = ITicketsStorage(addressTicketsStorage);\r\n        ticketStorage.setWhitelist(address(sundayLottery), true);\r\n        sundayLottery.setControllerContract(msg.sender);\r\n        return address(sundayLottery);\r\n    }\r\n\r\n    function withdrawFunds(uint _amount) external onlyOwnerContract {\r\n        require(_amount <= address(this).balance, \"Increase amount larger than balance.\");\r\n        emit WithdrawFund(_amount, msg.sender);\r\n        ownerContract.transfer(_amount);\r\n    }\r\n\r\n    function setStorageAddress(address _addressFundStorage, address _addressReferStorage, address _addressTicketsStorage) external onlyOwnerContract {\r\n        require(_addressReferStorage != address(0) && _addressFundStorage != address(0) && _addressTicketsStorage != address(0));\r\n        addressFundStorage = _addressFundStorage;\r\n        addressReferStorage = _addressReferStorage;\r\n        addressTicketsStorage = _addressTicketsStorage;\r\n    }\r\n\r\n    function setCroupierWallet(address payable _newWallet) external onlyOwnerContract {\r\n        require(_newWallet != address(0));\r\n        address _oldWallet = botCroupier;\r\n        botCroupier = _newWallet;\r\n        emit ChangeAddressWallet(msg.sender, _newWallet, _oldWallet);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_ownerContract\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_botCroupier\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"ChangeAddressWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addressContract\",\"type\":\"address\"}],\"name\":\"MakeNewGameContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"WithdrawFund\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"countContract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_ownerWallet\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_contractOwnerWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_systemOwnerPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_contractOwnerPercent\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_myAccountToJpFund\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_myAccountToReferFund\",\"type\":\"address\"}],\"name\":\"makeNewGame\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerContract\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"setCroupierWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setParentContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressFundStorage\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_addressReferStorage\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_addressTicketsStorage\",\"type\":\"address\"}],\"name\":\"setStorageAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"HeadsOrTails","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000002da10e7b8c666d488478fdbe0c95c16a7a7394620000000000000000000000005d6caea68ccc6aeff1963ab40d45211c69ef9295","Library":"","LicenseType":"None","SwarmSource":"bzzr://35919d33dc71765cf3803bbc4555283d693594b0770b9b4b1a6e48bbcc385549"}]}