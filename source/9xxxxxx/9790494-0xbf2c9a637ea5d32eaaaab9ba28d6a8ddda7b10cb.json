{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.21 <0.6.0;\r\n\r\ncontract MultiSigInterface{\r\n  function update_and_check_reach_majority(uint64 id, string memory name, bytes32 hash, address sender) public returns (bool);\r\n  function is_signer(address addr) public view returns(bool);\r\n}\r\n\r\ncontract MultiSigTools{\r\n  MultiSigInterface public multisig_contract;\r\n  constructor(address _contract) public{\r\n    require(_contract!= address(0x0));\r\n    multisig_contract = MultiSigInterface(_contract);\r\n  }\r\n\r\n  modifier only_signer{\r\n    require(multisig_contract.is_signer(msg.sender), \"only a signer can call in MultiSigTools\");\r\n    _;\r\n  }\r\n\r\n  modifier is_majority_sig(uint64 id, string memory name) {\r\n    bytes32 hash = keccak256(abi.encodePacked(msg.sig, msg.data));\r\n    if(multisig_contract.update_and_check_reach_majority(id, name, hash, msg.sender)){\r\n      _;\r\n    }\r\n  }\r\n\r\n  event TransferMultiSig(address _old, address _new);\r\n\r\n  function transfer_multisig(uint64 id, address _contract) public only_signer\r\n  is_majority_sig(id, \"transfer_multisig\"){\r\n    require(_contract != address(0x0));\r\n    address old = address(multisig_contract);\r\n    multisig_contract = MultiSigInterface(_contract);\r\n    emit TransferMultiSig(old, _contract);\r\n  }\r\n}\r\n\r\ncontract TrustListInterface{\r\n  function is_trusted(address addr) public returns(bool);\r\n}\r\ncontract TrustListTools{\r\n  TrustListInterface public list;\r\n  constructor(address _list) public {\r\n    require(_list != address(0x0));\r\n    list = TrustListInterface(_list);\r\n  }\r\n\r\n  modifier is_trusted(address addr){\r\n    require(list.is_trusted(addr), \"not a trusted issuer\");\r\n    _;\r\n  }\r\n\r\n}\r\n\r\ncontract TransferableToken{\r\n    function balanceOf(address _owner) public returns (uint256 balance) ;\r\n    function transfer(address _to, uint256 _amount) public returns (bool success) ;\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) ;\r\n}\r\n\r\n\r\ncontract TokenClaimer{\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _to, uint _amount);\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n  function _claimStdTokens(address _token, address payable to) internal {\r\n        if (_token == address(0x0)) {\r\n            to.transfer(address(this).balance);\r\n            return;\r\n        }\r\n        TransferableToken token = TransferableToken(_token);\r\n        uint balance = token.balanceOf(address(this));\r\n\r\n        (bool status,) = _token.call(abi.encodeWithSignature(\"transfer(address,uint256)\", to, balance));\r\n        require(status, \"call failed\");\r\n        emit ClaimedTokens(_token, to, balance);\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a, \"add\");\r\n    }\r\n    function safeSub(uint a, uint b) public pure returns (uint c) {\r\n        require(b <= a, \"sub\");\r\n        c = a - b;\r\n    }\r\n    function safeMul(uint a, uint b) public pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"mul\");\r\n    }\r\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\r\n        require(b > 0, \"div\");\r\n        c = a / b;\r\n    }\r\n}\r\n\r\ncontract IERC20Auction{\r\n function is_expired() public view returns(bool);\r\n\r\n function is_finished() public view returns(bool);\r\n\r\n function auction_expiration() public returns(bool);\r\n}\r\n\r\ncontract IERC20AuctionFactory{\r\n\r\n  function createERC20Auction(address _auction_proxy,\r\n              uint _min_obj_amount,\r\n              uint _min_bid_price,\r\n              uint _obj_price_unit,\r\n              uint _start_block,\r\n              uint _end_block,\r\n              address _creator,\r\n              address _multisig\r\n                             ) public returns(address);\r\n\r\n}\r\n\r\ncontract IERC20AuctionOpProxy {\r\n  function add_auction(address _auction) public;\r\n  function apply_bid(address addr, uint amount, uint price, uint price_unit) public;\r\n  function revoke_bid(address addr, uint amount, uint price, uint price_unit) public;\r\n  function apply_auction(address addr, uint amount, uint price, uint price_unit) public;\r\n  function object_token() public view returns(address, string memory);\r\n  function object_total_amount() public view returns(uint);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ERC20TokenBankInterface{\r\n  function balance() public view returns(uint);\r\n  function token() public view returns(address, string memory);\r\n  function issue(address _to, uint _amount) public returns (bool success);\r\n}\r\n\r\ncontract ERC20PeriodAuction is MultiSigTools{\r\n  IERC20AuctionOpProxy public auction_proxy;\r\n\r\n  uint public minimum_object_amount;\r\n  uint public minimum_bid_price;\r\n  uint public obj_price_unit;\r\n\r\n  uint public auction_period;\r\n  bool public auction_paused;\r\n\r\n  IERC20AuctionFactory public auction_factory;\r\n\r\n  IERC20Auction public current_auction;\r\n\r\n  mapping (address => bool) private trusted_auctions;\r\n\r\n  constructor(uint _min_obj_amount,\r\n              uint _min_bid_price,\r\n              uint _obj_price_unit,\r\n              uint _auction_period,\r\n              address _auction_factory,\r\n             address _multisig) public MultiSigTools(_multisig){\r\n    minimum_object_amount = _min_obj_amount;\r\n    minimum_bid_price = _min_bid_price;\r\n    obj_price_unit = _obj_price_unit;\r\n\r\n    auction_period = _auction_period;\r\n    auction_factory = IERC20AuctionFactory(_auction_factory);\r\n    auction_paused = false;\r\n  }\r\n\r\n  function unpause_auction(uint64 id) public only_signer is_majority_sig(id, \"unpause_auction\"){\r\n    require(auction_paused, \"already unpaused\");\r\n    auction_paused = false;\r\n  }\r\n  function pause_auction(uint64 id) public only_signer is_majority_sig(id, \"pause_auction\"){\r\n    require(!auction_paused, \"already paused\");\r\n    auction_paused = true;\r\n  }\r\n\r\n  event ChangeAuctionProxy(address old_addr, address new_addr);\r\n  function change_auction_proxy(uint64 id, address new_proxy) public only_signer is_majority_sig(id, \"change_auction_proxy\"){\r\n    require(new_proxy != address(0x0), \"invalid address\");\r\n    if(address(current_auction) != address(0x0)){\r\n      require(current_auction.is_finished(), \"current auction is not finished\");\r\n    }\r\n    address old = address(auction_proxy);\r\n    auction_proxy = IERC20AuctionOpProxy(new_proxy);\r\n    emit ChangeAuctionProxy(old, new_proxy);\r\n  }\r\n\r\n  event ChangeMinObjAmount(uint old_amount, uint new_amount);\r\n  function change_minimum_object_amount(uint64 id, uint new_amount) public only_signer is_majority_sig(id, \"change_minimum_object_amount\"){\r\n    require(new_amount != 0, \"invalid amount\");\r\n    if(address(current_auction) != address(0x0)){\r\n      require(current_auction.is_finished(), \"current auction is not finished\");\r\n    }\r\n    uint old = minimum_object_amount;\r\n    minimum_object_amount = new_amount;\r\n    emit ChangeMinObjAmount(old, new_amount);\r\n  }\r\n\r\n  event ChangeMinBidPrice(uint old_price, uint new_price);\r\n  function change_min_bid_price(uint64 id, uint new_price) public only_signer is_majority_sig(id, \"change_min_bid_price\"){\r\n    require(new_price != 0, \"invalid price\");\r\n    if(address(current_auction) != address(0x0)){\r\n      require(current_auction.is_finished(), \"current auction is not finished\");\r\n    }\r\n    uint old = minimum_bid_price;\r\n    minimum_bid_price = new_price;\r\n    emit ChangeMinBidPrice(old, new_price);\r\n  }\r\n\r\n  event ChangeAuctionObjPriceUnit(uint old_unit, uint new_unit);\r\n  function change_auction_obj_price_unit(uint64 id, uint new_unit) public only_signer is_majority_sig(id, \"change_auction_obj_price_unit\"){\r\n    require(new_unit >=1, \"invalid unit\");\r\n    if(address(current_auction) != address(0x0)){\r\n      require(current_auction.is_finished(), \"current auction is not finished\");\r\n    }\r\n    uint old = obj_price_unit;\r\n    obj_price_unit = new_unit;\r\n    emit ChangeAuctionObjPriceUnit(old, new_unit);\r\n  }\r\n\r\n  event ChangeAuctionPeriod(uint old_period, uint new_period);\r\n  function change_auction_period(uint64 id, uint new_period) public only_signer is_majority_sig(id, \"change_auction_period\"){\r\n    require(new_period > 1, \"invalid period\");\r\n    if(address(current_auction) != address(0x0)){\r\n      require(current_auction.is_finished(), \"current auction is not finished\");\r\n    }\r\n    uint old = auction_period;\r\n    auction_period = new_period;\r\n    emit ChangeAuctionPeriod(old, auction_period);\r\n  }\r\n\r\n  event ChangeAuctionFactory(address old_factory, address new_factory);\r\n  function change_auction_factory(uint64 id, address new_factory) public only_signer is_majority_sig(id, \"change_auction_factory\"){\r\n    require(new_factory != address(0x0), \"invalid address\");\r\n    if(address(current_auction) != address(0x0)){\r\n      require(current_auction.is_finished(), \"current auction is not finished\");\r\n    }\r\n    address old = address(auction_factory);\r\n    auction_factory = IERC20AuctionFactory(new_factory);\r\n    emit ChangeAuctionFactory(old, new_factory);\r\n  }\r\n\r\n  event ChangeCurrentAuction(address old_auction, address new_auction);\r\n  function change_current_auction(uint64 id, address new_auction) public only_signer is_majority_sig(id, \"change_current_auction\"){\r\n    require(new_auction != address(0x0), \"invalid address\");\r\n    if(address(current_auction) != address(0x0)){\r\n      require(current_auction.is_finished(), \"current auction is not finished\");\r\n    }\r\n    address old = address(current_auction);\r\n    current_auction = IERC20Auction(new_auction);\r\n    trusted_auctions[new_auction] = true;\r\n    emit ChangeCurrentAuction(old, new_auction);\r\n    auction_proxy.add_auction(address(current_auction));\r\n  }\r\n\r\n  event NewAuction(address new_auction);\r\n  function new_auction() public returns (address auction_address){\r\n    require(!auction_paused, \"auction already paused\");\r\n    require(address(auction_proxy) != address(0x0), \"not ready for create auction\");\r\n\r\n    if(address(current_auction) != address(0x0)){\r\n      require(current_auction.is_expired(), \"current auction is not expired\");\r\n      if(!current_auction.is_finished()){\r\n        current_auction.auction_expiration();\r\n      }\r\n      require(current_auction.is_finished(), \"current auction cannot be finished\");\r\n    }\r\n\r\n\r\n    address _current_auction = auction_factory.createERC20Auction(address(auction_proxy),\r\n                                                        minimum_object_amount,\r\n                                                        minimum_bid_price,\r\n                                                        obj_price_unit,\r\n                                                        block.number,\r\n                                                        block.number + auction_period,\r\n                                                        msg.sender,\r\n                                                        address(multisig_contract)\r\n                                                        );\r\n\r\n    trusted_auctions[address(_current_auction)] = true;\r\n    current_auction = IERC20Auction(_current_auction);\r\n    auction_proxy.add_auction(address(current_auction));\r\n\r\n    emit NewAuction(address(current_auction));\r\n    return address(current_auction);\r\n  }\r\n}\r\n\r\ncontract ERC20PeriodAuctionFactory{\r\n  event NewERC20PeriodAuction(address addr);\r\n  function createERC20PeriodAuction(uint _min_obj_amount,\r\n              uint _min_bid_price,\r\n              uint _obj_price_unit,\r\n              uint _auction_period,\r\n              address _auction_factory,\r\n             address _multisig) public returns(address){\r\n\r\n               ERC20PeriodAuction auction = new ERC20PeriodAuction(\r\n                 _min_obj_amount,\r\n                 _min_bid_price,\r\n                 _obj_price_unit,\r\n                 _auction_period,\r\n                 _auction_factory,\r\n                 _multisig\r\n               );\r\n\r\n               emit NewERC20PeriodAuction(address(auction));\r\n\r\n               return address(auction);\r\n          }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_min_obj_amount\",\"type\":\"uint256\"},{\"name\":\"_min_bid_price\",\"type\":\"uint256\"},{\"name\":\"_obj_price_unit\",\"type\":\"uint256\"},{\"name\":\"_auction_period\",\"type\":\"uint256\"},{\"name\":\"_auction_factory\",\"type\":\"address\"},{\"name\":\"_multisig\",\"type\":\"address\"}],\"name\":\"createERC20PeriodAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"NewERC20PeriodAuction\",\"type\":\"event\"}]","ContractName":"ERC20PeriodAuctionFactory","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://fb505991a2315f848a024931c63ee9e02a4f76bccc188ead7b2eef978f45f868"}]}