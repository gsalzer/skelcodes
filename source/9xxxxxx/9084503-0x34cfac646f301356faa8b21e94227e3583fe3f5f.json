{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.0 <0.7.0;\r\n\r\n/// @title SelfAuthorized - authorizes current contract to perform actions\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract SelfAuthorized {\r\n    modifier authorized() {\r\n        require(msg.sender == address(this), \"Method can only be called from this contract\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title MasterCopy - Base for master copy contracts (should always be first super contract)\r\n///         This contract is tightly coupled to our proxy contract (see `proxies/Proxy.sol`)\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ncontract MasterCopy is SelfAuthorized {\r\n\r\n    event ChangedMasterCopy(address masterCopy);\r\n\r\n    // masterCopy always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\r\n    // It should also always be ensured that the address is stored alone (uses a full word)\r\n    address private masterCopy;\r\n\r\n    /// @dev Allows to upgrade the contract. This can only be done via a Safe transaction.\r\n    /// @param _masterCopy New contract address.\r\n    function changeMasterCopy(address _masterCopy)\r\n        public\r\n        authorized\r\n    {\r\n        // Master copy address cannot be null.\r\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\r\n        masterCopy = _masterCopy;\r\n        emit ChangedMasterCopy(_masterCopy);\r\n    }\r\n}\r\n\r\n\r\n/// @title Module - Base class for modules.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract Module is MasterCopy {\r\n\r\n    ModuleManager public manager;\r\n\r\n    modifier authorized() {\r\n        require(msg.sender == address(manager), \"Method can only be called from manager\");\r\n        _;\r\n    }\r\n\r\n    function setManager()\r\n        internal\r\n    {\r\n        // manager can only be 0 at initalization of contract.\r\n        // Check ensures that setup function can only be called once.\r\n        require(address(manager) == address(0), \"Manager has already been set\");\r\n        manager = ModuleManager(msg.sender);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @title Enum - Collection of enums\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract Enum {\r\n    enum Operation {\r\n        Call,\r\n        DelegateCall\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @title Executor - A contract that can execute transactions\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract Executor {\r\n\r\n    function execute(address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        if (operation == Enum.Operation.Call)\r\n            success = executeCall(to, value, data, txGas);\r\n        else if (operation == Enum.Operation.DelegateCall)\r\n            success = executeDelegateCall(to, data, txGas);\r\n        else\r\n            success = false;\r\n    }\r\n\r\n    function executeCall(address to, uint256 value, bytes memory data, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n\r\n    function executeDelegateCall(address to, bytes memory data, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title SecuredTokenTransfer - Secure token transfer\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract SecuredTokenTransfer {\r\n\r\n    /// @dev Transfers a token and returns if it was a success\r\n    /// @param token Token that should be transferred\r\n    /// @param receiver Receiver to whom the token should be transferred\r\n    /// @param amount The amount of tokens that should be transferred\r\n    function transferToken (\r\n        address token,\r\n        address receiver,\r\n        uint256 amount\r\n    )\r\n        internal\r\n        returns (bool transferred)\r\n    {\r\n        bytes memory data = abi.encodeWithSignature(\"transfer(address,uint256)\", receiver, amount);\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let success := call(sub(gas, 10000), token, 0, add(data, 0x20), mload(data), 0, 0)\r\n            let ptr := mload(0x40)\r\n            mstore(0x40, add(ptr, returndatasize()))\r\n            returndatacopy(ptr, 0, returndatasize())\r\n            switch returndatasize()\r\n            case 0 { transferred := success }\r\n            case 0x20 { transferred := iszero(or(iszero(success), iszero(mload(ptr)))) }\r\n            default { transferred := 0 }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract ModuleManager is SelfAuthorized, Executor {\r\n\r\n    event EnabledModule(Module module);\r\n    event DisabledModule(Module module);\r\n    event ExecutionFromModuleSuccess(address indexed module);\r\n    event ExecutionFromModuleFailure(address indexed module);\r\n\r\n    address internal constant SENTINEL_MODULES = address(0x1);\r\n\r\n    mapping (address => address) internal modules;\r\n\r\n    function setupModules(address to, bytes memory data)\r\n        internal\r\n    {\r\n        require(modules[SENTINEL_MODULES] == address(0), \"Modules have already been initialized\");\r\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\r\n        if (to != address(0))\r\n            // Setup has to complete successfully or transaction fails.\r\n            require(executeDelegateCall(to, data, gasleft()), \"Could not finish initialization\");\r\n    }\r\n\r\n    /// @dev Allows to add a module to the whitelist.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param module Module to be whitelisted.\r\n    function enableModule(Module module)\r\n        public\r\n        authorized\r\n    {\r\n        // Module address cannot be null or sentinel.\r\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\r\n        // Module cannot be added twice.\r\n        require(modules[address(module)] == address(0), \"Module has already been added\");\r\n        modules[address(module)] = modules[SENTINEL_MODULES];\r\n        modules[SENTINEL_MODULES] = address(module);\r\n        emit EnabledModule(module);\r\n    }\r\n\r\n    /// @dev Allows to remove a module from the whitelist.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\r\n    /// @param module Module to be removed.\r\n    function disableModule(Module prevModule, Module module)\r\n        public\r\n        authorized\r\n    {\r\n        // Validate module address and check that it corresponds to module index.\r\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\r\n        require(modules[address(prevModule)] == address(module), \"Invalid prevModule, module pair provided\");\r\n        modules[address(prevModule)] = modules[address(module)];\r\n        modules[address(module)] = address(0);\r\n        emit DisabledModule(module);\r\n    }\r\n\r\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\r\n    /// @param to Destination address of module transaction.\r\n    /// @param value Ether value of module transaction.\r\n    /// @param data Data payload of module transaction.\r\n    /// @param operation Operation type of module transaction.\r\n    function execTransactionFromModule(address to, uint256 value, bytes memory data, Enum.Operation operation)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        // Only whitelisted modules are allowed.\r\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"Method can only be called from an enabled module\");\r\n        // Execute transaction without further confirmations.\r\n        success = execute(to, value, data, operation, gasleft());\r\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\r\n        else emit ExecutionFromModuleFailure(msg.sender);\r\n    }\r\n\r\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\r\n    /// @param to Destination address of module transaction.\r\n    /// @param value Ether value of module transaction.\r\n    /// @param data Data payload of module transaction.\r\n    /// @param operation Operation type of module transaction.\r\n    function execTransactionFromModuleReturnData(address to, uint256 value, bytes memory data, Enum.Operation operation)\r\n        public\r\n        returns (bool success, bytes memory returnData)\r\n    {\r\n        success = execTransactionFromModule(to, value, data, operation);\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            // Load free memory location\r\n            let ptr := mload(0x40)\r\n            // We allocate memory for the return data by setting the free memory location to\r\n            // current free memory location + data size + 32 bytes for data size value\r\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\r\n            // Store the size\r\n            mstore(ptr, returndatasize())\r\n            // Store the data\r\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\r\n            // Point the return data to the correct memory location\r\n            returnData := ptr\r\n        }\r\n    }\r\n\r\n    /// @dev Returns array of first 10 modules.\r\n    /// @return Array of modules.\r\n    function getModules()\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        (address[] memory array,) = getModulesPaginated(SENTINEL_MODULES, 10);\r\n        return array;\r\n    }\r\n\r\n    /// @dev Returns array of modules.\r\n    /// @param start Start of the page.\r\n    /// @param pageSize Maximum number of modules that should be returned.\r\n    /// @return Array of modules.\r\n    function getModulesPaginated(address start, uint256 pageSize)\r\n        public\r\n        view\r\n        returns (address[] memory array, address next)\r\n    {\r\n        // Init array with max page size\r\n        array = new address[](pageSize);\r\n\r\n        // Populate return array\r\n        uint256 moduleCount = 0;\r\n        address currentModule = modules[start];\r\n        while(currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\r\n            array[moduleCount] = currentModule;\r\n            currentModule = modules[currentModule];\r\n            moduleCount++;\r\n        }\r\n        next = currentModule;\r\n        // Set correct size of returned array\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            mstore(array, moduleCount)\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/// @title OwnerManager - Manages a set of owners and a threshold to perform actions.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract OwnerManager is SelfAuthorized {\r\n\r\n    event AddedOwner(address owner);\r\n    event RemovedOwner(address owner);\r\n    event ChangedThreshold(uint256 threshold);\r\n\r\n    address internal constant SENTINEL_OWNERS = address(0x1);\r\n\r\n    mapping(address => address) internal owners;\r\n    uint256 ownerCount;\r\n    uint256 internal threshold;\r\n\r\n    /// @dev Setup function sets initial storage of contract.\r\n    /// @param _owners List of Safe owners.\r\n    /// @param _threshold Number of required confirmations for a Safe transaction.\r\n    function setupOwners(address[] memory _owners, uint256 _threshold)\r\n        internal\r\n    {\r\n        // Threshold can only be 0 at initialization.\r\n        // Check ensures that setup function can only be called once.\r\n        require(threshold == 0, \"Owners have already been setup\");\r\n        // Validate that threshold is smaller than number of added owners.\r\n        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\r\n        // There has to be at least one Safe owner.\r\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\r\n        // Initializing Safe owners.\r\n        address currentOwner = SENTINEL_OWNERS;\r\n        for (uint256 i = 0; i < _owners.length; i++) {\r\n            // Owner address cannot be null.\r\n            address owner = _owners[i];\r\n            require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n            // No duplicate owners allowed.\r\n            require(owners[owner] == address(0), \"Duplicate owner address provided\");\r\n            owners[currentOwner] = owner;\r\n            currentOwner = owner;\r\n        }\r\n        owners[currentOwner] = SENTINEL_OWNERS;\r\n        ownerCount = _owners.length;\r\n        threshold = _threshold;\r\n    }\r\n\r\n    /// @dev Allows to add a new owner to the Safe and update the threshold at the same time.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param owner New owner address.\r\n    /// @param _threshold New threshold.\r\n    function addOwnerWithThreshold(address owner, uint256 _threshold)\r\n        public\r\n        authorized\r\n    {\r\n        // Owner address cannot be null.\r\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n        // No duplicate owners allowed.\r\n        require(owners[owner] == address(0), \"Address is already an owner\");\r\n        owners[owner] = owners[SENTINEL_OWNERS];\r\n        owners[SENTINEL_OWNERS] = owner;\r\n        ownerCount++;\r\n        emit AddedOwner(owner);\r\n        // Change threshold if threshold was changed.\r\n        if (threshold != _threshold)\r\n            changeThreshold(_threshold);\r\n    }\r\n\r\n    /// @dev Allows to remove an owner from the Safe and update the threshold at the same time.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param prevOwner Owner that pointed to the owner to be removed in the linked list\r\n    /// @param owner Owner address to be removed.\r\n    /// @param _threshold New threshold.\r\n    function removeOwner(address prevOwner, address owner, uint256 _threshold)\r\n        public\r\n        authorized\r\n    {\r\n        // Only allow to remove an owner, if threshold can still be reached.\r\n        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\r\n        // Validate owner address and check that it corresponds to owner index.\r\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\r\n        owners[prevOwner] = owners[owner];\r\n        owners[owner] = address(0);\r\n        ownerCount--;\r\n        emit RemovedOwner(owner);\r\n        // Change threshold if threshold was changed.\r\n        if (threshold != _threshold)\r\n            changeThreshold(_threshold);\r\n    }\r\n\r\n    /// @dev Allows to swap/replace an owner from the Safe with another address.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\r\n    /// @param oldOwner Owner address to be replaced.\r\n    /// @param newOwner New owner address.\r\n    function swapOwner(address prevOwner, address oldOwner, address newOwner)\r\n        public\r\n        authorized\r\n    {\r\n        // Owner address cannot be null.\r\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n        // No duplicate owners allowed.\r\n        require(owners[newOwner] == address(0), \"Address is already an owner\");\r\n        // Validate oldOwner address and check that it corresponds to owner index.\r\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\r\n        owners[newOwner] = owners[oldOwner];\r\n        owners[prevOwner] = newOwner;\r\n        owners[oldOwner] = address(0);\r\n        emit RemovedOwner(oldOwner);\r\n        emit AddedOwner(newOwner);\r\n    }\r\n\r\n    /// @dev Allows to update the number of required confirmations by Safe owners.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param _threshold New threshold.\r\n    function changeThreshold(uint256 _threshold)\r\n        public\r\n        authorized\r\n    {\r\n        // Validate that threshold is smaller than number of owners.\r\n        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\r\n        // There has to be at least one Safe owner.\r\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\r\n        threshold = _threshold;\r\n        emit ChangedThreshold(threshold);\r\n    }\r\n\r\n    function getThreshold()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return threshold;\r\n    }\r\n\r\n    function isOwner(address owner)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\r\n    }\r\n\r\n    /// @dev Returns array of owners.\r\n    /// @return Array of Safe owners.\r\n    function getOwners()\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        address[] memory array = new address[](ownerCount);\r\n\r\n        // populate return array\r\n        uint256 index = 0;\r\n        address currentOwner = owners[SENTINEL_OWNERS];\r\n        while(currentOwner != SENTINEL_OWNERS) {\r\n            array[index] = currentOwner;\r\n            currentOwner = owners[currentOwner];\r\n            index ++;\r\n        }\r\n        return array;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract FallbackManager is SelfAuthorized {\r\n\r\n    // keccak256(\"fallback_manager.handler.address\")\r\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\r\n\r\n    function internalSetFallbackHandler(address handler) internal {\r\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            sstore(slot, handler)\r\n        }\r\n    }\r\n\r\n    /// @dev Allows to add a contract to handle fallback calls.\r\n    ///      Only fallback calls without value and with data will be forwarded.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param handler contract to handle fallbacks calls.\r\n    function setFallbackHandler(address handler)\r\n        public\r\n        authorized\r\n    {\r\n        internalSetFallbackHandler(handler);\r\n    }\r\n\r\n    function ()\r\n        external\r\n        payable\r\n    {\r\n        // Only calls without value and with data will be forwarded\r\n        if (msg.value > 0 || msg.data.length == 0) {\r\n            return;\r\n        }\r\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\r\n        address handler;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            handler := sload(slot)\r\n        }\r\n\r\n        if (handler != address(0)) {\r\n            // solium-disable-next-line security/no-inline-assembly\r\n            assembly {\r\n                calldatacopy(0, 0, calldatasize())\r\n                let success := call(gas, handler, 0, 0, calldatasize(), 0, 0)\r\n                returndatacopy(0, 0, returndatasize())\r\n                if eq(success, 0) { revert(0, returndatasize()) }\r\n                return(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title SignatureDecoder - Decodes signatures that a encoded as bytes\r\n/// @author Ricardo Guilherme Schmidt (Status Research & Development GmbH)\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract SignatureDecoder {\r\n    \r\n    /// @dev Recovers address who signed the message\r\n    /// @param messageHash operation ethereum signed message hash\r\n    /// @param messageSignature message `txHash` signature\r\n    /// @param pos which signature to read\r\n    function recoverKey (\r\n        bytes32 messageHash,\r\n        bytes memory messageSignature,\r\n        uint256 pos\r\n    )\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n        (v, r, s) = signatureSplit(messageSignature, pos);\r\n        return ecrecover(messageHash, v, r, s);\r\n    }\r\n\r\n    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.\r\n    /// @notice Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures\r\n    /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access\r\n    /// @param signatures concatenated rsv signatures\r\n    function signatureSplit(bytes memory signatures, uint256 pos)\r\n        internal\r\n        pure\r\n        returns (uint8 v, bytes32 r, bytes32 s)\r\n    {\r\n        // The signature format is a compact form of:\r\n        //   {bytes32 r}{bytes32 s}{uint8 v}\r\n        // Compact means, uint8 is not padded to 32 bytes.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let signaturePos := mul(0x41, pos)\r\n            r := mload(add(signatures, add(signaturePos, 0x20)))\r\n            s := mload(add(signatures, add(signaturePos, 0x40)))\r\n            // Here we are loading the last 32 bytes, including 31 bytes\r\n            // of 's'. There is no 'mload8' to do this.\r\n            //\r\n            // 'byte' is not working due to the Solidity parser, so lets\r\n            // use the second best option, 'and'\r\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ncontract ISignatureValidatorConstants {\r\n    // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\r\n    bytes4 constant internal EIP1271_MAGIC_VALUE = 0x20c13b0b;\r\n}\r\n\r\ncontract ISignatureValidator is ISignatureValidatorConstants {\r\n\r\n    /**\r\n    * @dev Should return whether the signature provided is valid for the provided data\r\n    * @param _data Arbitrary length data signed on the behalf of address(this)\r\n    * @param _signature Signature byte array associated with _data\r\n    *\r\n    * MUST return the bytes4 magic value 0x20c13b0b when function passes.\r\n    * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\r\n    * MUST allow external calls\r\n    */\r\n    function isValidSignature(\r\n        bytes memory _data,\r\n        bytes memory _signature)\r\n        public\r\n        view\r\n        returns (bytes4);\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n * TODO: remove once open zeppelin update to solc 0.5.0\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.\r\n/// @author Stefan George - <stefan@gnosis.io>\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\n/// @author Ricardo Guilherme Schmidt - (Status Research & Development GmbH) - Gas Token Payment\r\ncontract GnosisSafe\r\n    is MasterCopy, ModuleManager, OwnerManager, SignatureDecoder, SecuredTokenTransfer, ISignatureValidatorConstants, FallbackManager {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    string public constant NAME = \"Gnosis Safe\";\r\n    string public constant VERSION = \"1.1.1\";\r\n\r\n    //keccak256(\r\n    //    \"EIP712Domain(address verifyingContract)\"\r\n    //);\r\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x035aff83d86937d35b32e04f0ddc6ff469290eef2f1b692d8a815c89404d4749;\r\n\r\n    //keccak256(\r\n    //    \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\r\n    //);\r\n    bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\r\n\r\n    //keccak256(\r\n    //    \"SafeMessage(bytes message)\"\r\n    //);\r\n    bytes32 private constant SAFE_MSG_TYPEHASH = 0x60b3cbf8b4a223d68d641b3b6ddf9a298e7f33710cf3d3a9d1146b5a6150fbca;\r\n\r\n    event ApproveHash(\r\n        bytes32 indexed approvedHash,\r\n        address indexed owner\r\n    );\r\n    event SignMsg(\r\n        bytes32 indexed msgHash\r\n    );\r\n    event ExecutionFailure(\r\n        bytes32 txHash, uint256 payment\r\n    );\r\n    event ExecutionSuccess(\r\n        bytes32 txHash, uint256 payment\r\n    );\r\n\r\n    uint256 public nonce;\r\n    bytes32 public domainSeparator;\r\n    // Mapping to keep track of all message hashes that have been approve by ALL REQUIRED owners\r\n    mapping(bytes32 => uint256) public signedMessages;\r\n    // Mapping to keep track of all hashes (message or transaction) that have been approve by ANY owners\r\n    mapping(address => mapping(bytes32 => uint256)) public approvedHashes;\r\n\r\n    // This constructor ensures that this contract can only be used as a master copy for Proxy contracts\r\n    constructor() public {\r\n        // By setting the threshold it is not possible to call setup anymore,\r\n        // so we create a Safe with 0 owners and threshold 1.\r\n        // This is an unusable Safe, perfect for the mastercopy\r\n        threshold = 1;\r\n    }\r\n\r\n    /// @dev Setup function sets initial storage of contract.\r\n    /// @param _owners List of Safe owners.\r\n    /// @param _threshold Number of required confirmations for a Safe transaction.\r\n    /// @param to Contract address for optional delegate call.\r\n    /// @param data Data payload for optional delegate call.\r\n    /// @param fallbackHandler Handler for fallback calls to this contract\r\n    /// @param paymentToken Token that should be used for the payment (0 is ETH)\r\n    /// @param payment Value that should be paid\r\n    /// @param paymentReceiver Adddress that should receive the payment (or 0 if tx.origin)\r\n    function setup(\r\n        address[] calldata _owners,\r\n        uint256 _threshold,\r\n        address to,\r\n        bytes calldata data,\r\n        address fallbackHandler,\r\n        address paymentToken,\r\n        uint256 payment,\r\n        address payable paymentReceiver\r\n    )\r\n        external\r\n    {\r\n        require(domainSeparator == 0, \"Domain Separator already set!\");\r\n        domainSeparator = keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, this));\r\n        setupOwners(_owners, _threshold);\r\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\r\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\r\n        setupModules(to, data);\r\n\r\n        if (payment > 0) {\r\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\r\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\r\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\r\n        }\r\n    }\r\n\r\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\r\n    ///      Note: The fees are always transfered, even if the user transaction fails.\r\n    /// @param to Destination address of Safe transaction.\r\n    /// @param value Ether value of Safe transaction.\r\n    /// @param data Data payload of Safe transaction.\r\n    /// @param operation Operation type of Safe transaction.\r\n    /// @param safeTxGas Gas that should be used for the Safe transaction.\r\n    /// @param baseGas Gas costs for that are indipendent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\r\n    /// @param gasPrice Gas price that should be used for the payment calculation.\r\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\r\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\r\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\r\n    function execTransaction(\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        uint256 baseGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address payable refundReceiver,\r\n        bytes calldata signatures\r\n    )\r\n        external\r\n        returns (bool success)\r\n    {\r\n        bytes32 txHash;\r\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\r\n        {\r\n            bytes memory txHashData = encodeTransactionData(\r\n                to, value, data, operation, // Transaction info\r\n                safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, // Payment info\r\n                nonce\r\n            );\r\n            // Increase nonce and execute transaction.\r\n            nonce++;\r\n            txHash = keccak256(txHashData);\r\n            checkSignatures(txHash, txHashData, signatures, true);\r\n        }\r\n        require(gasleft() >= safeTxGas, \"Not enough gas to execute safe transaction\");\r\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\r\n        {\r\n            uint256 gasUsed = gasleft();\r\n            // If no safeTxGas has been set and the gasPrice is 0 we assume that all available gas can be used\r\n            success = execute(to, value, data, operation, safeTxGas == 0 && gasPrice == 0 ? gasleft() : safeTxGas);\r\n            gasUsed = gasUsed.sub(gasleft());\r\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\r\n            uint256 payment = 0;\r\n            if (gasPrice > 0) {\r\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\r\n            }\r\n            if (success) emit ExecutionSuccess(txHash, payment);\r\n            else emit ExecutionFailure(txHash, payment);\r\n        }\r\n    }\r\n\r\n    function handlePayment(\r\n        uint256 gasUsed,\r\n        uint256 baseGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address payable refundReceiver\r\n    )\r\n        private\r\n        returns (uint256 payment)\r\n    {\r\n        // solium-disable-next-line security/no-tx-origin\r\n        address payable receiver = refundReceiver == address(0) ? tx.origin : refundReceiver;\r\n        if (gasToken == address(0)) {\r\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\r\n            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\r\n            // solium-disable-next-line security/no-send\r\n            require(receiver.send(payment), \"Could not pay gas costs with ether\");\r\n        } else {\r\n            payment = gasUsed.add(baseGas).mul(gasPrice);\r\n            require(transferToken(gasToken, receiver, payment), \"Could not pay gas costs with token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\r\n    * @param dataHash Hash of the data (could be either a message hash or transaction hash)\r\n    * @param data That should be signed (this is passed to an external validator contract)\r\n    * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\r\n    * @param consumeHash Indicates that in case of an approved hash the storage can be freed to save gas\r\n    */\r\n    function checkSignatures(bytes32 dataHash, bytes memory data, bytes memory signatures, bool consumeHash)\r\n        internal\r\n    {\r\n        // Load threshold to avoid multiple storage loads\r\n        uint256 _threshold = threshold;\r\n        // Check that a threshold is set\r\n        require(_threshold > 0, \"Threshold needs to be defined!\");\r\n        // Check that the provided signature data is not too short\r\n        require(signatures.length >= _threshold.mul(65), \"Signatures data too short\");\r\n        // There cannot be an owner with address 0.\r\n        address lastOwner = address(0);\r\n        address currentOwner;\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint256 i;\r\n        for (i = 0; i < _threshold; i++) {\r\n            (v, r, s) = signatureSplit(signatures, i);\r\n            // If v is 0 then it is a contract signature\r\n            if (v == 0) {\r\n                // When handling contract signatures the address of the contract is encoded into r\r\n                currentOwner = address(uint256(r));\r\n\r\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\r\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\r\n                // Here we only check that the pointer is not pointing inside the part that is being processed\r\n                require(uint256(s) >= _threshold.mul(65), \"Invalid contract signature location: inside static part\");\r\n\r\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\r\n                require(uint256(s).add(32) <= signatures.length, \"Invalid contract signature location: length not present\");\r\n\r\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\r\n                uint256 contractSignatureLen;\r\n                // solium-disable-next-line security/no-inline-assembly\r\n                assembly {\r\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\r\n                }\r\n                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"Invalid contract signature location: data not complete\");\r\n\r\n                // Check signature\r\n                bytes memory contractSignature;\r\n                // solium-disable-next-line security/no-inline-assembly\r\n                assembly {\r\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\r\n                    contractSignature := add(add(signatures, s), 0x20)\r\n                }\r\n                require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"Invalid contract signature provided\");\r\n            // If v is 1 then it is an approved hash\r\n            } else if (v == 1) {\r\n                // When handling approved hashes the address of the approver is encoded into r\r\n                currentOwner = address(uint256(r));\r\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\r\n                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"Hash has not been approved\");\r\n                // Hash has been marked for consumption. If this hash was pre-approved free storage\r\n                if (consumeHash && msg.sender != currentOwner) {\r\n                    approvedHashes[currentOwner][dataHash] = 0;\r\n                }\r\n            } else if (v > 30) {\r\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\r\n                currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\r\n            } else {\r\n                // Use ecrecover with the messageHash for EOA signatures\r\n                currentOwner = ecrecover(dataHash, v, r, s);\r\n            }\r\n            require (\r\n                currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS,\r\n                \"Invalid owner provided\"\r\n            );\r\n            lastOwner = currentOwner;\r\n        }\r\n    }\r\n\r\n    /// @dev Allows to estimate a Safe transaction.\r\n    ///      This method is only meant for estimation purpose, therefore two different protection mechanism against execution in a transaction have been made:\r\n    ///      1.) The method can only be called from the safe itself\r\n    ///      2.) The response is returned with a revert\r\n    ///      When estimating set `from` to the address of the safe.\r\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\r\n    /// @param to Destination address of Safe transaction.\r\n    /// @param value Ether value of Safe transaction.\r\n    /// @param data Data payload of Safe transaction.\r\n    /// @param operation Operation type of Safe transaction.\r\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\r\n    function requiredTxGas(address to, uint256 value, bytes calldata data, Enum.Operation operation)\r\n        external\r\n        authorized\r\n        returns (uint256)\r\n    {\r\n        uint256 startGas = gasleft();\r\n        // We don't provide an error message here, as we use it to return the estimate\r\n        // solium-disable-next-line error-reason\r\n        require(execute(to, value, data, operation, gasleft()));\r\n        uint256 requiredGas = startGas - gasleft();\r\n        // Convert response to string and return via error message\r\n        revert(string(abi.encodePacked(requiredGas)));\r\n    }\r\n\r\n    /**\r\n    * @dev Marks a hash as approved. This can be used to validate a hash that is used by a signature.\r\n    * @param hashToApprove The hash that should be marked as approved for signatures that are verified by this contract.\r\n    */\r\n    function approveHash(bytes32 hashToApprove)\r\n        external\r\n    {\r\n        require(owners[msg.sender] != address(0), \"Only owners can approve a hash\");\r\n        approvedHashes[msg.sender][hashToApprove] = 1;\r\n        emit ApproveHash(hashToApprove, msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev Marks a message as signed\r\n    * @param _data Arbitrary length data that should be marked as signed on the behalf of address(this)\r\n    */\r\n    function signMessage(bytes calldata _data)\r\n        external\r\n        authorized\r\n    {\r\n        bytes32 msgHash = getMessageHash(_data);\r\n        signedMessages[msgHash] = 1;\r\n        emit SignMsg(msgHash);\r\n    }\r\n\r\n    /**\r\n    * Implementation of ISignatureValidator (see `interfaces/ISignatureValidator.sol`)\r\n    * @dev Should return whether the signature provided is valid for the provided data.\r\n    *       The save does not implement the interface since `checkSignatures` is not a view method.\r\n    *       The method will not perform any state changes (see parameters of `checkSignatures`)\r\n    * @param _data Arbitrary length data signed on the behalf of address(this)\r\n    * @param _signature Signature byte array associated with _data\r\n    * @return a bool upon valid or invalid signature with corresponding _data\r\n    */\r\n    function isValidSignature(bytes calldata _data, bytes calldata _signature)\r\n        external\r\n        returns (bytes4)\r\n    {\r\n        bytes32 messageHash = getMessageHash(_data);\r\n        if (_signature.length == 0) {\r\n            require(signedMessages[messageHash] != 0, \"Hash not approved\");\r\n        } else {\r\n            // consumeHash needs to be false, as the state should not be changed\r\n            checkSignatures(messageHash, _data, _signature, false);\r\n        }\r\n        return EIP1271_MAGIC_VALUE;\r\n    }\r\n\r\n    /// @dev Returns hash of a message that can be signed by owners.\r\n    /// @param message Message that should be hashed\r\n    /// @return Message hash.\r\n    function getMessageHash(\r\n        bytes memory message\r\n    )\r\n        public\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        bytes32 safeMessageHash = keccak256(\r\n            abi.encode(SAFE_MSG_TYPEHASH, keccak256(message))\r\n        );\r\n        return keccak256(\r\n            abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, safeMessageHash)\r\n        );\r\n    }\r\n\r\n    /// @dev Returns the bytes that are hashed to be signed by owners.\r\n    /// @param to Destination address.\r\n    /// @param value Ether value.\r\n    /// @param data Data payload.\r\n    /// @param operation Operation type.\r\n    /// @param safeTxGas Fas that should be used for the safe transaction.\r\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\r\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\r\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\r\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\r\n    /// @param _nonce Transaction nonce.\r\n    /// @return Transaction hash bytes.\r\n    function encodeTransactionData(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        uint256 baseGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address refundReceiver,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        bytes32 safeTxHash = keccak256(\r\n            abi.encode(SAFE_TX_TYPEHASH, to, value, keccak256(data), operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce)\r\n        );\r\n        return abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, safeTxHash);\r\n    }\r\n\r\n    /// @dev Returns hash to be signed by owners.\r\n    /// @param to Destination address.\r\n    /// @param value Ether value.\r\n    /// @param data Data payload.\r\n    /// @param operation Operation type.\r\n    /// @param safeTxGas Fas that should be used for the safe transaction.\r\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\r\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\r\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\r\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\r\n    /// @param _nonce Transaction nonce.\r\n    /// @return Transaction hash.\r\n    function getTransactionHash(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        uint256 baseGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address refundReceiver,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"AddedOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"approvedHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ApproveHash\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"masterCopy\",\"type\":\"address\"}],\"name\":\"ChangedMasterCopy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"ChangedThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract Module\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"DisabledModule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract Module\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"EnabledModule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"}],\"name\":\"ExecutionFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"ExecutionFromModuleFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"ExecutionFromModuleSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"}],\"name\":\"ExecutionSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"RemovedOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"msgHash\",\"type\":\"bytes32\"}],\"name\":\"SignMsg\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"addOwnerWithThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hashToApprove\",\"type\":\"bytes32\"}],\"name\":\"approveHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"approvedHashes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_masterCopy\",\"type\":\"address\"}],\"name\":\"changeMasterCopy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"changeThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract Module\",\"name\":\"prevModule\",\"type\":\"address\"},{\"internalType\":\"contract Module\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"disableModule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"domainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract Module\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"enableModule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Enum.Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"safeTxGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"gasToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"refundReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"encodeTransactionData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Enum.Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"safeTxGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"gasToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"refundReceiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"execTransaction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Enum.Operation\",\"name\":\"operation\",\"type\":\"uint8\"}],\"name\":\"execTransactionFromModule\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Enum.Operation\",\"name\":\"operation\",\"type\":\"uint8\"}],\"name\":\"execTransactionFromModuleReturnData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"getMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getModules\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"start\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pageSize\",\"type\":\"uint256\"}],\"name\":\"getModulesPaginated\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"array\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"next\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Enum.Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"safeTxGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"gasToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"refundReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"getTransactionHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Enum.Operation\",\"name\":\"operation\",\"type\":\"uint8\"}],\"name\":\"requiredTxGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"handler\",\"type\":\"address\"}],\"name\":\"setFallbackHandler\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"fallbackHandler\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"paymentReceiver\",\"type\":\"address\"}],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"signMessage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"signedMessages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"swapOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GnosisSafe","CompilerVersion":"v0.5.14+commit.1f1aaa4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://a7fb8401881dd34db9eb6d0ba5ed869bcd2fed1947a667da00937b6b6bda9361"}]}