{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/jake/plasma-contracts/plasma_framework/contracts/src/vaults/Erc20Vault.sol\": {\r\n      \"content\": \"pragma solidity 0.5.11;\\n\\nimport \\\"./Vault.sol\\\";\\nimport \\\"./verifiers/IErc20DepositVerifier.sol\\\";\\nimport \\\"../framework/PlasmaFramework.sol\\\";\\n\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\ncontract Erc20Vault is Vault {\\n    using SafeERC20 for IERC20;\\n\\n    event Erc20Withdrawn(\\n        address indexed receiver,\\n        address indexed token,\\n        uint256 amount\\n    );\\n\\n    event DepositCreated(\\n        address indexed depositor,\\n        uint256 indexed blknum,\\n        address indexed token,\\n        uint256 amount\\n    );\\n\\n    constructor(PlasmaFramework _framework) public Vault(_framework) {}\\n\\n    /**\\n     * @notice Deposits approved amount of ERC20 token(s) into the contract\\n     * Once the deposit is recognized, the owner (depositor) can transact on the OmiseGO Network\\n     * The approve function of the ERC20 token contract must be called before calling this function\\n     * for at least the amount that is deposited into the contract\\n     * @param depositTx RLP-encoded transaction to act as the deposit\\n     */\\n    function deposit(bytes calldata depositTx) external {\\n        address depositVerifier = super.getEffectiveDepositVerifier();\\n        require(depositVerifier != address(0), \\\"Deposit verifier has not been set\\\");\\n\\n        (address depositor, address token, uint256 amount) = IErc20DepositVerifier(depositVerifier)\\n            .verify(depositTx, msg.sender, address(this));\\n\\n        IERC20(token).safeTransferFrom(depositor, address(this), amount);\\n\\n        uint256 blknum = super.submitDepositBlock(depositTx);\\n\\n        emit DepositCreated(msg.sender, blknum, token, amount);\\n    }\\n\\n    /**\\n    * @notice Withdraw ERC20 tokens that have successfully exited from the OmiseGO Network\\n    * @param receiver Address of the recipient\\n    * @param token Address of ERC20 token contract\\n    * @param amount Amount to transfer\\n    */\\n    function withdraw(address payable receiver, address token, uint256 amount) external onlyFromNonQuarantinedExitGame {\\n        IERC20(token).safeTransfer(receiver, amount);\\n        emit Erc20Withdrawn(receiver, token, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/jake/plasma-contracts/plasma_framework/contracts/src/framework/BlockController.sol\": {\r\n      \"content\": \"pragma solidity 0.5.11;\\n\\nimport \\\"./models/BlockModel.sol\\\";\\nimport \\\"./registries/VaultRegistry.sol\\\";\\nimport \\\"../utils/OnlyFromAddress.sol\\\";\\n\\n/**\\n* @notice Controls the logic and functions for block submissions in PlasmaFramework\\n* @dev There are two types of blocks: child block and deposit block\\n*      Each child block has an interval of 'childBlockInterval'\\n*      The interval is preserved for deposits. Each deposit results in one deposit block.\\n*      For instance, a child block would be in block 1000 and the next deposit would result in block 1001.\\n*\\n*      Only the authority address can perform a block submission.\\n*      Details on limitations for the authority address can be found here: https://github.com/omisego/elixir-omg#managing-the-operator-address\\n*/\\ncontract BlockController is OnlyFromAddress, VaultRegistry {\\n    address public authority;\\n    uint256 public childBlockInterval;\\n    uint256 public nextChildBlock;\\n    uint256 public nextDeposit;\\n    bool public isChildChainActivated;\\n\\n    mapping (uint256 => BlockModel.Block) public blocks; // block number => Block data\\n\\n    event BlockSubmitted(\\n        uint256 blknum\\n    );\\n\\n    event ChildChainActivated(\\n        address authority\\n    );\\n\\n    constructor(\\n        uint256 _interval,\\n        uint256 _minExitPeriod,\\n        uint256 _initialImmuneVaults,\\n        address _authority\\n    )\\n        public\\n        VaultRegistry(_minExitPeriod, _initialImmuneVaults)\\n    {\\n        authority = _authority;\\n        childBlockInterval = _interval;\\n        nextChildBlock = childBlockInterval;\\n        nextDeposit = 1;\\n        isChildChainActivated = false;\\n    }\\n\\n    /**\\n     * @notice Activates the child chain so that child chain can start to submit child blocks to root chain\\n     * @notice Can only be called once by the authority.\\n     * @notice Sets isChildChainActivated to true and emits the ChildChainActivated event.\\n     * @dev This is a preserved action for authority account to start its nonce with 1.\\n     *      Child chain rely ethereum nonce to protect re-org: https://git.io/JecDG\\n     *      see discussion: https://git.io/JenaT, https://git.io/JecDO\\n     */\\n    function activateChildChain() external onlyFrom(authority) {\\n        require(isChildChainActivated == false, \\\"Child chain already activated\\\");\\n        isChildChainActivated = true;\\n        emit ChildChainActivated(authority);\\n    }\\n\\n    /**\\n     * @notice Allows the authority to submit the Merkle root of a Plasma block\\n     * @dev emit BlockSubmitted event\\n     * @dev Block number jumps 'childBlockInterval' per submission\\n     * @dev See discussion in https://github.com/omisego/plasma-contracts/issues/233\\n     * @param _blockRoot Merkle root of the Plasma block\\n     */\\n    function submitBlock(bytes32 _blockRoot) external onlyFrom(authority) {\\n        require(isChildChainActivated == true, \\\"Child chain has not been activated by authority address yet\\\");\\n        uint256 submittedBlockNumber = nextChildBlock;\\n\\n        blocks[submittedBlockNumber] = BlockModel.Block({\\n            root: _blockRoot,\\n            timestamp: block.timestamp\\n        });\\n\\n        nextChildBlock += childBlockInterval;\\n        nextDeposit = 1;\\n\\n        emit BlockSubmitted(submittedBlockNumber);\\n    }\\n\\n    /**\\n     * @notice Submits a block for deposit\\n     * @dev Block number adds 1 per submission; it's possible to have at most 'childBlockInterval' deposit blocks between two child chain blocks\\n     * @param _blockRoot Merkle root of the Plasma block\\n     * @return The deposit block number\\n     */\\n    function submitDepositBlock(bytes32 _blockRoot) public onlyFromNonQuarantinedVault returns (uint256) {\\n        require(isChildChainActivated == true, \\\"Child chain has not been activated by authority address yet\\\");\\n        require(nextDeposit < childBlockInterval, \\\"Exceeded limit of deposits per child block interval\\\");\\n\\n        uint256 blknum = nextDepositBlock();\\n        blocks[blknum] = BlockModel.Block({\\n            root : _blockRoot,\\n            timestamp : block.timestamp\\n        });\\n\\n        nextDeposit++;\\n        return blknum;\\n    }\\n\\n    function nextDepositBlock() public view returns (uint256) {\\n        return nextChildBlock - childBlockInterval + nextDeposit;\\n    }\\n\\n    function isDeposit(uint256 blockNum) public view returns (bool) {\\n        require(blocks[blockNum].timestamp != 0, \\\"Block does not exist\\\");\\n        return blockNum % childBlockInterval != 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/jake/plasma-contracts/plasma_framework/contracts/src/framework/ExitGameController.sol\": {\r\n      \"content\": \"pragma solidity 0.5.11;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./interfaces/IExitProcessor.sol\\\";\\nimport \\\"./registries/ExitGameRegistry.sol\\\";\\nimport \\\"./utils/PriorityQueue.sol\\\";\\nimport \\\"./utils/ExitPriority.sol\\\";\\nimport \\\"../utils/PosLib.sol\\\";\\n\\n/**\\n * @notice Controls the logic and functions for ExitGame to interact with the PlasmaFramework\\n *         Plasma M(ore)VP relies on exit priority to secure the user from invalid transactions\\n *         The priority queue ensures the exit is processed with the exit priority\\n *         For details, see the Plasma MVP spec: https://ethresear.ch/t/minimal-viable-plasma/426\\n */\\ncontract ExitGameController is ExitGameRegistry {\\n    // exit hashed (priority, vault id, token) => IExitProcessor\\n    mapping (bytes32 => IExitProcessor) public delegations;\\n    // hashed (vault id, token) => PriorityQueue\\n    mapping (bytes32 => PriorityQueue) public exitsQueues;\\n    // outputId => exitId\\n    mapping (bytes32 => uint160) public outputsFinalizations;\\n    bool private mutex = false;\\n\\n    event ExitQueueAdded(\\n        uint256 vaultId,\\n        address token\\n    );\\n\\n    event ProcessedExitsNum(\\n        uint256 processedNum,\\n        uint256 vaultId,\\n        address token\\n    );\\n\\n    event ExitQueued(\\n        uint160 indexed exitId,\\n        uint256 priority\\n    );\\n\\n    constructor(uint256 _minExitPeriod, uint256 _initialImmuneExitGames)\\n        public\\n        ExitGameRegistry(_minExitPeriod, _initialImmuneExitGames)\\n    {\\n    }\\n\\n    /**\\n     * @dev Prevents reentrant calls by using a mutex.\\n     */\\n    modifier nonReentrant() {\\n        require(!mutex, \\\"Reentrant call\\\");\\n        mutex = true;\\n        _;\\n        assert(mutex);\\n        mutex = false;\\n    }\\n\\n    /**\\n     * @notice Activates non reentrancy mode\\n     *         Guards against reentering into publicly accessible code that modifies state related to exits\\n     * @dev Accessible only from non quarantined exit games, uses a mutex\\n     */\\n    function activateNonReentrant() external onlyFromNonQuarantinedExitGame() {\\n        require(!mutex, \\\"Reentrant call\\\");\\n        mutex = true;\\n    }\\n\\n    /**\\n     * @notice Deactivates non reentrancy mode\\n     * @dev Accessible only from non quarantined exit games, uses a mutex\\n     */\\n    function deactivateNonReentrant() external onlyFromNonQuarantinedExitGame() {\\n        assert(mutex);\\n        mutex = false;\\n    }\\n\\n    /**\\n     * @notice Checks if the queue for a specified token was created\\n     * @param vaultId ID of the vault that handles the token\\n     * @param token Address of the token\\n     * @return bool Defines whether the queue for a token was created\\n     */\\n    function hasExitQueue(uint256 vaultId, address token) public view returns (bool) {\\n        bytes32 key = exitQueueKey(vaultId, token);\\n        return hasExitQueue(key);\\n    }\\n\\n    /**\\n     * @notice Adds queue to the Plasma framework\\n     * @dev The queue is created as a new contract instance\\n     * @param vaultId ID of the vault\\n     * @param token Address of the token\\n     */\\n    function addExitQueue(uint256 vaultId, address token) external {\\n        require(vaultId != 0, \\\"Vault ID must not be 0\\\");\\n        bytes32 key = exitQueueKey(vaultId, token);\\n        require(!hasExitQueue(key), \\\"Exit queue exists\\\");\\n        exitsQueues[key] = new PriorityQueue();\\n        emit ExitQueueAdded(vaultId, token);\\n    }\\n\\n    /**\\n     * @notice Enqueue exits from exit game contracts is a function that places the exit into the\\n     *         priority queue to enforce the priority of exit during 'processExits'\\n     * @dev emits ExitQueued event, which can be used to back trace the priority inside the queue\\n     * @dev Caller of this function should add \\\"pragma experimental ABIEncoderV2;\\\" on top of file\\n     * @dev Priority (exitableAt, txPos, exitId) must be unique per queue. Do not enqueue when the same priority is already in the queue.\\n     * @param vaultId Vault ID of the vault that stores exiting funds\\n     * @param token Token for the exit\\n     * @param exitableAt The earliest time a specified exit can be processed\\n     * @param txPos Transaction position for the exit priority. For SE it should be the exit tx, for IFE it should be the youngest input tx position.\\n     * @param exitId ID used by the exit processor contract to determine how to process the exit\\n     * @param exitProcessor The exit processor contract, called during \\\"processExits\\\"\\n     * @return A unique priority number computed for the exit\\n     */\\n    function enqueue(\\n        uint256 vaultId,\\n        address token,\\n        uint64 exitableAt,\\n        PosLib.Position calldata txPos,\\n        uint160 exitId,\\n        IExitProcessor exitProcessor\\n    )\\n        external\\n        onlyFromNonQuarantinedExitGame\\n        returns (uint256)\\n    {\\n        bytes32 key = exitQueueKey(vaultId, token);\\n        require(hasExitQueue(key), \\\"The queue for the (vaultId, token) pair is not yet added to the Plasma framework\\\");\\n        PriorityQueue queue = exitsQueues[key];\\n\\n        uint256 priority = ExitPriority.computePriority(exitableAt, txPos, exitId);\\n\\n        queue.insert(priority);\\n\\n        bytes32 delegationKey = getDelegationKey(priority, vaultId, token);\\n        require(address(delegations[delegationKey]) == address(0), \\\"The same priority is already enqueued\\\");\\n        delegations[delegationKey] = exitProcessor;\\n\\n        emit ExitQueued(exitId, priority);\\n        return priority;\\n    }\\n\\n    /**\\n     * @notice Processes any exits that have completed the challenge period. Exits are processed according to the exit priority.\\n     * @dev Emits ProcessedExitsNum event\\n     * @param vaultId Vault ID of the vault that stores exiting funds\\n     * @param token The token type to process\\n     * @param topExitId Unique identifier for prioritizing the first exit to process. Set to zero to skip this check.\\n     * @param maxExitsToProcess Maximum number of exits to process\\n     * @return Total number of processed exits\\n     */\\n    function processExits(uint256 vaultId, address token, uint160 topExitId, uint256 maxExitsToProcess) external nonReentrant {\\n        bytes32 key = exitQueueKey(vaultId, token);\\n        require(hasExitQueue(key), \\\"The token is not yet added to the Plasma framework\\\");\\n        PriorityQueue queue = exitsQueues[key];\\n        require(queue.currentSize() > 0, \\\"Exit queue is empty\\\");\\n\\n        uint256 uniquePriority = queue.getMin();\\n        uint160 exitId = ExitPriority.parseExitId(uniquePriority);\\n        require(topExitId == 0 || exitId == topExitId,\\n            \\\"Top exit ID of the queue is different to the one specified\\\");\\n\\n        bytes32 delegationKey = getDelegationKey(uniquePriority, vaultId, token);\\n        IExitProcessor processor = delegations[delegationKey];\\n        uint256 processedNum = 0;\\n\\n        while (processedNum < maxExitsToProcess && ExitPriority.parseExitableAt(uniquePriority) < block.timestamp) {\\n            delete delegations[delegationKey];\\n            queue.delMin();\\n            processedNum++;\\n\\n            processor.processExit(exitId, vaultId, token);\\n\\n            if (queue.currentSize() == 0) {\\n                break;\\n            }\\n\\n            uniquePriority = queue.getMin();\\n            delegationKey = getDelegationKey(uniquePriority, vaultId, token);\\n            exitId = ExitPriority.parseExitId(uniquePriority);\\n            processor = delegations[delegationKey];\\n        }\\n\\n        emit ProcessedExitsNum(processedNum, vaultId, token);\\n    }\\n\\n    /**\\n     * @notice Checks whether any of the output with the given outputIds is already spent\\n     * @param _outputIds Output IDs to check\\n     */\\n    function isAnyInputFinalizedByOtherExit(bytes32[] calldata _outputIds, uint160 exitId) external view returns (bool) {\\n        for (uint i = 0; i < _outputIds.length; i++) {\\n            uint160 finalizedExitId = outputsFinalizations[_outputIds[i]];\\n            if (finalizedExitId != 0 && finalizedExitId != exitId) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Batch flags already spent outputs (only not already spent)\\n     * @param outputIds Output IDs to flag\\n     */\\n    function batchFlagOutputsFinalized(bytes32[] calldata outputIds, uint160 exitId) external onlyFromNonQuarantinedExitGame {\\n        for (uint i = 0; i < outputIds.length; i++) {\\n            require(outputIds[i] != bytes32(\\\"\\\"), \\\"Should not flag with empty outputId\\\");\\n            if (outputsFinalizations[outputIds[i]] == 0) {\\n                outputsFinalizations[outputIds[i]] = exitId;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Flags a single output as spent if it is not flagged already\\n     * @param outputId The output ID to flag as spent\\n     */\\n    function flagOutputFinalized(bytes32 outputId, uint160 exitId) external onlyFromNonQuarantinedExitGame {\\n        require(outputId != bytes32(\\\"\\\"), \\\"Should not flag with empty outputId\\\");\\n        if (outputsFinalizations[outputId] == 0) {\\n            outputsFinalizations[outputId] = exitId;\\n        }\\n    }\\n\\n     /**\\n     * @notice Checks whether output with a given outputId is finalized\\n     * @param outputId Output ID to check\\n     */\\n    function isOutputFinalized(bytes32 outputId) external view returns (bool) {\\n        return outputsFinalizations[outputId] != 0;\\n    }\\n\\n    function getNextExit(uint256 vaultId, address token) external view returns (uint256) {\\n        bytes32 key = exitQueueKey(vaultId, token);\\n        return exitsQueues[key].getMin();\\n    }\\n\\n    function exitQueueKey(uint256 vaultId, address token) private pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(vaultId, token));\\n    }\\n\\n    function hasExitQueue(bytes32 queueKey) private view returns (bool) {\\n        return address(exitsQueues[queueKey]) != address(0);\\n    }\\n\\n    function getDelegationKey(uint256 priority, uint256 vaultId, address token) private pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(priority, vaultId, token));\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/jake/plasma-contracts/plasma_framework/contracts/src/framework/PlasmaFramework.sol\": {\r\n      \"content\": \"pragma solidity 0.5.11;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./BlockController.sol\\\";\\nimport \\\"./ExitGameController.sol\\\";\\nimport \\\"./registries/VaultRegistry.sol\\\";\\nimport \\\"./registries/ExitGameRegistry.sol\\\";\\n\\ncontract PlasmaFramework is VaultRegistry, ExitGameRegistry, ExitGameController, BlockController {\\n    uint256 public constant CHILD_BLOCK_INTERVAL = 1000;\\n\\n    /**\\n     * The minimum finalization period is the Plasma guarantee that all exits are safe provided the user takes action within the specified time period\\n     * When the child chain is rogue, user should start their exit and challenge any invalid exit within this period\\n     * An exit can be processed/finalized after minimum two finalization periods from its inclusion position, unless it is an exit for a deposit,\\n     * which would use one finalization period, instead of two\\n     *\\n     * For the Abstract Layer Design, OmiseGO also uses some multitude of this period to update its framework\\n     * See also ExitGameRegistry.sol, VaultRegistry.sol, and Vault.sol for more information on the update waiting time (the quarantined period)\\n     *\\n     * MVP: https://ethresear.ch/t/minimal-viable-plasma/426\\n     * MoreVP: https://github.com/omisego/elixir-omg/blob/master/docs/morevp.md#timeline\\n     * Special period for deposit: https://git.io/JecCV\\n     */\\n    uint256 public minExitPeriod;\\n    address private maintainer;\\n    string public version;\\n\\n    constructor(\\n        uint256 _minExitPeriod,\\n        uint256 _initialImmuneVaults,\\n        uint256 _initialImmuneExitGames,\\n        address _authority,\\n        address _maintainer\\n    )\\n        public\\n        BlockController(CHILD_BLOCK_INTERVAL, _minExitPeriod, _initialImmuneVaults, _authority)\\n        ExitGameController(_minExitPeriod, _initialImmuneExitGames)\\n    {\\n        minExitPeriod = _minExitPeriod;\\n        maintainer = _maintainer;\\n    }\\n\\n    function getMaintainer() public view returns (address) {\\n        return maintainer;\\n    }\\n\\n    /**\\n     * @notice Gets the semantic version of the current deployed contracts\\n    */\\n    function getVersion() external view returns (string memory) {\\n        return version;\\n    }\\n    \\n    /**\\n     * @notice Sets the semantic version of the current deployed contracts\\n     * @param _version is semver string\\n     */\\n    function setVersion(string memory _version) public onlyFrom(getMaintainer()) {\\n        version = _version;\\n    }\\n}\"\r\n    },\r\n    \"/Users/jake/plasma-contracts/plasma_framework/contracts/src/framework/Protocol.sol\": {\r\n      \"content\": \"pragma solidity 0.5.11;\\n\\n/**\\n * @notice Protocols for the PlasmaFramework\\n */\\nlibrary Protocol {\\n    uint8 constant internal MVP_VALUE = 1;\\n    uint8 constant internal MORE_VP_VALUE = 2;\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function MVP() internal pure returns (uint8) {\\n        return MVP_VALUE;\\n    }\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function MORE_VP() internal pure returns (uint8) {\\n        return MORE_VP_VALUE;\\n    }\\n\\n    function isValidProtocol(uint8 protocol) internal pure returns (bool) {\\n        return protocol == MVP_VALUE || protocol == MORE_VP_VALUE;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/jake/plasma-contracts/plasma_framework/contracts/src/framework/interfaces/IExitProcessor.sol\": {\r\n      \"content\": \"pragma solidity 0.5.11;\\n\\n/**\\n * @dev An interface that allows custom logic to process exits for different requirements.\\n *      This interface is used to dispatch to each custom processor when 'processExits' is called on PlasmaFramework.\\n */\\ninterface IExitProcessor {\\n    /**\\n     * @dev Function interface for processing exits.\\n     * @param exitId Unique ID for exit per tx type\\n     * @param vaultId ID of the vault that funds the exit\\n     * @param token Address of the token contract\\n     */\\n    function processExit(uint160 exitId, uint256 vaultId, address token) external;\\n}\\n\"\r\n    },\r\n    \"/Users/jake/plasma-contracts/plasma_framework/contracts/src/framework/models/BlockModel.sol\": {\r\n      \"content\": \"pragma solidity 0.5.11;\\n\\nlibrary BlockModel {\\n    /**\\n     * @notice Block data structure that is stored in the contract\\n     * @param root The Merkle root block hash of the Plasma blocks\\n     * @param timestamp The timestamp, in seconds, when the block is saved\\n     */\\n    struct Block {\\n        bytes32 root;\\n        uint256 timestamp;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/jake/plasma-contracts/plasma_framework/contracts/src/framework/registries/ExitGameRegistry.sol\": {\r\n      \"content\": \"pragma solidity 0.5.11;\\n\\nimport \\\"openzeppelin-solidity/contracts/utils/Address.sol\\\";\\n\\nimport \\\"../Protocol.sol\\\";\\nimport \\\"../utils/Quarantine.sol\\\";\\nimport \\\"../../utils/OnlyFromAddress.sol\\\";\\n\\ncontract ExitGameRegistry is OnlyFromAddress {\\n    using Quarantine for Quarantine.Data;\\n\\n    mapping(uint256 => address) private _exitGames; // txType => exit game contract address\\n    mapping(address => uint256) private _exitGameToTxType; // exit game contract address => tx type\\n    mapping(uint256 => uint8) private _protocols; // tx type => protocol (MVP/MORE_VP)\\n    Quarantine.Data private _exitGameQuarantine;\\n\\n    event ExitGameRegistered(\\n        uint256 txType,\\n        address exitGameAddress,\\n        uint8 protocol\\n    );\\n\\n    /**\\n     * @dev It takes at least 3 * minExitPeriod before each new exit game contract is able to start protecting existing transactions\\n     *      see: https://github.com/omisego/plasma-contracts/issues/172\\n     *           https://github.com/omisego/plasma-contracts/issues/197\\n     */\\n    constructor (uint256 _minExitPeriod, uint256 _initialImmuneExitGames)\\n        public\\n    {\\n        _exitGameQuarantine.quarantinePeriod = 4 * _minExitPeriod;\\n        _exitGameQuarantine.immunitiesRemaining = _initialImmuneExitGames;\\n    }\\n\\n    /**\\n     * @notice A modifier to verify that the call is from a non-quarantined exit game\\n     */\\n    modifier onlyFromNonQuarantinedExitGame() {\\n        require(_exitGameToTxType[msg.sender] != 0, \\\"The call is not from a registered exit game contract\\\");\\n        require(!_exitGameQuarantine.isQuarantined(msg.sender), \\\"ExitGame is quarantined\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice interface to get the 'maintainer' address.\\n     * @dev see discussion here: https://git.io/Je8is\\n     */\\n    function getMaintainer() public view returns (address);\\n\\n    /**\\n     * @notice Checks whether the contract is safe to use and is not under quarantine\\n     * @dev Exposes information about exit games quarantine\\n     * @param _contract Address of the exit game contract\\n     * @return boolean Whether the contract is safe to use and is not under quarantine\\n     */\\n    function isExitGameSafeToUse(address _contract) public view returns (bool) {\\n        return _exitGameToTxType[_contract] != 0 && !_exitGameQuarantine.isQuarantined(_contract);\\n    }\\n\\n    /**\\n     * @notice Registers an exit game within the PlasmaFramework. Only the maintainer can call the function.\\n     * @dev Emits ExitGameRegistered event to notify clients\\n     * @param _txType The tx type where the exit game wants to register\\n     * @param _contract Address of the exit game contract\\n     * @param _protocol The transaction protocol, either 1 for MVP or 2 for MoreVP\\n     */\\n    function registerExitGame(uint256 _txType, address _contract, uint8 _protocol) public onlyFrom(getMaintainer()) {\\n        require(_txType != 0, \\\"Should not register with tx type 0\\\");\\n        require(Address.isContract(_contract), \\\"Should not register with a non-contract address\\\");\\n        require(_exitGames[_txType] == address(0), \\\"The tx type is already registered\\\");\\n        require(_exitGameToTxType[_contract] == 0, \\\"The exit game contract is already registered\\\");\\n        require(Protocol.isValidProtocol(_protocol), \\\"Invalid protocol value\\\");\\n\\n        _exitGames[_txType] = _contract;\\n        _exitGameToTxType[_contract] = _txType;\\n        _protocols[_txType] = _protocol;\\n        _exitGameQuarantine.quarantine(_contract);\\n\\n        emit ExitGameRegistered(_txType, _contract, _protocol);\\n    }\\n\\n    /**\\n     * @notice Public getter for retrieving protocol with tx type\\n     */\\n    function protocols(uint256 _txType) public view returns (uint8) {\\n        return _protocols[_txType];\\n    }\\n\\n    /**\\n     * @notice Public getter for retrieving exit game address with tx type\\n     */\\n    function exitGames(uint256 _txType) public view returns (address) {\\n        return _exitGames[_txType];\\n    }\\n\\n    /**\\n     * @notice Public getter for retrieving tx type with exit game address\\n     */\\n    function exitGameToTxType(address _exitGame) public view returns (uint256) {\\n        return _exitGameToTxType[_exitGame];\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/jake/plasma-contracts/plasma_framework/contracts/src/framework/registries/VaultRegistry.sol\": {\r\n      \"content\": \"pragma solidity 0.5.11;\\n\\nimport \\\"openzeppelin-solidity/contracts/utils/Address.sol\\\";\\n\\nimport \\\"../utils/Quarantine.sol\\\";\\nimport \\\"../../utils/OnlyFromAddress.sol\\\";\\n\\ncontract VaultRegistry is OnlyFromAddress {\\n    using Quarantine for Quarantine.Data;\\n\\n    mapping(uint256 => address) private _vaults; // vault id => vault address\\n    mapping(address => uint256) private _vaultToId; // vault address => vault id\\n    Quarantine.Data private _vaultQuarantine;\\n\\n    event VaultRegistered(\\n        uint256 vaultId,\\n        address vaultAddress\\n    );\\n\\n    /**\\n     * @dev It takes at least 2 minExitPeriod for each new vault contract to start.\\n     *      This is to protect deposit transactions already in mempool,\\n     *      and also make sure user only needs to SE within first week when invalid vault is registered.\\n     *      see: https://github.com/omisego/plasma-contracts/issues/412\\n     *           https://github.com/omisego/plasma-contracts/issues/173\\n     */\\n    constructor(uint256 _minExitPeriod, uint256 _initialImmuneVaults)\\n        public\\n    {\\n        _vaultQuarantine.quarantinePeriod = 2 * _minExitPeriod;\\n        _vaultQuarantine.immunitiesRemaining = _initialImmuneVaults;\\n    }\\n\\n    /**\\n     * @notice interface to get the 'maintainer' address.\\n     * @dev see discussion here: https://git.io/Je8is\\n     */\\n    function getMaintainer() public view returns (address);\\n\\n    /**\\n     * @notice A modifier to check that the call is from a non-quarantined vault\\n     */\\n    modifier onlyFromNonQuarantinedVault() {\\n        require(_vaultToId[msg.sender] > 0, \\\"The call is not from a registered vault\\\");\\n        require(!_vaultQuarantine.isQuarantined(msg.sender), \\\"Vault is quarantined\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Register a vault within the PlasmaFramework. Only a maintainer can make the call.\\n     * @dev emits VaultRegistered event to notify clients\\n     * @param _vaultId The ID for the vault contract to register\\n     * @param _vaultAddress Address of the vault contract\\n     */\\n    function registerVault(uint256 _vaultId, address _vaultAddress) public onlyFrom(getMaintainer()) {\\n        require(_vaultId != 0, \\\"Should not register with vault ID 0\\\");\\n        require(Address.isContract(_vaultAddress), \\\"Should not register with a non-contract address\\\");\\n        require(_vaults[_vaultId] == address(0), \\\"The vault ID is already registered\\\");\\n        require(_vaultToId[_vaultAddress] == 0, \\\"The vault contract is already registered\\\");\\n\\n        _vaults[_vaultId] = _vaultAddress;\\n        _vaultToId[_vaultAddress] = _vaultId;\\n        _vaultQuarantine.quarantine(_vaultAddress);\\n\\n        emit VaultRegistered(_vaultId, _vaultAddress);\\n    }\\n\\n    /**\\n     * @notice Public getter for retrieving vault address with vault ID\\n     */\\n    function vaults(uint256 _vaultId) public view returns (address) {\\n        return _vaults[_vaultId];\\n    }\\n\\n    /**\\n     * @notice Public getter for retrieving vault ID with vault address\\n     */\\n    function vaultToId(address _vaultAddress) public view returns (uint256) {\\n        return _vaultToId[_vaultAddress];\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/jake/plasma-contracts/plasma_framework/contracts/src/framework/utils/ExitPriority.sol\": {\r\n      \"content\": \"pragma solidity 0.5.11;\\n\\nimport \\\"../../utils/PosLib.sol\\\";\\n\\nlibrary ExitPriority {\\n\\n    using PosLib for PosLib.Position;\\n\\n    /**\\n     * @dev Returns an exit priority for a given UTXO position and a unique ID.\\n     * The priority for Plasma M(ore)VP protocol is a combination of 'exitableAt' and 'txPos'.\\n     * Since 'exitableAt' only provides granularity of block, add 'txPos' to provide priority for a transaction.\\n     * @notice Detailed explanation on field lengths can be found at https://github.com/omisego/plasma-contracts/pull/303#discussion_r328850572\\n     * @param exitId Unique exit identifier\\n     * @return An exit priority\\n     *   Anatomy of returned value, most significant bits first\\n     *   42 bits  - timestamp in seconds (exitable_at); we can represent dates until year 141431\\n     *   54 bits  - blocknum * 10^5 + txindex; 54 bits represent all transactions for 85 years. Be aware that child chain block number jumps with the interval of CHILD_BLOCK_INTERVAL, which would be 1000 in production.\\n     *   160 bits - exit id\\n     */\\n    function computePriority(uint64 exitableAt, PosLib.Position memory txPos, uint160 exitId)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return (uint256(exitableAt) << 214) | (txPos.getTxPositionForExitPriority() << 160) | uint256(exitId);\\n    }\\n\\n    function parseExitableAt(uint256 priority) internal pure returns (uint64) {\\n        return uint64(priority >> 214);\\n    }\\n\\n    function parseExitId(uint256 priority) internal pure returns (uint160) {\\n        // Exit ID uses only 160 least significant bits\\n        return uint160(priority);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/jake/plasma-contracts/plasma_framework/contracts/src/framework/utils/PriorityQueue.sol\": {\r\n      \"content\": \"pragma solidity 0.5.11;\\n\\nimport \\\"../../utils/OnlyFromAddress.sol\\\";\\n\\nimport \\\"openzeppelin-solidity/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n * @title PriorityQueue\\n * @dev Min-heap priority queue implementation\\n */\\ncontract PriorityQueue is OnlyFromAddress {\\n    using SafeMath for uint256;\\n\\n    struct Queue {\\n        uint256[] heapList;\\n        uint256 currentSize;\\n    }\\n\\n    Queue public queue;\\n    address public framework;\\n\\n    constructor() public {\\n        queue.heapList = [0];\\n        queue.currentSize = 0;\\n\\n        // it is expected that this should be called by PlasmaFramework\\n        // and only PlasmaFramework contract can add things to the queue\\n        framework = msg.sender;\\n    }\\n\\n    /**\\n     * @notice Gets num of elements in the queue\\n     */\\n    function currentSize() external view returns (uint256) {\\n        return queue.currentSize;\\n    }\\n\\n    /**\\n     * @notice Gets all elements in the queue\\n     */\\n    function heapList() external view returns (uint256[] memory) {\\n        return queue.heapList;\\n    }\\n\\n    /**\\n     * @notice Inserts an element into the queue by the framework\\n     * @dev Does not perform deduplication\\n     */\\n    function insert(uint256 _element) external onlyFrom(framework) {\\n        queue.heapList.push(_element);\\n        queue.currentSize = queue.currentSize.add(1);\\n        percUp(queue, queue.currentSize);\\n    }\\n\\n    /**\\n     * @notice Deletes the smallest element from the queue by the framework\\n     * @dev Fails when queue is empty\\n     * @return The smallest element in the priority queue\\n     */\\n    function delMin() external onlyFrom(framework) returns (uint256) {\\n        require(queue.currentSize > 0, \\\"Queue is empty\\\");\\n        uint256 retVal = queue.heapList[1];\\n        queue.heapList[1] = queue.heapList[queue.currentSize];\\n        delete queue.heapList[queue.currentSize];\\n        queue.currentSize = queue.currentSize.sub(1);\\n        percDown(queue, 1);\\n        queue.heapList.length = queue.heapList.length.sub(1);\\n        return retVal;\\n    }\\n\\n    /**\\n     * @notice Returns the smallest element from the queue\\n     * @dev Fails when queue is empty\\n     * @return The smallest element in the priority queue\\n     */\\n    function getMin() external view returns (uint256) {\\n        require(queue.currentSize > 0, \\\"Queue is empty\\\");\\n        return queue.heapList[1];\\n    }\\n\\n    function percUp(Queue storage self, uint256 pointer) private {\\n        uint256 i = pointer;\\n        uint256 j = i;\\n        uint256 newVal = self.heapList[i];\\n        while (newVal < self.heapList[i.div(2)]) {\\n            self.heapList[i] = self.heapList[i.div(2)];\\n            i = i.div(2);\\n        }\\n        if (i != j) {\\n            self.heapList[i] = newVal;\\n        }\\n    }\\n\\n    function percDown(Queue storage self, uint256 pointer) private {\\n        uint256 i = pointer;\\n        uint256 j = i;\\n        uint256 newVal = self.heapList[i];\\n        uint256 mc = minChild(self, i);\\n        while (mc <= self.currentSize && newVal > self.heapList[mc]) {\\n            self.heapList[i] = self.heapList[mc];\\n            i = mc;\\n            mc = minChild(self, i);\\n        }\\n        if (i != j) {\\n            self.heapList[i] = newVal;\\n        }\\n    }\\n\\n    function minChild(Queue storage self, uint256 i) private view returns (uint256) {\\n        if (i.mul(2).add(1) > self.currentSize) {\\n            return i.mul(2);\\n        } else {\\n            if (self.heapList[i.mul(2)] < self.heapList[i.mul(2).add(1)]) {\\n                return i.mul(2);\\n            } else {\\n                return i.mul(2).add(1);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/jake/plasma-contracts/plasma_framework/contracts/src/framework/utils/Quarantine.sol\": {\r\n      \"content\": \"pragma solidity 0.5.11;\\n\\n/**\\n * @notice Provides a way to quarantine (disable) contracts for a specified period of time\\n * @dev The immunitiesRemaining member allows deployment to the platform with some\\n * pre-verified contracts that don't get quarantined\\n */\\nlibrary Quarantine {\\n    struct Data {\\n        mapping(address => uint256) store;\\n        uint256 quarantinePeriod;\\n        uint256 immunitiesRemaining;\\n    }\\n\\n    /**\\n     * @notice Checks whether a contract is quarantined\\n     */\\n    function isQuarantined(Data storage _self, address _contractAddress) internal view returns (bool) {\\n        return block.timestamp < _self.store[_contractAddress];\\n    }\\n\\n    /**\\n     * @notice Places a contract into quarantine\\n     * @param _contractAddress The address of the contract\\n     */\\n    function quarantine(Data storage _self, address _contractAddress) internal {\\n        require(_contractAddress != address(0), \\\"An empty address cannot be quarantined\\\");\\n        require(_self.store[_contractAddress] == 0, \\\"The contract is already quarantined\\\");\\n\\n        if (_self.immunitiesRemaining == 0) {\\n            _self.store[_contractAddress] = block.timestamp + _self.quarantinePeriod;\\n        } else {\\n            _self.immunitiesRemaining--;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/jake/plasma-contracts/plasma_framework/contracts/src/utils/OnlyFromAddress.sol\": {\r\n      \"content\": \"pragma solidity 0.5.11;\\n\\ncontract OnlyFromAddress {\\n\\n    modifier onlyFrom(address caller) {\\n        require(msg.sender == caller, \\\"Caller address is unauthorized\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/jake/plasma-contracts/plasma_framework/contracts/src/utils/PosLib.sol\": {\r\n      \"content\": \"pragma solidity 0.5.11;\\n\\nimport \\\"openzeppelin-solidity/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n * @dev UTXO position = (blknum * BLOCK_OFFSET + txIndex * TX_OFFSET + outputIndex).\\n * TX position = (blknum * BLOCK_OFFSET + txIndex * TX_OFFSET)\\n */\\nlibrary PosLib {\\n    struct Position {\\n        uint64 blockNum;\\n        uint16 txIndex;\\n        uint16 outputIndex;\\n    }\\n\\n    uint256 constant internal BLOCK_OFFSET = 1000000000;\\n    uint256 constant internal TX_OFFSET = 10000;\\n    \\n    uint256 constant internal MAX_OUTPUT_INDEX = TX_OFFSET - 1;\\n    // since we are using merkle tree of depth 16, max tx index size is 2^16 - 1\\n    uint256 constant internal MAX_TX_INDEX = 2 ** 16 - 1;\\n    // in ExitPriority, only 54 bits are reserved for both blockNum and txIndex\\n    uint256 constant internal MAX_BLOCK_NUM = ((2 ** 54 - 1) - MAX_TX_INDEX) / (BLOCK_OFFSET / TX_OFFSET);\\n\\n    /**\\n     * @notice Returns transaction position which is an utxo position of zero index output\\n     * @param pos UTXO position of the output\\n     * @return Position of a transaction\\n     */\\n    function toStrictTxPos(Position memory pos)\\n        internal\\n        pure\\n        returns (Position memory)\\n    {\\n        return Position(pos.blockNum, pos.txIndex, 0);\\n    }\\n\\n    /**\\n     * @notice Used for calculating exit priority\\n     * @param pos UTXO position for the output\\n     * @return Identifier of the transaction\\n     */\\n    function getTxPositionForExitPriority(Position memory pos)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return encode(pos) / TX_OFFSET;\\n    }\\n\\n    /**\\n     * @notice Encodes a position\\n     * @param pos Position\\n     * @return Position encoded as an integer\\n     */\\n    function encode(Position memory pos) internal pure returns (uint256) {\\n        require(pos.outputIndex <= MAX_OUTPUT_INDEX, \\\"Invalid output index\\\");\\n        require(pos.blockNum <= MAX_BLOCK_NUM, \\\"Invalid block number\\\");\\n\\n        return pos.blockNum * BLOCK_OFFSET + pos.txIndex * TX_OFFSET + pos.outputIndex;\\n    }\\n\\n    /**\\n     * @notice Decodes a position from an integer value\\n     * @param pos Encoded position\\n     * @return Position\\n     */\\n    function decode(uint256 pos) internal pure returns (Position memory) {\\n        uint256 blockNum = pos / BLOCK_OFFSET;\\n        uint256 txIndex = (pos % BLOCK_OFFSET) / TX_OFFSET;\\n        uint16 outputIndex = uint16(pos % TX_OFFSET);\\n\\n        require(blockNum <= MAX_BLOCK_NUM, \\\"blockNum exceeds max size allowed in PlasmaFramework\\\");\\n        require(txIndex <= MAX_TX_INDEX, \\\"txIndex exceeds the size of uint16\\\");\\n        return Position(uint64(blockNum), uint16(txIndex), outputIndex);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/jake/plasma-contracts/plasma_framework/contracts/src/vaults/Vault.sol\": {\r\n      \"content\": \"pragma solidity 0.5.11;\\n\\nimport \\\"../framework/PlasmaFramework.sol\\\";\\nimport \\\"../utils/OnlyFromAddress.sol\\\";\\n\\n/**\\n * @notice Base contract for vault implementation\\n * @dev This is the functionality to swap \\\"deposit verifier\\\"\\n *      Setting a new deposit verifier allows an upgrade to a new deposit tx type without upgrading the vault\\n */\\ncontract Vault is OnlyFromAddress {\\n\\n    byte private constant LEAF_SALT = 0x00;\\n    byte private constant NODE_SALT = 0x01;\\n\\n    event SetDepositVerifierCalled(address nextDepositVerifier);\\n    PlasmaFramework internal framework;\\n    bytes32[16] internal zeroHashes; // Pre-computes zero hashes to be used for building merkle tree for deposit block\\n\\n    /**\\n     * @notice Stores deposit verifier contract addresses; first contract address is effective until the\\n     *  `newDepositVerifierMaturityTimestamp`; second contract address becomes effective after that timestamp\\n    */\\n    address[2] public depositVerifiers;\\n    uint256 public newDepositVerifierMaturityTimestamp = 2 ** 255; // point far in the future\\n\\n    constructor(PlasmaFramework _framework) public {\\n        framework = _framework;\\n        zeroHashes = getZeroHashes();\\n    }\\n\\n    /**\\n     * @dev Pre-computes zero hashes to be used for building Merkle tree for deposit block\\n     */\\n    function getZeroHashes() private pure returns (bytes32[16] memory) {\\n        bytes32[16] memory hashes;\\n        bytes32 zeroHash = keccak256(abi.encodePacked(LEAF_SALT, uint256(0)));\\n        for (uint i = 0; i < 16; i++) {\\n            hashes[i] = zeroHash;\\n            zeroHash = keccak256(abi.encodePacked(NODE_SALT, zeroHash, zeroHash));\\n        }\\n        return hashes;\\n    }\\n\\n    /**\\n     * @notice Checks whether the call originates from a non-quarantined exit game contract\\n    */\\n    modifier onlyFromNonQuarantinedExitGame() {\\n        require(\\n            ExitGameRegistry(framework).isExitGameSafeToUse(msg.sender),\\n            \\\"Called from a non-registered or quarantined exit game contract\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @notice Sets the deposit verifier contract, which may be called only by the operator\\n     * @dev emit SetDepositVerifierCalled\\n     * @dev When one contract is already set, the next one is effective after 2 * MIN_EXIT_PERIOD.\\n     *      This is to protect deposit transactions already in mempool,\\n     *      and also make sure user only needs to SE within first week when invalid vault is registered.\\n     *\\n     *      see: https://github.com/omisego/plasma-contracts/issues/412\\n     *           https://github.com/omisego/plasma-contracts/issues/173\\n     *\\n     * @param _verifier Address of the verifier contract\\n     */\\n    function setDepositVerifier(address _verifier) public onlyFrom(framework.getMaintainer()) {\\n        require(_verifier != address(0), \\\"Cannot set an empty address as deposit verifier\\\");\\n\\n        if (depositVerifiers[0] != address(0)) {\\n            depositVerifiers[0] = getEffectiveDepositVerifier();\\n            depositVerifiers[1] = _verifier;\\n            newDepositVerifierMaturityTimestamp = now + 2 * framework.minExitPeriod();\\n        } else {\\n            depositVerifiers[0] = _verifier;\\n        }\\n\\n        emit SetDepositVerifierCalled(_verifier);\\n    }\\n\\n    /**\\n     * @notice Retrieves the currently effective deposit verifier contract address\\n     * @return Contract address of the deposit verifier\\n     */\\n    function getEffectiveDepositVerifier() public view returns (address) {\\n        if (now < newDepositVerifierMaturityTimestamp) {\\n            return depositVerifiers[0];\\n        } else {\\n            return depositVerifiers[1];\\n        }\\n    }\\n\\n    /**\\n     * @notice Generate and submit a deposit block root to the PlasmaFramework\\n     * @dev Designed to be called by the contract that inherits Vault\\n     */\\n    function submitDepositBlock(bytes memory depositTx) internal returns (uint256) {\\n        bytes32 root = getDepositBlockRoot(depositTx);\\n\\n        uint256 depositBlkNum = framework.submitDepositBlock(root);\\n        return depositBlkNum;\\n    }\\n\\n    function getDepositBlockRoot(bytes memory depositTx) private view returns (bytes32) {\\n        bytes32 root = keccak256(abi.encodePacked(LEAF_SALT, depositTx));\\n        for (uint i = 0; i < 16; i++) {\\n            root = keccak256(abi.encodePacked(NODE_SALT, root, zeroHashes[i]));\\n        }\\n        return root;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/jake/plasma-contracts/plasma_framework/contracts/src/vaults/verifiers/IErc20DepositVerifier.sol\": {\r\n      \"content\": \"pragma solidity 0.5.11;\\n\\ninterface IErc20DepositVerifier {\\n    /**\\n     * @notice Verifies a deposit transaction\\n     * @param depositTx The deposit transaction\\n     * @param sender The owner of the deposit transaction\\n     * @param vault The address of the Erc20Vault contract\\n     * @return Verified (owner, token, amount) of the deposit ERC20 token data\\n     */\\n    function verify(bytes calldata depositTx, address sender, address vault)\\n        external\\n        view\\n        returns (address owner, address token, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see `ERC20Detailed`.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\n     * zero by default.\\n     *\\n     * This value changes when `approve` or `transferFrom` are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * > Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an `Approval` event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to `approve`. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Collection of functions related to the address type,\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\n     * execution of a contract's constructor, its address will be reported as\\n     * not containing a contract.\\n     *\\n     * > It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"depositVerifiers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_verifier\",\"type\":\"address\"}],\"name\":\"setDepositVerifier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEffectiveDepositVerifier\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"depositTx\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newDepositVerifierMaturityTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract PlasmaFramework\",\"name\":\"_framework\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Erc20Withdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blknum\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nextDepositVerifier\",\"type\":\"address\"}],\"name\":\"SetDepositVerifierCalled\",\"type\":\"event\"}]","ContractName":"Erc20Vault","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000d4c1222f5e839a911e2053860e45f18921d72ac","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}