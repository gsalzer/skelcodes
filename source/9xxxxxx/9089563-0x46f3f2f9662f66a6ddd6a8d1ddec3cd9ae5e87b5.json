{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/Math.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: contracts/EpochTokenLocker.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n/** @title Epoch Token Locker\r\n *  EpochTokenLocker saveguards tokens for applications with constant-balances during discrete epochs\r\n *  It allows to deposit a token which become credited in the next epoch and allows to request a token-withdraw\r\n *  which becomes claimable after the current epoch has expired.\r\n *  @author @gnosis/dfusion-team <https://github.com/orgs/gnosis/teams/dfusion-team/members>\r\n */\r\ncontract EpochTokenLocker {\r\n    using SafeMath for uint256;\r\n\r\n    /** @dev Number of seconds a batch is lasting*/\r\n    uint32 public constant BATCH_TIME = 300;\r\n\r\n    // User => Token => BalanceState\r\n    mapping(address => mapping(address => BalanceState)) private balanceStates;\r\n\r\n    // user => token => lastCreditBatchId\r\n    mapping(address => mapping(address => uint256)) public lastCreditBatchId;\r\n\r\n    struct BalanceState {\r\n        uint256 balance;\r\n        PendingFlux pendingDeposits; // deposits will be credited in any future epoch, i.e. currentStateIndex > batchId\r\n        PendingFlux pendingWithdraws; // withdraws are allowed in any future epoch, i.e. currentStateIndex > batchId\r\n    }\r\n\r\n    struct PendingFlux {\r\n        uint256 amount;\r\n        uint32 batchId;\r\n    }\r\n\r\n    event Deposit(address user, address token, uint256 amount, uint256 stateIndex);\r\n\r\n    event WithdrawRequest(address user, address token, uint256 amount, uint256 stateIndex);\r\n\r\n    event Withdraw(address user, address token, uint256 amount);\r\n\r\n    /** @dev credits user with deposit amount on next epoch (given by getCurrentBatchId)\r\n      * @param token address of token to be deposited\r\n      * @param amount number of token(s) to be credited to user's account\r\n      *\r\n      * Emits an {Deposit} event with relevent deposit information.\r\n      *\r\n      * Requirements:\r\n      * - token transfer to contract is successfull\r\n      */\r\n    function deposit(address token, uint256 amount) public {\r\n        updateDepositsBalance(msg.sender, token);\r\n        SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), amount);\r\n        // solhint-disable-next-line max-line-length\r\n        balanceStates[msg.sender][token].pendingDeposits.amount = balanceStates[msg.sender][token].pendingDeposits.amount.add(\r\n            amount\r\n        );\r\n        balanceStates[msg.sender][token].pendingDeposits.batchId = getCurrentBatchId();\r\n        emit Deposit(msg.sender, token, amount, getCurrentBatchId());\r\n    }\r\n\r\n    /** @dev Signals and initiates user's intent to withdraw.\r\n      * @param token address of token to be withdrawn\r\n      * @param amount number of token(s) to be withdrawn\r\n      *\r\n      * Emits an {WithdrawRequest} event with relevent request information.\r\n      */\r\n    function requestWithdraw(address token, uint256 amount) public {\r\n        requestFutureWithdraw(token, amount, getCurrentBatchId());\r\n    }\r\n\r\n    /** @dev Signals and initiates user's intent to withdraw.\r\n      * @param token address of token to be withdrawn\r\n      * @param amount number of token(s) to be withdrawn\r\n      * @param batchId state index at which request is to be made.\r\n      *\r\n      * Emits an {WithdrawRequest} event with relevent request information.\r\n      */\r\n    function requestFutureWithdraw(address token, uint256 amount, uint32 batchId) public {\r\n        // First process pendingWithdraw (if any), as otherwise balances might increase for currentBatchId - 1\r\n        if (hasValidWithdrawRequest(msg.sender, token)) {\r\n            withdraw(msg.sender, token);\r\n        }\r\n        require(batchId >= getCurrentBatchId(), \"Request cannot be made in the past\");\r\n        balanceStates[msg.sender][token].pendingWithdraws = PendingFlux({amount: amount, batchId: batchId});\r\n        emit WithdrawRequest(msg.sender, token, amount, batchId);\r\n    }\r\n\r\n    /** @dev Claims pending withdraw - can be called on behalf of others\r\n      * @param token address of token to be withdrawn\r\n      * @param user address of user who withdraw is being claimed.\r\n      *\r\n      * Emits an {Withdraw} event stating that `user` withdrew `amount` of `token`\r\n      *\r\n      * Requirements:\r\n      * - withdraw was requested in previous epoch\r\n      * - token was received from exchange in current auction batch\r\n      */\r\n    function withdraw(address user, address token) public {\r\n        updateDepositsBalance(user, token); // withdrawn amount may have been deposited in previous epoch\r\n        require(\r\n            balanceStates[user][token].pendingWithdraws.batchId < getCurrentBatchId(),\r\n            \"withdraw was not registered previously\"\r\n        );\r\n        require(\r\n            lastCreditBatchId[msg.sender][token] < getCurrentBatchId(),\r\n            \"Withdraw not possible for token that is traded in the current auction\"\r\n        );\r\n        uint256 amount = Math.min(balanceStates[user][token].balance, balanceStates[msg.sender][token].pendingWithdraws.amount);\r\n\r\n        balanceStates[user][token].balance = balanceStates[user][token].balance.sub(amount);\r\n        delete balanceStates[user][token].pendingWithdraws;\r\n\r\n        SafeERC20.safeTransfer(IERC20(token), user, amount);\r\n        emit Withdraw(user, token, amount);\r\n    }\r\n    /**\r\n     * Public view functions\r\n     */\r\n\r\n    /** @dev getter function used to display pending deposit\r\n      * @param user address of user\r\n      * @param token address of ERC20 token\r\n      * return amount and batchId of deposit's transfer if any (else 0)\r\n      */\r\n    function getPendingDeposit(address user, address token) public view returns (uint256, uint256) {\r\n        PendingFlux memory pendingDeposit = balanceStates[user][token].pendingDeposits;\r\n        return (pendingDeposit.amount, pendingDeposit.batchId);\r\n    }\r\n\r\n    /** @dev getter function used to display pending withdraw\r\n      * @param user address of user\r\n      * @param token address of ERC20 token\r\n      * return amount and batchId when withdraw was requested if any (else 0)\r\n      */\r\n    function getPendingWithdraw(address user, address token) public view returns (uint256, uint256) {\r\n        PendingFlux memory pendingWithdraw = balanceStates[user][token].pendingWithdraws;\r\n        return (pendingWithdraw.amount, pendingWithdraw.batchId);\r\n    }\r\n\r\n    /** @dev getter function to determine current auction id.\r\n      * return current batchId\r\n      */\r\n    function getCurrentBatchId() public view returns (uint32) {\r\n        return uint32(now / BATCH_TIME);\r\n    }\r\n\r\n    /** @dev used to determine how much time is left in a batch\r\n      * return seconds remaining in current batch\r\n      */\r\n    function getSecondsRemainingInBatch() public view returns (uint256) {\r\n        return BATCH_TIME - (now % BATCH_TIME);\r\n    }\r\n\r\n    /** @dev fetches and returns user's balance\r\n      * @param user address of user\r\n      * @param token address of ERC20 token\r\n      * return Current `token` balance of `user`'s account\r\n      */\r\n    function getBalance(address user, address token) public view returns (uint256) {\r\n        uint256 balance = balanceStates[user][token].balance;\r\n        if (balanceStates[user][token].pendingDeposits.batchId < getCurrentBatchId()) {\r\n            balance = balance.add(balanceStates[user][token].pendingDeposits.amount);\r\n        }\r\n        if (balanceStates[user][token].pendingWithdraws.batchId < getCurrentBatchId()) {\r\n            balance = balance.sub(Math.min(balanceStates[user][token].pendingWithdraws.amount, balance));\r\n        }\r\n        return balance;\r\n    }\r\n\r\n    /** @dev Used to determine if user has a valid pending withdraw request of specific token\r\n      * @param user address of user\r\n      * @param token address of ERC20 token\r\n      * return true if `user` has valid withdraw request for `token`, otherwise false\r\n      */\r\n    function hasValidWithdrawRequest(address user, address token) public view returns (bool) {\r\n        return\r\n            balanceStates[user][token].pendingWithdraws.batchId < getCurrentBatchId() &&\r\n            balanceStates[user][token].pendingWithdraws.batchId > 0;\r\n    }\r\n\r\n    /**\r\n     * internal functions\r\n     */\r\n    /**\r\n     * The following function should be used to update any balances within an epoch, which\r\n     * will not be immediately final. E.g. the BatchExchange credits new balances to\r\n     * the buyers in an auction, but as there are might be better solutions, the updates are\r\n     * not final. In order to prevent withdraws from non-final updates, we disallow withdraws\r\n     * by setting lastCreditBatchId to the current batchId and allow only withdraws in batches\r\n     * with a higher batchId.\r\n     */\r\n    function addBalanceAndBlockWithdrawForThisBatch(address user, address token, uint256 amount) internal {\r\n        if (hasValidWithdrawRequest(user, token)) {\r\n            lastCreditBatchId[user][token] = getCurrentBatchId();\r\n        }\r\n        addBalance(user, token, amount);\r\n    }\r\n\r\n    function addBalance(address user, address token, uint256 amount) internal {\r\n        updateDepositsBalance(user, token);\r\n        balanceStates[user][token].balance = balanceStates[user][token].balance.add(amount);\r\n    }\r\n\r\n    function subtractBalance(address user, address token, uint256 amount) internal {\r\n        updateDepositsBalance(user, token);\r\n        balanceStates[user][token].balance = balanceStates[user][token].balance.sub(amount);\r\n    }\r\n\r\n    function updateDepositsBalance(address user, address token) private {\r\n        if (balanceStates[user][token].pendingDeposits.batchId < getCurrentBatchId()) {\r\n            balanceStates[user][token].balance = balanceStates[user][token].balance.add(\r\n                balanceStates[user][token].pendingDeposits.amount\r\n            );\r\n            delete balanceStates[user][token].pendingDeposits;\r\n        }\r\n    }\r\n}\r\n\r\n// File: @gnosis.pm/solidity-data-structures/contracts/libraries/IdToAddressBiMap.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\nlibrary IdToAddressBiMap {\r\n    struct Data {\r\n        mapping(uint16 => address) idToAddress;\r\n        mapping(address => uint16) addressToId;\r\n    }\r\n\r\n    function hasId(Data storage self, uint16 id) public view returns (bool) {\r\n        return self.idToAddress[id + 1] != address(0);\r\n    }\r\n\r\n    function hasAddress(Data storage self, address addr) public view returns (bool) {\r\n        return self.addressToId[addr] != 0;\r\n    }\r\n\r\n    function getAddressAt(Data storage self, uint16 id) public view returns (address) {\r\n        require(hasId(self, id), \"Must have ID to get Address\");\r\n        return self.idToAddress[id + 1];\r\n    }\r\n\r\n    function getId(Data storage self, address addr) public view returns (uint16) {\r\n        require(hasAddress(self, addr), \"Must have Address to get ID\");\r\n        return self.addressToId[addr] - 1;\r\n    }\r\n\r\n    function insert(Data storage self, uint16 id, address addr) public returns (bool) {\r\n        // Ensure bijectivity of the mappings\r\n        if (self.addressToId[addr] != 0 || self.idToAddress[id + 1] != address(0)) {\r\n            return false;\r\n        }\r\n        self.idToAddress[id + 1] = addr;\r\n        self.addressToId[addr] = id + 1;\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n// File: @gnosis.pm/solidity-data-structures/contracts/libraries/IterableAppendOnlySet.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\nlibrary IterableAppendOnlySet {\r\n    struct Data {\r\n        mapping(address => address) nextMap;\r\n        address last;\r\n    }\r\n\r\n    function insert(Data storage self, address value) public returns (bool) {\r\n        if (contains(self, value)) {\r\n            return false;\r\n        }\r\n        self.nextMap[self.last] = value;\r\n        self.last = value;\r\n        return true;\r\n    }\r\n\r\n    function contains(Data storage self, address value) public view returns (bool) {\r\n        require(value != address(0), \"Inserting address(0) is not supported\");\r\n        return self.nextMap[value] != address(0) || (self.last == value);\r\n    }\r\n\r\n    function first(Data storage self) public view returns (address) {\r\n        require(self.last != address(0), \"Trying to get first from empty set\");\r\n        return self.nextMap[address(0)];\r\n    }\r\n\r\n    function next(Data storage self, address value) public view returns (address) {\r\n        require(contains(self, value), \"Trying to get next of non-existent element\");\r\n        require(value != self.last, \"Trying to get next of last element\");\r\n        return self.nextMap[value];\r\n    }\r\n\r\n    function size(Data storage self) public view returns (uint256) {\r\n        if (self.last == address(0)) {\r\n            return 0;\r\n        }\r\n        uint256 count = 1;\r\n        address current = first(self);\r\n        while (current != self.last) {\r\n            current = next(self, current);\r\n            count++;\r\n        }\r\n        return count;\r\n    }\r\n}\r\n\r\n// File: @gnosis.pm/util-contracts/contracts/Math.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/// @title Math library - Allows calculation of logarithmic and exponential functions\r\n/// @author Alan Lu - <alan.lu@gnosis.pm>\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\nlibrary GnosisMath {\r\n    /*\r\n     *  Constants\r\n     */\r\n    // This is equal to 1 in our calculations\r\n    uint public constant ONE = 0x10000000000000000;\r\n    uint public constant LN2 = 0xb17217f7d1cf79ac;\r\n    uint public constant LOG2_E = 0x171547652b82fe177;\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Returns natural exponential function value of given x\r\n    /// @param x x\r\n    /// @return e**x\r\n    function exp(int x) public pure returns (uint) {\r\n        // revert if x is > MAX_POWER, where\r\n        // MAX_POWER = int(mp.floor(mp.log(mpf(2**256 - 1) / ONE) * ONE))\r\n        require(x <= 2454971259878909886679);\r\n        // return 0 if exp(x) is tiny, using\r\n        // MIN_POWER = int(mp.floor(mp.log(mpf(1) / ONE) * ONE))\r\n        if (x < -818323753292969962227) return 0;\r\n        // Transform so that e^x -> 2^x\r\n        x = x * int(ONE) / int(LN2);\r\n        // 2^x = 2^whole(x) * 2^frac(x)\r\n        //       ^^^^^^^^^^ is a bit shift\r\n        // so Taylor expand on z = frac(x)\r\n        int shift;\r\n        uint z;\r\n        if (x >= 0) {\r\n            shift = x / int(ONE);\r\n            z = uint(x % int(ONE));\r\n        } else {\r\n            shift = x / int(ONE) - 1;\r\n            z = ONE - uint(-x % int(ONE));\r\n        }\r\n        // 2^x = 1 + (ln 2) x + (ln 2)^2/2! x^2 + ...\r\n        //\r\n        // Can generate the z coefficients using mpmath and the following lines\r\n        // >>> from mpmath import mp\r\n        // >>> mp.dps = 100\r\n        // >>> ONE =  0x10000000000000000\r\n        // >>> print('\\n'.join(hex(int(mp.log(2)**i / mp.factorial(i) * ONE)) for i in range(1, 7)))\r\n        // 0xb17217f7d1cf79ab\r\n        // 0x3d7f7bff058b1d50\r\n        // 0xe35846b82505fc5\r\n        // 0x276556df749cee5\r\n        // 0x5761ff9e299cc4\r\n        // 0xa184897c363c3\r\n        uint zpow = z;\r\n        uint result = ONE;\r\n        result += 0xb17217f7d1cf79ab * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x3d7f7bff058b1d50 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0xe35846b82505fc5 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x276556df749cee5 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x5761ff9e299cc4 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0xa184897c363c3 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0xffe5fe2c4586 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x162c0223a5c8 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x1b5253d395e * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x1e4cf5158b * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x1e8cac735 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x1c3bd650 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x1816193 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x131496 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0xe1b7 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x9c7 * zpow / ONE;\r\n        if (shift >= 0) {\r\n            if (result >> (256 - shift) > 0) return (2 ** 256 - 1);\r\n            return result << shift;\r\n        } else return result >> (-shift);\r\n    }\r\n\r\n    /// @dev Returns natural logarithm value of given x\r\n    /// @param x x\r\n    /// @return ln(x)\r\n    function ln(uint x) public pure returns (int) {\r\n        require(x > 0);\r\n        // binary search for floor(log2(x))\r\n        int ilog2 = floorLog2(x);\r\n        int z;\r\n        if (ilog2 < 0) z = int(x << uint(-ilog2));\r\n        else z = int(x >> uint(ilog2));\r\n        // z = x * 2^-⌊log₂x⌋\r\n        // so 1 <= z < 2\r\n        // and ln z = ln x - ⌊log₂x⌋/log₂e\r\n        // so just compute ln z using artanh series\r\n        // and calculate ln x from that\r\n        int term = (z - int(ONE)) * int(ONE) / (z + int(ONE));\r\n        int halflnz = term;\r\n        int termpow = term * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 3;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 5;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 7;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 9;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 11;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 13;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 15;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 17;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 19;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 21;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 23;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 25;\r\n        return (ilog2 * int(ONE)) * int(ONE) / int(LOG2_E) + 2 * halflnz;\r\n    }\r\n\r\n    /// @dev Returns base 2 logarithm value of given x\r\n    /// @param x x\r\n    /// @return logarithmic value\r\n    function floorLog2(uint x) public pure returns (int lo) {\r\n        lo = -64;\r\n        int hi = 193;\r\n        // I use a shift here instead of / 2 because it floors instead of rounding towards 0\r\n        int mid = (hi + lo) >> 1;\r\n        while ((lo + 1) < hi) {\r\n            if (mid < 0 && x << uint(-mid) < ONE || mid >= 0 && x >> uint(mid) < ONE) hi = mid;\r\n            else lo = mid;\r\n            mid = (hi + lo) >> 1;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns maximum of an array\r\n    /// @param nums Numbers to look through\r\n    /// @return Maximum number\r\n    function max(int[] memory nums) public pure returns (int maxNum) {\r\n        require(nums.length > 0);\r\n        maxNum = -2 ** 255;\r\n        for (uint i = 0; i < nums.length; i++) if (nums[i] > maxNum) maxNum = nums[i];\r\n    }\r\n\r\n    /// @dev Returns whether an add operation causes an overflow\r\n    /// @param a First addend\r\n    /// @param b Second addend\r\n    /// @return Did no overflow occur?\r\n    function safeToAdd(uint a, uint b) internal pure returns (bool) {\r\n        return a + b >= a;\r\n    }\r\n\r\n    /// @dev Returns whether a subtraction operation causes an underflow\r\n    /// @param a Minuend\r\n    /// @param b Subtrahend\r\n    /// @return Did no underflow occur?\r\n    function safeToSub(uint a, uint b) internal pure returns (bool) {\r\n        return a >= b;\r\n    }\r\n\r\n    /// @dev Returns whether a multiply operation causes an overflow\r\n    /// @param a First factor\r\n    /// @param b Second factor\r\n    /// @return Did no overflow occur?\r\n    function safeToMul(uint a, uint b) internal pure returns (bool) {\r\n        return b == 0 || a * b / b == a;\r\n    }\r\n\r\n    /// @dev Returns sum if no overflow occurred\r\n    /// @param a First addend\r\n    /// @param b Second addend\r\n    /// @return Sum\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        require(safeToAdd(a, b));\r\n        return a + b;\r\n    }\r\n\r\n    /// @dev Returns difference if no overflow occurred\r\n    /// @param a Minuend\r\n    /// @param b Subtrahend\r\n    /// @return Difference\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        require(safeToSub(a, b));\r\n        return a - b;\r\n    }\r\n\r\n    /// @dev Returns product if no overflow occurred\r\n    /// @param a First factor\r\n    /// @param b Second factor\r\n    /// @return Product\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        require(safeToMul(a, b));\r\n        return a * b;\r\n    }\r\n\r\n    /// @dev Returns whether an add operation causes an overflow\r\n    /// @param a First addend\r\n    /// @param b Second addend\r\n    /// @return Did no overflow occur?\r\n    function safeToAdd(int a, int b) internal pure returns (bool) {\r\n        return (b >= 0 && a + b >= a) || (b < 0 && a + b < a);\r\n    }\r\n\r\n    /// @dev Returns whether a subtraction operation causes an underflow\r\n    /// @param a Minuend\r\n    /// @param b Subtrahend\r\n    /// @return Did no underflow occur?\r\n    function safeToSub(int a, int b) internal pure returns (bool) {\r\n        return (b >= 0 && a - b <= a) || (b < 0 && a - b > a);\r\n    }\r\n\r\n    /// @dev Returns whether a multiply operation causes an overflow\r\n    /// @param a First factor\r\n    /// @param b Second factor\r\n    /// @return Did no overflow occur?\r\n    function safeToMul(int a, int b) internal pure returns (bool) {\r\n        return (b == 0) || (a * b / b == a);\r\n    }\r\n\r\n    /// @dev Returns sum if no overflow occurred\r\n    /// @param a First addend\r\n    /// @param b Second addend\r\n    /// @return Sum\r\n    function add(int a, int b) internal pure returns (int) {\r\n        require(safeToAdd(a, b));\r\n        return a + b;\r\n    }\r\n\r\n    /// @dev Returns difference if no overflow occurred\r\n    /// @param a Minuend\r\n    /// @param b Subtrahend\r\n    /// @return Difference\r\n    function sub(int a, int b) internal pure returns (int) {\r\n        require(safeToSub(a, b));\r\n        return a - b;\r\n    }\r\n\r\n    /// @dev Returns product if no overflow occurred\r\n    /// @param a First factor\r\n    /// @param b Second factor\r\n    /// @return Product\r\n    function mul(int a, int b) internal pure returns (int) {\r\n        require(safeToMul(a, b));\r\n        return a * b;\r\n    }\r\n}\r\n\r\n// File: @gnosis.pm/util-contracts/contracts/Token.sol\r\n\r\n/// Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\npragma solidity ^0.5.2;\r\n\r\n/// @title Abstract token contract - Functions to be implemented by token contracts\r\ncontract Token {\r\n    /*\r\n     *  Events\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    function transfer(address to, uint value) public returns (bool);\r\n    function transferFrom(address from, address to, uint value) public returns (bool);\r\n    function approve(address spender, uint value) public returns (bool);\r\n    function balanceOf(address owner) public view returns (uint);\r\n    function allowance(address owner, address spender) public view returns (uint);\r\n    function totalSupply() public view returns (uint);\r\n}\r\n\r\n// File: @gnosis.pm/util-contracts/contracts/Proxy.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/// @title Proxied - indicates that a contract will be proxied. Also defines storage requirements for Proxy.\r\n/// @author Alan Lu - <alan@gnosis.pm>\r\ncontract Proxied {\r\n    address public masterCopy;\r\n}\r\n\r\n/// @title Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\ncontract Proxy is Proxied {\r\n    /// @dev Constructor function sets address of master copy contract.\r\n    /// @param _masterCopy Master copy address.\r\n    constructor(address _masterCopy) public {\r\n        require(_masterCopy != address(0), \"The master copy is required\");\r\n        masterCopy = _masterCopy;\r\n    }\r\n\r\n    /// @dev Fallback function forwards all transactions and returns all received return data.\r\n    function() external payable {\r\n        address _masterCopy = masterCopy;\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize)\r\n            let success := delegatecall(not(0), _masterCopy, 0, calldatasize, 0, 0)\r\n            returndatacopy(0, 0, returndatasize)\r\n            switch success\r\n                case 0 {\r\n                    revert(0, returndatasize)\r\n                }\r\n                default {\r\n                    return(0, returndatasize)\r\n                }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @gnosis.pm/util-contracts/contracts/GnosisStandardToken.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n/**\r\n * Deprecated: Use Open Zeppeling one instead\r\n */\r\ncontract StandardTokenData {\r\n    /*\r\n     *  Storage\r\n     */\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowances;\r\n    uint totalTokens;\r\n}\r\n\r\n/**\r\n * Deprecated: Use Open Zeppeling one instead\r\n */\r\n/// @title Standard token contract with overflow protection\r\ncontract GnosisStandardToken is Token, StandardTokenData {\r\n    using GnosisMath for *;\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Transfers sender's tokens to a given address. Returns success\r\n    /// @param to Address of token receiver\r\n    /// @param value Number of tokens to transfer\r\n    /// @return Was transfer successful?\r\n    function transfer(address to, uint value) public returns (bool) {\r\n        if (!balances[msg.sender].safeToSub(value) || !balances[to].safeToAdd(value)) {\r\n            return false;\r\n        }\r\n\r\n        balances[msg.sender] -= value;\r\n        balances[to] += value;\r\n        emit Transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success\r\n    /// @param from Address from where tokens are withdrawn\r\n    /// @param to Address to where tokens are sent\r\n    /// @param value Number of tokens to transfer\r\n    /// @return Was transfer successful?\r\n    function transferFrom(address from, address to, uint value) public returns (bool) {\r\n        if (!balances[from].safeToSub(value) || !allowances[from][msg.sender].safeToSub(\r\n            value\r\n        ) || !balances[to].safeToAdd(value)) {\r\n            return false;\r\n        }\r\n        balances[from] -= value;\r\n        allowances[from][msg.sender] -= value;\r\n        balances[to] += value;\r\n        emit Transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Sets approved amount of tokens for spender. Returns success\r\n    /// @param spender Address of allowed account\r\n    /// @param value Number of approved tokens\r\n    /// @return Was approval successful?\r\n    function approve(address spender, uint value) public returns (bool) {\r\n        allowances[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Returns number of allowed tokens for given address\r\n    /// @param owner Address of token owner\r\n    /// @param spender Address of token spender\r\n    /// @return Remaining allowance for spender\r\n    function allowance(address owner, address spender) public view returns (uint) {\r\n        return allowances[owner][spender];\r\n    }\r\n\r\n    /// @dev Returns number of tokens owned by given address\r\n    /// @param owner Address of token owner\r\n    /// @return Balance of owner\r\n    function balanceOf(address owner) public view returns (uint) {\r\n        return balances[owner];\r\n    }\r\n\r\n    /// @dev Returns total supply of tokens\r\n    /// @return Total supply\r\n    function totalSupply() public view returns (uint) {\r\n        return totalTokens;\r\n    }\r\n}\r\n\r\n// File: @gnosis.pm/owl-token/contracts/TokenOWL.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\ncontract TokenOWL is Proxied, GnosisStandardToken {\r\n    using GnosisMath for *;\r\n\r\n    string public constant name = \"OWL Token\";\r\n    string public constant symbol = \"OWL\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    struct masterCopyCountdownType {\r\n        address masterCopy;\r\n        uint timeWhenAvailable;\r\n    }\r\n\r\n    masterCopyCountdownType masterCopyCountdown;\r\n\r\n    address public creator;\r\n    address public minter;\r\n\r\n    event Minted(address indexed to, uint256 amount);\r\n    event Burnt(address indexed from, address indexed user, uint256 amount);\r\n\r\n    modifier onlyCreator() {\r\n        // R1\r\n        require(msg.sender == creator, \"Only the creator can perform the transaction\");\r\n        _;\r\n    }\r\n    /// @dev trickers the update process via the proxyMaster for a new address _masterCopy\r\n    /// updating is only possible after 30 days\r\n    function startMasterCopyCountdown(address _masterCopy) public onlyCreator {\r\n        require(address(_masterCopy) != address(0), \"The master copy must be a valid address\");\r\n\r\n        // Update masterCopyCountdown\r\n        masterCopyCountdown.masterCopy = _masterCopy;\r\n        masterCopyCountdown.timeWhenAvailable = now + 30 days;\r\n    }\r\n\r\n    /// @dev executes the update process via the proxyMaster for a new address _masterCopy\r\n    function updateMasterCopy() public onlyCreator {\r\n        require(address(masterCopyCountdown.masterCopy) != address(0), \"The master copy must be a valid address\");\r\n        require(\r\n            block.timestamp >= masterCopyCountdown.timeWhenAvailable,\r\n            \"It's not possible to update the master copy during the waiting period\"\r\n        );\r\n\r\n        // Update masterCopy\r\n        masterCopy = masterCopyCountdown.masterCopy;\r\n    }\r\n\r\n    function getMasterCopy() public view returns (address) {\r\n        return masterCopy;\r\n    }\r\n\r\n    /// @dev Set minter. Only the creator of this contract can call this.\r\n    /// @param newMinter The new address authorized to mint this token\r\n    function setMinter(address newMinter) public onlyCreator {\r\n        minter = newMinter;\r\n    }\r\n\r\n    /// @dev change owner/creator of the contract. Only the creator/owner of this contract can call this.\r\n    /// @param newOwner The new address, which should become the owner\r\n    function setNewOwner(address newOwner) public onlyCreator {\r\n        creator = newOwner;\r\n    }\r\n\r\n    /// @dev Mints OWL.\r\n    /// @param to Address to which the minted token will be given\r\n    /// @param amount Amount of OWL to be minted\r\n    function mintOWL(address to, uint amount) public {\r\n        require(minter != address(0), \"The minter must be initialized\");\r\n        require(msg.sender == minter, \"Only the minter can mint OWL\");\r\n        balances[to] = balances[to].add(amount);\r\n        totalTokens = totalTokens.add(amount);\r\n        emit Minted(to, amount);\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    /// @dev Burns OWL.\r\n    /// @param user Address of OWL owner\r\n    /// @param amount Amount of OWL to be burnt\r\n    function burnOWL(address user, uint amount) public {\r\n        allowances[user][msg.sender] = allowances[user][msg.sender].sub(amount);\r\n        balances[user] = balances[user].sub(amount);\r\n        totalTokens = totalTokens.sub(amount);\r\n        emit Burnt(msg.sender, user, amount);\r\n        emit Transfer(user, address(0), amount);\r\n    }\r\n\r\n    function getMasterCopyCountdown() public view returns (address, uint) {\r\n        return (masterCopyCountdown.masterCopy, masterCopyCountdown.timeWhenAvailable);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/SafeCast.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's uintXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256 in Solidity does not revert on overflow. This can \r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. `SafeCast` restores this intuition by \r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} to extend it to smaller types, by performing\r\n * all math on `uint256` and then downcasting.\r\n */\r\nlibrary SafeCast {\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n}\r\n\r\n// File: solidity-bytes-utils/contracts/BytesLib.sol\r\n\r\n/*\r\n * @title Solidity Bytes Arrays Utils\r\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\r\n *\r\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\r\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\r\n */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\nlibrary BytesLib {\r\n    function concat(\r\n        bytes memory _preBytes,\r\n        bytes memory _postBytes\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the tempBytes memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of tempBytes\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add \r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(0x40, and(\r\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n              not(31) // Round down to the nearest 32 bytes.\r\n            ))\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\r\n        assembly {\r\n            // Read the first 32 bytes of _preBytes storage, which is the length\r\n            // of the array. (We don't need to use the offset into the slot\r\n            // because arrays use the entire slot.)\r\n            let fslot := sload(_preBytes_slot)\r\n            // Arrays of 31 bytes or less have an even value in their slot,\r\n            // while longer arrays have an odd value. The actual length is\r\n            // the slot divided by two for odd values, and the lowest order\r\n            // byte divided by two for even values.\r\n            // If the slot is even, bitwise and the slot with 255 and divide by\r\n            // two to get the length. If the slot is odd, bitwise and the slot\r\n            // with -1 and divide by two.\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n            let newlength := add(slength, mlength)\r\n            // slength can contain both the length and contents of the array\r\n            // if length < 32 bytes so let's prepare for that\r\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n            switch add(lt(slength, 32), lt(newlength, 32))\r\n            case 2 {\r\n                // Since the new array still fits in the slot, we just need to\r\n                // update the contents of the slot.\r\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\r\n                sstore(\r\n                    _preBytes_slot,\r\n                    // all the modifications to the slot are inside this\r\n                    // next block\r\n                    add(\r\n                        // we can just add to the slot contents because the\r\n                        // bytes we want to change are the LSBs\r\n                        fslot,\r\n                        add(\r\n                            mul(\r\n                                div(\r\n                                    // load the bytes from memory\r\n                                    mload(add(_postBytes, 0x20)),\r\n                                    // zero all bytes to the right\r\n                                    exp(0x100, sub(32, mlength))\r\n                                ),\r\n                                // and now shift left the number of bytes to\r\n                                // leave space for the length in the slot\r\n                                exp(0x100, sub(32, newlength))\r\n                            ),\r\n                            // increase length by the double of the memory\r\n                            // bytes length\r\n                            mul(mlength, 2)\r\n                        )\r\n                    )\r\n                )\r\n            }\r\n            case 1 {\r\n                // The stored value fits in the slot, but the combined value\r\n                // will exceed it.\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                // The contents of the _postBytes array start 32 bytes into\r\n                // the structure. Our first read should obtain the `submod`\r\n                // bytes that can fit into the unused space in the last word\r\n                // of the stored array. To get this, we read 32 bytes starting\r\n                // from `submod`, so the data we read overlaps with the array\r\n                // contents by `submod` bytes. Masking the lowest-order\r\n                // `submod` bytes allows us to add that value directly to the\r\n                // stored value.\r\n\r\n                let submod := sub(32, slength)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(\r\n                    sc,\r\n                    add(\r\n                        and(\r\n                            fslot,\r\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n                        ),\r\n                        and(mload(mc), mask)\r\n                    )\r\n                )\r\n\r\n                for {\r\n                    mc := add(mc, 0x20)\r\n                    sc := add(sc, 1)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n            default {\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                // Start copying to the last used word of the stored array.\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                // Copy over the first `submod` bytes of the new data as in\r\n                // case 1 above.\r\n                let slengthmod := mod(slength, 32)\r\n                let mlengthmod := mod(mlength, 32)\r\n                let submod := sub(32, slengthmod)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\r\n                \r\n                for { \r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n        }\r\n    }\r\n\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint _start,\r\n        uint _length\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        require(_bytes.length >= (_start + _length));\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\r\n        require(_bytes.length >= (_start + 20));\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\r\n        require(_bytes.length >= (_start + 1));\r\n        uint8 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x1), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\r\n        require(_bytes.length >= (_start + 2));\r\n        uint16 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x2), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\r\n        require(_bytes.length >= (_start + 4));\r\n        uint32 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x4), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\r\n        require(_bytes.length >= (_start + 8));\r\n        uint64 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x8), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\r\n        require(_bytes.length >= (_start + 12));\r\n        uint96 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0xc), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\r\n        require(_bytes.length >= (_start + 16));\r\n        uint128 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x10), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\r\n        require(_bytes.length >= (_start + 32));\r\n        uint256 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\r\n        require(_bytes.length >= (_start + 32));\r\n        bytes32 tempBytes32;\r\n\r\n        assembly {\r\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes32;\r\n    }\r\n\r\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            let length := mload(_preBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(length, mload(_postBytes))\r\n            case 1 {\r\n                // cb is a circuit breaker in the for loop since there's\r\n                //  no said feature for inline assembly loops\r\n                // cb = 1 - don't breaker\r\n                // cb = 0 - break\r\n                let cb := 1\r\n\r\n                let mc := add(_preBytes, 0x20)\r\n                let end := add(mc, length)\r\n\r\n                for {\r\n                    let cc := add(_postBytes, 0x20)\r\n                // the next line is the loop condition:\r\n                // while(uint(mc < end) + cb == 2)\r\n                } eq(add(lt(mc, end), cb), 2) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    // if any of these checks fails then arrays are not equal\r\n                    if iszero(eq(mload(mc), mload(cc))) {\r\n                        // unsuccess:\r\n                        success := 0\r\n                        cb := 0\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function equalStorage(\r\n        bytes storage _preBytes,\r\n        bytes memory _postBytes\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            // we know _preBytes_offset is 0\r\n            let fslot := sload(_preBytes_slot)\r\n            // Decode the length of the stored array like in concatStorage().\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(slength, mlength)\r\n            case 1 {\r\n                // slength can contain both the length and contents of the array\r\n                // if length < 32 bytes so let's prepare for that\r\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n                if iszero(iszero(slength)) {\r\n                    switch lt(slength, 32)\r\n                    case 1 {\r\n                        // blank the last byte which is the length\r\n                        fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n                            // unsuccess:\r\n                            success := 0\r\n                        }\r\n                    }\r\n                    default {\r\n                        // cb is a circuit breaker in the for loop since there's\r\n                        //  no said feature for inline assembly loops\r\n                        // cb = 1 - don't breaker\r\n                        // cb = 0 - break\r\n                        let cb := 1\r\n\r\n                        // get the keccak hash to get the contents of the array\r\n                        mstore(0x0, _preBytes_slot)\r\n                        let sc := keccak256(0x0, 0x20)\r\n\r\n                        let mc := add(_postBytes, 0x20)\r\n                        let end := add(mc, mlength)\r\n\r\n                        // the next line is the loop condition:\r\n                        // while(uint(mc < end) + cb == 2)\r\n                        for {} eq(add(lt(mc, end), cb), 2) {\r\n                            sc := add(sc, 1)\r\n                            mc := add(mc, 0x20)\r\n                        } {\r\n                            if iszero(eq(sload(sc), mload(mc))) {\r\n                                // unsuccess:\r\n                                success := 0\r\n                                cb := 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/drafts/SignedSafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SignedSafeMath\r\n * @dev Signed math operations with safety checks that revert on error.\r\n */\r\nlibrary SignedSafeMath {\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n     * @dev Multiplies two signed integers, reverts on overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == INT256_MIN), \"SignedSafeMath: multiplication overflow\");\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"SignedSafeMath: division by zero\");\r\n        require(!(b == -1 && a == INT256_MIN), \"SignedSafeMath: division overflow\");\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two signed integers, reverts on overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two signed integers, reverts on overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/TokenConservation.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/** @title Token Conservation\r\n *  A library for updating and verifying the tokenConservation contraint for BatchExchange's batch auction\r\n *  @author @gnosis/dfusion-team <https://github.com/orgs/gnosis/teams/dfusion-team/members>\r\n */\r\nlibrary TokenConservation {\r\n    using SignedSafeMath for int256;\r\n\r\n    /** @dev initialize the token conservation data structure\r\n      * @param tokenIdsForPrice sorted list of tokenIds for which token conservation should be checked\r\n      */\r\n    function init(uint16[] memory tokenIdsForPrice) internal pure returns (int256[] memory) {\r\n        return new int256[](tokenIdsForPrice.length + 1);\r\n    }\r\n\r\n    /** @dev returns the token imbalance of the fee token\r\n      * @param self internal datastructure created by TokenConservation.init()\r\n      */\r\n    function feeTokenImbalance(int256[] memory self) internal pure returns (int256) {\r\n        return self[0];\r\n    }\r\n\r\n    /** @dev updated token conservation array.\r\n      * @param self internal datastructure created by TokenConservation.init()\r\n      * @param buyToken id of token whose imbalance should be subtracted from\r\n      * @param sellToken id of token whose imbalance should be added to\r\n      * @param tokenIdsForPrice sorted list of tokenIds\r\n      * @param buyAmount amount to be subtracted at `self[buyTokenIndex]`\r\n      * @param sellAmount amount to be added at `self[sellTokenIndex]`\r\n      */\r\n    function updateTokenConservation(\r\n        int256[] memory self,\r\n        uint16 buyToken,\r\n        uint16 sellToken,\r\n        uint16[] memory tokenIdsForPrice,\r\n        uint128 buyAmount,\r\n        uint128 sellAmount\r\n    ) internal pure {\r\n        uint256 buyTokenIndex = findPriceIndex(buyToken, tokenIdsForPrice);\r\n        uint256 sellTokenIndex = findPriceIndex(sellToken, tokenIdsForPrice);\r\n        self[buyTokenIndex] = self[buyTokenIndex].sub(int256(buyAmount));\r\n        self[sellTokenIndex] = self[sellTokenIndex].add(int256(sellAmount));\r\n    }\r\n\r\n    /** @dev Ensures all array's elements are zero except the first.\r\n      * @param self internal datastructure created by TokenConservation.init()\r\n      * @return true if all, but first element of self are zero else false\r\n      */\r\n    function checkTokenConservation(int256[] memory self) internal pure {\r\n        require(self[0] > 0, \"Token conservation at 0 must be positive.\");\r\n        for (uint256 i = 1; i < self.length; i++) {\r\n            require(self[i] == 0, \"Token conservation does not hold\");\r\n        }\r\n    }\r\n\r\n    /** @dev Token ordering is verified by submitSolution. Required because binary search is used to fetch token info.\r\n      * @param tokenIdsForPrice list of tokenIds\r\n      * @return true if tokenIdsForPrice is sorted else false\r\n      */\r\n    function checkPriceOrdering(uint16[] memory tokenIdsForPrice) internal pure returns (bool) {\r\n        for (uint256 i = 1; i < tokenIdsForPrice.length; i++) {\r\n            if (tokenIdsForPrice[i] <= tokenIdsForPrice[i - 1]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /** @dev implementation of binary search on sorted list returns token id\r\n      * @param tokenId element whose index is to be found\r\n      * @param tokenIdsForPrice list of (sorted) tokenIds for which binary search is applied.\r\n      * @return `index` in `tokenIdsForPrice` where `tokenId` appears (reverts if not found).\r\n      */\r\n    function findPriceIndex(uint16 tokenId, uint16[] memory tokenIdsForPrice) private pure returns (uint256) {\r\n        // Fee token is not included in tokenIdsForPrice\r\n        if (tokenId == 0) {\r\n            return 0;\r\n        }\r\n        // binary search for the other tokens\r\n        uint256 leftValue = 0;\r\n        uint256 rightValue = tokenIdsForPrice.length - 1;\r\n        while (rightValue >= leftValue) {\r\n            uint256 middleValue = leftValue + (rightValue - leftValue) / 2;\r\n            if (tokenIdsForPrice[middleValue] == tokenId) {\r\n                // shifted one to the right to account for fee token at index 0\r\n                return middleValue + 1;\r\n            } else if (tokenIdsForPrice[middleValue] < tokenId) {\r\n                leftValue = middleValue + 1;\r\n            } else {\r\n                rightValue = middleValue - 1;\r\n            }\r\n        }\r\n        revert(\"Price not provided for token\");\r\n    }\r\n}\r\n\r\n// File: contracts/BatchExchange.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/** @title BatchExchange - A decentralized exchange for any ERC20 token as a multi-token batch\r\n *  auction with uniform clearing prices.\r\n *  For more information visit: <https://github.com/gnosis/dex-contracts>\r\n *  @author @gnosis/dfusion-team <https://github.com/orgs/gnosis/teams/dfusion-team/members>\r\n */\r\ncontract BatchExchange is EpochTokenLocker {\r\n    using SafeCast for uint256;\r\n    using SafeMath for uint128;\r\n    using BytesLib for bytes32;\r\n    using BytesLib for bytes;\r\n    using TokenConservation for int256[];\r\n    using TokenConservation for uint16[];\r\n    using IterableAppendOnlySet for IterableAppendOnlySet.Data;\r\n\r\n    /** @dev Maximum number of touched orders in auction (used in submitSolution) */\r\n    uint256 public constant MAX_TOUCHED_ORDERS = 25;\r\n\r\n    /** @dev Fee charged for adding a token */\r\n    uint256 public constant FEE_FOR_LISTING_TOKEN_IN_OWL = 10 ether;\r\n\r\n    /** @dev minimum allowed value (in WEI) of any prices or executed trade amounts */\r\n    uint256 public constant AMOUNT_MINIMUM = 10**4;\r\n\r\n    /** Corresponds to percentage that competing solution must improve on current\r\n      * (p = IMPROVEMENT_DENOMINATOR + 1 / IMPROVEMENT_DENOMINATOR)\r\n      */\r\n    uint256 public constant IMPROVEMENT_DENOMINATOR = 100; // 1%\r\n\r\n    /** @dev maximum number of tokens that can be listed for exchange */\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    uint256 public MAX_TOKENS;\r\n\r\n    /** @dev Current number of tokens listed/available for exchange */\r\n    uint16 public numTokens;\r\n\r\n    /** @dev A fixed integer used to evaluate fees as a fraction of trade execution 1/feeDenominator */\r\n    uint128 public feeDenominator;\r\n\r\n    /** @dev The feeToken of the exchange will be the OWL Token */\r\n    TokenOWL public feeToken;\r\n\r\n    /** @dev mapping of type userAddress -> List[Order] where all the user's orders are stored */\r\n    mapping(address => Order[]) public orders;\r\n\r\n    /** @dev mapping of type tokenId -> curentPrice of tokenId */\r\n    mapping(uint16 => uint128) public currentPrices;\r\n\r\n    /** @dev Sufficient information for current winning auction solution */\r\n    SolutionData public latestSolution;\r\n\r\n    // Iterable set of all users, required to collect auction information\r\n    IterableAppendOnlySet.Data private allUsers;\r\n    IdToAddressBiMap.Data private registeredTokens;\r\n\r\n    struct Order {\r\n        uint16 buyToken;\r\n        uint16 sellToken;\r\n        uint32 validFrom; // order is valid from auction collection period: validFrom inclusive\r\n        uint32 validUntil; // order is valid till auction collection period: validUntil inclusive\r\n        uint128 priceNumerator;\r\n        uint128 priceDenominator;\r\n        uint128 usedAmount; // remainingAmount = priceDenominator - usedAmount\r\n    }\r\n\r\n    struct TradeData {\r\n        address owner;\r\n        uint128 volume;\r\n        uint16 orderId;\r\n    }\r\n\r\n    struct SolutionData {\r\n        uint32 batchId;\r\n        TradeData[] trades;\r\n        uint16[] tokenIdsForPrice;\r\n        address solutionSubmitter;\r\n        uint256 feeReward;\r\n        uint256 objectiveValue;\r\n    }\r\n\r\n    event OrderPlacement(\r\n        address owner,\r\n        uint256 index,\r\n        uint16 buyToken,\r\n        uint16 sellToken,\r\n        uint32 validFrom,\r\n        uint32 validUntil,\r\n        uint128 priceNumerator,\r\n        uint128 priceDenominator\r\n    );\r\n\r\n    /** @dev Event emitted when an order is cancelled but still valid in the batch that is\r\n     * currently being solved. It remains in storage but will not be tradable in any future\r\n     * batch to be solved.\r\n     */\r\n    event OrderCancelation(address owner, uint256 id);\r\n\r\n    /** @dev Event emitted when an order is removed from storage.\r\n     */\r\n    event OrderDeletion(address owner, uint256 id);\r\n\r\n    /** @dev Event emitted when a new trade is settled\r\n     */\r\n    event Trade(address indexed owner, uint256 indexed orderIds, uint256 executedSellAmount, uint256 executedBuyAmount);\r\n\r\n    /** @dev Event emitted when an already exectued trade gets reverted\r\n     */\r\n    event TradeReversion(address indexed owner, uint256 indexed orderIds, uint256 executedSellAmount, uint256 executedBuyAmount);\r\n\r\n    /** @dev Constructor determines exchange parameters\r\n      * @param maxTokens The maximum number of tokens that can be listed.\r\n      * @param _feeDenominator fee as a proportion is (1 / feeDenominator)\r\n      * @param _feeToken Address of ERC20 fee token.\r\n      */\r\n    constructor(uint256 maxTokens, uint128 _feeDenominator, address _feeToken) public {\r\n        // All solutions for the batches must have normalized prices. The following line sets the\r\n        // price of OWL to 10**18 for all solutions and hence enforces a normalization.\r\n        currentPrices[0] = 1 ether;\r\n        MAX_TOKENS = maxTokens;\r\n        feeToken = TokenOWL(_feeToken);\r\n        // The burn functionallity of OWL requires an approval.\r\n        // In the following line the approval is set for all future burn calls.\r\n        feeToken.approve(address(this), uint256(-1));\r\n        feeDenominator = _feeDenominator;\r\n        addToken(_feeToken); // feeToken will always have the token index 0\r\n    }\r\n\r\n    /** @dev Used to list a new token on the contract: Hence, making it available for exchange in an auction.\r\n      * @param token ERC20 token to be listed.\r\n      *\r\n      * Requirements:\r\n      * - `maxTokens` has not already been reached\r\n      * - `token` has not already been added\r\n      */\r\n    function addToken(address token) public {\r\n        require(numTokens < MAX_TOKENS, \"Max tokens reached\");\r\n        if (numTokens > 0) {\r\n            // Only charge fees for tokens other than the fee token itself\r\n            feeToken.burnOWL(msg.sender, FEE_FOR_LISTING_TOKEN_IN_OWL);\r\n        }\r\n        require(IdToAddressBiMap.insert(registeredTokens, numTokens, token), \"Token already registered\");\r\n        numTokens++;\r\n    }\r\n\r\n    /** @dev A user facing function used to place limit sell orders in auction with expiry defined by batchId\r\n      * @param buyToken id of token to be bought\r\n      * @param sellToken id of token to be sold\r\n      * @param validUntil batchId represnting order's expiry\r\n      * @param buyAmount relative minimum amount of requested buy amount\r\n      * @param sellAmount maximum amount of sell token to be exchanged\r\n      * @return orderId as index of user's current orders\r\n      *\r\n      * Emits an {OrderPlacement} event with all relevant order details.\r\n      */\r\n    function placeOrder(uint16 buyToken, uint16 sellToken, uint32 validUntil, uint128 buyAmount, uint128 sellAmount)\r\n        public\r\n        returns (uint256)\r\n    {\r\n        return placeOrderInternal(buyToken, sellToken, getCurrentBatchId(), validUntil, buyAmount, sellAmount);\r\n    }\r\n\r\n    /** @dev A user facing function used to place limit sell orders in auction with expiry defined by batchId\r\n      * Note that parameters are passed as arrays and the indices correspond to each order.\r\n      * @param buyTokens ids of tokens to be bought\r\n      * @param sellTokens ids of tokens to be sold\r\n      * @param validFroms batchIds representing order's validity start time\r\n      * @param validUntils batchIds represnnting order's expiry\r\n      * @param buyAmounts relative minimum amount of requested buy amounts\r\n      * @param sellAmounts maximum amounts of sell token to be exchanged\r\n      * @return `orderIds` an array of indices in which `msg.sender`'s orders are included\r\n      *\r\n      * Emits an {OrderPlacement} event with all relevant order details.\r\n      */\r\n    function placeValidFromOrders(\r\n        uint16[] memory buyTokens,\r\n        uint16[] memory sellTokens,\r\n        uint32[] memory validFroms,\r\n        uint32[] memory validUntils,\r\n        uint128[] memory buyAmounts,\r\n        uint128[] memory sellAmounts\r\n    ) public returns (uint256[] memory orderIds) {\r\n        orderIds = new uint256[](buyTokens.length);\r\n        for (uint256 i = 0; i < buyTokens.length; i++) {\r\n            orderIds[i] = placeOrderInternal(\r\n                buyTokens[i],\r\n                sellTokens[i],\r\n                validFroms[i],\r\n                validUntils[i],\r\n                buyAmounts[i],\r\n                sellAmounts[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    /** @dev a user facing function used to cancel orders. If the order is valid for the batch that is currently\r\n      * being solved, it sets order expiry to that batchId. Otherwise it removes it from storage. Can be called\r\n      * multiple times (e.g. to eventually free storage once order is expired).\r\n      *\r\n      * @param ids referencing the index of user's order to be canceled\r\n      *\r\n      * Emits an {OrderCancelation} or {OrderDeletion} with sender's address and orderId\r\n      */\r\n    function cancelOrders(uint256[] memory ids) public {\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            if (!checkOrderValidity(orders[msg.sender][ids[i]], getCurrentBatchId() - 1)) {\r\n                delete orders[msg.sender][ids[i]];\r\n                emit OrderDeletion(msg.sender, ids[i]);\r\n            } else {\r\n                orders[msg.sender][ids[i]].validUntil = getCurrentBatchId() - 1;\r\n                emit OrderCancelation(msg.sender, ids[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @dev A user facing wrapper to cancel and place new orders in the same transaction.\r\n      * @param cancellations ids of orders to be cancelled\r\n      * @param buyTokens ids of tokens to be bought in new orders\r\n      * @param sellTokens ids of tokens to be sold in new orders\r\n      * @param validFroms batchIds representing order's validity start time in new orders\r\n      * @param validUntils batchIds represnnting order's expiry in new orders\r\n      * @param buyAmounts relative minimum amount of requested buy amounts in new orders\r\n      * @param sellAmounts maximum amounts of sell token to be exchanged in new orders\r\n      * @return `orderIds` an array of indices in which `msg.sender`'s new orders are included\r\n      *\r\n      * Emits {OrderCancelation} events for all cancelled orders and {OrderPlacement} events with all relevant new order details.\r\n      */\r\n    function replaceOrders(\r\n        uint256[] memory cancellations,\r\n        uint16[] memory buyTokens,\r\n        uint16[] memory sellTokens,\r\n        uint32[] memory validFroms,\r\n        uint32[] memory validUntils,\r\n        uint128[] memory buyAmounts,\r\n        uint128[] memory sellAmounts\r\n    ) public returns (uint256[] memory orderIds) {\r\n        cancelOrders(cancellations);\r\n        return placeValidFromOrders(buyTokens, sellTokens, validFroms, validUntils, buyAmounts, sellAmounts);\r\n    }\r\n\r\n    /** @dev a solver facing function called for auction settlement\r\n      * @param batchIndex index of auction solution is referring to\r\n      * @param owners array of addresses corresponding to touched orders\r\n      * @param orderIds array of order ids used in parallel with owners to identify touched order\r\n      * @param buyVolumes executed buy amounts for each order identified by index of owner-orderId arrays\r\n      * @param prices list of prices for touched tokens indexed by next parameter\r\n      * @param tokenIdsForPrice price[i] is the price for the token with tokenID tokenIdsForPrice[i]\r\n      * @return the computed objective value of the solution\r\n      *\r\n      * Requirements:\r\n      * - Solutions for this `batchIndex` are currently being accepted.\r\n      * - Claimed objetive value is a great enough improvement on the current winning solution\r\n      * - Fee Token price is non-zero\r\n      * - `tokenIdsForPrice` is sorted.\r\n      * - Number of touched orders does not exceed `MAX_TOUCHED_ORDERS`.\r\n      * - Each touched order is valid at current `batchIndex`.\r\n      * - Each touched order's `executedSellAmount` does not exceed its remaining amount.\r\n      * - Limit Price of each touched order is respected.\r\n      * - Solution's objective evaluation must be positive.\r\n      *\r\n      * Sub Requirements: Those nested within other functions\r\n      * - checkAndOverrideObjectiveValue; Objetive value is a great enough improvement on the current winning solution\r\n      * - checkTokenConservation; for all, non-fee, tokens total amount sold == total amount bought\r\n      */\r\n    function submitSolution(\r\n        uint32 batchIndex,\r\n        uint256 claimedObjectiveValue,\r\n        address[] memory owners,\r\n        uint16[] memory orderIds,\r\n        uint128[] memory buyVolumes,\r\n        uint128[] memory prices,\r\n        uint16[] memory tokenIdsForPrice\r\n    ) public returns (uint256) {\r\n        require(acceptingSolutions(batchIndex), \"Solutions are no longer accepted for this batch\");\r\n        require(\r\n            isObjectiveValueSufficientlyImproved(claimedObjectiveValue),\r\n            \"Claimed objective doesn't sufficiently improve current solution\"\r\n        );\r\n        require(verifyAmountThreshold(prices), \"At least one price lower than AMOUNT_MINIMUM\");\r\n        require(tokenIdsForPrice[0] != 0, \"Fee token has fixed price!\");\r\n        require(tokenIdsForPrice.checkPriceOrdering(), \"prices are not ordered by tokenId\");\r\n        require(owners.length <= MAX_TOUCHED_ORDERS, \"Solution exceeds MAX_TOUCHED_ORDERS\");\r\n        burnPreviousAuctionFees();\r\n        undoCurrentSolution();\r\n        updateCurrentPrices(prices, tokenIdsForPrice);\r\n        delete latestSolution.trades;\r\n        int256[] memory tokenConservation = TokenConservation.init(tokenIdsForPrice);\r\n        uint256 utility = 0;\r\n        for (uint256 i = 0; i < owners.length; i++) {\r\n            Order memory order = orders[owners[i]][orderIds[i]];\r\n            require(checkOrderValidity(order, batchIndex), \"Order is invalid\");\r\n            (uint128 executedBuyAmount, uint128 executedSellAmount) = getTradedAmounts(buyVolumes[i], order);\r\n            require(executedBuyAmount >= AMOUNT_MINIMUM, \"buy amount less than AMOUNT_MINIMUM\");\r\n            require(executedSellAmount >= AMOUNT_MINIMUM, \"sell amount less than AMOUNT_MINIMUM\");\r\n            tokenConservation.updateTokenConservation(\r\n                order.buyToken,\r\n                order.sellToken,\r\n                tokenIdsForPrice,\r\n                executedBuyAmount,\r\n                executedSellAmount\r\n            );\r\n            require(getRemainingAmount(order) >= executedSellAmount, \"executedSellAmount bigger than specified in order\");\r\n            // Ensure executed price is not lower than the order price:\r\n            //       executedSellAmount / executedBuyAmount <= order.priceDenominator / order.priceNumerator\r\n            require(\r\n                executedSellAmount.mul(order.priceNumerator) <= executedBuyAmount.mul(order.priceDenominator),\r\n                \"limit price not satisfied\"\r\n            );\r\n            // accumulate utility before updateRemainingOrder, but after limitPrice verified!\r\n            utility = utility.add(evaluateUtility(executedBuyAmount, order));\r\n            updateRemainingOrder(owners[i], orderIds[i], executedSellAmount);\r\n            addBalanceAndBlockWithdrawForThisBatch(owners[i], tokenIdToAddressMap(order.buyToken), executedBuyAmount);\r\n            emit Trade(owners[i], orderIds[i], executedSellAmount, executedBuyAmount);\r\n        }\r\n        // Perform all subtractions after additions to avoid negative values\r\n        for (uint256 i = 0; i < owners.length; i++) {\r\n            Order memory order = orders[owners[i]][orderIds[i]];\r\n            (, uint128 executedSellAmount) = getTradedAmounts(buyVolumes[i], order);\r\n            subtractBalance(owners[i], tokenIdToAddressMap(order.sellToken), executedSellAmount);\r\n        }\r\n        uint256 disregardedUtility = 0;\r\n        for (uint256 i = 0; i < owners.length; i++) {\r\n            disregardedUtility = disregardedUtility.add(evaluateDisregardedUtility(orders[owners[i]][orderIds[i]], owners[i]));\r\n        }\r\n        uint256 burntFees = uint256(tokenConservation.feeTokenImbalance()) / 2;\r\n        // burntFees ensures direct trades (when available) yield better solutions than longer rings\r\n        uint256 objectiveValue = utility.add(burntFees).sub(disregardedUtility);\r\n        checkAndOverrideObjectiveValue(objectiveValue);\r\n        grantRewardToSolutionSubmitter(burntFees);\r\n        tokenConservation.checkTokenConservation();\r\n        documentTrades(batchIndex, owners, orderIds, buyVolumes, tokenIdsForPrice);\r\n        return (objectiveValue);\r\n    }\r\n    /**\r\n     * Public View Methods\r\n     */\r\n\r\n    /** @dev View returning ID of listed tokens\r\n      * @param addr address of listed token.\r\n      * @return tokenId as stored within the contract.\r\n      */\r\n    function tokenAddressToIdMap(address addr) public view returns (uint16) {\r\n        return IdToAddressBiMap.getId(registeredTokens, addr);\r\n    }\r\n\r\n    /** @dev View returning address of listed token by ID\r\n      * @param id tokenId as stored, via BiMap, within the contract.\r\n      * @return address of (listed) token\r\n      */\r\n    function tokenIdToAddressMap(uint16 id) public view returns (address) {\r\n        return IdToAddressBiMap.getAddressAt(registeredTokens, id);\r\n    }\r\n\r\n    /** @dev View returning a bool attesting whether token was already added\r\n      * @param addr address of the token to be checked\r\n      * @return bool attesting whether token was already added\r\n      */\r\n    function hasToken(address addr) public view returns (bool) {\r\n        return IdToAddressBiMap.hasAddress(registeredTokens, addr);\r\n    }\r\n\r\n    /** @dev View returning all byte-encoded sell orders for specified user\r\n      * @param user address of user whose orders are being queried\r\n      * @return encoded bytes representing all orders\r\n      */\r\n    function getEncodedUserOrders(address user) public view returns (bytes memory elements) {\r\n        for (uint256 i = 0; i < orders[user].length; i++) {\r\n            elements = elements.concat(\r\n                encodeAuctionElement(user, getBalance(user, tokenIdToAddressMap(orders[user][i].sellToken)), orders[user][i])\r\n            );\r\n        }\r\n        return elements;\r\n    }\r\n\r\n    /** @dev View returning all byte-encoded sell orders\r\n      * @return encoded bytes representing all orders ordered by (user, index)\r\n      */\r\n    function getEncodedOrders() public view returns (bytes memory elements) {\r\n        if (allUsers.size() > 0) {\r\n            address user = allUsers.first();\r\n            bool stop = false;\r\n            while (!stop) {\r\n                elements = elements.concat(getEncodedUserOrders(user));\r\n                if (user == allUsers.last) {\r\n                    stop = true;\r\n                } else {\r\n                    user = allUsers.next(user);\r\n                }\r\n            }\r\n        }\r\n        return elements;\r\n    }\r\n\r\n    function acceptingSolutions(uint32 batchIndex) public view returns (bool) {\r\n        return batchIndex == getCurrentBatchId() - 1 && getSecondsRemainingInBatch() >= 1 minutes;\r\n    }\r\n\r\n    /** @dev gets the objective value of currently winning solution.\r\n      * @return objective function evaluation of the currently winning solution, or zero if no solution proposed.\r\n      */\r\n    function getCurrentObjectiveValue() public view returns (uint256) {\r\n        if (latestSolution.batchId == getCurrentBatchId() - 1) {\r\n            return latestSolution.objectiveValue;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n    /**\r\n     * Private Functions\r\n     */\r\n\r\n    function placeOrderInternal(\r\n        uint16 buyToken,\r\n        uint16 sellToken,\r\n        uint32 validFrom,\r\n        uint32 validUntil,\r\n        uint128 buyAmount,\r\n        uint128 sellAmount\r\n    ) private returns (uint256) {\r\n        require(buyToken != sellToken, \"Exchange tokens not distinct\");\r\n        require(validFrom >= getCurrentBatchId(), \"Orders can't be placed in the past\");\r\n        orders[msg.sender].push(\r\n            Order({\r\n                buyToken: buyToken,\r\n                sellToken: sellToken,\r\n                validFrom: validFrom,\r\n                validUntil: validUntil,\r\n                priceNumerator: buyAmount,\r\n                priceDenominator: sellAmount,\r\n                usedAmount: 0\r\n            })\r\n        );\r\n        uint256 orderIndex = orders[msg.sender].length - 1;\r\n        emit OrderPlacement(msg.sender, orderIndex, buyToken, sellToken, validFrom, validUntil, buyAmount, sellAmount);\r\n        allUsers.insert(msg.sender);\r\n        return orderIndex;\r\n    }\r\n\r\n    /** @dev called at the end of submitSolution with a value of tokenConservation / 2\r\n      * @param feeReward amount to be rewarded to the solver\r\n      */\r\n    function grantRewardToSolutionSubmitter(uint256 feeReward) private {\r\n        latestSolution.feeReward = feeReward;\r\n        addBalanceAndBlockWithdrawForThisBatch(msg.sender, tokenIdToAddressMap(0), feeReward);\r\n    }\r\n\r\n    /** @dev called during solution submission to burn fees from previous auction\r\n      */\r\n    function burnPreviousAuctionFees() private {\r\n        if (!currentBatchHasSolution()) {\r\n            feeToken.burnOWL(address(this), latestSolution.feeReward);\r\n        }\r\n    }\r\n\r\n    /** @dev Called from within submitSolution to update the token prices.\r\n      * @param prices list of prices for touched tokens only, first price is always fee token price\r\n      * @param tokenIdsForPrice price[i] is the price for the token with tokenID tokenIdsForPrice[i]\r\n      */\r\n    function updateCurrentPrices(uint128[] memory prices, uint16[] memory tokenIdsForPrice) private {\r\n        for (uint256 i = 0; i < latestSolution.tokenIdsForPrice.length; i++) {\r\n            currentPrices[latestSolution.tokenIdsForPrice[i]] = 0;\r\n        }\r\n        for (uint256 i = 0; i < tokenIdsForPrice.length; i++) {\r\n            currentPrices[tokenIdsForPrice[i]] = prices[i];\r\n        }\r\n    }\r\n\r\n    /** @dev Updates an order's remaing requested sell amount upon (partial) execution of a standing order\r\n      * @param owner order's corresponding user address\r\n      * @param orderId index of order in list of owner's orders\r\n      * @param executedAmount proportion of order's requested sellAmount that was filled.\r\n      */\r\n    function updateRemainingOrder(address owner, uint256 orderId, uint128 executedAmount) private {\r\n        orders[owner][orderId].usedAmount = orders[owner][orderId].usedAmount.add(executedAmount).toUint128();\r\n    }\r\n\r\n    /** @dev The inverse of updateRemainingOrder, called when reverting a solution in favour of a better one.\r\n      * @param owner order's corresponding user address\r\n      * @param orderId index of order in list of owner's orders\r\n      * @param executedAmount proportion of order's requested sellAmount that was filled.\r\n      */\r\n    function revertRemainingOrder(address owner, uint256 orderId, uint128 executedAmount) private {\r\n        orders[owner][orderId].usedAmount = orders[owner][orderId].usedAmount.sub(executedAmount).toUint128();\r\n    }\r\n\r\n    /** @dev This function writes solution information into contract storage\r\n      * @param batchIndex index of referenced auction\r\n      * @param owners array of addresses corresponding to touched orders\r\n      * @param orderIds array of order ids used in parallel with owners to identify touched order\r\n      * @param volumes executed buy amounts for each order identified by index of owner-orderId arrays\r\n      * @param tokenIdsForPrice price[i] is the price for the token with tokenID tokenIdsForPrice[i]\r\n      */\r\n    function documentTrades(\r\n        uint32 batchIndex,\r\n        address[] memory owners,\r\n        uint16[] memory orderIds,\r\n        uint128[] memory volumes,\r\n        uint16[] memory tokenIdsForPrice\r\n    ) private {\r\n        latestSolution.batchId = batchIndex;\r\n        for (uint256 i = 0; i < owners.length; i++) {\r\n            latestSolution.trades.push(TradeData({owner: owners[i], orderId: orderIds[i], volume: volumes[i]}));\r\n        }\r\n        latestSolution.tokenIdsForPrice = tokenIdsForPrice;\r\n        latestSolution.solutionSubmitter = msg.sender;\r\n    }\r\n\r\n    /** @dev reverts all relevant contract storage relating to an overwritten auction solution.\r\n      */\r\n    function undoCurrentSolution() private {\r\n        if (currentBatchHasSolution()) {\r\n            for (uint256 i = 0; i < latestSolution.trades.length; i++) {\r\n                address owner = latestSolution.trades[i].owner;\r\n                uint256 orderId = latestSolution.trades[i].orderId;\r\n                Order memory order = orders[owner][orderId];\r\n                (, uint128 sellAmount) = getTradedAmounts(latestSolution.trades[i].volume, order);\r\n                addBalance(owner, tokenIdToAddressMap(order.sellToken), sellAmount);\r\n            }\r\n            for (uint256 i = 0; i < latestSolution.trades.length; i++) {\r\n                address owner = latestSolution.trades[i].owner;\r\n                uint256 orderId = latestSolution.trades[i].orderId;\r\n                Order memory order = orders[owner][orderId];\r\n                (uint128 buyAmount, uint128 sellAmount) = getTradedAmounts(latestSolution.trades[i].volume, order);\r\n                revertRemainingOrder(owner, orderId, sellAmount);\r\n                subtractBalance(owner, tokenIdToAddressMap(order.buyToken), buyAmount);\r\n                emit TradeReversion(owner, orderId, sellAmount, buyAmount);\r\n            }\r\n            // subtract granted fees:\r\n            subtractBalance(latestSolution.solutionSubmitter, tokenIdToAddressMap(0), latestSolution.feeReward);\r\n        }\r\n    }\r\n\r\n    /** @dev determines if value is better than currently and updates if it is.\r\n      * @param newObjectiveValue proposed value to be updated if a great enough improvement on the current objective value\r\n      */\r\n    function checkAndOverrideObjectiveValue(uint256 newObjectiveValue) private {\r\n        require(\r\n            isObjectiveValueSufficientlyImproved(newObjectiveValue),\r\n            \"New objective doesn't sufficiently improve current solution\"\r\n        );\r\n        latestSolution.objectiveValue = newObjectiveValue;\r\n    }\r\n\r\n    // Private view\r\n    /** @dev Evaluates utility of executed trade\r\n      * @param execBuy represents proportion of order executed (in terms of buy amount)\r\n      * @param order the sell order whose utility is being evaluated\r\n      * @return Utility = ((execBuy * order.sellAmt - execSell * order.buyAmt) * price.buyToken) / order.sellAmt\r\n      */\r\n    function evaluateUtility(uint128 execBuy, Order memory order) private view returns (uint256) {\r\n        // Utility = ((execBuy * order.sellAmt - execSell * order.buyAmt) * price.buyToken) / order.sellAmt\r\n        uint256 execSellTimesBuy = getExecutedSellAmount(execBuy, currentPrices[order.buyToken], currentPrices[order.sellToken])\r\n            .mul(order.priceNumerator);\r\n\r\n        uint256 roundedUtility = execBuy.sub(execSellTimesBuy.div(order.priceDenominator)).mul(currentPrices[order.buyToken]);\r\n        uint256 utilityError = execSellTimesBuy.mod(order.priceDenominator).mul(currentPrices[order.buyToken]).div(\r\n            order.priceDenominator\r\n        );\r\n        return roundedUtility.sub(utilityError).toUint128();\r\n    }\r\n\r\n    /** @dev computes a measure of how much of an order was disregarded (only valid when limit price is respected)\r\n      * @param order the sell order whose disregarded utility is being evaluated\r\n      * @param user address of order's owner\r\n      * @return disregardedUtility of the order (after it has been applied)\r\n      * Note that:\r\n      * |disregardedUtility| = (limitTerm * leftoverSellAmount) / order.sellAmount\r\n      * where limitTerm = price.SellToken * order.sellAmt - order.buyAmt * price.buyToken * (1 - phi)\r\n      * and leftoverSellAmount = order.sellAmt - execSellAmt\r\n      * Balances and orders have all been updated so: sellAmount - execSellAmt == remainingAmount(order).\r\n      * For correctness, we take the minimum of this with the user's token balance.\r\n      */\r\n    function evaluateDisregardedUtility(Order memory order, address user) private view returns (uint256) {\r\n        uint256 leftoverSellAmount = Math.min(getRemainingAmount(order), getBalance(user, tokenIdToAddressMap(order.sellToken)));\r\n        uint256 limitTermLeft = currentPrices[order.sellToken].mul(order.priceDenominator);\r\n        uint256 limitTermRight = order.priceNumerator.mul(currentPrices[order.buyToken]).mul(feeDenominator).div(\r\n            feeDenominator - 1\r\n        );\r\n        uint256 limitTerm = 0;\r\n        if (limitTermLeft > limitTermRight) {\r\n            limitTerm = limitTermLeft.sub(limitTermRight);\r\n        }\r\n        return leftoverSellAmount.mul(limitTerm).div(order.priceDenominator).toUint128();\r\n    }\r\n\r\n    /** @dev Evaluates executedBuy amount based on prices and executedBuyAmout (fees included)\r\n      * @param executedBuyAmount amount of buyToken executed for purchase in batch auction\r\n      * @param buyTokenPrice uniform clearing price of buyToken\r\n      * @param sellTokenPrice uniform clearing price of sellToken\r\n      * @return executedSellAmount as expressed in Equation (2)\r\n      * https://github.com/gnosis/dex-contracts/issues/173#issuecomment-526163117\r\n      * execSellAmount * p[sellToken] * (1 - phi) == execBuyAmount * p[buyToken]\r\n      * where phi = 1/feeDenominator\r\n      * Note that: 1 - phi = (feeDenominator - 1) / feeDenominator\r\n      * And so, 1/(1-phi) = feeDenominator / (feeDenominator - 1)\r\n      * execSellAmount = (execBuyAmount * p[buyToken]) / (p[sellToken] * (1 - phi))\r\n      *                = (execBuyAmount * buyTokenPrice / sellTokenPrice) * feeDenominator / (feeDenominator - 1)\r\n      * in order to minimize rounding errors, the order of operations is switched\r\n      *                = ((executedBuyAmount * buyTokenPrice) / (feeDenominator - 1)) * feeDenominator) / sellTokenPrice\r\n      */\r\n    function getExecutedSellAmount(uint128 executedBuyAmount, uint128 buyTokenPrice, uint128 sellTokenPrice)\r\n        private\r\n        view\r\n        returns (uint128)\r\n    {\r\n        return\r\n            uint256(executedBuyAmount)\r\n                .mul(buyTokenPrice)\r\n                .div(feeDenominator - 1)\r\n                .mul(feeDenominator)\r\n                .div(sellTokenPrice)\r\n                .toUint128();\r\n    }\r\n\r\n    /** @dev used to determine if solution if first provided in current batch\r\n      * @return true if `latestSolution` is storing a solution for current batch, else false\r\n      */\r\n    function currentBatchHasSolution() private view returns (bool) {\r\n        return latestSolution.batchId == getCurrentBatchId() - 1;\r\n    }\r\n\r\n    // Private view\r\n    /** @dev Compute trade execution based on executedBuyAmount and relevant token prices\r\n      * @param executedBuyAmount executed buy amount\r\n      * @param order contains relevant buy-sell token information\r\n      * @return (executedBuyAmount, executedSellAmount)\r\n      */\r\n    function getTradedAmounts(uint128 executedBuyAmount, Order memory order) private view returns (uint128, uint128) {\r\n        uint128 executedSellAmount = getExecutedSellAmount(\r\n            executedBuyAmount,\r\n            currentPrices[order.buyToken],\r\n            currentPrices[order.sellToken]\r\n        );\r\n        return (executedBuyAmount, executedSellAmount);\r\n    }\r\n\r\n    /** @dev Checks that the proposed objective value is a significant enough improvement on the latest one\r\n      * @param objectiveValue the proposed objective value to check\r\n      * @return true if the objectiveValue is a significant enough improvement, false otherwise\r\n      */\r\n    function isObjectiveValueSufficientlyImproved(uint256 objectiveValue) private view returns (bool) {\r\n        return (objectiveValue.mul(IMPROVEMENT_DENOMINATOR) > getCurrentObjectiveValue().mul(IMPROVEMENT_DENOMINATOR + 1));\r\n    }\r\n\r\n    // Private pure\r\n    /** @dev used to determine if an order is valid for specific auction/batch\r\n      * @param order object whose validity is in question\r\n      * @param batchIndex auction index of validity\r\n      * @return true if order is valid in auction batchIndex else false\r\n      */\r\n    function checkOrderValidity(Order memory order, uint256 batchIndex) private pure returns (bool) {\r\n        return order.validFrom <= batchIndex && order.validUntil >= batchIndex;\r\n    }\r\n\r\n    /** @dev computes the remaining sell amount for a given order\r\n      * @param order the order for which remaining amount should be calculated\r\n      * @return the remaining sell amount\r\n      */\r\n    function getRemainingAmount(Order memory order) private pure returns (uint128) {\r\n        return order.priceDenominator - order.usedAmount;\r\n    }\r\n\r\n    /** @dev called only by getEncodedOrders and used to pack auction info into bytes\r\n      * @param user list of tokenIds\r\n      * @param sellTokenBalance user's account balance of sell token\r\n      * @param order a sell order\r\n      * @return byte encoded, packed, concatenation of relevant order information\r\n      */\r\n    function encodeAuctionElement(address user, uint256 sellTokenBalance, Order memory order)\r\n        private\r\n        pure\r\n        returns (bytes memory element)\r\n    {\r\n        element = abi.encodePacked(user);\r\n        element = element.concat(abi.encodePacked(sellTokenBalance));\r\n        element = element.concat(abi.encodePacked(order.buyToken));\r\n        element = element.concat(abi.encodePacked(order.sellToken));\r\n        element = element.concat(abi.encodePacked(order.validFrom));\r\n        element = element.concat(abi.encodePacked(order.validUntil));\r\n        element = element.concat(abi.encodePacked(order.priceNumerator));\r\n        element = element.concat(abi.encodePacked(order.priceDenominator));\r\n        element = element.concat(abi.encodePacked(getRemainingAmount(order)));\r\n        return element;\r\n    }\r\n\r\n    /** @dev determines if value is better than currently and updates if it is.\r\n      * @param amounts array of values to be verified with AMOUNT_MINIMUM\r\n      */\r\n    function verifyAmountThreshold(uint128[] memory amounts) private pure returns (bool) {\r\n        for (uint256 i = 0; i < amounts.length; i++) {\r\n            if (amounts[i] < AMOUNT_MINIMUM) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"IMPROVEMENT_DENOMINATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSecondsRemainingInBatch\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeDenominator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEncodedOrders\",\"outputs\":[{\"name\":\"elements\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyToken\",\"type\":\"uint16\"},{\"name\":\"sellToken\",\"type\":\"uint16\"},{\"name\":\"validUntil\",\"type\":\"uint32\"},{\"name\":\"buyAmount\",\"type\":\"uint128\"},{\"name\":\"sellAmount\",\"type\":\"uint128\"}],\"name\":\"placeOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"batchIndex\",\"type\":\"uint32\"},{\"name\":\"claimedObjectiveValue\",\"type\":\"uint256\"},{\"name\":\"owners\",\"type\":\"address[]\"},{\"name\":\"orderIds\",\"type\":\"uint16[]\"},{\"name\":\"buyVolumes\",\"type\":\"uint128[]\"},{\"name\":\"prices\",\"type\":\"uint128[]\"},{\"name\":\"tokenIdsForPrice\",\"type\":\"uint16[]\"}],\"name\":\"submitSolution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint16\"}],\"name\":\"tokenIdToAddressMap\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"requestWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEE_FOR_LISTING_TOKEN_IN_OWL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AMOUNT_MINIMUM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyTokens\",\"type\":\"uint16[]\"},{\"name\":\"sellTokens\",\"type\":\"uint16[]\"},{\"name\":\"validFroms\",\"type\":\"uint32[]\"},{\"name\":\"validUntils\",\"type\":\"uint32[]\"},{\"name\":\"buyAmounts\",\"type\":\"uint128[]\"},{\"name\":\"sellAmounts\",\"type\":\"uint128[]\"}],\"name\":\"placeValidFromOrders\",\"outputs\":[{\"name\":\"orderIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"currentPrices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getEncodedUserOrders\",\"outputs\":[{\"name\":\"elements\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orders\",\"outputs\":[{\"name\":\"buyToken\",\"type\":\"uint16\"},{\"name\":\"sellToken\",\"type\":\"uint16\"},{\"name\":\"validFrom\",\"type\":\"uint32\"},{\"name\":\"validUntil\",\"type\":\"uint32\"},{\"name\":\"priceNumerator\",\"type\":\"uint128\"},{\"name\":\"priceDenominator\",\"type\":\"uint128\"},{\"name\":\"usedAmount\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastCreditBatchId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"hasToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestSolution\",\"outputs\":[{\"name\":\"batchId\",\"type\":\"uint32\"},{\"name\":\"solutionSubmitter\",\"type\":\"address\"},{\"name\":\"feeReward\",\"type\":\"uint256\"},{\"name\":\"objectiveValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getPendingDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"cancelOrders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getPendingWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"batchIndex\",\"type\":\"uint32\"}],\"name\":\"acceptingSolutions\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"addToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cancellations\",\"type\":\"uint256[]\"},{\"name\":\"buyTokens\",\"type\":\"uint16[]\"},{\"name\":\"sellTokens\",\"type\":\"uint16[]\"},{\"name\":\"validFroms\",\"type\":\"uint32[]\"},{\"name\":\"validUntils\",\"type\":\"uint32[]\"},{\"name\":\"buyAmounts\",\"type\":\"uint128[]\"},{\"name\":\"sellAmounts\",\"type\":\"uint128[]\"}],\"name\":\"replaceOrders\",\"outputs\":[{\"name\":\"orderIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BATCH_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentBatchId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"tokenAddressToIdMap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"batchId\",\"type\":\"uint32\"}],\"name\":\"requestFutureWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"hasValidWithdrawRequest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TOKENS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TOUCHED_ORDERS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentObjectiveValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"maxTokens\",\"type\":\"uint256\"},{\"name\":\"_feeDenominator\",\"type\":\"uint128\"},{\"name\":\"_feeToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyToken\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"sellToken\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"validFrom\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"validUntil\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"priceNumerator\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"priceDenominator\",\"type\":\"uint128\"}],\"name\":\"OrderPlacement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"OrderCancelation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"OrderDeletion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"orderIds\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"executedSellAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"executedBuyAmount\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"orderIds\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"executedSellAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"executedBuyAmount\",\"type\":\"uint256\"}],\"name\":\"TradeReversion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stateIndex\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stateIndex\",\"type\":\"uint256\"}],\"name\":\"WithdrawRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"}]","ContractName":"BatchExchange","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000ffff00000000000000000000000000000000000000000000000000000000000003e80000000000000000000000001a5f9352af8af974bfc03399e3767df6370d82e4","Library":"IdToAddressBiMap:aebd846a05eadfe42db884805e6ac99f32e8af43;IterableAppendOnlySet:cddb32b6bb2808d5b5115daab207479ce98d2636","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://d75d8f06b335b5c4398c51039c6bbb9a0b7d2e34f3a8a69428935ad3326899cb"}]}