{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.13;\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n/**\n * @title Synthetix Grants DAO\n * @notice This contract allows for grants to be proposed and voted on by community members\n * and the Synthetix team. All proposals must receive at least one approving vote by a\n * Synthetix member before funds will transfer.\n */\ncontract GrantsDAO {\n\n  using SafeMath for uint256;\n\n  uint256 public constant VOTING_PHASE = 9 days;\n  uint256 public toPass;\n  uint256 public counter = 1;\n\n  IERC20 public SNX;\n\n  struct Proposal {\n    bool teamApproval;\n    address receiver;\n    uint256 amount;\n    uint256 createdAt;\n    uint256 approvals;\n    string description;\n    string url;\n    mapping(address => bool) voted;\n  }\n\n  mapping(uint256 => Proposal) public proposals;\n  mapping(uint256 => Proposal) public completeProposals;\n  mapping(address => bool) public teamMembers;\n  mapping(address => bool) public communityMembers;\n\n  address[] private teamAddresses;\n  address[] private communityAddresses;\n  uint256[] private validProposals;\n  uint256[] private completeProposalIds;\n\n  event NewProposal(address receiver, uint256 amount, uint256 proposalNumber);\n  event VoteProposal(uint256 proposal, address member, bool vote);\n  event ExecuteProposal(address receiver, uint256 amount);\n  event DeleteProposal(uint256 proposalNumber);\n\n  /**\n   * @notice Contract is created with an initial array of team and community members\n   * which will be stored in mappings\n   * @param _snx The address of the SNX token\n   * @param _teamMembers An array of addresses for the team members\n   * @param _communityMembers An array of addresses for the community members\n   * @param _toPass The number of votes each proposal is required in order to execute\n   */\n  constructor(\n    address _snx,\n    address[] memory _teamMembers,\n    address[] memory _communityMembers,\n    uint256 _toPass\n  ) public {\n    require(_teamMembers.length > 0, \"Need at least one teamMember\");\n    require(_toPass <= (_teamMembers.length + _communityMembers.length), \"Invalid value to pass proposals\");\n\n    // Add members to their respective mappings and increase members count\n    for (uint i = 0; i < _teamMembers.length; i++) {\n      teamMembers[_teamMembers[i]] = true;\n      teamAddresses.push(_teamMembers[i]);\n    }\n    for (uint i = 0; i < _communityMembers.length; i++) {\n      communityMembers[_communityMembers[i]] = true;\n      communityAddresses.push(_communityMembers[i]);\n    }\n\n    toPass = _toPass;\n    SNX = IERC20(_snx);\n  }\n\n  /**\n   * @notice Called by proposers (team or community) to propose funding for an address.\n   * Emits NewProposal event.\n   * @param _receiver The address to receive funds if proposal executes\n   * @param _amount The amount that the receiver will receive\n   * @param _description The description of the proposal\n   * @return The proposal number for reference\n   */\n  function createProposal(\n    address _receiver,\n    uint256 _amount,\n    string calldata _description,\n    string calldata _url\n  ) external onlyProposer() returns (uint256) {\n    require(_amount > 0, \"Amount must be greater than 0\");\n    require(_receiver != address(0), \"Receiver cannot be zero address\");\n\n    uint256 _counter = counter; // Pull counter into memory to save gas\n    counter = _counter.add(1);\n\n    proposals[_counter] = Proposal(\n      false,\n      _receiver,\n      _amount,\n      block.timestamp,\n      1,\n      _description,\n      _url\n    );\n\n    // If a proposal is created by a team member, mark it as approved by the team\n    if (teamMembers[msg.sender]) {\n      proposals[_counter].teamApproval = true;\n    }\n\n    proposals[_counter].voted[msg.sender] = true;\n    validProposals.push(_counter);\n\n    emit NewProposal(_receiver, _amount, _counter);\n\n    return _counter;\n  }\n\n  /**\n   * @notice Called by proposers (team or community) to vote for a specified proposal.\n   * Emits VoteProposal event.\n   * @param _proposal The proposal number to vote on\n   * @param _vote Boolean to indicate whether or not they approve of the proposal\n   */\n  function voteProposal(uint256 _proposal, bool _vote) external onlyProposer() {\n    require(votingPhase(_proposal), \"Proposal not in voting phase\");\n    require(!proposals[_proposal].voted[msg.sender], \"Already voted\");\n    proposals[_proposal].voted[msg.sender] = true;\n\n    if (_vote) {\n      if (teamMembers[msg.sender]) {\n        proposals[_proposal].teamApproval = true;\n      }\n      proposals[_proposal].approvals = proposals[_proposal].approvals.add(1);\n\n      // Only execute if enough approvals AND the proposal has at least one teamApproval\n      if (proposals[_proposal].approvals >= toPass && proposals[_proposal].teamApproval) {\n        _executeProposal(_proposal);\n      }\n    } else {\n      // Allows a team member to automatically kill a proposal\n      if (teamMembers[msg.sender]) {\n        _deleteProposal(_proposal);\n        // Do not emit VoteProposal if deleting\n        return;\n      }\n    }\n\n    emit VoteProposal(_proposal, msg.sender, _vote);\n  }\n\n  /**\n   * @notice Called by proposers to clean up storage and unlock funds.\n   * Emits DeleteProposal event.\n   * @param _proposal The proposal number to delete\n   */\n  function deleteProposal(uint256 _proposal) external onlyProposer() {\n    require(block.timestamp > proposals[_proposal].createdAt.add(VOTING_PHASE), \"Proposal not expired\");\n    _deleteProposal(_proposal);\n  }\n\n  /**\n   * @notice Returns the addresses for the active community members\n   * @return Array of community member addresses\n   */\n  function getCommunityMembers() external view returns (address[] memory) {\n    return communityAddresses;\n  }\n\n  /**\n   * @notice Gets the addresses for the active team members\n   * @return Array of team member addresses\n   */\n  function getTeamMembers() external view returns (address[] memory) {\n    return teamAddresses;\n  }\n\n  /**\n   * @notice Gets the proposal IDs of active proposals\n   * @return Unsorted array of proposal IDs\n   */\n  function getProposals() external view returns (uint256[] memory) {\n    return validProposals;\n  }\n\n  /**\n   * @notice Gets the proposal IDs of complete proposals\n   * @return Unsorted array of proposal IDs\n   */\n  function getCompleteProposals() external view returns (uint256[] memory) {\n    return completeProposalIds;\n  }\n\n  /**\n   * @notice Called by team members to withdraw extra tokens in the contract\n   * @param _receiver The address to receive tokens\n   * @param _amount The amount to withdraw\n   */\n  function withdraw(address _receiver, uint256 _amount) external onlyTeamMember() {\n    require(_amount <= withdrawable(), \"Unable to withdraw amount\");\n    assert(SNX.transfer(_receiver, _amount));\n  }\n\n  /**\n  * @notice Allows team members to withdraw any tokens from the contract\n  * @param _receiver The address to receive tokens\n  * @param _amount The amount to withdraw\n  * @param _erc20 The address of the ERC20 token being transferred\n  *\n  */\n  function withdrawERC20(address _receiver, uint256 _amount, address _erc20) external onlyTeamMember() {\n    if (_erc20 == address(SNX)) {\n      require(_amount <= withdrawable(), \"Unable to withdraw amount\");\n    }\n    assert(IERC20(_erc20).transfer(_receiver, _amount));\n  }\n\n  /**\n   * @notice Allows community members to be added as proposers and voters\n   * @param _member The address of the community member\n   */\n  function addCommunityMember(address _member) external onlyTeamMember() {\n    communityMembers[_member] = true;\n    communityAddresses.push(_member);\n  }\n\n  /**\n   * @notice Allows community members to be removed\n   * @dev The caller can specify an array of proposals to have the member's vote removed\n   * @param _member The address of the community member\n   * @param _proposals The array of proposals to have the member's vote removed from\n   */\n  function removeCommunityMember(address _member, uint256[] calldata _proposals) external onlyTeamMember() {\n    delete communityMembers[_member];\n    for (uint i = 0; i < communityAddresses.length; i++) {\n      if (communityAddresses[i] == _member) {\n        communityAddresses[i] = communityAddresses[communityAddresses.length - 1];\n        communityAddresses.length--;\n      }\n    }\n    for (uint i = 0; i < _proposals.length; i++) {\n      require(proposals[_proposals[i]].voted[_member], \"Member did not vote for proposal\");\n      delete proposals[_proposals[i]].voted[_member];\n      proposals[_proposals[i]].approvals = proposals[_proposals[i]].approvals.sub(1);\n    }\n  }\n\n  /**\n   * @notice Allows team members to be added\n   * @param _member The address of the team member\n   */\n  function addTeamMember(address _member) external onlyTeamMember() {\n    teamMembers[_member] = true;\n    teamAddresses.push(_member);\n  }\n\n  /**\n   * @notice Allows team members to be removed\n   * @param _member The address of the team member\n   */\n  function removeTeamMember(address _member) external onlyTeamMember() {\n    // Prevents the possibility of there being no team members\n    require(msg.sender != _member, \"Cannot remove self\");\n    delete teamMembers[_member];\n    for (uint i = 0; i < teamAddresses.length; i++) {\n      if (teamAddresses[i] == _member) {\n        teamAddresses[i] = teamAddresses[teamAddresses.length - 1];\n        teamAddresses.length--;\n      }\n    }\n  }\n\n  /**\n   * @notice Allows the number of votes required to pass a proposal to be updated\n   * @param _toPass The new value for the number of votes to pass a proposal\n   */\n  function updateToPass(uint256 _toPass) external onlyTeamMember() {\n    require(_toPass > 0, \"Invalid value to pass proposals\");\n    toPass = _toPass;\n  }\n\n  /**\n  * @notice Allows team members to update the SNX proxy address being used\n  * @param _proxy The new proxy address to be used\n  */\n  function updateProxyAddress(address _proxy) external onlyTeamMember() {\n    require(_proxy != address(SNX), \"Cannot set proxy address to the current proxy address\");\n    SNX = IERC20(_proxy);\n  }\n\n  /**\n   * @notice Shows the balance of the contract which can be withdrawn by team members\n   * @return The withdrawable balance\n   */\n  function withdrawable() public view returns (uint256) {\n    return SNX.balanceOf(address(this));\n  }\n\n  /**\n   * @notice Displays the total balance of the contract\n   * @return The balance of the contract\n   */\n  function totalBalance() external view returns (uint256) {\n    return SNX.balanceOf(address(this));\n  }\n\n  /**\n   * @notice Checks to see whether an address has voted on a proposal\n   * @return Boolean indicating if the address has voted\n   */\n  function voted(address _member, uint256 _proposal) external view returns (bool) {\n    return proposals[_proposal].voted[_member];\n  }\n\n  /**\n   * @notice Check to see whether a proposal is in the voting phase\n   * @param _proposal The proposal number to check\n   * @return Boolean indicating if the proposal is in the voting phase\n   */\n  function votingPhase(uint256 _proposal) public view returns (bool) {\n    uint256 createdAt = proposals[_proposal].createdAt;\n    return block.timestamp <= createdAt.add(VOTING_PHASE);\n  }\n\n  /**\n   * @dev Private method to delete a proposal\n   * @param _proposal The proposal number to delete\n   */\n  function _deleteProposal(uint256 _proposal) private {\n    delete proposals[_proposal];\n    for (uint i = 0; i < validProposals.length; i++) {\n      if (validProposals[i] == _proposal) {\n        validProposals[i] = validProposals[validProposals.length - 1];\n        validProposals.length--;\n      }\n    }\n    emit DeleteProposal(_proposal);\n  }\n\n  /**\n   * @dev Private method to execute a proposal\n   * @param _proposal The proposal number to delete\n   */\n  function _executeProposal(uint256 _proposal) private {\n    Proposal memory proposal = proposals[_proposal];\n    require(withdrawable() >= proposal.amount, \"Not enough SNX to execute proposal\");\n    completeProposalIds.push(_proposal);\n    completeProposals[_proposal] = proposal;\n    _deleteProposal(_proposal);\n    for (uint i = 0; i < validProposals.length; i++) {\n      if (validProposals[i] == _proposal) {\n        validProposals[i] = validProposals[validProposals.length - 1];\n        validProposals.length--;\n      }\n    }\n    assert(SNX.transfer(proposal.receiver, proposal.amount));\n    emit ExecuteProposal(proposal.receiver, proposal.amount);\n  }\n\n  /**\n   * @dev Reverts if caller is not a team member\n   */\n  modifier onlyTeamMember() {\n    require(teamMembers[msg.sender], \"Not team member\");\n    _;\n  }\n\n  /**\n   * @dev Reverts if caller is not a proposer (team or community member)\n   */\n  modifier onlyProposer() {\n    require(\n      teamMembers[msg.sender] ||\n      communityMembers[msg.sender],\n      \"Not proposer\"\n    );\n    _;\n  }\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_snx\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_teamMembers\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_communityMembers\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_toPass\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalNumber\",\"type\":\"uint256\"}],\"name\":\"DeleteProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ExecuteProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalNumber\",\"type\":\"uint256\"}],\"name\":\"NewProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"vote\",\"type\":\"bool\"}],\"name\":\"VoteProposal\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"SNX\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VOTING_PHASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"addCommunityMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"addTeamMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"communityMembers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"completeProposals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"teamApproval\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"approvals\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"url\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"counter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_url\",\"type\":\"string\"}],\"name\":\"createProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposal\",\"type\":\"uint256\"}],\"name\":\"deleteProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCommunityMembers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCompleteProposals\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProposals\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTeamMembers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"teamApproval\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"approvals\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"url\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_proposals\",\"type\":\"uint256[]\"}],\"name\":\"removeCommunityMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"removeTeamMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"teamMembers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"toPass\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"updateProxyAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_toPass\",\"type\":\"uint256\"}],\"name\":\"updateToPass\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposal\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_vote\",\"type\":\"bool\"}],\"name\":\"voteProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_proposal\",\"type\":\"uint256\"}],\"name\":\"voted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposal\",\"type\":\"uint256\"}],\"name\":\"votingPhase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_erc20\",\"type\":\"address\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"GrantsDAO","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000c011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000002000000000000000000000000dda03223b1341bf929551220c116d8109f819e750000000000000000000000000a69c08c7b03f5e647d72f78ac008428fac94e370000000000000000000000000000000000000000000000000000000000000003000000000000000000000000003f6b20bfa4b5cab701960ecf73859cb3c095fc000000000000000000000000a5f7a39e55d7878bc5bd754ee5d6bd7a7662355b000000000000000000000000fe072d936072107ef9ab409cc523b0753efabd01","Library":"","LicenseType":"","SwarmSource":""}]}