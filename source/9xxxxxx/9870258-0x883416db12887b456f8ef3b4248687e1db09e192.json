{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: contracts/Portal.sol\n\npragma solidity 0.5.8;\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ninterface UniswapFactoryInterface {\n    // Create Exchange\n    function createExchange(address token) external returns (address exchange);\n    // Get Exchange and Token Info\n    function getExchange(address token) external view returns (address exchange);\n    function getToken(address exchange) external view returns (address token);\n    function getTokenWithId(uint256 tokenId) external view returns (address token);\n    // Never use\n    function initializeFactory(address template) external;\n}\n\n\ninterface UniswapExchangeInterface {\n    // Address of ERC20 token sold on this exchange\n    function tokenAddress() external view returns (address token);\n    // Address of Uniswap Factory\n    function factoryAddress() external view returns (address factory);\n    // Provide Liquidity\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\n    // Get Prices\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\n    // Trade ETH to ERC20\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\n    // Trade ERC20 to ETH\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\n    // Trade ERC20 to ERC20\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\n    // Trade ERC20 to Custom Pool\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\n    // ERC20 comaptibility for liquidity tokens\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function allowance(address _owner, address _spender) external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    // Never use\n    function setup(address token_addr) external;\n}\n\ninterface Token {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (string memory);\n\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\ncontract Ownable {\n    address public _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal  {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract Pausable is Ownable {\n    /**\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\n     */\n    event Unpaused(address account);\n\n    bool _paused;\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    function pause() public onlyOwner{\n        _pause();\n    }\n\n    function unpause() public onlyOwner{\n        _unpause();\n    }\n\n\n    /**\n     * @dev Called by a pauser to pause, triggers stopped state.\n     */\n    function _pause() internal whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @dev Called by a pauser to unpause, returns to normal state.\n     */\n    function _unpause() internal whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n}\n\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\ncontract Portal is  Pausable, Initializable {\n    using SafeMath for uint256;\n    using SafeMath for uint32;\n\n    uint256 interestRate ;\n    uint256 MAX_UINT;\n    uint256 ONE_DAY ;\n    address public xioExchangeAddress ;\n    address public xioContractAddress ;\n    address public uniswapFactoryAddress ;\n    uint256 portalId;\n\n    mapping (address=>StakerData[]) public stakerData;\n    mapping (uint256=>PortalData) public portalData;\n\n    //for testing\n    uint256 ONE_MINUTE;\n    mapping (address=>bool) internal whiteListed;\n\n    //stake restriction parameters\n    uint256 stakeDays;\n    uint256 xioStakeQuantity;\n\n    struct StakerData {\n        uint256 portalId;\n        address publicKey;\n        uint256 stakeQuantity;\n        uint256 stakeDurationTimestamp;\n        uint256 stakeInitiationTimestamp;\n        string outputTokenSymbol;\n        uint256 boughAmount;\n    }\n\n    struct PortalData {\n        uint256 portalId;\n        address tokenAddress;\n        address tokenExchangeAddress;\n        string outputTokenSymbol;\n        uint256 xioStaked;\n    }\n\n    function initialize() public initializer{\n        _paused = false;\n        _owner = msg.sender;\n        interestRate = 684931506849315;\n        MAX_UINT = 2**256 - 1;\n        ONE_DAY = 24*60*60;\n        xioExchangeAddress = 0x7B6E5278a14d5318571d65aceD036d09c998C707;\n        xioContractAddress = 0x0f7F961648aE6Db43C75663aC7E5414Eb79b5704;\n        uniswapFactoryAddress = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;\n        portalId = 0;\n        ONE_MINUTE = 60;\n    }\n\n    event DataEntered(address staker, uint256  portalId, uint256 quantity); // When data is entered into the mapping\n    event Tranferred(address staker, uint256  portalId, uint256 quantity, string symbol); // When bought tokens are transferred to staker\n    event Bought(address staker, uint256  portalId, uint256 _tokensBought, string symbol); // When tokens are bought\n    event Transfer(address to, uint256 value); // When tokens are withdrawn\n\n\n    /* @dev to get interest rate of the portal */\n    function getInterestRate() public view returns(uint256){\n        return interestRate;\n    }\n\n    /* @dev to get exchange rate of XIO to ETH\n    *  @param _amount, xio amount\n    */\n    function getXIOtoETH(uint256 _amount) public view returns (uint256){\n        return UniswapExchangeInterface(xioExchangeAddress).getTokenToEthInputPrice(_amount);\n    }\n\n    /* @dev to get exchange rate of ETH to ALT\n    *  @param _amount, xio amount\n    *  @param _outputTokenAddressExchange, exchange address of output token on uniswap\n    */\n    function getETHtoALT(uint256 _amount, address _outputTokenAddressExchange) public view returns (uint256){\n        return UniswapExchangeInterface(_outputTokenAddressExchange).getEthToTokenInputPrice(_amount);\n    }\n\n    /* @dev to get array's lenght of staker data // for front end feasiblity\n    *  @param _address, address of staker\n    */\n    function getArrayLengthOfStakerData(address _address) public view returns(uint256){\n        return stakerData[_address].length;\n    }\n\n    /* @dev to get number of days in the stake condition\n    */\n    function getDays() public view returns(uint256) {\n        return stakeDays; \n    }\n\n    /* @dev to get number of xio quantity user can max stake\n    */\n    function getXIOStakeQuantity() public view returns(uint256) {\n        return xioStakeQuantity;\n    }\n\n\n    /* @dev to check if given address is contract's or not\n    *  @param _addr, public address\n    */\n    function isContract(address _addr) internal view returns (bool){\n        uint32 size;\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return (size > 0);\n    }\n\n    /* @dev to check portal if it already exists or not\n    *  @param _tokenAddress, address of output token\n    */\n    function checkPortalExists(address _tokenAddress) internal view returns (bool){\n        bool exists;\n        for(uint256 i=0; ;i++){\n            if(portalData[i].tokenAddress == address(0)){\n                exists = false;\n                break;\n            } else if(portalData[i].tokenAddress == _tokenAddress){\n                exists = true;\n                break;\n            }\n        }\n        return exists;\n    }\n\n\n    /* @dev stake function which calls uniswaps exchange to buy output tokens and send them to the user.\n    *  @param _quantity , xio token quanity user has staked (in wei)\n    *  @param _xioQuantity, xio interest generated upon the days (in wei)\n    *  @param _tokensBought, how much tokens are bought from the uniswaps exchange (in wei)\n    *  @param _portalId, portal id of the exchange.\n    *  @param _symbol, bought token symbol\n    *  @param _outputTokenAddress, bought token ERC20 address\n    *  @param _days, how much days he has staked (in days)\n    */\n    function stakeXIO( address _outputTokenAddress, uint256 _days, uint256 _xioQuantity, uint256 _tokensBought, uint256 _portalId) public whenNotPaused returns (bool) {\n\n        require(_days<=stakeDays, \"Invalid Days\");  // To check days\n        require(_xioQuantity <= xioStakeQuantity, \"Invalid XIO quantity\"); // To verify XIO quantity\n        require(_outputTokenAddress != address(0),\"0 address not allowed\"); // To verify output token address\n        require(isContract(_outputTokenAddress) != false, \"Not a contract address\"); // To verify address is contract or not\n        require(portalData[_portalId].tokenAddress != address(0), \"Portal does not exists\"); // To verify portal info\n        require(whiteListed[msg.sender] == true, \"Not whitelist address\"); //To verify whitelisters\n        require(portalData[_portalId].tokenAddress == _outputTokenAddress, \"Wrong portal\"); //To check correct portal\n\n        // stakerData[msg.sender].push(StakerData(_portalId, msg.sender, _xioQuantity, _days.mul(ONE_MINUTE), block.timestamp, portalData[_portalId].outputTokenSymbol));\n\n        emit DataEntered(msg.sender,_portalId,_xioQuantity);\n\n        portalData[_portalId].xioStaked = portalData[_portalId].xioStaked.add(_xioQuantity)  ;\n\n        Token(xioContractAddress).transferFrom(msg.sender, address(this),_xioQuantity);\n\n        uint256 soldXIO = (_xioQuantity.mul(interestRate).mul(_days)).div(1000000000000000000);\n\n        uint256 bought = UniswapExchangeInterface(xioExchangeAddress).tokenToTokenSwapInput(soldXIO,_tokensBought,1,1839591241,_outputTokenAddress);\n\n        stakerData[msg.sender].push(StakerData(_portalId, msg.sender, _xioQuantity, _days.mul(ONE_DAY), block.timestamp, portalData[_portalId].outputTokenSymbol, bought));\n\n        if(bought > 0){\n            emit Bought(msg.sender,_portalId,bought,portalData[_portalId].outputTokenSymbol);\n            Token(portalData[_portalId].tokenAddress).transfer(msg.sender,bought);\n            emit Tranferred(msg.sender,_portalId,bought,portalData[_portalId].outputTokenSymbol);\n            return true;\n        }\n        return false;\n    }\n\n    /* @dev withdrwal function by which user can withdraw their staked xio\n    *  @param _amount , xio token quanity user has staked (in wei)\n    */\n    function withdrawXIO(uint256 _amount) public whenNotPaused {\n        require(_amount>0, \"Amount should be greater than 0\");\n        uint256 withdrawAmount = 0;\n        StakerData[] storage stakerArray= stakerData[msg.sender];\n        for(uint256 i=0; i<stakerArray.length;i++){\n            if((stakerArray[i].stakeInitiationTimestamp.add(stakerArray[i].stakeDurationTimestamp)  <= block.timestamp) && (stakerArray[i].publicKey != address(0))){\n                if(_amount > stakerArray[i].stakeQuantity){\n                    stakerArray[i].publicKey = address(0);\n                    _amount = _amount.sub(stakerArray[i].stakeQuantity);\n                    withdrawAmount = withdrawAmount.add(stakerArray[i].stakeQuantity);\n                    portalData[stakerArray[i].portalId].xioStaked = portalData[stakerArray[i].portalId].xioStaked.sub(stakerArray[i].stakeQuantity);\n                    stakerArray[i].stakeQuantity = 0;\n                }\n                else if(_amount == stakerArray[i].stakeQuantity){\n                    stakerArray[i].publicKey = address(0);\n                    withdrawAmount = withdrawAmount.add(stakerArray[i].stakeQuantity);\n                    stakerArray[i].stakeQuantity = 0;\n                    portalData[stakerArray[i].portalId].xioStaked = portalData[stakerArray[i].portalId].xioStaked.sub(_amount);\n                    break;\n                }else if(_amount < stakerArray[i].stakeQuantity){\n                    stakerArray[i].stakeQuantity = stakerArray[i].stakeQuantity.sub(_amount);\n                    withdrawAmount = withdrawAmount.add(_amount);\n                    portalData[stakerArray[i].portalId].xioStaked = portalData[stakerArray[i].portalId].xioStaked.sub( _amount);\n                    break;\n                }\n\n            }\n        }\n        require(withdrawAmount !=0, \"Not Transferred\");\n        Token(xioContractAddress).transfer(msg.sender,withdrawAmount);\n        emit Transfer(msg.sender,withdrawAmount);\n    }\n\n    /* @dev incase of emergency owner can withdraw all the funds */\n    function withdrawTokens() public onlyOwner whenNotPaused{\n        uint256 balance = Token(xioContractAddress).balanceOf(address(this));\n        Token(xioContractAddress).transfer(_owner,balance);\n    }\n\n\n    /* @dev to add portal into the contract\n    *  @param _tokenAddress, address of output token\n    */\n    function addPortal(address _tokenAddress) public onlyOwner whenNotPaused returns(bool) {\n        require(_tokenAddress != address(0), \"Zero address not allowed\");\n        require(checkPortalExists(_tokenAddress) == false , \"Portal already exists\");\n        address exchangeAddress = UniswapFactoryInterface(uniswapFactoryAddress).getExchange(_tokenAddress);\n        require(exchangeAddress != address(0));\n        string memory symbol = Token(_tokenAddress).symbol();\n        portalData[portalId] = PortalData(portalId, _tokenAddress, exchangeAddress, symbol, 0);\n        portalId = portalId.add(1);\n        return true;\n    }\n\n    /* @dev to delete portal into the contract\n    *  @param _portalId, portal Id of portal\n    */\n    function removePortal(uint256 _portalId) public onlyOwner whenNotPaused returns(bool) {\n        require(portalData[_portalId].tokenAddress != address(0),\"Portal does not exist\");\n        uint256 xioAmount = portalData[_portalId].xioStaked;\n        portalData[_portalId] = PortalData(_portalId, address(0), address(0), \"NONE\", xioAmount);\n        return true;\n    }\n\n    /* @dev to set interest rate. Can only be called by owner\n    *  @param _rate, interest rate (in wei)\n    */\n    function setInterestRate(uint256 _rate) public onlyOwner whenNotPaused returns(bool) {\n        require(_rate != 0, \"Rate connot be zero\");\n        interestRate = _rate;\n    }\n\n    /* @dev to set days. Can only be called by owner\n    *  @param _days, days in number\n    */\n    function setDays(uint256 _days) public onlyOwner whenNotPaused returns(bool) {\n        require(_days != 0, \"Rate connot be zero\");\n        stakeDays = _days;\n    }\n\n    /* @dev to set xio quantity. Can only be called by owner\n    *  @param _quantity, xio quantity (in wei)\n    */\n    function setXIOStakeQuantity(uint256 _quantity) public onlyOwner whenNotPaused returns(bool) {\n        require(_quantity > 0, \"quantity connot be zero\");\n        xioStakeQuantity = _quantity;\n    }\n\n    /* @dev to allow XIO exchange max XIO tokens from the portal, can only be called by owner */\n    function allowXIO() public onlyOwner whenNotPaused returns(bool) {\n        return Token(xioContractAddress).approve(xioExchangeAddress, MAX_UINT);\n    }\n\n    /* @dev to add whitelist addresses // for front end feasiblity\n    *  @param __staker, array of staker address\n    */\n    function addWhiteListAccount(address[] memory _staker) public onlyOwner whenNotPaused {\n        for(uint8 i=0; i<_staker.length;i++){\n            require(_staker[i] != address(0), \"Zero address not allowed\");\n            whiteListed[_staker[i]]=true;\n        }\n    }\n\n    /* @dev to update exchange address\n    *  @param _exchangeAddress, xio exchange address\n    */\n    function setXIOExchangeAddress(address _exchangeAddress) public onlyOwner whenNotPaused {\n        require(_exchangeAddress != address(0), \"Zero address not allowed\");\n        xioExchangeAddress = _exchangeAddress;\n    }\n\n    /* @dev to update factory address\n    *  @param _factoryAddress, factory address of uniswap\n    */\n    function setUniswapFactoryAddress(address _factoryAddress) public onlyOwner whenNotPaused {\n        require(_factoryAddress != address(0), \"Zero address not allowed\");\n        uniswapFactoryAddress = _factoryAddress;\n    }\n\n}\n","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getXIOtoETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allowXIO\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getArrayLengthOfStakerData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswapFactoryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"portalData\",\"outputs\":[{\"name\":\"portalId\",\"type\":\"uint256\"},{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokenExchangeAddress\",\"type\":\"address\"},{\"name\":\"outputTokenSymbol\",\"type\":\"string\"},{\"name\":\"xioStaked\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"addPortal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInterestRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xioExchangeAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setInterestRate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_outputTokenAddressExchange\",\"type\":\"address\"}],\"name\":\"getETHtoALT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakerData\",\"outputs\":[{\"name\":\"portalId\",\"type\":\"uint256\"},{\"name\":\"publicKey\",\"type\":\"address\"},{\"name\":\"stakeQuantity\",\"type\":\"uint256\"},{\"name\":\"stakeDurationTimestamp\",\"type\":\"uint256\"},{\"name\":\"stakeInitiationTimestamp\",\"type\":\"uint256\"},{\"name\":\"outputTokenSymbol\",\"type\":\"string\"},{\"name\":\"boughAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_outputTokenAddress\",\"type\":\"address\"},{\"name\":\"_days\",\"type\":\"uint256\"},{\"name\":\"_xioQuantity\",\"type\":\"uint256\"},{\"name\":\"_tokensBought\",\"type\":\"uint256\"},{\"name\":\"_portalId\",\"type\":\"uint256\"}],\"name\":\"stakeXIO\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDays\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"setXIOStakeQuantity\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getXIOStakeQuantity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_portalId\",\"type\":\"uint256\"}],\"name\":\"removePortal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xioContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_factoryAddress\",\"type\":\"address\"}],\"name\":\"setUniswapFactoryAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeAddress\",\"type\":\"address\"}],\"name\":\"setXIOExchangeAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_staker\",\"type\":\"address[]\"}],\"name\":\"addWhiteListAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"setDays\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawXIO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"portalId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"DataEntered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"portalId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"Tranferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"portalId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokensBought\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"Bought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Portal","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":""}]}