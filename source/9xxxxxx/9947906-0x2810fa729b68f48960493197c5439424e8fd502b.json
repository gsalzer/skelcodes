{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n// File: contracts/MultisigVaultETH.sol\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract MultisigVaultETH {\n\n    using SafeMath for uint256;\n\n    struct Approval {\n        bool transfered;\n        uint256 coincieded;\n        mapping(address => bool) coinciedeParties;\n    }\n\n    uint256 private participantsAmount;\n    uint256 private signatureMinThreshold;\n    address payable private serviceAddress;\n    uint256 private serviceFeeMicro;\n\n    string  private _symbol;\n    uint8   private _decimals;\n\n    address constant public ETHER_ADDRESS = address(0x1);\n\n    mapping(address => bool) public parties;\n\n    mapping(\n        // Destination\n        address => mapping(\n            // Amount\n            uint256 => Approval\n        )\n    ) public approvals;\n\n    event ConfirmationReceived(address indexed from, address indexed destination, address currency, uint256 amount);\n    event ConsensusAchived(address indexed destination, address currency, uint256 amount);\n\n    /**\n      * @dev Construcor.\n      *\n      * Requirements:\n      * - `_signatureMinThreshold` .\n      * - `_parties`.\n      * - `_serviceAddress`.\n      * - `_serviceFeeMicro` represented by integer amount of million'th fractions.\n      */\n    constructor(\n        uint256 _signatureMinThreshold,\n        address[] memory _parties,\n        address payable _serviceAddress,\n        uint256 _serviceFeeMicro\n    ) public {\n        require(_parties.length > 0 && _parties.length <= 10);\n        require(_signatureMinThreshold > 0 && _signatureMinThreshold <= _parties.length);\n\n        signatureMinThreshold = _signatureMinThreshold;\n        serviceAddress = _serviceAddress;\n        serviceFeeMicro = _serviceFeeMicro;\n\n        _symbol = \"ETH\";\n        _decimals = 18;\n\n        for (uint256 i = 0; i < _parties.length; i++) parties[_parties[i]] = true;\n    }\n\n    modifier isMember() {\n        require(parties[msg.sender]);\n        _;\n    }\n\n    modifier sufficient(uint256 _amount) {\n        require(address(this).balance >= _amount);\n        _;\n    }\n\n    function partyCoincieded(\n        address _destination,\n        uint256 _amount,\n        address _partyAddress\n    ) public view returns (bool) {\n        Approval storage approval = approvals[_destination][_amount];\n        return approval.coinciedeParties[_partyAddress];\n    }\n\n    // https://ethereum.stackexchange.com/questions/19341/address-send-vs-address-transfer-best-practice-usage\n    function approve(\n        address payable _destination,\n        uint256 _amount\n    ) public isMember sufficient(_amount) returns (bool) {\n        Approval storage approval  = approvals[_destination][_amount]; // Create new project\n\n        if (!approval.coinciedeParties[msg.sender]) {\n            approval.coinciedeParties[msg.sender] = true;\n            approval.coincieded += 1;\n\n            emit ConfirmationReceived(msg.sender, _destination, ETHER_ADDRESS, _amount);\n\n            if (\n                approval.coincieded >= signatureMinThreshold &&\n                !approval.transfered\n            ) {\n                approval.transfered = true;\n\n                uint256 _amountToWithhold = _amount.mul(serviceFeeMicro).div(1000000);\n                uint256 _amountToRelease = _amount.sub(_amountToWithhold);\n\n                _destination.transfer(_amountToRelease);    // Release funds\n                serviceAddress.transfer(_amountToWithhold); // Take service margin\n\n                emit ConsensusAchived(_destination, ETHER_ADDRESS, _amount);\n            }\n\n            return true;\n        } else {\n            // Raise will eat rest of gas. Lets not waist it. Just record this approval instead\n            return false;\n        }\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function() external payable { }\n}\n","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_destination\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"parties\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_destination\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_partyAddress\",\"type\":\"address\"}],\"name\":\"partyCoincieded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHER_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approvals\",\"outputs\":[{\"name\":\"transfered\",\"type\":\"bool\"},{\"name\":\"coincieded\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_signatureMinThreshold\",\"type\":\"uint256\"},{\"name\":\"_parties\",\"type\":\"address[]\"},{\"name\":\"_serviceAddress\",\"type\":\"address\"},{\"name\":\"_serviceFeeMicro\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ConfirmationReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ConsensusAchived\",\"type\":\"event\"}]","ContractName":"MultisigVaultETH","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000800000000000000000000000006e8c059494ba4951c04d26b3e2af803bd8c318a600000000000000000000000000000000000000000000000000000000000009c4000000000000000000000000000000000000000000000000000000000000000200000000000000000000000019ABD81d3F35d2BbB0d720c5c83972196a996A420000000000000000000000007e524cabb64e4368961daa83e8cdb471fe157b20","Library":"","LicenseType":"","SwarmSource":""}]}