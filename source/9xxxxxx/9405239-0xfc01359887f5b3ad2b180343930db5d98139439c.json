{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.25 <0.6.0;\npragma experimental ABIEncoderV2;\n\n\ninterface BalanceRecordable {\n    \n    function balanceRecordsCount(address account)\n    external\n    view\n    returns (uint256);\n\n    \n    function recordBalance(address account, uint256 index)\n    external\n    view\n    returns (uint256);\n\n    \n    function recordBlockNumber(address account, uint256 index)\n    external\n    view\n    returns (uint256);\n\n    \n    function recordIndexByBlockNumber(address account, uint256 blockNumber)\n    external\n    view\n    returns (int256);\n}\n\nlibrary SafeMathUintLib {\n    function mul(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        uint256 c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        \n        uint256 c = a / b;\n        \n        return c;\n    }\n\n    function sub(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\n    \n    \n    \n    function clamp(uint256 a, uint256 min, uint256 max)\n    public\n    pure\n    returns (uint256)\n    {\n        return (a > max) ? max : ((a < min) ? min : a);\n    }\n\n    function clampMin(uint256 a, uint256 min)\n    public\n    pure\n    returns (uint256)\n    {\n        return (a < min) ? min : a;\n    }\n\n    function clampMax(uint256 a, uint256 max)\n    public\n    pure\n    returns (uint256)\n    {\n        return (a > max) ? max : a;\n    }\n}\n\ncontract BalanceAucCalculator {\n    using SafeMathUintLib for uint256;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function calculate(BalanceRecordable balanceRecordable, address wallet, uint256 startBlock, uint256 endBlock)\n    public\n    view\n    returns (uint256)\n    {\n        \n        if (endBlock < startBlock)\n            return 0;\n\n        \n        uint256 recordsCount = balanceRecordable.balanceRecordsCount(wallet);\n\n        \n        if (0 == recordsCount)\n            return 0;\n\n        \n        int256 _endIndex = balanceRecordable.recordIndexByBlockNumber(wallet, endBlock);\n\n        \n        if (0 > _endIndex)\n            return 0;\n\n        \n        uint256 endIndex = uint256(_endIndex);\n\n        \n        \n        startBlock = startBlock.clampMin(balanceRecordable.recordBlockNumber(wallet, 0));\n\n        \n        uint256 startIndex = uint256(balanceRecordable.recordIndexByBlockNumber(wallet, startBlock));\n\n        \n        uint256 result = 0;\n\n        \n        if (startIndex < endIndex)\n            result = result.add(\n                balanceRecordable.recordBalance(wallet, startIndex).mul(\n                    balanceRecordable.recordBlockNumber(wallet, startIndex.add(1)).sub(startBlock)\n                )\n            );\n\n        \n        for (uint256 i = startIndex.add(1); i < endIndex; i = i.add(1))\n            result = result.add(\n                balanceRecordable.recordBalance(wallet, i).mul(\n                    balanceRecordable.recordBlockNumber(wallet, i.add(1)).sub(\n                        balanceRecordable.recordBlockNumber(wallet, i)\n                    )\n                )\n            );\n\n        \n        result = result.add(\n            balanceRecordable.recordBalance(wallet, endIndex).mul(\n                endBlock.sub(\n                    balanceRecordable.recordBlockNumber(wallet, endIndex).clampMin(startBlock)\n                ).add(1)\n            )\n        );\n\n        \n        return result;\n    }\n}\n\nlibrary ConstantsLib {\n    \n    function PARTS_PER()\n    public\n    pure\n    returns (int256)\n    {\n        return 1e18;\n    }\n}\n\ncontract Modifiable {\n    \n    \n    \n    modifier notNullAddress(address _address) {\n        require(_address != address(0));\n        _;\n    }\n\n    modifier notThisAddress(address _address) {\n        require(_address != address(this));\n        _;\n    }\n\n    modifier notNullOrThisAddress(address _address) {\n        require(_address != address(0));\n        require(_address != address(this));\n        _;\n    }\n\n    modifier notSameAddresses(address _address1, address _address2) {\n        if (_address1 != _address2)\n            _;\n    }\n}\n\ncontract SelfDestructible {\n    \n    \n    \n    bool public selfDestructionDisabled;\n\n    \n    \n    \n    event SelfDestructionDisabledEvent(address wallet);\n    event TriggerSelfDestructionEvent(address wallet);\n\n    \n    \n    \n    \n    function destructor()\n    public\n    view\n    returns (address);\n\n    \n    \n    function disableSelfDestruction()\n    public\n    {\n        \n        require(destructor() == msg.sender);\n\n        \n        selfDestructionDisabled = true;\n\n        \n        emit SelfDestructionDisabledEvent(msg.sender);\n    }\n\n    \n    function triggerSelfDestruction()\n    public\n    {\n        \n        require(destructor() == msg.sender);\n\n        \n        require(!selfDestructionDisabled);\n\n        \n        emit TriggerSelfDestructionEvent(msg.sender);\n\n        \n        selfdestruct(msg.sender);\n    }\n}\n\ncontract Ownable is Modifiable, SelfDestructible {\n    \n    \n    \n    address public deployer;\n    address public operator;\n\n    \n    \n    \n    event SetDeployerEvent(address oldDeployer, address newDeployer);\n    event SetOperatorEvent(address oldOperator, address newOperator);\n\n    \n    \n    \n    constructor(address _deployer) internal notNullOrThisAddress(_deployer) {\n        deployer = _deployer;\n        operator = _deployer;\n    }\n\n    \n    \n    \n    \n    function destructor()\n    public\n    view\n    returns (address)\n    {\n        return deployer;\n    }\n\n    \n    \n    function setDeployer(address newDeployer)\n    public\n    onlyDeployer\n    notNullOrThisAddress(newDeployer)\n    {\n        if (newDeployer != deployer) {\n            \n            address oldDeployer = deployer;\n            deployer = newDeployer;\n\n            \n            emit SetDeployerEvent(oldDeployer, newDeployer);\n        }\n    }\n\n    \n    \n    function setOperator(address newOperator)\n    public\n    onlyOperator\n    notNullOrThisAddress(newOperator)\n    {\n        if (newOperator != operator) {\n            \n            address oldOperator = operator;\n            operator = newOperator;\n\n            \n            emit SetOperatorEvent(oldOperator, newOperator);\n        }\n    }\n\n    \n    \n    function isDeployer()\n    internal\n    view\n    returns (bool)\n    {\n        return msg.sender == deployer;\n    }\n\n    \n    \n    function isOperator()\n    internal\n    view\n    returns (bool)\n    {\n        return msg.sender == operator;\n    }\n\n    \n    \n    \n    function isDeployerOrOperator()\n    internal\n    view\n    returns (bool)\n    {\n        return isDeployer() || isOperator();\n    }\n\n    \n    \n    modifier onlyDeployer() {\n        require(isDeployer());\n        _;\n    }\n\n    modifier notDeployer() {\n        require(!isDeployer());\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(isOperator());\n        _;\n    }\n\n    modifier notOperator() {\n        require(!isOperator());\n        _;\n    }\n\n    modifier onlyDeployerOrOperator() {\n        require(isDeployerOrOperator());\n        _;\n    }\n\n    modifier notDeployerOrOperator() {\n        require(!isDeployerOrOperator());\n        _;\n    }\n}\n\ncontract Beneficiary {\n    \n    \n    \n    function receiveEthersTo(address wallet, string memory balanceType)\n    public\n    payable;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function receiveTokensTo(address wallet, string memory balanceType, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public;\n}\n\nlibrary MonetaryTypesLib {\n    \n    \n    \n    struct Currency {\n        address ct;\n        uint256 id;\n    }\n\n    struct Figure {\n        int256 amount;\n        Currency currency;\n    }\n\n    struct NoncedAmount {\n        uint256 nonce;\n        int256 amount;\n    }\n}\n\ncontract AccrualBeneficiary is Beneficiary {\n    \n    \n    \n    event CloseAccrualPeriodEvent();\n\n    \n    \n    \n    function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory)\n    public\n    {\n        emit CloseAccrualPeriodEvent();\n    }\n}\n\ncontract Benefactor is Ownable {\n    \n    \n    \n    Beneficiary[] public beneficiaries;\n    mapping(address => uint256) public beneficiaryIndexByAddress;\n\n    \n    \n    \n    event RegisterBeneficiaryEvent(Beneficiary beneficiary);\n    event DeregisterBeneficiaryEvent(Beneficiary beneficiary);\n\n    \n    \n    \n    \n    \n    function registerBeneficiary(Beneficiary beneficiary)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        address _beneficiary = address(beneficiary);\n\n        if (beneficiaryIndexByAddress[_beneficiary] > 0)\n            return false;\n\n        beneficiaries.push(beneficiary);\n        beneficiaryIndexByAddress[_beneficiary] = beneficiaries.length;\n\n        \n        emit RegisterBeneficiaryEvent(beneficiary);\n\n        return true;\n    }\n\n    \n    \n    function deregisterBeneficiary(Beneficiary beneficiary)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        address _beneficiary = address(beneficiary);\n\n        if (beneficiaryIndexByAddress[_beneficiary] == 0)\n            return false;\n\n        uint256 idx = beneficiaryIndexByAddress[_beneficiary] - 1;\n        if (idx < beneficiaries.length - 1) {\n            \n            beneficiaries[idx] = beneficiaries[beneficiaries.length - 1];\n            beneficiaryIndexByAddress[address(beneficiaries[idx])] = idx + 1;\n        }\n        beneficiaries.length--;\n        beneficiaryIndexByAddress[_beneficiary] = 0;\n\n        \n        emit DeregisterBeneficiaryEvent(beneficiary);\n\n        return true;\n    }\n\n    \n    \n    \n    function isRegisteredBeneficiary(Beneficiary beneficiary)\n    public\n    view\n    returns (bool)\n    {\n        return beneficiaryIndexByAddress[address(beneficiary)] > 0;\n    }\n\n    \n    \n    function registeredBeneficiariesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return beneficiaries.length;\n    }\n}\n\nlibrary SafeMathIntLib {\n    int256 constant INT256_MIN = int256((uint256(1) << 255));\n    int256 constant INT256_MAX = int256(~((uint256(1) << 255)));\n\n    \n    \n    \n    function div(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a != INT256_MIN || b != - 1);\n        return a / b;\n    }\n\n    function mul(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a != - 1 || b != INT256_MIN);\n        \n        require(b != - 1 || a != INT256_MIN);\n        \n        int256 c = a * b;\n        require((b == 0) || (c / b == a));\n        return c;\n    }\n\n    function sub(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require((b >= 0 && a - b <= a) || (b < 0 && a - b > a));\n        return a - b;\n    }\n\n    function add(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\n        return c;\n    }\n\n    \n    \n    \n    function div_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b > 0);\n        return a / b;\n    }\n\n    function mul_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0);\n        int256 c = a * b;\n        require(a == 0 || c / a == b);\n        require(c >= 0);\n        return c;\n    }\n\n    function sub_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0 && b <= a);\n        return a - b;\n    }\n\n    function add_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0);\n        int256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    \n    \n    \n    function abs(int256 a)\n    public\n    pure\n    returns (int256)\n    {\n        return a < 0 ? neg(a) : a;\n    }\n\n    function neg(int256 a)\n    public\n    pure\n    returns (int256)\n    {\n        return mul(a, - 1);\n    }\n\n    function toNonZeroInt256(uint256 a)\n    public\n    pure\n    returns (int256)\n    {\n        require(a > 0 && a < (uint256(1) << 255));\n        return int256(a);\n    }\n\n    function toInt256(uint256 a)\n    public\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && a < (uint256(1) << 255));\n        return int256(a);\n    }\n\n    function toUInt256(int256 a)\n    public\n    pure\n    returns (uint256)\n    {\n        require(a >= 0);\n        return uint256(a);\n    }\n\n    function isNonZeroPositiveInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a > 0);\n    }\n\n    function isPositiveInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a >= 0);\n    }\n\n    function isNonZeroNegativeInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a < 0);\n    }\n\n    function isNegativeInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a <= 0);\n    }\n\n    \n    \n    \n    function clamp(int256 a, int256 min, int256 max)\n    public\n    pure\n    returns (int256)\n    {\n        if (a < min)\n            return min;\n        return (a > max) ? max : a;\n    }\n\n    function clampMin(int256 a, int256 min)\n    public\n    pure\n    returns (int256)\n    {\n        return (a < min) ? min : a;\n    }\n\n    function clampMax(int256 a, int256 max)\n    public\n    pure\n    returns (int256)\n    {\n        return (a > max) ? max : a;\n    }\n}\n\ncontract AccrualBenefactor is Benefactor {\n    using SafeMathIntLib for int256;\n\n    \n    \n    \n    mapping(address => int256) private _beneficiaryFractionMap;\n    int256 public totalBeneficiaryFraction;\n\n    \n    \n    \n    event RegisterAccrualBeneficiaryEvent(Beneficiary beneficiary, int256 fraction);\n    event DeregisterAccrualBeneficiaryEvent(Beneficiary beneficiary);\n\n    \n    \n    \n    \n    \n    function registerBeneficiary(Beneficiary beneficiary)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        return registerFractionalBeneficiary(AccrualBeneficiary(address(beneficiary)), ConstantsLib.PARTS_PER());\n    }\n\n    \n    \n    \n    function registerFractionalBeneficiary(AccrualBeneficiary beneficiary, int256 fraction)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        require(fraction > 0, \"Fraction not strictly positive [AccrualBenefactor.sol:59]\");\n        require(\n            totalBeneficiaryFraction.add(fraction) <= ConstantsLib.PARTS_PER(),\n            \"Total beneficiary fraction out of bounds [AccrualBenefactor.sol:60]\"\n        );\n\n        if (!super.registerBeneficiary(beneficiary))\n            return false;\n\n        _beneficiaryFractionMap[address(beneficiary)] = fraction;\n        totalBeneficiaryFraction = totalBeneficiaryFraction.add(fraction);\n\n        \n        emit RegisterAccrualBeneficiaryEvent(beneficiary, fraction);\n\n        return true;\n    }\n\n    \n    \n    function deregisterBeneficiary(Beneficiary beneficiary)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        if (!super.deregisterBeneficiary(beneficiary))\n            return false;\n\n        address _beneficiary = address(beneficiary);\n\n        totalBeneficiaryFraction = totalBeneficiaryFraction.sub(_beneficiaryFractionMap[_beneficiary]);\n        _beneficiaryFractionMap[_beneficiary] = 0;\n\n        \n        emit DeregisterAccrualBeneficiaryEvent(beneficiary);\n\n        return true;\n    }\n\n    \n    \n    \n    function beneficiaryFraction(AccrualBeneficiary beneficiary)\n    public\n    view\n    returns (int256)\n    {\n        return _beneficiaryFractionMap[address(beneficiary)];\n    }\n}\n\ncontract TransferController {\n    \n    \n    \n    event CurrencyTransferred(address from, address to, uint256 value,\n        address currencyCt, uint256 currencyId);\n\n    \n    \n    \n    function isFungible()\n    public\n    view\n    returns (bool);\n\n    function standard()\n    public\n    view\n    returns (string memory);\n\n    \n    function receive(address from, address to, uint256 value, address currencyCt, uint256 currencyId)\n    public;\n\n    \n    function approve(address to, uint256 value, address currencyCt, uint256 currencyId)\n    public;\n\n    \n    function dispatch(address from, address to, uint256 value, address currencyCt, uint256 currencyId)\n    public;\n\n    \n\n    function getReceiveSignature()\n    public\n    pure\n    returns (bytes4)\n    {\n        return bytes4(keccak256(\"receive(address,address,uint256,address,uint256)\"));\n    }\n\n    function getApproveSignature()\n    public\n    pure\n    returns (bytes4)\n    {\n        return bytes4(keccak256(\"approve(address,uint256,address,uint256)\"));\n    }\n\n    function getDispatchSignature()\n    public\n    pure\n    returns (bytes4)\n    {\n        return bytes4(keccak256(\"dispatch(address,address,uint256,address,uint256)\"));\n    }\n}\n\ncontract TransferControllerManager is Ownable {\n    \n    \n    \n    struct CurrencyInfo {\n        bytes32 standard;\n        bool blacklisted;\n    }\n\n    \n    \n    \n    mapping(bytes32 => address) public registeredTransferControllers;\n    mapping(address => CurrencyInfo) public registeredCurrencies;\n\n    \n    \n    \n    event RegisterTransferControllerEvent(string standard, address controller);\n    event ReassociateTransferControllerEvent(string oldStandard, string newStandard, address controller);\n\n    event RegisterCurrencyEvent(address currencyCt, string standard);\n    event DeregisterCurrencyEvent(address currencyCt);\n    event BlacklistCurrencyEvent(address currencyCt);\n    event WhitelistCurrencyEvent(address currencyCt);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    function registerTransferController(string calldata standard, address controller)\n    external\n    onlyDeployer\n    notNullAddress(controller)\n    {\n        require(bytes(standard).length > 0, \"Empty standard not supported [TransferControllerManager.sol:58]\");\n        bytes32 standardHash = keccak256(abi.encodePacked(standard));\n\n        registeredTransferControllers[standardHash] = controller;\n\n        \n        emit RegisterTransferControllerEvent(standard, controller);\n    }\n\n    function reassociateTransferController(string calldata oldStandard, string calldata newStandard, address controller)\n    external\n    onlyDeployer\n    notNullAddress(controller)\n    {\n        require(bytes(newStandard).length > 0, \"Empty new standard not supported [TransferControllerManager.sol:72]\");\n        bytes32 oldStandardHash = keccak256(abi.encodePacked(oldStandard));\n        bytes32 newStandardHash = keccak256(abi.encodePacked(newStandard));\n\n        require(registeredTransferControllers[oldStandardHash] != address(0), \"Old standard not registered [TransferControllerManager.sol:76]\");\n        require(registeredTransferControllers[newStandardHash] == address(0), \"New standard previously registered [TransferControllerManager.sol:77]\");\n\n        registeredTransferControllers[newStandardHash] = registeredTransferControllers[oldStandardHash];\n        registeredTransferControllers[oldStandardHash] = address(0);\n\n        \n        emit ReassociateTransferControllerEvent(oldStandard, newStandard, controller);\n    }\n\n    function registerCurrency(address currencyCt, string calldata standard)\n    external\n    onlyOperator\n    notNullAddress(currencyCt)\n    {\n        require(bytes(standard).length > 0, \"Empty standard not supported [TransferControllerManager.sol:91]\");\n        bytes32 standardHash = keccak256(abi.encodePacked(standard));\n\n        require(registeredCurrencies[currencyCt].standard == bytes32(0), \"Currency previously registered [TransferControllerManager.sol:94]\");\n\n        registeredCurrencies[currencyCt].standard = standardHash;\n\n        \n        emit RegisterCurrencyEvent(currencyCt, standard);\n    }\n\n    function deregisterCurrency(address currencyCt)\n    external\n    onlyOperator\n    {\n        require(registeredCurrencies[currencyCt].standard != 0, \"Currency not registered [TransferControllerManager.sol:106]\");\n\n        registeredCurrencies[currencyCt].standard = bytes32(0);\n        registeredCurrencies[currencyCt].blacklisted = false;\n\n        \n        emit DeregisterCurrencyEvent(currencyCt);\n    }\n\n    function blacklistCurrency(address currencyCt)\n    external\n    onlyOperator\n    {\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:119]\");\n\n        registeredCurrencies[currencyCt].blacklisted = true;\n\n        \n        emit BlacklistCurrencyEvent(currencyCt);\n    }\n\n    function whitelistCurrency(address currencyCt)\n    external\n    onlyOperator\n    {\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:131]\");\n\n        registeredCurrencies[currencyCt].blacklisted = false;\n\n        \n        emit WhitelistCurrencyEvent(currencyCt);\n    }\n\n    \n    function transferController(address currencyCt, string memory standard)\n    public\n    view\n    returns (TransferController)\n    {\n        if (bytes(standard).length > 0) {\n            bytes32 standardHash = keccak256(abi.encodePacked(standard));\n\n            require(registeredTransferControllers[standardHash] != address(0), \"Standard not registered [TransferControllerManager.sol:150]\");\n            return TransferController(registeredTransferControllers[standardHash]);\n        }\n\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:154]\");\n        require(!registeredCurrencies[currencyCt].blacklisted, \"Currency blacklisted [TransferControllerManager.sol:155]\");\n\n        address controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\n        require(controllerAddress != address(0), \"No matching transfer controller [TransferControllerManager.sol:158]\");\n\n        return TransferController(controllerAddress);\n    }\n}\n\ncontract TransferControllerManageable is Ownable {\n    \n    \n    \n    TransferControllerManager public transferControllerManager;\n\n    \n    \n    \n    event SetTransferControllerManagerEvent(TransferControllerManager oldTransferControllerManager,\n        TransferControllerManager newTransferControllerManager);\n\n    \n    \n    \n    \n    \n    function setTransferControllerManager(TransferControllerManager newTransferControllerManager)\n    public\n    onlyDeployer\n    notNullAddress(address(newTransferControllerManager))\n    notSameAddresses(address(newTransferControllerManager), address(transferControllerManager))\n    {\n        \n        TransferControllerManager oldTransferControllerManager = transferControllerManager;\n        transferControllerManager = newTransferControllerManager;\n\n        \n        emit SetTransferControllerManagerEvent(oldTransferControllerManager, newTransferControllerManager);\n    }\n\n    \n    function transferController(address currencyCt, string memory standard)\n    internal\n    view\n    returns (TransferController)\n    {\n        return transferControllerManager.transferController(currencyCt, standard);\n    }\n\n    \n    \n    \n    modifier transferControllerManagerInitialized() {\n        require(address(transferControllerManager) != address(0), \"Transfer controller manager not initialized [TransferControllerManageable.sol:63]\");\n        _;\n    }\n}\n\nlibrary CurrenciesLib {\n    using SafeMathUintLib for uint256;\n\n    \n    \n    \n    struct Currencies {\n        MonetaryTypesLib.Currency[] currencies;\n        mapping(address => mapping(uint256 => uint256)) indexByCurrency;\n    }\n\n    \n    \n    \n    function add(Currencies storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        \n        if (0 == self.indexByCurrency[currencyCt][currencyId]) {\n            self.currencies.push(MonetaryTypesLib.Currency(currencyCt, currencyId));\n            self.indexByCurrency[currencyCt][currencyId] = self.currencies.length;\n        }\n    }\n\n    function removeByCurrency(Currencies storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        \n        uint256 index = self.indexByCurrency[currencyCt][currencyId];\n        if (0 < index)\n            removeByIndex(self, index - 1);\n    }\n\n    function removeByIndex(Currencies storage self, uint256 index)\n    internal\n    {\n        require(index < self.currencies.length, \"Index out of bounds [CurrenciesLib.sol:51]\");\n\n        address currencyCt = self.currencies[index].ct;\n        uint256 currencyId = self.currencies[index].id;\n\n        if (index < self.currencies.length - 1) {\n            self.currencies[index] = self.currencies[self.currencies.length - 1];\n            self.indexByCurrency[self.currencies[index].ct][self.currencies[index].id] = index + 1;\n        }\n        self.currencies.length--;\n        self.indexByCurrency[currencyCt][currencyId] = 0;\n    }\n\n    function count(Currencies storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.currencies.length;\n    }\n\n    function has(Currencies storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return 0 != self.indexByCurrency[currencyCt][currencyId];\n    }\n\n    function getByIndex(Currencies storage self, uint256 index)\n    internal\n    view\n    returns (MonetaryTypesLib.Currency memory)\n    {\n        require(index < self.currencies.length, \"Index out of bounds [CurrenciesLib.sol:85]\");\n        return self.currencies[index];\n    }\n\n    function getByIndices(Currencies storage self, uint256 low, uint256 up)\n    internal\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        require(0 < self.currencies.length, \"No currencies found [CurrenciesLib.sol:94]\");\n        require(low <= up, \"Bounds parameters mismatch [CurrenciesLib.sol:95]\");\n\n        up = up.clampMax(self.currencies.length - 1);\n        MonetaryTypesLib.Currency[] memory _currencies = new MonetaryTypesLib.Currency[](up - low + 1);\n        for (uint256 i = low; i <= up; i++)\n            _currencies[i - low] = self.currencies[i];\n\n        return _currencies;\n    }\n}\n\nlibrary FungibleBalanceLib {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using CurrenciesLib for CurrenciesLib.Currencies;\n\n    \n    \n    \n    struct Record {\n        int256 amount;\n        uint256 blockNumber;\n    }\n\n    struct Balance {\n        mapping(address => mapping(uint256 => int256)) amountByCurrency;\n        mapping(address => mapping(uint256 => Record[])) recordsByCurrency;\n\n        CurrenciesLib.Currencies inUseCurrencies;\n        CurrenciesLib.Currencies everUsedCurrencies;\n    }\n\n    \n    \n    \n    function get(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (int256)\n    {\n        return self.amountByCurrency[currencyCt][currencyId];\n    }\n\n    function getByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (int256)\n    {\n        (int256 amount,) = recordByBlockNumber(self, currencyCt, currencyId, blockNumber);\n        return amount;\n    }\n\n    function set(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = amount;\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function setByBlockNumber(Balance storage self, int256 amount, address currencyCt, uint256 currencyId,\n        uint256 blockNumber)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = amount;\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], blockNumber)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function add(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function addByBlockNumber(Balance storage self, int256 amount, address currencyCt, uint256 currencyId,\n        uint256 blockNumber)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], blockNumber)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function sub(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function subByBlockNumber(Balance storage self, int256 amount, address currencyCt, uint256 currencyId,\n        uint256 blockNumber)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], blockNumber)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function transfer(Balance storage _from, Balance storage _to, int256 amount,\n        address currencyCt, uint256 currencyId)\n    internal\n    {\n        sub(_from, amount, currencyCt, currencyId);\n        add(_to, amount, currencyCt, currencyId);\n    }\n\n    function add_nn(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add_nn(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function sub_nn(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub_nn(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function transfer_nn(Balance storage _from, Balance storage _to, int256 amount,\n        address currencyCt, uint256 currencyId)\n    internal\n    {\n        sub_nn(_from, amount, currencyCt, currencyId);\n        add_nn(_to, amount, currencyCt, currencyId);\n    }\n\n    function recordsCount(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.recordsByCurrency[currencyCt][currencyId].length;\n    }\n\n    function recordByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (int256, uint256)\n    {\n        uint256 index = indexByBlockNumber(self, currencyCt, currencyId, blockNumber);\n        return 0 < index ? recordByIndex(self, currencyCt, currencyId, index - 1) : (0, 0);\n    }\n\n    function recordByIndex(Balance storage self, address currencyCt, uint256 currencyId, uint256 index)\n    internal\n    view\n    returns (int256, uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return (0, 0);\n\n        index = index.clampMax(self.recordsByCurrency[currencyCt][currencyId].length - 1);\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][index];\n        return (record.amount, record.blockNumber);\n    }\n\n    function lastRecord(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (int256, uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return (0, 0);\n\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][self.recordsByCurrency[currencyCt][currencyId].length - 1];\n        return (record.amount, record.blockNumber);\n    }\n\n    function hasInUseCurrency(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return self.inUseCurrencies.has(currencyCt, currencyId);\n    }\n\n    function hasEverUsedCurrency(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return self.everUsedCurrencies.has(currencyCt, currencyId);\n    }\n\n    function updateCurrencies(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        if (0 == self.amountByCurrency[currencyCt][currencyId] && self.inUseCurrencies.has(currencyCt, currencyId))\n            self.inUseCurrencies.removeByCurrency(currencyCt, currencyId);\n        else if (!self.inUseCurrencies.has(currencyCt, currencyId)) {\n            self.inUseCurrencies.add(currencyCt, currencyId);\n            self.everUsedCurrencies.add(currencyCt, currencyId);\n        }\n    }\n\n    function indexByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return 0;\n        for (uint256 i = self.recordsByCurrency[currencyCt][currencyId].length; i > 0; i--)\n            if (self.recordsByCurrency[currencyCt][currencyId][i - 1].blockNumber <= blockNumber)\n                return i;\n        return 0;\n    }\n}\n\nlibrary TxHistoryLib {\n    \n    \n    \n    struct AssetEntry {\n        int256 amount;\n        uint256 blockNumber;\n        address currencyCt;      \n        uint256 currencyId;\n    }\n\n    struct TxHistory {\n        AssetEntry[] deposits;\n        mapping(address => mapping(uint256 => AssetEntry[])) currencyDeposits;\n\n        AssetEntry[] withdrawals;\n        mapping(address => mapping(uint256 => AssetEntry[])) currencyWithdrawals;\n    }\n\n    \n    \n    \n    function addDeposit(TxHistory storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        AssetEntry memory deposit = AssetEntry(amount, block.number, currencyCt, currencyId);\n        self.deposits.push(deposit);\n        self.currencyDeposits[currencyCt][currencyId].push(deposit);\n    }\n\n    function addWithdrawal(TxHistory storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        AssetEntry memory withdrawal = AssetEntry(amount, block.number, currencyCt, currencyId);\n        self.withdrawals.push(withdrawal);\n        self.currencyWithdrawals[currencyCt][currencyId].push(withdrawal);\n    }\n\n    \n\n    function deposit(TxHistory storage self, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        require(index < self.deposits.length, \"Index ouf of bounds [TxHistoryLib.sol:56]\");\n\n        amount = self.deposits[index].amount;\n        blockNumber = self.deposits[index].blockNumber;\n        currencyCt = self.deposits[index].currencyCt;\n        currencyId = self.deposits[index].currencyId;\n    }\n\n    function depositsCount(TxHistory storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.deposits.length;\n    }\n\n    function currencyDeposit(TxHistory storage self, address currencyCt, uint256 currencyId, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        require(index < self.currencyDeposits[currencyCt][currencyId].length, \"Index out of bounds [TxHistoryLib.sol:77]\");\n\n        amount = self.currencyDeposits[currencyCt][currencyId][index].amount;\n        blockNumber = self.currencyDeposits[currencyCt][currencyId][index].blockNumber;\n    }\n\n    function currencyDepositsCount(TxHistory storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.currencyDeposits[currencyCt][currencyId].length;\n    }\n\n    \n\n    function withdrawal(TxHistory storage self, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        require(index < self.withdrawals.length, \"Index out of bounds [TxHistoryLib.sol:98]\");\n\n        amount = self.withdrawals[index].amount;\n        blockNumber = self.withdrawals[index].blockNumber;\n        currencyCt = self.withdrawals[index].currencyCt;\n        currencyId = self.withdrawals[index].currencyId;\n    }\n\n    function withdrawalsCount(TxHistory storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.withdrawals.length;\n    }\n\n    function currencyWithdrawal(TxHistory storage self, address currencyCt, uint256 currencyId, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        require(index < self.currencyWithdrawals[currencyCt][currencyId].length, \"Index out of bounds [TxHistoryLib.sol:119]\");\n\n        amount = self.currencyWithdrawals[currencyCt][currencyId][index].amount;\n        blockNumber = self.currencyWithdrawals[currencyCt][currencyId][index].blockNumber;\n    }\n\n    function currencyWithdrawalsCount(TxHistory storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.currencyWithdrawals[currencyCt][currencyId].length;\n    }\n}\n\ncontract RevenueFund is Ownable, AccrualBeneficiary, AccrualBenefactor, TransferControllerManageable {\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\n    using TxHistoryLib for TxHistoryLib.TxHistory;\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using CurrenciesLib for CurrenciesLib.Currencies;\n\n    \n    \n    \n    FungibleBalanceLib.Balance periodAccrual;\n    CurrenciesLib.Currencies periodCurrencies;\n\n    FungibleBalanceLib.Balance aggregateAccrual;\n    CurrenciesLib.Currencies aggregateCurrencies;\n\n    TxHistoryLib.TxHistory private txHistory;\n\n    \n    \n    \n    event ReceiveEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\n    event CloseAccrualPeriodEvent();\n    event RegisterServiceEvent(address service);\n    event DeregisterServiceEvent(address service);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    \n    function() external payable {\n        receiveEthersTo(msg.sender, \"\");\n    }\n\n    \n    \n    function receiveEthersTo(address wallet, string memory)\n    public\n    payable\n    {\n        int256 amount = SafeMathIntLib.toNonZeroInt256(msg.value);\n\n        \n        periodAccrual.add(amount, address(0), 0);\n        aggregateAccrual.add(amount, address(0), 0);\n\n        \n        periodCurrencies.add(address(0), 0);\n        aggregateCurrencies.add(address(0), 0);\n\n        \n        txHistory.addDeposit(amount, address(0), 0);\n\n        \n        emit ReceiveEvent(wallet, amount, address(0), 0);\n    }\n\n    \n    \n    \n    \n    \n    function receiveTokens(string memory balanceType, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        receiveTokensTo(msg.sender, balanceType, amount, currencyCt, currencyId, standard);\n    }\n\n    \n    \n    \n    \n    \n    \n    function receiveTokensTo(address wallet, string memory, int256 amount,\n        address currencyCt, uint256 currencyId, string memory standard)\n    public\n    {\n        require(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [RevenueFund.sol:115]\");\n\n        \n        TransferController controller = transferController(currencyCt, standard);\n        (bool success,) = address(controller).delegatecall(\n            abi.encodeWithSelector(\n                controller.getReceiveSignature(), msg.sender, this, uint256(amount), currencyCt, currencyId\n            )\n        );\n        require(success, \"Reception by controller failed [RevenueFund.sol:124]\");\n\n        \n        periodAccrual.add(amount, currencyCt, currencyId);\n        aggregateAccrual.add(amount, currencyCt, currencyId);\n\n        \n        periodCurrencies.add(currencyCt, currencyId);\n        aggregateCurrencies.add(currencyCt, currencyId);\n\n        \n        txHistory.addDeposit(amount, currencyCt, currencyId);\n\n        \n        emit ReceiveEvent(wallet, amount, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    function periodAccrualBalance(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return periodAccrual.get(currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function aggregateAccrualBalance(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return aggregateAccrual.get(currencyCt, currencyId);\n    }\n\n    \n    \n    function periodCurrenciesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return periodCurrencies.count();\n    }\n\n    \n    \n    \n    \n    function periodCurrenciesByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        return periodCurrencies.getByIndices(low, up);\n    }\n\n    \n    \n    function aggregateCurrenciesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return aggregateCurrencies.count();\n    }\n\n    \n    \n    \n    \n    function aggregateCurrenciesByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        return aggregateCurrencies.getByIndices(low, up);\n    }\n\n    \n    \n    function depositsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return txHistory.depositsCount();\n    }\n\n    \n    \n    function deposit(uint index)\n    public\n    view\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        return txHistory.deposit(index);\n    }\n\n    \n    \n    function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory currencies)\n    public\n    onlyOperator\n    {\n        require(\n            ConstantsLib.PARTS_PER() == totalBeneficiaryFraction,\n            \"Total beneficiary fraction out of bounds [RevenueFund.sol:236]\"\n        );\n\n        \n        for (uint256 i = 0; i < currencies.length; i++) {\n            MonetaryTypesLib.Currency memory currency = currencies[i];\n\n            int256 remaining = periodAccrual.get(currency.ct, currency.id);\n\n            if (0 >= remaining)\n                continue;\n\n            for (uint256 j = 0; j < beneficiaries.length; j++) {\n                AccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\n                if (beneficiaryFraction(beneficiary) > 0) {\n                    int256 transferable = periodAccrual.get(currency.ct, currency.id)\n                    .mul(beneficiaryFraction(beneficiary))\n                    .div(ConstantsLib.PARTS_PER());\n\n                    if (transferable > remaining)\n                        transferable = remaining;\n\n                    if (transferable > 0) {\n                        \n                        if (currency.ct == address(0))\n                            beneficiary.receiveEthersTo.value(uint256(transferable))(address(0), \"\");\n\n                        \n                        else {\n                            TransferController controller = transferController(currency.ct, \"\");\n                            (bool success,) = address(controller).delegatecall(\n                                abi.encodeWithSelector(\n                                    controller.getApproveSignature(), address(beneficiary), uint256(transferable), currency.ct, currency.id\n                                )\n                            );\n                            require(success, \"Approval by controller failed [RevenueFund.sol:274]\");\n\n                            beneficiary.receiveTokensTo(address(0), \"\", transferable, currency.ct, currency.id, \"\");\n                        }\n\n                        remaining = remaining.sub(transferable);\n                    }\n                }\n            }\n\n            \n            periodAccrual.set(remaining, currency.ct, currency.id);\n\n            \n            if (0 == remaining)\n                periodCurrencies.removeByCurrency(currency.ct, currency.id);\n        }\n\n        \n        for (uint256 j = 0; j < beneficiaries.length; j++) {\n            AccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\n            \n            if (0 >= beneficiaryFraction(beneficiary))\n                continue;\n\n            \n            beneficiary.closeAccrualPeriod(currencies);\n        }\n\n        \n        emit CloseAccrualPeriodEvent();\n    }\n}\n\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n\n    \n    function balanceOf(address account) external view returns (uint256);\n\n    \n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        \n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        \n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary Address {\n    \n    function isContract(address account) internal view returns (bool) {\n        \n        \n        \n\n        \n        \n        \n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        \n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n\n    \n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    \n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        \n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        \n        \n        \n        \n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    \n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        \n        \n\n        \n        \n        \n        \n        \n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        \n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { \n            \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract TokenMultiTimelock is Ownable {\n    using SafeMathUintLib for uint256;\n    using SafeERC20 for IERC20;\n\n    \n    \n    \n    struct Release {\n        uint256 blockNumber;\n        uint256 earliestReleaseTime;\n        uint256 amount;\n        uint256 totalAmount;\n        bool done;\n    }\n\n    \n    \n    \n    IERC20 public token;\n    address public beneficiary;\n\n    Release[] public releases;\n    uint256 public totalReleasedAmount;\n    uint256 public totalLockedAmount;\n    uint256 public executedReleasesCount;\n\n    \n    \n    \n    event SetTokenEvent(IERC20 token);\n    event SetBeneficiaryEvent(address beneficiary);\n    event DefineReleaseEvent(uint256 blockNumber, uint256 earliestReleaseTime, uint256 amount,\n        uint256 totalAmount, bool done);\n    event SetReleaseBlockNumberEvent(uint256 index, uint256 blockNumber);\n    event ReleaseEvent(uint256 index, uint256 blockNumber, uint256 earliestReleaseTime,\n        uint256 actualReleaseTime, uint256 amount);\n\n    \n    \n    \n    constructor(address deployer)\n    Ownable(deployer)\n    public\n    {\n    }\n\n    \n    \n    \n    \n    \n    function setToken(IERC20 _token)\n    public\n    onlyOperator\n    notNullOrThisAddress(address(_token))\n    {\n        \n        require(address(token) == address(0), \"Token previously set [TokenMultiTimelock.sol:79]\");\n\n        \n        token = _token;\n\n        \n        emit SetTokenEvent(token);\n    }\n\n    \n    \n    function setBeneficiary(address _beneficiary)\n    public\n    onlyOperator\n    notNullAddress(_beneficiary)\n    {\n        \n        beneficiary = _beneficiary;\n\n        \n        emit SetBeneficiaryEvent(beneficiary);\n    }\n\n    \n    \n    function defineReleases(Release[] memory _releases)\n    onlyOperator\n    public\n    {\n        \n        require(address(token) != address(0), \"Token not initialized [TokenMultiTimelock.sol:109]\");\n\n        \n        for (uint256 i = 0; i < _releases.length; i++) {\n            \n            totalLockedAmount += _releases[i].amount;\n\n            \n            \n            require(token.balanceOf(address(this)) >= totalLockedAmount, \"Total locked amount overrun [TokenMultiTimelock.sol:118]\");\n\n            \n            releases.push(_releases[i]);\n\n            \n            emit DefineReleaseEvent(_releases[i].blockNumber, _releases[i].earliestReleaseTime, _releases[i].amount,\n                totalLockedAmount, _releases[i].done);\n        }\n    }\n\n    \n    \n    function releasesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return releases.length;\n    }\n\n    \n    \n    \n    function setReleaseBlockNumber(uint256 index, uint256 blockNumber)\n    public\n    onlyBeneficiary\n    {\n        \n        require(!releases[index].done, \"Release previously done [TokenMultiTimelock.sol:147]\");\n\n        \n        releases[index].blockNumber = blockNumber;\n\n        \n        emit SetReleaseBlockNumberEvent(index, blockNumber);\n    }\n\n    \n    \n    \n    \n    function releaseIndexByBlockNumber(uint256 blockNumber)\n    public\n    view\n    returns (int256)\n    {\n        for (uint256 i = releases.length; i > 0;) {\n            i = i.sub(1);\n            if (0 < releases[i].blockNumber && releases[i].blockNumber <= blockNumber)\n                return int256(i);\n        }\n        return - 1;\n    }\n\n    \n    \n    function release(uint256 index)\n    public\n    onlyBeneficiary\n    {\n        \n        Release storage _release = releases[index];\n\n        \n        require(0 < _release.amount, \"Release amount not strictly positive [TokenMultiTimelock.sol:183]\");\n\n        \n        require(!_release.done, \"Release previously done [TokenMultiTimelock.sol:186]\");\n\n        \n        require(block.timestamp >= _release.earliestReleaseTime, \"Block time stamp less than earliest release time [TokenMultiTimelock.sol:189]\");\n\n        \n        totalReleasedAmount = totalReleasedAmount.add(_release.amount);\n\n        \n        _release.totalAmount = totalReleasedAmount;\n\n        \n        _release.done = true;\n\n        \n        if (0 == _release.blockNumber)\n            _release.blockNumber = block.number;\n\n        \n        executedReleasesCount = executedReleasesCount.add(1);\n\n        \n        totalLockedAmount = totalLockedAmount.sub(_release.amount);\n\n        \n        token.safeTransfer(beneficiary, _release.amount);\n\n        \n        emit ReleaseEvent(index, _release.blockNumber, _release.earliestReleaseTime, block.timestamp, _release.amount);\n    }\n\n    \n    \n    modifier onlyBeneficiary() {\n        require(msg.sender == beneficiary, \"Message sender not beneficiary [TokenMultiTimelock.sol:220]\");\n        _;\n    }\n}\n\ncontract RevenueTokenManager is TokenMultiTimelock, BalanceRecordable {\n    using SafeMathUintLib for uint256;\n\n    \n    \n    \n    constructor(address deployer)\n    public\n    TokenMultiTimelock(deployer)\n    {\n    }\n\n    \n    \n    \n    \n    \n    function balanceRecordsCount(address)\n    external\n    view\n    returns (uint256)\n    {\n        return executedReleasesCount;\n    }\n\n    \n    \n    \n    function recordBalance(address, uint256 index)\n    external\n    view\n    returns (uint256)\n    {\n        return releases[index].totalAmount;\n    }\n\n    \n    \n    \n    function recordBlockNumber(address, uint256 index)\n    external\n    view\n    returns (uint256)\n    {\n        return releases[index].blockNumber;\n    }\n\n    \n    \n    \n    \n    function recordIndexByBlockNumber(address, uint256 blockNumber)\n    external\n    view\n    returns (int256)\n    {\n        return releaseIndexByBlockNumber(blockNumber);\n    }\n}\n\ncontract Servable is Ownable {\n    \n    \n    \n    struct ServiceInfo {\n        bool registered;\n        uint256 activationTimestamp;\n        mapping(bytes32 => bool) actionsEnabledMap;\n        bytes32[] actionsList;\n    }\n\n    \n    \n    \n    mapping(address => ServiceInfo) internal registeredServicesMap;\n    uint256 public serviceActivationTimeout;\n\n    \n    \n    \n    event ServiceActivationTimeoutEvent(uint256 timeoutInSeconds);\n    event RegisterServiceEvent(address service);\n    event RegisterServiceDeferredEvent(address service, uint256 timeout);\n    event DeregisterServiceEvent(address service);\n    event EnableServiceActionEvent(address service, string action);\n    event DisableServiceActionEvent(address service, string action);\n\n    \n    \n    \n    \n    \n    function setServiceActivationTimeout(uint256 timeoutInSeconds)\n    public\n    onlyDeployer\n    {\n        serviceActivationTimeout = timeoutInSeconds;\n\n        \n        emit ServiceActivationTimeoutEvent(timeoutInSeconds);\n    }\n\n    \n    \n    function registerService(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        _registerService(service, 0);\n\n        \n        emit RegisterServiceEvent(service);\n    }\n\n    \n    \n    function registerServiceDeferred(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        _registerService(service, serviceActivationTimeout);\n\n        \n        emit RegisterServiceDeferredEvent(service, serviceActivationTimeout);\n    }\n\n    \n    \n    function deregisterService(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        registeredServicesMap[service].registered = false;\n\n        \n        emit DeregisterServiceEvent(service);\n    }\n\n    \n    \n    \n    function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        \n        emit EnableServiceActionEvent(service, action);\n    }\n\n    \n    \n    \n    function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        \n        emit DisableServiceActionEvent(service, action);\n    }\n\n    \n    \n    \n    function isRegisteredService(address service)\n    public\n    view\n    returns (bool)\n    {\n        return registeredServicesMap[service].registered;\n    }\n\n    \n    \n    \n    function isRegisteredActiveService(address service)\n    public\n    view\n    returns (bool)\n    {\n        return isRegisteredService(service) && block.timestamp >= registeredServicesMap[service].activationTimestamp;\n    }\n\n    \n    \n    \n    function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }\n\n    \n    \n    \n    function hashString(string memory _string)\n    internal\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_string));\n    }\n\n    \n    \n    \n    function _registerService(address service, uint256 timeout)\n    private\n    {\n        if (!registeredServicesMap[service].registered) {\n            registeredServicesMap[service].registered = true;\n            registeredServicesMap[service].activationTimestamp = block.timestamp + timeout;\n        }\n    }\n\n    \n    \n    \n    modifier onlyActiveService() {\n        require(isRegisteredActiveService(msg.sender));\n        _;\n    }\n\n    modifier onlyEnabledServiceAction(string memory action) {\n        require(isEnabledServiceAction(msg.sender, action));\n        _;\n    }\n}\n\ncontract Context {\n    \n    \n    constructor () internal { }\n    \n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; \n        return msg.data;\n    }\n}\n\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    \n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    \n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    \n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    \n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    \n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    \n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    \n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     \n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    \n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    \n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    \n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    \n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    \n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\ncontract MinterRole is Context {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(_msgSender());\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(_msgSender()), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(_msgSender());\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n\ncontract ERC20Mintable is ERC20, MinterRole {\n    \n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n}\n\nlibrary Math {\n    \n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    \n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    \n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\ncontract TokenUpgradeAgent {\n\n    \n    address public origin;\n\n    constructor(address _origin)\n    public\n    {\n        origin = _origin;\n    }\n\n    \n    \n    \n    function upgradeFrom(address from, uint256 value)\n    public\n    returns (bool);\n\n    \n    \n    \n    modifier onlyOrigin() {\n        require(msg.sender == origin);\n        _;\n    }\n}\n\ncontract RevenueToken is ERC20Mintable, BalanceRecordable {\n    using SafeMath for uint256;\n    using Math for uint256;\n\n    struct BalanceRecord {\n        uint256 blockNumber;\n        uint256 balance;\n    }\n\n    mapping(address => BalanceRecord[]) public balanceRecords;\n\n    bool public mintingDisabled;\n\n    event DisableMinting();\n    event Upgrade(TokenUpgradeAgent tokenUpgradeAgent, address from, uint256 value);\n    event UpgradeFrom(TokenUpgradeAgent tokenUpgradeAgent, address upgrader, address from, uint256 value);\n    event UpgradeBalanceRecords(address account, uint256 startIndex, uint256 endIndex);\n\n    \n    function disableMinting()\n    public\n    onlyMinter\n    {\n        \n        mintingDisabled = true;\n\n        \n        emit DisableMinting();\n    }\n\n    \n    function mint(address to, uint256 value)\n    public\n    onlyMinter\n    returns (bool)\n    {\n        \n        require(!mintingDisabled, \"Minting disabled [RevenueToken.sol:68]\");\n\n        \n        bool minted = super.mint(to, value);\n\n        \n        if (minted)\n            _addBalanceRecord(to);\n\n        \n        return minted;\n    }\n\n    \n    function transfer(address to, uint256 value)\n    public\n    returns (bool)\n    {\n        \n        bool transferred = super.transfer(to, value);\n\n        \n        if (transferred) {\n            _addBalanceRecord(msg.sender);\n            _addBalanceRecord(to);\n        }\n\n        \n        return transferred;\n    }\n\n    \n    function approve(address spender, uint256 value)\n    public\n    returns (bool)\n    {\n        \n        require(\n            0 == value || 0 == allowance(msg.sender, spender),\n            \"Value or allowance non-zero [RevenueToken.sol:117]\"\n        );\n\n        \n        return super.approve(spender, value);\n    }\n\n    \n    function transferFrom(address from, address to, uint256 value)\n    public\n    returns (bool)\n    {\n        \n        bool transferred = super.transferFrom(from, to, value);\n\n        \n        if (transferred) {\n            _addBalanceRecord(from);\n            _addBalanceRecord(to);\n        }\n\n        \n        return transferred;\n    }\n\n    \n    function upgrade(TokenUpgradeAgent tokenUpgradeAgent, uint256 value)\n    public\n    returns (bool)\n    {\n        \n        _burn(msg.sender, value);\n\n        \n        bool upgraded = tokenUpgradeAgent.upgradeFrom(msg.sender, value);\n\n        \n        require(upgraded, \"Upgrade failed [RevenueToken.sol:168]\");\n\n        \n        emit Upgrade(tokenUpgradeAgent, msg.sender, value);\n\n        \n        return upgraded;\n    }\n\n    \n    function upgradeFrom(TokenUpgradeAgent tokenUpgradeAgent, address from, uint256 value)\n    public\n    returns (bool)\n    {\n        \n        _burnFrom(from, value);\n\n        \n        bool upgraded = tokenUpgradeAgent.upgradeFrom(from, value);\n\n        \n        require(upgraded, \"Upgrade failed [RevenueToken.sol:195]\");\n\n        \n        emit UpgradeFrom(tokenUpgradeAgent, msg.sender, from, value);\n\n        \n        return upgraded;\n    }\n\n    \n    function balanceRecordsCount(address account)\n    public\n    view\n    returns (uint256)\n    {\n        return balanceRecords[account].length;\n    }\n\n    \n    function recordBalance(address account, uint256 index)\n    public\n    view\n    returns (uint256)\n    {\n        return balanceRecords[account][index].balance;\n    }\n\n    \n    function recordBlockNumber(address account, uint256 index)\n    public\n    view\n    returns (uint256)\n    {\n        return balanceRecords[account][index].blockNumber;\n    }\n\n    \n    function recordIndexByBlockNumber(address account, uint256 blockNumber)\n    public\n    view\n    returns (int256)\n    {\n        for (uint256 i = balanceRecords[account].length; i > 0;) {\n            i = i.sub(1);\n            if (balanceRecords[account][i].blockNumber <= blockNumber)\n                return int256(i);\n        }\n        return - 1;\n    }\n\n    \n    function upgradeBalanceRecords(address account, BalanceRecord[] memory _balanceRecords)\n    public\n    onlyMinter\n    {\n        \n        if (0 < _balanceRecords.length) {\n            \n            require(!mintingDisabled, \"Minting disabled [RevenueToken.sol:280]\");\n\n            \n            uint256 startIndex = balanceRecords[account].length;\n            uint256 endIndex = startIndex.add(_balanceRecords.length).sub(1);\n\n            \n            uint256 previousBlockNumber = startIndex > 0 ? balanceRecords[account][startIndex - 1].blockNumber : 0;\n\n            \n            for (uint256 i = 0; i < _balanceRecords.length; i++) {\n                \n                require(previousBlockNumber <= _balanceRecords[i].blockNumber, \"Invalid balance record block number [RevenueToken.sol:292]\");\n\n                \n                balanceRecords[account].push(_balanceRecords[i]);\n\n                \n                previousBlockNumber = _balanceRecords[i].blockNumber;\n            }\n\n            \n            emit UpgradeBalanceRecords(account, startIndex, endIndex);\n        }\n    }\n\n    \n    function _addBalanceRecord(address account)\n    private\n    {\n        balanceRecords[account].push(BalanceRecord(block.number, balanceOf(account)));\n    }\n}\n\ncontract TokenHolderRevenueFund is Ownable, AccrualBeneficiary, Servable, TransferControllerManageable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\n    using CurrenciesLib for CurrenciesLib.Currencies;\n\n    \n    \n    \n    string constant public CLOSE_ACCRUAL_PERIOD_ACTION = \"close_accrual_period\";\n\n    \n    \n    \n    struct Accrual {\n        uint256 startBlock;\n        uint256 endBlock;\n        int256 amount;\n\n        mapping(address => ClaimRecord) claimRecordsByWallet;\n    }\n\n    struct ClaimRecord {\n        bool completed;\n        BlockSpan[] completedSpans;\n    }\n\n    struct BlockSpan {\n        uint256 startBlock;\n        uint256 endBlock;\n    }\n\n    \n    \n    \n    RevenueTokenManager public revenueTokenManager;\n    BalanceAucCalculator public balanceBlocksCalculator;\n    BalanceAucCalculator public releasedAmountBlocksCalculator;\n\n    FungibleBalanceLib.Balance private periodAccrual;\n    CurrenciesLib.Currencies private periodCurrencies;\n\n    FungibleBalanceLib.Balance private aggregateAccrual;\n    CurrenciesLib.Currencies private aggregateCurrencies;\n\n    mapping(address => mapping(uint256 => Accrual[])) public closedAccrualsByCurrency;\n\n    address[] public nonClaimers;\n    mapping(address => uint256) public nonClaimerIndicesByWallet;\n\n    mapping(address => mapping(address => mapping(uint256 => uint256[]))) public claimedAccrualIndicesByWalletCurrency;\n    mapping(address => mapping(address => mapping(uint256 => mapping(uint256 => bool)))) public accrualClaimedByWalletCurrencyAccrual;\n\n    mapping(address => mapping(address => mapping(uint256 => mapping(uint256 => uint256)))) public maxClaimedBlockNumberByWalletCurrencyAccrual;\n    uint256 public claimBlockNumberBatchSize;\n\n    mapping(address => mapping(uint256 => mapping(uint256 => int256))) public aggregateAccrualAmountByCurrencyBlockNumber;\n\n    mapping(address => FungibleBalanceLib.Balance) private stagedByWallet;\n\n    \n    \n    \n    event SetRevenueTokenManagerEvent(RevenueTokenManager manager);\n    event SetBalanceBlocksCalculatorEvent(BalanceAucCalculator calculator);\n    event SetReleasedAmountBlocksCalculatorEvent(BalanceAucCalculator calculator);\n    event SetClaimBlockNumberBatchSizeEvent(uint256 batchSize);\n    event RegisterNonClaimerEvent(address wallet);\n    event DeregisterNonClaimerEvent(address wallet);\n    event ReceiveEvent(address wallet, int256 amount, address currencyCt,\n        uint256 currencyId);\n    event WithdrawEvent(address to, int256 amount, address currencyCt, uint256 currencyId);\n    event CloseAccrualPeriodEvent(int256 periodAmount, int256 aggregateAmount, address currencyCt,\n        uint256 currencyId);\n    event ClaimAndTransferToBeneficiaryByAccrualsEvent(address wallet, string balanceType, int256 amount,\n        address currencyCt, uint256 currencyId, uint256 startAccrualIndex, uint256 endAccrualIndex,\n        string standard);\n    event ClaimAndTransferToBeneficiaryByBlockNumbersEvent(address wallet, string balanceType, int256 amount,\n        address currencyCt, uint256 currencyId, uint256 startBlock, uint256 endBlock,\n        string standard);\n    event ClaimAndStageByAccrualsEvent(address from, int256 amount, address currencyCt,\n        uint256 currencyId, uint256 startAccrualIndex, uint256 endAccrualIndex);\n    event ClaimAndStageByBlockNumbersEvent(address from, int256 amount, address currencyCt,\n        uint256 currencyId, uint256 startBlock, uint256 endBlock);\n    event WithdrawEvent(address from, int256 amount, address currencyCt, uint256 currencyId,\n        string standard);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    \n    \n    function setRevenueTokenManager(RevenueTokenManager manager)\n    public\n    onlyDeployer\n    notNullAddress(address(manager))\n    {\n        \n        revenueTokenManager = manager;\n\n        \n        emit SetRevenueTokenManagerEvent(manager);\n    }\n\n    \n    \n    function setBalanceBlocksCalculator(BalanceAucCalculator calculator)\n    public\n    onlyDeployer\n    notNullOrThisAddress(address(calculator))\n    {\n        \n        balanceBlocksCalculator = calculator;\n\n        \n        emit SetBalanceBlocksCalculatorEvent(balanceBlocksCalculator);\n    }\n\n    \n    \n    function setReleasedAmountBlocksCalculator(BalanceAucCalculator calculator)\n    public\n    onlyDeployer\n    notNullOrThisAddress(address(calculator))\n    {\n        \n        releasedAmountBlocksCalculator = calculator;\n\n        \n        emit SetReleasedAmountBlocksCalculatorEvent(releasedAmountBlocksCalculator);\n    }\n\n    \n    \n    \n    \n    function setClaimBlockNumberBatchSize(uint256 batchSize)\n    public\n    onlyDeployer\n    {\n        \n        claimBlockNumberBatchSize = batchSize;\n\n        \n        emit SetClaimBlockNumberBatchSizeEvent(batchSize);\n    }\n\n    \n    \n    function nonClaimersCount()\n    public\n    view\n    returns (uint256)\n    {\n        return nonClaimers.length;\n    }\n\n    \n    \n    \n    function isNonClaimer(address wallet)\n    public\n    view\n    returns (bool)\n    {\n        return 0 < nonClaimerIndicesByWallet[wallet];\n    }\n\n    \n    \n    function registerNonClaimer(address wallet)\n    public\n    onlyDeployer\n    notNullAddress(wallet)\n    {\n        \n        if (0 == nonClaimerIndicesByWallet[wallet]) {\n            \n            nonClaimers.push(wallet);\n            nonClaimerIndicesByWallet[wallet] = nonClaimers.length;\n\n            \n            emit RegisterNonClaimerEvent(wallet);\n        }\n    }\n\n    \n    \n    function deregisterNonClaimer(address wallet)\n    public\n    onlyDeployer\n    notNullAddress(wallet)\n    {\n        \n        if (0 < nonClaimerIndicesByWallet[wallet]) {\n            \n            if (nonClaimerIndicesByWallet[wallet] < nonClaimers.length) {\n                nonClaimers[nonClaimerIndicesByWallet[wallet].sub(1)] = nonClaimers[nonClaimers.length.sub(1)];\n                nonClaimerIndicesByWallet[nonClaimers[nonClaimers.length.sub(1)]] = nonClaimerIndicesByWallet[wallet];\n            }\n            nonClaimers.length--;\n            nonClaimerIndicesByWallet[wallet] = 0;\n\n            \n            emit DeregisterNonClaimerEvent(wallet);\n        }\n    }\n\n    \n    function() external payable {\n        receiveEthersTo(msg.sender, \"\");\n    }\n\n    \n    \n    function receiveEthersTo(address wallet, string memory)\n    public\n    payable\n    {\n        int256 amount = SafeMathIntLib.toNonZeroInt256(msg.value);\n\n        \n        periodAccrual.add(amount, address(0), 0);\n        aggregateAccrual.add(amount, address(0), 0);\n\n        \n        periodCurrencies.add(address(0), 0);\n        aggregateCurrencies.add(address(0), 0);\n\n        \n        emit ReceiveEvent(wallet, amount, address(0), 0);\n    }\n\n    \n    \n    \n    \n    \n    function receiveTokens(string memory, int256 amount, address currencyCt, uint256 currencyId,\n        string memory standard)\n    public\n    {\n        receiveTokensTo(msg.sender, \"\", amount, currencyCt, currencyId, standard);\n    }\n\n    \n    \n    \n    \n    \n    \n    function receiveTokensTo(address wallet, string memory, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        require(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [TokenHolderRevenueFund.sol:293]\");\n\n        \n        TransferController controller = transferController(currencyCt, standard);\n        (bool success,) = address(controller).delegatecall(\n            abi.encodeWithSelector(\n                controller.getReceiveSignature(), msg.sender, this, uint256(amount), currencyCt, currencyId\n            )\n        );\n        require(success, \"Reception by controller failed [TokenHolderRevenueFund.sol:302]\");\n\n        \n        periodAccrual.add(amount, currencyCt, currencyId);\n        aggregateAccrual.add(amount, currencyCt, currencyId);\n\n        \n        periodCurrencies.add(currencyCt, currencyId);\n        aggregateCurrencies.add(currencyCt, currencyId);\n\n        \n        emit ReceiveEvent(wallet, amount, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    function periodAccrualBalance(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return periodAccrual.get(currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function aggregateAccrualBalance(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return aggregateAccrual.get(currencyCt, currencyId);\n    }\n\n    \n    \n    function periodCurrenciesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return periodCurrencies.count();\n    }\n\n    \n    \n    \n    \n    function periodCurrenciesByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        return periodCurrencies.getByIndices(low, up);\n    }\n\n    \n    \n    function aggregateCurrenciesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return aggregateCurrencies.count();\n    }\n\n    \n    \n    \n    \n    function aggregateCurrenciesByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        return aggregateCurrencies.getByIndices(low, up);\n    }\n\n    \n    \n    \n    \n    \n    function stagedBalance(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return stagedByWallet[wallet].get(currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    function closedAccrualsCount(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return closedAccrualsByCurrency[currencyCt][currencyId].length;\n    }\n\n    \n    \n    function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory currencies)\n    public\n    onlyEnabledServiceAction(CLOSE_ACCRUAL_PERIOD_ACTION)\n    {\n        \n        for (uint256 i = 0; i < currencies.length; i = i.add(1)) {\n            MonetaryTypesLib.Currency memory currency = currencies[i];\n\n            \n            int256 periodAmount = periodAccrual.get(currency.ct, currency.id);\n\n            \n            uint256 startBlock = (\n            0 == closedAccrualsByCurrency[currency.ct][currency.id].length ?\n            0 :\n            closedAccrualsByCurrency[currency.ct][currency.id][closedAccrualsByCurrency[currency.ct][currency.id].length - 1].endBlock + 1\n            );\n\n            \n            closedAccrualsByCurrency[currency.ct][currency.id].push(Accrual(startBlock, block.number, periodAmount));\n\n            \n            aggregateAccrualAmountByCurrencyBlockNumber[currency.ct][currency.id][block.number] = aggregateAccrualBalance(\n                currency.ct, currency.id\n            );\n\n            if (periodAmount > 0) {\n                \n                periodAccrual.set(0, currency.ct, currency.id);\n\n                \n                periodCurrencies.removeByCurrency(currency.ct, currency.id);\n            }\n\n            \n            emit CloseAccrualPeriodEvent(\n                periodAmount,\n                aggregateAccrualAmountByCurrencyBlockNumber[currency.ct][currency.id][block.number],\n                currency.ct, currency.id\n            );\n        }\n    }\n\n    \n    \n    \n    \n    \n    function closedAccrualIndexByBlockNumber(address currencyCt, uint256 currencyId, uint256 blockNumber)\n    public\n    view\n    returns (uint256)\n    {\n        for (uint256 i = closedAccrualsByCurrency[currencyCt][currencyId].length; i > 0;) {\n            i = i.sub(1);\n            if (closedAccrualsByCurrency[currencyCt][currencyId][i].startBlock <= blockNumber)\n                return i;\n        }\n        return 0;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function claimableAmountByAccruals(address wallet, address currencyCt, uint256 currencyId,\n        uint256 startAccrualIndex, uint256 endAccrualIndex)\n    public\n    view\n    returns (int256)\n    {\n        \n        if (isNonClaimer(wallet))\n            return 0;\n\n        \n        if (0 == closedAccrualsByCurrency[currencyCt][currencyId].length)\n            return 0;\n\n        \n        require(startAccrualIndex <= endAccrualIndex, \"Accrual index ordinality mismatch [TokenHolderRevenueFund.sol:496]\");\n\n        \n        int256 claimableAmount = 0;\n\n        \n        for (\n            uint256 i = startAccrualIndex;\n            i <= endAccrualIndex && i < closedAccrualsByCurrency[currencyCt][currencyId].length;\n            i = i.add(1)\n        ) {\n            \n            claimableAmount = claimableAmount.add(\n                _claimableAmount(wallet, closedAccrualsByCurrency[currencyCt][currencyId][i])\n            );\n        }\n\n        \n        return claimableAmount;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function claimableAmountByBlockNumbers(address wallet, address currencyCt, uint256 currencyId,\n        uint256 startBlock, uint256 endBlock)\n    public\n    view\n    returns (int256)\n    {\n        \n        if (isNonClaimer(wallet))\n            return 0;\n\n        \n        if (0 == closedAccrualsByCurrency[currencyCt][currencyId].length)\n            return 0;\n\n        \n        require(startBlock <= endBlock, \"Block number ordinality mismatch [TokenHolderRevenueFund.sol:540]\");\n\n        \n        uint256 startAccrualIndex = closedAccrualIndexByBlockNumber(currencyCt, currencyId, startBlock);\n        uint256 endAccrualIndex = closedAccrualIndexByBlockNumber(currencyCt, currencyId, endBlock);\n\n        \n        Accrual storage endAccrual = closedAccrualsByCurrency[currencyCt][currencyId][endAccrualIndex];\n\n        \n        if (endBlock < endAccrual.startBlock)\n            return 0;\n\n        \n        int256 claimableAmount = 0;\n\n        \n        if (startAccrualIndex < endAccrualIndex) {\n            \n            Accrual storage startAccrual = closedAccrualsByCurrency[currencyCt][currencyId][startAccrualIndex];\n\n            \n            claimableAmount = _claimableAmount(\n                wallet, startAccrual,\n                startBlock.clampMin(startAccrual.startBlock),\n                endBlock.clampMax(startAccrual.endBlock)\n            );\n        }\n\n        \n        for (uint256 i = startAccrualIndex.add(1); i < endAccrualIndex; i = i.add(1)) {\n            \n            claimableAmount = claimableAmount.add(\n                _claimableAmount(wallet, closedAccrualsByCurrency[currencyCt][currencyId][i])\n            );\n        }\n\n        \n        claimableAmount = claimableAmount.add(\n            _claimableAmount(\n                wallet, endAccrual,\n                startBlock.clampMin(endAccrual.startBlock),\n                endBlock.clampMax(endAccrual.endBlock)\n            )\n        );\n\n        \n        return claimableAmount;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function claimAndTransferToBeneficiaryByAccruals(Beneficiary beneficiary, address destWallet, string memory balanceType,\n        address currencyCt, uint256 currencyId, uint256 startAccrualIndex, uint256 endAccrualIndex,\n        string memory standard)\n    public\n    {\n        \n        require(!isNonClaimer(msg.sender), \"Message sender is non-claimer [TokenHolderRevenueFund.sol:605]\");\n\n        \n        int256 claimedAmount = _claimByAccruals(msg.sender, currencyCt, currencyId, startAccrualIndex, endAccrualIndex);\n\n        \n        _transferToBeneficiary(beneficiary, destWallet, balanceType, claimedAmount,\n            currencyCt, currencyId, standard);\n\n        \n        emit ClaimAndTransferToBeneficiaryByAccrualsEvent(msg.sender, balanceType, claimedAmount, currencyCt, currencyId,\n            startAccrualIndex, endAccrualIndex, standard);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function claimAndTransferToBeneficiaryByBlockNumbers(Beneficiary beneficiary, address destWallet,\n        string memory balanceType, address currencyCt, uint256 currencyId, uint256 startBlock,\n        uint256 endBlock, string memory standard)\n    public\n    {\n        \n        require(!isNonClaimer(msg.sender), \"Message sender is non-claimer [TokenHolderRevenueFund.sol:634]\");\n\n        \n        int256 claimedAmount = _claimByBlockNumbers(msg.sender, currencyCt, currencyId, startBlock, endBlock);\n\n        \n        _transferToBeneficiary(beneficiary, destWallet, balanceType, claimedAmount,\n            currencyCt, currencyId, standard);\n\n        \n        emit ClaimAndTransferToBeneficiaryByBlockNumbersEvent(msg.sender, balanceType, claimedAmount, currencyCt,\n            currencyId, startBlock, endBlock, standard);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function claimAndTransferToBeneficiary(Beneficiary beneficiary, address destWallet, string memory balanceType,\n        address currencyCt, uint256 currencyId, string memory standard)\n    public\n    {\n        \n        \n        uint256 accrualIndex = (\n        0 == claimedAccrualIndicesByWalletCurrency[msg.sender][currencyCt][currencyId].length ?\n        0 :\n        claimedAccrualIndicesByWalletCurrency[msg.sender][currencyCt][currencyId][\n        claimedAccrualIndicesByWalletCurrency[msg.sender][currencyCt][currencyId].length - 1\n        ] + 1\n        );\n\n        \n        if (0 == claimBlockNumberBatchSize) {\n            \n            _updateClaimedAccruals(msg.sender, currencyCt, currencyId, accrualIndex);\n\n            \n            claimAndTransferToBeneficiaryByAccruals(\n                beneficiary, destWallet, balanceType, currencyCt, currencyId,\n                accrualIndex, accrualIndex, standard\n            );\n        }\n\n        \n        else {\n            \n            Accrual storage accrual = closedAccrualsByCurrency[currencyCt][currencyId][accrualIndex];\n\n            \n            uint256 startBlock = (\n            0 == maxClaimedBlockNumberByWalletCurrencyAccrual[msg.sender][currencyCt][currencyId][accrualIndex] ?\n            accrual.startBlock :\n            maxClaimedBlockNumberByWalletCurrencyAccrual[msg.sender][currencyCt][currencyId][accrualIndex] + 1\n            ).clampMax(accrual.endBlock);\n            uint256 endBlock = (startBlock + claimBlockNumberBatchSize - 1).clampMax(accrual.endBlock);\n\n            \n            if (endBlock == accrual.endBlock)\n                _updateClaimedAccruals(msg.sender, currencyCt, currencyId, accrualIndex);\n\n            \n            maxClaimedBlockNumberByWalletCurrencyAccrual[msg.sender][currencyCt][currencyId][accrualIndex] = endBlock;\n\n            \n            claimAndTransferToBeneficiaryByBlockNumbers(\n                beneficiary, destWallet, balanceType, currencyCt, currencyId,\n                startBlock, endBlock, standard\n            );\n        }\n    }\n\n    \n    \n    \n    \n    \n    function claimAndStageByAccruals(address currencyCt, uint256 currencyId,\n        uint256 startAccrualIndex, uint256 endAccrualIndex)\n    public\n    {\n        \n        require(!isNonClaimer(msg.sender), \"Message sender is non-claimer [TokenHolderRevenueFund.sol:719]\");\n\n        \n        int256 claimedAmount = _claimByAccruals(msg.sender, currencyCt, currencyId, startAccrualIndex, endAccrualIndex);\n\n        \n        if (0 < claimedAmount) {\n            \n            stagedByWallet[msg.sender].add(claimedAmount, currencyCt, currencyId);\n\n            \n            emit ClaimAndStageByAccrualsEvent(msg.sender, claimedAmount, currencyCt, currencyId, startAccrualIndex, endAccrualIndex);\n        }\n    }\n\n    \n    \n    \n    \n    \n    function claimAndStageByBlockNumbers(address currencyCt, uint256 currencyId,\n        uint256 startBlock, uint256 endBlock)\n    public\n    {\n        \n        require(!isNonClaimer(msg.sender), \"Message sender is non-claimer [TokenHolderRevenueFund.sol:744]\");\n\n        \n        int256 claimedAmount = _claimByBlockNumbers(msg.sender, currencyCt, currencyId, startBlock, endBlock);\n\n        \n        if (0 < claimedAmount) {\n            \n            stagedByWallet[msg.sender].add(claimedAmount, currencyCt, currencyId);\n\n            \n            emit ClaimAndStageByBlockNumbersEvent(msg.sender, claimedAmount, currencyCt, currencyId, startBlock, endBlock);\n        }\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function fullyClaimed(address wallet, address currencyCt, uint256 currencyId, uint256 accrualIndex)\n    public\n    view\n    returns (bool)\n    {\n        \n        return (\n        accrualIndex < closedAccrualsByCurrency[currencyCt][currencyId].length &&\n        closedAccrualsByCurrency[currencyCt][currencyId][accrualIndex].claimRecordsByWallet[wallet].completed\n        );\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function partiallyClaimed(address wallet, address currencyCt, uint256 currencyId, uint256 accrualIndex)\n    public\n    view\n    returns (bool)\n    {\n        \n        return (\n        accrualIndex < closedAccrualsByCurrency[currencyCt][currencyId].length &&\n        0 < closedAccrualsByCurrency[currencyCt][currencyId][accrualIndex].claimRecordsByWallet[wallet].completedSpans.length\n        );\n    }\n\n    \n    \n    \n    \n    \n    \n    function claimedBlockSpans(address wallet, address currencyCt, uint256 currencyId, uint256 accrualIndex)\n    public\n    view\n    returns (BlockSpan[] memory)\n    {\n        if (closedAccrualsByCurrency[currencyCt][currencyId].length <= accrualIndex)\n            return new BlockSpan[](0);\n\n        return closedAccrualsByCurrency[currencyCt][currencyId][accrualIndex].claimRecordsByWallet[wallet].completedSpans;\n    }\n\n    \n    \n    \n    \n    \n    function withdraw(int256 amount, address currencyCt, uint256 currencyId, string memory standard)\n    public\n    {\n        \n        require(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [TokenHolderRevenueFund.sol:823]\");\n\n        \n        amount = amount.clampMax(stagedByWallet[msg.sender].get(currencyCt, currencyId));\n\n        \n        stagedByWallet[msg.sender].sub(amount, currencyCt, currencyId);\n\n        \n        if (address(0) == currencyCt && 0 == currencyId)\n            msg.sender.transfer(uint256(amount));\n\n        else {\n            TransferController controller = transferController(currencyCt, standard);\n            (bool success,) = address(controller).delegatecall(\n                abi.encodeWithSelector(\n                    controller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n                )\n            );\n            require(success, \"Dispatch by controller failed [TokenHolderRevenueFund.sol:842]\");\n        }\n\n        \n        emit WithdrawEvent(msg.sender, amount, currencyCt, currencyId, standard);\n    }\n\n    \n    \n    \n    function _claimByAccruals(address wallet, address currencyCt, uint256 currencyId,\n        uint256 startAccrualIndex, uint256 endAccrualIndex)\n    private\n    returns (int256)\n    {\n        \n        require(0 < closedAccrualsByCurrency[currencyCt][currencyId].length, \"No terminated accrual found [TokenHolderRevenueFund.sol:858]\");\n\n        \n        require(startAccrualIndex <= endAccrualIndex, \"Accrual index mismatch [TokenHolderRevenueFund.sol:861]\");\n\n        \n        int256 claimedAmount = 0;\n\n        \n        for (\n            uint256 i = startAccrualIndex;\n            i <= endAccrualIndex && i < closedAccrualsByCurrency[currencyCt][currencyId].length;\n            i = i.add(1)\n        ) {\n            \n            Accrual storage accrual = closedAccrualsByCurrency[currencyCt][currencyId][i];\n\n            \n            claimedAmount = claimedAmount.add(_claimableAmount(wallet, accrual));\n\n            \n            _updateClaimRecord(wallet, accrual);\n        }\n\n        \n        return claimedAmount;\n    }\n\n    function _claimByBlockNumbers(address wallet, address currencyCt, uint256 currencyId,\n        uint256 startBlock, uint256 endBlock)\n    private\n    returns (int256)\n    {\n        \n        require(0 < closedAccrualsByCurrency[currencyCt][currencyId].length, \"No terminated accrual found [TokenHolderRevenueFund.sol:892]\");\n\n        \n        require(startBlock <= endBlock, \"Block number mismatch [TokenHolderRevenueFund.sol:895]\");\n\n        \n        uint256 startAccrualIndex = closedAccrualIndexByBlockNumber(currencyCt, currencyId, startBlock);\n        uint256 endAccrualIndex = closedAccrualIndexByBlockNumber(currencyCt, currencyId, endBlock);\n\n        \n        int256 claimedAmount = 0;\n        uint256 clampedStartBlock = 0;\n        uint256 clampedEndBlock = 0;\n\n        \n        if (startAccrualIndex < endAccrualIndex) {\n            \n            Accrual storage accrual = closedAccrualsByCurrency[currencyCt][currencyId][startAccrualIndex];\n\n            \n            clampedStartBlock = startBlock.clampMin(accrual.startBlock);\n            clampedEndBlock = endBlock.clampMax(accrual.endBlock);\n\n            \n            claimedAmount = _claimableAmount(wallet, accrual, clampedStartBlock, clampedEndBlock);\n\n            \n            _updateClaimRecord(wallet, accrual, clampedStartBlock, clampedEndBlock);\n        }\n\n        \n        for (uint256 i = startAccrualIndex.add(1); i < endAccrualIndex; i = i.add(1)) {\n            \n            Accrual storage accrual = closedAccrualsByCurrency[currencyCt][currencyId][i];\n\n            \n            claimedAmount = claimedAmount.add(_claimableAmount(wallet, accrual));\n\n            \n            _updateClaimRecord(wallet, accrual);\n        }\n\n        \n        Accrual storage accrual = closedAccrualsByCurrency[currencyCt][currencyId][endAccrualIndex];\n\n        \n        clampedStartBlock = startBlock.clampMin(accrual.startBlock);\n        clampedEndBlock = endBlock.clampMax(accrual.endBlock);\n\n        \n        claimedAmount = claimedAmount.add(\n            _claimableAmount(wallet, accrual, clampedStartBlock, clampedEndBlock)\n        );\n\n        \n        _updateClaimRecord(wallet, accrual, clampedStartBlock, clampedEndBlock);\n\n        \n        return claimedAmount;\n    }\n\n    function _transferToBeneficiary(Beneficiary beneficiary, address destWallet, string memory balanceType,\n        int256 amount, address currencyCt, uint256 currencyId, string memory standard)\n    private\n    {\n        \n        if (address(0) == currencyCt && 0 == currencyId)\n            beneficiary.receiveEthersTo.value(uint256(amount))(destWallet, balanceType);\n\n        else {\n            \n            TransferController controller = transferController(currencyCt, standard);\n            (bool success,) = address(controller).delegatecall(\n                abi.encodeWithSelector(\n                    controller.getApproveSignature(), address(beneficiary), uint256(amount), currencyCt, currencyId\n                )\n            );\n            require(success, \"Approval by controller failed [TokenHolderRevenueFund.sol:969]\");\n\n            \n            beneficiary.receiveTokensTo(destWallet, balanceType, amount, currencyCt, currencyId, standard);\n        }\n    }\n\n    function _updateClaimRecord(address wallet, Accrual storage accrual)\n    private\n    {\n        \n        accrual.claimRecordsByWallet[wallet].completed = true;\n\n        \n        if (0 < accrual.claimRecordsByWallet[wallet].completedSpans.length)\n            accrual.claimRecordsByWallet[wallet].completedSpans.length = 0;\n    }\n\n    function _updateClaimRecord(address wallet, Accrual storage accrual,\n        uint256 startBlock, uint256 endBlock)\n    private\n    {\n        \n        accrual.claimRecordsByWallet[wallet].completedSpans.push(\n            BlockSpan(startBlock, endBlock)\n        );\n    }\n\n    function _updateClaimedAccruals(address wallet, address currencyCt, uint256 currencyId, uint256 accrualIndex)\n    private\n    {\n        if (!accrualClaimedByWalletCurrencyAccrual[wallet][currencyCt][currencyId][accrualIndex]) {\n            claimedAccrualIndicesByWalletCurrency[wallet][currencyCt][currencyId].push(accrualIndex);\n            accrualClaimedByWalletCurrencyAccrual[wallet][currencyCt][currencyId][accrualIndex] = true;\n        }\n    }\n\n    \n    \n    function _isClaimable(address wallet, Accrual storage accrual)\n    private\n    view\n    returns (bool)\n    {\n        \n        return (\n        0 < accrual.amount &&\n        !accrual.claimRecordsByWallet[wallet].completed &&\n        0 == accrual.claimRecordsByWallet[wallet].completedSpans.length\n        );\n    }\n\n    function _isClaimable(address wallet, Accrual storage accrual,\n        uint256 startBlock, uint256 endBlock)\n    private\n    view\n    returns (bool)\n    {\n        \n        if (\n            0 == accrual.amount ||\n        accrual.claimRecordsByWallet[wallet].completed\n        )\n            return false;\n\n        \n        for (uint256 i = 0;\n            i < accrual.claimRecordsByWallet[wallet].completedSpans.length;\n            i = i.add(1)) {\n            if (\n                (\n                accrual.claimRecordsByWallet[wallet].completedSpans[i].startBlock <= startBlock &&\n                startBlock <= accrual.claimRecordsByWallet[wallet].completedSpans[i].endBlock\n                ) ||\n                (\n                accrual.claimRecordsByWallet[wallet].completedSpans[i].startBlock <= endBlock &&\n                endBlock <= accrual.claimRecordsByWallet[wallet].completedSpans[i].endBlock\n                )\n            )\n                return false;\n        }\n\n        return true;\n    }\n\n    function _claimableAmount(address wallet, Accrual storage accrual)\n    private\n    view\n    returns (int256)\n    {\n        \n        if (!_isClaimable(wallet, accrual))\n            return 0;\n\n        \n        int256 _releasedAmountBlocks = _correctedReleasedAmountBlocks(\n            accrual.startBlock, accrual.endBlock\n        );\n\n        \n        if (0 == _releasedAmountBlocks)\n            return 0;\n\n        \n        int256 _walletBalanceBlocks = _balanceBlocks(\n            wallet, accrual.startBlock, accrual.endBlock\n        );\n\n        \n        return accrual.amount\n        .mul_nn(_walletBalanceBlocks)\n        .div_nn(_releasedAmountBlocks);\n    }\n\n    function _claimableAmount(address wallet, Accrual storage accrual,\n        uint256 startBlock, uint256 endBlock)\n    private\n    view\n    returns (int256)\n    {\n        \n        if (!_isClaimable(wallet, accrual, startBlock, endBlock))\n            return 0;\n\n        \n        int256 _releasedAmountBlocks = _correctedReleasedAmountBlocks(\n            startBlock, endBlock\n        );\n\n        \n        if (0 == _releasedAmountBlocks)\n            return 0;\n\n        \n        int256 _walletBalanceBlocks = _balanceBlocks(\n            wallet, startBlock, endBlock\n        );\n\n        \n        int256 _accrualNumerator = int256(endBlock.sub(startBlock).add(1));\n        int256 _accrualDenominator = int256(accrual.endBlock.sub(accrual.startBlock).add(1));\n\n        \n        return accrual.amount\n        .mul_nn(_walletBalanceBlocks)\n        .mul_nn(_accrualNumerator)\n        .div_nn(_releasedAmountBlocks.mul_nn(_accrualDenominator));\n    }\n\n    function _balanceBlocks(address wallet, uint256 startBlock, uint256 endBlock)\n    private\n    view\n    returns (int256)\n    {\n        return int256(balanceBlocksCalculator.calculate(\n                BalanceRecordable(address(revenueTokenManager.token())), wallet, startBlock, endBlock\n            ));\n    }\n\n    function _correctedReleasedAmountBlocks(uint256 startBlock, uint256 endBlock)\n    private\n    view\n    returns (int256)\n    {\n        \n        int256 amountBlocks = int256(releasedAmountBlocksCalculator.calculate(\n                BalanceRecordable(address(revenueTokenManager)), address(0), startBlock, endBlock\n            ));\n\n        \n        for (uint256 i = 0; i < nonClaimers.length; i = i.add(1))\n            amountBlocks = amountBlocks.sub(_balanceBlocks(nonClaimers[i], startBlock, endBlock));\n\n        \n        return amountBlocks;\n    }\n}\n\ncontract RevenueFundAccrualMonitor is Ownable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n\n    \n    \n    \n    RevenueFund public revenueFund;\n    TokenHolderRevenueFund public tokenHolderRevenueFund;\n    RevenueTokenManager public revenueTokenManager;\n    BalanceAucCalculator public balanceBlocksCalculator;\n    BalanceAucCalculator public releasedAmountBlocksCalculator;\n\n    \n    \n    \n    event SetRevenueFundEvent(RevenueFund revenueFund);\n    event SetTokenHolderRevenueFundEvent(TokenHolderRevenueFund tokenHolderRvenueFund);\n    event SetRevenueTokenManagerEvent(RevenueTokenManager revenueTokenManager);\n    event SetBalanceBlocksCalculatorEvent(BalanceAucCalculator balanceAucCalculator);\n    event SetReleasedAmountBlocksCalculatorEvent(BalanceAucCalculator balanceAucCalculator);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    \n    \n    function setRevenueFund(RevenueFund _revenueFund)\n    public\n    onlyDeployer\n    notNullAddress(address(_revenueFund))\n    {\n        \n        revenueFund = _revenueFund;\n\n        \n        emit SetRevenueFundEvent(revenueFund);\n    }\n\n    \n    \n    function setTokenHolderRevenueFund(TokenHolderRevenueFund _tokenHolderRevenueFund)\n    public\n    onlyDeployer\n    notNullAddress(address(_tokenHolderRevenueFund))\n    {\n        \n        tokenHolderRevenueFund = _tokenHolderRevenueFund;\n\n        \n        emit SetTokenHolderRevenueFundEvent(tokenHolderRevenueFund);\n    }\n\n    \n    \n    function setRevenueTokenManager(RevenueTokenManager _revenueTokenManager)\n    public\n    onlyDeployer\n    notNullAddress(address(_revenueTokenManager))\n    {\n        \n        revenueTokenManager = _revenueTokenManager;\n\n        \n        emit SetRevenueTokenManagerEvent(revenueTokenManager);\n    }\n\n    \n    \n    function setBalanceBlocksCalculator(BalanceAucCalculator _balanceAucCalculator)\n    public\n    onlyDeployer\n    notNullOrThisAddress(address(_balanceAucCalculator))\n    {\n        \n        balanceBlocksCalculator = _balanceAucCalculator;\n\n        \n        emit SetBalanceBlocksCalculatorEvent(balanceBlocksCalculator);\n    }\n\n    \n    \n    function setReleasedAmountBlocksCalculator(BalanceAucCalculator _balanceAucCalculator)\n    public\n    onlyDeployer\n    notNullOrThisAddress(address(_balanceAucCalculator))\n    {\n        \n        releasedAmountBlocksCalculator = _balanceAucCalculator;\n\n        \n        emit SetReleasedAmountBlocksCalculatorEvent(releasedAmountBlocksCalculator);\n    }\n\n    \n    \n    \n    \n    \n    \n    function claimableAmount(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        \n        \n        int256 accrualClaimableAmount = _accrualClaimableAmount(currencyCt, currencyId);\n\n        \n        \n        uint256 currentAccrualStartBlock = _currentAccrualStartBlock(currencyCt, currencyId);\n\n        \n        int256 balanceBlocks = _balanceBlocks(wallet, currentAccrualStartBlock, block.number);\n\n        \n        \n        int256 amountBlocks = _correctedReleasedAmountBlocks(currentAccrualStartBlock, block.number);\n\n        \n        return accrualClaimableAmount\n        .mul_nn(balanceBlocks)\n        .div_nn(amountBlocks);\n    }\n\n    \n    \n    \n    function _accrualClaimableAmount(address currencyCt, uint256 currencyId)\n    private\n    view\n    returns (int256)\n    {\n        int256 periodAccrualBalance = revenueFund.periodAccrualBalance(currencyCt, currencyId);\n\n        int256 beneficiaryFraction = revenueFund.beneficiaryFraction(tokenHolderRevenueFund);\n\n        return periodAccrualBalance\n        .mul_nn(beneficiaryFraction)\n        .div_nn(ConstantsLib.PARTS_PER());\n    }\n\n    function _currentAccrualStartBlock(address currencyCt, uint256 currencyId)\n    private\n    view\n    returns (uint256)\n    {\n        uint256 lastClosedAccrualIndex = tokenHolderRevenueFund.closedAccrualsCount(\n            currencyCt, currencyId\n        );\n        if (0 == lastClosedAccrualIndex)\n            return 0;\n        else {\n            (,uint256 endBlock,) = tokenHolderRevenueFund.closedAccrualsByCurrency(\n                currencyCt, currencyId, lastClosedAccrualIndex.sub(1)\n            );\n            return endBlock.add(1);\n        }\n    }\n\n    function _balanceBlocks(address wallet, uint256 startBlock, uint256 endBlock)\n    private\n    view\n    returns (int256)\n    {\n        return int256(balanceBlocksCalculator.calculate(\n                BalanceRecordable(address(revenueTokenManager.token())), wallet, startBlock, endBlock\n            ));\n    }\n\n    function _correctedReleasedAmountBlocks(uint256 startBlock, uint256 endBlock)\n    private\n    view\n    returns (int256)\n    {\n        \n        int256 amountBlocks = int256(releasedAmountBlocksCalculator.calculate(\n                BalanceRecordable(address(revenueTokenManager)), address(0), startBlock, endBlock\n            ));\n\n        \n        for (uint256 i = 0; i < tokenHolderRevenueFund.nonClaimersCount(); i = i.add(1))\n            amountBlocks = amountBlocks.sub(_balanceBlocks(tokenHolderRevenueFund.nonClaimers(i), startBlock, endBlock));\n\n        \n        return amountBlocks;\n    }\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"SelfDestructionDisabledEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract BalanceAucCalculator\",\"name\":\"balanceAucCalculator\",\"type\":\"address\"}],\"name\":\"SetBalanceBlocksCalculatorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldDeployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"SetDeployerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"SetOperatorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract BalanceAucCalculator\",\"name\":\"balanceAucCalculator\",\"type\":\"address\"}],\"name\":\"SetReleasedAmountBlocksCalculatorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract RevenueFund\",\"name\":\"revenueFund\",\"type\":\"address\"}],\"name\":\"SetRevenueFundEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract RevenueTokenManager\",\"name\":\"revenueTokenManager\",\"type\":\"address\"}],\"name\":\"SetRevenueTokenManagerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract TokenHolderRevenueFund\",\"name\":\"tokenHolderRvenueFund\",\"type\":\"address\"}],\"name\":\"SetTokenHolderRevenueFundEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"TriggerSelfDestructionEvent\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceBlocksCalculator\",\"outputs\":[{\"internalType\":\"contract BalanceAucCalculator\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"claimableAmount\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"destructor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"releasedAmountBlocksCalculator\",\"outputs\":[{\"internalType\":\"contract BalanceAucCalculator\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"revenueFund\",\"outputs\":[{\"internalType\":\"contract RevenueFund\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"revenueTokenManager\",\"outputs\":[{\"internalType\":\"contract RevenueTokenManager\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"selfDestructionDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract BalanceAucCalculator\",\"name\":\"_balanceAucCalculator\",\"type\":\"address\"}],\"name\":\"setBalanceBlocksCalculator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"setDeployer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract BalanceAucCalculator\",\"name\":\"_balanceAucCalculator\",\"type\":\"address\"}],\"name\":\"setReleasedAmountBlocksCalculator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract RevenueFund\",\"name\":\"_revenueFund\",\"type\":\"address\"}],\"name\":\"setRevenueFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract RevenueTokenManager\",\"name\":\"_revenueTokenManager\",\"type\":\"address\"}],\"name\":\"setRevenueTokenManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract TokenHolderRevenueFund\",\"name\":\"_tokenHolderRevenueFund\",\"type\":\"address\"}],\"name\":\"setTokenHolderRevenueFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenHolderRevenueFund\",\"outputs\":[{\"internalType\":\"contract TokenHolderRevenueFund\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"triggerSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RevenueFundAccrualMonitor","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"000000000000000000000000f05179bac3d1fbef58a2fcd7ad0f769840027cc6","Library":"ConstantsLib:5fcf3704016b90ded3c81d75613ceab0a6a26025","LicenseType":"","SwarmSource":"bzzr://dc2023b1cf4488b8dec775d7f579912e1f2bf0711c4b828cb5587a073dde9af3"}]}