{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/LiteSig.sol\r\n\r\npragma solidity 0.5.8;\r\n\r\n/**\r\n * LiteSig is a lighter weight multisig based on https://github.com/christianlundkvist/simple-multisig\r\n * Owners aggregate signatures offline and then broadcast a transaction with the required number of signatures.\r\n * Unlike other multisigs, this is meant to have minimal administration functions and other features in order\r\n * to reduce the footprint and attack surface.\r\n */\r\ncontract LiteSig {\r\n\r\n    //  Events triggered for incoming and outgoing transactions\r\n    event Deposit(address indexed source, uint value);\r\n    event Execution(uint indexed transactionId, address indexed destination, uint value, bytes data);\r\n    event ExecutionFailure(uint indexed transactionId, address indexed destination, uint value, bytes data);\r\n\r\n    // List of owner addresses - for external readers convenience only\r\n    address[] public owners;\r\n\r\n    // Mapping of owner address to keep track for lookups\r\n    mapping(address => bool) ownersMap;\r\n\r\n    // Nonce increments by one on each broadcast transaction to prevent replays\r\n    uint public nonce = 0;\r\n\r\n    // Number of required signatures from the list of owners\r\n    uint public requiredSignatures = 0;\r\n\r\n    // EIP712 Precomputed hashes:\r\n    // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\")\r\n    bytes32 constant EIP712DOMAINTYPE_HASH = 0xd87cd6ef79d4e2b95e15ce8abf732db51ec771f1ca2edccf22a46c729ac56472;\r\n\r\n    // keccak256(\"LiteSig\")\r\n    bytes32 constant NAME_HASH = 0x3308695f49e3f28122810c848e1569a04488ca4f6a11835568450d7a38a86120;\r\n\r\n    // keccak256(\"1\")\r\n    bytes32 constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\r\n\r\n    // keccak256(\"MultiSigTransaction(address destination,uint256 value,bytes data,uint256 nonce,address txOrigin)\")\r\n    bytes32 constant TXTYPE_HASH = 0x81336c6b66e18c614f29c0c96edcbcbc5f8e9221f35377412f0ea5d6f428918e;\r\n\r\n    // keccak256(\"TOKENSOFT\")\r\n    bytes32 constant SALT = 0x9c360831104e550f13ec032699c5f1d7f17190a31cdaf5c83945a04dfd319eea;\r\n\r\n    // Hash for EIP712, computed from data and contract address - ensures it can't be replayed against\r\n    // other contracts or chains\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n\r\n    // Track init state\r\n    bool initialized = false;\r\n\r\n    // The init function inputs a list of owners and the number of signatures that\r\n    //   are required before a transaction is executed.\r\n    // Owners list must be in ascending address order.\r\n    // Required sigs must be greater than 0 and less than or equal to number of owners.\r\n    // Chain ID prevents replay across chains\r\n    // This function can only be run one time\r\n    function init(address[] memory _owners, uint _requiredSignatures, uint chainId) public {\r\n        // Verify it can't be initialized again\r\n        require(!initialized, \"Init function can only be run once\");\r\n        initialized = true;\r\n\r\n        // Verify the lengths of values being passed in\r\n        require(_owners.length > 0 && _owners.length <= 10, \"Owners List min is 1 and max is 10\");\r\n        require(\r\n            _requiredSignatures > 0 && _requiredSignatures <= _owners.length,\r\n            \"Required signatures must be in the proper range\"\r\n        );\r\n\r\n        // Verify the owners list is valid and in order\r\n        // No 0 addresses or duplicates\r\n        address lastAdd = address(0);\r\n        for (uint i = 0; i < _owners.length; i++) {\r\n            require(_owners[i] > lastAdd, \"Owner addresses must be unique and in order\");\r\n            ownersMap[_owners[i]] = true;\r\n            lastAdd = _owners[i];\r\n        }\r\n\r\n        // Save off owner list and required sig.\r\n        owners = _owners;\r\n        requiredSignatures = _requiredSignatures;\r\n\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(EIP712DOMAINTYPE_HASH,\r\n            NAME_HASH,\r\n            VERSION_HASH,\r\n            chainId,\r\n            address(this),\r\n            SALT)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * This function is adapted from the OpenZeppelin libarary but instead of passing in bytes\r\n     * array, it already has the sig fields broken down.\r\n     *\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * (.note) This call _does not revert_ if the signature is invalid, or\r\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\r\n     * the zero address is returned.\r\n     *\r\n     * (.warning) `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise)\r\n     * be too long), and then calling `toEthSignedMessageHash` on it.\r\n     */\r\n    function safeRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\r\n\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            return address(0);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * Once the owners of the multisig have signed across the payload, they can submit it to this function.\r\n     * This will verify enough signatures were aggregated and then broadcast the transaction.\r\n     * It can be used to send ETH or trigger a function call against another address (or both).\r\n     *\r\n     * Signatures must be in the correct ascending order (according to associated addresses)\r\n     */\r\n    function submit(\r\n        uint8[] memory sigV,\r\n        bytes32[] memory sigR,\r\n        bytes32[] memory sigS,\r\n        address destination,\r\n        uint value,\r\n        bytes memory data\r\n    ) public returns (bool)\r\n    {\r\n        // Verify initialized\r\n        require(initialized, \"Initialization must be complete\");\r\n\r\n        // Verify signature lengths\r\n        require(sigR.length == sigS.length && sigR.length == sigV.length, \"Sig arrays not the same lengths\");\r\n        require(sigR.length == requiredSignatures, \"Signatures list is not the expected length\");\r\n\r\n        // EIP712 scheme: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md\r\n        // Note that the nonce is always included from the contract state to prevent replay attacks\r\n        // Note that tx.origin is included to ensure only a predetermined account can broadcast\r\n        bytes32 txInputHash = keccak256(abi.encode(TXTYPE_HASH, destination, value, keccak256(data), nonce, tx.origin));\r\n        bytes32 totalHash = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, txInputHash));\r\n\r\n        // Add in the ETH specific prefix\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, totalHash));\r\n\r\n        // Iterate and verify signatures are from owners\r\n        address lastAdd = address(0); // cannot have address(0) as an owner\r\n        for (uint i = 0; i < requiredSignatures; i++) {\r\n\r\n            // Recover the address from the signature - if anything is wrong, this will return 0\r\n            address recovered = safeRecover(prefixedHash, sigV[i], sigR[i], sigS[i]);\r\n\r\n            // Ensure the signature is from an owner address and there are no duplicates\r\n            // Also verifies error of 0 returned\r\n            require(ownersMap[recovered], \"Signature must be from an owner\");\r\n            require(recovered > lastAdd, \"Signature must be unique\");\r\n            lastAdd = recovered;\r\n        }\r\n\r\n        // Increment the nonce before making external call\r\n        nonce = nonce + 1;\r\n        (bool success, ) = address(destination).call.value(value)(data);\r\n        if(success) {\r\n            emit Execution(nonce, destination, value, data);\r\n        } else {\r\n            emit ExecutionFailure(nonce, destination, value, data);\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    // Allow ETH to be sent to this contract\r\n    function () external payable {\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/Administratable.sol\r\n\r\npragma solidity 0.5.8;\r\n\r\n\r\n/**\r\nThis contract allows a list of administrators to be tracked.  This list can then be enforced\r\non functions with administrative permissions.  Only the owner of the contract should be allowed\r\nto modify the administrator list.\r\n */\r\ncontract Administratable is Ownable {\r\n\r\n    // The mapping to track administrator accounts - true is reserved for admin addresses.\r\n    mapping (address => bool) public administrators;\r\n\r\n    // Events to allow tracking add/remove.\r\n    event AdminAdded(address indexed addedAdmin, address indexed addedBy);\r\n    event AdminRemoved(address indexed removedAdmin, address indexed removedBy);\r\n\r\n    /**\r\n    Function modifier to enforce administrative permissions.\r\n     */\r\n    modifier onlyAdministrator() {\r\n        require(isAdministrator(msg.sender), \"Calling account is not an administrator.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    Determine if the message sender is in the administrators list.\r\n     */\r\n    function isAdministrator(address addressToTest) public view returns (bool) {\r\n        return administrators[addressToTest];\r\n    }\r\n\r\n    /**\r\n    Add an admin to the list.  This should only be callable by the owner of the contract.\r\n     */\r\n    function addAdmin(address adminToAdd) public onlyOwner {\r\n        // Verify the account is not already an admin\r\n        require(administrators[adminToAdd] == false, \"Account to be added to admin list is already an admin\");\r\n\r\n        // Set the address mapping to true to indicate it is an administrator account.\r\n        administrators[adminToAdd] = true;\r\n\r\n        // Emit the event for any watchers.\r\n        emit AdminAdded(adminToAdd, msg.sender);\r\n    }\r\n\r\n    /**\r\n    Remove an admin from the list.  This should only be callable by the owner of the contract.\r\n     */\r\n    function removeAdmin(address adminToRemove) public onlyOwner {\r\n        // Verify the account is an admin\r\n        require(administrators[adminToRemove] == true, \"Account to be removed from admin list is not already an admin\");\r\n\r\n        // Set the address mapping to false to indicate it is NOT an administrator account.\r\n        administrators[adminToRemove] = false;\r\n\r\n        // Emit the event for any watchers.\r\n        emit AdminRemoved(adminToRemove, msg.sender);\r\n    }\r\n}\r\n\r\n// File: contracts/LiteSigFactory.sol\r\n\r\npragma solidity 0.5.8;\r\n\r\n\r\n\r\n/**\r\n * LiteSig Factory creates new instances of the multisig contract and triggers an event\r\n * for listeners to see the new contract.\r\n */\r\ncontract LiteSigFactory is Administratable {\r\n\r\n  // Event to track deployments\r\n  event Deployed(address indexed deployedAddress);\r\n\r\n  // Constructor for the factory\r\n  constructor() public {\r\n    // Add the deployer as an admin by default\r\n    Administratable.addAdmin(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * Function called by external addresses to create a new multisig contract\r\n   * Caller must be whitelisted as an admin - this is to prevent someone from sniping the address\r\n   * (the standard approach to locking in the sender addr into the salt was not chosen in case a long time\r\n   * passes before the contract is created and a new deployment account is required for some unknown reason)\r\n   */\r\n  function createLiteSig(bytes32 salt, address[] memory _owners, uint _requiredSignatures, uint chainId)\r\n    public onlyAdministrator returns (address) {\r\n    // Track the address for the new contract\r\n    address payable deployedAddress;\r\n\r\n    // Get the creation code from the payment handler\r\n    bytes memory code = type(LiteSig).creationCode;\r\n\r\n    // Drop into assembly to deploy with create2\r\n    assembly {\r\n      deployedAddress := create2(0, add(code, 0x20), mload(code), salt)\r\n      if iszero(extcodesize(deployedAddress)) { revert(0, 0) }\r\n    }\r\n\r\n    // Initialize the contract with this master's address\r\n    LiteSig(deployedAddress).init(_owners, _requiredSignatures, chainId);\r\n\r\n    // Trigger the event for any listeners\r\n    emit Deployed(deployedAddress);\r\n\r\n    // Return address back to caller if applicable\r\n    return deployedAddress;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"addressToTest\",\"type\":\"address\"}],\"name\":\"isAdministrator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"adminToRemove\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"salt\",\"type\":\"bytes32\"},{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_requiredSignatures\",\"type\":\"uint256\"},{\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"createLiteSig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"adminToAdd\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"administrators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"deployedAddress\",\"type\":\"address\"}],\"name\":\"Deployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addedAdmin\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"addedBy\",\"type\":\"address\"}],\"name\":\"AdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"removedAdmin\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"removedBy\",\"type\":\"address\"}],\"name\":\"AdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"LiteSigFactory","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://214af8fa564165917ad7c5fd97aa4a26d94abd0de2a21f225b948da3d2f87b30"}]}