{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.15;\r\n\r\n/**\r\n* @author ESPAY PTY LTD.\r\n*/\r\n\r\n/**\r\n* @title ERC223Interface\r\n* @dev ERC223 Contract Interface\r\n*/\r\ncontract ERC20Interface {\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n    function balanceOf(address who)public view returns (uint);\r\n}\r\n\r\n/**\r\n* @title Forwarder\r\n* @dev Contract that will forward any incoming Ether & token to wallet\r\n*/\r\ncontract Forwarder {\r\n    \r\n    address payable public parentAddress;\r\n \r\n    event ForwarderDeposited(address from, uint value, bytes data);\r\n    event TokensFlushed(address forwarderAddress, uint value, address tokenContractAddress);\r\n\r\n    /**\r\n    * @dev Modifier that will execute internal code block only if the sender is the parent address\r\n    */\r\n    modifier onlyParent {\r\n        require(msg.sender == parentAddress);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n    * @dev Create the contract, and sets the destination address to that of the creator\r\n    */\r\n    constructor() public{\r\n        parentAddress = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Default function; Gets called when Ether is deposited, and forwards it to the parent address.\r\n    *      Credit eth to contract creator.\r\n    */\r\n    function() external payable {\r\n        parentAddress.transfer(msg.value);\r\n        emit ForwarderDeposited(msg.sender, msg.value, msg.data);\r\n    }\r\n\r\n    /**\r\n    * @dev Execute a token transfer of the full balance from the forwarder token to the parent address\r\n    * @param tokenContractAddress the address of the erc20 token contract\r\n    */\r\n    function flushTokens(address tokenContractAddress) public onlyParent {\r\n        ERC20Interface instance = ERC20Interface(tokenContractAddress);\r\n        uint forwarderBalance = instance.balanceOf(address(this));\r\n        require(forwarderBalance > 0);\r\n        require(instance.transfer(parentAddress, forwarderBalance));\r\n        emit TokensFlushed(address(this), forwarderBalance, tokenContractAddress);\r\n    }\r\n  \r\n    /**\r\n    * @dev Execute a specified token transfer from the forwarder token to the parent address.\r\n    * @param _from the address of the erc20 token contract.\r\n    * @param _value the amount of token.\r\n    */\r\n    function flushToken(address _from, uint _value) external{\r\n        require(ERC20Interface(_from).transfer(parentAddress, _value), \"instance error\");\r\n    }\r\n\r\n    /**\r\n    * @dev It is possible that funds were sent to this address before the contract was deployed.\r\n    *      We can flush those funds to the parent address.\r\n    */\r\n    function flush() public {\r\n        parentAddress.transfer(address(this).balance);\r\n    }\r\n}\r\n\r\n/**\r\n* @title MultiSignWallet\r\n*/\r\ncontract MultiSignWallet {\r\n    \r\n    address[] public signers;\r\n    bool public safeMode; \r\n    uint forwarderCount;\r\n    uint lastsequenceId;\r\n    \r\n    event Deposited(address from, uint value, bytes data);\r\n    event SafeModeActivated(address msgSender);\r\n    event SafeModeInActivated(address msgSender);\r\n    event ForwarderCreated(address forwarderAddress);\r\n    event Transacted(address msgSender, address otherSigner, bytes32 operation, address toAddress, uint value, bytes data);\r\n    event TokensTransfer(address tokenContractAddress, uint value);\r\n    \r\n    /**\r\n    * @dev Modifier that will execute internal code block only if the \r\n    *      sender is an authorized signer on this wallet\r\n    */\r\n    modifier onlySigner {\r\n        require(isSigner(msg.sender));\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Set up a simple multi-sig wallet by specifying the signers allowed to be used on this wallet.\r\n    *      2 signers will be required to send a transaction from this wallet.\r\n    *      Note: The sender is NOT automatically added to the list of signers.\r\n    *      Signers CANNOT be changed once they are set\r\n    * @param allowedSigners An array of signers on the wallet\r\n    */\r\n    constructor(address[] memory allowedSigners) public {\r\n        require(allowedSigners.length == 3);\r\n        signers = allowedSigners;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets called when a transaction is received without calling a method\r\n    */\r\n    function() external payable {\r\n        if(msg.value > 0){\r\n            emit Deposited(msg.sender, msg.value, msg.data);\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * @dev Determine if an address is a signer on this wallet\r\n    * @param signer address to check\r\n    * @return boolean indicating whether address is signer or not\r\n    */\r\n    function isSigner(address signer) public view returns (bool) {\r\n        for (uint i = 0; i < signers.length; i++) {\r\n            if (signers[i] == signer) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * @dev Irrevocably puts contract into safe mode. When in this mode, \r\n    *      transactions may only be sent to signing addresses.\r\n    */\r\n    function activateSafeMode() public onlySigner {\r\n        require(!safeMode);\r\n        safeMode = true;\r\n        emit SafeModeActivated(msg.sender);\r\n    }\r\n    \r\n    /**\r\n    * @dev Irrevocably puts out contract into safe mode.\r\n    */ \r\n    function turnOffSafeMode() public onlySigner {\r\n        require(safeMode);\r\n        safeMode = false;\r\n        emit SafeModeInActivated(msg.sender);\r\n    }\r\n    \r\n    /**\r\n    * @dev Create a new contract (and also address) that forwards funds to this contract\r\n    *      returns address of newly created forwarder address\r\n    */\r\n    function createForwarder() public returns (address) {\r\n        Forwarder f = new Forwarder();\r\n        forwarderCount += 1;\r\n        emit ForwarderCreated(address(f));\r\n        return(address(f));\r\n    }\r\n    \r\n    /**\r\n    * @dev for return No of forwarder generated. \r\n    * @return total number of generated forwarder count.\r\n    */\r\n    function getForwarder() public view returns(uint){\r\n        return forwarderCount;\r\n    }\r\n    \r\n    /**\r\n    * @dev Execute a token flush from one of the forwarder addresses. \r\n    *      This transfer needs only a single signature and can be done by any signer\r\n    * @param forwarderAddress the address of the forwarder address to flush the tokens from\r\n    * @param tokenContractAddress the address of the erc20 token contract\r\n    */\r\n    function flushForwarderTokens(address payable forwarderAddress, address tokenContractAddress) public onlySigner {\r\n        Forwarder forwarder = Forwarder(forwarderAddress);\r\n        forwarder.flushTokens(tokenContractAddress);\r\n    }\r\n    \r\n    /**\r\n    * @dev Gets the next available sequence ID for signing when using executeAndConfirm\r\n    * @return the sequenceId one higher than the highest currently stored\r\n    */\r\n    function getNextSequenceId() public view returns (uint) {\r\n        return lastsequenceId+1;\r\n    }\r\n    \r\n    /** \r\n    * @dev generate the hash for sendMultiSig\r\n    *      same parameter as sendMultiSig\r\n    * @return the hash generated by parameters \r\n    */\r\n    function getHash(address toAddress, uint value, bytes memory data, uint expireTime, uint sequenceId)public pure returns (bytes32){\r\n        return keccak256(abi.encodePacked(\"ETHER\", toAddress, value, data, expireTime, sequenceId));\r\n    }\r\n\r\n    /**\r\n    * @dev Execute a multi-signature transaction from this wallet using 2 signers: \r\n    *      one from msg.sender and the other from ecrecover.\r\n    *      Sequence IDs are numbers starting from 1. They are used to prevent replay \r\n    *      attacks and may not be repeated.\r\n    * @param toAddress the destination address to send an outgoing transaction\r\n    * @param value the amount in Wei to be sent\r\n    * @param data the data to send to the toAddress when invoking the transaction\r\n    * @param expireTime the number of seconds since 1970 for which this transaction is valid\r\n    * @param sequenceId the unique sequence id obtainable from getNextSequenceId\r\n    * @param signature see Data Formats\r\n    */\r\n    function sendMultiSig(address payable toAddress, uint value, bytes memory data, uint expireTime, uint sequenceId, bytes memory signature) public payable onlySigner {\r\n        bytes32 operationHash = keccak256(abi.encodePacked(\"ETHER\", toAddress, value, data, expireTime, sequenceId));\r\n        address otherSigner = verifyMultiSig(toAddress, operationHash, signature, expireTime, sequenceId);\r\n        toAddress.transfer(value);\r\n        emit Transacted(msg.sender, otherSigner, operationHash, toAddress, value, data);\r\n    }\r\n    \r\n    /** \r\n    * @dev generate the hash for sendMultiSigToken and sendMultiSigForwarder.\r\n    *      same parameter as sendMultiSigToken and sendMultiSigForwarder.\r\n    * @return the hash generated by parameters \r\n    */\r\n    function getTokenHash( address toAddress, uint value, address tokenContractAddress, uint expireTime, uint sequenceId) public pure returns (bytes32){\r\n        return keccak256(abi.encodePacked(\"ERC20\", toAddress, value, tokenContractAddress, expireTime, sequenceId));\r\n    }\r\n  \r\n    /**\r\n    * @dev Execute a multi-signature token transfer from this wallet using 2 signers: \r\n    *      one from msg.sender and the other from ecrecover.\r\n    *      Sequence IDs are numbers starting from 1. They are used to prevent replay \r\n    *      attacks and may not be repeated.\r\n    * @param toAddress the destination address to send an outgoing transaction\r\n    * @param value the amount in tokens to be sent\r\n    * @param tokenContractAddress the address of the erc20 token contract\r\n    * @param expireTime the number of seconds since 1970 for which this transaction is valid\r\n    * @param sequenceId the unique sequence id obtainable from getNextSequenceId\r\n    * @param signature see Data Formats\r\n    */\r\n    function sendMultiSigToken(address toAddress, uint value, address tokenContractAddress, uint expireTime, uint sequenceId, bytes memory signature) public onlySigner {\r\n        bytes32 operationHash = keccak256(abi.encodePacked(\"ERC20\", toAddress, value, tokenContractAddress, expireTime, sequenceId));\r\n        verifyMultiSig(toAddress, operationHash, signature, expireTime, sequenceId);\r\n        ERC20Interface instance = ERC20Interface(tokenContractAddress);\r\n        require(instance.balanceOf(address(this)) > 0);\r\n        require(instance.transfer(toAddress, value));\r\n        emit TokensTransfer(tokenContractAddress, value);\r\n    }\r\n    \r\n    /**\r\n    * @dev Gets signer's address using ecrecover\r\n    * @param operationHash see Data Formats\r\n    * @param signature see Data Formats\r\n    * @return address recovered from the signature\r\n    */\r\n    function recoverAddressFromSignature(bytes32 operationHash, bytes memory signature) private pure returns (address) {\r\n        require(signature.length == 65);\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        assembly {\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n            v := byte(0, mload(add(signature, 96)))\r\n        }\r\n        if (v < 27) {\r\n            v += 27; \r\n        }\r\n        return ecrecover(operationHash, v, r, s);\r\n    }\r\n\r\n    /**\r\n    * @dev Verify that the sequence id has not been used before and inserts it. Throws if the sequence ID was not accepted.\r\n    * @param sequenceId to insert into array of stored ids\r\n    */\r\n    function tryInsertSequenceId(uint sequenceId) private onlySigner {\r\n        require(sequenceId > lastsequenceId && sequenceId <= (lastsequenceId+1000), \"Enter Valid sequenceId\");\r\n        lastsequenceId=sequenceId;\r\n    }\r\n\r\n    /** \r\n    * @dev Do common multisig verification for both eth sends and erc20token transfers\r\n    * @param toAddress the destination address to send an outgoing transaction\r\n    * @param operationHash see Data Formats\r\n    * @param signature see Data Formats\r\n    * @param expireTime the number of seconds since 1970 for which this transaction is valid\r\n    * @param sequenceId the unique sequence id obtainable from getNextSequenceId\r\n    * @return address that has created the signature\r\n    */\r\n    function verifyMultiSig(address toAddress, bytes32 operationHash, bytes memory signature, uint expireTime, uint sequenceId) private returns (address) {\r\n\r\n        address otherSigner = recoverAddressFromSignature(operationHash, signature);\r\n        if (safeMode && !isSigner(toAddress)) {\r\n            revert(\"safemode error\");\r\n        }\r\n        require(isSigner(otherSigner) && expireTime > now);\r\n        require(otherSigner != msg.sender);\r\n        tryInsertSequenceId(sequenceId);\r\n        return otherSigner;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"allowedSigners\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"forwarderAddress\",\"type\":\"address\"}],\"name\":\"ForwarderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"}],\"name\":\"SafeModeActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"}],\"name\":\"SafeModeInActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TokensTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"otherSigner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Transacted\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[],\"name\":\"activateSafeMode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createForwarder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"forwarderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"}],\"name\":\"flushForwarderTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getForwarder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sequenceId\",\"type\":\"uint256\"}],\"name\":\"getHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextSequenceId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sequenceId\",\"type\":\"uint256\"}],\"name\":\"getTokenHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"isSigner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"safeMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sequenceId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"sendMultiSig\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sequenceId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"sendMultiSigToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"signers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"turnOffSafeMode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MultiSignWallet","CompilerVersion":"v0.5.15+commit.6a57276f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000003000000000000000000000000613da1646873e5d17c4d5725d9a213dc3d26f49b0000000000000000000000004e86ae51b46c1b02fe20971cd95c6b29a53b41f7000000000000000000000000f8a827d928056fddf3b00916220aafed06bfeed8","Library":"","LicenseType":"None","SwarmSource":"bzzr://4594b1f7f4fb5202b1ac1531ca93dc3c7f0e6049f41eb484fd8820634d5f8c8a"}]}