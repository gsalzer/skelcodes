{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.13;\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Synthetix Grants DAO\r\n * @notice This contract allows for grants to be proposed and voted on by community members\r\n * and the Synthetix team. All proposals must receive at least one approving vote by a\r\n * Synthetix member before funds will transfer.\r\n */\r\ncontract GrantsDAO {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public constant SUBMISSION_PHASE = 2 days;\r\n  uint256 public constant VOTING_PHASE = 9 days; // for 7 days after the submission phase\r\n  uint256 public toPass;\r\n  uint256 public counter = 1;\r\n  uint256 public locked;\r\n\r\n  IERC20 public SNX;\r\n\r\n  struct Proposal {\r\n    bool teamApproval;\r\n    address receiver;\r\n    uint256 amount;\r\n    uint256 createdAt;\r\n    uint256 approvals;\r\n    string description;\r\n    string url;\r\n    mapping(address => bool) voted;\r\n  }\r\n\r\n  mapping(uint256 => Proposal) public proposals;\r\n  mapping(uint256 => Proposal) public completeProposals;\r\n  mapping(address => bool) public teamMembers;\r\n  mapping(address => bool) public communityMembers;\r\n\r\n  address[] private teamAddresses;\r\n  address[] private communityAddresses;\r\n  uint256[] private validProposals;\r\n  uint256[] private completeProposalIds;\r\n\r\n  event NewProposal(address receiver, uint256 amount, uint256 proposalNumber);\r\n  event VoteProposal(uint256 proposal, address member, bool vote);\r\n  event ExecuteProposal(address receiver, uint256 amount);\r\n  event DeleteProposal(uint256 proposalNumber);\r\n\r\n  /**\r\n   * @notice Contract is created with an initial array of team and community members\r\n   * which will be stored in mappings\r\n   * @param _snx The address of the SNX token\r\n   * @param _teamMembers An array of addresses for the team members\r\n   * @param _communityMembers An array of addresses for the community members\r\n   * @param _toPass The number of votes each proposal is required in order to execute\r\n   */\r\n  constructor(\r\n    address _snx,\r\n    address[] memory _teamMembers,\r\n    address[] memory _communityMembers,\r\n    uint256 _toPass\r\n  ) public {\r\n    require(_teamMembers.length > 0, \"Need at least one teamMember\");\r\n    require(_toPass <= (_teamMembers.length + _communityMembers.length), \"Invalid value to pass proposals\");\r\n\r\n    // Add members to their respective mappings and increase members count\r\n    for (uint i = 0; i < _teamMembers.length; i++) {\r\n      teamMembers[_teamMembers[i]] = true;\r\n      teamAddresses.push(_teamMembers[i]);\r\n    }\r\n    for (uint i = 0; i < _communityMembers.length; i++) {\r\n      communityMembers[_communityMembers[i]] = true;\r\n      communityAddresses.push(_communityMembers[i]);\r\n    }\r\n\r\n    toPass = _toPass;\r\n    SNX = IERC20(_snx);\r\n  }\r\n\r\n  /**\r\n   * @notice Called by proposers (team or community) to propose funding for an address.\r\n   * Emits NewProposal event.\r\n   * @param _receiver The address to receive funds if proposal executes\r\n   * @param _amount The amount that the receiver will receive\r\n   * @param _description The description of the proposal\r\n   * @return The proposal number for reference\r\n   */\r\n  function createProposal(\r\n    address _receiver,\r\n    uint256 _amount,\r\n    string calldata _description,\r\n    string calldata _url\r\n  ) external onlyProposer() returns (uint256) {\r\n    require(_amount > 0, \"Amount must be greater than 0\");\r\n    require(_receiver != address(0), \"Receiver cannot be zero address\");\r\n    uint256 available = SNX.balanceOf(address(this)).sub(locked);\r\n    require(_amount <= available, \"Unavailable funds on DAO\");\r\n\r\n    uint256 _counter = counter; // Pull counter into memory to save gas\r\n    counter = _counter.add(1);\r\n\r\n    proposals[_counter] = Proposal(\r\n      false,\r\n      _receiver,\r\n      _amount,\r\n      block.timestamp,\r\n      1,\r\n      _description,\r\n      _url\r\n    );\r\n\r\n    // If a proposal is created by a team member, mark it as approved by the team\r\n    if (teamMembers[msg.sender]) {\r\n      proposals[_counter].teamApproval = true;\r\n    }\r\n\r\n    locked = locked.add(_amount);\r\n    proposals[_counter].voted[msg.sender] = true;\r\n    validProposals.push(_counter);\r\n\r\n    emit NewProposal(_receiver, _amount, _counter);\r\n\r\n    return _counter;\r\n  }\r\n\r\n  /**\r\n   * @notice Called by proposers (team or community) to vote for a specified proposal.\r\n   * Emits VoteProposal event.\r\n   * @param _proposal The proposal number to vote on\r\n   * @param _vote Boolean to indicate whether or not they approve of the proposal\r\n   */\r\n  function voteProposal(uint256 _proposal, bool _vote) external onlyProposer() {\r\n    require(votingPhase(_proposal), \"Proposal not in voting phase\");\r\n    require(!proposals[_proposal].voted[msg.sender], \"Already voted\");\r\n    proposals[_proposal].voted[msg.sender] = true;\r\n\r\n    if (_vote) {\r\n      if (teamMembers[msg.sender]) {\r\n        proposals[_proposal].teamApproval = true;\r\n      }\r\n      proposals[_proposal].approvals = proposals[_proposal].approvals.add(1);\r\n\r\n      // Only execute if enough approvals AND the proposal has at least one teamApproval\r\n      if (proposals[_proposal].approvals >= toPass && proposals[_proposal].teamApproval) {\r\n        _executeProposal(_proposal);\r\n      }\r\n    } else {\r\n      // Allows a team member to automatically kill a proposal\r\n      if (teamMembers[msg.sender]) {\r\n        _deleteProposal(_proposal);\r\n        // Do not emit VoteProposal if deleting\r\n        return;\r\n      }\r\n    }\r\n\r\n    emit VoteProposal(_proposal, msg.sender, _vote);\r\n  }\r\n\r\n  /**\r\n   * @notice Called by proposers to clean up storage and unlock funds.\r\n   * Emits DeleteProposal event.\r\n   * @param _proposal The proposal number to delete\r\n   */\r\n  function deleteProposal(uint256 _proposal) external onlyProposer() {\r\n    require(block.timestamp > proposals[_proposal].createdAt.add(VOTING_PHASE), \"Proposal not expired\");\r\n    _deleteProposal(_proposal);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the addresses for the active community members\r\n   * @return Array of community member addresses\r\n   */\r\n  function getCommunityMembers() external view returns (address[] memory) {\r\n    return communityAddresses;\r\n  }\r\n\r\n  /**\r\n   * @notice Gets the addresses for the active team members\r\n   * @return Array of team member addresses\r\n   */\r\n  function getTeamMembers() external view returns (address[] memory) {\r\n    return teamAddresses;\r\n  }\r\n\r\n  /**\r\n   * @notice Gets the proposal IDs of active proposals\r\n   * @return Unsorted array of proposal IDs\r\n   */\r\n  function getProposals() external view returns (uint256[] memory) {\r\n    return validProposals;\r\n  }\r\n\r\n  /**\r\n   * @notice Gets the proposal IDs of complete proposals\r\n   * @return Unsorted array of proposal IDs\r\n   */\r\n  function getCompleteProposals() external view returns (uint256[] memory) {\r\n    return completeProposalIds;\r\n  }\r\n\r\n  /**\r\n   * @notice Called by team members to withdraw extra tokens in the contract\r\n   * @dev Will not allow withdrawing balances locked in proposals\r\n   * @param _receiver The address to receive tokens\r\n   * @param _amount The amount to withdraw\r\n   */\r\n  function withdraw(address _receiver, uint256 _amount) external onlyTeamMember () {\r\n    require(_amount <= withdrawable(), \"Unable to withdraw amount\");\r\n    assert(SNX.transfer(_receiver, _amount));\r\n  }\r\n\r\n  /**\r\n   * @notice Allows community members to be added as proposers and voters\r\n   * @param _member The address of the community member\r\n   */\r\n  function addCommunityMember(address _member) external onlyTeamMember() {\r\n    communityMembers[_member] = true;\r\n    communityAddresses.push(_member);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows community members to be removed\r\n   * @dev The caller can specify an array of proposals to have the member's vote removed\r\n   * @param _member The address of the community member\r\n   * @param _proposals The array of proposals to have the member's vote removed from\r\n   */\r\n  function removeCommunityMember(address _member, uint256[] calldata _proposals) external onlyTeamMember() {\r\n    delete communityMembers[_member];\r\n    for (uint i = 0; i < communityAddresses.length; i++) {\r\n      if (communityAddresses[i] == _member) {\r\n        communityAddresses[i] = communityAddresses[communityAddresses.length - 1];\r\n        communityAddresses.length--;\r\n      }\r\n    }\r\n    for (uint i = 0; i < _proposals.length; i++) {\r\n      require(proposals[_proposals[i]].voted[_member], \"Member did not vote for proposal\");\r\n      delete proposals[_proposals[i]].voted[_member];\r\n      proposals[_proposals[i]].approvals = proposals[_proposals[i]].approvals.sub(1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Allows team members to be added\r\n   * @param _member The address of the team member\r\n   */\r\n  function addTeamMember(address _member) external onlyTeamMember() {\r\n    teamMembers[_member] = true;\r\n    teamAddresses.push(_member);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows team members to be removed\r\n   * @param _member The address of the team member\r\n   */\r\n  function removeTeamMember(address _member) external onlyTeamMember() {\r\n    // Prevents the possibility of there being no team members\r\n    require(msg.sender != _member, \"Cannot remove self\");\r\n    delete teamMembers[_member];\r\n    for (uint i = 0; i < teamAddresses.length; i++) {\r\n      if (teamAddresses[i] == _member) {\r\n        teamAddresses[i] = teamAddresses[teamAddresses.length - 1];\r\n        teamAddresses.length--;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Allows the number of votes required to pass a proposal to be updated\r\n   * @param _toPass The new value for the number of votes to pass a proposal\r\n   */\r\n  function updateToPass(uint256 _toPass) external onlyTeamMember() {\r\n    require(_toPass > 0, \"Invalid value to pass proposals\");\r\n    toPass = _toPass;\r\n  }\r\n\r\n  /**\r\n   * @notice Shows the balance of the contract which can be withdrawn by team members\r\n   * @return The withdrawable balance\r\n   */\r\n  function withdrawable() public view returns (uint256) {\r\n    return SNX.balanceOf(address(this)).sub(locked);\r\n  }\r\n\r\n  /**\r\n   * @notice Displays the total balance of the contract, including locked and withdrawable\r\n   * @return The balance of the contract\r\n   */\r\n  function totalBalance() external view returns (uint256) {\r\n    return SNX.balanceOf(address(this));\r\n  }\r\n\r\n  /**\r\n   * @notice Checks to see whether an address has voted on a proposal\r\n   * @return Boolean indicating if the address has voted\r\n   */\r\n  function voted(address _member, uint256 _proposal) external view returns (bool) {\r\n    return proposals[_proposal].voted[_member];\r\n  }\r\n\r\n  /**\r\n   * @notice Check to see whether a proposal is in the voting phase\r\n   * @param _proposal The proposal number to check\r\n   * @return Boolean indicating if the proposal is in the voting phase\r\n   */\r\n  function votingPhase(uint256 _proposal) public view returns (bool) {\r\n    uint256 createdAt = proposals[_proposal].createdAt;\r\n    return createdAt <= block.timestamp.sub(SUBMISSION_PHASE) &&\r\n      block.timestamp <= createdAt.add(VOTING_PHASE);\r\n  }\r\n\r\n  /**\r\n   * @dev Private method to delete a proposal\r\n   * @param _proposal The proposal number to delete\r\n   */\r\n  function _deleteProposal(uint256 _proposal) private {\r\n    locked = locked.sub(proposals[_proposal].amount);\r\n    delete proposals[_proposal];\r\n    for (uint i = 0; i < validProposals.length; i++) {\r\n      if (validProposals[i] == _proposal) {\r\n        validProposals[i] = validProposals[validProposals.length - 1];\r\n        validProposals.length--;\r\n      }\r\n    }\r\n    emit DeleteProposal(_proposal);\r\n  }\r\n\r\n  /**\r\n   * @dev Private method to execute a proposal\r\n   * @param _proposal The proposal number to delete\r\n   */\r\n  function _executeProposal(uint256 _proposal) private {\r\n    Proposal memory proposal = proposals[_proposal];\r\n    completeProposalIds.push(_proposal);\r\n    completeProposals[_proposal] = proposal;\r\n    delete proposals[_proposal];\r\n    for (uint i = 0; i < validProposals.length; i++) {\r\n      if (validProposals[i] == _proposal) {\r\n        validProposals[i] = validProposals[validProposals.length - 1];\r\n        validProposals.length--;\r\n      }\r\n    }\r\n    assert(SNX.transfer(proposal.receiver, proposal.amount));\r\n    emit ExecuteProposal(proposal.receiver, proposal.amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if caller is not a team member\r\n   */\r\n  modifier onlyTeamMember() {\r\n    require(teamMembers[msg.sender], \"Not team member\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if caller is not a proposer (team or community member)\r\n   */\r\n  modifier onlyProposer() {\r\n    require(\r\n      teamMembers[msg.sender] ||\r\n      communityMembers[msg.sender],\r\n      \"Not proposer\"\r\n    );\r\n    _;\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_snx\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_teamMembers\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_communityMembers\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_toPass\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalNumber\",\"type\":\"uint256\"}],\"name\":\"DeleteProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ExecuteProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalNumber\",\"type\":\"uint256\"}],\"name\":\"NewProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"vote\",\"type\":\"bool\"}],\"name\":\"VoteProposal\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"SNX\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SUBMISSION_PHASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VOTING_PHASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"addCommunityMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"addTeamMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"communityMembers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"completeProposals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"teamApproval\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"approvals\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"url\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"counter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_url\",\"type\":\"string\"}],\"name\":\"createProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposal\",\"type\":\"uint256\"}],\"name\":\"deleteProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCommunityMembers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCompleteProposals\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProposals\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTeamMembers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"teamApproval\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"approvals\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"url\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_proposals\",\"type\":\"uint256[]\"}],\"name\":\"removeCommunityMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"removeTeamMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"teamMembers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"toPass\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_toPass\",\"type\":\"uint256\"}],\"name\":\"updateToPass\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposal\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_vote\",\"type\":\"bool\"}],\"name\":\"voteProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_proposal\",\"type\":\"uint256\"}],\"name\":\"voted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposal\",\"type\":\"uint256\"}],\"name\":\"votingPhase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"GrantsDAO","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000c011a72400e58ecd99ee497cf89e3775d4bd732f000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000002000000000000000000000000dda03223b1341bf929551220c116d8109f819e75000000000000000000000000003f6b20bfa4b5cab701960ecf73859cb3c095fc0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000a5f7a39e55d7878bc5bd754ee5d6bd7a7662355b000000000000000000000000fe072d936072107ef9ab409cc523b0753efabd010000000000000000000000000a69c08c7b03f5e647d72f78ac008428fac94e37","Library":"","LicenseType":"None","SwarmSource":"bzzr://2534ddddc493ced4fa7db3ec4738e9d6b7280f14541928a7a70295487cfc23cb"}]}