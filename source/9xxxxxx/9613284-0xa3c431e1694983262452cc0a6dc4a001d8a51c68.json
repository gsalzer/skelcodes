{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: contracts/interfaces/SyscoinSuperblocksI.sol\n\npragma solidity ^0.5.13;\n\ninterface SyscoinSuperblocksI {\n\n    // @dev - Superblock status\n    enum Status { Uninitialized, New, InBattle, SemiApproved, Approved, Invalid }\n    struct SuperblockInfo {\n        bytes32 blocksMerkleRoot;\n        uint timestamp;\n        uint mtpTimestamp;\n        bytes32 lastHash;\n        bytes32 parentId;\n        address submitter;\n        uint32 lastBits;\n        uint32 height;\n        Status status;\n    }\n    function propose(\n        bytes32 _blocksMerkleRoot,\n        uint _timestamp,\n        uint _mtpTimestamp,\n        bytes32 _lastHash,\n        uint32 _lastBits,\n        bytes32 _parentId,\n        address submitter\n    ) external returns (uint, bytes32);\n\n    function getSuperblock(bytes32 superblockHash) external view returns (\n        bytes32 _blocksMerkleRoot,\n        uint _timestamp,\n        uint _mtpTimestamp,\n        bytes32 _lastHash,\n        uint32 _lastBits,\n        bytes32 _parentId,\n        address _submitter,\n        Status _status,\n        uint32 _height\n    );\n\n    function relayTx(\n        bytes calldata _txBytes,\n        uint _txIndex,\n        uint[] calldata _txSiblings,\n        bytes calldata _syscoinBlockHeader,\n        uint _syscoinBlockIndex,\n        uint[] calldata _syscoinBlockSiblings,\n        bytes32 _superblockHash\n    ) external returns (uint);\n\n    function confirm(bytes32 _superblockHash, address _validator) external returns (uint);\n    function challenge(bytes32 _superblockHash, address _challenger) external returns (uint);\n    function semiApprove(bytes32 _superblockHash, address _validator) external returns (uint);\n    function invalidate(bytes32 _superblockHash, address _validator) external returns (uint);\n    function getBestSuperblock() external view returns (bytes32);\n    function getChainHeight() external view returns (uint);\n    function getSuperblockHeight(bytes32 superblockHash) external view returns (uint32);\n    function getSuperblockParentId(bytes32 _superblockHash) external view returns (bytes32);\n    function getSuperblockStatus(bytes32 _superblockHash) external view returns (Status);\n    function getSuperblockAt(uint _height) external view returns (bytes32);\n    function getSuperblockTimestamp(bytes32 _superblockHash) external view returns (uint);\n    function getSuperblockMedianTimestamp(bytes32 _superblockHash) external view returns (uint);\n\n    function relayAssetTx(\n        bytes calldata _txBytes,\n        uint _txIndex,\n        uint[] calldata _txSiblings,\n        bytes calldata _syscoinBlockHeader,\n        uint _syscoinBlockIndex,\n        uint[] calldata _syscoinBlockSiblings,\n        bytes32 _superblockHash\n    ) external returns (uint);\n}\n\n// File: contracts/SyscoinErrorCodes.sol\n\npragma solidity ^0.5.13;\n\n// @dev - SyscoinSuperblocks error codes\ncontract SyscoinErrorCodes {\n    // Error codes\n    uint constant ERR_INVALID_HEADER = 10050;\n    uint constant ERR_COINBASE_INDEX = 10060; // coinbase tx index within Bitcoin merkle isn't 0\n    uint constant ERR_NOT_MERGE_MINED = 10070; // trying to check AuxPoW on a block that wasn't merge mined\n    uint constant ERR_FOUND_TWICE = 10080; // 0xfabe6d6d found twice\n    uint constant ERR_NO_MERGE_HEADER = 10090; // 0xfabe6d6d not found\n    uint constant ERR_CHAIN_MERKLE = 10110;\n    uint constant ERR_PARENT_MERKLE = 10120;\n    uint constant ERR_PROOF_OF_WORK = 10130;\n    uint constant ERR_INVALID_HEADER_HASH = 10140;\n    uint constant ERR_PROOF_OF_WORK_AUXPOW = 10150;\n    uint constant ERR_PARSE_TX_OUTPUT_LENGTH = 10160;\n\n\n    uint constant ERR_SUPERBLOCK_OK = 0;\n    uint constant ERR_SUPERBLOCK_MISSING_BLOCKS = 1;\n    uint constant ERR_SUPERBLOCK_BAD_STATUS = 50020;\n    uint constant ERR_SUPERBLOCK_BAD_SYSCOIN_STATUS = 50025;\n    uint constant ERR_SUPERBLOCK_TIMEOUT = 50026;\n    uint constant ERR_SUPERBLOCK_NO_TIMEOUT = 50030;\n    uint constant ERR_SUPERBLOCK_BAD_TIMESTAMP = 50035;\n    uint constant ERR_SUPERBLOCK_INVALID_TIMESTAMP = 50036;\n    uint constant ERR_SUPERBLOCK_INVALID_MERKLE = 50038;\n\n    // The error codes \"ERR_SUPERBLOCK_BAD_PARENT_*\" corresponds to ERR_SUPERBLOCK_BAD_PARENT + superblock.status\n    uint constant ERR_SUPERBLOCK_BAD_PARENT = 50040;\n    uint constant ERR_SUPERBLOCK_BAD_PARENT_UNINITIALIZED = 50040;\n    uint constant ERR_SUPERBLOCK_BAD_PARENT_NEW = 50041;\n    uint constant ERR_SUPERBLOCK_BAD_PARENT_INBATTLE = 50042;\n    uint constant ERR_SUPERBLOCK_BAD_PARENT_INVALID = 50045;\n\n    uint constant ERR_SUPERBLOCK_OWN_CHALLENGE = 50055;\n    uint constant ERR_SUPERBLOCK_BAD_PREV_TIMESTAMP = 50056;\n    uint constant ERR_SUPERBLOCK_BITS_SUPERBLOCK = 50057;\n    uint constant ERR_SUPERBLOCK_BITS_PREVBLOCK = 50058;\n    uint constant ERR_SUPERBLOCK_HASH_SUPERBLOCK = 50059;\n    uint constant ERR_SUPERBLOCK_HASH_PREVBLOCK = 50060;\n    uint constant ERR_SUPERBLOCK_HASH_PREVSUPERBLOCK = 50061;\n    uint constant ERR_SUPERBLOCK_MAX_INPROGRESS = 50062;\n    uint constant ERR_SUPERBLOCK_BITS_LASTBLOCK = 50064;\n    uint constant ERR_SUPERBLOCK_MIN_DEPOSIT = 50065;\n    uint constant ERR_SUPERBLOCK_BITS_INTERIM_PREVBLOCK = 50066;\n    uint constant ERR_SUPERBLOCK_HASH_INTERIM_PREVBLOCK = 50067;\n    uint constant ERR_SUPERBLOCK_BAD_TIMESTAMP_AVERAGE = 50068;\n    uint constant ERR_SUPERBLOCK_BAD_TIMESTAMP_MTP = 50069;\n\n    uint constant ERR_SUPERBLOCK_NOT_CLAIMMANAGER = 50070;\n    uint constant ERR_SUPERBLOCK_MISMATCH_TIMESTAMP_MTP = 50071;\n    uint constant ERR_SUPERBLOCK_TOOSMALL_TIMESTAMP_MTP = 50072;\n\n    uint constant ERR_SUPERBLOCK_BAD_CLAIM = 50080;\n    uint constant ERR_SUPERBLOCK_VERIFICATION_PENDING = 50090;\n    uint constant ERR_SUPERBLOCK_CLAIM_DECIDED = 50100;\n    uint constant ERR_SUPERBLOCK_CHALLENGE_EXISTS = 50110;\n\n    uint constant ERR_SUPERBLOCK_BAD_ACCUMULATED_WORK = 50120;\n    uint constant ERR_SUPERBLOCK_BAD_BITS = 50130;\n    uint constant ERR_SUPERBLOCK_MISSING_CONFIRMATIONS = 50140;\n    uint constant ERR_SUPERBLOCK_BAD_LASTBLOCK = 50150;\n    uint constant ERR_SUPERBLOCK_BAD_LASTBLOCK_STATUS = 50160;\n    uint constant ERR_SUPERBLOCK_BAD_BLOCKHEIGHT = 50170;\n    uint constant ERR_SUPERBLOCK_BAD_PREVBLOCK = 50190;\n    uint constant ERR_SUPERBLOCK_CLAIM_ALREADY_DEFENDED = 50200;\n    uint constant ERR_SUPERBLOCK_BAD_MISMATCH = 50210;\n    uint constant ERR_SUPERBLOCK_INTERIMBLOCK_MISSING = 50220;\n    uint constant ERR_SUPERBLOCK_BAD_INTERIM_PREVHASH = 50230;\n    uint constant ERR_SUPERBLOCK_BAD_INTERIM_BLOCKINDEX = 50240;\n\n\n    // error codes for verifyTx\n    uint constant ERR_BAD_FEE = 20010;\n    uint constant ERR_CONFIRMATIONS = 20020;\n    uint constant ERR_CHAIN = 20030;\n    uint constant ERR_SUPERBLOCK = 20040;\n    uint constant ERR_MERKLE_ROOT = 20050;\n    uint constant ERR_TX_64BYTE = 20060;\n    uint constant ERR_SUPERBLOCK_MERKLE_ROOT = 20070;\n    // error codes for relayTx\n    uint constant ERR_RELAY_VERIFY = 30010;\n    uint constant ERR_CANCEL_TRANSFER_VERIFY = 30020;\n    uint constant public minProposalDeposit = 3000000000000000000;\n}\n\n// File: contracts/SyscoinTransactionProcessor.sol\n\npragma solidity ^0.5.13;\n\n// Interface contract to be implemented by SyscoinERC20Manager\ninterface SyscoinTransactionProcessor {\n    function processTransaction(uint txHash, uint value, address destinationAddress, address superblockSubmitterAddress, address erc20ContractAddress, uint32 assetGUID, uint8 precision) external;\n    function freezeBurnERC20(uint value, uint32 assetGUID, address erc20ContractAddress, uint8 precision, bytes calldata syscoinAddress) external returns (bool);\n    function cancelTransferRequest(uint32 bridgeTransferId) external;\n    function cancelTransferSuccess(uint32 bridgeTransferId, address challengerAddress) external;\n    function processCancelTransferFail(uint32 bridgeTransferId, address payable challengerAddress) external;\n    function processAsset(uint txHash, uint32 assetGUID, uint32 height, address erc20ContractAddress) external;\n}\n\n// File: @openzeppelin/upgrades/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: solidity-rlp/contracts/RLPReader.sol\n\n/*\n* @author Hamdi Allam hamdi.allam97@gmail.com\n* Please reach out with any questions or concerns\n*/\npragma solidity ^0.5.0;\n\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START  = 0xb8;\n    uint8 constant LIST_SHORT_START   = 0xc0;\n    uint8 constant LIST_LONG_START    = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint len;\n        uint memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item;   // Item that's being iterated over.\n        uint nextPtr;   // Position of the next item in the list.\n    }\n\n    /*\n    * @dev Returns the next element in the iteration. Reverts if it has not next element.\n    * @param self The iterator.\n    * @return The next element in the iteration.\n    */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint ptr = self.nextPtr;\n        uint itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n    * @dev Returns true if the iteration has more elements.\n    * @param self The iterator.\n    * @return true if the iteration has more elements.\n    */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n    * @param item RLP encoded bytes\n    */\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n    * @dev Create an iterator. Reverts if item is not a list.\n    * @param self The RLP item.\n    * @return An 'Iterator' over the item.\n    */\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n    * @param item RLP encoded bytes\n    */\n    function rlpLen(RLPItem memory item) internal pure returns (uint) {\n        return item.len;\n    }\n\n    /*\n    * @param item RLP encoded bytes\n    */\n    function payloadLen(RLPItem memory item) internal pure returns (uint) {\n        return item.len - _payloadOffset(item.memPtr);\n    }\n\n    /*\n    * @param item RLP encoded list in bytes\n    */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint dataLen;\n        for (uint i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr); \n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START)\n            return false;\n        return true;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n        \n        uint ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint result;\n        uint memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        return result == 0 ? false : true;\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(toUint(item));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint) {\n        require(item.len > 0 && item.len <= 33);\n\n        uint offset = _payloadOffset(item.memPtr);\n        uint len = item.len - offset;\n\n        uint result;\n        uint memPtr = item.memPtr + offset;\n        assembly {\n            result := mload(memPtr)\n\n            // shfit to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint result;\n        uint memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        uint offset = _payloadOffset(item.memPtr);\n        uint len = item.len - offset; // data length\n        bytes memory result = new bytes(len);\n\n        uint destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n    /*\n    * Private Helpers\n    */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) private pure returns (uint) {\n        if (item.len == 0) return 0;\n\n        uint count = 0;\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n           currPtr = currPtr + _itemLength(currPtr); // skip over an item\n           count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint memPtr) private pure returns (uint) {\n        uint itemLen;\n        uint byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START)\n            itemLen = 1;\n        \n        else if (byte0 < STRING_LONG_START)\n            itemLen = byte0 - STRING_SHORT_START + 1;\n\n        else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n                \n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } \n\n        else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint memPtr) private pure returns (uint) {\n        uint byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) \n            return 0;\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))\n            return 1;\n        else if (byte0 < LIST_SHORT_START)  // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        else\n            return byte0 - (LIST_LONG_START - 1) + 1;\n    }\n\n    /*\n    * @param src Pointer to source\n    * @param dest Pointer to destination\n    * @param len Amount of memory to copy from the source\n    */\n    function copy(uint src, uint dest, uint len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n\n// File: contracts/SyscoinParser/SyscoinMessageLibrary.sol\n\npragma solidity ^0.5.13;\n\n\n// parse a raw Syscoin transaction byte array\ncontract SyscoinMessageLibrary {\n\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for bytes;\n\n    uint constant ERR_PARSE_TX_SYS = 10170;\n    enum Network { MAINNET, TESTNET, REGTEST }\n    uint32 constant SYSCOIN_TX_VERSION_ALLOCATION_BURN_TO_ETHEREUM = 0x7407;\n\n    // Convert a variable integer into something useful and return it and\n    // the index to after it.\n    function parseVarInt(bytes memory txBytes, uint pos) public pure returns (uint, uint) {\n        // the first byte tells us how big the integer is\n        uint8 ibit = uint8(txBytes[pos]);\n        pos += 1;  // skip ibit\n\n        if (ibit < 0xfd) {\n            return (ibit, pos);\n        } else if (ibit == 0xfd) {\n            return (getBytesLE(txBytes, pos, 16), pos + 2);\n        } else if (ibit == 0xfe) {\n            return (getBytesLE(txBytes, pos, 32), pos + 4);\n        } else if (ibit == 0xff) {\n            return (getBytesLE(txBytes, pos, 64), pos + 8);\n        }\n    }\n\n    // convert little endian bytes to uint\n    function getBytesLE(bytes memory data, uint pos, uint bits)\n        public\n        pure\n        returns (uint256 result)\n    {\n        for (uint256 i = 0; i < bits / 8; i++) {\n            result += uint256(uint8(data[pos + i])) * 2 ** (i * 8);\n        }\n    }\n\n    // @dev - Converts a bytes of size 4 to uint32,\n    // e.g. for input [0x01, 0x02, 0x03 0x04] returns 0x01020304\n    function bytesToUint32Flipped(bytes memory input, uint pos)\n        public\n        pure\n        returns (uint32 result)\n    {\n        assembly {\n            let data := mload(add(add(input, 0x20), pos))\n            let flip := mload(0x40)\n            mstore8(add(flip, 0), byte(3, data))\n            mstore8(add(flip, 1), byte(2, data))\n            mstore8(add(flip, 2), byte(1, data))\n            mstore8(add(flip, 3), byte(0, data))\n            result := shr(mul(8, 28), mload(flip))\n        }\n    }\n\n    // @dev - convert an unsigned integer from little-endian to big-endian representation\n    //\n    // @param _input - little-endian value\n    // @return - input value in big-endian format\n    function flip32Bytes(uint _input) public pure returns (uint result) {\n        assembly {\n            let pos := mload(0x40)\n            mstore8(add(pos, 0), byte(31, _input))\n            mstore8(add(pos, 1), byte(30, _input))\n            mstore8(add(pos, 2), byte(29, _input))\n            mstore8(add(pos, 3), byte(28, _input))\n            mstore8(add(pos, 4), byte(27, _input))\n            mstore8(add(pos, 5), byte(26, _input))\n            mstore8(add(pos, 6), byte(25, _input))\n            mstore8(add(pos, 7), byte(24, _input))\n            mstore8(add(pos, 8), byte(23, _input))\n            mstore8(add(pos, 9), byte(22, _input))\n            mstore8(add(pos, 10), byte(21, _input))\n            mstore8(add(pos, 11), byte(20, _input))\n            mstore8(add(pos, 12), byte(19, _input))\n            mstore8(add(pos, 13), byte(18, _input))\n            mstore8(add(pos, 14), byte(17, _input))\n            mstore8(add(pos, 15), byte(16, _input))\n            mstore8(add(pos, 16), byte(15, _input))\n            mstore8(add(pos, 17), byte(14, _input))\n            mstore8(add(pos, 18), byte(13, _input))\n            mstore8(add(pos, 19), byte(12, _input))\n            mstore8(add(pos, 20), byte(11, _input))\n            mstore8(add(pos, 21), byte(10, _input))\n            mstore8(add(pos, 22), byte(9, _input))\n            mstore8(add(pos, 23), byte(8, _input))\n            mstore8(add(pos, 24), byte(7, _input))\n            mstore8(add(pos, 25), byte(6, _input))\n            mstore8(add(pos, 26), byte(5, _input))\n            mstore8(add(pos, 27), byte(4, _input))\n            mstore8(add(pos, 28), byte(3, _input))\n            mstore8(add(pos, 29), byte(2, _input))\n            mstore8(add(pos, 30), byte(1, _input))\n            mstore8(add(pos, 31), byte(0, _input))\n            result := mload(pos)\n        }\n    }\n    \n    // @dev - For a valid proof, returns the root of the Merkle tree.\n    //\n    // @param _txHash - transaction hash\n    // @param _txIndex - transaction's index within the block it's assumed to be in\n    // @param _siblings - transaction's Merkle siblings\n    // @return - Merkle tree root of the block the transaction belongs to if the proof is valid,\n    // garbage if it's invalid\n    function computeMerkle(uint _txHash, uint _txIndex, uint[] memory _siblings)\n        public\n        pure\n        returns (uint)\n    {\n        uint length = _siblings.length;\n        uint i;\n        for (i = 0; i < length; i++) {\n            _siblings[i] = flip32Bytes(_siblings[i]);\n        }\n\n        i = 0;\n        uint resultHash = flip32Bytes(_txHash);        \n\n        while (i < length) {\n            uint proofHex = _siblings[i];\n\n            uint left;\n            uint right;\n            if (_txIndex % 2 == 1) { // 0 means _siblings is on the right; 1 means left\n                left = proofHex;\n                right = resultHash;\n            } else {\n                left = resultHash;\n                right = proofHex;\n            }\n            resultHash = uint(sha256(abi.encodePacked(sha256(abi.encodePacked(left, right)))));\n\n            _txIndex /= 2;\n            i += 1;\n        }\n\n        return flip32Bytes(resultHash);\n    }\n\n    // @dev returns a portion of a given byte array specified by its starting and ending points\n    // Breaks underscore naming convention for parameters because it raises a compiler error\n    // if `offset` is changed to `_offset`.\n    //\n    // @param _rawBytes - array to be sliced\n    // @param offset - first byte of sliced array\n    // @param _endIndex - last byte of sliced array\n    function sliceArray(bytes memory _rawBytes, uint offset, uint _endIndex) public view returns (bytes memory) {\n        uint len = _endIndex - offset;\n        bytes memory result = new bytes(len);\n        assembly {\n            // Call precompiled contract to copy data\n            if iszero(staticcall(gas, 0x04, add(add(_rawBytes, 0x20), offset), len, add(result, 0x20), len)) {\n                revert(0, 0)\n            }\n        }\n        return result;\n    }\n}\n\n// File: contracts/SyscoinSuperblocks.sol\n\npragma solidity ^0.5.13;\n\n\n\n\n\n\n// @dev - Manages superblocks\n//\n// Management of superblocks and status transitions\ncontract SyscoinSuperblocks is Initializable, SyscoinSuperblocksI, SyscoinErrorCodes, SyscoinMessageLibrary {\n\n    uint constant ERR_PARSE_TX_SYS = 10170;\n\n    uint32 constant SYSCOIN_TX_VERSION_ALLOCATION_BURN_TO_ETHEREUM = 0x7407;\n    uint32 constant SYSCOIN_TX_VERSION_ALLOCATION_MINT = 0x7406;\n    \n    // Mapping superblock id => superblock data\n    mapping (bytes32 => SuperblockInfo) internal superblocks;\n\n    bytes32 internal bestSuperblock;\n\n    SyscoinTransactionProcessor public syscoinERC20Manager;\n\n    event NewSuperblock(bytes32 superblockHash, address who);\n    event ApprovedSuperblock(bytes32 superblockHash, address who);\n    event ChallengeSuperblock(bytes32 superblockHash, address who);\n    event SemiApprovedSuperblock(bytes32 superblockHash, address who);\n    event InvalidSuperblock(bytes32 superblockHash, address who);\n\n    event ErrorSuperblock(bytes32 superblockHash, uint err);\n\n    event VerifyTransaction(bytes32 txHash, uint returnCode);\n    event RelayTransaction(bytes32 txHash, uint returnCode);\n    event ChallengeCancelTransferRequest(uint returnCode);\n    // SyscoinClaimManager\n    address public trustedClaimManager;\n\n    uint32 constant SYSCOIN_TX_VERSION_ASSET_ACTIVATE = 0x7402;\n    uint32 constant SYSCOIN_TX_VERSION_ASSET_UPDATE = 0x7403;\n    modifier onlyClaimManager() {\n        require(msg.sender == trustedClaimManager);\n        _;\n    }\n\n    // @param _syscoinERC20Manager - address of the SyscoinERC20Manager contract to be associated with\n    // @param _claimManager - address of the ClaimManager contract to be associated with\n    function init(address _syscoinERC20Manager, address _claimManager) public initializer {\n        require(address(syscoinERC20Manager) == address(0) && _syscoinERC20Manager != address(0));\n        syscoinERC20Manager = SyscoinTransactionProcessor(_syscoinERC20Manager);\n\n        require(address(trustedClaimManager) == address(0) && _claimManager != address(0));\n        trustedClaimManager = _claimManager;\n    }\n\n    // Returns true if the tx output is an OP_RETURN output\n    function isOpReturn(bytes memory txBytes, uint pos) internal pure returns (bool) {\n        // scriptPub format is\n        // 0x6a OP_RETURN\n        return txBytes[pos] == byte(0x6a);\n    }\n\n    function bytesToUint64(bytes memory input, uint pos) public pure returns (uint64 result) {\n        result = uint64(uint8(input[pos+7])) + uint64(uint8(input[pos + 6]))*(2**8) + uint64(uint8(input[pos + 5]))*(2**16) + uint64(uint8(input[pos + 4]))*(2**24) + uint64(uint8(input[pos + 3]))*(2**32) + uint64(uint8(input[pos + 2]))*(2**40) + uint64(uint8(input[pos + 1]))*(2**48) + uint64(uint8(input[pos]))*(2**56);\n    }\n\n    function bytesToUint32(bytes memory input, uint pos) public pure returns (uint32 result) {\n        result = uint32(uint8(input[pos+3])) + uint32(uint8(input[pos + 2]))*(2**8) + uint32(uint8(input[pos + 1]))*(2**16) + uint32(uint8(input[pos]))*(2**24);\n    }\n\n    // Returns asset data parsed from the op_return data output from syscoin asset burn transaction\n    function scanAssetDetails(bytes memory txBytes, uint pos)\n        internal\n        pure\n        returns (uint, address, uint32, uint8, address)\n    {\n        uint32 assetGUID;\n        address destinationAddress;\n        address erc20Address;\n        uint output_value;\n        uint8 precision;\n        uint8 op;\n        // vchAsset\n        (op, pos) = getOpcode(txBytes, pos);\n        // guid length should be 4 bytes\n        require(op == 0x04);\n        assetGUID = bytesToUint32(txBytes, pos);\n        pos += op;\n        // amount\n        (op, pos) = getOpcode(txBytes, pos);\n        require(op == 0x08);\n        output_value = bytesToUint64(txBytes, pos);\n        pos += op;\n         // destination address\n        (op, pos) = getOpcode(txBytes, pos);\n        // ethereum contracts are 20 bytes (without the 0x)\n        require(op == 0x14);\n        destinationAddress = readEthereumAddress(txBytes, pos);\n        pos += op;\n        // precision\n        (op, pos) = getOpcode(txBytes, pos);\n        require(op == 0x01);\n        precision = uint8(txBytes[pos]);\n        pos += op;\n        // erc20Address\n        (op, pos) = getOpcode(txBytes, pos);\n        require(op == 0x14);\n        erc20Address = readEthereumAddress(txBytes, pos);\n        return (output_value, destinationAddress, assetGUID, precision, erc20Address);\n    }\n\n    // Read the ethereum address embedded in the tx output\n    function readEthereumAddress(bytes memory txBytes, uint pos) internal pure returns (address) {\n        uint256 data;\n        assembly {\n            data := mload(add(add(txBytes, 20), pos))\n        }\n        return address(uint160(data));\n    }\n\n    // Read next opcode from script\n    function getOpcode(bytes memory txBytes, uint pos) private pure returns (uint8, uint) {\n        require(pos < txBytes.length);\n        return (uint8(txBytes[pos]), pos + 1);\n    }\n\n    function getOpReturnPos(bytes memory txBytes, uint pos) public pure returns (uint) {\n        uint n_inputs;\n        uint script_len;\n        uint output_value;\n        uint n_outputs;\n\n        (n_inputs, pos) = parseVarInt(txBytes, pos);\n        // if dummy 0x00 is present this is a witness transaction\n        if(n_inputs == 0x00){\n            (n_inputs, pos) = parseVarInt(txBytes, pos); // flag\n            require(n_inputs != 0x00, \"#SyscoinSuperblocks getOpReturnPos(): Unexpected dummy/flag\");\n            // after dummy/flag the real var int comes for txins\n            (n_inputs, pos) = parseVarInt(txBytes, pos);\n        }\n        require(n_inputs < 100, \"#SyscoinSuperblocks getOpReturnPos(): Incorrect size of n_inputs\");\n\n        for (uint i = 0; i < n_inputs; i++) {\n            pos += 36;  // skip outpoint\n            (script_len, pos) = parseVarInt(txBytes, pos);\n            pos += script_len + 4;  // skip sig_script, seq\n        }\n        \n        (n_outputs, pos) = parseVarInt(txBytes, pos);\n        require(n_outputs < 10, \"#SyscoinSuperblocks getOpReturnPos(): Incorrect size of n_outputs\");\n        for (uint i = 0; i < n_outputs; i++) {\n            pos += 8;\n            // varint\n            (script_len, pos) = parseVarInt(txBytes, pos);\n            if(!isOpReturn(txBytes, pos)){\n                // output script\n                pos += script_len;\n                output_value = 0;\n                continue;\n            }\n            // skip opreturn marker\n            pos += 1;\n            return pos;\n        }\n        revert(\"#SyscoinSuperblocks getOpReturnPos(): No OpReturn found\");\n    }\n\n    /**\n     * @dev Parse syscoin mint transaction to recover bridgeTransferId\n     * @param txBytes syscoin raw transaction\n     * @return errorCode, bridgeTransferId\n     */\n    function parseMintTx(bytes memory txBytes)\n        public\n        view\n        returns (uint errorCode, uint32 bridgeTransferId)\n    {\n        uint32 version;\n        uint pos = 0;\n        version = bytesToUint32Flipped(txBytes, pos);\n        if(version != SYSCOIN_TX_VERSION_ALLOCATION_MINT){\n            return (ERR_PARSE_TX_SYS, bridgeTransferId);\n        }\n        pos = getOpReturnPos(txBytes, 4);\n        pos += 3; // skip pushdata2 + 2 bytes for opreturn varint\n\n        // SHA3 of TokenFreeze(address,uint256,uint32)\n        bytes32 tokenFreezeTopic = 0xaabab1db49e504b5156edf3f99042aeecb9607a08f392589571cd49743aaba8d;\n        bridgeTransferId = uint32(\n            getBridgeTransactionId(\n                getLogValuesForTopic(\n                    getEthReceipt(txBytes, pos), tokenFreezeTopic\n                )\n            )\n        );\n    }\n\n\n     /** @dev Parse syscoin asset transaction to recover asset guid and contract, for purposes of updating asset registry in erc20manager\n     * @param txBytes syscoin raw transaction\n     * @return errorCode, assetGuid, erc20Address\n     */\n    function parseAssetTx(bytes memory txBytes)\n        public\n        view\n        returns (uint errorCode, uint32 assetGuid, address erc20Address)\n    {\n        uint32 version;\n        uint pos = 0;\n        version = bytesToUint32Flipped(txBytes, pos);\n        if(version != SYSCOIN_TX_VERSION_ASSET_ACTIVATE && version != SYSCOIN_TX_VERSION_ASSET_UPDATE){\n            return (ERR_PARSE_TX_SYS, 0, address(0));\n        }\n        pos = getOpReturnPos(txBytes, 4);\n        byte pushDataOp = txBytes[pos+1];\n        pos += 2; // we will have to skip pushdata op as well as atleast 1 byte\n        if(pushDataOp == 0x4d){\n            pos++; // skip pushdata2 + 2 bytes for opreturn varint\n        }\n\n        (assetGuid, erc20Address) = scanAssetTx(txBytes, pos);\n        require(erc20Address != address(0),\n        \"parseAssetTx(): erc20Address cannot be empty\");\n    }\n\n    function bytesToUint16(bytes memory input, uint pos) public pure returns (uint16 result) {\n        result = uint16(uint8(input[pos+1])) + uint16(uint8(input[pos]))*(2**8);\n    }\n\n    /**\n     * Parse txBytes and returns ethereum tx receipt\n     * @param txBytes syscoin raw transaction\n     * @param pos position at where to start parsing\n     * @return ethTxReceipt ethereum tx receipt\n     */\n    function getEthReceipt(bytes memory txBytes, uint pos)\n        public\n        view\n        returns (bytes memory)\n    {\n        bytes memory ethTxReceipt = new bytes(0);\n        uint bytesToRead;\n        // skip vchTxValue\n        (bytesToRead, pos) = parseVarInt(txBytes, pos);\n        pos += bytesToRead;\n        // skip vchTxParentNodes\n        (bytesToRead, pos) = parseVarInt(txBytes, pos);\n        pos += bytesToRead;\n        // skip vchTxRoot\n        (bytesToRead, pos) = parseVarInt(txBytes, pos);\n        pos += bytesToRead;\n        // skip vchTxPath\n        (bytesToRead, pos) = parseVarInt(txBytes, pos);\n        pos += bytesToRead;\n        // get vchReceiptValue\n        (bytesToRead, pos) = parseVarInt(txBytes, pos);\n        // if position is encoded in receipt value, decode position and read the value from next field (parent nodes)\n        if(bytesToRead == 2){\n            uint16 positionOfValue = bytesToUint16(txBytes, pos);\n            pos += bytesToRead;\n            // get vchReceiptParentNodes\n            (bytesToRead, pos) = parseVarInt(txBytes, pos);\n            pos += positionOfValue;\n            ethTxReceipt = sliceArray(txBytes, pos, pos+(bytesToRead-positionOfValue));\n        }\n        // size > 2 means receipt value is fully serialized in this field and no need to get parent nodes field\n        else{\n            ethTxReceipt = sliceArray(txBytes, pos, pos+bytesToRead);      \n        }\n        return ethTxReceipt;\n    }\n\n     /**\n     * Parse txBytes and returns assetguid + contract address\n     * @param txBytes syscoin raw transaction\n     * @param pos position at where to start parsing\n     * @return asset guid (uint32) and erc20 address linked to the asset guid to update registry in erc20manager\n     */\n    function scanAssetTx(bytes memory txBytes, uint pos)\n        public\n        view\n        returns (uint32, address)\n    {\n        uint32 assetGUID;\n        address erc20Address;\n        uint bytesToRead;\n        // skip vchPubData\n        (bytesToRead, pos) = parseVarInt(txBytes, pos);\n        pos += bytesToRead;\n        // skip txHash\n        pos += 32;\n        // get nAsset\n        assetGUID = bytesToUint32Flipped(txBytes, pos);\n        pos += 4;\n        // skip strSymbol\n        (bytesToRead, pos) = parseVarInt(txBytes, pos);\n        pos += bytesToRead;\n        // skip witnessAddress.nVersion\n        pos += 1;\n        // skip witnessAddress.vchWitnessProgram\n        (bytesToRead, pos) = parseVarInt(txBytes, pos);\n        pos += bytesToRead;\n        // skip witnessAddressTransfer.nVersion\n        pos += 1;\n        // skip witnessAddressTransfer.vchWitnessProgram\n        (bytesToRead, pos) = parseVarInt(txBytes, pos);\n        pos += bytesToRead;\n        // skip nBalance\n        pos += 8;\n        // skip nTotalSupply\n        pos += 8;\n        // skip nMaxSupply\n        pos += 8;\n        // skip nHeight\n        pos += 4;\n        // skip nUpdateFlags\n        pos += 1;\n        // skip nPrecision\n        pos += 1;\n        // get vchContract\n        (bytesToRead, pos) = parseVarInt(txBytes, pos);\n        require(bytesToRead == 0x14,\n        \"scanAssetTx(): Invalid number of bytes read for contract field\");\n        erc20Address = readEthereumAddress(txBytes, pos);\n        return (assetGUID, erc20Address);\n    }\n\n    // @dev converts bytes of any length to bytes32.\n    // If `_rawBytes` is longer than 32 bytes, it truncates to the 32 leftmost bytes.\n    // If it is shorter, it pads with 0s on the left.\n    // Should be private, made internal for testing\n    //\n    // @param _rawBytes - arbitrary length bytes\n    // @return - leftmost 32 or less bytes of input value; padded if less than 32\n    function bytesToBytes32(bytes memory _rawBytes, uint pos) public pure returns (bytes32) {\n        bytes32 out;\n        assembly {\n            out := mload(add(add(_rawBytes, 0x20), pos))\n        }\n        return out;\n    }\n\n    /**\n     * Return logs for given ethereum transaction receipt\n     * @param  ethTxReceipt ethereum transaction receipt\n     * @return logs bloom\n     */\n    function getLogValuesForTopic(bytes memory ethTxReceipt, bytes32 expectedTopic)\n        public\n        pure\n        returns (bytes memory)\n    {\n        RLPReader.RLPItem[] memory ethTxReceiptList = ethTxReceipt.toRlpItem().toList();\n        RLPReader.RLPItem[] memory logsList = ethTxReceiptList[3].toList();\n        for (uint256 i = 0; i < logsList.length; i++) {\n            RLPReader.RLPItem[] memory log = logsList[i].toList();\n            bytes memory rawTopic = log[1].toBytes();\n            bytes32 topic = bytesToBytes32(rawTopic, 1); // need to remove first byte \"a0\"\n            if (topic == expectedTopic) {\n                // data for given log\n                return log[2].toBytes();\n            }\n        }\n        revert(\"Topic not found\");\n    }\n\n    /**\n     * Get bridgeTransactionId from logs bloom\n     * @param logValues log values\n     * @return bridgeTransactionId\n     */\n    function getBridgeTransactionId(bytes memory logValues) public pure returns (uint256 value) {\n        uint8 index = 3; // log's third value\n        assembly {\n            value := mload(add(logValues, mul(32, index)))\n        }\n    }\n\n    // @dev - Initializes superblocks contract\n    //\n    // Initializes the superblock contract. It can only be called once.\n    //\n    // @param _blocksMerkleRoot Root of the merkle tree of blocks contained in a superblock\n    // @param _timestamp Timestamp of the last block in the superblock\n    // @param _mtpTimestamp Median Timestamp of the last block in the superblock\n    // @param _lastHash Hash of the last block in the superblock\n    // @param _lastBits Difficulty bits of the last block in the superblock bits\n    // @param _parentId Id of the parent superblock\n    // @param _blockHeight Block height of last block in superblock\n    // @return Error code and superblockHash\n    function initialize(\n        bytes32 _blocksMerkleRoot,\n        uint _timestamp,\n        uint _mtpTimestamp,\n        bytes32 _lastHash,\n        uint32 _lastBits,\n        bytes32 _parentId\n    ) external returns (uint, bytes32) {\n        require(bestSuperblock == 0);\n        require(_parentId == 0);\n\n        bytes32 superblockHash = calcSuperblockHash(_blocksMerkleRoot, _timestamp, _mtpTimestamp, _lastHash, _lastBits, _parentId);\n        SuperblockInfo storage superblock = superblocks[superblockHash];\n\n        require(superblock.status == Status.Uninitialized);\n\n        superblock.blocksMerkleRoot = _blocksMerkleRoot;\n        superblock.timestamp = _timestamp;\n        superblock.mtpTimestamp = _mtpTimestamp;\n        superblock.lastHash = _lastHash;\n        superblock.parentId = _parentId;\n        superblock.submitter = msg.sender;\n        superblock.height = 1;\n        superblock.lastBits = _lastBits;\n        superblock.status = Status.Approved;\n\n        emit NewSuperblock(superblockHash, msg.sender);\n\n        bestSuperblock = superblockHash;\n        emit ApprovedSuperblock(superblockHash, msg.sender);\n\n        return (ERR_SUPERBLOCK_OK, superblockHash);\n    }\n\n    // @dev - Proposes a new superblock\n    //\n    // To be accepted, a new superblock needs to have its parent\n    // either approved or semi-approved.\n    //\n    // @param _blocksMerkleRoot Root of the merkle tree of blocks contained in a superblock\n    // @param _timestamp Timestamp of the last block in the superblock\n    // @param _mtpTimestamp Median Timestamp of the last block in the superblock\n    // @param _lastHash Hash of the last block in the superblock\n    // @param _lastBits Difficulty bits of the last block in the superblock bits\n    // @param _parentId Id of the parent superblock\n    // @return Error code and superblockHash\n    function propose(\n        bytes32 _blocksMerkleRoot,\n        uint _timestamp,\n        uint _mtpTimestamp,\n        bytes32 _lastHash,\n        uint32 _lastBits,\n        bytes32 _parentId,\n        address submitter\n    ) external returns (uint, bytes32) {\n        if (msg.sender != trustedClaimManager) {\n            emit ErrorSuperblock(0, ERR_SUPERBLOCK_NOT_CLAIMMANAGER);\n            return (ERR_SUPERBLOCK_NOT_CLAIMMANAGER, 0);\n        }\n\n        SuperblockInfo storage parent = superblocks[_parentId];\n        if (parent.status != Status.SemiApproved && parent.status != Status.Approved) {\n            emit ErrorSuperblock(_parentId, ERR_SUPERBLOCK_BAD_PARENT + uint(parent.status));\n            return (ERR_SUPERBLOCK_BAD_PARENT + uint(parent.status), 0);\n        }\n\n        if (parent.height < getChainHeight()) {\n            emit ErrorSuperblock(_parentId, ERR_SUPERBLOCK_BAD_BLOCKHEIGHT);\n            return (ERR_SUPERBLOCK_BAD_BLOCKHEIGHT, 0);\n        }\n\n        bytes32 superblockHash = calcSuperblockHash(_blocksMerkleRoot, _timestamp, _mtpTimestamp, _lastHash, _lastBits, _parentId);\n        SuperblockInfo storage superblock = superblocks[superblockHash];\n        if (superblock.status == Status.Uninitialized) {\n            superblock.blocksMerkleRoot = _blocksMerkleRoot;\n            superblock.timestamp = _timestamp;\n            superblock.mtpTimestamp = _mtpTimestamp;\n            superblock.lastHash = _lastHash;\n            superblock.parentId = _parentId;\n            superblock.height = parent.height + 1;\n            superblock.lastBits = _lastBits;\n        }\n        superblock.status = Status.New;\n        superblock.submitter = submitter;\n        emit NewSuperblock(superblockHash, submitter);\n        return (ERR_SUPERBLOCK_OK, superblockHash);\n    }\n\n    // @dev - Confirm a proposed superblock\n    //\n    // An unchallenged superblock can be confirmed after a timeout.\n    // A challenged superblock is confirmed if it has enough descendants\n    // in the main chain.\n    //\n    // @param _superblockHash Id of the superblock to confirm\n    // @param _validator Address requesting superblock confirmation\n    // @return Error code and superblockHash\n    function confirm(bytes32 _superblockHash, address _validator) external returns (uint) {\n        if (msg.sender != trustedClaimManager) {\n            emit ErrorSuperblock(_superblockHash, ERR_SUPERBLOCK_NOT_CLAIMMANAGER);\n            return ERR_SUPERBLOCK_NOT_CLAIMMANAGER;\n        }\n        SuperblockInfo storage superblock = superblocks[_superblockHash];\n        if (superblock.status != Status.New && superblock.status != Status.SemiApproved) {\n            emit ErrorSuperblock(_superblockHash, ERR_SUPERBLOCK_BAD_STATUS);\n            return ERR_SUPERBLOCK_BAD_STATUS;\n        }\n\n        if (superblock.height <= getChainHeight()) {\n            emit ErrorSuperblock(_superblockHash, ERR_SUPERBLOCK_BAD_BLOCKHEIGHT);\n            return ERR_SUPERBLOCK_BAD_BLOCKHEIGHT;\n        }\n\n        SuperblockInfo storage parent = superblocks[superblock.parentId];\n        if (parent.status != Status.Approved) {\n            emit ErrorSuperblock(_superblockHash, ERR_SUPERBLOCK_BAD_PARENT);\n            return ERR_SUPERBLOCK_BAD_PARENT;\n        }\n\n        superblock.status = Status.Approved;\n        bestSuperblock = _superblockHash;\n\n        emit ApprovedSuperblock(_superblockHash, _validator);\n        return ERR_SUPERBLOCK_OK;\n    }\n\n    // @dev - Challenge a proposed superblock\n    //\n    // A new superblock can be challenged to start a battle\n    // to verify the correctness of the data submitted.\n    //\n    // @param _superblockHash Id of the superblock to challenge\n    // @param _challenger Address requesting a challenge\n    // @return Error code and superblockHash\n    function challenge(bytes32 _superblockHash, address _challenger) external returns (uint) {\n        if (msg.sender != trustedClaimManager) {\n            emit ErrorSuperblock(_superblockHash, ERR_SUPERBLOCK_NOT_CLAIMMANAGER);\n            return ERR_SUPERBLOCK_NOT_CLAIMMANAGER;\n        }\n        SuperblockInfo storage superblock = superblocks[_superblockHash];\n        if (superblock.status != Status.New && superblock.status != Status.InBattle) {\n            emit ErrorSuperblock(_superblockHash, ERR_SUPERBLOCK_BAD_STATUS);\n            return ERR_SUPERBLOCK_BAD_STATUS;\n        }\n        if(superblock.submitter == _challenger){\n            emit ErrorSuperblock(_superblockHash, ERR_SUPERBLOCK_OWN_CHALLENGE);\n            return ERR_SUPERBLOCK_OWN_CHALLENGE;\n        }\n        superblock.status = Status.InBattle;\n        emit ChallengeSuperblock(_superblockHash, _challenger);\n        return ERR_SUPERBLOCK_OK;\n    }\n\n    // @dev - Semi-approve a challenged superblock\n    //\n    // A challenged superblock can be marked as semi-approved\n    // if it satisfies all the queries or when all challengers have\n    // stopped participating.\n    //\n    // @param _superblockHash Id of the superblock to semi-approve\n    // @param _validator Address requesting semi approval\n    // @return Error code and superblockHash\n    function semiApprove(bytes32 _superblockHash, address _validator) external returns (uint) {\n        if (msg.sender != trustedClaimManager) {\n            emit ErrorSuperblock(_superblockHash, ERR_SUPERBLOCK_NOT_CLAIMMANAGER);\n            return ERR_SUPERBLOCK_NOT_CLAIMMANAGER;\n        }\n        SuperblockInfo storage superblock = superblocks[_superblockHash];\n\n        if (superblock.status != Status.InBattle && superblock.status != Status.New) {\n            emit ErrorSuperblock(_superblockHash, ERR_SUPERBLOCK_BAD_STATUS);\n            return ERR_SUPERBLOCK_BAD_STATUS;\n        }\n        superblock.status = Status.SemiApproved;\n\n        emit SemiApprovedSuperblock(_superblockHash, _validator);\n        return ERR_SUPERBLOCK_OK;\n    }\n\n    // @dev - Invalidates a superblock\n    //\n    // A superblock with incorrect data can be invalidated immediately.\n    // Superblocks that are not in the main chain can be invalidated\n    // if not enough superblocks follow them, i.e. they don't have\n    // enough descendants.\n    //\n    // @param _superblockHash Id of the superblock to invalidate\n    // @param _validator Address requesting superblock invalidation\n    // @return Error code and superblockHash\n    function invalidate(bytes32 _superblockHash, address _validator) external returns (uint) {\n        if (msg.sender != trustedClaimManager) {\n            emit ErrorSuperblock(_superblockHash, ERR_SUPERBLOCK_NOT_CLAIMMANAGER);\n            return ERR_SUPERBLOCK_NOT_CLAIMMANAGER;\n        }\n        SuperblockInfo storage superblock = superblocks[_superblockHash];\n        if (superblock.status != Status.InBattle && superblock.status != Status.SemiApproved) {\n            emit ErrorSuperblock(_superblockHash, ERR_SUPERBLOCK_BAD_STATUS);\n            return ERR_SUPERBLOCK_BAD_STATUS;\n        }\n        superblock.status = Status.Invalid;\n        emit InvalidSuperblock(_superblockHash, _validator);\n        return ERR_SUPERBLOCK_OK;\n    }\n\n    // @dev - Verify TX SPV to Block proof as well as Block SPV proof to Superblock\n    // @param _txBytes - transaction bytes\n    // @param _txIndex - transaction's index within the block\n    // @param _txSiblings - transaction's Merkle siblings\n    // @param _syscoinBlockHeader - block header containing transaction\n    // @param _syscoinBlockIndex - block's index within superblock\n    // @param _syscoinBlockSiblings - block's merkle siblings\n    // @param _superblockHash - superblock containing block header\n    function verifySPVProofs(\n        bytes memory _syscoinBlockHeader,\n        uint _syscoinBlockIndex,\n        uint[] memory _syscoinBlockSiblings,\n        bytes32 _superblockHash,\n        bytes memory _txBytes,\n        uint _txIndex,\n        uint[] memory _txSiblings\n    ) private returns (uint) {\n        // Check if Syscoin block belongs to given superblock\n        if (bytes32(computeMerkle(dblShaFlip(_syscoinBlockHeader), _syscoinBlockIndex, _syscoinBlockSiblings))\n            != superblocks[_superblockHash].blocksMerkleRoot) {\n            // Syscoin block is not in superblock\n            emit VerifyTransaction(bytes32(0), ERR_SUPERBLOCK_MERKLE_ROOT);\n            return 0;\n        }\n        return verifyTx(_txBytes, _txIndex, _txSiblings, _syscoinBlockHeader, _superblockHash);\n    }\n\n    // @dev - relays transaction `_txBytes` to ERC20Manager's processTransaction() method.\n    // Also logs the value of processTransaction.\n    // Note: callers cannot be 100% certain when an ERR_RELAY_VERIFY occurs because\n    // it may also have been returned by processTransaction(). Callers should be\n    // aware of the contract that they are relaying transactions to and\n    // understand what that contract's processTransaction method returns.\n    //\n    // @param _txBytes - transaction bytes\n    // @param _txIndex - transaction's index within the block\n    // @param _txSiblings - transaction's Merkle siblings\n    // @param _syscoinBlockHeader - block header containing transaction\n    // @param _syscoinBlockIndex - block's index within superblock\n    // @param _syscoinBlockSiblings - block's merkle siblings\n    // @param _superblockHash - superblock containing block header\n    function relayTx(\n        bytes memory _txBytes,\n        uint _txIndex,\n        uint[] memory _txSiblings,\n        bytes memory _syscoinBlockHeader,\n        uint _syscoinBlockIndex,\n        uint[] memory _syscoinBlockSiblings,\n        bytes32 _superblockHash\n    ) public returns (uint) {\n        uint txHash = verifySPVProofs(_syscoinBlockHeader, _syscoinBlockIndex, _syscoinBlockSiblings, _superblockHash, _txBytes, _txIndex, _txSiblings);\n        if (txHash != 0) {\n            uint value;\n            address destinationAddress;\n            uint ret;\n            uint32 assetGUID;\n            address erc20ContractAddress;\n            uint8 precision;\n            (ret, value, destinationAddress, assetGUID, precision, erc20ContractAddress) = parseBurnTx(_txBytes);\n            if(ret != 0){\n                emit RelayTransaction(bytes32(txHash), ret);\n                return ret;\n            }\n            syscoinERC20Manager.processTransaction(txHash, value, destinationAddress, superblocks[_superblockHash].submitter, erc20ContractAddress, assetGUID, precision);\n            return value;\n        }\n        emit RelayTransaction(bytes32(0), ERR_RELAY_VERIFY);\n        return(ERR_RELAY_VERIFY);\n    }\n\n    // @dev - relays asset transaction(new or update) `_txBytes` to ERC20Manager's processAsset() method.\n    // Also logs the value of processAsset.\n    // Note: callers cannot be 100% certain when an ERR_RELAY_VERIFY occurs because\n    // it may also have been returned by processAsset(). Callers should be\n    // aware of the contract that they are relaying transactions to and\n    // understand what that contract's processTransaction method returns.\n    //\n    // @param _txBytes - transaction bytes\n    // @param _txIndex - transaction's index within the block\n    // @param _txSiblings - transaction's Merkle siblings\n    // @param _syscoinBlockHeader - block header containing transaction\n    // @param _syscoinBlockIndex - block's index within superblock\n    // @param _syscoinBlockSiblings - block's merkle siblings\n    // @param _superblockHash - superblock containing block header\n    function relayAssetTx(\n        bytes memory _txBytes,\n        uint _txIndex,\n        uint[] memory _txSiblings,\n        bytes memory _syscoinBlockHeader,\n        uint _syscoinBlockIndex,\n        uint[] memory _syscoinBlockSiblings,\n        bytes32 _superblockHash\n    ) public returns (uint) {\n        uint txHash = verifySPVProofs(_syscoinBlockHeader, _syscoinBlockIndex, _syscoinBlockSiblings, _superblockHash, _txBytes, _txIndex, _txSiblings);\n        if (txHash != 0) {\n            uint ret;\n            uint32 assetGUID;\n            address erc20ContractAddress;\n            (ret, assetGUID, erc20ContractAddress) = parseAssetTx(_txBytes);\n            if(ret != 0){\n                emit RelayTransaction(bytes32(txHash), ret);\n                return ret;\n            }\n            uint32 height = superblocks[_superblockHash].height*60;\n            height += uint32(_syscoinBlockIndex);\n            // pass in height of block as well by calc superblock sets of 60 blocks\n            syscoinERC20Manager.processAsset(txHash, assetGUID, height, erc20ContractAddress);\n            return 0;\n        }\n        emit RelayTransaction(bytes32(0), ERR_RELAY_VERIFY);\n        return(ERR_RELAY_VERIFY);\n    }\n\n    // Challenges a bridge cancellation request with SPV proofs linking tx to superblock and showing that a valid\n    // cancellation request exists. If challenge fails, the cancellation request continues until timeout at which point erc20 is refunded\n    //\n    // @param _txBytes - transaction bytes\n    // @param _txIndex - transaction's index within the block\n    // @param _txSiblings - transaction's Merkle siblings\n    // @param _syscoinBlockHeader - block header containing transaction\n    // @param _syscoinBlockIndex - block's index within superblock\n    // @param _syscoinBlockSiblings - block's merkle siblings\n    // @param _superblockHash - superblock containing block header\n    function challengeCancelTransfer(\n        bytes memory _txBytes,\n        uint _txIndex,\n        uint[] memory _txSiblings,\n        bytes memory _syscoinBlockHeader,\n        uint _syscoinBlockIndex,\n        uint[] memory _syscoinBlockSiblings,\n        bytes32 _superblockHash\n    ) public returns (uint) {\n        uint txHash = verifySPVProofs(_syscoinBlockHeader, _syscoinBlockIndex, _syscoinBlockSiblings, _superblockHash, _txBytes, _txIndex, _txSiblings);\n        if (txHash != 0) {\n            uint32 bridgeTransferId;\n            uint ret;\n            (ret, bridgeTransferId) = parseMintTx(_txBytes);\n            if(ret != 0){\n                emit RelayTransaction(bytes32(txHash), ret);\n                return ret;\n            }\n            // check if cancellation request exists in valid state\n            // cancel cancellation request if challenger wins, challenger gets paid cancellors deposit\n            syscoinERC20Manager.processCancelTransferFail(bridgeTransferId, msg.sender);\n            return 0;\n        }\n        emit ChallengeCancelTransferRequest(ERR_CANCEL_TRANSFER_VERIFY);\n        return(ERR_CANCEL_TRANSFER_VERIFY);\n    }\n\n    // @dev - Parses a syscoin tx\n    //\n    // @param txBytes - tx byte array\n    // Outputs\n    // @return output_value - amount sent to the lock address in satoshis\n    // @return destinationAddress - ethereum destination address\n    function parseBurnTx(bytes memory txBytes)\n        public\n        pure\n        returns (uint, uint, address, uint32, uint8, address)\n    {\n        uint output_value;\n        uint32 assetGUID;\n        address destinationAddress;\n        uint32 version;\n        address erc20Address;\n        uint8 precision;\n        uint pos = 0;\n        version = bytesToUint32Flipped(txBytes, pos);\n        if(version != SYSCOIN_TX_VERSION_ALLOCATION_BURN_TO_ETHEREUM){\n            return (ERR_PARSE_TX_SYS, output_value, destinationAddress, assetGUID, precision, erc20Address);\n        }\n        pos = getOpReturnPos(txBytes, 4);\n        (output_value, destinationAddress, assetGUID, precision, erc20Address) = scanAssetDetails(txBytes, pos);\n        return (0, output_value, destinationAddress, assetGUID, precision, erc20Address);\n    }\n\n    function skipInputs(bytes memory txBytes, uint pos)\n        private\n        pure\n        returns (uint)\n    {\n        uint n_inputs;\n        uint script_len;\n        (n_inputs, pos) = parseVarInt(txBytes, pos);\n        // if dummy 0x00 is present this is a witness transaction\n        if(n_inputs == 0x00){\n            (n_inputs, pos) = parseVarInt(txBytes, pos); // flag\n            require(n_inputs != 0x00, \"#SyscoinSuperblocks skipInputs(): Unexpected dummy/flag\");\n            // after dummy/flag the real var int comes for txins\n            (n_inputs, pos) = parseVarInt(txBytes, pos);\n        }\n        require(n_inputs < 100, \"#SyscoinSuperblocks skipInputs(): Incorrect size of n_inputs\");\n\n        for (uint i = 0; i < n_inputs; i++) {\n            pos += 36;  // skip outpoint\n            (script_len, pos) = parseVarInt(txBytes, pos);\n            pos += script_len + 4;  // skip sig_script, seq\n        }\n\n        return pos;\n    }\n\n    // @dev - Checks whether the transaction given by `_txBytes` is in the block identified by `_txBlockHeaderBytes`.\n    // First it guards against a Merkle tree collision attack by raising an error if the transaction is exactly 64 bytes long,\n    // then it calls helperVerifyHash to do the actual check.\n    //\n    // @param _txBytes - transaction bytes\n    // @param _txIndex - transaction's index within the block\n    // @param _siblings - transaction's Merkle siblings\n    // @param _txBlockHeaderBytes - block header containing transaction\n    // @param _txsuperblockHash - superblock containing block header\n    // @return - SHA-256 hash of _txBytes if the transaction is in the block, 0 otherwise\n    function verifyTx(\n        bytes memory _txBytes,\n        uint _txIndex,\n        uint[] memory _siblings,\n        bytes memory _txBlockHeaderBytes,\n        bytes32 _txsuperblockHash\n    ) private returns (uint) {\n        uint txHash = dblShaFlip(_txBytes);\n\n        if (_txBytes.length == 64) {  // todo: is check 32 also needed?\n            emit VerifyTransaction(bytes32(txHash), ERR_TX_64BYTE);\n            return 0;\n        }\n\n        if (helperVerifyHash(txHash, _txIndex, _siblings, _txBlockHeaderBytes, _txsuperblockHash) == 1) {\n            return txHash;\n        } else {\n            // log is done via helperVerifyHash\n            return 0;\n        }\n    }\n\n    // @dev - Bitcoin-way of hashing\n    // @param _dataBytes - raw data to be hashed\n    // @return - result of applying SHA-256 twice to raw data and then flipping the bytes\n    function dblShaFlip(bytes memory _dataBytes) public pure returns (uint) {\n        return flip32Bytes(uint(sha256(abi.encodePacked(sha256(abi.encodePacked(_dataBytes))))));\n    }\n\n    // @dev - extract Merkle root field from a raw Syscoin block header\n    //\n    // @param _blockHeader - Syscoin block header bytes\n    // @param pos - where to start reading root from\n    // @return - block's Merkle root in big endian format\n    function getHeaderMerkleRoot(bytes memory _blockHeader) public pure returns (uint) {\n        uint merkle;\n        assembly {\n            merkle := mload(add(add(_blockHeader, 32), 0x24))\n        }\n        return flip32Bytes(merkle);\n    }\n\n    // @dev - Checks whether the transaction identified by `_txHash` is in the block identified by `_blockHeaderBytes`\n    // and whether the block is in the Syscoin main chain. Transaction check is done via Merkle proof.\n    // Note: no verification is performed to prevent txHash from just being an\n    // internal hash in the Merkle tree. Thus this helper method should NOT be used\n    // directly and is intended to be private.\n    //\n    // @param _txHash - transaction hash\n    // @param _txIndex - transaction's index within the block\n    // @param _siblings - transaction's Merkle siblings\n    // @param _blockHeaderBytes - block header containing transaction\n    // @param _txsuperblockHash - superblock containing block header\n    // @return - 1 if the transaction is in the block and the block is in the main chain,\n    // 20020 (ERR_CONFIRMATIONS) if the block is not in the main chain,\n    // 20050 (ERR_MERKLE_ROOT) if the block is in the main chain but the Merkle proof fails.\n    function helperVerifyHash(\n        uint256 _txHash,\n        uint _txIndex,\n        uint[] memory _siblings,\n        bytes memory _blockHeaderBytes,\n        bytes32 _txsuperblockHash\n    ) private returns (uint) {\n\n        if (!isApproved(_txsuperblockHash)) {\n            emit VerifyTransaction(bytes32(_txHash), ERR_CHAIN);\n            return (ERR_CHAIN);\n        }\n\n        // Verify tx Merkle root\n        uint merkle = getHeaderMerkleRoot(_blockHeaderBytes);\n        if (computeMerkle(_txHash, _txIndex, _siblings) != merkle) {\n            emit VerifyTransaction(bytes32(_txHash), ERR_MERKLE_ROOT);\n            return (ERR_MERKLE_ROOT);\n        }\n        return (1);\n    }\n\n    // @dev - Calculate superblock hash from superblock data\n    //\n    // @param _blocksMerkleRoot Root of the merkle tree of blocks contained in a superblock\n    // @param _timestamp Timestamp of the last block in the superblock\n    // @param _mtpTimestamp Median Timestamp of the last block in the superblock\n    // @param _lastHash Hash of the last block in the superblock\n    // @param _lastBits Difficulty bits of the last block in the superblock bits\n    // @param _parentId Id of the parent superblock\n    // @return Superblock id\n    function calcSuperblockHash(\n        bytes32 _blocksMerkleRoot,\n        uint _timestamp,\n        uint _mtpTimestamp,\n        bytes32 _lastHash,\n        uint32 _lastBits,\n        bytes32 _parentId\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\n            _blocksMerkleRoot,\n            _timestamp,\n            _mtpTimestamp,\n            _lastHash,\n            _lastBits,\n            _parentId\n        ));\n    }\n\n    // @dev - Returns the confirmed superblock with the most accumulated work\n    //\n    // @return Best superblock hash\n    function getBestSuperblock() external view returns (bytes32) {\n        return bestSuperblock;\n    }\n\n    // @dev - Returns the superblock data for the supplied superblock hash\n    //\n    function getSuperblock(bytes32 superblockHash) external view returns (\n        bytes32 _blocksMerkleRoot,\n        uint _timestamp,\n        uint _mtpTimestamp,\n        bytes32 _lastHash,\n        uint32 _lastBits,\n        bytes32 _parentId,\n        address _submitter,\n        Status _status,\n        uint32 _height\n    ) {\n        SuperblockInfo storage superblock = superblocks[superblockHash];\n        return (\n            superblock.blocksMerkleRoot,\n            superblock.timestamp,\n            superblock.mtpTimestamp,\n            superblock.lastHash,\n            superblock.lastBits,\n            superblock.parentId,\n            superblock.submitter,\n            superblock.status,\n            superblock.height\n        );\n    }\n\n    // @dev - Returns superblock height\n    function getSuperblockHeight(bytes32 superblockHash) public view returns (uint32) {\n        return superblocks[superblockHash].height;\n    }\n\n    // @dev - Return superblock timestamp\n    function getSuperblockTimestamp(bytes32 _superblockHash) external view returns (uint) {\n        return superblocks[_superblockHash].timestamp;\n    }\n\n    // @dev - Return superblock median timestamp\n    function getSuperblockMedianTimestamp(bytes32 _superblockHash) external view returns (uint) {\n        return superblocks[_superblockHash].mtpTimestamp;\n    }\n\n    // @dev - Return superblock parent\n    function getSuperblockParentId(bytes32 _superblockHash) external view returns (bytes32) {\n        return superblocks[_superblockHash].parentId;\n    }\n\n\n    // @dev - Return superblock status\n    function getSuperblockStatus(bytes32 _superblockHash) public view returns (Status) {\n        return superblocks[_superblockHash].status;\n    }\n\n    function isApproved(bytes32 _superblockHash) private view returns (bool) {\n        return (getSuperblockStatus(_superblockHash) == Status.Approved);\n    }\n    function getChainHeight() public view returns (uint) {\n        return superblocks[bestSuperblock].height;\n    }\n\n    // @dev - return superblock hash at a given height in superblock main chain\n    //\n    // @param _height - superblock height\n    // @return - hash corresponding to block of height _height\n    function getSuperblockAt(uint _height) external view returns (bytes32) {\n        bytes32 superblockHash = bestSuperblock;\n\n        while (getSuperblockHeight(superblockHash) > _height) {\n            superblockHash = superblocks[superblockHash].parentId;\n        }\n\n        return superblockHash;\n    }\n}\n","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"ApprovedSuperblock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"returnCode\",\"type\":\"uint256\"}],\"name\":\"ChallengeCancelTransferRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"ChallengeSuperblock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"err\",\"type\":\"uint256\"}],\"name\":\"ErrorSuperblock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"InvalidSuperblock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"NewSuperblock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"returnCode\",\"type\":\"uint256\"}],\"name\":\"RelayTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"SemiApprovedSuperblock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"returnCode\",\"type\":\"uint256\"}],\"name\":\"VerifyTransaction\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_rawBytes\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"pos\",\"type\":\"uint256\"}],\"name\":\"bytesToBytes32\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"input\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"pos\",\"type\":\"uint256\"}],\"name\":\"bytesToUint16\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"result\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"input\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"pos\",\"type\":\"uint256\"}],\"name\":\"bytesToUint32\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"result\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"input\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"pos\",\"type\":\"uint256\"}],\"name\":\"bytesToUint32Flipped\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"result\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"input\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"pos\",\"type\":\"uint256\"}],\"name\":\"bytesToUint64\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"result\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_blocksMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mtpTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_lastHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_lastBits\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_parentId\",\"type\":\"bytes32\"}],\"name\":\"calcSuperblockHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_superblockHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_challenger\",\"type\":\"address\"}],\"name\":\"challenge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_txBytes\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_txIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_txSiblings\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_syscoinBlockHeader\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_syscoinBlockIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_syscoinBlockSiblings\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32\",\"name\":\"_superblockHash\",\"type\":\"bytes32\"}],\"name\":\"challengeCancelTransfer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_txHash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_txIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_siblings\",\"type\":\"uint256[]\"}],\"name\":\"computeMerkle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_superblockHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"}],\"name\":\"confirm\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_dataBytes\",\"type\":\"bytes\"}],\"name\":\"dblShaFlip\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_input\",\"type\":\"uint256\"}],\"name\":\"flip32Bytes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBestSuperblock\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"logValues\",\"type\":\"bytes\"}],\"name\":\"getBridgeTransactionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"pos\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bits\",\"type\":\"uint256\"}],\"name\":\"getBytesLE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getChainHeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txBytes\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"pos\",\"type\":\"uint256\"}],\"name\":\"getEthReceipt\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_blockHeader\",\"type\":\"bytes\"}],\"name\":\"getHeaderMerkleRoot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"ethTxReceipt\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"expectedTopic\",\"type\":\"bytes32\"}],\"name\":\"getLogValuesForTopic\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txBytes\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"pos\",\"type\":\"uint256\"}],\"name\":\"getOpReturnPos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"}],\"name\":\"getSuperblock\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"_blocksMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mtpTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_lastHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_lastBits\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_parentId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_submitter\",\"type\":\"address\"},{\"internalType\":\"enum SyscoinSuperblocksI.Status\",\"name\":\"_status\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"_height\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_height\",\"type\":\"uint256\"}],\"name\":\"getSuperblockAt\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"}],\"name\":\"getSuperblockHeight\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_superblockHash\",\"type\":\"bytes32\"}],\"name\":\"getSuperblockMedianTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_superblockHash\",\"type\":\"bytes32\"}],\"name\":\"getSuperblockParentId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_superblockHash\",\"type\":\"bytes32\"}],\"name\":\"getSuperblockStatus\",\"outputs\":[{\"internalType\":\"enum SyscoinSuperblocksI.Status\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_superblockHash\",\"type\":\"bytes32\"}],\"name\":\"getSuperblockTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_syscoinERC20Manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_claimManager\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_blocksMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mtpTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_lastHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_lastBits\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_parentId\",\"type\":\"bytes32\"}],\"name\":\"initialize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_superblockHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"}],\"name\":\"invalidate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minProposalDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txBytes\",\"type\":\"bytes\"}],\"name\":\"parseAssetTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"errorCode\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"assetGuid\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txBytes\",\"type\":\"bytes\"}],\"name\":\"parseBurnTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txBytes\",\"type\":\"bytes\"}],\"name\":\"parseMintTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"errorCode\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"bridgeTransferId\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txBytes\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"pos\",\"type\":\"uint256\"}],\"name\":\"parseVarInt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_blocksMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mtpTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_lastHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_lastBits\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_parentId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"}],\"name\":\"propose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_txBytes\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_txIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_txSiblings\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_syscoinBlockHeader\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_syscoinBlockIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_syscoinBlockSiblings\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32\",\"name\":\"_superblockHash\",\"type\":\"bytes32\"}],\"name\":\"relayAssetTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_txBytes\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_txIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_txSiblings\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_syscoinBlockHeader\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_syscoinBlockIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_syscoinBlockSiblings\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32\",\"name\":\"_superblockHash\",\"type\":\"bytes32\"}],\"name\":\"relayTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txBytes\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"pos\",\"type\":\"uint256\"}],\"name\":\"scanAssetTx\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_superblockHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"}],\"name\":\"semiApprove\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_rawBytes\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endIndex\",\"type\":\"uint256\"}],\"name\":\"sliceArray\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"syscoinERC20Manager\",\"outputs\":[{\"internalType\":\"contract SyscoinTransactionProcessor\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trustedClaimManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SyscoinSuperblocks","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":""}]}