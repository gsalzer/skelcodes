{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n    Copyright 2020 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.5.7;\r\npragma experimental ABIEncoderV2;\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Require.sol\r\n\r\n/**\r\n * @title Require\r\n * @author dYdX\r\n *\r\n * Stringifies parameters to pretty-print revert messages. Costs more gas than regular require()\r\n */\r\nlibrary Require {\r\n\r\n    // ============ Constants ============\r\n\r\n    uint256 constant ASCII_ZERO = 48; // '0'\r\n    uint256 constant ASCII_RELATIVE_ZERO = 87; // 'a' - 10\r\n    uint256 constant ASCII_LOWER_EX = 120; // 'x'\r\n    bytes2 constant COLON = 0x3a20; // ': '\r\n    bytes2 constant COMMA = 0x2c20; // ', '\r\n    bytes2 constant LPAREN = 0x203c; // ' <'\r\n    byte constant RPAREN = 0x3e; // '>'\r\n    uint256 constant FOUR_BIT_MASK = 0xf;\r\n\r\n    // ============ Library Functions ============\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason)\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        uint256 payloadA\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        uint256 payloadA,\r\n        uint256 payloadB\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA,\r\n        uint256 payloadB\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA,\r\n        uint256 payloadB,\r\n        uint256 payloadC\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        COMMA,\r\n                        stringify(payloadC),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        bytes32 payloadA\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        bytes32 payloadA,\r\n        uint256 payloadB,\r\n        uint256 payloadC\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        COMMA,\r\n                        stringify(payloadC),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    // ============ Private Functions ============\r\n\r\n    function stringifyTruncated(\r\n        bytes32 input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        // put the input bytes into the result\r\n        bytes memory result = abi.encodePacked(input);\r\n\r\n        // determine the length of the input by finding the location of the last non-zero byte\r\n        for (uint256 i = 32; i > 0; ) {\r\n            // reverse-for-loops with unsigned integer\r\n            /* solium-disable-next-line security/no-modify-for-iter-var */\r\n            i--;\r\n\r\n            // find the last non-zero byte in order to determine the length\r\n            if (result[i] != 0) {\r\n                uint256 length = i + 1;\r\n\r\n                /* solium-disable-next-line security/no-inline-assembly */\r\n                assembly {\r\n                    mstore(result, length) // r.length = length;\r\n                }\r\n\r\n                return result;\r\n            }\r\n        }\r\n\r\n        // all bytes are zero\r\n        return new bytes(0);\r\n    }\r\n\r\n    function stringify(\r\n        uint256 input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        if (input == 0) {\r\n            return \"0\";\r\n        }\r\n\r\n        // get the final string length\r\n        uint256 j = input;\r\n        uint256 length;\r\n        while (j != 0) {\r\n            length++;\r\n            j /= 10;\r\n        }\r\n\r\n        // allocate the string\r\n        bytes memory bstr = new bytes(length);\r\n\r\n        // populate the string starting with the least-significant character\r\n        j = input;\r\n        for (uint256 i = length; i > 0; ) {\r\n            // reverse-for-loops with unsigned integer\r\n            /* solium-disable-next-line security/no-modify-for-iter-var */\r\n            i--;\r\n\r\n            // take last decimal digit\r\n            bstr[i] = byte(uint8(ASCII_ZERO + (j % 10)));\r\n\r\n            // remove the last decimal digit\r\n            j /= 10;\r\n        }\r\n\r\n        return bstr;\r\n    }\r\n\r\n    function stringify(\r\n        address input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        uint256 z = uint256(input);\r\n\r\n        // addresses are \"0x\" followed by 20 bytes of data which take up 2 characters each\r\n        bytes memory result = new bytes(42);\r\n\r\n        // populate the result with \"0x\"\r\n        result[0] = byte(uint8(ASCII_ZERO));\r\n        result[1] = byte(uint8(ASCII_LOWER_EX));\r\n\r\n        // for each byte (starting from the lowest byte), populate the result with two characters\r\n        for (uint256 i = 0; i < 20; i++) {\r\n            // each byte takes two characters\r\n            uint256 shift = i * 2;\r\n\r\n            // populate the least-significant character\r\n            result[41 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n\r\n            // populate the most-significant character\r\n            result[40 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function stringify(\r\n        bytes32 input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        uint256 z = uint256(input);\r\n\r\n        // bytes32 are \"0x\" followed by 32 bytes of data which take up 2 characters each\r\n        bytes memory result = new bytes(66);\r\n\r\n        // populate the result with \"0x\"\r\n        result[0] = byte(uint8(ASCII_ZERO));\r\n        result[1] = byte(uint8(ASCII_LOWER_EX));\r\n\r\n        // for each byte (starting from the lowest byte), populate the result with two characters\r\n        for (uint256 i = 0; i < 32; i++) {\r\n            // each byte takes two characters\r\n            uint256 shift = i * 2;\r\n\r\n            // populate the least-significant character\r\n            result[65 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n\r\n            // populate the most-significant character\r\n            result[64 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function char(\r\n        uint256 input\r\n    )\r\n        private\r\n        pure\r\n        returns (byte)\r\n    {\r\n        // return ASCII digit (0-9)\r\n        if (input < 10) {\r\n            return byte(uint8(input + ASCII_ZERO));\r\n        }\r\n\r\n        // return ASCII letter (a-f)\r\n        return byte(uint8(input + ASCII_RELATIVE_ZERO));\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Math.sol\r\n\r\n/**\r\n * @title Math\r\n * @author dYdX\r\n *\r\n * Library for non-standard Math functions\r\n */\r\nlibrary Math {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Constants ============\r\n\r\n    bytes32 constant FILE = \"Math\";\r\n\r\n    // ============ Library Functions ============\r\n\r\n    /*\r\n     * Return target * (numerator / denominator).\r\n     */\r\n    function getPartial(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return target.mul(numerator).div(denominator);\r\n    }\r\n\r\n    /*\r\n     * Return target * (numerator / denominator), but rounded up.\r\n     */\r\n    function getPartialRoundUp(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (target == 0 || numerator == 0) {\r\n            // SafeMath will check for zero denominator\r\n            return SafeMath.div(0, denominator);\r\n        }\r\n        return target.mul(numerator).sub(1).div(denominator).add(1);\r\n    }\r\n\r\n    function to128(\r\n        uint256 number\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint128)\r\n    {\r\n        uint128 result = uint128(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \"Unsafe cast to uint128\"\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function to96(\r\n        uint256 number\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint96)\r\n    {\r\n        uint96 result = uint96(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \"Unsafe cast to uint96\"\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function to32(\r\n        uint256 number\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint32)\r\n    {\r\n        uint32 result = uint32(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \"Unsafe cast to uint32\"\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function min(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a > b ? a : b;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Monetary.sol\r\n\r\n/**\r\n * @title Monetary\r\n * @author dYdX\r\n *\r\n * Library for types involving money\r\n */\r\nlibrary Monetary {\r\n\r\n    /*\r\n     * The price of a base-unit of an asset.\r\n     */\r\n    struct Price {\r\n        uint256 value;\r\n    }\r\n\r\n    /*\r\n     * Total value of an some amount of an asset. Equal to (price * amount).\r\n     */\r\n    struct Value {\r\n        uint256 value;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Types.sol\r\n\r\n/**\r\n * @title Types\r\n * @author dYdX\r\n *\r\n * Library for interacting with the basic structs used in Solo\r\n */\r\nlibrary Types {\r\n    using Math for uint256;\r\n\r\n    // ============ AssetAmount ============\r\n\r\n    enum AssetDenomination {\r\n        Wei, // the amount is denominated in wei\r\n        Par  // the amount is denominated in par\r\n    }\r\n\r\n    enum AssetReference {\r\n        Delta, // the amount is given as a delta from the current value\r\n        Target // the amount is given as an exact number to end up at\r\n    }\r\n\r\n    struct AssetAmount {\r\n        bool sign; // true if positive\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n\r\n    // ============ Par (Principal Amount) ============\r\n\r\n    // Total borrow and supply values for a market\r\n    struct TotalPar {\r\n        uint128 borrow;\r\n        uint128 supply;\r\n    }\r\n\r\n    // Individual principal amount for an account\r\n    struct Par {\r\n        bool sign; // true if positive\r\n        uint128 value;\r\n    }\r\n\r\n    function zeroPar()\r\n        internal\r\n        pure\r\n        returns (Par memory)\r\n    {\r\n        return Par({\r\n            sign: false,\r\n            value: 0\r\n        });\r\n    }\r\n\r\n    function sub(\r\n        Par memory a,\r\n        Par memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Par memory)\r\n    {\r\n        return add(a, negative(b));\r\n    }\r\n\r\n    function add(\r\n        Par memory a,\r\n        Par memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Par memory)\r\n    {\r\n        Par memory result;\r\n        if (a.sign == b.sign) {\r\n            result.sign = a.sign;\r\n            result.value = SafeMath.add(a.value, b.value).to128();\r\n        } else {\r\n            if (a.value >= b.value) {\r\n                result.sign = a.sign;\r\n                result.value = SafeMath.sub(a.value, b.value).to128();\r\n            } else {\r\n                result.sign = b.sign;\r\n                result.value = SafeMath.sub(b.value, a.value).to128();\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function equals(\r\n        Par memory a,\r\n        Par memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (a.value == b.value) {\r\n            if (a.value == 0) {\r\n                return true;\r\n            }\r\n            return a.sign == b.sign;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function negative(\r\n        Par memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (Par memory)\r\n    {\r\n        return Par({\r\n            sign: !a.sign,\r\n            value: a.value\r\n        });\r\n    }\r\n\r\n    function isNegative(\r\n        Par memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return !a.sign && a.value > 0;\r\n    }\r\n\r\n    function isPositive(\r\n        Par memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.sign && a.value > 0;\r\n    }\r\n\r\n    function isZero(\r\n        Par memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.value == 0;\r\n    }\r\n\r\n    // ============ Wei (Token Amount) ============\r\n\r\n    // Individual token amount for an account\r\n    struct Wei {\r\n        bool sign; // true if positive\r\n        uint256 value;\r\n    }\r\n\r\n    function zeroWei()\r\n        internal\r\n        pure\r\n        returns (Wei memory)\r\n    {\r\n        return Wei({\r\n            sign: false,\r\n            value: 0\r\n        });\r\n    }\r\n\r\n    function sub(\r\n        Wei memory a,\r\n        Wei memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Wei memory)\r\n    {\r\n        return add(a, negative(b));\r\n    }\r\n\r\n    function add(\r\n        Wei memory a,\r\n        Wei memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Wei memory)\r\n    {\r\n        Wei memory result;\r\n        if (a.sign == b.sign) {\r\n            result.sign = a.sign;\r\n            result.value = SafeMath.add(a.value, b.value);\r\n        } else {\r\n            if (a.value >= b.value) {\r\n                result.sign = a.sign;\r\n                result.value = SafeMath.sub(a.value, b.value);\r\n            } else {\r\n                result.sign = b.sign;\r\n                result.value = SafeMath.sub(b.value, a.value);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function equals(\r\n        Wei memory a,\r\n        Wei memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (a.value == b.value) {\r\n            if (a.value == 0) {\r\n                return true;\r\n            }\r\n            return a.sign == b.sign;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function negative(\r\n        Wei memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (Wei memory)\r\n    {\r\n        return Wei({\r\n            sign: !a.sign,\r\n            value: a.value\r\n        });\r\n    }\r\n\r\n    function isNegative(\r\n        Wei memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return !a.sign && a.value > 0;\r\n    }\r\n\r\n    function isPositive(\r\n        Wei memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.sign && a.value > 0;\r\n    }\r\n\r\n    function isZero(\r\n        Wei memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.value == 0;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Account.sol\r\n\r\n/**\r\n * @title Account\r\n * @author dYdX\r\n *\r\n * Library of structs and functions that represent an account\r\n */\r\nlibrary Account {\r\n    // ============ Enums ============\r\n\r\n    /*\r\n     * Most-recently-cached account status.\r\n     *\r\n     * Normal: Can only be liquidated if the account values are violating the global margin-ratio.\r\n     * Liquid: Can be liquidated no matter the account values.\r\n     *         Can be vaporized if there are no more positive account values.\r\n     * Vapor:  Has only negative (or zeroed) account values. Can be vaporized.\r\n     *\r\n     */\r\n    enum Status {\r\n        Normal,\r\n        Liquid,\r\n        Vapor\r\n    }\r\n\r\n    // ============ Structs ============\r\n\r\n    // Represents the unique key that specifies an account\r\n    struct Info {\r\n        address owner;  // The address that owns the account\r\n        uint256 number; // A nonce that allows a single address to control many accounts\r\n    }\r\n\r\n    // The complete storage for any account\r\n    struct Storage {\r\n        mapping (uint256 => Types.Par) balances; // Mapping from marketId to principal\r\n        Status status;\r\n    }\r\n\r\n    // ============ Library Functions ============\r\n\r\n    function equals(\r\n        Info memory a,\r\n        Info memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.owner == b.owner && a.number == b.number;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/interfaces/IAutoTrader.sol\r\n\r\n/**\r\n * @title IAutoTrader\r\n * @author dYdX\r\n *\r\n * Interface that Auto-Traders for Solo must implement in order to approve trades.\r\n */\r\ncontract IAutoTrader {\r\n\r\n    // ============ Public Functions ============\r\n\r\n    /**\r\n     * Allows traders to make trades approved by this smart contract. The active trader's account is\r\n     * the takerAccount and the passive account (for which this contract approves trades\r\n     * on-behalf-of) is the makerAccount.\r\n     *\r\n     * @param  inputMarketId   The market for which the trader specified the original amount\r\n     * @param  outputMarketId  The market for which the trader wants the resulting amount specified\r\n     * @param  makerAccount    The account for which this contract is making trades\r\n     * @param  takerAccount    The account requesting the trade\r\n     * @param  oldInputPar     The old principal amount for the makerAccount for the inputMarketId\r\n     * @param  newInputPar     The new principal amount for the makerAccount for the inputMarketId\r\n     * @param  inputWei        The change in token amount for the makerAccount for the inputMarketId\r\n     * @param  data            Arbitrary data passed in by the trader\r\n     * @return                 The AssetAmount for the makerAccount for the outputMarketId\r\n     */\r\n    function getTradeCost(\r\n        uint256 inputMarketId,\r\n        uint256 outputMarketId,\r\n        Account.Info memory makerAccount,\r\n        Account.Info memory takerAccount,\r\n        Types.Par memory oldInputPar,\r\n        Types.Par memory newInputPar,\r\n        Types.Wei memory inputWei,\r\n        bytes memory data\r\n    )\r\n        public\r\n        returns (Types.AssetAmount memory);\r\n}\r\n\r\n// File: contracts/protocol/interfaces/ICallee.sol\r\n\r\n/**\r\n * @title ICallee\r\n * @author dYdX\r\n *\r\n * Interface that Callees for Solo must implement in order to ingest data.\r\n */\r\ncontract ICallee {\r\n\r\n    // ============ Public Functions ============\r\n\r\n    /**\r\n     * Allows users to send this contract arbitrary data.\r\n     *\r\n     * @param  sender       The msg.sender to Solo\r\n     * @param  accountInfo  The account from which the data is being sent\r\n     * @param  data         Arbitrary data given by the sender\r\n     */\r\n    function callFunction(\r\n        address sender,\r\n        Account.Info memory accountInfo,\r\n        bytes memory data\r\n    )\r\n        public;\r\n}\r\n\r\n// File: contracts/protocol/SoloMargin.sol\r\n\r\ncontract SoloMargin {\r\n\r\n    /* ... */\r\n\r\n    function getAccountWei(\r\n        Account.Info memory account,\r\n        uint256 marketId\r\n    )\r\n        public\r\n        view\r\n        returns (Types.Wei memory);\r\n\r\n    function getMarketPrice(\r\n        uint256 marketId\r\n    )\r\n        public\r\n        view\r\n        returns (Monetary.Price memory);\r\n\r\n    /* ... */\r\n}\r\n\r\n// File: contracts/external/helpers/OnlySolo.sol\r\n\r\n/**\r\n * @title OnlySolo\r\n * @author dYdX\r\n *\r\n * Inheritable contract that restricts the calling of certain functions to Solo only\r\n */\r\ncontract OnlySolo {\r\n\r\n    // ============ Constants ============\r\n\r\n    bytes32 constant FILE = \"OnlySolo\";\r\n\r\n    // ============ Storage ============\r\n\r\n    SoloMargin public SOLO_MARGIN;\r\n\r\n    // ============ Constructor ============\r\n\r\n    constructor (\r\n        address soloMargin\r\n    )\r\n        public\r\n    {\r\n        SOLO_MARGIN = SoloMargin(soloMargin);\r\n    }\r\n\r\n    // ============ Modifiers ============\r\n\r\n    modifier onlySolo(address from) {\r\n        Require.that(\r\n            from == address(SOLO_MARGIN),\r\n            FILE,\r\n            \"Only Solo can call function\",\r\n            from\r\n        );\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/external/lib/TypedSignature.sol\r\n\r\n/**\r\n * @title TypedSignature\r\n * @author dYdX\r\n *\r\n * Library to unparse typed signatures\r\n */\r\nlibrary TypedSignature {\r\n\r\n    // ============ Constants ============\r\n\r\n    bytes32 constant private FILE = \"TypedSignature\";\r\n\r\n    // prepended message with the length of the signed hash in decimal\r\n    bytes constant private PREPEND_DEC = \"\\x19Ethereum Signed Message:\\n32\";\r\n\r\n    // prepended message with the length of the signed hash in hexadecimal\r\n    bytes constant private PREPEND_HEX = \"\\x19Ethereum Signed Message:\\n\\x20\";\r\n\r\n    // Number of bytes in a typed signature\r\n    uint256 constant private NUM_SIGNATURE_BYTES = 66;\r\n\r\n    // ============ Enums ============\r\n\r\n    // Different RPC providers may implement signing methods differently, so we allow different\r\n    // signature types depending on the string prepended to a hash before it was signed.\r\n    enum SignatureType {\r\n        NoPrepend,   // No string was prepended.\r\n        Decimal,     // PREPEND_DEC was prepended.\r\n        Hexadecimal, // PREPEND_HEX was prepended.\r\n        Invalid      // Not a valid type. Used for bound-checking.\r\n    }\r\n\r\n    // ============ Functions ============\r\n\r\n    /**\r\n     * Gives the address of the signer of a hash. Also allows for the commonly prepended string of\r\n     * '\\x19Ethereum Signed Message:\\n' + message.length\r\n     *\r\n     * @param  hash               Hash that was signed (does not include prepended message)\r\n     * @param  signatureWithType  Type and ECDSA signature with structure: {32:r}{32:s}{1:v}{1:type}\r\n     * @return                    address of the signer of the hash\r\n     */\r\n    function recover(\r\n        bytes32 hash,\r\n        bytes memory signatureWithType\r\n    )\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        Require.that(\r\n            signatureWithType.length == NUM_SIGNATURE_BYTES,\r\n            FILE,\r\n            \"Invalid signature length\"\r\n        );\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        uint8 rawSigType;\r\n\r\n        /* solium-disable-next-line security/no-inline-assembly */\r\n        assembly {\r\n            r := mload(add(signatureWithType, 0x20))\r\n            s := mload(add(signatureWithType, 0x40))\r\n            let lastSlot := mload(add(signatureWithType, 0x60))\r\n            v := byte(0, lastSlot)\r\n            rawSigType := byte(1, lastSlot)\r\n        }\r\n\r\n        Require.that(\r\n            rawSigType < uint8(SignatureType.Invalid),\r\n            FILE,\r\n            \"Invalid signature type\"\r\n        );\r\n\r\n        SignatureType sigType = SignatureType(rawSigType);\r\n\r\n        bytes32 signedHash;\r\n        if (sigType == SignatureType.NoPrepend) {\r\n            signedHash = hash;\r\n        } else if (sigType == SignatureType.Decimal) {\r\n            signedHash = keccak256(abi.encodePacked(PREPEND_DEC, hash));\r\n        } else {\r\n            assert(sigType == SignatureType.Hexadecimal);\r\n            signedHash = keccak256(abi.encodePacked(PREPEND_HEX, hash));\r\n        }\r\n\r\n        return ecrecover(\r\n            signedHash,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/external/traders/CanonicalOrders.sol\r\n\r\n/**\r\n * @title CanonicalOrders\r\n * @author dYdX\r\n *\r\n * Allows for Canonical Orders to be used with dYdX\r\n */\r\ncontract CanonicalOrders is\r\n    Ownable,\r\n    OnlySolo,\r\n    IAutoTrader,\r\n    ICallee\r\n{\r\n    using Math for uint256;\r\n    using SafeMath for uint256;\r\n    using Types for Types.Par;\r\n    using Types for Types.Wei;\r\n\r\n    // ============ Constants ============\r\n\r\n    bytes32 constant private FILE = \"CanonicalOrders\";\r\n\r\n    // EIP191 header for EIP712 prefix\r\n    bytes2 constant private EIP191_HEADER = 0x1901;\r\n\r\n    // EIP712 Domain Name value\r\n    string constant private EIP712_DOMAIN_NAME = \"CanonicalOrders\";\r\n\r\n    // EIP712 Domain Version value\r\n    string constant private EIP712_DOMAIN_VERSION = \"1.0\";\r\n\r\n    // Hash of the EIP712 Domain Separator Schema\r\n    /* solium-disable-next-line indentation */\r\n    bytes32 constant private EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\r\n        \"EIP712Domain(\",\r\n        \"string name,\",\r\n        \"string version,\",\r\n        \"uint256 chainId,\",\r\n        \"address verifyingContract\",\r\n        \")\"\r\n    ));\r\n\r\n    // Hash of the EIP712 CanonicalOrder struct\r\n    /* solium-disable-next-line indentation */\r\n    bytes32 constant private EIP712_ORDER_STRUCT_SCHEMA_HASH = keccak256(abi.encodePacked(\r\n        \"CanonicalOrder(\",\r\n        \"bytes32 flags,\",\r\n        \"uint256 baseMarket,\",\r\n        \"uint256 quoteMarket,\",\r\n        \"uint256 amount,\",\r\n        \"uint256 limitPrice,\",\r\n        \"uint256 triggerPrice,\",\r\n        \"uint256 limitFee,\",\r\n        \"address makerAccountOwner,\",\r\n        \"uint256 makerAccountNumber,\",\r\n        \"uint256 expiration\",\r\n        \")\"\r\n    ));\r\n\r\n    // Number of bytes in an Order struct plus number of bytes in a FillArgs struct\r\n    uint256 constant private NUM_ORDER_AND_FILL_BYTES = 416;\r\n\r\n    // Number of bytes in a typed signature\r\n    uint256 constant private NUM_SIGNATURE_BYTES = 66;\r\n\r\n    // The number of decimal places of precision in the price ratio of a triggerPrice\r\n    uint256 constant private PRICE_BASE = 10 ** 18;\r\n\r\n    // Bitmasks for the order.flag argument\r\n    bytes32 constant private IS_BUY_FLAG = bytes32(uint256(1));\r\n    bytes32 constant private IS_DECREASE_ONLY_FLAG = bytes32(uint256(1 << 1));\r\n    bytes32 constant private IS_NEGATIVE_FEE_FLAG = bytes32(uint256(1 << 2));\r\n\r\n    // ============ Enums ============\r\n\r\n    enum OrderStatus {\r\n        Null,\r\n        Approved,\r\n        Canceled\r\n    }\r\n\r\n    enum CallFunctionType {\r\n        Approve,\r\n        Cancel,\r\n        SetFillArgs\r\n    }\r\n\r\n    // ============ Structs ============\r\n\r\n    struct Order {\r\n        bytes32 flags; // salt, negativeFee, decreaseOnly, isBuy\r\n        uint256 baseMarket;\r\n        uint256 quoteMarket;\r\n        uint256 amount;\r\n        uint256 limitPrice;\r\n        uint256 triggerPrice;\r\n        uint256 limitFee;\r\n        address makerAccountOwner;\r\n        uint256 makerAccountNumber;\r\n        uint256 expiration;\r\n    }\r\n\r\n    struct FillArgs {\r\n        uint256 price;\r\n        uint128 fee;\r\n        bool isNegativeFee;\r\n    }\r\n\r\n    struct OrderInfo {\r\n        Order order;\r\n        FillArgs fill;\r\n        bytes32 orderHash;\r\n    }\r\n\r\n    struct OrderQueryOutput {\r\n        OrderStatus orderStatus;\r\n        uint256 filledAmount;\r\n    }\r\n\r\n    // ============ Events ============\r\n\r\n    event LogContractStatusSet(\r\n        bool operational\r\n    );\r\n\r\n    event LogTakerSet(\r\n        address taker\r\n    );\r\n\r\n    event LogCanonicalOrderCanceled(\r\n        bytes32 indexed orderHash,\r\n        address indexed canceler,\r\n        uint256 baseMarket,\r\n        uint256 quoteMarket\r\n    );\r\n\r\n    event LogCanonicalOrderApproved(\r\n        bytes32 indexed orderHash,\r\n        address indexed approver,\r\n        uint256 baseMarket,\r\n        uint256 quoteMarket\r\n    );\r\n\r\n    event LogCanonicalOrderFilled(\r\n        bytes32 indexed orderHash,\r\n        address indexed orderMaker,\r\n        uint256 fillAmount,\r\n        uint256 totalFilledAmount,\r\n        bool isBuy,\r\n        FillArgs fill\r\n    );\r\n\r\n    // ============ Immutable Storage ============\r\n\r\n    // Hash of the EIP712 Domain Separator data\r\n    bytes32 public EIP712_DOMAIN_HASH;\r\n\r\n    // ============ Mutable Storage ============\r\n\r\n    // true if this contract can process orders\r\n    bool public g_isOperational;\r\n\r\n    // order hash => filled amount (in baseAmount)\r\n    mapping (bytes32 => uint256) public g_filledAmount;\r\n\r\n    // order hash => status\r\n    mapping (bytes32 => OrderStatus) public g_status;\r\n\r\n    // stored fillArgs\r\n    FillArgs public g_fillArgs;\r\n\r\n    // required taker address\r\n    address public g_taker;\r\n\r\n    // ============ Constructor ============\r\n\r\n    constructor (\r\n        address soloMargin,\r\n        address taker,\r\n        uint256 chainId\r\n    )\r\n        public\r\n        OnlySolo(soloMargin)\r\n    {\r\n        g_isOperational = true;\r\n        g_taker = taker;\r\n\r\n        /* solium-disable-next-line indentation */\r\n        EIP712_DOMAIN_HASH = keccak256(abi.encode(\r\n            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\r\n            keccak256(bytes(EIP712_DOMAIN_NAME)),\r\n            keccak256(bytes(EIP712_DOMAIN_VERSION)),\r\n            chainId,\r\n            address(this)\r\n        ));\r\n    }\r\n\r\n    // ============ Admin Functions ============\r\n\r\n    /**\r\n     * The owner can shut down the exchange.\r\n     */\r\n    function shutDown()\r\n        external\r\n        onlyOwner\r\n    {\r\n        g_isOperational = false;\r\n        emit LogContractStatusSet(false);\r\n    }\r\n\r\n    /**\r\n     * The owner can start back up the exchange.\r\n     */\r\n    function startUp()\r\n        external\r\n        onlyOwner\r\n    {\r\n        g_isOperational = true;\r\n        emit LogContractStatusSet(true);\r\n    }\r\n\r\n    /**\r\n     * The owner can set the taker address.\r\n     */\r\n    function setTakerAddress(\r\n        address taker\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        g_taker = taker;\r\n        emit LogTakerSet(taker);\r\n    }\r\n\r\n    // ============ External Functions ============\r\n\r\n    /**\r\n     * Cancels an order.\r\n     *\r\n     * @param  order  The order to cancel\r\n     */\r\n    function cancelOrder(\r\n        Order memory order\r\n    )\r\n        public\r\n    {\r\n        cancelOrderInternal(msg.sender, order);\r\n    }\r\n\r\n    /**\r\n     * Approves an order. Cannot already be canceled.\r\n     *\r\n     * @param  order  The order to approve\r\n     */\r\n    function approveOrder(\r\n        Order memory order\r\n    )\r\n        public\r\n    {\r\n        approveOrderInternal(msg.sender, order);\r\n    }\r\n\r\n    // ============ Only-Solo Functions ============\r\n\r\n    /**\r\n     * Allows traders to make trades approved by this smart contract. The active trader's account is\r\n     * the takerAccount and the passive account (for which this contract approves trades\r\n     * on-behalf-of) is the makerAccount.\r\n     *\r\n     * @param  inputMarketId   The market for which the trader specified the original amount\r\n     * @param  outputMarketId  The market for which the trader wants the resulting amount specified\r\n     * @param  makerAccount    The account for which this contract is making trades\r\n     * @param  takerAccount    The account requesting the trade\r\n     * @param  oldInputPar     The par balance of the makerAccount for inputMarketId pre-trade\r\n     * @param  newInputPar     The par balance of the makerAccount for inputMarketId post-trade\r\n     * @param  inputWei        The change in token amount for the makerAccount for the inputMarketId\r\n     * @param  data            Arbitrary data passed in by the trader\r\n     * @return                 The AssetAmount for the makerAccount for the outputMarketId\r\n     */\r\n    function getTradeCost(\r\n        uint256 inputMarketId,\r\n        uint256 outputMarketId,\r\n        Account.Info memory makerAccount,\r\n        Account.Info memory takerAccount,\r\n        Types.Par memory oldInputPar,\r\n        Types.Par memory newInputPar,\r\n        Types.Wei memory inputWei,\r\n        bytes memory data\r\n    )\r\n        public\r\n        onlySolo(msg.sender)\r\n        returns (Types.AssetAmount memory)\r\n    {\r\n        Require.that(\r\n            g_isOperational,\r\n            FILE,\r\n            \"Contract is not operational\"\r\n        );\r\n\r\n        OrderInfo memory orderInfo = getOrderInfo(data);\r\n\r\n        verifySignature(orderInfo, data);\r\n\r\n        verifyOrderInfo(\r\n            orderInfo,\r\n            makerAccount,\r\n            takerAccount,\r\n            inputMarketId,\r\n            outputMarketId,\r\n            inputWei\r\n        );\r\n\r\n        Types.AssetAmount memory assetAmount = getOutputAssetAmount(\r\n            inputMarketId,\r\n            outputMarketId,\r\n            inputWei,\r\n            orderInfo\r\n        );\r\n\r\n        if (isDecreaseOnly(orderInfo.order)) {\r\n            verifyDecreaseOnly(\r\n                oldInputPar,\r\n                newInputPar,\r\n                assetAmount,\r\n                makerAccount,\r\n                outputMarketId\r\n            );\r\n        }\r\n\r\n        return assetAmount;\r\n    }\r\n\r\n    /**\r\n     * Allows users to send this contract arbitrary data.\r\n     *\r\n     *  param  sender       (unused)\r\n     * @param  accountInfo  The account from which the data is being sent\r\n     * @param  data         Arbitrary data given by the sender\r\n     */\r\n    function callFunction(\r\n        address /* sender */,\r\n        Account.Info memory accountInfo,\r\n        bytes memory data\r\n    )\r\n        public\r\n        onlySolo(msg.sender)\r\n    {\r\n        CallFunctionType cft = abi.decode(data, (CallFunctionType));\r\n\r\n        if (cft == CallFunctionType.SetFillArgs) {\r\n            FillArgs memory fillArgs;\r\n            (cft, fillArgs) = abi.decode(data, (CallFunctionType, FillArgs));\r\n            g_fillArgs = fillArgs;\r\n        } else {\r\n            Order memory order;\r\n            (cft, order) = abi.decode(data, (CallFunctionType, Order));\r\n            if (cft == CallFunctionType.Approve) {\r\n                approveOrderInternal(accountInfo.owner, order);\r\n            } else {\r\n                assert(cft == CallFunctionType.Cancel);\r\n                cancelOrderInternal(accountInfo.owner, order);\r\n            }\r\n        }\r\n    }\r\n\r\n    // ============ Getters ============\r\n\r\n    /**\r\n     * Returns the status and the filled amount of several orders.\r\n     */\r\n    function getOrderStates(\r\n        bytes32[] memory orderHashes\r\n    )\r\n        public\r\n        view\r\n        returns(OrderQueryOutput[] memory)\r\n    {\r\n        uint256 numOrders = orderHashes.length;\r\n        OrderQueryOutput[] memory output = new OrderQueryOutput[](numOrders);\r\n\r\n        // for each order\r\n        for (uint256 i = 0; i < numOrders; i++) {\r\n            bytes32 orderHash = orderHashes[i];\r\n            output[i] = OrderQueryOutput({\r\n                orderStatus: g_status[orderHash],\r\n                filledAmount: g_filledAmount[orderHash]\r\n            });\r\n        }\r\n        return output;\r\n    }\r\n\r\n    // ============ Private Storage Functions ============\r\n\r\n    /**\r\n     * Cancels an order as long as it is not already canceled.\r\n     */\r\n    function cancelOrderInternal(\r\n        address canceler,\r\n        Order memory order\r\n    )\r\n        private\r\n    {\r\n        Require.that(\r\n            canceler == order.makerAccountOwner,\r\n            FILE,\r\n            \"Canceler must be maker\"\r\n        );\r\n        bytes32 orderHash = getOrderHash(order);\r\n        g_status[orderHash] = OrderStatus.Canceled;\r\n        emit LogCanonicalOrderCanceled(\r\n            orderHash,\r\n            canceler,\r\n            order.baseMarket,\r\n            order.quoteMarket\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Approves an order as long as it is not already approved or canceled.\r\n     */\r\n    function approveOrderInternal(\r\n        address approver,\r\n        Order memory order\r\n    )\r\n        private\r\n    {\r\n        Require.that(\r\n            approver == order.makerAccountOwner,\r\n            FILE,\r\n            \"Approver must be maker\"\r\n        );\r\n        bytes32 orderHash = getOrderHash(order);\r\n        Require.that(\r\n            g_status[orderHash] != OrderStatus.Canceled,\r\n            FILE,\r\n            \"Cannot approve canceled order\",\r\n            orderHash\r\n        );\r\n        g_status[orderHash] = OrderStatus.Approved;\r\n        emit LogCanonicalOrderApproved(\r\n            orderHash,\r\n            approver,\r\n            order.baseMarket,\r\n            order.quoteMarket\r\n        );\r\n    }\r\n\r\n    // ============ Private Helper Functions ============\r\n\r\n    /**\r\n     * Parses the order, verifies that it is not expired or canceled, and verifies the signature.\r\n     */\r\n    function getOrderInfo(\r\n        bytes memory data\r\n    )\r\n        private\r\n        returns (OrderInfo memory)\r\n    {\r\n        Require.that(\r\n            (\r\n                data.length == NUM_ORDER_AND_FILL_BYTES ||\r\n                data.length == NUM_ORDER_AND_FILL_BYTES + NUM_SIGNATURE_BYTES\r\n            ),\r\n            FILE,\r\n            \"Cannot parse order from data\"\r\n        );\r\n\r\n        // load orderInfo from calldata\r\n        OrderInfo memory orderInfo;\r\n        (\r\n            orderInfo.order,\r\n            orderInfo.fill\r\n        ) = abi.decode(data, (Order, FillArgs));\r\n\r\n        // load fillArgs from storage if price is zero\r\n        if (orderInfo.fill.price == 0) {\r\n            orderInfo.fill = g_fillArgs;\r\n            g_fillArgs = FillArgs({\r\n                price: 0,\r\n                fee: 0,\r\n                isNegativeFee: false\r\n            });\r\n        }\r\n        Require.that(\r\n            orderInfo.fill.price != 0,\r\n            FILE,\r\n            \"FillArgs loaded price is zero\"\r\n        );\r\n\r\n        orderInfo.orderHash = getOrderHash(orderInfo.order);\r\n\r\n        return orderInfo;\r\n    }\r\n\r\n    function verifySignature(\r\n        OrderInfo memory orderInfo,\r\n        bytes memory data\r\n    )\r\n        private\r\n        view\r\n    {\r\n        OrderStatus orderStatus = g_status[orderInfo.orderHash];\r\n\r\n        // verify valid signature or is pre-approved\r\n        if (orderStatus == OrderStatus.Null) {\r\n            bytes memory signature = parseSignature(data);\r\n            address signer = TypedSignature.recover(orderInfo.orderHash, signature);\r\n            Require.that(\r\n                orderInfo.order.makerAccountOwner == signer,\r\n                FILE,\r\n                \"Order invalid signature\",\r\n                orderInfo.orderHash\r\n            );\r\n        } else {\r\n            Require.that(\r\n                orderStatus != OrderStatus.Canceled,\r\n                FILE,\r\n                \"Order canceled\",\r\n                orderInfo.orderHash\r\n            );\r\n            assert(orderStatus == OrderStatus.Approved);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Verifies that the order is still fillable for the particular accounts and markets specified.\r\n     */\r\n    function verifyOrderInfo(\r\n        OrderInfo memory orderInfo,\r\n        Account.Info memory makerAccount,\r\n        Account.Info memory takerAccount,\r\n        uint256 inputMarketId,\r\n        uint256 outputMarketId,\r\n        Types.Wei memory inputWei\r\n    )\r\n        private\r\n        view\r\n    {\r\n        // verify fill price\r\n        FillArgs memory fill = orderInfo.fill;\r\n        bool validPrice = isBuy(orderInfo.order)\r\n            ? fill.price <= orderInfo.order.limitPrice\r\n            : fill.price >= orderInfo.order.limitPrice;\r\n        Require.that(\r\n            validPrice,\r\n            FILE,\r\n            \"Fill invalid price\"\r\n        );\r\n\r\n        // verify fill fee\r\n        bool validFee = isNegativeLimitFee(orderInfo.order)\r\n            ? (fill.fee >= orderInfo.order.limitFee) && fill.isNegativeFee\r\n            : (fill.fee <= orderInfo.order.limitFee) || fill.isNegativeFee;\r\n        Require.that(\r\n            validFee,\r\n            FILE,\r\n            \"Fill invalid fee\"\r\n        );\r\n\r\n        // verify triggerPrice\r\n        if (orderInfo.order.triggerPrice > 0) {\r\n            uint256 currentPrice = getCurrentPrice(\r\n                orderInfo.order.baseMarket,\r\n                orderInfo.order.quoteMarket\r\n            );\r\n            Require.that(\r\n                isBuy(orderInfo.order)\r\n                    ? currentPrice >= orderInfo.order.triggerPrice\r\n                    : currentPrice <= orderInfo.order.triggerPrice,\r\n                FILE,\r\n                \"Order triggerPrice not triggered\",\r\n                currentPrice\r\n            );\r\n        }\r\n\r\n        // verify expriy\r\n        Require.that(\r\n            orderInfo.order.expiration == 0 || orderInfo.order.expiration >= block.timestamp,\r\n            FILE,\r\n            \"Order expired\",\r\n            orderInfo.orderHash\r\n        );\r\n\r\n        // verify maker\r\n        Require.that(\r\n            makerAccount.owner == orderInfo.order.makerAccountOwner &&\r\n            makerAccount.number == orderInfo.order.makerAccountNumber,\r\n            FILE,\r\n            \"Order maker account mismatch\",\r\n            orderInfo.orderHash\r\n        );\r\n\r\n        // verify taker\r\n        Require.that(\r\n            takerAccount.owner == g_taker,\r\n            FILE,\r\n            \"Order taker mismatch\",\r\n            orderInfo.orderHash\r\n        );\r\n\r\n        // verify markets\r\n        Require.that(\r\n            (\r\n                orderInfo.order.baseMarket == outputMarketId &&\r\n                orderInfo.order.quoteMarket == inputMarketId\r\n            ) || (\r\n                orderInfo.order.quoteMarket == outputMarketId &&\r\n                orderInfo.order.baseMarket == inputMarketId\r\n            ),\r\n            FILE,\r\n            \"Market mismatch\",\r\n            orderInfo.orderHash\r\n        );\r\n\r\n        // verify inputWei is non-zero\r\n        Require.that(\r\n            !inputWei.isZero(),\r\n            FILE,\r\n            \"InputWei is zero\",\r\n            orderInfo.orderHash\r\n        );\r\n\r\n        // verify inputWei is positive if-and-only-if:\r\n        // 1) inputMarket is the baseMarket and the order is a buy order\r\n        // 2) inputMarket is the quoteMarket and the order is a sell order\r\n        Require.that(\r\n            inputWei.sign ==\r\n                ((orderInfo.order.baseMarket == inputMarketId) == isBuy(orderInfo.order)),\r\n            FILE,\r\n            \"InputWei sign mismatch\",\r\n            orderInfo.orderHash\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Verifies that the order is decreasing the size of the maker's position.\r\n     */\r\n    function verifyDecreaseOnly(\r\n        Types.Par memory oldInputPar,\r\n        Types.Par memory newInputPar,\r\n        Types.AssetAmount memory assetAmount,\r\n        Account.Info memory makerAccount,\r\n        uint256 outputMarketId\r\n    )\r\n        private\r\n        view\r\n    {\r\n        // verify that the balance of inputMarketId is not increased\r\n        Require.that(\r\n            newInputPar.isZero()\r\n            || (newInputPar.value <= oldInputPar.value && newInputPar.sign == oldInputPar.sign),\r\n            FILE,\r\n            \"inputMarket not decreased\"\r\n        );\r\n\r\n        // verify that the balance of outputMarketId is not increased\r\n        Types.Wei memory oldOutputWei = SOLO_MARGIN.getAccountWei(makerAccount, outputMarketId);\r\n        Require.that(\r\n            assetAmount.value == 0\r\n            || (assetAmount.value <= oldOutputWei.value && assetAmount.sign != oldOutputWei.sign),\r\n            FILE,\r\n            \"outputMarket not decreased\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns the AssetAmount for the outputMarketId given the order and the inputs. Updates the\r\n     * filled amount of the order in storage.\r\n     */\r\n    function getOutputAssetAmount(\r\n        uint256 inputMarketId,\r\n        uint256 outputMarketId,\r\n        Types.Wei memory inputWei,\r\n        OrderInfo memory orderInfo\r\n    )\r\n        private\r\n        returns (Types.AssetAmount memory)\r\n    {\r\n        uint256 fee = orderInfo.fill.price.getPartial(orderInfo.fill.fee, PRICE_BASE);\r\n        uint256 adjustedPrice = (isBuy(orderInfo.order) == orderInfo.fill.isNegativeFee)\r\n            ? orderInfo.fill.price.sub(fee)\r\n            : orderInfo.fill.price.add(fee);\r\n\r\n        uint256 outputAmount;\r\n        uint256 fillAmount;\r\n        if (orderInfo.order.quoteMarket == inputMarketId) {\r\n            outputAmount = inputWei.value.getPartial(PRICE_BASE, adjustedPrice);\r\n            fillAmount = outputAmount;\r\n        } else {\r\n            assert(orderInfo.order.quoteMarket == outputMarketId);\r\n            outputAmount = inputWei.value.getPartial(adjustedPrice, PRICE_BASE);\r\n            fillAmount = inputWei.value;\r\n        }\r\n\r\n        updateFilledAmount(orderInfo, fillAmount);\r\n\r\n        return Types.AssetAmount({\r\n            sign: !inputWei.sign,\r\n            denomination: Types.AssetDenomination.Wei,\r\n            ref: Types.AssetReference.Delta,\r\n            value: outputAmount\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Increases the stored filled amount of the order by fillAmount.\r\n     * Returns the new total filled amount.\r\n     */\r\n    function updateFilledAmount(\r\n        OrderInfo memory orderInfo,\r\n        uint256 fillAmount\r\n    )\r\n        private\r\n    {\r\n        uint256 oldFilledAmount = g_filledAmount[orderInfo.orderHash];\r\n        uint256 totalFilledAmount = oldFilledAmount.add(fillAmount);\r\n        Require.that(\r\n            totalFilledAmount <= orderInfo.order.amount,\r\n            FILE,\r\n            \"Cannot overfill order\",\r\n            orderInfo.orderHash,\r\n            oldFilledAmount,\r\n            fillAmount\r\n        );\r\n\r\n        g_filledAmount[orderInfo.orderHash] = totalFilledAmount;\r\n\r\n        emit LogCanonicalOrderFilled(\r\n            orderInfo.orderHash,\r\n            orderInfo.order.makerAccountOwner,\r\n            fillAmount,\r\n            totalFilledAmount,\r\n            isBuy(orderInfo.order),\r\n            orderInfo.fill\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns the current price of baseMarket divided by the current price of quoteMarket. This\r\n     * value is multiplied by 10^18.\r\n     */\r\n    function getCurrentPrice(\r\n        uint256 baseMarket,\r\n        uint256 quoteMarket\r\n    )\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Monetary.Price memory basePrice = SOLO_MARGIN.getMarketPrice(baseMarket);\r\n        Monetary.Price memory quotePrice = SOLO_MARGIN.getMarketPrice(quoteMarket);\r\n        return basePrice.value.mul(PRICE_BASE).div(quotePrice.value);\r\n    }\r\n\r\n    // ============ Private Parsing Functions ============\r\n\r\n    /**\r\n     * Returns the EIP712 hash of an order.\r\n     */\r\n    function getOrderHash(\r\n        Order memory order\r\n    )\r\n        private\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        // compute the overall signed struct hash\r\n        /* solium-disable-next-line indentation */\r\n        bytes32 structHash = keccak256(abi.encode(\r\n            EIP712_ORDER_STRUCT_SCHEMA_HASH,\r\n            order\r\n        ));\r\n\r\n        // compute eip712 compliant hash\r\n        /* solium-disable-next-line indentation */\r\n        return keccak256(abi.encodePacked(\r\n            EIP191_HEADER,\r\n            EIP712_DOMAIN_HASH,\r\n            structHash\r\n        ));\r\n    }\r\n\r\n    /**\r\n     * Parses out a signature from call data.\r\n     */\r\n    function parseSignature(\r\n        bytes memory data\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        Require.that(\r\n            data.length == NUM_ORDER_AND_FILL_BYTES + NUM_SIGNATURE_BYTES,\r\n            FILE,\r\n            \"Cannot parse signature from data\"\r\n        );\r\n\r\n        bytes memory signature = new bytes(NUM_SIGNATURE_BYTES);\r\n\r\n        uint256 sigOffset = NUM_ORDER_AND_FILL_BYTES;\r\n        /* solium-disable-next-line security/no-inline-assembly */\r\n        assembly {\r\n            let sigStart := add(data, sigOffset)\r\n            mstore(add(signature, 0x020), mload(add(sigStart, 0x20)))\r\n            mstore(add(signature, 0x040), mload(add(sigStart, 0x40)))\r\n            mstore(add(signature, 0x042), mload(add(sigStart, 0x42)))\r\n        }\r\n\r\n        return signature;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the order is a buy order.\r\n     */\r\n    function isBuy(\r\n        Order memory order\r\n    )\r\n        private\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return (order.flags & IS_BUY_FLAG) != bytes32(0);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the order is a decrease-only order.\r\n     */\r\n    function isDecreaseOnly(\r\n        Order memory order\r\n    )\r\n        private\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return (order.flags & IS_DECREASE_ONLY_FLAG) != bytes32(0);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the order's limitFee is negative.\r\n     */\r\n    function isNegativeLimitFee(\r\n        Order memory order\r\n    )\r\n        private\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return (order.flags & IS_NEGATIVE_FEE_FLAG) != bytes32(0);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"g_taker\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"g_fillArgs\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint128\"},{\"name\":\"isNegativeFee\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"shutDown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SOLO_MARGIN\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startUp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"inputMarketId\",\"type\":\"uint256\"},{\"name\":\"outputMarketId\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"makerAccount\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"takerAccount\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"sign\",\"type\":\"bool\"},{\"name\":\"value\",\"type\":\"uint128\"}],\"name\":\"oldInputPar\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"sign\",\"type\":\"bool\"},{\"name\":\"value\",\"type\":\"uint128\"}],\"name\":\"newInputPar\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"sign\",\"type\":\"bool\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"inputWei\",\"type\":\"tuple\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"getTradeCost\",\"outputs\":[{\"components\":[{\"name\":\"sign\",\"type\":\"bool\"},{\"name\":\"denomination\",\"type\":\"uint8\"},{\"name\":\"ref\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"flags\",\"type\":\"bytes32\"},{\"name\":\"baseMarket\",\"type\":\"uint256\"},{\"name\":\"quoteMarket\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"limitPrice\",\"type\":\"uint256\"},{\"name\":\"triggerPrice\",\"type\":\"uint256\"},{\"name\":\"limitFee\",\"type\":\"uint256\"},{\"name\":\"makerAccountOwner\",\"type\":\"address\"},{\"name\":\"makerAccountNumber\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"accountInfo\",\"type\":\"tuple\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"callFunction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderHashes\",\"type\":\"bytes32[]\"}],\"name\":\"getOrderStates\",\"outputs\":[{\"components\":[{\"name\":\"orderStatus\",\"type\":\"uint8\"},{\"name\":\"filledAmount\",\"type\":\"uint256\"}],\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"g_status\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"flags\",\"type\":\"bytes32\"},{\"name\":\"baseMarket\",\"type\":\"uint256\"},{\"name\":\"quoteMarket\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"limitPrice\",\"type\":\"uint256\"},{\"name\":\"triggerPrice\",\"type\":\"uint256\"},{\"name\":\"limitFee\",\"type\":\"uint256\"},{\"name\":\"makerAccountOwner\",\"type\":\"address\"},{\"name\":\"makerAccountNumber\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"approveOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"g_filledAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EIP712_DOMAIN_HASH\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"taker\",\"type\":\"address\"}],\"name\":\"setTakerAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"g_isOperational\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"soloMargin\",\"type\":\"address\"},{\"name\":\"taker\",\"type\":\"address\"},{\"name\":\"chainId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operational\",\"type\":\"bool\"}],\"name\":\"LogContractStatusSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"taker\",\"type\":\"address\"}],\"name\":\"LogTakerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"canceler\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"baseMarket\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"quoteMarket\",\"type\":\"uint256\"}],\"name\":\"LogCanonicalOrderCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"approver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"baseMarket\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"quoteMarket\",\"type\":\"uint256\"}],\"name\":\"LogCanonicalOrderApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"orderMaker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fillAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalFilledAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isBuy\",\"type\":\"bool\"},{\"components\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint128\"},{\"name\":\"isNegativeFee\",\"type\":\"bool\"}],\"indexed\":false,\"name\":\"fill\",\"type\":\"tuple\"}],\"name\":\"LogCanonicalOrderFilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CanonicalOrders","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"0000000000000000000000001e0447b19bb6ecfdae1e4ae1694b0c3659614e4e000000000000000000000000f809e07870dca762b9536d61a4fbef1a171780920000000000000000000000000000000000000000000000000000000000000001","Library":"","LicenseType":"None","SwarmSource":"bzzr://9f68f84473591abe23935913c661689e575c712e3cf6f80558ee2096674d1b36"}]}