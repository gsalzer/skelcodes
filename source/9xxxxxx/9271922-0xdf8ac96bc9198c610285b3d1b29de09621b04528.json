{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.4;\r\n\r\ncontract Owned {\r\n\r\n    // The owner\r\n    address public owner;\r\n\r\n    event OwnerChanged(address indexed _newOwner);\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Must be owner\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Lets the owner transfer ownership of the contract to a new owner.\r\n     * @param _newOwner The new owner.\r\n     */\r\n    function changeOwner(address _newOwner) external onlyOwner {\r\n        require(_newOwner != address(0), \"Address must not be null\");\r\n        owner = _newOwner;\r\n        emit OwnerChanged(_newOwner);\r\n    }\r\n}\r\n\r\ncontract LogicManager is Owned {\r\n\r\n    event UpdateLogicSubmitted(address indexed logic, bool value);\r\n    event UpdateLogicCancelled(address indexed logic);\r\n    event UpdateLogicDone(address indexed logic, bool value);\r\n\r\n    struct pending {\r\n        bool value;\r\n        uint dueTime;\r\n    }\r\n\r\n    // The authorized logic modules\r\n    mapping (address => bool) public authorized;\r\n\r\n    /*\r\n    array\r\n    index 0: AccountLogic address\r\n          1: TransferLogic address\r\n          2: DualsigsLogic address\r\n          3: DappLogic address\r\n          4: ...\r\n     */\r\n    address[] public authorizedLogics;\r\n\r\n    // updated logics and their due time of becoming effective\r\n    mapping (address => pending) public pendingLogics;\r\n\r\n    // pending time before updated logics take effect\r\n    struct pendingTime {\r\n        uint curPendingTime;\r\n        uint nextPendingTime;\r\n        uint dueTime;\r\n    }\r\n\r\n    pendingTime public pt;\r\n\r\n    // how many authorized logics\r\n    uint public logicCount;\r\n\r\n    constructor(address[] memory _initialLogics, uint256 _pendingTime) public\r\n    {\r\n        for (uint i = 0; i < _initialLogics.length; i++) {\r\n            address logic = _initialLogics[i];\r\n            authorized[logic] = true;\r\n            logicCount += 1;\r\n        }\r\n        authorizedLogics = _initialLogics;\r\n\r\n        pt.curPendingTime = _pendingTime;\r\n        pt.nextPendingTime = _pendingTime;\r\n        pt.dueTime = now;\r\n    }\r\n\r\n    function submitUpdatePendingTime(uint _pendingTime) external onlyOwner {\r\n        pt.nextPendingTime = _pendingTime;\r\n        pt.dueTime = pt.curPendingTime + now;\r\n    }\r\n\r\n    function triggerUpdatePendingTime() external {\r\n        require(pt.dueTime <= now, \"too early to trigger updatePendingTime\");\r\n        pt.curPendingTime = pt.nextPendingTime;\r\n    }\r\n\r\n    function isAuthorized(address _logic) external view returns (bool) {\r\n        return authorized[_logic];\r\n    }\r\n\r\n    function getAuthorizedLogics() external view returns (address[] memory) {\r\n        return authorizedLogics;\r\n    }\r\n\r\n    function submitUpdate(address _logic, bool _value) external onlyOwner {\r\n        pending storage p = pendingLogics[_logic];\r\n        p.value = _value;\r\n        p.dueTime = now + pt.curPendingTime;\r\n        emit UpdateLogicSubmitted(_logic, _value);\r\n    }\r\n\r\n    function cancelUpdate(address _logic) external onlyOwner {\r\n        delete pendingLogics[_logic];\r\n        emit UpdateLogicCancelled(_logic);\r\n    }\r\n\r\n    function triggerUpdateLogic(address _logic) external {\r\n        pending memory p = pendingLogics[_logic];\r\n        require(p.dueTime > 0, \"pending logic not found\");\r\n        require(p.dueTime <= now, \"too early to trigger updateLogic\");\r\n        updateLogic(_logic, p.value);\r\n        delete pendingLogics[_logic];\r\n    }\r\n\r\n    function updateLogic(address _logic, bool _value) internal {\r\n        if (authorized[_logic] != _value) {\r\n            if(_value) {\r\n                logicCount += 1;\r\n                authorized[_logic] = true;\r\n                authorizedLogics.push(_logic);\r\n            }\r\n            else {\r\n                logicCount -= 1;\r\n                require(logicCount > 0, \"must have at least one logic module\");\r\n                delete authorized[_logic];\r\n                removeLogic(_logic);\r\n            }\r\n            emit UpdateLogicDone(_logic, _value);\r\n        }\r\n    }\r\n\r\n    function removeLogic(address _logic) internal {\r\n        uint len = authorizedLogics.length;\r\n        address lastLogic = authorizedLogics[len - 1];\r\n        if (_logic != lastLogic) {\r\n            for (uint i = 0; i < len; i++) {\r\n                 if (_logic == authorizedLogics[i]) {\r\n                     authorizedLogics[i] = lastLogic;\r\n                     break;\r\n                 }\r\n            }\r\n        }\r\n        authorizedLogics.length--;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_pendingTime\",\"type\":\"uint256\"}],\"name\":\"submitUpdatePendingTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_logic\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"submitUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingLogics\",\"outputs\":[{\"name\":\"value\",\"type\":\"bool\"},{\"name\":\"dueTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"triggerUpdatePendingTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAuthorizedLogics\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"logicCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pt\",\"outputs\":[{\"name\":\"curPendingTime\",\"type\":\"uint256\"},{\"name\":\"nextPendingTime\",\"type\":\"uint256\"},{\"name\":\"dueTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_logic\",\"type\":\"address\"}],\"name\":\"cancelUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"authorizedLogics\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_logic\",\"type\":\"address\"}],\"name\":\"triggerUpdateLogic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_logic\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_initialLogics\",\"type\":\"address[]\"},{\"name\":\"_pendingTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"logic\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"UpdateLogicSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"logic\",\"type\":\"address\"}],\"name\":\"UpdateLogicCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"logic\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"UpdateLogicDone\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"}]","ContractName":"LogicManager","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000000000400000000000000000000000052dab11c6029862ebf1e65a4d5c30641f5fbd9570000000000000000000000001c2349acbb7f83d07577692c75b6d7654899bf10000000000000000000000000039aa54febe98aaadb91ae2b1db7aa00a82f85710000000000000000000000002cd784297b10a53003092d6110c83c4092b2fbd2","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://714c85ff2e33b84b9be095b3ec67a480dc131346a86f58ae9d3e2f774e8dc1cf"}]}