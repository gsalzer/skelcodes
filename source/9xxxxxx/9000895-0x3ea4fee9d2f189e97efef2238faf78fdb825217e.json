{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.10;\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract UniswapExchangeInterface {\r\n    // Address of ERC20 token sold on this exchange\r\n    function tokenAddress() external view returns (address token);\r\n    // Address of Uniswap Factory\r\n    function factoryAddress() external view returns (address factory);\r\n    // Provide Liquidity\r\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\r\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\r\n    // Get Prices\r\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\r\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\r\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\r\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\r\n    // Trade ETH to ERC20\r\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);\r\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\r\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\r\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\r\n    // Trade ERC20 to ETH\r\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\r\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\r\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\r\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\r\n    // Trade ERC20 to ERC20\r\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\r\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\r\n    // Trade ERC20 to Custom Pool\r\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\r\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\r\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\r\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\r\n    // ERC20 comaptibility for liquidity tokens\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public decimals;\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    // Never use\r\n    function setup(address token_addr) external;\r\n}\r\n\r\ninterface KyberNetworkProxyInterface {\r\n    function maxGasPrice() external view returns(uint);\r\n    function getUserCapInWei(address user) external view returns(uint);\r\n    function getUserCapInTokenWei(address user, IERC20 token) external view returns(uint);\r\n    function enabled() external view returns(bool);\r\n    function info(bytes32 id) external view returns(uint);\r\n\r\n    function getExpectedRate(IERC20 src, IERC20 dest, uint srcQty) external view returns (uint expectedRate, uint slippageRate);\r\n\r\n    function tradeWithHint(IERC20 src, uint srcAmount, IERC20 dest, address destAddress, uint maxDestAmount, uint minConversionRate, address walletId, bytes calldata hint) external payable returns(uint);\r\n\r\n    function swapEtherToToken(IERC20 token, uint minRate) external payable returns (uint);\r\n\r\n    function swapTokenToEther(IERC20 token, uint tokenQty, uint minRate) external returns (uint);\r\n}\r\n\r\ninterface OrFeedInterface {\r\n    function getExchangeRate ( string calldata fromSymbol, string calldata toSymbol, string calldata venue, uint256 amount ) external view returns ( uint256 );\r\n    function getTokenDecimalCount ( address tokenAddress ) external view returns ( uint256 );\r\n    function getTokenAddress ( string calldata symbol ) external view returns ( address );\r\n    function getSynthBytes32 ( string calldata symbol ) external view returns ( bytes32 );\r\n    function getForexAddress ( string calldata symbol ) external view returns ( address );\r\n}\r\n\r\ncontract Ourbitrage {\r\n    uint256 internal constant _DEFAULT_MAX_RATE = 8000000000000000000000000000000000000000000000000000000000000000;\r\n    uint256 internal constant _ETH_UNIT = 1000000000000000000;\r\n    IERC20 internal constant _ETH_TOKEN_ADDRESS = IERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n    bytes internal constant _PERM_HINT = \"PERM\";\r\n\r\n    UniswapExchangeInterface internal _uniswap;\r\n    KyberNetworkProxyInterface internal _kyber;\r\n    OrFeedInterface internal _orfeed;\r\n\r\n    address private _owner;\r\n    address internal _fundingToken; // Contract Address of Token to Fund Arbitrage with (SAI/DAI)\r\n    address internal _feeCollector;\r\n//    uint internal _maxTokensToSwapPerTx;\r\n\r\n    event Arbitrage(address token, uint profit);\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    //\r\n    // Initialize\r\n    //\r\n    constructor() public {\r\n        _owner = msg.sender;\r\n\r\n        _kyber = KyberNetworkProxyInterface(0x818E6FECD516Ecc3849DAf6845e3EC868087B755);\r\n        _orfeed = OrFeedInterface(0x3c1935Ebe06Ca18964A5B49B8Cd55A4A71081DE2);\r\n    }\r\n\r\n    function () external payable  {}\r\n\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n\r\n\r\n\r\n    function getKyberBuyEthPrice() public view returns (uint256){\r\n        uint256 currentPrice =  _orfeed.getExchangeRate(\"ETH\", \"SAI\", \"BUY-KYBER-EXCHANGE\", _ETH_UNIT);\r\n        return currentPrice;\r\n    }\r\n    function getKyberSellEthPrice() public view returns (uint256){\r\n        uint256 currentPrice =  _orfeed.getExchangeRate(\"ETH\", \"SAI\", \"SELL-KYBER-EXCHANGE\", _ETH_UNIT);\r\n        return currentPrice;\r\n    }\r\n\r\n    function getUniswapBuyEthPrice() public view returns (uint256){\r\n        uint256 currentPrice =  _orfeed.getExchangeRate(\"ETH\", \"SAI\", \"BUY-UNISWAP-EXCHANGE\", _ETH_UNIT);\r\n        return currentPrice;\r\n    }\r\n    function getUniswapSellEthPrice() public view returns (uint256){\r\n        uint256 currentPrice =  _orfeed.getExchangeRate(\"ETH\", \"SAI\", \"SELL-UNISWAP-EXCHANGE\", _ETH_UNIT);\r\n        return currentPrice;\r\n    }\r\n\r\n\r\n\r\n    function getPrice(string memory from, string memory to, string memory venue) public view returns (uint256) {\r\n        uint256 currentPrice = _orfeed.getExchangeRate(from, to, venue, _ETH_UNIT);\r\n        return currentPrice;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n//    function getKyberBuyPrice(string memory tokenSymbol) public view returns (uint256) {\r\n//        return _orfeed.getExchangeRate(\"ETH\", tokenSymbol, \"BUY-KYBER-EXCHANGE\", 1 ether);\r\n//    }\r\n//\r\n//    function getKyberSellPrice(string memory tokenSymbol) public view returns (uint256) {\r\n//        require(address(_orfeed) != address(0), \"OrFeed Interface has not been set\");\r\n//        return _orfeed.getExchangeRate(\"ETH\", tokenSymbol, \"SELL-KYBER-EXCHANGE\", 1 ether);\r\n//    }\r\n//\r\n//    function getUniswapBuyPrice(string memory tokenSymbol) public view returns (uint256) {\r\n//        require(address(_orfeed) != address(0), \"OrFeed Interface has not been set\");\r\n//        return _orfeed.getExchangeRate(\"ETH\", tokenSymbol, \"BUY-UNISWAP-EXCHANGE\", 1 ether);\r\n//    }\r\n//\r\n//    function getUniswapSellPrice(string memory tokenSymbol) public view returns (uint256) {\r\n//        require(address(_orfeed) != address(0), \"OrFeed Interface has not been set\");\r\n//        return _orfeed.getExchangeRate(\"ETH\", tokenSymbol, \"SELL-UNISWAP-EXCHANGE\", 1 ether);\r\n//    }\r\n\r\n    function getExpectedRate(uint tokenAmount) public view returns (uint256 minRate) {\r\n        IERC20 token = IERC20(_fundingToken);\r\n        (, minRate) = _kyber.getExpectedRate(token, _ETH_TOKEN_ADDRESS, tokenAmount);\r\n    }\r\n\r\n    function getEthBalance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function getFundingTokenAddress() public view returns (address) {\r\n        return _fundingToken;\r\n    }\r\n\r\n    function getFundingTokenBalance() public view returns (uint256) {\r\n        address ourbitrage = address(this);\r\n        IERC20 token = IERC20(_fundingToken);\r\n        return token.balanceOf(ourbitrage);\r\n    }\r\n\r\n    //\r\n    // Only Owner\r\n    //\r\n\r\n    function withdrawAll() public onlyOwner {\r\n        _withdrawETH(msg.sender);\r\n        _withdrawToken(msg.sender);\r\n    }\r\n\r\n    function withdrawETH() public onlyOwner {\r\n        _withdrawETH(msg.sender);\r\n    }\r\n\r\n    function withdrawToken() public onlyOwner {\r\n        _withdrawToken(msg.sender);\r\n    }\r\n\r\n    function setKyberNetworkProxyInterface(KyberNetworkProxyInterface kyber) public onlyOwner {\r\n        require(address(kyber) != address(0), \"Invalid KyberNetworkProxyInterface address\");\r\n        _kyber = KyberNetworkProxyInterface(kyber);\r\n    }\r\n\r\n    function setOrFeedInterface(OrFeedInterface orfeed) public onlyOwner {\r\n        require(address(orfeed) != address(0), \"Invalid OrFeedInterface address\");\r\n        _orfeed = OrFeedInterface(orfeed);\r\n    }\r\n\r\n    function setFeeCollector(address feeCollector) public onlyOwner {\r\n        require(address(feeCollector) != address(0), \"Invalid Fee Collector address\");\r\n        _feeCollector = feeCollector;\r\n    }\r\n\r\n//    function setupFundingToken(address tokenAddress, address uniswapExchangeAddress, uint maxSwapAmount) public onlyOwner {\r\n    function setupFundingToken(address tokenAddress, address uniswapExchangeAddress) public onlyOwner {\r\n        // Check for existing funds in contract\r\n        if (_fundingToken != address(0)) {\r\n            address ourbitrage = address(this);\r\n            IERC20 oldToken = IERC20(_fundingToken);\r\n            uint256 oldTokenBalance = oldToken.balanceOf(ourbitrage);\r\n            require(oldTokenBalance == 0, \"You have an existing token balance\");\r\n        }\r\n\r\n        // Set New Funding Token + Exchange\r\n        _fundingToken = tokenAddress;\r\n//        _maxTokensToSwapPerTx = maxSwapAmount;\r\n        _uniswap = UniswapExchangeInterface(uniswapExchangeAddress);\r\n    }\r\n\r\n    function depositFunds(address tokenAddress, uint tokenAmount) public payable onlyOwner {\r\n        require(_fundingToken != address(0), \"Funding Token has not been setup\");\r\n        require(_fundingToken != tokenAddress, \"Funding Token is not the same as the deposited token type\");\r\n\r\n        IERC20 token = IERC20(_fundingToken);\r\n        uint256 currentTokenBalance = token.balanceOf(msg.sender);\r\n        require(tokenAmount <= currentTokenBalance, \"User does not have enough funds to deposit\");\r\n\r\n        // Mitigate ERC20 Approve front-running attack, by initially setting allowance to 0\r\n        address ourbitrage = address(this);\r\n        require(token.approve(ourbitrage, 0), \"Failed to approve Ourbitrage Contract transfer Token Funds\");\r\n        token.approve(ourbitrage, tokenAmount);\r\n\r\n        // Check that the token transferFrom has succeeded\r\n        require(token.transferFrom(msg.sender, ourbitrage, tokenAmount), \"Failed to transfer Token Funds into Ourbitrage Contract\");\r\n    }\r\n\r\n    // @dev Buy ETH on Kyber and Sell on Uniswap using Token\r\n    // @param tokenExchange Uniswap Exchange Interface Address for Token (ie. SAI)\r\n    // @param tokenContract Token Contract Address (ie. SAI)\r\n    // @param tokenAmount The amount of the Token to Transfer\r\n    function kyberToUniswap() public payable onlyOwner {\r\n        _kyberToUniswap();\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    //\r\n    // Private/Internal\r\n    //\r\n\r\n    function _withdrawETH(address payable receiver) internal {\r\n        require(receiver != address(0), \"Invalid receiver for withdraw\");\r\n        address ourbitrage = address(this);\r\n        receiver.transfer(ourbitrage.balance);\r\n    }\r\n\r\n    function _withdrawToken(address receiver) internal {\r\n        require(receiver != address(0), \"Invalid receiver for withdraw\");\r\n        address ourbitrage = address(this);\r\n        IERC20 token = IERC20(_fundingToken);\r\n        uint256 currentTokenBalance = token.balanceOf(ourbitrage);\r\n        token.transfer(receiver, currentTokenBalance);\r\n    }\r\n\r\n    // @dev Buy ETH on Kyber and Sell on Uniswap using Token\r\n    // @param tokenOwner The address of the owner of the Token\r\n    // @param tokenExchange Uniswap Exchange Interface Address for Token (ie. SAI)\r\n    // @param tokenContract Token Contract Address (ie. SAI)\r\n    // @param tokenAmount The amount of the Token to Transfer\r\n    function _kyberToUniswap() internal {\r\n        require(_fundingToken != address(0), \"Funding Token has not been set\");\r\n        require(address(_kyber) != address(0), \"Kyber Network Exchange Interface has not been set\");\r\n        require(address(_orfeed) != address(0), \"OrFeed Interface has not been set\");\r\n\r\n        // Get Amount of Funds in Contract\r\n        address ourbitrage = address(this);\r\n        IERC20 token = IERC20(_fundingToken);\r\n        uint256 tokenBalance = token.balanceOf(ourbitrage);\r\n        require(tokenBalance > 0, \"Insufficient funds to process arbitration\");\r\n\r\n        // Check Swap Cap\r\n//        uint tokensToSwap = tokenBalance;\r\n//        if (_maxTokensToSwapPerTx > 0 && tokensToSwap > _maxTokensToSwapPerTx) {\r\n//            tokensToSwap = _maxTokensToSwapPerTx;\r\n//        }\r\n\r\n        // Perform Swap\r\n        uint ethReceived = _swapTokenToEther(token, tokenBalance);  // Buy ETH on Kyber\r\n        _swapEtherToToken(ethReceived);                             // Sell ETH on Uniswap\r\n\r\n        // Determine Profits\r\n        uint profit = (token.balanceOf(ourbitrage) - tokenBalance);\r\n        emit Arbitrage(_fundingToken, profit);\r\n    }\r\n\r\n    // @dev Buy ETH on Kyber for Token (SAI/DAI)\r\n    function _swapTokenToEther(IERC20 token, uint tokenAmount) internal returns (uint) {\r\n        address ourbitrage = address(this);\r\n        uint minRate;\r\n        (, minRate) = _kyber.getExpectedRate(token, _ETH_TOKEN_ADDRESS, tokenAmount);\r\n\r\n        // Mitigate ERC20 Approve front-running attack, by initially setting allowance to 0\r\n        require(token.approve(address(_kyber), 0), \"Failed to approve KyberNetwork for token transfer\");\r\n        token.approve(address(_kyber), tokenAmount);\r\n\r\n        // Perform Swap\r\n        return _kyber.tradeWithHint(IERC20(token), tokenAmount, _ETH_TOKEN_ADDRESS, ourbitrage, _DEFAULT_MAX_RATE, minRate, _feeCollector, _PERM_HINT);\r\n    }\r\n\r\n    // @dev Sell ETH on Uniswap for Token (SAI/DAI)\r\n    function _swapEtherToToken(uint ethAmount) internal returns (bool) {\r\n        // Create Exchange Interface for Token Type\r\n        _uniswap.ethToTokenSwapInput.value(ethAmount)(1, block.timestamp);\r\n        return true;\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        _owner = newOwner;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"getExpectedRate\",\"outputs\":[{\"name\":\"minRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getKyberSellEthPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFundingTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kyberToUniswap\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"string\"},{\"name\":\"to\",\"type\":\"string\"},{\"name\":\"venue\",\"type\":\"string\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFundingTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orfeed\",\"type\":\"address\"}],\"name\":\"setOrFeedInterface\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEthBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"uniswapExchangeAddress\",\"type\":\"address\"}],\"name\":\"setupFundingToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"depositFunds\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUniswapBuyEthPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feeCollector\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"kyber\",\"type\":\"address\"}],\"name\":\"setKyberNetworkProxyInterface\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUniswapSellEthPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getKyberBuyEthPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"profit\",\"type\":\"uint256\"}],\"name\":\"Arbitrage\",\"type\":\"event\"}]","ContractName":"Ourbitrage","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://e617726d3a6d5b8b619d9f871546ae0e88528eeb59cea2bb8f06e935414aea76"}]}