{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.12; \r\n\r\nlibrary DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n    \r\n}\r\n\r\ninterface CErc20 { \r\n    \r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address tokenOwner) external view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function approve(address spender, uint tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\r\n}\r\n\r\ninterface InterestProxy { \r\n    function sweep(address beneficiary, address paymentToken, uint amount) payable external; \r\n    function widthdraw(address beneficiary, address paymentToken, uint amount) external; \r\n    \r\n}\r\n\r\ninterface ERC721 /* is ERC165 */ {\r\n           \r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\ninterface ERC165 {\r\n\r\n   function supportsInterface(bytes4 interfaceID) external view returns (bool); \r\n    \r\n}\r\n\r\ninterface ERC721TokenReceiver {\r\n           \r\n   function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n}\r\n         \r\n/**\r\n    @title ERC-1155 Multi Token Standard\r\n    @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1155.md\r\n    Note: The ERC-165 identifier for this interface is 0xd9b67a26.\r\n */\r\ninterface IERC1155 /* is ERC165 */ {\r\n   \r\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\r\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n    event URI(string _value, uint256 indexed _id);\r\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;\r\n    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\r\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\r\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n/**\r\n    Note: The ERC-165 identifier for this interface is 0x4e2312e0.\r\n*/\r\ninterface ERC1155TokenReceiver {\r\n    \r\n    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external returns(bytes4);\r\n    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);\r\n}\r\n\r\ncontract AuctionHouse is ERC721TokenReceiver, ERC1155TokenReceiver {\r\n    \r\n    mapping (uint => AuctionListing) public auctions; \r\n    mapping (uint => bool) public auctionActive;\r\n    \r\n    address payable public proxyAddress = 0x657480455BA008c31D6F255c09d982Bc2d4D3527; \r\n    \r\n    uint public auctionCount; \r\n    uint public auctionPeriod = 24 hours; \r\n    uint public auctionBoost = 10 seconds; \r\n    \r\n    enum AuctionType { ERC20, ERC721, ERC1155}\r\n    using DSMath for uint; \r\n    \r\n    struct AuctionListing {\r\n        address auctioneer; \r\n        uint auctionId; \r\n        uint auctionType; \r\n        address paymentToken;\r\n        uint itemId; \r\n        address tokenContract; \r\n        uint startTime; \r\n        uint endTime; \r\n        uint startPrice; \r\n        uint currentBid; \r\n        uint tick; \r\n        uint totalRaised;\r\n        uint bidCount; \r\n        address highBidder;\r\n        \r\n    }\r\n    \r\n    /// @notice Create an auction listing and take custody of item\r\n    /// @dev Note - this doesn't start the auction or the timer.\r\n    /// @param tokenContract Address of the token/NFT being listed \r\n    /// @param paymentToken Address of the token being used as payment method, use address(0) for ETH\r\n    /// @param itemId Item identifier for NFT listing types\r\n    /// @param auctionType Signifies either of 0 - ERC20 prize, 1 - ERC721 prize, 2 - ERC1155 prize\r\n    /// @param startPrice Starting price of auction. For auctions > 0.01 starting price, tick is set to 0.01, else it matches precision of the start price (triangular auction)\r\n    function createAuction(address tokenContract, address paymentToken, uint itemId, uint auctionType,uint startPrice) public { \r\n        \r\n        AuctionListing memory al  = AuctionListing(msg.sender,auctionCount,auctionType,paymentToken,itemId,tokenContract,0,0,startPrice,startPrice,0,0,0,address(0)); \r\n        \r\n        uint tick; \r\n        uint digits;\r\n        \r\n        if (startPrice > 0.01 ether) {\r\n           tick = 0.01 ether; \r\n       \r\n        } else {\r\n            while (startPrice  > 0) {\r\n            startPrice /= 10;\r\n            digits++;\r\n        }\r\n        \r\n        tick = 10 ** digits.sub(1); \r\n        }\r\n        \r\n        al.tick = tick; \r\n        \r\n        auctions[auctionCount] = al; \r\n        auctionCount++;\r\n        \r\n        //Token deposit \r\n        if (auctionType == 0) {\r\n            CErc20 auctionToken = CErc20(tokenContract); \r\n            require(auctionToken.transferFrom(msg.sender,address(this), 1));\r\n        }\r\n        \r\n        if (auctionType == 1) {\r\n            ERC721 auctionToken = ERC721(tokenContract);\r\n            auctionToken.transferFrom(msg.sender,address(this),itemId);\r\n        }\r\n        \r\n        if (auctionType == 3) {\r\n             IERC1155 auctionToken = IERC1155(tokenContract);\r\n             auctionToken.safeTransferFrom(msg.sender,address(this),itemId,1,\"\");\r\n        }\r\n        \r\n        emit AuctionListed(al.auctionId,msg.sender,tokenContract,paymentToken,al.startPrice,tick);\r\n        \r\n    }\r\n    \r\n    /// @notice Place a bid on an auction\r\n    /// @dev Note - auction must have been activated with `startAuction(uint)`\r\n    /// @param auctionId uint. Which listing to place bid on. \r\n    \r\n    function bid (uint auctionId) public payable {\r\n        \r\n        require(auctionId < auctionCount); \r\n        require(auctionActive[auctionId] == true);\r\n        \r\n        AuctionListing memory al = auctions[auctionId]; \r\n        uint currentBid = al.currentBid; \r\n        \r\n        uint time = now; \r\n        \r\n        if (time >= al.endTime) {\r\n            // Don't allow bids after end: \r\n            revert(); \r\n        }\r\n        \r\n        if (al.paymentToken == address(0)) { //ETH \r\n             require(msg.value == currentBid); \r\n             \r\n             //Transfer to interest proxy:\r\n             InterestProxy proxy = InterestProxy(proxyAddress); \r\n             proxy.sweep.value(msg.value)(al.auctioneer,address(0),msg.value);\r\n             \r\n        } else { \r\n            CErc20 paymentToken = CErc20(al.paymentToken);\r\n            require(paymentToken.transferFrom(msg.sender,address(this),currentBid));\r\n            \r\n            //Transfer to interest proxy:\r\n            paymentToken.approve(proxyAddress,currentBid);\r\n            InterestProxy proxy = InterestProxy(proxyAddress); \r\n            proxy.sweep(al.auctioneer,al.paymentToken,currentBid);\r\n        }\r\n        \r\n        al.totalRaised = al.totalRaised.add(al.currentBid); \r\n        al.currentBid = al.currentBid.add(al.tick); \r\n        al.highBidder = msg.sender;\r\n        al.bidCount = al.bidCount.add(1);\r\n        \r\n        if (((al.endTime.sub(time)).add(auctionBoost)) < auctionPeriod)\r\n          al.endTime = al.endTime.add(auctionBoost); \r\n        \r\n        auctions[auctionId] = al;\r\n        \r\n        emit BidPlaced(al.auctionId,msg.sender,currentBid); \r\n    }\r\n    \r\n    /// @notice Start an auction, and set the countdown 24 hours from when mined. If no bids are placed, use `claim(auctionId)` to return the NFT\r\n    /// @param auctionId uint. Which listing to start. \r\n    function startAuction(uint auctionId) public { \r\n         require(auctionId < auctionCount);\r\n         \r\n         AuctionListing memory al = auctions[auctionId]; \r\n         \r\n         require(al.auctioneer == msg.sender);\r\n         require(al.tokenContract != address(0));\r\n         \r\n         auctionActive[auctionId] = true; \r\n         \r\n         uint time = now; \r\n         \r\n         al.startTime = time; \r\n         al.endTime = time.add(auctionPeriod);\r\n         \r\n         \r\n        auctions[auctionId] = al;\r\n        \r\n        emit AuctionStarted(auctionId,al.endTime);\r\n        \r\n    }\r\n    \r\n    /// @notice Cancel auction. If you haven't officially started the auction, you can reclaim the NFT here.\r\n    /// @param auctionId uint. Which listing to cancel. \r\n    function cancel(uint auctionId) public {\r\n         require(auctionId < auctionCount);\r\n         require(auctionActive[auctionId] == false); \r\n         \r\n         AuctionListing memory al = auctions[auctionId];\r\n         \r\n         require(msg.sender == al.auctioneer); \r\n         \r\n         auctions[auctionId].tokenContract = address(0);\r\n         \r\n         //Release the item to auctioneer:   \r\n            if (al.auctionType == 0) {\r\n              CErc20 auctionToken = CErc20(al.tokenContract); \r\n              require(auctionToken.transferFrom(address(this),al.auctioneer, 1));\r\n            }\r\n        \r\n            if (al.auctionType == 1) {\r\n              ERC721 auctionToken = ERC721(al.tokenContract);\r\n              auctionToken.safeTransferFrom(address(this),al.auctioneer,al.itemId);\r\n            }\r\n        \r\n            if (al.auctionType == 3) {\r\n             IERC1155 auctionToken = IERC1155(al.tokenContract);\r\n             auctionToken.safeTransferFrom(address(this),al.auctioneer,al.itemId,1,\"\");\r\n            }\r\n         \r\n        \r\n    }\r\n    \r\n     /// @notice Claim. Release the goods and send funds to auctioneer. If no bids, item is returned to auctioneer.\r\n    /// @param auctionId uint. Which listing to claim. \r\n    function claim(uint auctionId) public {\r\n        require(auctionId < auctionCount);\r\n        require(auctionActive[auctionId] == true);\r\n        \r\n        AuctionListing memory al = auctions[auctionId];\r\n        \r\n        require(now >= al.endTime);\r\n        require(msg.sender == al.auctioneer || msg.sender == al.highBidder);\r\n        \r\n        auctionActive[auctionId] = false; \r\n        \r\n        auctions[auctionId].tokenContract = address(0);\r\n        \r\n        if (al.bidCount > 0) {\r\n            //Release the item to highBidder \r\n             if (al.auctionType == 0) {\r\n              CErc20 auctionToken = CErc20(al.tokenContract); \r\n              require(auctionToken.transferFrom(address(this),al.highBidder, 1));\r\n            }\r\n        \r\n            if (al.auctionType == 1) {\r\n              ERC721 auctionToken = ERC721(al.tokenContract);\r\n              auctionToken.safeTransferFrom(address(this),al.highBidder,al.itemId);\r\n            }\r\n        \r\n            if (al.auctionType == 3) {\r\n             IERC1155 auctionToken = IERC1155(al.tokenContract);\r\n             auctionToken.safeTransferFrom(address(this),al.highBidder,al.itemId,1,\"\");\r\n            }\r\n            \r\n            //Release the funds to auctioneer: \r\n             InterestProxy proxy = InterestProxy(proxyAddress); \r\n             proxy.widthdraw(al.auctioneer,al.paymentToken, al.totalRaised);\r\n             \r\n             emit AuctionWon(auctionId,al.currentBid.sub(al.tick),al.highBidder);\r\n        } else { \r\n            \r\n            //Release the item to auctioneer:   \r\n            if (al.auctionType == 0) {\r\n              CErc20 auctionToken = CErc20(al.tokenContract); \r\n              require(auctionToken.transferFrom(address(this),al.auctioneer, 1));\r\n            }\r\n        \r\n            if (al.auctionType == 1) {\r\n              ERC721 auctionToken = ERC721(al.tokenContract);\r\n              auctionToken.safeTransferFrom(address(this),al.auctioneer,al.itemId);\r\n            }\r\n        \r\n            if (al.auctionType == 3) {\r\n             IERC1155 auctionToken = IERC1155(al.tokenContract);\r\n             auctionToken.safeTransferFrom(address(this),al.auctioneer,al.itemId,1,\"\");\r\n            }\r\n            \r\n        }\r\n        \r\n        \r\n    }\r\n    \r\n     /// @notice Returns time left in seconds or 0 if auction is over or not active. \r\n    /// @param auctionId uint. Which auction to query. \r\n    function getTimeLeft(uint auctionId) view public returns (uint) {\r\n          require(auctionId < auctionCount);\r\n          uint256 time = now; \r\n          \r\n          AuctionListing memory al = auctions[auctionId];\r\n          \r\n          return (time > al.endTime) ? 0 : al.endTime.sub(time); \r\n          \r\n      }\r\n      \r\n      \r\n      function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) public returns(bytes4) {\r\n           return 0x150b7a02;\r\n      }\r\n      \r\n      function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes memory _data) public returns(bytes4) {\r\n          return 0xf23a6e61;\r\n      }\r\n      \r\n      function onERC1155BatchReceived(address _operator, address _from, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) public returns(bytes4) {\r\n          return 0xbc197c81;\r\n      }\r\n    \r\n    event AuctionListed(uint auction_id, address auctioneer, address auctionToken, address paymentToken, uint startPrice, uint tick ); \r\n    event AuctionStarted(uint aution_id, uint endTime); \r\n    event BidPlaced(uint auction_id, address bidder, uint price);\r\n    event AuctionWon(uint auction_id, uint highestBid, address winner);\r\n    \r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auction_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"auctioneer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"auctionToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tick\",\"type\":\"uint256\"}],\"name\":\"AuctionListed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"aution_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"AuctionStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auction_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"highestBid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"AuctionWon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auction_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"BidPlaced\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctionActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionBoost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"auctioneer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tick\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRaised\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"highBidder\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startPrice\",\"type\":\"uint256\"}],\"name\":\"createAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"getTimeLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"startAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AuctionHouse","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://3c671bfd9babcdbe78cc98613e5bd4f368d579f440309915444add66bee98839"}]}