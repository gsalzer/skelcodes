{"status":"1","message":"OK","result":[{"SourceCode":"/**\nAuthor: Loopring Foundation (Loopring Project Ltd)\n*/\n\npragma solidity ^0.5.11;\n\n\ncontract ERC20 {\n    function totalSupply()\n        public\n        view\n        returns (uint);\n\n    function balanceOf(\n        address who\n        )\n        public\n        view\n        returns (uint);\n\n    function allowance(\n        address owner,\n        address spender\n        )\n        public\n        view\n        returns (uint);\n\n    function transfer(\n        address to,\n        uint value\n        )\n        public\n        returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint    value\n        )\n        public\n        returns (bool);\n\n    function approve(\n        address spender,\n        uint    value\n        )\n        public\n        returns (bool);\n}\n\ncontract BurnableERC20 is ERC20\n{\n    function burn(\n        uint value\n        )\n        public\n        returns (bool);\n\n    function burnFrom(\n        address from,\n        uint value\n        )\n        public\n        returns (bool);\n}\n\nlibrary ERC20SafeTransfer {\n    function safeTransferAndVerify(\n        address token,\n        address to,\n        uint    value\n        )\n        internal\n    {\n        safeTransferWithGasLimitAndVerify(\n            token,\n            to,\n            value,\n            gasleft()\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint    value\n        )\n        internal\n        returns (bool)\n    {\n        return safeTransferWithGasLimit(\n            token,\n            to,\n            value,\n            gasleft()\n        );\n    }\n\n    function safeTransferWithGasLimitAndVerify(\n        address token,\n        address to,\n        uint    value,\n        uint    gasLimit\n        )\n        internal\n    {\n        require(\n            safeTransferWithGasLimit(token, to, value, gasLimit),\n            \"TRANSFER_FAILURE\"\n        );\n    }\n\n    function safeTransferWithGasLimit(\n        address token,\n        address to,\n        uint    value,\n        uint    gasLimit\n        )\n        internal\n        returns (bool)\n    {\n        \n        \n        \n\n        \n        bytes memory callData = abi.encodeWithSelector(\n            bytes4(0xa9059cbb),\n            to,\n            value\n        );\n        (bool success, ) = token.call.gas(gasLimit)(callData);\n        return checkReturnValue(success);\n    }\n\n    function safeTransferFromAndVerify(\n        address token,\n        address from,\n        address to,\n        uint    value\n        )\n        internal\n    {\n        safeTransferFromWithGasLimitAndVerify(\n            token,\n            from,\n            to,\n            value,\n            gasleft()\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint    value\n        )\n        internal\n        returns (bool)\n    {\n        return safeTransferFromWithGasLimit(\n            token,\n            from,\n            to,\n            value,\n            gasleft()\n        );\n    }\n\n    function safeTransferFromWithGasLimitAndVerify(\n        address token,\n        address from,\n        address to,\n        uint    value,\n        uint    gasLimit\n        )\n        internal\n    {\n        bool result = safeTransferFromWithGasLimit(\n            token,\n            from,\n            to,\n            value,\n            gasLimit\n        );\n        require(result, \"TRANSFER_FAILURE\");\n    }\n\n    function safeTransferFromWithGasLimit(\n        address token,\n        address from,\n        address to,\n        uint    value,\n        uint    gasLimit\n        )\n        internal\n        returns (bool)\n    {\n        \n        \n        \n\n        \n        bytes memory callData = abi.encodeWithSelector(\n            bytes4(0x23b872dd),\n            from,\n            to,\n            value\n        );\n        (bool success, ) = token.call.gas(gasLimit)(callData);\n        return checkReturnValue(success);\n    }\n\n    function checkReturnValue(\n        bool success\n        )\n        internal\n        pure\n        returns (bool)\n    {\n        \n        \n        \n        if (success) {\n            assembly {\n                switch returndatasize()\n                \n                case 0 {\n                    success := 1\n                }\n                \n                case 32 {\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)\n                }\n                \n                default {\n                    success := 0\n                }\n            }\n        }\n        return success;\n    }\n}\n\nlibrary MathUint {\n    function mul(\n        uint a,\n        uint b\n        )\n        internal\n        pure\n        returns (uint c)\n    {\n        c = a * b;\n        require(a == 0 || c / a == b, \"MUL_OVERFLOW\");\n    }\n\n    function sub(\n        uint a,\n        uint b\n        )\n        internal\n        pure\n        returns (uint)\n    {\n        require(b <= a, \"SUB_UNDERFLOW\");\n        return a - b;\n    }\n\n    function add(\n        uint a,\n        uint b\n        )\n        internal\n        pure\n        returns (uint c)\n    {\n        c = a + b;\n        require(c >= a, \"ADD_OVERFLOW\");\n    }\n\n    function decodeFloat(\n        uint f\n        )\n        internal\n        pure\n        returns (uint value)\n    {\n        uint numBitsMantissa = 23;\n        uint exponent = f >> numBitsMantissa;\n        uint mantissa = f & ((1 << numBitsMantissa) - 1);\n        value = mantissa * (10 ** exponent);\n    }\n}\n\ncontract Ownable {\n    address public owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    \n    \n    constructor()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    \n    modifier onlyOwner()\n    {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n        _;\n    }\n\n    \n    \n    \n    function transferOwnership(\n        address newOwner\n        )\n        public\n        onlyOwner\n    {\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function renounceOwnership()\n        public\n        onlyOwner\n    {\n        emit OwnershipTransferred(owner, address(0));\n        owner = address(0);\n    }\n}\n\ncontract Claimable is Ownable\n{\n    address public pendingOwner;\n\n    \n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner, \"UNAUTHORIZED\");\n        _;\n    }\n\n    \n    \n    function transferOwnership(\n        address newOwner\n        )\n        public\n        onlyOwner\n    {\n        require(newOwner != address(0) && newOwner != owner, \"INVALID_ADDRESS\");\n        pendingOwner = newOwner;\n    }\n\n    \n    function claimOwnership()\n        public\n        onlyPendingOwner\n    {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n}\n\ncontract IBlockVerifier is Claimable\n{\n    \n\n    event CircuitRegistered(\n        uint8  indexed blockType,\n        bool           onchainDataAvailability,\n        uint16         blockSize,\n        uint8          blockVersion\n    );\n\n    event CircuitDisabled(\n        uint8  indexed blockType,\n        bool           onchainDataAvailability,\n        uint16         blockSize,\n        uint8          blockVersion\n    );\n\n    \n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function registerCircuit(\n        uint8    blockType,\n        bool     onchainDataAvailability,\n        uint16   blockSize,\n        uint8    blockVersion,\n        uint[18] calldata vk\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function disableCircuit(\n        uint8  blockType,\n        bool   onchainDataAvailability,\n        uint16 blockSize,\n        uint8  blockVersion\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function verifyProofs(\n        uint8  blockType,\n        bool   onchainDataAvailability,\n        uint16 blockSize,\n        uint8  blockVersion,\n        uint[] calldata publicInputs,\n        uint[] calldata proofs\n        )\n        external\n        view\n        returns (bool);\n\n    \n    \n    \n    \n    \n    \n    \n    function isCircuitRegistered(\n        uint8  blockType,\n        bool   onchainDataAvailability,\n        uint16 blockSize,\n        uint8  blockVersion\n        )\n        external\n        view\n        returns (bool);\n\n    \n    \n    \n    \n    \n    \n    \n    function isCircuitEnabled(\n        uint8  blockType,\n        bool   onchainDataAvailability,\n        uint16 blockSize,\n        uint8  blockVersion\n        )\n        external\n        view\n        returns (bool);\n}\n\ncontract ReentrancyGuard {\n    \n    uint private _guardValue;\n\n    \n    modifier nonReentrant()\n    {\n        \n        require(_guardValue == 0, \"REENTRANCY\");\n\n        \n        _guardValue = 1;\n\n        \n        _;\n\n        \n        _guardValue = 0;\n    }\n}\n\ncontract ILoopring is Claimable, ReentrancyGuard\n{\n    string  constant public version = \"\"; \n\n    uint    public exchangeCreationCostLRC;\n    address public universalRegistry;\n    address public lrcAddress;\n\n    event ExchangeInitialized(\n        uint    indexed exchangeId,\n        address indexed exchangeAddress,\n        address indexed owner,\n        address         operator,\n        bool            onchainDataAvailability\n    );\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function initializeExchange(\n        address exchangeAddress,\n        uint    exchangeId,\n        address owner,\n        address payable operator,\n        bool    onchainDataAvailability\n        )\n        external;\n}\n\ncontract ILoopringV3 is ILoopring\n{\n    \n\n    event ExchangeStakeDeposited(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event ExchangeStakeWithdrawn(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event ExchangeStakeBurned(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event ProtocolFeeStakeDeposited(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event ProtocolFeeStakeWithdrawn(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event SettingsUpdated(\n        uint            time\n    );\n\n    \n    struct Exchange\n    {\n        address exchangeAddress;\n        uint    exchangeStake;\n        uint    protocolFeeStake;\n    }\n\n    mapping (uint => Exchange) internal exchanges;\n\n    string  constant public version = \"3.1\";\n\n    address public wethAddress;\n    uint    public totalStake;\n    address public blockVerifierAddress;\n    address public downtimeCostCalculator;\n    uint    public maxWithdrawalFee;\n    uint    public withdrawalFineLRC;\n    uint    public tokenRegistrationFeeLRCBase;\n    uint    public tokenRegistrationFeeLRCDelta;\n    uint    public minExchangeStakeWithDataAvailability;\n    uint    public minExchangeStakeWithoutDataAvailability;\n    uint    public revertFineLRC;\n    uint8   public minProtocolTakerFeeBips;\n    uint8   public maxProtocolTakerFeeBips;\n    uint8   public minProtocolMakerFeeBips;\n    uint8   public maxProtocolMakerFeeBips;\n    uint    public targetProtocolTakerFeeStake;\n    uint    public targetProtocolMakerFeeStake;\n\n    address payable public protocolFeeVault;\n\n    \n    \n    \n    \n    \n    \n    function updateSettings(\n        address payable _protocolFeeVault,   \n        address _blockVerifierAddress,       \n        address _downtimeCostCalculator,     \n        uint    _exchangeCreationCostLRC,\n        uint    _maxWithdrawalFee,\n        uint    _tokenRegistrationFeeLRCBase,\n        uint    _tokenRegistrationFeeLRCDelta,\n        uint    _minExchangeStakeWithDataAvailability,\n        uint    _minExchangeStakeWithoutDataAvailability,\n        uint    _revertFineLRC,\n        uint    _withdrawalFineLRC\n        )\n        external;\n\n    \n    \n    \n    \n    \n    function updateProtocolFeeSettings(\n        uint8 _minProtocolTakerFeeBips,\n        uint8 _maxProtocolTakerFeeBips,\n        uint8 _minProtocolMakerFeeBips,\n        uint8 _maxProtocolMakerFeeBips,\n        uint  _targetProtocolTakerFeeStake,\n        uint  _targetProtocolMakerFeeStake\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function canExchangeCommitBlocks(\n        uint exchangeId,\n        bool onchainDataAvailability\n        )\n        external\n        view\n        returns (bool);\n\n    \n    \n    \n    function getExchangeStake(\n        uint exchangeId\n        )\n        public\n        view\n        returns (uint stakedLRC);\n\n    \n    \n    \n    \n    \n    function burnExchangeStake(\n        uint exchangeId,\n        uint amount\n        )\n        external\n        returns (uint burnedLRC);\n\n    \n    \n    \n    \n    function depositExchangeStake(\n        uint exchangeId,\n        uint amountLRC\n        )\n        external\n        returns (uint stakedLRC);\n\n    \n    \n    \n    \n    \n    \n    function withdrawExchangeStake(\n        uint    exchangeId,\n        address recipient,\n        uint    requestedAmount\n        )\n        external\n        returns (uint amount);\n\n    \n    \n    \n    \n    function depositProtocolFeeStake(\n        uint exchangeId,\n        uint amountLRC\n        )\n        external\n        returns (uint stakedLRC);\n\n    \n    \n    \n    \n    \n    function withdrawProtocolFeeStake(\n        uint    exchangeId,\n        address recipient,\n        uint    amount\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    function getProtocolFeeValues(\n        uint exchangeId,\n        bool onchainDataAvailability\n        )\n        external\n        view\n        returns (\n            uint8 takerFeeBips,\n            uint8 makerFeeBips\n        );\n\n    \n    \n    \n    function getProtocolFeeStake(\n        uint exchangeId\n        )\n        external\n        view\n        returns (uint protocolFeeStake);\n}\n\nlibrary ExchangeData {\n    \n    enum BlockType\n    {\n        RING_SETTLEMENT,\n        DEPOSIT,\n        ONCHAIN_WITHDRAWAL,\n        OFFCHAIN_WITHDRAWAL,\n        ORDER_CANCELLATION,\n        TRANSFER\n    }\n\n    enum BlockState\n    {\n        \n        \n        NEW,            \n\n        \n        COMMITTED,      \n\n        \n        \n        VERIFIED        \n    }\n\n    \n    struct Account\n    {\n        address owner;\n\n        \n        \n        \n        \n        \n        \n        \n        \n        uint    pubKeyX;\n        uint    pubKeyY;\n    }\n\n    struct Token\n    {\n        address token;\n        bool    depositDisabled;\n    }\n\n    struct ProtocolFeeData\n    {\n        uint32 timestamp;\n        uint8 takerFeeBips;\n        uint8 makerFeeBips;\n        uint8 previousTakerFeeBips;\n        uint8 previousMakerFeeBips;\n    }\n\n    \n    \n    struct Block\n    {\n        \n        \n        bytes32 merkleRoot;\n\n        \n        \n        \n        \n        \n        \n        bytes32 publicDataHash;\n\n        \n        BlockState state;\n\n        \n        \n        BlockType blockType;\n\n        \n        \n        \n        \n        uint16 blockSize;\n\n        \n        uint8  blockVersion;\n\n        \n        uint32 timestamp;\n\n        \n        \n        uint32 numDepositRequestsCommitted;\n\n        \n        \n        uint32 numWithdrawalRequestsCommitted;\n\n        \n        \n        bool   blockFeeWithdrawn;\n\n        \n        uint16 numWithdrawalsDistributed;\n\n        \n        \n        \n        \n        \n        \n        \n        \n        bytes  withdrawals;\n    }\n\n    \n    \n    \n    struct Request\n    {\n        bytes32 accumulatedHash;\n        uint    accumulatedFee;\n        uint32  timestamp;\n    }\n\n    \n    struct Deposit\n    {\n        uint24 accountID;\n        uint16 tokenID;\n        uint96 amount;\n    }\n\n    function SNARK_SCALAR_FIELD() internal pure returns (uint) {\n        \n        return 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    }\n\n    function MAX_PROOF_GENERATION_TIME_IN_SECONDS() internal pure returns (uint32) { return 14 days; }\n    function MAX_GAP_BETWEEN_FINALIZED_AND_VERIFIED_BLOCKS() internal pure returns (uint32) { return 1000; }\n    function MAX_OPEN_DEPOSIT_REQUESTS() internal pure returns (uint16) { return 1024; }\n    function MAX_OPEN_WITHDRAWAL_REQUESTS() internal pure returns (uint16) { return 1024; }\n    function MAX_AGE_UNFINALIZED_BLOCK_UNTIL_WITHDRAW_MODE() internal pure returns (uint32) { return 21 days; }\n    function MAX_AGE_REQUEST_UNTIL_FORCED() internal pure returns (uint32) { return 14 days; }\n    function MAX_AGE_REQUEST_UNTIL_WITHDRAW_MODE() internal pure returns (uint32) { return 15 days; }\n    function MAX_TIME_IN_SHUTDOWN_BASE() internal pure returns (uint32) { return 30 days; }\n    function MAX_TIME_IN_SHUTDOWN_DELTA() internal pure returns (uint32) { return 1 seconds; }\n    function TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS() internal pure returns (uint32) { return 7 days; }\n    function MAX_NUM_TOKENS() internal pure returns (uint) { return 2 ** 8; }\n    function MAX_NUM_ACCOUNTS() internal pure returns (uint) { return 2 ** 20 - 1; }\n    function MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS() internal pure returns (uint32) { return 14 days; }\n    function MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS_SHUTDOWN_MODE() internal pure returns (uint32) {\n        return MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS() * 10;\n    }\n    function FEE_BLOCK_FINE_START_TIME() internal pure returns (uint32) { return 6 hours; }\n    function FEE_BLOCK_FINE_MAX_DURATION() internal pure returns (uint32) { return 6 hours; }\n    function MIN_GAS_TO_DISTRIBUTE_WITHDRAWALS() internal pure returns (uint32) { return 150000; }\n    function MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED() internal pure returns (uint32) { return 1 days; }\n    function GAS_LIMIT_SEND_TOKENS() internal pure returns (uint32) { return 60000; }\n\n    \n    struct State\n    {\n        uint    id;\n        uint    exchangeCreationTimestamp;\n        address payable operator; \n        bool    onchainDataAvailability;\n\n        ILoopringV3    loopring;\n        IBlockVerifier blockVerifier;\n\n        address lrcAddress;\n\n        uint    totalTimeInMaintenanceSeconds;\n        uint    numDowntimeMinutes;\n        uint    downtimeStart;\n\n        address addressWhitelist;\n        uint    accountCreationFeeETH;\n        uint    accountUpdateFeeETH;\n        uint    depositFeeETH;\n        uint    withdrawalFeeETH;\n\n        Block[]     blocks;\n        Token[]     tokens;\n        Account[]   accounts;\n        Deposit[]   deposits;\n        Request[]   depositChain;\n        Request[]   withdrawalChain;\n\n        \n        mapping (address => uint24) ownerToAccountId;\n        mapping (address => uint16) tokenToTokenId;\n\n        \n        mapping (address => mapping (address => bool)) withdrawnInWithdrawMode;\n\n        \n        mapping (address => uint) tokenBalances;\n\n        \n        \n        \n        uint numBlocksFinalized;\n\n        \n        ProtocolFeeData protocolFeeData;\n\n        \n        uint shutdownStartTime;\n    }\n}\n\nlibrary ExchangeMode {\n    using MathUint  for uint;\n\n    function isInWithdrawalMode(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool result)\n    {\n        result = false;\n        ExchangeData.Block storage currentBlock = S.blocks[S.blocks.length - 1];\n\n        \n        if (currentBlock.numDepositRequestsCommitted < S.depositChain.length) {\n            uint32 requestTimestamp = S.depositChain[currentBlock.numDepositRequestsCommitted].timestamp;\n            result = requestTimestamp < now.sub(ExchangeData.MAX_AGE_REQUEST_UNTIL_WITHDRAW_MODE());\n        }\n\n        \n        if (result == false && currentBlock.numWithdrawalRequestsCommitted < S.withdrawalChain.length) {\n            uint32 requestTimestamp = S.withdrawalChain[currentBlock.numWithdrawalRequestsCommitted].timestamp;\n            result = requestTimestamp < now.sub(ExchangeData.MAX_AGE_REQUEST_UNTIL_WITHDRAW_MODE());\n        }\n\n        \n        if (result == false) {\n            result = isAnyUnfinalizedBlockTooOld(S);\n        }\n\n        \n        if (result == false && isShutdown(S) && !isInInitialState(S)) {\n            \n            \n            uint maxTimeInShutdown = ExchangeData.MAX_TIME_IN_SHUTDOWN_BASE();\n            maxTimeInShutdown = maxTimeInShutdown.add(S.accounts.length.mul(ExchangeData.MAX_TIME_IN_SHUTDOWN_DELTA()));\n            result = now > S.shutdownStartTime.add(maxTimeInShutdown);\n        }\n    }\n\n    function isShutdown(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool)\n    {\n        return S.shutdownStartTime > 0;\n    }\n\n    function isInMaintenance(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool)\n    {\n        return S.downtimeStart != 0 && getNumDowntimeMinutesLeft(S) > 0;\n    }\n\n    function isInInitialState(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool)\n    {\n        ExchangeData.Block storage firstBlock = S.blocks[0];\n        ExchangeData.Block storage lastBlock = S.blocks[S.blocks.length - 1];\n        return (S.blocks.length == S.numBlocksFinalized) &&\n            (lastBlock.numDepositRequestsCommitted == S.depositChain.length) &&\n            (lastBlock.merkleRoot == firstBlock.merkleRoot);\n    }\n\n    function areUserRequestsEnabled(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool)\n    {\n        \n        \n        return !isInMaintenance(S) && !isShutdown(S) && !isInWithdrawalMode(S);\n    }\n\n    function isAnyUnfinalizedBlockTooOld(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool)\n    {\n        if (S.numBlocksFinalized < S.blocks.length) {\n            uint32 blockTimestamp = S.blocks[S.numBlocksFinalized].timestamp;\n            return blockTimestamp < now.sub(ExchangeData.MAX_AGE_UNFINALIZED_BLOCK_UNTIL_WITHDRAW_MODE());\n        } else {\n            return false;\n        }\n    }\n\n    function getNumDowntimeMinutesLeft(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (uint)\n    {\n        if (S.downtimeStart == 0) {\n            return S.numDowntimeMinutes;\n        } else {\n            \n            uint numDowntimeMinutesUsed = now.sub(S.downtimeStart) / 60;\n            if (S.numDowntimeMinutes > numDowntimeMinutesUsed) {\n                return S.numDowntimeMinutes.sub(numDowntimeMinutesUsed);\n            } else {\n                return 0;\n            }\n        }\n    }\n}\n\nlibrary ExchangeTokens {\n    using MathUint          for uint;\n    using ERC20SafeTransfer for address;\n    using ExchangeMode      for ExchangeData.State;\n\n    event TokenRegistered(\n        address indexed token,\n        uint16  indexed tokenId\n    );\n\n    function registerToken(\n        ExchangeData.State storage S,\n        address tokenAddress\n        )\n        external\n        returns (uint16 tokenID)\n    {\n        tokenID = registerToken(\n            S,\n            tokenAddress,\n            getLRCFeeForRegisteringOneMoreToken(S)\n        );\n    }\n\n    function getTokenAddress(\n        ExchangeData.State storage S,\n        uint16 tokenID\n        )\n        external\n        view\n        returns (address)\n    {\n        require(tokenID < S.tokens.length, \"INVALID_TOKEN_ID\");\n        return S.tokens[tokenID].token;\n    }\n\n    function getLRCFeeForRegisteringOneMoreToken(\n        ExchangeData.State storage S\n        )\n        public\n        view\n        returns (uint feeLRC)\n    {\n        return S.loopring.tokenRegistrationFeeLRCBase().add(\n            S.loopring.tokenRegistrationFeeLRCDelta().mul(S.tokens.length)\n        );\n    }\n\n    function registerToken(\n        ExchangeData.State storage S,\n        address tokenAddress,\n        uint    amountToBurn\n        )\n        public\n        returns (uint16 tokenID)\n    {\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\n        require(S.tokenToTokenId[tokenAddress] == 0, \"TOKEN_ALREADY_EXIST\");\n        require(S.tokens.length < ExchangeData.MAX_NUM_TOKENS(), \"TOKEN_REGISTRY_FULL\");\n\n        if (amountToBurn > 0) {\n            address feeVault = S.loopring.protocolFeeVault();\n            S.lrcAddress.safeTransferFromAndVerify(msg.sender, feeVault, amountToBurn);\n        }\n\n        ExchangeData.Token memory token = ExchangeData.Token(tokenAddress, false);\n        S.tokens.push(token);\n        tokenID = uint16(S.tokens.length - 1);\n        S.tokenToTokenId[tokenAddress] = tokenID + 1;\n\n        emit TokenRegistered(tokenAddress, tokenID);\n    }\n\n    function getTokenID(\n        ExchangeData.State storage S,\n        address tokenAddress\n        )\n        public\n        view\n        returns (uint16 tokenID)\n    {\n        tokenID = S.tokenToTokenId[tokenAddress];\n        require(tokenID != 0, \"TOKEN_NOT_FOUND\");\n        tokenID = tokenID - 1;\n    }\n\n    function disableTokenDeposit(\n        ExchangeData.State storage S,\n        address tokenAddress\n        )\n        external\n    {\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\n\n        require(tokenAddress != address(0), \"ETHER_CANNOT_BE_DISABLED\");\n        require(tokenAddress != S.loopring.wethAddress(), \"WETH_CANNOT_BE_DISABLED\");\n        require(tokenAddress != S.loopring.lrcAddress(), \"LRC_CANNOT_BE_DISABLED\");\n\n        uint16 tokenID = getTokenID(S, tokenAddress);\n        ExchangeData.Token storage token = S.tokens[tokenID];\n        require(!token.depositDisabled, \"TOKEN_DEPOSIT_ALREADY_DISABLED\");\n        token.depositDisabled = true;\n    }\n\n    function enableTokenDeposit(\n        ExchangeData.State storage S,\n        address tokenAddress\n        )\n        external\n    {\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\n        uint16 tokenID = getTokenID(S, tokenAddress);\n        ExchangeData.Token storage token = S.tokens[tokenID];\n        require(token.depositDisabled, \"TOKEN_DEPOSIT_ALREADY_ENABLED\");\n        token.depositDisabled = false;\n    }\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"name\":\"TokenRegistered\",\"type\":\"event\"}]","ContractName":"ExchangeTokens","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://de6ea6c3af6bdd98870a485df6ac5bb854573e5db48612cc6636fd4b05bb2b08"}]}