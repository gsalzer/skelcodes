{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.13;\r\n\r\ninterface RNGOracle {\r\n  function modulusRequest(uint256 _modulus, uint256 _betmask, bytes32 _seed, uint256 _callbackGasLimit) external returns (bytes32 queryId);\r\n  function queryWallet(address _user) external view returns (uint256);\r\n  // function addQueryBalance() external payable; (use this in the ABI to add balance)\r\n}\r\n\r\ninterface DDN {\r\n  function transfer(address _to, uint256 _tokens) external returns (bool);\r\n  function balanceOf(address _user) external view returns (uint256);\r\n  function dividendsOf(address _user) external view returns (uint256);\r\n  function buy() external payable returns (uint256);\r\n  function reinvest() external returns (uint256);\r\n}\r\n\r\ninterface PYRO {\r\n  function transfer(address _to, uint256 _tokens) external returns (bool);\r\n  function balanceOf(address _user) external view returns (uint256);\r\n}\r\n\r\ncontract WheelOfDDN {\r\n  using SafeMath for uint;\r\n\r\n  // Modifiers\r\n  modifier noActiveBet(address _user) {\r\n    require(betStatus[_user] == false);\r\n    _;\r\n  }\r\n\r\n  modifier gameActive() {\r\n    require(gamePaused == false);\r\n    _;\r\n  }\r\n\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == admin);\r\n    _;\r\n  }\r\n\r\n  modifier autoReinvest() {\r\n    if (ddn.dividendsOf(address(this)) > 0.1 ether) {\r\n      reinvest();\r\n    }\r\n    _;\r\n  }\r\n\r\n  // Events\r\n  event BetPlaced(address indexed player, bytes32 queryId);\r\n  event BetResolved(address indexed player, bytes32 indexed queryId, uint256 betAmount, uint256 roll, uint256 bracket, uint256 win, bool stakeBet, uint256 pyro);\r\n  event BetFailed(address indexed player, bytes32 indexed queryId, uint256 betAmount, bool stakeBet);\r\n  event Stake(address indexed player, uint256 tokens);\r\n  event Withdraw(address indexed player, uint256 tokens);\r\n\r\n  address admin;\r\n  bool public gamePaused = false;\r\n\r\n  uint8[10] brackets = [1, 3, 6, 12, 24, 40, 56, 68, 76, 80];\r\n\r\n  uint256 constant internal constantFactor = 1e44;\r\n  uint256 internal globalFactor = 1e22;\r\n  uint256 internal nonStakeTokens;\r\n  uint256 internal CALLBACK_GAS_LIMIT = 300000;\r\n\r\n  struct BetInfo {\r\n    address user;\r\n    uint256 tokens;\r\n    bool stakeBet;\r\n  }\r\n\r\n  mapping(bytes32 => BetInfo) private betInfo;\r\n  mapping(address => uint256) internal personalFactorLedger_;\r\n  mapping(address => uint256) internal balanceLedger_;\r\n  mapping(address => bool) internal betStatus;\r\n  mapping(bytes32 => bool) internal queryStatus;\r\n  mapping(address => bytes32) internal lastQuery;\r\n\r\n  DDN private ddn;\r\n  RNGOracle private oracle;\r\n  PYRO private pyro;\r\n\r\n\r\n  constructor(address _oracleAddress, address _DDN_address, address _PYRO_address)\r\n    public\r\n  {\r\n    admin = msg.sender;\r\n    oracle = RNGOracle(_oracleAddress);\r\n    ddn = DDN(_DDN_address);\r\n    pyro = PYRO(_PYRO_address);\r\n  }\r\n\r\n\r\n  function stake()\r\n    external\r\n    payable\r\n    autoReinvest\r\n    noActiveBet(msg.sender)\r\n  {\r\n    require(msg.value > 0);\r\n    _stake(msg.sender, ddn.buy.value(msg.value)());\r\n  }\r\n\r\n  function placeBet()\r\n    external\r\n    payable\r\n    autoReinvest\r\n    noActiveBet(msg.sender)\r\n  {\r\n    require(msg.value > 0);\r\n    _initSpin(msg.sender, ddn.buy.value(msg.value)(), false);\r\n  }\r\n\r\n\r\n  function tokenCallback(address _from, uint256 _tokens, bytes calldata _data)\r\n    external\r\n    autoReinvest\r\n    noActiveBet(_from)\r\n    returns (bool)\r\n  {\r\n    require(msg.sender == address(ddn));\r\n    require(_tokens > 0);\r\n    if (_data.length == 0) {\r\n      _stake(_from, _tokens);\r\n    } else {\r\n      _initSpin(_from, _tokens, false);\r\n    }\r\n    return true;\r\n  }\r\n\r\n\r\n  function stakeSpin(uint256 _tokens)\r\n    external\r\n    autoReinvest\r\n    noActiveBet(msg.sender)\r\n  {\r\n    address _user = msg.sender;\r\n    require(stakeOf(_user) >= _tokens);\r\n    // User cannot bet more than 5% of available pool\r\n    if (_tokens > betPool(_user) / 20) {\r\n      _tokens = betPool(_user) / 20;\r\n    }\r\n    _initSpin(_user, _tokens, true);\r\n  }\r\n\r\n\r\n  function modulusCallback(bytes32 _queryId, uint256, uint256 _result)\r\n    external\r\n  {\r\n    require(msg.sender == address(oracle));\r\n    _executeSpin(_queryId, _result);\r\n  }\r\n\r\n\r\n  function queryFailed(bytes32 _queryId)\r\n    external\r\n  {\r\n    if (_queryId == bytes32(0x0)) {\r\n      _queryId = lastQuery[msg.sender];\r\n    } else {\r\n      require(msg.sender == address(oracle));\r\n    }\r\n    require(!queryStatus[_queryId]);\r\n    BetInfo memory _betInfo = betInfo[_queryId];\r\n    address _user = _betInfo.user;\r\n    uint256 _tokens = _betInfo.tokens;\r\n    bool _stakeBet = _betInfo.stakeBet;\r\n    require(betStatus[_user]);\r\n    if (!_stakeBet) {\r\n      nonStakeTokens = nonStakeTokens.sub(_tokens);\r\n      ddn.transfer(_user, _tokens);\r\n    }\r\n    betStatus[_user] = false;\r\n    queryStatus[_queryId] = true;\r\n    emit BetFailed(_user, _queryId, _tokens, _stakeBet);\r\n  }\r\n\r\n\r\n  function getBalance()\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return ddn.balanceOf(address(this)) - nonStakeTokens;\r\n  }\r\n\r\n\r\n  function withdraw(uint256 _tokens)\r\n    public\r\n    autoReinvest\r\n    noActiveBet(msg.sender)\r\n  {\r\n    address _user = msg.sender;\r\n    uint256 _withdrawable = _tokens;\r\n    if (_withdrawable > stakeOf(_user)) {\r\n      _withdrawable = stakeOf(_user);\r\n    }\r\n    require(_withdrawable > 0);\r\n    ddn.transfer(_user, _withdrawable);\r\n    balanceLedger_[_user] = stakeOf(_user).sub(_withdrawable);\r\n    personalFactorLedger_[_user] = constantFactor / globalFactor;\r\n    emit Withdraw(_user, _withdrawable);\r\n  }\r\n\r\n\r\n  function withdrawAll()\r\n    external\r\n    noActiveBet(msg.sender)\r\n  {\r\n    withdraw(stakeOf(msg.sender));\r\n  }\r\n\r\n\r\n  function stakeOf(address _user)\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    // Balance ledger * personal factor * globalFactor / constantFactor\r\n    return balanceLedger_[_user].mul(personalFactorLedger_[_user]).mul(globalFactor) / constantFactor;\r\n  }\r\n\r\n\r\n  function betPool(address _user)\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    // Balance of contract minus balance of the user\r\n    return getBalance().sub(stakeOf(_user));\r\n  }\r\n\r\n\r\n  function allInfoFor(address _user) public view returns (uint256 bankroll, uint256 userQueryBalance, uint256 userBalance, uint256 userStake) {\r\n    return (getBalance(), oracle.queryWallet(_user), ddn.balanceOf(_user), stakeOf(_user));\r\n  }\r\n\r\n\r\n  // Internal Functions\r\n\r\n\r\n  function _stake(address _user, uint256 _amount)\r\n    internal\r\n    gameActive\r\n  {\r\n    balanceLedger_[_user] = stakeOf(_user).add(_amount);\r\n    personalFactorLedger_[_user] = constantFactor / globalFactor;\r\n    emit Stake(_user, _amount);\r\n  }\r\n\r\n\r\n  function _initSpin(address _user, uint256 _betAmount, bool _stakeSpin)\r\n    internal\r\n    gameActive\r\n  {\r\n    bytes32 _queryId = oracle.modulusRequest(80, 1, keccak256(abi.encodePacked(_user, block.number)), CALLBACK_GAS_LIMIT);\r\n    BetInfo memory _betInfo = BetInfo({\r\n      user: _user,\r\n      tokens: _betAmount,\r\n      stakeBet: _stakeSpin\r\n    });\r\n    betInfo[_queryId] = _betInfo;\r\n    emit BetPlaced(_user, _queryId);\r\n    if (!_stakeSpin) {\r\n      nonStakeTokens += _betAmount;\r\n    }\r\n    betStatus[_user] = true;\r\n    lastQuery[_user] = _queryId;\r\n  }\r\n\r\n\r\n  function _executeSpin(bytes32 _queryId, uint256 _result)\r\n    internal\r\n    gameActive\r\n  {\r\n    require(!queryStatus[_queryId]);\r\n    BetInfo memory _betInfo = betInfo[_queryId];\r\n    address _user = _betInfo.user;\r\n    uint256 _tokens = _betInfo.tokens;\r\n    bool _stakeBet = _betInfo.stakeBet;\r\n\r\n    require(betStatus[_user]);\r\n\r\n    uint256 _userStake = stakeOf(_user);\r\n\r\n    // max bet is 5% of the stake (of everyone else)\r\n    // max win is 4x, 4x5 = 20% of the bankroll monkaS\r\n    require(betPool(_user) > 0);\r\n    if (_tokens > betPool(_user) / 20) {\r\n      _tokens = betPool(_user) / 20;\r\n    }\r\n\r\n    if (_stakeBet) {\r\n      require(_tokens <= _userStake);\r\n    }\r\n\r\n    uint256 _bracket;\r\n    uint256 _return;\r\n    (_bracket, _return) = _calculateReturn(_result, _tokens);\r\n\r\n    if (_return > _tokens) {  // win\r\n      uint256 _won = _return - _tokens;\r\n      _houseLose(_user, _won);\r\n      if (_stakeBet) {\r\n        // scenario 1.1: stake bet win\r\n        personalFactorLedger_[_user] = constantFactor / globalFactor;\r\n        balanceLedger_[_user] = _userStake.add(_won);\r\n      } else {\r\n        // scenario 1.2: direct bet win\r\n        personalFactorLedger_[_user] = constantFactor / globalFactor;\r\n        balanceLedger_[_user] = _userStake; // user stake is unchanged despite global win\r\n        ddn.transfer(_user, _return);\r\n      }\r\n    } else {                 // lose\r\n      uint256 _lost = _tokens - _return;\r\n      _houseWin(_user, _lost);\r\n      if (_stakeBet) {\r\n        // scenario 2.1: stake bet lose\r\n        _userStake = _userStake.sub(_tokens);\r\n        _userStake = _userStake.add(_return);\r\n        balanceLedger_[_user] = _userStake;\r\n        personalFactorLedger_[_user] = constantFactor / globalFactor;\r\n      } else {\r\n        // scenario 2.2: direct bet lose\r\n        personalFactorLedger_[_user] = constantFactor / globalFactor;\r\n        balanceLedger_[_user] = _userStake; // user stake is unchanged despite global loss\r\n        if (_return > 0) {\r\n          ddn.transfer(_user, _return);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!_stakeBet) {\r\n      nonStakeTokens = nonStakeTokens.sub(_betInfo.tokens);\r\n      if (_betInfo.tokens > _tokens) {\r\n        ddn.transfer(_user, _betInfo.tokens - _tokens);\r\n      }\r\n    }\r\n\r\n    uint256 _userPyro = pyro.balanceOf(_user);\r\n    uint256 _bonusPyro = pyro.balanceOf(address(this));\r\n    uint256 _pyroReward = _return * 25; // 25:1 PYRO per DDN won\r\n    _pyroReward = _bonusPyro > _pyroReward ? _pyroReward : _bonusPyro;\r\n    if (_pyroReward > 0) {\r\n      pyro.transfer(_user, _pyroReward);\r\n      _pyroReward = pyro.balanceOf(_user).sub(_userPyro);\r\n    }\r\n\r\n    betStatus[_user] = false;\r\n    queryStatus[_queryId] = true;\r\n    emit BetResolved(_user, _queryId, _tokens, _result, _bracket, _return, _stakeBet, _pyroReward);\r\n  }\r\n\r\n\r\n  function _calculateReturn(uint256 _result, uint256 _tokens)\r\n    internal\r\n    view\r\n    returns (uint256 bracket, uint256 win)\r\n  {\r\n    for (uint256 i = 0; i < brackets.length; i++) {\r\n      if (brackets[i] > _result) {\r\n        bracket = i;\r\n        break;\r\n      }\r\n    }\r\n    if (bracket == 0) { win = _tokens * 5; } // Grand Jackpot 5x\r\n    else if (bracket == 1) { win = _tokens * 3; } // Jackpot 3x\r\n    else if (bracket == 2) { win = _tokens * 2; } // Grand Prize 2x\r\n    else if (bracket == 3) { win = _tokens * 3 / 2; } // Major Prize 1.5x\r\n    else if (bracket == 4) { win = _tokens * 5 / 4; } // Minor Prize 1.25x\r\n    else if (bracket == 5) { win = _tokens * 21 / 20; } // Tiny Prize 1.05x\r\n    else if (bracket == 6) { win = _tokens * 4 / 5; } // Minor Loss 0.8x\r\n    else if (bracket == 7) { win = _tokens * 11 / 20; } // Major Loss 0.55x\r\n    else if (bracket == 8) { win = _tokens / 4; } // Grand Loss 0.25x\r\n    else { win = 0; } // Total Loss 0x\r\n  }\r\n\r\n\r\n  function _houseLose(address _user, uint256 _tokens)\r\n    internal\r\n  {\r\n    uint256 globalDecrease = globalFactor.mul(_tokens) / betPool(_user);\r\n    globalFactor = globalFactor.sub(globalDecrease);\r\n  }\r\n\r\n\r\n  function _houseWin(address _user, uint256 _tokens)\r\n    internal\r\n  {\r\n    uint256 globalIncrease = globalFactor.mul(_tokens) / betPool(_user);\r\n    globalFactor = globalFactor.add(globalIncrease);\r\n  }\r\n\r\n\r\n  function reinvest()\r\n    public\r\n  {\r\n    uint256 _tokens = ddn.reinvest();\r\n    // Increase amount of ddn everyone owns\r\n    uint256 globalIncrease = globalFactor.mul(_tokens) / getBalance();\r\n    globalFactor = globalFactor.add(globalIncrease);\r\n  }\r\n\r\n\r\n  // emergency  /  dev functions\r\n\r\n\r\n  /*\r\n    panicButton and refundUser are here incase of an emergency, or launch of a new contract\r\n    The game will be frozen, and all token holders will be refunded\r\n  */\r\n\r\n  function setCallbackGas(uint256 _newLimit)\r\n    public\r\n    onlyAdmin\r\n  {\r\n    CALLBACK_GAS_LIMIT = _newLimit;\r\n  }\r\n\r\n\r\n  function panicButton()\r\n    public\r\n    onlyAdmin\r\n  {\r\n    if (gamePaused) {\r\n      gamePaused = false;\r\n    } else {\r\n      gamePaused = true;\r\n    }\r\n  }\r\n\r\n\r\n  function refundUser(address _user)\r\n    public\r\n    onlyAdmin\r\n  {\r\n    uint256 _tokens = stakeOf(_user);\r\n    if (_tokens > ddn.balanceOf(address(this))) {\r\n      _tokens = ddn.balanceOf(address(this));\r\n    }\r\n    balanceLedger_[_user] = balanceLedger_[_user].sub(_tokens);\r\n    personalFactorLedger_[_user] = constantFactor / globalFactor;\r\n    ddn.transfer(_user, _tokens);\r\n    emit Withdraw(_user, _tokens);\r\n  }\r\n\r\n\r\n  function withdrawAllPYRO()\r\n    public\r\n    onlyAdmin\r\n  {\r\n    pyro.transfer(address(0x0E7b52B895E3322eF341004DC6CB5C63e1d9b1c5), pyro.balanceOf(address(this)));\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_DDN_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_PYRO_address\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"queryId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"betAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"stakeBet\",\"type\":\"bool\"}],\"name\":\"BetFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"queryId\",\"type\":\"bytes32\"}],\"name\":\"BetPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"queryId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"betAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roll\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bracket\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"win\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"stakeBet\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pyro\",\"type\":\"uint256\"}],\"name\":\"BetResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"allInfoFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bankroll\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userQueryBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userStake\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"betPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gamePaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_result\",\"type\":\"uint256\"}],\"name\":\"modulusCallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"panicButton\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"placeBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"}],\"name\":\"queryFailed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"refundUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setCallbackGas\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stake\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"stakeOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"stakeSpin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenCallback\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAllPYRO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"WheelOfDDN","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005a4e4b5e2e78bf2d9df2cd916106862e5873f819000000000000000000000000dd17d00c4bba48008d49bb4cc292819f5a4282d400000000000000000000000014409b0fc5c7f87b5dad20754fe22d29a3de8217","Library":"","LicenseType":"None","SwarmSource":"bzzr://3ab461234f9ff35f9772ce730d98d9158ab5e7fc8fe54f02f1a01cbfaf65430e"}]}