{"status":"1","message":"OK","result":[{"SourceCode":"/**\n *Submitted for verification at Etherscan.io on 2018-01-17\n*/\n\npragma solidity ^0.4.19;\n\n/*\n    Copyright 2016, Jordi Baylina\n    Contributor: Adrià Massanet <adria@codecontext.io>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n    \n    \n    This is just some extra garbage to check about comments\n*/\n/// Add an extra comment here see if I care\n/// @title Owned\n/// @author Adrià Massanet <adria@codecontext.io>\n/// @notice The Owned contract has an owner address, and provides basic \n///  authorization control functions, this simplifies & the implementation of\n///  user permissions; this contract has three work flows for a change in\n///  ownership, the first requires the new owner to validate that they have the\n///  ability to accept ownership, the second allows the ownership to be\n///  directly transfered without requiring acceptance, and the third allows for\n///  the ownership to be removed to allow for decentralization \ncontract Owned {\n\n    address public owner;\n    address public newOwnerCandidate;\n\n    event OwnershipRequested(address indexed by, address indexed to);\n    event OwnershipTransferred(address indexed from, address indexed to);\n    event OwnershipRemoved();\n\n    /// @dev The constructor sets the `msg.sender` as the`owner` of the contract\n    function Owned() public {\n        owner = msg.sender;\n    }\n\n    /// @dev `owner` is the only address that can call a function with this\n    /// modifier\n    modifier onlyOwner() {\n        require (msg.sender == owner);\n        _;\n    }\n    \n    /// @dev In this 1st option for ownership transfer `proposeOwnership()` must\n    ///  be called first by the current `owner` then `acceptOwnership()` must be\n    ///  called by the `newOwnerCandidate`\n    /// @notice `onlyOwner` Proposes to transfer control of the contract to a\n    ///  new owner\n    /// @param _newOwnerCandidate The address being proposed as the new owner\n    function proposeOwnership(address _newOwnerCandidate) public onlyOwner {\n        newOwnerCandidate = _newOwnerCandidate;\n        OwnershipRequested(msg.sender, newOwnerCandidate);\n    }\n\n    /// @notice Can only be called by the `newOwnerCandidate`, accepts the\n    ///  transfer of ownership\n    function acceptOwnership() public {\n        require(msg.sender == newOwnerCandidate);\n\n        address oldOwner = owner;\n        owner = newOwnerCandidate;\n        newOwnerCandidate = 0x0;\n\n        OwnershipTransferred(oldOwner, owner);\n    }\n\n    /// @dev In this 2nd option for ownership transfer `changeOwnership()` can\n    ///  be called and it will immediately assign ownership to the `newOwner`\n    /// @notice `owner` can step down and assign some other address to this role\n    /// @param _newOwner The address of the new owner\n    function changeOwnership(address _newOwner) public onlyOwner {\n        require(_newOwner != 0x0);\n\n        address oldOwner = owner;\n        owner = _newOwner;\n        newOwnerCandidate = 0x0;\n\n        OwnershipTransferred(oldOwner, owner);\n    }\n\n    /// @dev In this 3rd option for ownership transfer `removeOwnership()` can\n    ///  be called and it will immediately assign ownership to the 0x0 address;\n    ///  it requires a 0xdece be input as a parameter to prevent accidental use\n    /// @notice Decentralizes the contract, this operation cannot be undone \n    /// @param _dac `0xdac` has to be entered for this function to work\n    function removeOwnership(address _dac) public onlyOwner {\n        require(_dac == 0xdac);\n        owner = 0x0;\n        newOwnerCandidate = 0x0;\n        OwnershipRemoved();     \n    }\n} \n\n\n\n/**\n * @title ERC20\n * @dev A standard interface for tokens.\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n */\ncontract ERC20 {\n  \n    /// @dev Returns the total token supply\n    function totalSupply() public constant returns (uint256 supply);\n\n    /// @dev Returns the account balance of the account with address _owner\n    function balanceOf(address _owner) public constant returns (uint256 balance);\n\n    /// @dev Transfers _value number of tokens to address _to\n    function transfer(address _to, uint256 _value) public returns (bool success);\n\n    /// @dev Transfers _value number of tokens from address _from to address _to\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n    /// @dev Allows _spender to withdraw from the msg.sender's account up to the _value amount\n    function approve(address _spender, uint256 _value) public returns (bool success);\n\n    /// @dev Returns the amount which _spender is still allowed to withdraw from _owner\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\n\n/// @dev `Escapable` is a base level contract built off of the `Owned`\n///  contract; it creates an escape hatch function that can be called in an\n///  emergency that will allow designated addresses to send any ether or tokens\n///  held in the contract to an `escapeHatchDestination` as long as they were\n///  not blacklisted\ncontract Escapable is Owned {\n    address public escapeHatchCaller;\n    address public escapeHatchDestination;\n    mapping (address=>bool) private escapeBlacklist; // Token contract addresses\n\n    /// @notice The Constructor assigns the `escapeHatchDestination` and the\n    ///  `escapeHatchCaller`\n    /// @param _escapeHatchCaller The address of a trusted account or contract\n    ///  to call `escapeHatch()` to send the ether in this contract to the\n    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller`\n    ///  cannot move funds out of `escapeHatchDestination`\n    /// @param _escapeHatchDestination The address of a safe location (usu a\n    ///  Multisig) to send the ether held in this contract; if a neutral address\n    ///  is required, the WHG Multisig is an option:\n    ///  0x8Ff920020c8AD673661c8117f2855C384758C572 \n    function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) public {\n        escapeHatchCaller = _escapeHatchCaller;\n        escapeHatchDestination = _escapeHatchDestination;\n    }\n\n    /// @dev The addresses preassigned as `escapeHatchCaller` or `owner`\n    ///  are the only addresses that can call a function with this modifier\n    modifier onlyEscapeHatchCallerOrOwner {\n        require ((msg.sender == escapeHatchCaller)||(msg.sender == owner));\n        _;\n    }\n\n    /// @notice Creates the blacklist of tokens that are not able to be taken\n    ///  out of the contract; can only be done at the deployment, and the logic\n    ///  to add to the blacklist will be in the constructor of a child contract\n    /// @param _token the token contract address that is to be blacklisted \n    function blacklistEscapeToken(address _token) internal {\n        escapeBlacklist[_token] = true;\n        EscapeHatchBlackistedToken(_token);\n    }\n\n    /// @notice Checks to see if `_token` is in the blacklist of tokens\n    /// @param _token the token address being queried\n    /// @return False if `_token` is in the blacklist and can't be taken out of\n    ///  the contract via the `escapeHatch()`\n    function isTokenEscapable(address _token) constant public returns (bool) {\n        return !escapeBlacklist[_token];\n    }\n\n    /// @notice The `escapeHatch()` should only be called as a last resort if a\n    /// security issue is uncovered or something unexpected happened\n    /// @param _token to transfer, use 0x0 for ether\n    function escapeHatch(address _token) public onlyEscapeHatchCallerOrOwner {   \n        require(escapeBlacklist[_token]==false);\n\n        uint256 balance;\n\n        /// @dev Logic for ether\n        if (_token == 0x0) {\n            balance = this.balance;\n            escapeHatchDestination.transfer(balance);\n            EscapeHatchCalled(_token, balance);\n            return;\n        }\n        /// @dev Logic for tokens\n        ERC20 token = ERC20(_token);\n        balance = token.balanceOf(this);\n        require(token.transfer(escapeHatchDestination, balance));\n        EscapeHatchCalled(_token, balance);\n    }\n\n    /// @notice Changes the address assigned to call `escapeHatch()`\n    /// @param _newEscapeHatchCaller The address of a trusted account or\n    ///  contract to call `escapeHatch()` to send the value in this contract to\n    function changeHatchEscapeCaller(address _newEscapeHatchCaller) public onlyEscapeHatchCallerOrOwner {\n        escapeHatchCaller = _newEscapeHatchCaller;\n    }\n\n    event EscapeHatchBlackistedToken(address token);\n    event EscapeHatchCalled(address token, uint amount);\n}\n\n// Copyright (C) 2018 Alon Bukai This program is free software: you \n// can redistribute it and/or modify it under the terms of the GNU General \n// Public License as published by the Free Software Foundation, version. \n// This program is distributed in the hope that it will be useful, \n// but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n// more details. You should have received a copy of the GNU General Public\n// License along with this program. If not, see http://www.gnu.org/licenses/\n\n/// @notice `MultiSend` is a contract for sending multiple ETH/ERC20 Tokens to\n///  multiple addresses. In addition this contract can call multiple contracts\n///  with multiple amounts. There are also TightlyPacked functions which in\n///  some situations allow for gas savings. TightlyPacked is cheaper if you\n///  need to store input data and if amount is less than 12 bytes. Normal is\n///  cheaper if you don't need to store input data or if amounts are greater\n///  than 12 bytes. Supports deterministic deployment. As explained\n///  here: https://github.com/ethereum/EIPs/issues/777#issuecomment-356103528\ncontract MultiSend is Escapable {\n  \n    /// @dev Hardcoded escapeHatchCaller\n    address CALLER = 0x4c1C78a66a3F5C0E4D1DacAeE0608816FCA0C461;\n    /// @dev Hardcoded escapeHatchDestination\n    address DESTINATION = 0x4c1C78a66a3F5C0E4D1DacAeE0608816FCA0C461;\n\n    event MultiTransfer(\n        address indexed _from,\n        uint indexed _value,\n        address _to,\n        uint _amount\n    );\n\n    event MultiCall(\n        address indexed _from,\n        uint indexed _value,\n        address _to,\n        uint _amount\n    );\n\n    event MultiERC20Transfer(\n        address indexed _from,\n        uint indexed _value,\n        address _to,\n        uint _amount,\n        ERC20 _token\n    );\n\n    /// @notice Constructor using Escapable and Hardcoded values\n    function MultiSend() Escapable(CALLER, DESTINATION) public {}\n\n    /// @notice Send to multiple addresses using a byte32 array which\n    ///  includes the address and the amount.\n    ///  Addresses and amounts are stored in a packed bytes32 array\n    ///  Address is stored in the 20 most significant bytes\n    ///  The address is retrieved by bitshifting 96 bits to the right\n    ///  Amount is stored in the 12 least significant bytes\n    ///  The amount is retrieved by taking the 96 least significant bytes\n    ///  and converting them into an unsigned integer\n    ///  Payable\n    /// @param _addressesAndAmounts Bitwise packed array of addresses\n    ///  and amounts\n    function multiTransferTightlyPacked(bytes32[] _addressesAndAmounts)\n    payable public returns(bool)\n    {\n        uint startBalance = this.balance;\n        for (uint i = 0; i < _addressesAndAmounts.length; i++) {\n            address to = address(_addressesAndAmounts[i] >> 96);\n            uint amount = uint(uint96(_addressesAndAmounts[i]));\n            _safeTransfer(to, amount);\n            MultiTransfer(msg.sender, msg.value, to, amount);\n        }\n        require(startBalance - msg.value == this.balance);\n        return true;\n    }\n\n    /// @notice Send to multiple addresses using two arrays which\n    ///  includes the address and the amount.\n    ///  Payable\n    /// @param _addresses Array of addresses to send to\n    /// @param _amounts Array of amounts to send\n    function multiTransfer(address[] _addresses, uint[] _amounts)\n    payable public returns(bool)\n    {\n        uint startBalance = this.balance;\n        for (uint i = 0; i < _addresses.length; i++) {\n            _safeTransfer(_addresses[i], _amounts[i]);\n            MultiTransfer(msg.sender, msg.value, _addresses[i], _amounts[i]);\n        }\n        require(startBalance - msg.value == this.balance);\n        return true;\n    }\n\n    /// @notice Call to multiple contracts using a byte32 array which\n    ///  includes the contract address and the amount.\n    ///  Addresses and amounts are stored in a packed bytes32 array.\n    ///  Address is stored in the 20 most significant bytes.\n    ///  The address is retrieved by bitshifting 96 bits to the right\n    ///  Amount is stored in the 12 least significant bytes.\n    ///  The amount is retrieved by taking the 96 least significant bytes\n    ///  and converting them into an unsigned integer.\n    ///  Payable\n    /// @param _addressesAndAmounts Bitwise packed array of contract\n    ///  addresses and amounts\n    function multiCallTightlyPacked(bytes32[] _addressesAndAmounts)\n    payable public returns(bool)\n    {\n        uint startBalance = this.balance;\n        for (uint i = 0; i < _addressesAndAmounts.length; i++) {\n            address to = address(_addressesAndAmounts[i] >> 96);\n            uint amount = uint(uint96(_addressesAndAmounts[i]));\n            _safeCall(to, amount);\n            MultiCall(msg.sender, msg.value, to, amount);\n        }\n        require(startBalance - msg.value == this.balance);\n        return true;\n    }\n\n    /// @notice Call to multiple contracts using two arrays which\n    ///  includes the contract address and the amount.\n    /// @param _addresses Array of contract addresses to call\n    /// @param _amounts Array of amounts to send\n    function multiCall(address[] _addresses, uint[] _amounts)\n    payable public returns(bool)\n    {\n        uint startBalance = this.balance;\n        for (uint i = 0; i < _addresses.length; i++) {\n            _safeCall(_addresses[i], _amounts[i]);\n            MultiCall(msg.sender, msg.value, _addresses[i], _amounts[i]);\n        }\n        require(startBalance - msg.value == this.balance);\n        return true;\n    }\n\n    /// @notice Send ERC20 tokens to multiple contracts \n    ///  using a byte32 array which includes the address and the amount.\n    ///  Addresses and amounts are stored in a packed bytes32 array.\n    ///  Address is stored in the 20 most significant bytes.\n    ///  The address is retrieved by bitshifting 96 bits to the right\n    ///  Amount is stored in the 12 least significant bytes.\n    ///  The amount is retrieved by taking the 96 least significant bytes\n    ///  and converting them into an unsigned integer.\n    /// @param _token The token to send\n    /// @param _addressesAndAmounts Bitwise packed array of addresses\n    ///  and token amounts\n    function multiERC20TransferTightlyPacked\n    (\n        ERC20 _token,\n        bytes32[] _addressesAndAmounts\n    ) public\n    {\n        for (uint i = 0; i < _addressesAndAmounts.length; i++) {\n            address to = address(_addressesAndAmounts[i] >> 96);\n            uint amount = uint(uint96(_addressesAndAmounts[i]));\n            _safeERC20Transfer(_token, to, amount);\n            MultiERC20Transfer(msg.sender, msg.value, to, amount, _token);\n        }\n    }\n\n    /// @notice Send ERC20 tokens to multiple contracts\n    ///  using two arrays which includes the address and the amount.\n    /// @param _token The token to send\n    /// @param _addresses Array of addresses to send to\n    /// @param _amounts Array of token amounts to send\n    function multiERC20Transfer(\n        ERC20 _token,\n        address[] _addresses,\n        uint[] _amounts\n    ) public\n    {\n        for (uint i = 0; i < _addresses.length; i++) {\n            _safeERC20Transfer(_token, _addresses[i], _amounts[i]);\n            MultiERC20Transfer(\n                msg.sender,\n                msg.value,\n                _addresses[i],\n                _amounts[i],\n                _token\n            );\n        }\n    }\n\n    /// @notice `_safeTransfer` is used internally when transfer funds safely.\n    function _safeTransfer(address _to, uint _amount) internal {\n        require(_to != 0);\n        _to.transfer(_amount);\n    }\n\n    /// @notice `_safeCall` is used internally when call a contract safely.\n    function _safeCall(address _to, uint _amount) internal {\n        require(_to != 0);\n        require(_to.call.value(_amount)());\n    }\n\n    /// @notice `_safeERC20Transfer` is used internally when\n    ///  transfer a quantity of ERC20 tokens.\n    function _safeERC20Transfer(ERC20 _token, address _to, uint _amount)\n    internal\n    {\n        require(_to != 0);\n        require(_token.transferFrom(msg.sender, _to, _amount));\n    }\n\n    /// @dev Default payable function to not allow sending to contract;\n    ///  remember this does not necesarily prevent the contract\n    ///  from accumulating funds.\n    function () public payable {\n        revert();\n    }\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"multiCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"multiTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escapeHatchCaller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressesAndAmounts\",\"type\":\"bytes32[]\"}],\"name\":\"multiTransferTightlyPacked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"multiERC20Transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dac\",\"type\":\"address\"}],\"name\":\"removeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwnerCandidate\",\"type\":\"address\"}],\"name\":\"proposeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"isTokenEscapable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"escapeHatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressesAndAmounts\",\"type\":\"bytes32[]\"}],\"name\":\"multiCallTightlyPacked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwnerCandidate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newEscapeHatchCaller\",\"type\":\"address\"}],\"name\":\"changeHatchEscapeCaller\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escapeHatchDestination\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_addressesAndAmounts\",\"type\":\"bytes32[]\"}],\"name\":\"multiERC20TransferTightlyPacked\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"MultiTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"MultiCall\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"MultiERC20Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"}],\"name\":\"EscapeHatchBlackistedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EscapeHatchCalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OwnershipRemoved\",\"type\":\"event\"}]","ContractName":"MultiSend","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":""}]}