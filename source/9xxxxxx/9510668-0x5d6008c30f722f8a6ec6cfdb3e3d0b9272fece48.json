{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.22 <0.7.0;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n \r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Owner\r\n * @dev Set & change owner\r\n */\r\ncontract Owner {\r\n\r\n    address private owner;\r\n    \r\n    // event for EVM logging\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    \r\n    // modifier to check if caller is owner\r\n    modifier isOwner() {\r\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\r\n        // changes to the state and to Ether balances are reverted.\r\n        // This used to consume all gas in old EVM versions, but not anymore.\r\n        // It is often a good idea to use 'require' to check if functions are called correctly.\r\n        // As a second argument, you can also provide an explanation about what went wrong.\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public isOwner {\r\n        emit OwnerSet(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address \r\n     * @return address of owner\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract Zdzmedia is Owner{\r\n  \r\n    struct  Record{\r\n        address payable buyer;\r\n        uint256 amount; \r\n        bool isSend;\r\n        uint buyTime;\r\n        bool isBuy;\r\n        uint endTime;\r\n    }\r\n \r\n   using SafeMath for uint256 ;\r\n \r\n    Owner public creator;\r\n\r\n\r\n    mapping( address =>  Record) public records;\r\n    \r\n    \r\n    constructor() public {\r\n        creator = Owner(msg.sender); \r\n    }\r\n    \r\n   function() payable external{\r\n        require(msg.sender != address(0));\r\n        if(msg.value>=0.0001 ether && msg.value <= 0.0005 ether){\r\n            require(!records[msg.sender].isBuy,\r\n            \"you already buy.\");   \r\n \r\n          records[msg.sender] = Record({\r\n                buyer: msg.sender,\r\n                amount: msg.value,\r\n                isSend:false,\r\n                buyTime: now,\r\n                isBuy:true,\r\n                endTime:0\r\n            });\r\n        }\r\n    }\r\n\r\n     \r\n     function  send(address toaddress) public returns (bool)  {\r\n         uint n = now;\r\n         require(records[toaddress].amount > 0,\"amount is 0\");\r\n         require(records[toaddress].isBuy,\"not buy\");\r\n         require(!records[toaddress].isSend,\"record is sended\");\r\n         \r\n         Record memory record  = records[toaddress];  \r\n         if ((record.buyTime + 1 minutes)  <= n && !record.isSend) {\r\n             uint256 eth = record.amount.div(100)*2;\r\n             eth = record.amount.add(eth);\r\n             require(address(this).balance >= eth,\"Insufficient contract balance\");\r\n             records[toaddress].isSend = true;\r\n             records[toaddress].endTime = now;\r\n             \r\n             records[toaddress].buyer.transfer(eth);\r\n             return true;\r\n         }\r\n         \r\n         return false;\r\n     }\r\n    \r\n    \r\n     \r\n     \r\n     function kill() public isOwner{\r\n         selfdestruct( msg.sender);\r\n     }\r\n     \r\n     function getBalance() external view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toaddress\",\"type\":\"address\"}],\"name\":\"send\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"records\",\"outputs\":[{\"name\":\"buyer\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"isSend\",\"type\":\"bool\"},{\"name\":\"buyTime\",\"type\":\"uint256\"},{\"name\":\"isBuy\",\"type\":\"bool\"},{\"name\":\"endTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"}]","ContractName":"Zdzmedia","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://fdc7400aebf930ea94d012496feb1eb89a69eced65c4ff9ca16844311d3968e3"}]}