{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.2;\r\n\r\ncontract Savings {\r\n\tmapping(address => mapping(address => uint256)) private balances;\r\n\tmapping(address => mapping(address => uint)) private experations;\r\n\r\n\r\n    // Function to deposit currency to the contract\r\n    // _duration is in blocks from current\r\n\tfunction deposit(address _tokenAddress, uint256 _amount, uint _duration) public returns (bool success) {\r\n\r\n\r\n\t\t// Require that user doesn't have any pending balances in this token\r\n\t\trequire(balances[msg.sender][_tokenAddress] == 0, \"You can't have two pending pools with the same currency\");\r\n\r\n\t\t// Check that we have allowance to transfer tokens\r\n\t\trequire(ERC20Interface(_tokenAddress).allowance(msg.sender,address(this)) >= _amount, \"Allowance is too low for this transaction\");\r\n\r\n\t\t// Check that user has requested balance\r\n\t\trequire(ERC20Interface(_tokenAddress).balanceOf(msg.sender) >= _amount,\"Wallet balance is too low for this transaction\");\r\n\r\n\r\n\t\t// Good to go, execute transaction\r\n\t\t\r\n\r\n\t\t// transfer tokens to this contract\r\n\t\trequire(ERC20Interface(_tokenAddress).transferFrom(msg.sender,address(this),_amount));\r\n\r\n\t\t// Experation is current block plus duration\r\n\t\tuint experation = block.number + _duration;\r\n\t\tassert(experation > block.number);\r\n\r\n\t\tbalances[msg.sender][_tokenAddress] = _amount;\r\n\t\texperations[msg.sender][_tokenAddress] = experation;\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction withdraw(address _tokenAddress) public returns (bool success) {\r\n\t\t//Require that value is not zero\r\n\t\trequire(balances[msg.sender][_tokenAddress] > 0, \"Sender does not own any of specified token in Savings contract\");\r\n\r\n\t\t// Require that term has ended\r\n\t\trequire(experations[msg.sender][_tokenAddress] <= block.number, \"The term has not ended yet\");\r\n\r\n\t\t// Store amount to send back then clear before sending. Protects against attack.\r\n\t\tuint256 withdrawalAmount = balances[msg.sender][_tokenAddress];\r\n\r\n\t\t// Clear term from contract\r\n\t\tbalances[msg.sender][_tokenAddress] = 0;\r\n\r\n\t\t// Send back tokens\r\n\t\trequire(ERC20Interface(_tokenAddress).transfer(msg.sender,withdrawalAmount));\r\n\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\n\r\ninterface ERC20Interface {\r\n\tfunction totalSupply() external view returns (uint supply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    function decimals() external view returns(uint digits);\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Savings","CompilerVersion":"v0.6.2+commit.bacdbe57","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"ipfs://7e9bec656f19a9fd3f527be89bc3ca130f6e43d84509388756f23d33a3b09819"}]}