{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.13;\n\n\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        \n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        \n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ncontract Context {\n    \n    \n    constructor () internal { }\n    \n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; \n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \n    constructor () internal {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    \n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    \n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    \n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    \n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    \n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract ReentrancyGuard {\n    \n    uint256 private _guardCounter;\n\n    constructor () internal {\n        \n        \n        _guardCounter = 1;\n    }\n\n    \n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n\ninterface IMiniMeToken {\n    function balanceOf(address _owner) external view returns (uint256 balance);\n    function totalSupply() external view returns(uint);\n    function generateTokens(address _owner, uint _amount) external returns (bool);\n    function destroyTokens(address _owner, uint _amount) external returns (bool);\n    function totalSupplyAt(uint _blockNumber) external view returns(uint);\n    function balanceOfAt(address _holder, uint _blockNumber) external view returns (uint);\n    function transferOwnership(address newOwner) external;\n}\n\ncontract TokenController {\n  \n  \n  \n  function proxyPayment(address _owner) public payable returns(bool);\n\n  \n  \n  \n  \n  \n  \n  function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n\n  \n  \n  \n  \n  \n  \n  function onApprove(address _owner, address _spender, uint _amount) public\n    returns(bool);\n}\n\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n\n    \n    function balanceOf(address account) external view returns (uint256);\n\n    \n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    \n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    \n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    \n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    \n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\nlibrary Address {\n    \n    function isContract(address account) internal view returns (bool) {\n        \n        \n        \n\n        \n        \n        \n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        \n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n\n    \n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    \n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        \n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        \n        \n        \n        \n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    \n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        \n        \n\n        \n        \n        \n        \n        \n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        \n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { \n            \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ninterface KyberNetwork {\n  function getExpectedRate(ERC20Detailed src, ERC20Detailed dest, uint srcQty) external view\n      returns (uint expectedRate, uint slippageRate);\n\n  function tradeWithHint(\n    ERC20Detailed src, uint srcAmount, ERC20Detailed dest, address payable destAddress, uint maxDestAmount,\n    uint minConversionRate, address walletId, bytes calldata hint) external payable returns(uint);\n}\n\ncontract Utils {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20Detailed;\n\n  \n  modifier isValidToken(address _token) {\n    require(_token != address(0));\n    if (_token != address(ETH_TOKEN_ADDRESS)) {\n      require(isContract(_token));\n    }\n    _;\n  }\n\n  address public DAI_ADDR;\n  address payable public KYBER_ADDR;\n  address payable public DEXAG_ADDR;\n\n  bytes public constant PERM_HINT = \"PERM\";\n\n  ERC20Detailed internal constant ETH_TOKEN_ADDRESS = ERC20Detailed(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n  ERC20Detailed internal dai;\n  KyberNetwork internal kyber;\n\n  uint constant internal PRECISION = (10**18);\n  uint constant internal MAX_QTY   = (10**28); \n  uint constant internal ETH_DECIMALS = 18;\n  uint constant internal MAX_DECIMALS = 18;\n\n  constructor(\n    address _daiAddr,\n    address payable _kyberAddr,\n    address payable _dexagAddr\n  ) public {\n    DAI_ADDR = _daiAddr;\n    KYBER_ADDR = _kyberAddr;\n    DEXAG_ADDR = _dexagAddr;\n\n    dai = ERC20Detailed(_daiAddr);\n    kyber = KyberNetwork(_kyberAddr);\n  }\n\n  \n  function getDecimals(ERC20Detailed _token) internal view returns(uint256) {\n    if (address(_token) == address(ETH_TOKEN_ADDRESS)) {\n      return uint256(ETH_DECIMALS);\n    }\n    return uint256(_token.decimals());\n  }\n\n  \n  function getBalance(ERC20Detailed _token, address _addr) internal view returns(uint256) {\n    if (address(_token) == address(ETH_TOKEN_ADDRESS)) {\n      return uint256(_addr.balance);\n    }\n    return uint256(_token.balanceOf(_addr));\n  }\n\n  \n  function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\n        internal pure returns(uint)\n  {\n    require(srcAmount <= MAX_QTY);\n    require(destAmount <= MAX_QTY);\n\n    if (dstDecimals >= srcDecimals) {\n      require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n      return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\n    } else {\n      require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n      return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\n    }\n  }\n\n  \n  function __kyberTrade(ERC20Detailed _srcToken, uint256 _srcAmount, ERC20Detailed _destToken)\n    internal\n    returns(\n      uint256 _destPriceInSrc,\n      uint256 _srcPriceInDest,\n      uint256 _actualDestAmount,\n      uint256 _actualSrcAmount\n    )\n  {\n    require(_srcToken != _destToken);\n\n    uint256 beforeSrcBalance = getBalance(_srcToken, address(this));\n    uint256 msgValue;\n    if (_srcToken != ETH_TOKEN_ADDRESS) {\n      msgValue = 0;\n      _srcToken.safeApprove(KYBER_ADDR, 0);\n      _srcToken.safeApprove(KYBER_ADDR, _srcAmount);\n    } else {\n      msgValue = _srcAmount;\n    }\n    _actualDestAmount = kyber.tradeWithHint.value(msgValue)(\n      _srcToken,\n      _srcAmount,\n      _destToken,\n      toPayableAddr(address(this)),\n      MAX_QTY,\n      1,\n      0x332D87209f7c8296389C307eAe170c2440830A47,\n      PERM_HINT\n    );\n    _actualSrcAmount = beforeSrcBalance.sub(getBalance(_srcToken, address(this)));\n    require(_actualDestAmount > 0 && _actualSrcAmount > 0);\n    _destPriceInSrc = calcRateFromQty(_actualDestAmount, _actualSrcAmount, getDecimals(_destToken), getDecimals(_srcToken));\n    _srcPriceInDest = calcRateFromQty(_actualSrcAmount, _actualDestAmount, getDecimals(_srcToken), getDecimals(_destToken));\n  }\n\n  \n  function __dexagTrade(ERC20Detailed _srcToken, uint256 _srcAmount, ERC20Detailed _destToken, bytes memory _calldata)\n    internal\n    returns(\n      uint256 _destPriceInSrc,\n      uint256 _srcPriceInDest,\n      uint256 _actualDestAmount,\n      uint256 _actualSrcAmount\n    )\n  {\n    require(_srcToken != _destToken);\n\n    uint256 beforeSrcBalance = getBalance(_srcToken, address(this));\n    uint256 beforeDestBalance = getBalance(_destToken, address(this));\n    \n    if (_srcToken != ETH_TOKEN_ADDRESS) {\n      _actualSrcAmount = 0;\n      _srcToken.safeApprove(DEXAG_ADDR, 0);\n      _srcToken.safeApprove(DEXAG_ADDR, _srcAmount);\n    } else {\n      _actualSrcAmount = _srcAmount;\n    }\n\n    \n    (bool success,) = DEXAG_ADDR.call.value(_actualSrcAmount)(_calldata);\n    require(success);\n\n    \n    _actualDestAmount = beforeDestBalance.sub(getBalance(_destToken, address(this)));\n    _actualSrcAmount = beforeSrcBalance.sub(getBalance(_srcToken, address(this)));\n    require(_actualDestAmount > 0 && _actualSrcAmount > 0);\n    _destPriceInSrc = calcRateFromQty(_actualDestAmount, _actualSrcAmount, getDecimals(_destToken), getDecimals(_srcToken));\n    _srcPriceInDest = calcRateFromQty(_actualSrcAmount, _actualDestAmount, getDecimals(_srcToken), getDecimals(_destToken));\n\n    \n    (, uint256 kyberSrcPriceInDest) = kyber.getExpectedRate(_srcToken, _destToken, _srcAmount);\n    require(kyberSrcPriceInDest > 0 && _srcPriceInDest >= kyberSrcPriceInDest);\n  }\n\n  \n  function isContract(address _addr) internal view returns(bool) {\n    uint size;\n    if (_addr == address(0)) return false;\n    assembly {\n        size := extcodesize(_addr)\n    }\n    return size>0;\n  }\n\n  function toPayableAddr(address _addr) internal pure returns (address payable) {\n    return address(uint160(_addr));\n  }\n}\n\ninterface BetokenProxyInterface {\n  function betokenFundAddress() external view returns (address payable);\n  function updateBetokenFundAddress() external;\n}\n\ninterface ScdMcdMigration {\n  \n  \n  \n  function swapSaiToDai(\n    uint wad\n  ) external;\n}\n\ncontract BetokenStorage is Ownable, ReentrancyGuard {\n  using SafeMath for uint256;\n\n  enum CyclePhase { Intermission, Manage }\n  enum VoteDirection { Empty, For, Against }\n  enum Subchunk { Propose, Vote }\n\n  struct Investment {\n    address tokenAddress;\n    uint256 cycleNumber;\n    uint256 stake;\n    uint256 tokenAmount;\n    uint256 buyPrice; \n    uint256 sellPrice; \n    uint256 buyTime;\n    uint256 buyCostInDAI;\n    bool isSold;\n  }\n\n  \n  uint256 public constant COMMISSION_RATE = 20 * (10 ** 16); \n  uint256 public constant ASSET_FEE_RATE = 1 * (10 ** 15); \n  uint256 public constant NEXT_PHASE_REWARD = 1 * (10 ** 18); \n  uint256 public constant MAX_BUY_KRO_PROP = 1 * (10 ** 16); \n  uint256 public constant FALLBACK_MAX_DONATION = 100 * (10 ** 18); \n  uint256 public constant MIN_KRO_PRICE = 25 * (10 ** 17); \n  uint256 public constant COLLATERAL_RATIO_MODIFIER = 75 * (10 ** 16); \n  uint256 public constant MIN_RISK_TIME = 3 days; \n  uint256 public constant INACTIVE_THRESHOLD = 2; \n  uint256 public constant ROI_PUNISH_THRESHOLD = 1 * (10 ** 17); \n  uint256 public constant ROI_BURN_THRESHOLD = 25 * (10 ** 16); \n  uint256 public constant ROI_PUNISH_SLOPE = 6; \n  uint256 public constant ROI_PUNISH_NEG_BIAS = 5 * (10 ** 17); \n  \n  uint256 public constant CHUNK_SIZE = 3 days;\n  uint256 public constant PROPOSE_SUBCHUNK_SIZE = 1 days;\n  uint256 public constant CYCLES_TILL_MATURITY = 3;\n  uint256 public constant QUORUM = 10 * (10 ** 16); \n  uint256 public constant VOTE_SUCCESS_THRESHOLD = 75 * (10 ** 16); \n\n  \n\n  \n  bool public hasInitializedTokenListings;\n\n  \n  bool public isInitialized;\n\n  \n  address public controlTokenAddr;\n\n  \n  address public shareTokenAddr;\n\n  \n  address payable public proxyAddr;\n\n  \n  address public compoundFactoryAddr;\n\n  \n  address public betokenLogic;\n  address public betokenLogic2;\n\n  \n  address payable public devFundingAccount;\n\n  \n  address payable public previousVersion;\n\n  \n  address public saiAddr;\n\n  \n  uint256 public cycleNumber;\n\n  \n  uint256 public totalFundsInDAI;\n\n  \n  uint256 public startTimeOfCyclePhase;\n\n  \n  uint256 public devFundingRate;\n\n  \n  uint256 public totalCommissionLeft;\n\n  \n  uint256[2] public phaseLengths;\n\n  \n  mapping(address => uint256) internal _lastCommissionRedemption;\n\n  \n  mapping(address => mapping(uint256 => bool)) internal _hasRedeemedCommissionForCycle;\n\n  \n  mapping(address => mapping(uint256 => uint256)) internal _riskTakenInCycle;\n\n  \n  mapping(address => uint256) internal _baseRiskStakeFallback;\n\n  \n  mapping(address => Investment[]) public userInvestments;\n\n  \n  mapping(address => address payable[]) public userCompoundOrders;\n\n  \n  mapping(uint256 => uint256) internal _totalCommissionOfCycle;\n\n  \n  mapping(uint256 => uint256) internal _managePhaseEndBlock;\n\n  \n  mapping(address => uint256) internal _lastActiveCycle;\n\n  \n  mapping(address => bool) public isKyberToken;\n\n  \n  mapping(address => bool) public isCompoundToken;\n\n  \n  mapping(address => bool) public isPositionToken;\n\n  \n  CyclePhase public cyclePhase;\n\n  \n  bool public hasFinalizedNextVersion; \n  bool public upgradeVotingActive; \n  address payable public nextVersion; \n  address[5] public proposers; \n  address payable[5] public candidates; \n  uint256[5] public forVotes; \n  uint256[5] public againstVotes; \n  uint256 public proposersVotingWeight; \n  mapping(uint256 => mapping(address => VoteDirection[5])) public managerVotes; \n  mapping(uint256 => uint256) public upgradeSignalStrength; \n  mapping(uint256 => mapping(address => bool)) public upgradeSignal; \n\n  \n  IMiniMeToken internal cToken;\n  IMiniMeToken internal sToken;\n  BetokenProxyInterface internal proxy;\n  ScdMcdMigration internal mcdaiMigration;\n\n  \n\n  event ChangedPhase(uint256 indexed _cycleNumber, uint256 indexed _newPhase, uint256 _timestamp, uint256 _totalFundsInDAI);\n\n  event Deposit(uint256 indexed _cycleNumber, address indexed _sender, address _tokenAddress, uint256 _tokenAmount, uint256 _daiAmount, uint256 _timestamp);\n  event Withdraw(uint256 indexed _cycleNumber, address indexed _sender, address _tokenAddress, uint256 _tokenAmount, uint256 _daiAmount, uint256 _timestamp);\n\n  event CreatedInvestment(uint256 indexed _cycleNumber, address indexed _sender, uint256 _id, address _tokenAddress, uint256 _stakeInWeis, uint256 _buyPrice, uint256 _costDAIAmount, uint256 _tokenAmount);\n  event SoldInvestment(uint256 indexed _cycleNumber, address indexed _sender, uint256 _id, address _tokenAddress, uint256 _receivedKairo, uint256 _sellPrice, uint256 _earnedDAIAmount);\n\n  event CreatedCompoundOrder(uint256 indexed _cycleNumber, address indexed _sender, uint256 _id, address _order, bool _orderType, address _tokenAddress, uint256 _stakeInWeis, uint256 _costDAIAmount);\n  event SoldCompoundOrder(uint256 indexed _cycleNumber, address indexed _sender, uint256 _id, address _order,  bool _orderType, address _tokenAddress, uint256 _receivedKairo, uint256 _earnedDAIAmount);\n  event RepaidCompoundOrder(uint256 indexed _cycleNumber, address indexed _sender, uint256 _id, address _order, uint256 _repaidDAIAmount);\n\n  event CommissionPaid(uint256 indexed _cycleNumber, address indexed _sender, uint256 _commission);\n  event TotalCommissionPaid(uint256 indexed _cycleNumber, uint256 _totalCommissionInDAI);\n\n  event Register(address indexed _manager, uint256 _donationInDAI, uint256 _kairoReceived);\n\n  event SignaledUpgrade(uint256 indexed _cycleNumber, address indexed _sender, bool indexed _inSupport);\n  event DeveloperInitiatedUpgrade(uint256 indexed _cycleNumber, address _candidate);\n  event InitiatedUpgrade(uint256 indexed _cycleNumber);\n  event ProposedCandidate(uint256 indexed _cycleNumber, uint256 indexed _voteID, address indexed _sender, address _candidate);\n  event Voted(uint256 indexed _cycleNumber, uint256 indexed _voteID, address indexed _sender, bool _inSupport, uint256 _weight);\n  event FinalizedNextVersion(uint256 indexed _cycleNumber, address _nextVersion);\n\n  \n\n  \n  function currentChunk() public view returns (uint) {\n    if (cyclePhase != CyclePhase.Manage) {\n      return 0;\n    }\n    return (now - startTimeOfCyclePhase) / CHUNK_SIZE;\n  }\n\n  \n  function currentSubchunk() public view returns (Subchunk _subchunk) {\n    if (cyclePhase != CyclePhase.Manage) {\n      return Subchunk.Vote;\n    }\n    uint256 timeIntoCurrChunk = (now - startTimeOfCyclePhase) % CHUNK_SIZE;\n    return timeIntoCurrChunk < PROPOSE_SUBCHUNK_SIZE ? Subchunk.Propose : Subchunk.Vote;\n  }\n\n  \n  function getVotingWeight(address _of) public view returns (uint256 _weight) {\n    if (cycleNumber <= CYCLES_TILL_MATURITY || _of == address(0)) {\n      return 0;\n    }\n    return cToken.balanceOfAt(_of, managePhaseEndBlock(cycleNumber.sub(CYCLES_TILL_MATURITY)));\n  }\n\n  \n  function getTotalVotingWeight() public view returns (uint256 _weight) {\n    if (cycleNumber <= CYCLES_TILL_MATURITY) {\n      return 0;\n    }\n    return cToken.totalSupplyAt(managePhaseEndBlock(cycleNumber.sub(CYCLES_TILL_MATURITY))).sub(proposersVotingWeight);\n  }\n\n  \n  function kairoPrice() public view returns (uint256 _kairoPrice) {\n    if (cToken.totalSupply() == 0) { return MIN_KRO_PRICE; }\n    uint256 controlPerKairo = totalFundsInDAI.mul(10 ** 18).div(cToken.totalSupply());\n    if (controlPerKairo < MIN_KRO_PRICE) {\n      \n      return MIN_KRO_PRICE;\n    }\n    return controlPerKairo;\n  }\n\n  function lastCommissionRedemption(address _manager) public view returns (uint256) {\n    if (_lastCommissionRedemption[_manager] == 0) {\n      return previousVersion == address(0) ? 0 : BetokenStorage(previousVersion).lastCommissionRedemption(_manager);\n    }\n    return _lastCommissionRedemption[_manager];\n  }\n\n  function hasRedeemedCommissionForCycle(address _manager, uint256 _cycle) public view returns (bool) {\n    if (_hasRedeemedCommissionForCycle[_manager][_cycle] == false) {\n      return previousVersion == address(0) ? false : BetokenStorage(previousVersion).hasRedeemedCommissionForCycle(_manager, _cycle);\n    }\n    return _hasRedeemedCommissionForCycle[_manager][_cycle];\n  }\n\n  function riskTakenInCycle(address _manager, uint256 _cycle) public view returns (uint256) {\n    if (_riskTakenInCycle[_manager][_cycle] == 0) {\n      return previousVersion == address(0) ? 0 : BetokenStorage(previousVersion).riskTakenInCycle(_manager, _cycle);\n    }\n    return _riskTakenInCycle[_manager][_cycle];\n  }\n\n  function baseRiskStakeFallback(address _manager) public view returns (uint256) {\n    if (_baseRiskStakeFallback[_manager] == 0) {\n      return previousVersion == address(0) ? 0 : BetokenStorage(previousVersion).baseRiskStakeFallback(_manager);\n    }\n    return _baseRiskStakeFallback[_manager];\n  }\n\n  function totalCommissionOfCycle(uint256 _cycle) public view returns (uint256) {\n    if (_totalCommissionOfCycle[_cycle] == 0) {\n      return previousVersion == address(0) ? 0 : BetokenStorage(previousVersion).totalCommissionOfCycle(_cycle);\n    }\n    return _totalCommissionOfCycle[_cycle];\n  }\n\n  function managePhaseEndBlock(uint256 _cycle) public view returns (uint256) {\n    if (_managePhaseEndBlock[_cycle] == 0) {\n      return previousVersion == address(0) ? 0 : BetokenStorage(previousVersion).managePhaseEndBlock(_cycle);\n    }\n    return _managePhaseEndBlock[_cycle];\n  }\n\n  function lastActiveCycle(address _manager) public view returns (uint256) {\n    if (_lastActiveCycle[_manager] == 0) {\n      return previousVersion == address(0) ? 0 : BetokenStorage(previousVersion).lastActiveCycle(_manager);\n    }\n    return _lastActiveCycle[_manager];\n  }\n}\n\ninterface PositionToken {\n  function mintWithToken(\n    address receiver,\n    address depositTokenAddress,\n    uint256 depositAmount,\n    uint256 maxPriceAllowed)\n    external\n    returns (uint256);\n\n  function burnToToken(\n    address receiver,\n    address burnTokenAddress,\n    uint256 burnAmount,\n    uint256 minPriceAllowed)\n    external\n    returns (uint256);\n\n  function tokenPrice()\n   external\n   view\n   returns (uint256 price);\n\n  function liquidationPrice()\n   external\n   view\n   returns (uint256 price);\n\n  function currentLeverage()\n    external\n    view\n    returns (uint256 leverage);\n\n  function decimals()\n    external\n    view\n    returns (uint8);\n\n  function balanceOf(address account)\n    external\n    view\n    returns (uint256);\n}\n\ninterface Comptroller {\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\n    function markets(address cToken) external view returns (bool isListed, uint256 collateralFactorMantissa);\n}\n\ninterface PriceOracle {\n  function getUnderlyingPrice(address cToken) external view returns (uint);\n}\n\ninterface CERC20 {\n  function mint(uint mintAmount) external returns (uint);\n  function redeemUnderlying(uint redeemAmount) external returns (uint);\n  function borrow(uint borrowAmount) external returns (uint);\n  function repayBorrow(uint repayAmount) external returns (uint);\n  function borrowBalanceCurrent(address account) external returns (uint);\n  function exchangeRateCurrent() external returns (uint);\n\n  function balanceOf(address account) external view returns (uint);\n  function decimals() external view returns (uint);\n  function underlying() external view returns (address);\n}\n\ninterface CEther {\n  function mint() external payable;\n  function redeemUnderlying(uint redeemAmount) external returns (uint);\n  function borrow(uint borrowAmount) external returns (uint);\n  function repayBorrow() external payable;\n  function borrowBalanceCurrent(address account) external returns (uint);\n  function exchangeRateCurrent() external returns (uint);\n\n  function balanceOf(address account) external view returns (uint);\n  function decimals() external view returns (uint);\n}\n\ncontract CompoundOrder is Utils(address(0), address(0), address(0)), Ownable {\n  \n  uint256 internal constant NEGLIGIBLE_DEBT = 10 ** 14; \n  uint256 internal constant MAX_REPAY_STEPS = 3; \n  uint256 internal constant DEFAULT_LIQUIDITY_SLIPPAGE = 10 ** 12; \n  uint256 internal constant FALLBACK_LIQUIDITY_SLIPPAGE = 10 ** 15; \n  uint256 internal constant MAX_LIQUIDITY_SLIPPAGE = 10 ** 17; \n\n  \n  Comptroller public COMPTROLLER; \n  PriceOracle public ORACLE; \n  CERC20 public CDAI; \n  address public CETH_ADDR;\n\n  \n  uint256 public stake;\n  uint256 public collateralAmountInDAI;\n  uint256 public loanAmountInDAI;\n  uint256 public cycleNumber;\n  uint256 public buyTime; \n  uint256 public outputAmount; \n  address public compoundTokenAddr;\n  bool public isSold;\n  bool public orderType; \n  bool internal initialized;\n\n\n  constructor() public {}\n\n  function init(\n    address _compoundTokenAddr,\n    uint256 _cycleNumber,\n    uint256 _stake,\n    uint256 _collateralAmountInDAI,\n    uint256 _loanAmountInDAI,\n    bool _orderType,\n    address _daiAddr,\n    address payable _kyberAddr,\n    address _comptrollerAddr,\n    address _priceOracleAddr,\n    address _cDAIAddr,\n    address _cETHAddr\n  ) public {\n    require(!initialized);\n    initialized = true;\n    \n    \n    require(_compoundTokenAddr != _cDAIAddr);\n    require(_stake > 0 && _collateralAmountInDAI > 0 && _loanAmountInDAI > 0); \n    stake = _stake;\n    collateralAmountInDAI = _collateralAmountInDAI;\n    loanAmountInDAI = _loanAmountInDAI;\n    cycleNumber = _cycleNumber;\n    compoundTokenAddr = _compoundTokenAddr;\n    orderType = _orderType;\n\n    COMPTROLLER = Comptroller(_comptrollerAddr);\n    ORACLE = PriceOracle(_priceOracleAddr);\n    CDAI = CERC20(_cDAIAddr);\n    CETH_ADDR = _cETHAddr;\n    DAI_ADDR = _daiAddr;\n    KYBER_ADDR = _kyberAddr;\n    dai = ERC20Detailed(_daiAddr);\n    kyber = KyberNetwork(_kyberAddr);\n\n    \n    _transferOwnership(msg.sender);\n  }\n\n  \n  function executeOrder(uint256 _minPrice, uint256 _maxPrice) public;\n\n  \n  function sellOrder(uint256 _minPrice, uint256 _maxPrice) public returns (uint256 _inputAmount, uint256 _outputAmount);\n\n  \n  function repayLoan(uint256 _repayAmountInDAI) public;\n\n  function getMarketCollateralFactor() public view returns (uint256);\n\n  function getCurrentCollateralInDAI() public returns (uint256 _amount);\n\n  function getCurrentBorrowInDAI() public returns (uint256 _amount);\n\n  function getCurrentCashInDAI() public view returns (uint256 _amount);\n\n  \n  function getCurrentProfitInDAI() public returns (bool _isNegative, uint256 _amount) {\n    uint256 l;\n    uint256 r;\n    if (isSold) {\n      l = outputAmount;\n      r = collateralAmountInDAI;\n    } else {\n      uint256 cash = getCurrentCashInDAI();\n      uint256 supply = getCurrentCollateralInDAI();\n      uint256 borrow = getCurrentBorrowInDAI();\n      if (cash >= borrow) {\n        l = supply.add(cash);\n        r = borrow.add(collateralAmountInDAI);\n      } else {\n        l = supply;\n        r = borrow.sub(cash).mul(PRECISION).div(getMarketCollateralFactor()).add(collateralAmountInDAI);\n      }\n    }\n    \n    if (l >= r) {\n      return (false, l.sub(r));\n    } else {\n      return (true, r.sub(l));\n    }\n  }\n\n  \n  function getCurrentCollateralRatioInDAI() public returns (uint256 _amount) {\n    uint256 supply = getCurrentCollateralInDAI();\n    uint256 borrow = getCurrentBorrowInDAI();\n    if (borrow == 0) {\n      return uint256(-1);\n    }\n    return supply.mul(PRECISION).div(borrow);\n  }\n\n  \n  function getCurrentLiquidityInDAI() public returns (bool _isNegative, uint256 _amount) {\n    uint256 supply = getCurrentCollateralInDAI();\n    uint256 borrow = getCurrentBorrowInDAI().mul(PRECISION).div(getMarketCollateralFactor());\n    if (supply >= borrow) {\n      return (false, supply.sub(borrow));\n    } else {\n      return (true, borrow.sub(supply));\n    }\n  }\n\n  function __sellDAIForToken(uint256 _daiAmount) internal returns (uint256 _actualDAIAmount, uint256 _actualTokenAmount) {\n    ERC20Detailed t = __underlyingToken(compoundTokenAddr);\n    (,, _actualTokenAmount, _actualDAIAmount) = __kyberTrade(dai, _daiAmount, t); \n    require(_actualDAIAmount > 0 && _actualTokenAmount > 0); \n  }\n\n  function __sellTokenForDAI(uint256 _tokenAmount) internal returns (uint256 _actualDAIAmount, uint256 _actualTokenAmount) {\n    ERC20Detailed t = __underlyingToken(compoundTokenAddr);\n    (,, _actualDAIAmount, _actualTokenAmount) = __kyberTrade(t, _tokenAmount, dai); \n    require(_actualDAIAmount > 0 && _actualTokenAmount > 0); \n  }\n\n  \n  function __daiToToken(address _cToken, uint256 _daiAmount) internal view returns (uint256) {\n    if (_cToken == CETH_ADDR) {\n      \n      return _daiAmount.mul(ORACLE.getUnderlyingPrice(address(CDAI))).div(PRECISION);\n    }\n    ERC20Detailed t = __underlyingToken(_cToken);\n    return _daiAmount.mul(ORACLE.getUnderlyingPrice(address(CDAI))).mul(10 ** getDecimals(t)).div(ORACLE.getUnderlyingPrice(_cToken).mul(PRECISION));\n  }\n\n  \n  function __tokenToDAI(address _cToken, uint256 _tokenAmount) internal view returns (uint256) {\n    if (_cToken == CETH_ADDR) {\n      \n      return _tokenAmount.mul(PRECISION).div(ORACLE.getUnderlyingPrice(address(CDAI)));\n    }\n    ERC20Detailed t = __underlyingToken(_cToken);\n    return _tokenAmount.mul(ORACLE.getUnderlyingPrice(_cToken)).mul(PRECISION).div(ORACLE.getUnderlyingPrice(address(CDAI)).mul(10 ** uint256(t.decimals())));\n  }\n\n  function __underlyingToken(address _cToken) internal view returns (ERC20Detailed) {\n    if (_cToken == CETH_ADDR) {\n      \n      return ETH_TOKEN_ADDRESS;\n    }\n    CERC20 ct = CERC20(_cToken);\n    address underlyingToken = ct.underlying();\n    ERC20Detailed t = ERC20Detailed(underlyingToken);\n    return t;\n  }\n\n  function() external payable {}\n}\n\ncontract LongCERC20Order is CompoundOrder {\n  modifier isValidPrice(uint256 _minPrice, uint256 _maxPrice) {\n    \n    uint256 tokenPrice = ORACLE.getUnderlyingPrice(compoundTokenAddr); \n    require(tokenPrice > 0); \n    tokenPrice = __tokenToDAI(CETH_ADDR, tokenPrice); \n    require(tokenPrice >= _minPrice && tokenPrice <= _maxPrice); \n    _;\n  }\n\n  function executeOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidToken(compoundTokenAddr)\n    isValidPrice(_minPrice, _maxPrice)\n  {\n    buyTime = now;\n\n    \n    dai.safeTransferFrom(owner(), address(this), collateralAmountInDAI); \n\n    \n    (,uint256 actualTokenAmount) = __sellDAIForToken(collateralAmountInDAI);\n\n    \n    CERC20 market = CERC20(compoundTokenAddr);\n    address[] memory markets = new address[](2);\n    markets[0] = compoundTokenAddr;\n    markets[1] = address(CDAI);\n    uint[] memory errors = COMPTROLLER.enterMarkets(markets);\n    require(errors[0] == 0 && errors[1] == 0);\n\n    \n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    token.safeApprove(compoundTokenAddr, 0); \n    token.safeApprove(compoundTokenAddr, actualTokenAmount); \n    require(market.mint(actualTokenAmount) == 0); \n    token.safeApprove(compoundTokenAddr, 0); \n    require(CDAI.borrow(loanAmountInDAI) == 0);\n    (bool negLiquidity, ) = getCurrentLiquidityInDAI();\n    require(!negLiquidity); \n\n    \n    __sellDAIForToken(loanAmountInDAI);\n\n    \n    if (dai.balanceOf(address(this)) > 0) {\n      uint256 repayAmount = dai.balanceOf(address(this));\n      dai.safeApprove(address(CDAI), 0);\n      dai.safeApprove(address(CDAI), repayAmount);\n      require(CDAI.repayBorrow(repayAmount) == 0);\n      dai.safeApprove(address(CDAI), 0);\n    }\n  }\n\n  function sellOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidPrice(_minPrice, _maxPrice)\n    returns (uint256 _inputAmount, uint256 _outputAmount)\n  {\n    require(buyTime > 0); \n    require(isSold == false);\n    isSold = true;\n    \n    \n    \n    CERC20 market = CERC20(compoundTokenAddr);\n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    for (uint256 i = 0; i < MAX_REPAY_STEPS; i = i.add(1)) {\n      uint256 currentDebt = getCurrentBorrowInDAI();\n      if (currentDebt > NEGLIGIBLE_DEBT) {\n        \n        uint256 currentBalance = getCurrentCashInDAI();\n        uint256 repayAmount = 0; \n        if (currentDebt <= currentBalance) {\n          \n          repayAmount = currentDebt;\n        } else {\n          \n          repayAmount = currentBalance;\n        }\n\n        \n        repayLoan(repayAmount);\n      }\n\n      \n      (bool isNeg, uint256 liquidity) = getCurrentLiquidityInDAI();\n      if (!isNeg) {\n        liquidity = __daiToToken(compoundTokenAddr, liquidity);\n        uint256 errorCode = market.redeemUnderlying(liquidity.mul(PRECISION.sub(DEFAULT_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n        if (errorCode != 0) {\n          \n          \n          errorCode = market.redeemUnderlying(liquidity.mul(PRECISION.sub(FALLBACK_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          if (errorCode != 0) {\n            \n            \n            market.redeemUnderlying(liquidity.mul(PRECISION.sub(MAX_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          }\n        }\n      }\n\n      if (currentDebt <= NEGLIGIBLE_DEBT) {\n        break;\n      }\n    }\n\n    \n    __sellTokenForDAI(token.balanceOf(address(this)));\n\n    \n    _inputAmount = collateralAmountInDAI;\n    _outputAmount = dai.balanceOf(address(this));\n    outputAmount = _outputAmount;\n    dai.safeTransfer(owner(), dai.balanceOf(address(this)));\n    token.safeTransfer(owner(), token.balanceOf(address(this))); \n  }\n\n  \n  function repayLoan(uint256 _repayAmountInDAI) public onlyOwner {\n    require(buyTime > 0); \n\n    \n    uint256 repayAmountInToken = __daiToToken(compoundTokenAddr, _repayAmountInDAI);\n    (uint256 actualDAIAmount,) = __sellTokenForDAI(repayAmountInToken);\n    \n    \n    uint256 currentDebt = CDAI.borrowBalanceCurrent(address(this));\n    if (actualDAIAmount > currentDebt) {\n      actualDAIAmount = currentDebt;\n    }\n    \n    \n    dai.safeApprove(address(CDAI), 0);\n    dai.safeApprove(address(CDAI), actualDAIAmount);\n    require(CDAI.repayBorrow(actualDAIAmount) == 0);\n    dai.safeApprove(address(CDAI), 0);\n  }\n\n  function getMarketCollateralFactor() public view returns (uint256) {\n    (, uint256 ratio) = COMPTROLLER.markets(address(compoundTokenAddr));\n    return ratio;\n  }\n\n  function getCurrentCollateralInDAI() public returns (uint256 _amount) {\n    CERC20 market = CERC20(compoundTokenAddr);\n    uint256 supply = __tokenToDAI(compoundTokenAddr, market.balanceOf(address(this)).mul(market.exchangeRateCurrent()).div(PRECISION));\n    return supply;\n  }\n\n  function getCurrentBorrowInDAI() public returns (uint256 _amount) {\n    uint256 borrow = CDAI.borrowBalanceCurrent(address(this));\n    return borrow;\n  }\n\n  function getCurrentCashInDAI() public view returns (uint256 _amount) {\n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    uint256 cash = __tokenToDAI(compoundTokenAddr, getBalance(token, address(this)));\n    return cash;\n  }\n}\n\ncontract LongCEtherOrder is CompoundOrder {\n  modifier isValidPrice(uint256 _minPrice, uint256 _maxPrice) {\n    \n    uint256 tokenPrice = PRECISION; \n    tokenPrice = __tokenToDAI(CETH_ADDR, tokenPrice); \n    require(tokenPrice >= _minPrice && tokenPrice <= _maxPrice); \n    _;\n  }\n\n  function executeOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidToken(compoundTokenAddr)\n    isValidPrice(_minPrice, _maxPrice)\n  {\n    buyTime = now;\n    \n    \n    dai.safeTransferFrom(owner(), address(this), collateralAmountInDAI); \n\n    \n    (,uint256 actualTokenAmount) = __sellDAIForToken(collateralAmountInDAI);\n\n    \n    CEther market = CEther(compoundTokenAddr);\n    address[] memory markets = new address[](2);\n    markets[0] = compoundTokenAddr;\n    markets[1] = address(CDAI);\n    uint[] memory errors = COMPTROLLER.enterMarkets(markets);\n    require(errors[0] == 0 && errors[1] == 0);\n    \n    \n    market.mint.value(actualTokenAmount)(); \n    require(CDAI.borrow(loanAmountInDAI) == 0);\n    (bool negLiquidity, ) = getCurrentLiquidityInDAI();\n    require(!negLiquidity); \n\n    \n    __sellDAIForToken(loanAmountInDAI);\n\n    \n    if (dai.balanceOf(address(this)) > 0) {\n      uint256 repayAmount = dai.balanceOf(address(this));\n      dai.safeApprove(address(CDAI), 0);\n      dai.safeApprove(address(CDAI), repayAmount);\n      require(CDAI.repayBorrow(repayAmount) == 0);\n      dai.safeApprove(address(CDAI), 0);\n    }\n  }\n\n  function sellOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidPrice(_minPrice, _maxPrice)\n    returns (uint256 _inputAmount, uint256 _outputAmount)\n  {\n    require(buyTime > 0); \n    require(isSold == false);\n    isSold = true;\n\n    \n    \n    CEther market = CEther(compoundTokenAddr);\n    for (uint256 i = 0; i < MAX_REPAY_STEPS; i = i.add(1)) {\n      uint256 currentDebt = getCurrentBorrowInDAI();\n      if (currentDebt > NEGLIGIBLE_DEBT) {\n        \n        uint256 currentBalance = getCurrentCashInDAI();\n        uint256 repayAmount = 0; \n        if (currentDebt <= currentBalance) {\n          \n          repayAmount = currentDebt;\n        } else {\n          \n          repayAmount = currentBalance;\n        }\n\n        \n        repayLoan(repayAmount);\n      }\n\n      \n      (bool isNeg, uint256 liquidity) = getCurrentLiquidityInDAI();\n      if (!isNeg) {\n        liquidity = __daiToToken(compoundTokenAddr, liquidity);\n        uint256 errorCode = market.redeemUnderlying(liquidity.mul(PRECISION.sub(DEFAULT_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n        if (errorCode != 0) {\n          \n          \n          errorCode = market.redeemUnderlying(liquidity.mul(PRECISION.sub(FALLBACK_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          if (errorCode != 0) {\n            \n            \n            market.redeemUnderlying(liquidity.mul(PRECISION.sub(MAX_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          }\n        }\n      }\n\n      if (currentDebt <= NEGLIGIBLE_DEBT) {\n        break;\n      }\n    }\n\n    \n    __sellTokenForDAI(address(this).balance);\n\n    \n    _inputAmount = collateralAmountInDAI;\n    _outputAmount = dai.balanceOf(address(this));\n    outputAmount = _outputAmount;\n    dai.safeTransfer(owner(), dai.balanceOf(address(this)));\n    toPayableAddr(owner()).transfer(address(this).balance); \n  }\n\n  \n  function repayLoan(uint256 _repayAmountInDAI) public onlyOwner {\n    require(buyTime > 0); \n\n    \n    uint256 repayAmountInToken = __daiToToken(compoundTokenAddr, _repayAmountInDAI);\n    (uint256 actualDAIAmount,) = __sellTokenForDAI(repayAmountInToken);\n    \n    \n    uint256 currentDebt = CDAI.borrowBalanceCurrent(address(this));\n    if (actualDAIAmount > currentDebt) {\n      actualDAIAmount = currentDebt;\n    }\n\n    \n    dai.safeApprove(address(CDAI), 0);\n    dai.safeApprove(address(CDAI), actualDAIAmount);\n    require(CDAI.repayBorrow(actualDAIAmount) == 0);\n    dai.safeApprove(address(CDAI), 0);\n  }\n\n  function getMarketCollateralFactor() public view returns (uint256) {\n    (, uint256 ratio) = COMPTROLLER.markets(address(compoundTokenAddr));\n    return ratio;\n  }\n\n  function getCurrentCollateralInDAI() public returns (uint256 _amount) {\n    CEther market = CEther(compoundTokenAddr);\n    uint256 supply = __tokenToDAI(compoundTokenAddr, market.balanceOf(address(this)).mul(market.exchangeRateCurrent()).div(PRECISION));\n    return supply;\n  }\n\n  function getCurrentBorrowInDAI() public returns (uint256 _amount) {\n    uint256 borrow = CDAI.borrowBalanceCurrent(address(this));\n    return borrow;\n  }\n\n  function getCurrentCashInDAI() public view returns (uint256 _amount) {\n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    uint256 cash = __tokenToDAI(compoundTokenAddr, getBalance(token, address(this)));\n    return cash;\n  }\n}\n\ncontract ShortCERC20Order is CompoundOrder {\n  modifier isValidPrice(uint256 _minPrice, uint256 _maxPrice) {\n    \n    uint256 tokenPrice = ORACLE.getUnderlyingPrice(compoundTokenAddr); \n    require(tokenPrice > 0); \n    tokenPrice = __tokenToDAI(CETH_ADDR, tokenPrice); \n    require(tokenPrice >= _minPrice && tokenPrice <= _maxPrice); \n    _;\n  }\n\n  function executeOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidToken(compoundTokenAddr)\n    isValidPrice(_minPrice, _maxPrice)\n  {\n    buyTime = now;\n\n    \n    dai.safeTransferFrom(owner(), address(this), collateralAmountInDAI); \n\n    \n    CERC20 market = CERC20(compoundTokenAddr);\n    address[] memory markets = new address[](2);\n    markets[0] = compoundTokenAddr;\n    markets[1] = address(CDAI);\n    uint[] memory errors = COMPTROLLER.enterMarkets(markets);\n    require(errors[0] == 0 && errors[1] == 0);\n    \n    \n    uint256 loanAmountInToken = __daiToToken(compoundTokenAddr, loanAmountInDAI);\n    dai.safeApprove(address(CDAI), 0); \n    dai.safeApprove(address(CDAI), collateralAmountInDAI); \n    require(CDAI.mint(collateralAmountInDAI) == 0); \n    dai.safeApprove(address(CDAI), 0);\n    require(market.borrow(loanAmountInToken) == 0);\n    (bool negLiquidity, ) = getCurrentLiquidityInDAI();\n    require(!negLiquidity); \n\n    \n    (uint256 actualDAIAmount,) = __sellTokenForDAI(loanAmountInToken);\n    loanAmountInDAI = actualDAIAmount; \n\n    \n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    if (token.balanceOf(address(this)) > 0) {\n      uint256 repayAmount = token.balanceOf(address(this));\n      token.safeApprove(compoundTokenAddr, 0);\n      token.safeApprove(compoundTokenAddr, repayAmount);\n      require(market.repayBorrow(repayAmount) == 0);\n      token.safeApprove(compoundTokenAddr, 0);\n    }\n  }\n\n  function sellOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidPrice(_minPrice, _maxPrice)\n    returns (uint256 _inputAmount, uint256 _outputAmount)\n  {\n    require(buyTime > 0); \n    require(isSold == false);\n    isSold = true;\n\n    \n    \n    for (uint256 i = 0; i < MAX_REPAY_STEPS; i = i.add(1)) {\n      uint256 currentDebt = getCurrentBorrowInDAI();\n      if (currentDebt > NEGLIGIBLE_DEBT) {\n        \n        uint256 currentBalance = getCurrentCashInDAI();\n        uint256 repayAmount = 0; \n        if (currentDebt <= currentBalance) {\n          \n          repayAmount = currentDebt;\n        } else {\n          \n          repayAmount = currentBalance;\n        }\n\n        \n        repayLoan(repayAmount);\n      }\n\n      \n      (bool isNeg, uint256 liquidity) = getCurrentLiquidityInDAI();\n      if (!isNeg) {\n        uint256 errorCode = CDAI.redeemUnderlying(liquidity.mul(PRECISION.sub(DEFAULT_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n        if (errorCode != 0) {\n          \n          \n          errorCode = CDAI.redeemUnderlying(liquidity.mul(PRECISION.sub(FALLBACK_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          if (errorCode != 0) {\n            \n            \n            CDAI.redeemUnderlying(liquidity.mul(PRECISION.sub(MAX_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          }\n        }\n      }\n\n      if (currentDebt <= NEGLIGIBLE_DEBT) {\n        break;\n      }\n    }\n\n    \n    _inputAmount = collateralAmountInDAI;\n    _outputAmount = dai.balanceOf(address(this));\n    outputAmount = _outputAmount;\n    dai.safeTransfer(owner(), dai.balanceOf(address(this)));\n  }\n\n  \n  function repayLoan(uint256 _repayAmountInDAI) public onlyOwner {\n    require(buyTime > 0); \n\n    \n    (,uint256 actualTokenAmount) = __sellDAIForToken(_repayAmountInDAI);\n\n    \n    CERC20 market = CERC20(compoundTokenAddr);\n    uint256 currentDebt = market.borrowBalanceCurrent(address(this));\n    if (actualTokenAmount > currentDebt) {\n      actualTokenAmount = currentDebt;\n    }\n\n    \n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    token.safeApprove(compoundTokenAddr, 0);\n    token.safeApprove(compoundTokenAddr, actualTokenAmount);\n    require(market.repayBorrow(actualTokenAmount) == 0);\n    token.safeApprove(compoundTokenAddr, 0);\n  }\n\n  function getMarketCollateralFactor() public view returns (uint256) {\n    (, uint256 ratio) = COMPTROLLER.markets(address(CDAI));\n    return ratio;\n  }\n\n  function getCurrentCollateralInDAI() public returns (uint256 _amount) {\n    uint256 supply = CDAI.balanceOf(address(this)).mul(CDAI.exchangeRateCurrent()).div(PRECISION);\n    return supply;\n  }\n\n  function getCurrentBorrowInDAI() public returns (uint256 _amount) {\n    CERC20 market = CERC20(compoundTokenAddr);\n    uint256 borrow = __tokenToDAI(compoundTokenAddr, market.borrowBalanceCurrent(address(this)));\n    return borrow;\n  }\n\n  function getCurrentCashInDAI() public view returns (uint256 _amount) {\n    uint256 cash = getBalance(dai, address(this));\n    return cash;\n  }\n}\n\ncontract ShortCEtherOrder is CompoundOrder {\n  modifier isValidPrice(uint256 _minPrice, uint256 _maxPrice) {\n    \n    uint256 tokenPrice = PRECISION; \n    tokenPrice = __tokenToDAI(CETH_ADDR, tokenPrice); \n    require(tokenPrice >= _minPrice && tokenPrice <= _maxPrice); \n    _;\n  }\n\n  function executeOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidToken(compoundTokenAddr)\n    isValidPrice(_minPrice, _maxPrice)\n  {\n    buyTime = now;\n\n    \n    dai.safeTransferFrom(owner(), address(this), collateralAmountInDAI); \n    \n    \n    CEther market = CEther(compoundTokenAddr);\n    address[] memory markets = new address[](2);\n    markets[0] = compoundTokenAddr;\n    markets[1] = address(CDAI);\n    uint[] memory errors = COMPTROLLER.enterMarkets(markets);\n    require(errors[0] == 0 && errors[1] == 0);\n\n    \n    uint256 loanAmountInToken = __daiToToken(compoundTokenAddr, loanAmountInDAI);\n    dai.safeApprove(address(CDAI), 0); \n    dai.safeApprove(address(CDAI), collateralAmountInDAI); \n    require(CDAI.mint(collateralAmountInDAI) == 0); \n    dai.safeApprove(address(CDAI), 0);\n    require(market.borrow(loanAmountInToken) == 0);\n    (bool negLiquidity, ) = getCurrentLiquidityInDAI();\n    require(!negLiquidity); \n\n    \n    (uint256 actualDAIAmount,) = __sellTokenForDAI(loanAmountInToken);\n    loanAmountInDAI = actualDAIAmount; \n\n    \n    if (address(this).balance > 0) {\n      uint256 repayAmount = address(this).balance;\n      market.repayBorrow.value(repayAmount)();\n    }\n  }\n\n  function sellOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidPrice(_minPrice, _maxPrice)\n    returns (uint256 _inputAmount, uint256 _outputAmount)\n  {\n    require(buyTime > 0); \n    require(isSold == false);\n    isSold = true;\n\n    \n    \n    for (uint256 i = 0; i < MAX_REPAY_STEPS; i = i.add(1)) {\n      uint256 currentDebt = getCurrentBorrowInDAI();\n      if (currentDebt > NEGLIGIBLE_DEBT) {\n        \n        uint256 currentBalance = getCurrentCashInDAI();\n        uint256 repayAmount = 0; \n        if (currentDebt <= currentBalance) {\n          \n          repayAmount = currentDebt;\n        } else {\n          \n          repayAmount = currentBalance;\n        }\n\n        \n        repayLoan(repayAmount);\n      }\n\n      \n      (bool isNeg, uint256 liquidity) = getCurrentLiquidityInDAI();\n      if (!isNeg) {\n        uint256 errorCode = CDAI.redeemUnderlying(liquidity.mul(PRECISION.sub(DEFAULT_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n        if (errorCode != 0) {\n          \n          \n          errorCode = CDAI.redeemUnderlying(liquidity.mul(PRECISION.sub(FALLBACK_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          if (errorCode != 0) {\n            \n            \n            CDAI.redeemUnderlying(liquidity.mul(PRECISION.sub(MAX_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          }\n        }\n      }\n\n      if (currentDebt <= NEGLIGIBLE_DEBT) {\n        break;\n      }\n    }\n\n    \n    _inputAmount = collateralAmountInDAI;\n    _outputAmount = dai.balanceOf(address(this));\n    outputAmount = _outputAmount;\n    dai.safeTransfer(owner(), dai.balanceOf(address(this)));\n  }\n\n  \n  function repayLoan(uint256 _repayAmountInDAI) public onlyOwner {\n    require(buyTime > 0); \n\n    \n    (,uint256 actualTokenAmount) = __sellDAIForToken(_repayAmountInDAI);\n\n    \n    CEther market = CEther(compoundTokenAddr);\n    uint256 currentDebt = market.borrowBalanceCurrent(address(this));\n    if (actualTokenAmount > currentDebt) {\n      actualTokenAmount = currentDebt;\n    }\n\n    \n    market.repayBorrow.value(actualTokenAmount)();\n  }\n\n  function getMarketCollateralFactor() public view returns (uint256) {\n    (, uint256 ratio) = COMPTROLLER.markets(address(CDAI));\n    return ratio;\n  }\n\n  function getCurrentCollateralInDAI() public returns (uint256 _amount) {\n    uint256 supply = CDAI.balanceOf(address(this)).mul(CDAI.exchangeRateCurrent()).div(PRECISION);\n    return supply;\n  }\n\n  function getCurrentBorrowInDAI() public returns (uint256 _amount) {\n    CEther market = CEther(compoundTokenAddr);\n    uint256 borrow = __tokenToDAI(compoundTokenAddr, market.borrowBalanceCurrent(address(this)));\n    return borrow;\n  }\n\n  function getCurrentCashInDAI() public view returns (uint256 _amount) {\n    uint256 cash = getBalance(dai, address(this));\n    return cash;\n  }\n}\n\ncontract CloneFactory {\n\n  function createClone(address target) internal returns (address result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(clone, 0x14), targetBytes)\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      result := create(0, clone, 0x37)\n    }\n  }\n\n  function isClone(address target, address query) internal view returns (bool result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n      mstore(add(clone, 0xa), targetBytes)\n      mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n\n      let other := add(clone, 0x40)\n      extcodecopy(query, other, 0, 0x2d)\n      result := and(\n        eq(mload(clone), mload(other)),\n        eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\n      )\n    }\n  }\n}\n\ncontract CompoundOrderFactory is CloneFactory {\n  address public SHORT_CERC20_LOGIC_CONTRACT;\n  address public SHORT_CEther_LOGIC_CONTRACT;\n  address public LONG_CERC20_LOGIC_CONTRACT;\n  address public LONG_CEther_LOGIC_CONTRACT;\n\n  address public DAI_ADDR;\n  address payable public KYBER_ADDR;\n  address public COMPTROLLER_ADDR;\n  address public ORACLE_ADDR;\n  address public CDAI_ADDR;\n  address public CETH_ADDR;\n\n  constructor(\n    address _shortCERC20LogicContract,\n    address _shortCEtherLogicContract,\n    address _longCERC20LogicContract,\n    address _longCEtherLogicContract,\n    address _daiAddr,\n    address payable _kyberAddr,\n    address _comptrollerAddr,\n    address _priceOracleAddr,\n    address _cDAIAddr,\n    address _cETHAddr\n  ) public {\n    SHORT_CERC20_LOGIC_CONTRACT = _shortCERC20LogicContract;\n    SHORT_CEther_LOGIC_CONTRACT = _shortCEtherLogicContract;\n    LONG_CERC20_LOGIC_CONTRACT = _longCERC20LogicContract;\n    LONG_CEther_LOGIC_CONTRACT = _longCEtherLogicContract;\n\n    DAI_ADDR = _daiAddr;\n    KYBER_ADDR = _kyberAddr;\n    COMPTROLLER_ADDR = _comptrollerAddr;\n    ORACLE_ADDR = _priceOracleAddr;\n    CDAI_ADDR = _cDAIAddr;\n    CETH_ADDR = _cETHAddr;\n  }\n\n  function createOrder(\n    address _compoundTokenAddr,\n    uint256 _cycleNumber,\n    uint256 _stake,\n    uint256 _collateralAmountInDAI,\n    uint256 _loanAmountInDAI,\n    bool _orderType\n  ) external returns (CompoundOrder) {\n    require(_compoundTokenAddr != address(0));\n\n    CompoundOrder order;\n\n    address payable clone;\n    if (_compoundTokenAddr != CETH_ADDR) {\n      if (_orderType) {\n        \n        clone = toPayableAddr(createClone(SHORT_CERC20_LOGIC_CONTRACT));\n      } else {\n        \n        clone = toPayableAddr(createClone(LONG_CERC20_LOGIC_CONTRACT));\n      }\n    } else {\n      if (_orderType) {\n        \n        clone = toPayableAddr(createClone(SHORT_CEther_LOGIC_CONTRACT));\n      } else {\n        \n        clone = toPayableAddr(createClone(LONG_CEther_LOGIC_CONTRACT));\n      }\n    }\n    order = CompoundOrder(clone);\n    order.init(_compoundTokenAddr, _cycleNumber, _stake, _collateralAmountInDAI, _loanAmountInDAI, _orderType,\n      DAI_ADDR, KYBER_ADDR, COMPTROLLER_ADDR, ORACLE_ADDR, CDAI_ADDR, CETH_ADDR);\n    order.transferOwnership(msg.sender);\n    return order;\n  }\n\n  function getMarketCollateralFactor(address _compoundTokenAddr) external view returns (uint256) {\n    Comptroller troll = Comptroller(COMPTROLLER_ADDR);\n    (, uint256 factor) = troll.markets(_compoundTokenAddr);\n    return factor;\n  }\n\n  function tokenIsListed(address _compoundTokenAddr) external view returns (bool) {\n    Comptroller troll = Comptroller(COMPTROLLER_ADDR);\n    (bool isListed,) = troll.markets(_compoundTokenAddr);\n    return isListed;\n  }\n\n  function toPayableAddr(address _addr) internal pure returns (address payable) {\n    return address(uint160(_addr));\n  }\n}\n\ncontract BetokenLogic2 is BetokenStorage, Utils(address(0), address(0), address(0)) {\n  \n  modifier notReadyForUpgrade {\n    require(hasFinalizedNextVersion == false);\n    _;\n  }\n\n  \n  modifier during(CyclePhase phase) {\n    require(cyclePhase == phase);\n    if (cyclePhase == CyclePhase.Intermission) {\n      require(isInitialized);\n    }\n    _;\n  }\n\n  \n  function nextPhase()\n    public\n  {\n    require(now >= startTimeOfCyclePhase.add(phaseLengths[uint(cyclePhase)]));\n\n    if (isInitialized == false) {\n      \n      \n      isInitialized = true;\n      require(proxyAddr != address(0)); \n      require(proxy.betokenFundAddress() == address(this)); \n      require(hasInitializedTokenListings); \n\n      \n      init();\n\n      require(previousVersion == address(0) || (previousVersion != address(0) && getBalance(dai, address(this)) > 0)); \n    } else {\n      \n      if (cyclePhase == CyclePhase.Intermission) {\n        require(hasFinalizedNextVersion == false); \n\n        \n        if (upgradeSignalStrength[cycleNumber] > getTotalVotingWeight().div(2)) {\n          upgradeVotingActive = true;\n          emit InitiatedUpgrade(cycleNumber);\n        }\n      } else if (cyclePhase == CyclePhase.Manage) {\n        \n        require(cToken.destroyTokens(address(this), cToken.balanceOf(address(this))));\n\n        \n        uint256 profit = 0;\n        if (getBalance(dai, address(this)) > totalFundsInDAI.add(totalCommissionLeft)) {\n          profit = getBalance(dai, address(this)).sub(totalFundsInDAI).sub(totalCommissionLeft);\n        }\n\n        totalFundsInDAI = getBalance(dai, address(this)).sub(totalCommissionLeft);\n\n        uint256 commissionThisCycle = COMMISSION_RATE.mul(profit).add(ASSET_FEE_RATE.mul(totalFundsInDAI)).div(PRECISION);\n        _totalCommissionOfCycle[cycleNumber] = totalCommissionOfCycle(cycleNumber).add(commissionThisCycle); \n        totalCommissionLeft = totalCommissionLeft.add(commissionThisCycle);\n\n\n        \n        uint256 devFunding = devFundingRate.mul(sToken.totalSupply()).div(PRECISION);\n        require(sToken.generateTokens(devFundingAccount, devFunding));\n\n        \n        emit TotalCommissionPaid(cycleNumber, totalCommissionOfCycle(cycleNumber));\n\n        _managePhaseEndBlock[cycleNumber] = block.number;\n\n        \n        if (nextVersion == address(this)) {\n          \n          \n          delete nextVersion;\n          delete hasFinalizedNextVersion;\n        }\n        if (nextVersion == address(0)) {\n          delete proposers;\n          delete candidates;\n          delete forVotes;\n          delete againstVotes;\n          delete upgradeVotingActive;\n          delete proposersVotingWeight;\n        } else {\n          hasFinalizedNextVersion = true;\n          emit FinalizedNextVersion(cycleNumber, nextVersion);\n        }\n\n        \n        cycleNumber = cycleNumber.add(1);\n      }\n\n      cyclePhase = CyclePhase(addmod(uint(cyclePhase), 1, 2));\n    }\n    \n    startTimeOfCyclePhase = now;\n\n    \n    if (cToken.balanceOf(msg.sender) > 0) {\n      require(cToken.generateTokens(msg.sender, NEXT_PHASE_REWARD));\n    }\n\n    emit ChangedPhase(cycleNumber, uint(cyclePhase), now, totalFundsInDAI);\n  }\n\n  \n  function init() internal {\n    \n    totalCommissionLeft = previousVersion == address(0) ? 0 : BetokenStorage(previousVersion).totalCommissionLeft();\n    totalFundsInDAI = getBalance(dai, address(this)).sub(totalCommissionLeft);\n    _managePhaseEndBlock[cycleNumber.sub(1)] = block.number;\n\n    \n    if (saiAddr != address(0)) {\n      ERC20Detailed sai = ERC20Detailed(saiAddr);\n      uint256 saiBalance = getBalance(sai, address(this));\n      require(sai.approve(address(mcdaiMigration), 0));\n      require(sai.approve(address(mcdaiMigration), saiBalance));\n      mcdaiMigration.swapSaiToDai(saiBalance);\n\n      \n      address cryptoChick = 0x8e9818E75ea25d0162F4998E033eae28cDDc231e;\n      address newCryptoChick = 0x617096ec92315d6A23a5ebDCf4f1Fc3A8C59E5d5;\n      uint256 balance = cToken.balanceOf(cryptoChick);\n      require(cToken.destroyTokens(cryptoChick, balance) && cToken.generateTokens(newCryptoChick, balance));\n\n      address garima = 0xd16Aa39e2812Fa1C9Dae6Ca4Eee0A11DEE262a9a;\n      cToken.generateTokens(garima, PRECISION.mul(628));\n    }\n  }\n\n  \n\n  \n  function developerInitiateUpgrade(address payable _candidate) public onlyOwner notReadyForUpgrade during(CyclePhase.Intermission) returns (bool _success) {\n    if (_candidate == address(0) || _candidate == address(this) || !__isMature()) {\n      return false;\n    }\n    nextVersion = _candidate;\n    upgradeVotingActive = true;\n    emit DeveloperInitiatedUpgrade(cycleNumber, _candidate);\n    return true;\n  }\n\n  \n  function signalUpgrade(bool _inSupport) public notReadyForUpgrade during(CyclePhase.Intermission) returns (bool _success) {\n    if (!__isMature()) {\n      return false;\n    }\n\n    if (upgradeSignal[cycleNumber][msg.sender] == false) {\n      if (_inSupport == true) {\n        upgradeSignal[cycleNumber][msg.sender] = true;\n        upgradeSignalStrength[cycleNumber] = upgradeSignalStrength[cycleNumber].add(getVotingWeight(msg.sender));\n      } else {\n        return false;\n      }\n    } else {\n      if (_inSupport == false) {\n        upgradeSignal[cycleNumber][msg.sender] = false;\n        upgradeSignalStrength[cycleNumber] = upgradeSignalStrength[cycleNumber].sub(getVotingWeight(msg.sender));\n      } else {\n        return false;\n      }\n    }\n    emit SignaledUpgrade(cycleNumber, msg.sender, _inSupport);\n    return true;\n  }\n\n  \n  function proposeCandidate(uint256 _chunkNumber, address payable _candidate) public notReadyForUpgrade during(CyclePhase.Manage) returns (bool _success) {\n    \n    if (!__isValidChunk(_chunkNumber) || currentChunk() != _chunkNumber || currentSubchunk() != Subchunk.Propose ||\n      upgradeVotingActive == false || _candidate == address(0) || msg.sender == address(0) || !__isMature()) {\n      return false;\n    }\n\n    \n    \n    uint256 voteID = _chunkNumber.sub(1);\n    uint256 i;\n    for (i = 0; i < voteID; i = i.add(1)) {\n      if (proposers[i] == msg.sender || candidates[i] == _candidate) {\n        return false;\n      }\n    }\n\n    \n    uint256 senderWeight = getVotingWeight(msg.sender);\n    uint256 currProposerWeight = getVotingWeight(proposers[voteID]);\n    if (senderWeight > currProposerWeight || (senderWeight == currProposerWeight && msg.sender > proposers[voteID]) || msg.sender == proposers[voteID]) {\n      proposers[voteID] = msg.sender;\n      candidates[voteID] = _candidate;\n      proposersVotingWeight = proposersVotingWeight.add(senderWeight).sub(currProposerWeight);\n      emit ProposedCandidate(cycleNumber, voteID, msg.sender, _candidate);\n      return true;\n    }\n    return false;\n  }\n\n  \n  function voteOnCandidate(uint256 _chunkNumber, bool _inSupport) public notReadyForUpgrade during(CyclePhase.Manage) returns (bool _success) {\n    \n    if (!__isValidChunk(_chunkNumber) || currentChunk() != _chunkNumber || currentSubchunk() != Subchunk.Vote || upgradeVotingActive == false || !__isMature()) {\n      return false;\n    }\n\n    \n    uint256 voteID = _chunkNumber.sub(1);\n    uint256 i;\n    for (i = 0; i < voteID; i = i.add(1)) {\n      if (proposers[i] == msg.sender) {\n        return false;\n      }\n    }\n\n    \n    VoteDirection currVote = managerVotes[cycleNumber][msg.sender][voteID];\n    uint256 votingWeight = getVotingWeight(msg.sender);\n    if ((currVote == VoteDirection.Empty || currVote == VoteDirection.Against) && _inSupport) {\n      managerVotes[cycleNumber][msg.sender][voteID] = VoteDirection.For;\n      forVotes[voteID] = forVotes[voteID].add(votingWeight);\n      if (currVote == VoteDirection.Against) {\n        againstVotes[voteID] = againstVotes[voteID].sub(votingWeight);\n      }\n    } else if ((currVote == VoteDirection.Empty || currVote == VoteDirection.For) && !_inSupport) {\n      managerVotes[cycleNumber][msg.sender][voteID] = VoteDirection.Against;\n      againstVotes[voteID] = againstVotes[voteID].add(votingWeight);\n      if (currVote == VoteDirection.For) {\n        forVotes[voteID] = forVotes[voteID].sub(votingWeight);\n      }\n    }\n    emit Voted(cycleNumber, voteID, msg.sender, _inSupport, votingWeight);\n    return true;\n  }\n\n  \n  function finalizeSuccessfulVote(uint256 _chunkNumber) public notReadyForUpgrade during(CyclePhase.Manage) returns (bool _success) {\n    \n    if (!__isValidChunk(_chunkNumber) || !__isMature()) {\n      return false;\n    }\n\n    \n    if (__voteSuccessful(_chunkNumber) == false) {\n      return false;\n    }\n\n    \n    if (_chunkNumber >= currentChunk()) {\n      return false;\n    }\n\n    \n    for (uint256 i = 1; i < _chunkNumber; i = i.add(1)) {\n      if (__voteSuccessful(i)) {\n        return false;\n      }\n    }\n\n    \n    upgradeVotingActive = false;\n    nextVersion = candidates[_chunkNumber.sub(1)];\n    hasFinalizedNextVersion = true;\n    return true;\n  }\n\n  \n  function __isMature() internal view returns (bool) {\n    return cycleNumber > CYCLES_TILL_MATURITY;\n  }\n\n  \n  function __isValidChunk(uint256 _chunkNumber) internal pure returns (bool) {\n    return _chunkNumber >= 1 && _chunkNumber <= 5;\n  }\n\n  \n  function __voteSuccessful(uint256 _chunkNumber) internal view returns (bool _success) {\n    if (!__isValidChunk(_chunkNumber)) {\n      return false;\n    }\n    uint256 voteID = _chunkNumber.sub(1);\n    return forVotes[voteID].mul(PRECISION).div(forVotes[voteID].add(againstVotes[voteID])) > VOTE_SUCCESS_THRESHOLD\n      && forVotes[voteID].add(againstVotes[voteID]) > getTotalVotingWeight().mul(QUORUM).div(PRECISION);\n  }\n\n  \n\n  \n  function depositEther()\n    public\n    payable\n    during(CyclePhase.Intermission)\n    notReadyForUpgrade\n    nonReentrant\n  {\n    \n    uint256 actualDAIDeposited;\n    uint256 actualETHDeposited;\n    (,, actualDAIDeposited, actualETHDeposited) = __kyberTrade(ETH_TOKEN_ADDRESS, msg.value, dai);\n\n    \n    uint256 leftOverETH = msg.value.sub(actualETHDeposited);\n    if (leftOverETH > 0) {\n      msg.sender.transfer(leftOverETH);\n    }\n\n    \n    __deposit(actualDAIDeposited);\n\n    \n    emit Deposit(cycleNumber, msg.sender, address(ETH_TOKEN_ADDRESS), actualETHDeposited, actualDAIDeposited, now);\n  }\n\n  \n  function depositDAI(uint256 _daiAmount)\n    public\n    during(CyclePhase.Intermission)\n    notReadyForUpgrade\n    nonReentrant\n  {\n    dai.safeTransferFrom(msg.sender, address(this), _daiAmount);\n\n    \n    __deposit(_daiAmount);\n\n    \n    emit Deposit(cycleNumber, msg.sender, DAI_ADDR, _daiAmount, _daiAmount, now);\n  }\n\n  \n  function depositToken(address _tokenAddr, uint256 _tokenAmount)\n    public\n    during(CyclePhase.Intermission)\n    notReadyForUpgrade\n    nonReentrant\n    isValidToken(_tokenAddr)\n  {\n    require(_tokenAddr != DAI_ADDR && _tokenAddr != address(ETH_TOKEN_ADDRESS));\n\n    ERC20Detailed token = ERC20Detailed(_tokenAddr);\n\n    token.safeTransferFrom(msg.sender, address(this), _tokenAmount);\n\n    \n    uint256 actualDAIDeposited;\n    uint256 actualTokenDeposited;\n    (,, actualDAIDeposited, actualTokenDeposited) = __kyberTrade(token, _tokenAmount, dai);\n\n    \n    uint256 leftOverTokens = _tokenAmount.sub(actualTokenDeposited);\n    if (leftOverTokens > 0) {\n      token.safeTransfer(msg.sender, leftOverTokens);\n    }\n\n    \n    __deposit(actualDAIDeposited);\n\n    \n    emit Deposit(cycleNumber, msg.sender, _tokenAddr, actualTokenDeposited, actualDAIDeposited, now);\n  }\n\n  \n  function withdrawEther(uint256 _amountInDAI)\n    public\n    during(CyclePhase.Intermission)\n    nonReentrant\n  {\n    \n    uint256 actualETHWithdrawn;\n    uint256 actualDAIWithdrawn;\n    (,, actualETHWithdrawn, actualDAIWithdrawn) = __kyberTrade(dai, _amountInDAI, ETH_TOKEN_ADDRESS);\n\n    __withdraw(actualDAIWithdrawn);\n\n    \n    msg.sender.transfer(actualETHWithdrawn);\n\n    \n    emit Withdraw(cycleNumber, msg.sender, address(ETH_TOKEN_ADDRESS), actualETHWithdrawn, actualDAIWithdrawn, now);\n  }\n\n  \n  function withdrawDAI(uint256 _amountInDAI)\n    public\n    during(CyclePhase.Intermission)\n    nonReentrant\n  {\n    __withdraw(_amountInDAI);\n\n    \n    dai.safeTransfer(msg.sender, _amountInDAI);\n\n    \n    emit Withdraw(cycleNumber, msg.sender, DAI_ADDR, _amountInDAI, _amountInDAI, now);\n  }\n\n  \n  function withdrawToken(address _tokenAddr, uint256 _amountInDAI)\n    public\n    during(CyclePhase.Intermission)\n    nonReentrant\n    isValidToken(_tokenAddr)\n  {\n    require(_tokenAddr != DAI_ADDR && _tokenAddr != address(ETH_TOKEN_ADDRESS));\n\n    ERC20Detailed token = ERC20Detailed(_tokenAddr);\n\n    \n    uint256 actualTokenWithdrawn;\n    uint256 actualDAIWithdrawn;\n    (,, actualTokenWithdrawn, actualDAIWithdrawn) = __kyberTrade(dai, _amountInDAI, token);\n\n    __withdraw(actualDAIWithdrawn);\n\n    \n    token.safeTransfer(msg.sender, actualTokenWithdrawn);\n\n    \n    emit Withdraw(cycleNumber, msg.sender, _tokenAddr, actualTokenWithdrawn, actualDAIWithdrawn, now);\n  }\n\n\n  \n  \n  \n  function maxRegistrationPaymentInDAI() public view returns (uint256 _maxDonationInDAI) {\n    uint256 kroPrice = kairoPrice();\n    _maxDonationInDAI = MAX_BUY_KRO_PROP.mul(cToken.totalSupply()).div(PRECISION).mul(kroPrice).div(PRECISION);\n    if (_maxDonationInDAI < FALLBACK_MAX_DONATION) {\n      _maxDonationInDAI = FALLBACK_MAX_DONATION;\n    }\n  }\n\n  \n  function registerWithDAI(uint256 _donationInDAI) public nonReentrant during(CyclePhase.Manage) {\n    dai.safeTransferFrom(msg.sender, address(this), _donationInDAI);\n\n    \n    uint256 maxDonationInDAI = maxRegistrationPaymentInDAI();\n    if (_donationInDAI > maxDonationInDAI) {\n      dai.safeTransfer(msg.sender, _donationInDAI.sub(maxDonationInDAI));\n      _donationInDAI = maxDonationInDAI;\n    }\n\n    __register(_donationInDAI);\n  }\n\n  \n  function registerWithETH() public payable nonReentrant during(CyclePhase.Manage) {\n    uint256 receivedDAI;\n\n    \n    (,,receivedDAI,) = __kyberTrade(ETH_TOKEN_ADDRESS, msg.value, dai);\n    \n    \n    uint256 maxDonationInDAI = maxRegistrationPaymentInDAI();\n    if (receivedDAI > maxDonationInDAI) {\n      dai.safeTransfer(msg.sender, receivedDAI.sub(maxDonationInDAI));\n      receivedDAI = maxDonationInDAI;\n    }\n\n    \n    __register(receivedDAI);\n  }\n\n  \n  function registerWithToken(address _token, uint256 _donationInTokens) public nonReentrant during(CyclePhase.Manage) {\n    require(_token != address(0) && _token != address(ETH_TOKEN_ADDRESS) && _token != DAI_ADDR);\n    ERC20Detailed token = ERC20Detailed(_token);\n    require(token.totalSupply() > 0);\n\n    token.safeTransferFrom(msg.sender, address(this), _donationInTokens);\n\n    uint256 receivedDAI;\n\n    (,,receivedDAI,) = __kyberTrade(token, _donationInTokens, dai);\n\n    \n    uint256 maxDonationInDAI = maxRegistrationPaymentInDAI();\n    if (receivedDAI > maxDonationInDAI) {\n      dai.safeTransfer(msg.sender, receivedDAI.sub(maxDonationInDAI));\n      receivedDAI = maxDonationInDAI;\n    }\n\n    \n    __register(receivedDAI);\n  }\n\n  \n  function sellLeftoverToken(address _tokenAddr)\n    public\n    nonReentrant\n    during(CyclePhase.Intermission)\n    isValidToken(_tokenAddr)\n  {\n    ERC20Detailed token = ERC20Detailed(_tokenAddr);\n    (,,uint256 actualDAIReceived,) = __kyberTrade(token, getBalance(token, address(this)), dai);\n    totalFundsInDAI = totalFundsInDAI.add(actualDAIReceived);\n  }\n\n  function sellLeftoverFulcrumToken(address _tokenAddr)\n    public\n    nonReentrant\n    during(CyclePhase.Intermission)\n    isValidToken(_tokenAddr)\n  {\n    PositionToken pToken = PositionToken(_tokenAddr);\n    uint256 beforeBalance = dai.balanceOf(address(this));\n    pToken.burnToToken(address(this), DAI_ADDR, pToken.balanceOf(address(this)), 0);\n    uint256 actualDAIReceived = dai.balanceOf(address(this)).sub(beforeBalance);\n    require(actualDAIReceived > 0);\n    totalFundsInDAI = totalFundsInDAI.add(actualDAIReceived);\n  }\n\n  \n  function sellLeftoverCompoundOrder(address payable _orderAddress)\n    public\n    nonReentrant\n    during(CyclePhase.Intermission)\n  {\n    \n    require(_orderAddress != address(0));\n    CompoundOrder order = CompoundOrder(_orderAddress);\n    require(order.isSold() == false && order.cycleNumber() < cycleNumber);\n\n    \n    \n    uint256 beforeDAIBalance = dai.balanceOf(address(this));\n    order.sellOrder(0, MAX_QTY);\n    uint256 actualDAIReceived = dai.balanceOf(address(this)).sub(beforeDAIBalance);\n\n    totalFundsInDAI = totalFundsInDAI.add(actualDAIReceived);\n  }\n\n  \n  function __register(uint256 _donationInDAI) internal {\n    require(cToken.balanceOf(msg.sender) == 0 && userInvestments[msg.sender].length == 0 && userCompoundOrders[msg.sender].length == 0); \n\n    \n    uint256 kroAmount = _donationInDAI.mul(PRECISION).div(kairoPrice());\n    require(cToken.generateTokens(msg.sender, kroAmount));\n\n    \n    _baseRiskStakeFallback[msg.sender] = kroAmount;\n\n    \n    _lastActiveCycle[msg.sender] = cycleNumber;\n\n    \n    totalFundsInDAI = totalFundsInDAI.add(_donationInDAI);\n    \n    \n    emit Register(msg.sender, _donationInDAI, kroAmount);\n  }\n\n  \n  function __deposit(uint256 _depositDAIAmount) internal {\n    \n    if (sToken.totalSupply() == 0 || totalFundsInDAI == 0) {\n      require(sToken.generateTokens(msg.sender, _depositDAIAmount));\n    } else {\n      require(sToken.generateTokens(msg.sender, _depositDAIAmount.mul(sToken.totalSupply()).div(totalFundsInDAI)));\n    }\n    totalFundsInDAI = totalFundsInDAI.add(_depositDAIAmount);\n  }\n\n  \n  function __withdraw(uint256 _withdrawDAIAmount) internal {\n    \n    require(sToken.destroyTokens(msg.sender, _withdrawDAIAmount.mul(sToken.totalSupply()).div(totalFundsInDAI)));\n    totalFundsInDAI = totalFundsInDAI.sub(_withdrawDAIAmount);\n  }\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_newPhase\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalFundsInDAI\",\"type\":\"uint256\"}],\"name\":\"ChangedPhase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_commission\",\"type\":\"uint256\"}],\"name\":\"CommissionPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_order\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_orderType\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stakeInWeis\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_costDAIAmount\",\"type\":\"uint256\"}],\"name\":\"CreatedCompoundOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stakeInWeis\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_buyPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_costDAIAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"CreatedInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_daiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"DeveloperInitiatedUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_nextVersion\",\"type\":\"address\"}],\"name\":\"FinalizedNextVersion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"}],\"name\":\"InitiatedUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_voteID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"ProposedCandidate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_donationInDAI\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_kairoReceived\",\"type\":\"uint256\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_order\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_repaidDAIAmount\",\"type\":\"uint256\"}],\"name\":\"RepaidCompoundOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"_inSupport\",\"type\":\"bool\"}],\"name\":\"SignaledUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_order\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_orderType\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_receivedKairo\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_earnedDAIAmount\",\"type\":\"uint256\"}],\"name\":\"SoldCompoundOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_receivedKairo\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_sellPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_earnedDAIAmount\",\"type\":\"uint256\"}],\"name\":\"SoldInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalCommissionInDAI\",\"type\":\"uint256\"}],\"name\":\"TotalCommissionPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_voteID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_inSupport\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_weight\",\"type\":\"uint256\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_daiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"ASSET_FEE_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CHUNK_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COLLATERAL_RATIO_MODIFIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMMISSION_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CYCLES_TILL_MATURITY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAI_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEXAG_ADDR\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FALLBACK_MAX_DONATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INACTIVE_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KYBER_ADDR\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_BUY_KRO_PROP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_KRO_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_RISK_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NEXT_PHASE_REWARD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERM_HINT\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROPOSE_SUBCHUNK_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"QUORUM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROI_BURN_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROI_PUNISH_NEG_BIAS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROI_PUNISH_SLOPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROI_PUNISH_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VOTE_SUCCESS_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"againstVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"baseRiskStakeFallback\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"betokenLogic\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"betokenLogic2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"candidates\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"compoundFactoryAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controlTokenAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentChunk\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentSubchunk\",\"outputs\":[{\"internalType\":\"enum BetokenStorage.Subchunk\",\"name\":\"_subchunk\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cycleNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cyclePhase\",\"outputs\":[{\"internalType\":\"enum BetokenStorage.CyclePhase\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_daiAmount\",\"type\":\"uint256\"}],\"name\":\"depositDAI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devFundingAccount\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devFundingRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"developerInitiateUpgrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chunkNumber\",\"type\":\"uint256\"}],\"name\":\"finalizeSuccessfulVote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"forVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalVotingWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_weight\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"getVotingWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_weight\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasFinalizedNextVersion\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasInitializedTokenListings\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"hasRedeemedCommissionForCycle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isCompoundToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isKyberToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPositionToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kairoPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_kairoPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"lastActiveCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"lastCommissionRedemption\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"managePhaseEndBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"managerVotes\",\"outputs\":[{\"internalType\":\"enum BetokenStorage.VoteDirection\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxRegistrationPaymentInDAI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxDonationInDAI\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"nextPhase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextVersion\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"phaseLengths\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"previousVersion\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chunkNumber\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"proposeCandidate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposersVotingWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyAddr\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_donationInDAI\",\"type\":\"uint256\"}],\"name\":\"registerWithDAI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"registerWithETH\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_donationInTokens\",\"type\":\"uint256\"}],\"name\":\"registerWithToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"riskTakenInCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saiAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_orderAddress\",\"type\":\"address\"}],\"name\":\"sellLeftoverCompoundOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"sellLeftoverFulcrumToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"sellLeftoverToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shareTokenAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_inSupport\",\"type\":\"bool\"}],\"name\":\"signalUpgrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTimeOfCyclePhase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCommissionLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"totalCommissionOfCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFundsInDAI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"upgradeSignal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"upgradeSignalStrength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeVotingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userCompoundOrders\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userInvestments\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cycleNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyCostInDAI\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSold\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chunkNumber\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_inSupport\",\"type\":\"bool\"}],\"name\":\"voteOnCandidate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountInDAI\",\"type\":\"uint256\"}],\"name\":\"withdrawDAI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountInDAI\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountInDAI\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BetokenLogic2","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://107afc4740f09fff2f4ce122af4f316a391686cdc57207218f953d80c90b6b55"}]}