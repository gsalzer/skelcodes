{"status":"1","message":"OK","result":[{"SourceCode":"// File: @digix/cacp-contracts/contracts/ACOwned.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n/// @title Owner based access control\r\n/// @author DigixGlobal\r\n\r\ncontract ACOwned {\r\n\r\n  address public owner;\r\n  address public new_owner;\r\n  bool is_ac_owned_init;\r\n\r\n  /// @dev Modifier to check if msg.sender is the contract owner\r\n  modifier if_owner() {\r\n    require(is_owner());\r\n    _;\r\n  }\r\n\r\n  function init_ac_owned()\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (is_ac_owned_init == false) {\r\n      owner = msg.sender;\r\n      is_ac_owned_init = true;\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  function is_owner()\r\n           private\r\n           constant\r\n           returns (bool _is_owner)\r\n  {\r\n    _is_owner = (msg.sender == owner);\r\n  }\r\n\r\n  function change_owner(address _new_owner)\r\n           if_owner()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    new_owner = _new_owner;\r\n    _success = true;\r\n  }\r\n\r\n  function claim_ownership()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    require(msg.sender == new_owner);\r\n    owner = new_owner;\r\n    _success = true;\r\n  }\r\n\r\n}\r\n\r\n// File: @digix/cacp-contracts/contracts/ACGroups.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n/// @title Owner based access control\r\n/// @author DigixGlobal\r\n\r\ncontract ACGroups is ACOwned {\r\n\r\n  bool is_ac_groups_init = false;\r\n\r\n  struct Group {\r\n    mapping(address => bool) members;\r\n  }\r\n\r\n  mapping (bytes32 => Group) groups;\r\n\r\n  modifier if_group(bytes32 _group_name) {\r\n    require(groups[_group_name].members[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  function init_ac_groups()\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if(is_ac_owned_init == false) {\r\n      init_ac_owned();\r\n    }\r\n    if(is_ac_groups_init == false) {\r\n      groups[\"admins\"].members[msg.sender] = true;\r\n      is_ac_groups_init = true;\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  function register_admin(address _newadmin)\r\n           if_owner\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    groups[\"admins\"].members[_newadmin] = true;\r\n    _success = true;\r\n  }\r\n\r\n  function unregister_admin(address _oldadmin)\r\n           if_owner\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    groups[\"admins\"].members[_oldadmin] = false;\r\n    _success = true;\r\n  }\r\n\r\n  function add_user_to_group(bytes32 _group, address _user)\r\n           if_group(\"admins\")\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    require(_group != \"admins\");\r\n    groups[_group].members[_user] = true;\r\n    _success = true;\r\n  }\r\n\r\n  function delete_user_from_group(bytes32 _group, address _user)\r\n           if_group(\"admins\")\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    require(_group != \"admins\");\r\n    groups[_group].members[_user] = false;\r\n    _success = true;\r\n  }\r\n\r\n  function is_group_member_of(bytes32 _group, address _user)\r\n           public\r\n           constant\r\n           returns (bool _ismember)\r\n  {\r\n    _ismember = groups[_group].members[_user];\r\n  }\r\n\r\n  function claim_ownership()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    // revoke admins role of old owner, add new owner to admins\r\n    groups[\"admins\"].members[owner] = false;\r\n    groups[\"admins\"].members[new_owner] = true;\r\n    _success = super.claim_ownership();\r\n  }\r\n}\r\n\r\n// File: @digix/cacp-contracts/contracts/Constants.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n/// @title Some useful constants\r\n/// @author DigixGlobal\r\n\r\ncontract Constants {\r\n  address constant NULL_ADDRESS = address(0x0);\r\n  uint256 constant ZERO = uint256(0);\r\n  bytes32 constant EMPTY = bytes32(0x0);\r\n}\r\n\r\n// File: @digix/cacp-contracts/contracts/ContractResolver.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n/// @title Contract Name Registry\r\n/// @author DigixGlobal\r\n\r\ncontract ContractResolver is ACGroups, Constants {\r\n\r\n  mapping (bytes32 => address) contracts;\r\n  event RegisterEvent(bytes32 indexed _contract_name,\r\n                      address indexed _contract_address);\r\n  event UnRegisterEvent(bytes32 indexed _contract_name);\r\n  bool public locked;\r\n  bool public time_locked;\r\n  uint public grace_period;\r\n\r\n  modifier unless_registered(bytes32 _key) {\r\n    require(contracts[_key] == NULL_ADDRESS);\r\n    _;\r\n  }\r\n\r\n  modifier if_owner_origin() {\r\n    require(tx.origin == owner);\r\n    _;\r\n  }\r\n\r\n  /// Function modifier to check if msg.sender corresponds to the resolved address of a given key\r\n  /// @param _contract The resolver key\r\n  modifier if_sender_is(bytes32 _contract) {\r\n    require(msg.sender == get_contract(_contract));\r\n    _;\r\n  }\r\n\r\n  modifier locked_after_period() {\r\n    if (time_locked == false) {\r\n      _;\r\n    } else {\r\n      require(grace_period >= now);\r\n      _;\r\n    }\r\n  }\r\n\r\n  modifier if_not_locked() {\r\n    require(locked == false);\r\n    _;\r\n  }\r\n\r\n  /// @dev ContractResolver constructor will perform the following: 1. Set msg.sender as the contract owner.  2. Adds msg.sender to the default groups 'admins' and 'nsadmins'\r\n  function ContractResolver() public\r\n  {\r\n    require(init_ac_groups());\r\n    groups[\"nsadmins\"].members[owner] = true;\r\n    locked = false;\r\n  }\r\n\r\n  /// TODO: this function can basically do everything register_contract can do (except for emitting an event). Maybe we should require that this function can only be called by a contract?\r\n  /// @dev Called at contract initialization\r\n  /// @param _key bytestring for CACP name\r\n  /// @param _contract_address The address of the contract to be registered\r\n  /// @return _success if the operation is successful\r\n  function init_register_contract(bytes32 _key, address _contract_address)\r\n           if_owner_origin()\r\n           if_not_locked()\r\n           unless_registered(_key)\r\n           locked_after_period()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    contracts[_key] = _contract_address;\r\n    _success = true;\r\n  }\r\n\r\n  /// @dev Lock the resolver from any further modifications.  This can only be called from an account that is part of the nsadmins group\r\n  /// @return _success if the operation is successful\r\n  function lock_resolver()\r\n           if_group(\"nsadmins\")\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    locked = true;\r\n    _success = true;\r\n  }\r\n\r\n  /// @dev Unlock the resolver to allow further modifications.  This can only be called from an account that is part of the nsadmins group\r\n  /// @return _success if the operation is successful\r\n  function unlock_resolver()\r\n           if_group(\"nsadmins\")\r\n           public\r\n           returns (bool _success)\r\n  {\r\n     locked = false;\r\n     _success = true;\r\n  }\r\n\r\n  /// @dev Enable time locking. This is potentially dangerous and must be from the owner\r\n  /// @param _grace_period the unix timestamp when the resolver is locked forever\r\n  function enable_time_locking(uint _grace_period)\r\n           if_owner()\r\n           locked_after_period()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    grace_period = _grace_period;\r\n    time_locked = true;\r\n    _success = true;\r\n  }\r\n\r\n  /// @dev Register a contract.  This can only be called from an account that is part of the nsadmins group\r\n  /// @param _key the bytestring of the contract name\r\n  /// @param _contract the address of the contract\r\n  /// @return _success if the operation is successful\r\n  function register_contract(bytes32 _key, address _contract)\r\n           if_group(\"nsadmins\")\r\n           if_owner_origin()\r\n           if_not_locked()\r\n           locked_after_period()\r\n           unless_registered(_key)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    contracts[_key] = _contract;\r\n    RegisterEvent(_key, _contract);\r\n    _success = true;\r\n  }\r\n\r\n  /// @dev Unregister a contract.  This can only be called from the contract with the key itself, which should be destroyed in the process\r\n  /// this must also be originated from the owner of this ContractResolver as well.\r\n  /// @param _key the bytestring of the contract name\r\n  /// @return _success if the operation is successful\r\n  function unregister_contract(bytes32 _key)\r\n           locked_after_period()\r\n           if_owner_origin()\r\n           if_not_locked()\r\n           if_sender_is(_key)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    delete contracts[_key];\r\n    UnRegisterEvent(_key);\r\n    _success = true;\r\n  }\r\n\r\n  /// @dev Get address of a contract\r\n  /// @param _key the bytestring name of the contract to look up\r\n  /// @return _contract the address of the contract\r\n  function get_contract(bytes32 _key)\r\n           public\r\n           constant\r\n           returns (address _contract)\r\n  {\r\n    require(contracts[_key] != NULL_ADDRESS);\r\n    _contract = contracts[_key];\r\n  }\r\n\r\n  function claim_ownership()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    // revoke nsadmins role of old owner, add new owner to nsadmins\r\n    groups[\"nsadmins\"].members[owner] = false;\r\n    groups[\"nsadmins\"].members[new_owner] = true;\r\n    _success = super.claim_ownership();\r\n  }\r\n}\r\n\r\n// File: @digix/cacp-contracts/contracts/ResolverClient.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n/// @title Contract Resolver Interface\r\n/// @author DigixGlobal\r\n\r\ncontract ResolverClient {\r\n\r\n  /// The address of the resolver contract for this project\r\n  address public resolver;\r\n  bytes32 public key;\r\n\r\n  /// Make our own address available to us as a constant\r\n  address public CONTRACT_ADDRESS;\r\n\r\n  /// Function modifier to check if msg.sender corresponds to the resolved address of a given key\r\n  /// @param _contract The resolver key\r\n  modifier if_sender_is(bytes32 _contract) {\r\n    require(msg.sender == ContractResolver(resolver).get_contract(_contract));\r\n    _;\r\n  }\r\n\r\n  /// Function modifier to check resolver's locking status.\r\n  modifier unless_resolver_is_locked() {\r\n    require(is_locked() == false);\r\n    _;\r\n  }\r\n\r\n  /// @dev Initialize new contract\r\n  /// @param _key the resolver key for this contract\r\n  /// @return _success if the initialization is successful\r\n  function init(bytes32 _key, address _resolver)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    bool _is_locked = ContractResolver(_resolver).locked();\r\n    if (_is_locked == false) {\r\n      CONTRACT_ADDRESS = address(this);\r\n      resolver = _resolver;\r\n      key = _key;\r\n      require(ContractResolver(resolver).init_register_contract(key, CONTRACT_ADDRESS));\r\n      _success = true;\r\n    }  else {\r\n      _success = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Destroy the contract and unregister self from the ContractResolver\r\n  /// @dev Can only be called by the owner of ContractResolver\r\n  function destroy()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    bool _is_locked = ContractResolver(resolver).locked();\r\n    require(!_is_locked);\r\n\r\n    address _owner_of_contract_resolver = ContractResolver(resolver).owner();\r\n    require(msg.sender == _owner_of_contract_resolver);\r\n\r\n    _success = ContractResolver(resolver).unregister_contract(key);\r\n    require(_success);\r\n\r\n    selfdestruct(_owner_of_contract_resolver);\r\n  }\r\n\r\n  /// @dev Check if resolver is locked\r\n  /// @return _locked if the resolver is currently locked\r\n  function is_locked()\r\n           private\r\n           constant\r\n           returns (bool _locked)\r\n  {\r\n    _locked = ContractResolver(resolver).locked();\r\n  }\r\n\r\n  /// @dev Get the address of a contract\r\n  /// @param _key the resolver key to look up\r\n  /// @return _contract the address of the contract\r\n  function get_contract(bytes32 _key)\r\n           public\r\n           constant\r\n           returns (address _contract)\r\n  {\r\n    _contract = ContractResolver(resolver).get_contract(_key);\r\n  }\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/lib/DoublyLinkedList.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\nlibrary DoublyLinkedList {\r\n\r\n  struct Item {\r\n    bytes32 item;\r\n    uint256 previous_index;\r\n    uint256 next_index;\r\n  }\r\n\r\n  struct Data {\r\n    uint256 first_index;\r\n    uint256 last_index;\r\n    uint256 count;\r\n    mapping(bytes32 => uint256) item_index;\r\n    mapping(uint256 => bool) valid_indexes;\r\n    Item[] collection;\r\n  }\r\n\r\n  struct IndexedUint {\r\n    mapping(bytes32 => Data) data;\r\n  }\r\n\r\n  struct IndexedAddress {\r\n    mapping(bytes32 => Data) data;\r\n  }\r\n\r\n  struct IndexedBytes {\r\n    mapping(bytes32 => Data) data;\r\n  }\r\n\r\n  struct Address {\r\n    Data data;\r\n  }\r\n\r\n  struct Bytes {\r\n    Data data;\r\n  }\r\n\r\n  struct Uint {\r\n    Data data;\r\n  }\r\n\r\n  uint256 constant NONE = uint256(0);\r\n  bytes32 constant EMPTY_BYTES = bytes32(0x0);\r\n  address constant NULL_ADDRESS = address(0x0);\r\n\r\n  function find(Data storage self, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    if ((self.item_index[_item] == NONE) && (self.count == NONE)) {\r\n      _item_index = NONE;\r\n    } else {\r\n      _item_index = self.item_index[_item];\r\n    }\r\n  }\r\n\r\n  function get(Data storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    if (self.valid_indexes[_item_index] == true) {\r\n      _item = self.collection[_item_index - 1].item;\r\n    } else {\r\n      _item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function append(Data storage self, bytes32 _data)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (find(self, _data) != NONE || _data == bytes32(\"\")) { // rejects addition of empty values\r\n      _success = false;\r\n    } else {\r\n      uint256 _index = uint256(self.collection.push(Item({item: _data, previous_index: self.last_index, next_index: NONE})));\r\n      if (self.last_index == NONE) {\r\n        if ((self.first_index != NONE) || (self.count != NONE)) {\r\n          revert();\r\n        } else {\r\n          self.first_index = self.last_index = _index;\r\n          self.count = 1;\r\n        }\r\n      } else {\r\n        self.collection[self.last_index - 1].next_index = _index;\r\n        self.last_index = _index;\r\n        self.count++;\r\n      }\r\n      self.valid_indexes[_index] = true;\r\n      self.item_index[_data] = _index;\r\n      _success = true;\r\n    }\r\n  }\r\n\r\n  function remove(Data storage self, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (self.valid_indexes[_index] == true) {\r\n      Item memory item = self.collection[_index - 1];\r\n      if (item.previous_index == NONE) {\r\n        self.first_index = item.next_index;\r\n      } else {\r\n        self.collection[item.previous_index - 1].next_index = item.next_index;\r\n      }\r\n\r\n      if (item.next_index == NONE) {\r\n        self.last_index = item.previous_index;\r\n      } else {\r\n        self.collection[item.next_index - 1].previous_index = item.previous_index;\r\n      }\r\n      delete self.collection[_index - 1];\r\n      self.valid_indexes[_index] = false;\r\n      delete self.item_index[item.item];\r\n      self.count--;\r\n      _success = true;\r\n    } else {\r\n      _success = false;\r\n    }\r\n  }\r\n\r\n  function remove_item(Data storage self, bytes32 _item)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    uint256 _item_index = find(self, _item);\r\n    if (_item_index != NONE) {\r\n      require(remove(self, _item_index));\r\n      _success = true;\r\n    } else {\r\n      _success = false;\r\n    }\r\n    return _success;\r\n  }\r\n\r\n  function total(Data storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = self.count;\r\n  }\r\n\r\n  function start(Data storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = self.first_index;\r\n    return _item_index;\r\n  }\r\n\r\n  function start_item(Data storage self)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    uint256 _item_index = start(self);\r\n    if (_item_index != NONE) {\r\n      _item = get(self, _item_index);\r\n    } else {\r\n      _item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function end(Data storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = self.last_index;\r\n    return _item_index;\r\n  }\r\n\r\n  function end_item(Data storage self)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    uint256 _item_index = end(self);\r\n    if (_item_index != NONE) {\r\n      _item = get(self, _item_index);\r\n    } else {\r\n      _item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function valid(Data storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = self.valid_indexes[_item_index];\r\n    //_yes = ((_item_index - 1) < self.collection.length);\r\n  }\r\n\r\n  function valid_item(Data storage self, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    uint256 _item_index = self.item_index[_item];\r\n    _yes = self.valid_indexes[_item_index];\r\n  }\r\n\r\n  function previous(Data storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    if (self.valid_indexes[_current_index] == true) {\r\n      _previous_index = self.collection[_current_index - 1].previous_index;\r\n    } else {\r\n      _previous_index = NONE;\r\n    }\r\n  }\r\n\r\n  function previous_item(Data storage self, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _previous_item)\r\n  {\r\n    uint256 _current_index = find(self, _current_item);\r\n    if (_current_index != NONE) {\r\n      uint256 _previous_index = previous(self, _current_index);\r\n      _previous_item = get(self, _previous_index);\r\n    } else {\r\n      _previous_item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function next(Data storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    if (self.valid_indexes[_current_index] == true) {\r\n      _next_index = self.collection[_current_index - 1].next_index;\r\n    } else {\r\n      _next_index = NONE;\r\n    }\r\n  }\r\n\r\n  function next_item(Data storage self, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _next_item)\r\n  {\r\n    uint256 _current_index = find(self, _current_item);\r\n    if (_current_index != NONE) {\r\n      uint256 _next_index = next(self, _current_index);\r\n      _next_item = get(self, _next_index);\r\n    } else {\r\n      _next_item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function find(Uint storage self, uint256 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = find(self.data, bytes32(_item));\r\n  }\r\n\r\n  function get(Uint storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = uint256(get(self.data, _item_index));\r\n  }\r\n\r\n\r\n  function append(Uint storage self, uint256 _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data, bytes32(_data));\r\n  }\r\n\r\n  function remove(Uint storage self, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data, _index);\r\n  }\r\n\r\n  function remove_item(Uint storage self, uint256 _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data, bytes32(_item));\r\n  }\r\n\r\n  function total(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data);\r\n  }\r\n\r\n  function start(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data);\r\n  }\r\n\r\n  function start_item(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _start_item)\r\n  {\r\n    _start_item = uint256(start_item(self.data));\r\n  }\r\n\r\n\r\n  function end(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data);\r\n  }\r\n\r\n  function end_item(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _end_item)\r\n  {\r\n    _end_item = uint256(end_item(self.data));\r\n  }\r\n\r\n  function valid(Uint storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data, _item_index);\r\n  }\r\n\r\n  function valid_item(Uint storage self, uint256 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data, bytes32(_item));\r\n  }\r\n\r\n  function previous(Uint storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data, _current_index);\r\n  }\r\n\r\n  function previous_item(Uint storage self, uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_item)\r\n  {\r\n    _previous_item = uint256(previous_item(self.data, bytes32(_current_item)));\r\n  }\r\n\r\n  function next(Uint storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data, _current_index);\r\n  }\r\n\r\n  function next_item(Uint storage self, uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _next_item)\r\n  {\r\n    _next_item = uint256(next_item(self.data, bytes32(_current_item)));\r\n  }\r\n\r\n  function find(Address storage self, address _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = find(self.data, bytes32(_item));\r\n  }\r\n\r\n  function get(Address storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = address(get(self.data, _item_index));\r\n  }\r\n\r\n\r\n  function find(IndexedUint storage self, bytes32 _collection_index, uint256 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = find(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function get(IndexedUint storage self, bytes32 _collection_index, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = uint256(get(self.data[_collection_index], _item_index));\r\n  }\r\n\r\n\r\n  function append(IndexedUint storage self, bytes32 _collection_index, uint256 _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data[_collection_index], bytes32(_data));\r\n  }\r\n\r\n  function remove(IndexedUint storage self, bytes32 _collection_index, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data[_collection_index], _index);\r\n  }\r\n\r\n  function remove_item(IndexedUint storage self, bytes32 _collection_index, uint256 _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function total(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data[_collection_index]);\r\n  }\r\n\r\n  function start(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data[_collection_index]);\r\n  }\r\n\r\n  function start_item(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _start_item)\r\n  {\r\n    _start_item = uint256(start_item(self.data[_collection_index]));\r\n  }\r\n\r\n\r\n  function end(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data[_collection_index]);\r\n  }\r\n\r\n  function end_item(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _end_item)\r\n  {\r\n    _end_item = uint256(end_item(self.data[_collection_index]));\r\n  }\r\n\r\n  function valid(IndexedUint storage self, bytes32 _collection_index, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data[_collection_index], _item_index);\r\n  }\r\n\r\n  function valid_item(IndexedUint storage self, bytes32 _collection_index, uint256 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function previous(IndexedUint storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function previous_item(IndexedUint storage self, bytes32 _collection_index, uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_item)\r\n  {\r\n    _previous_item = uint256(previous_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n  function next(IndexedUint storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function next_item(IndexedUint storage self, bytes32 _collection_index, uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _next_item)\r\n  {\r\n    _next_item = uint256(next_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n  function append(Address storage self, address _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data, bytes32(_data));\r\n  }\r\n\r\n  function remove(Address storage self, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data, _index);\r\n  }\r\n\r\n\r\n  function remove_item(Address storage self, address _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data, bytes32(_item));\r\n  }\r\n\r\n  function total(Address storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data);\r\n  }\r\n\r\n  function start(Address storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data);\r\n  }\r\n\r\n  function start_item(Address storage self)\r\n           public\r\n           constant\r\n           returns (address _start_item)\r\n  {\r\n    _start_item = address(start_item(self.data));\r\n  }\r\n\r\n\r\n  function end(Address storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data);\r\n  }\r\n\r\n  function end_item(Address storage self)\r\n           public\r\n           constant\r\n           returns (address _end_item)\r\n  {\r\n    _end_item = address(end_item(self.data));\r\n  }\r\n\r\n  function valid(Address storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data, _item_index);\r\n  }\r\n\r\n  function valid_item(Address storage self, address _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data, bytes32(_item));\r\n  }\r\n\r\n  function previous(Address storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data, _current_index);\r\n  }\r\n\r\n  function previous_item(Address storage self, address _current_item)\r\n           public\r\n           constant\r\n           returns (address _previous_item)\r\n  {\r\n    _previous_item = address(previous_item(self.data, bytes32(_current_item)));\r\n  }\r\n\r\n  function next(Address storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data, _current_index);\r\n  }\r\n\r\n  function next_item(Address storage self, address _current_item)\r\n           public\r\n           constant\r\n           returns (address _next_item)\r\n  {\r\n    _next_item = address(next_item(self.data, bytes32(_current_item)));\r\n  }\r\n\r\n  function append(IndexedAddress storage self, bytes32 _collection_index, address _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data[_collection_index], bytes32(_data));\r\n  }\r\n\r\n  function remove(IndexedAddress storage self, bytes32 _collection_index, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data[_collection_index], _index);\r\n  }\r\n\r\n\r\n  function remove_item(IndexedAddress storage self, bytes32 _collection_index, address _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function total(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data[_collection_index]);\r\n  }\r\n\r\n  function start(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data[_collection_index]);\r\n  }\r\n\r\n  function start_item(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (address _start_item)\r\n  {\r\n    _start_item = address(start_item(self.data[_collection_index]));\r\n  }\r\n\r\n\r\n  function end(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data[_collection_index]);\r\n  }\r\n\r\n  function end_item(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (address _end_item)\r\n  {\r\n    _end_item = address(end_item(self.data[_collection_index]));\r\n  }\r\n\r\n  function valid(IndexedAddress storage self, bytes32 _collection_index, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data[_collection_index], _item_index);\r\n  }\r\n\r\n  function valid_item(IndexedAddress storage self, bytes32 _collection_index, address _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function previous(IndexedAddress storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function previous_item(IndexedAddress storage self, bytes32 _collection_index, address _current_item)\r\n           public\r\n           constant\r\n           returns (address _previous_item)\r\n  {\r\n    _previous_item = address(previous_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n  function next(IndexedAddress storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function next_item(IndexedAddress storage self, bytes32 _collection_index, address _current_item)\r\n           public\r\n           constant\r\n           returns (address _next_item)\r\n  {\r\n    _next_item = address(next_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n\r\n  function find(Bytes storage self, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = find(self.data, _item);\r\n  }\r\n\r\n  function get(Bytes storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = get(self.data, _item_index);\r\n  }\r\n\r\n\r\n  function append(Bytes storage self, bytes32 _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data, _data);\r\n  }\r\n\r\n  function remove(Bytes storage self, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data, _index);\r\n  }\r\n\r\n\r\n  function remove_item(Bytes storage self, bytes32 _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data, _item);\r\n  }\r\n\r\n  function total(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data);\r\n  }\r\n\r\n  function start(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data);\r\n  }\r\n\r\n  function start_item(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (bytes32 _start_item)\r\n  {\r\n    _start_item = start_item(self.data);\r\n  }\r\n\r\n\r\n  function end(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data);\r\n  }\r\n\r\n  function end_item(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (bytes32 _end_item)\r\n  {\r\n    _end_item = end_item(self.data);\r\n  }\r\n\r\n  function valid(Bytes storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data, _item_index);\r\n  }\r\n\r\n  function valid_item(Bytes storage self, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data, _item);\r\n  }\r\n\r\n  function previous(Bytes storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data, _current_index);\r\n  }\r\n\r\n  function previous_item(Bytes storage self, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _previous_item)\r\n  {\r\n    _previous_item = previous_item(self.data, _current_item);\r\n  }\r\n\r\n  function next(Bytes storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data, _current_index);\r\n  }\r\n\r\n  function next_item(Bytes storage self, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _next_item)\r\n  {\r\n    _next_item = next_item(self.data, _current_item);\r\n  }\r\n\r\n  function append(IndexedBytes storage self, bytes32 _collection_index, bytes32 _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data[_collection_index], bytes32(_data));\r\n  }\r\n\r\n  function remove(IndexedBytes storage self, bytes32 _collection_index, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data[_collection_index], _index);\r\n  }\r\n\r\n\r\n  function remove_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function total(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data[_collection_index]);\r\n  }\r\n\r\n  function start(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data[_collection_index]);\r\n  }\r\n\r\n  function start_item(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (bytes32 _start_item)\r\n  {\r\n    _start_item = bytes32(start_item(self.data[_collection_index]));\r\n  }\r\n\r\n\r\n  function end(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data[_collection_index]);\r\n  }\r\n\r\n  function end_item(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (bytes32 _end_item)\r\n  {\r\n    _end_item = bytes32(end_item(self.data[_collection_index]));\r\n  }\r\n\r\n  function valid(IndexedBytes storage self, bytes32 _collection_index, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data[_collection_index], _item_index);\r\n  }\r\n\r\n  function valid_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function previous(IndexedBytes storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function previous_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _previous_item)\r\n  {\r\n    _previous_item = bytes32(previous_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n  function next(IndexedBytes storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function next_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _next_item)\r\n  {\r\n    _next_item = bytes32(next_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n\r\n}\r\n\r\n// File: @digix/solidity-statemachine/contracts/lib/StateMachine.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\nlibrary StateMachine {\r\n\r\n  using DoublyLinkedList for DoublyLinkedList.Bytes;\r\n\r\n  struct System {\r\n    mapping(bytes32 => Item) items;\r\n    mapping(address => uint256) to_role;\r\n    mapping(uint256 => mapping (uint256 => mapping(uint256 => bool))) access_control;\r\n    mapping(uint256 => DoublyLinkedList.Bytes) lists_by_state;\r\n    mapping(uint256 => bytes32) state_ids_to_name;\r\n    mapping(uint256 => bytes32) role_ids_to_name;\r\n    DoublyLinkedList.Bytes global_list;\r\n    bytes32 seed;\r\n  }\r\n\r\n  struct Item {\r\n    uint256 state;\r\n  }\r\n\r\n  function set_state_name(System storage _system, uint256 _state_id, bytes32 _state_name)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _system.state_ids_to_name[_state_id] = _state_name;\r\n    _success = true;\r\n  }\r\n\r\n  function get_state_name(System storage _system, uint256 _state_id)\r\n           internal\r\n           constant\r\n           returns (bytes32 _state_name)\r\n  {\r\n    if (_state_id == 0) {\r\n      _state_name = bytes32(\"none\");\r\n    } else {\r\n      _state_name = _system.state_ids_to_name[_state_id];\r\n    }\r\n  }\r\n\r\n  function get_item_state_id(System storage _system, bytes32 _item)\r\n           internal\r\n           constant\r\n           returns (uint256 _state_id)\r\n  {\r\n    _state_id = _system.items[_item].state;\r\n  }\r\n\r\n  function get_item_state_name(System storage _system, bytes32 _item)\r\n           internal\r\n           constant\r\n           returns (bytes32 _state_name)\r\n  {\r\n    _state_name = get_state_name(_system, get_item_state_id(_system, _item));\r\n  }\r\n\r\n  function set_role_name(System storage _system, uint256 _role_id, bytes32 _role_name)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _system.role_ids_to_name[_role_id] = _role_name;\r\n    _success = true;\r\n  }\r\n\r\n  function get_role_name(System storage _system, uint256 _role_id)\r\n           internal\r\n           constant\r\n           returns (bytes32 _role_name)\r\n  {\r\n    if (_role_id == 0) {\r\n      _role_name = bytes32(\"none\");\r\n    } else {\r\n      _role_name = _system.role_ids_to_name[_role_id];\r\n    }\r\n  }\r\n\r\n  function get_entity_role_id(System storage _system, address _entity)\r\n           internal\r\n           constant\r\n           returns (uint256 _role_id)\r\n  {\r\n    _role_id = _system.to_role[_entity];\r\n  }\r\n\r\n  function set_role(System storage _system, address _entity, uint256 _role_id)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _system.to_role[_entity] = _role_id;\r\n    _success = true;\r\n  }\r\n\r\n  function unset_role(System storage _system, address _entity)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (_system.to_role[_entity] == 0) {\r\n      _success = false;\r\n    } else {\r\n      delete _system.to_role[_entity];\r\n      _success = true;\r\n    }\r\n  }\r\n\r\n  function grant_access(System storage _system, uint256 _by_role, uint256 _from_state, uint256 _to_state)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (_system.access_control[_by_role][_from_state][_to_state] == false) {\r\n      _system.access_control[_by_role][_from_state][_to_state] = true;\r\n      _success = true;\r\n    } else {\r\n      _success = false;\r\n    }\r\n  }\r\n\r\n  function revoke_access(System storage _system, uint256 _by_role, uint256 _from_state, uint256 _to_state)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if(_system.access_control[_by_role][_from_state][_to_state] == true) {\r\n      _system.access_control[_by_role][_from_state][_to_state] = false;\r\n      _success = true;\r\n    } else {\r\n      _success = false;\r\n    }\r\n  }\r\n\r\n  function init(System storage _system)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    require(_system.seed == bytes32(0x0));\r\n    _system.seed = bytes32(address(this));\r\n    _success = true;\r\n  }\r\n\r\n  function get_new_identifier(System storage _system)\r\n           internal\r\n           returns (bytes32 _new_id)\r\n  {\r\n    require(_system.seed != bytes32(0x0));\r\n    _system.seed = keccak256(_system.seed, now);\r\n    _new_id = _system.seed;\r\n  }\r\n\r\n  function create_item(System storage _system, uint256 _by_role)\r\n           internal\r\n           returns (bool _success, bytes32 _item)\r\n  {\r\n    require(_system.seed != bytes32(0x0)); // system must be init-ed first, and hence seed must already have value\r\n    if (_system.access_control[_by_role][0][1] == true) {\r\n      _item = get_new_identifier(_system);\r\n      _system.items[_item].state = 1;\r\n      require(_system.global_list.append(_item));\r\n      require(_system.lists_by_state[1].append(_item));\r\n      _success = true;\r\n    } else {\r\n      _success = false;\r\n      _item = bytes32(0x0);\r\n    }\r\n  }\r\n\r\n  function change_item_state(System storage _system, uint256 _by_role, bytes32 _item, uint256 _to_state)\r\n           internal\r\n           returns (bool _success, uint256 _from_state, uint256 _new_state)\r\n  {\r\n\r\n    _from_state = _system.items[_item].state;\r\n\r\n    bool _append_success;\r\n    bool _remove_success;\r\n    _new_state = _from_state;\r\n    _success = false;\r\n\r\n    if (_system.access_control[0][_from_state][_to_state] == true) {\r\n      _by_role = 0;\r\n    }\r\n\r\n    if (_system.access_control[_by_role][_from_state][_to_state] == true) {\r\n      _system.items[_item].state = _to_state;\r\n      _append_success = _system.lists_by_state[_to_state].append(_item);\r\n      _remove_success = _system.lists_by_state[_from_state].remove_item(_item);\r\n      _new_state = _system.items[_item].state;\r\n      _success = (_append_success && _remove_success);\r\n    }\r\n  }\r\n\r\n  function total_in_state(System storage _system, uint256 _state_id)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = _system.lists_by_state[_state_id].total();\r\n  }\r\n\r\n  function total(System storage _system)\r\n           public\r\n           constant\r\n           returns (uint256 _global_count)\r\n  {\r\n    _global_count = _system.global_list.total();\r\n  }\r\n\r\n  function get_first_in_global(System storage _system)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _system.global_list.start_item();\r\n  }\r\n\r\n  function get_last_in_global(System storage _system)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _system.global_list.end_item();\r\n  }\r\n\r\n  function get_next_from_in_global(System storage _system, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _system.global_list.next_item(_current_item);\r\n  }\r\n\r\n  function get_previous_from_in_global(System storage _system, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _system.global_list.previous_item(_current_item);\r\n  }\r\n\r\n  function get_first_in_state(System storage _system, uint256 _state_id)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _system.lists_by_state[_state_id].start_item();\r\n  }\r\n\r\n  function get_last_in_state(System storage _system, uint256 _state_id)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _system.lists_by_state[_state_id].end_item();\r\n  }\r\n\r\n  function get_next_from_in_state(System storage _system, uint256 _state_id, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _system.lists_by_state[_state_id].next_item(_current_item);\r\n  }\r\n\r\n  function get_previous_from_in_state(System storage _system, uint256 _state_id, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _system.lists_by_state[_state_id].previous_item(_current_item);\r\n  }\r\n\r\n  function check_role_access(System storage _system, uint256 _role_id, uint256 _from_state, uint256 _to_state)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = _system.access_control[_role_id][_from_state][_to_state];\r\n  }\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/abstract/IndexedBytesIteratorStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n/**\r\n  @title Indexed Bytes Iterator Storage\r\n  @author DigixGlobal Pte Ltd\r\n  @notice This contract utilizes: [Doubly Linked List](/DoublyLinkedList)\r\n*/\r\ncontract IndexedBytesIteratorStorage {\r\n\r\n  using DoublyLinkedList for DoublyLinkedList.IndexedBytes;\r\n\r\n  /**\r\n    @notice Reads the first item from an Indexed Bytes Doubly Linked List\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @return {\"_item\":\"The first item from the specified `_list`\"}\r\n  */\r\n  function read_first_from_indexed_bytesarray(DoublyLinkedList.IndexedBytes storage _list, bytes32 _collection_index)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _list.start_item(_collection_index);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the last item from an Indexed Bytes Doubly Linked List\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @return {\"_item\":\"The last item from the specified `_list`\"}\r\n  */\r\n  function read_last_from_indexed_bytesarray(DoublyLinkedList.IndexedBytes storage _list, bytes32 _collection_index)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _list.end_item(_collection_index);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the next item from an Indexed Bytes Doubly Linked List\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @param _current_item The current item to be used as base line\r\n    @return {\"_item\":\"The next item from the specified `_current_item`\"}\r\n  */\r\n  function read_next_from_indexed_bytesarray(DoublyLinkedList.IndexedBytes storage _list, bytes32 _collection_index, bytes32 _current_item)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _list.next_item(_collection_index, _current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the previous item from an Indexed Bytes Doubly Linked List\r\n    @param _list The source list\r\n    @param _collection_index Collection Index\r\n    @param _current_item The current item to be used as base line\r\n    @return {\"_item\":\"The previous item from the specified `_current_item`\"}\r\n  */\r\n  function read_previous_from_indexed_bytesarray(DoublyLinkedList.IndexedBytes storage _list, bytes32 _collection_index, bytes32 _current_item)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _list.previous_item(_collection_index, _current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the list of Indexed Bytes and returns length of the list\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @return {\"_count\":\"\"}\r\n  */\r\n  function read_total_indexed_bytesarray(DoublyLinkedList.IndexedBytes storage _list, bytes32 _collection_index)\r\n           internal\r\n           constant\r\n           returns (uint256 _count)\r\n  {\r\n    _count = _list.total(_collection_index);\r\n  }\r\n\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/abstract/BytesIteratorStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n/**\r\n  @title Bytes Iterator Storage\r\n  @author DigixGlobal Pte Ltd\r\n*/\r\ncontract BytesIteratorStorage {\r\n\r\n  // Initialize Doubly Linked List of Bytes\r\n  using DoublyLinkedList for DoublyLinkedList.Bytes;\r\n\r\n  /**\r\n    @notice Reads the first item from the list of Bytes\r\n    @param _list The source list\r\n    @return {\"_item\": \"The first item from the list\"}\r\n  */\r\n  function read_first_from_bytesarray(DoublyLinkedList.Bytes storage _list)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _list.start_item();\r\n  }\r\n\r\n  /**\r\n    @notice Reads the last item from the list of Bytes\r\n    @param _list The source list\r\n    @return {\"_item\": \"The last item from the list\"}\r\n  */\r\n  function read_last_from_bytesarray(DoublyLinkedList.Bytes storage _list)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _list.end_item();\r\n  }\r\n\r\n  /**\r\n    @notice Reads the next item on the list of Bytes\r\n    @param _list The source list\r\n    @param _current_item The current item to be used as base line\r\n    @return {\"_item\": \"The next item from the list based on the specieid `_current_item`\"}\r\n    TODO: Need to verify what happens if the specified `_current_item` is the last item from the list\r\n  */\r\n  function read_next_from_bytesarray(DoublyLinkedList.Bytes storage _list, bytes32 _current_item)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _list.next_item(_current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the previous item on the list of Bytes\r\n    @param _list The source list\r\n    @param _current_item The current item to be used as base line\r\n    @return {\"_item\": \"The previous item from the list based on the spcified `_current_item`\"}\r\n    TODO: Need to verify what happens if the specified `_current_item` is the first item from the list\r\n  */\r\n  function read_previous_from_bytesarray(DoublyLinkedList.Bytes storage _list, bytes32 _current_item)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _list.previous_item(_current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the list of Bytes and returns the length of the list\r\n    @param _list The source list\r\n    @return {\"count\": \"`uint256` The lenght of the list\"}\r\n\r\n  */\r\n  function read_total_bytesarray(DoublyLinkedList.Bytes storage _list)\r\n           internal\r\n           constant\r\n           returns (uint256 _count)\r\n  {\r\n    _count = _list.total();\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/common/DigixConstants.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\ncontract DigixConstants {\r\n    /// general constants\r\n    uint256 constant SECONDS_IN_A_DAY = 24 * 60 * 60;\r\n\r\n    /// asset events\r\n    uint256 constant ASSET_EVENT_CREATED_VENDOR_ORDER = 1;\r\n    uint256 constant ASSET_EVENT_CREATED_TRANSFER_ORDER = 2;\r\n    uint256 constant ASSET_EVENT_CREATED_REPLACEMENT_ORDER = 3;\r\n    uint256 constant ASSET_EVENT_FULFILLED_VENDOR_ORDER = 4;\r\n    uint256 constant ASSET_EVENT_FULFILLED_TRANSFER_ORDER = 5;\r\n    uint256 constant ASSET_EVENT_FULFILLED_REPLACEMENT_ORDER = 6;\r\n    uint256 constant ASSET_EVENT_MINTED = 7;\r\n    uint256 constant ASSET_EVENT_MINTED_REPLACEMENT = 8;\r\n    uint256 constant ASSET_EVENT_RECASTED = 9;\r\n    uint256 constant ASSET_EVENT_REDEEMED = 10;\r\n    uint256 constant ASSET_EVENT_FAILED_AUDIT = 11;\r\n    uint256 constant ASSET_EVENT_ADMIN_FAILED = 12;\r\n    uint256 constant ASSET_EVENT_REMINTED = 13;\r\n\r\n    /// roles\r\n    uint256 constant ROLE_ZERO_ANYONE = 0;\r\n    uint256 constant ROLE_ROOT = 1;\r\n    uint256 constant ROLE_VENDOR = 2;\r\n    uint256 constant ROLE_XFERAUTH = 3;\r\n    uint256 constant ROLE_POPADMIN = 4;\r\n    uint256 constant ROLE_CUSTODIAN = 5;\r\n    uint256 constant ROLE_AUDITOR = 6;\r\n    uint256 constant ROLE_MARKETPLACE_ADMIN = 7;\r\n    uint256 constant ROLE_KYC_ADMIN = 8;\r\n    uint256 constant ROLE_FEES_ADMIN = 9;\r\n    uint256 constant ROLE_DOCS_UPLOADER = 10;\r\n    uint256 constant ROLE_KYC_RECASTER = 11;\r\n    uint256 constant ROLE_FEES_DISTRIBUTION_ADMIN = 12;\r\n\r\n    /// states\r\n    uint256 constant STATE_ZERO_UNDEFINED = 0;\r\n    uint256 constant STATE_CREATED = 1;\r\n    uint256 constant STATE_VENDOR_ORDER = 2;\r\n    uint256 constant STATE_TRANSFER = 3;\r\n    uint256 constant STATE_CUSTODIAN_DELIVERY = 4;\r\n    uint256 constant STATE_MINTED = 5;\r\n    uint256 constant STATE_AUDIT_FAILURE = 6;\r\n    uint256 constant STATE_REPLACEMENT_ORDER = 7;\r\n    uint256 constant STATE_REPLACEMENT_DELIVERY = 8;\r\n    uint256 constant STATE_RECASTED = 9;\r\n    uint256 constant STATE_REDEEMED = 10;\r\n    uint256 constant STATE_ADMIN_FAILURE = 11;\r\n\r\n\r\n\r\n    /// interactive contracts\r\n    bytes32 constant CONTRACT_INTERACTIVE_ASSETS_EXPLORER = \"i:asset:explorer\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_DIGIX_DIRECTORY = \"i:directory\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE = \"i:mp\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_ADMIN = \"i:mpadmin\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_POPADMIN = \"i:popadmin\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_PRODUCTS_LIST = \"i:products\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_TOKEN = \"i:token\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_BULK_WRAPPER = \"i:bulk-wrapper\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_TOKEN_CONFIG = \"i:token:config\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_TOKEN_INFORMATION = \"i:token:information\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_INFORMATION = \"i:mp:information\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_IDENTITY = \"i:identity\";\r\n\r\n\r\n    /// controller contracts\r\n    bytes32 constant CONTRACT_CONTROLLER_ASSETS = \"c:asset\";\r\n    bytes32 constant CONTRACT_CONTROLLER_ASSETS_RECAST = \"c:asset:recast\";\r\n    bytes32 constant CONTRACT_CONTROLLER_ASSETS_EXPLORER = \"c:explorer\";\r\n    bytes32 constant CONTRACT_CONTROLLER_DIGIX_DIRECTORY = \"c:directory\";\r\n    bytes32 constant CONTRACT_CONTROLLER_MARKETPLACE = \"c:mp\";\r\n    bytes32 constant CONTRACT_CONTROLLER_MARKETPLACE_ADMIN = \"c:mpadmin\";\r\n    bytes32 constant CONTRACT_CONTROLLER_PRODUCTS_LIST = \"c:products\";\r\n\r\n    bytes32 constant CONTRACT_CONTROLLER_TOKEN_APPROVAL = \"c:token:approval\";\r\n    bytes32 constant CONTRACT_CONTROLLER_TOKEN_CONFIG = \"c:token:config\";\r\n    bytes32 constant CONTRACT_CONTROLLER_TOKEN_INFO = \"c:token:info\";\r\n    bytes32 constant CONTRACT_CONTROLLER_TOKEN_TRANSFER = \"c:token:transfer\";\r\n\r\n    bytes32 constant CONTRACT_CONTROLLER_JOB_ID = \"c:jobid\";\r\n    bytes32 constant CONTRACT_CONTROLLER_IDENTITY = \"c:identity\";\r\n\r\n    /// storage contracts\r\n    bytes32 constant CONTRACT_STORAGE_ASSETS = \"s:asset\";\r\n    bytes32 constant CONTRACT_STORAGE_ASSET_EVENTS = \"s:asset:events\";\r\n    bytes32 constant CONTRACT_STORAGE_DIGIX_DIRECTORY = \"s:directory\";\r\n    bytes32 constant CONTRACT_STORAGE_MARKETPLACE = \"s:mp\";\r\n    bytes32 constant CONTRACT_STORAGE_PRODUCTS_LIST = \"s:products\";\r\n    bytes32 constant CONTRACT_STORAGE_GOLD_TOKEN = \"s:goldtoken\";\r\n    bytes32 constant CONTRACT_STORAGE_JOB_ID = \"s:jobid\";\r\n    bytes32 constant CONTRACT_STORAGE_IDENTITY = \"s:identity\";\r\n\r\n    /// service contracts\r\n    bytes32 constant CONTRACT_SERVICE_TOKEN_DEMURRAGE = \"sv:tdemurrage\";\r\n    bytes32 constant CONTRACT_SERVICE_MARKETPLACE = \"sv:mp\";\r\n    bytes32 constant CONTRACT_SERVICE_DIRECTORY = \"sv:directory\";\r\n\r\n    /// fees distributors\r\n    bytes32 constant CONTRACT_DEMURRAGE_FEES_DISTRIBUTOR = \"fees:distributor:demurrage\";\r\n    bytes32 constant CONTRACT_RECAST_FEES_DISTRIBUTOR = \"fees:distributor:recast\";\r\n    bytes32 constant CONTRACT_TRANSFER_FEES_DISTRIBUTOR = \"fees:distributor:transfer\";\r\n\r\n}\r\n\r\n// File: contracts/storage/AssetsStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract AssetsStorage is ResolverClient, IndexedBytesIteratorStorage, BytesIteratorStorage, DigixConstants {\r\n\r\n  using StateMachine for StateMachine.System;\r\n  using DoublyLinkedList for DoublyLinkedList.IndexedBytes;\r\n  using DoublyLinkedList for DoublyLinkedList.Bytes;\r\n\r\n  struct Item {\r\n    uint256 product_id;\r\n    uint256 ng_weight;\r\n    uint256 effective_ng_weight;\r\n    bytes32 serial;\r\n    uint256 time_minted;\r\n    uint256 redeem_deadline;\r\n    address mint_target;\r\n    address redeem_for;\r\n    bytes32 replaced_by; // id of the item that replaces this item if it fails audit\r\n    bytes32 replaces; // id of the item that this item replaces\r\n  }\r\n\r\n  struct System {\r\n    StateMachine.System state_machine;\r\n    DoublyLinkedList.Bytes global_audit_documents;\r\n    DoublyLinkedList.IndexedBytes asset_documents;\r\n    DoublyLinkedList.IndexedBytes user_recasts;\r\n    mapping (bytes32 => Item) items_by_id;\r\n    uint256 last_global_audit_time;\r\n    uint256 redeem_period;              // Recaster has to redeem the asset within redeem_period days\r\n    // last_asset_with_serial[serial_no] is the asset id of the latest asset that was added into the system with that serial_no\r\n    // note that a gold bar with the same serial number can go through multiple cycles of minting and redeeming\r\n    // and last_asset_with_serial records the asset id in the last cycle\r\n    mapping (bytes32 => bytes32) last_asset_with_serial;\r\n  }\r\n\r\n  System system;\r\n\r\n  function AssetsStorage(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_STORAGE_ASSETS, _resolver));\r\n    require(system.state_machine.init());\r\n    system.redeem_period = 31; // default to 31 days\r\n\r\n    // roles\r\n    system.state_machine.set_role_name(ROLE_VENDOR, \"vendor\");\r\n    system.state_machine.set_role_name(ROLE_XFERAUTH, \"xferauth\");\r\n    system.state_machine.set_role_name(ROLE_POPADMIN, \"popadmin\");\r\n    system.state_machine.set_role_name(ROLE_CUSTODIAN, \"custodian\");\r\n    system.state_machine.set_role_name(ROLE_AUDITOR, \"auditor\");\r\n\r\n    // state names\r\n    system.state_machine.set_state_name(STATE_CREATED, \"created\");\r\n    system.state_machine.set_state_name(STATE_VENDOR_ORDER, \"vendor_order\");\r\n    system.state_machine.set_state_name(STATE_TRANSFER, \"transfer\");\r\n    system.state_machine.set_state_name(STATE_CUSTODIAN_DELIVERY, \"custodian_delivery\");\r\n    system.state_machine.set_state_name(STATE_MINTED, \"minted\");\r\n    system.state_machine.set_state_name(STATE_AUDIT_FAILURE, \"audit_failure\");\r\n    system.state_machine.set_state_name(STATE_REPLACEMENT_ORDER, \"replacement_order\");\r\n    system.state_machine.set_state_name(STATE_REPLACEMENT_DELIVERY, \"replacement_delivery\");\r\n    system.state_machine.set_state_name(STATE_RECASTED, \"recasted\");\r\n    system.state_machine.set_state_name(STATE_REDEEMED, \"redeemed\");\r\n    system.state_machine.set_state_name(STATE_ADMIN_FAILURE, \"admin_failure\");\r\n\r\n    // popadmin: create an asset item\r\n    system.state_machine.grant_access(ROLE_POPADMIN, STATE_ZERO_UNDEFINED, STATE_CREATED);\r\n\r\n    // popadmin: change a newly created asset to 'vendor_order'\r\n    system.state_machine.grant_access(ROLE_POPADMIN, STATE_CREATED, STATE_VENDOR_ORDER);\r\n\r\n    // popadmin: change a newly created asset to 'transfer'\r\n    system.state_machine.grant_access(ROLE_POPADMIN, STATE_CREATED, STATE_TRANSFER);\r\n\r\n    // vendor: vendor_order to custodian_delivery\r\n    system.state_machine.grant_access(ROLE_VENDOR, STATE_VENDOR_ORDER, STATE_CUSTODIAN_DELIVERY);\r\n\r\n    // xferauth: transfer to custodian_delivery\r\n    system.state_machine.grant_access(ROLE_XFERAUTH, STATE_TRANSFER, STATE_CUSTODIAN_DELIVERY);\r\n\r\n    // custodian: custodian_delivery to minted\r\n    system.state_machine.grant_access(ROLE_CUSTODIAN, STATE_CUSTODIAN_DELIVERY, STATE_MINTED);\r\n\r\n    // auditor: minted to audit_failure\r\n    system.state_machine.grant_access(ROLE_AUDITOR, STATE_MINTED, STATE_AUDIT_FAILURE);\r\n\r\n    // popadmin: created to replacement_order\r\n    system.state_machine.grant_access(ROLE_POPADMIN, STATE_CREATED, STATE_REPLACEMENT_ORDER);\r\n\r\n    // vendor: replacement_order to replacement_delivery\r\n    system.state_machine.grant_access(ROLE_VENDOR, STATE_REPLACEMENT_ORDER, STATE_REPLACEMENT_DELIVERY);\r\n\r\n    // popadmin: vendor_order to admin_failure\r\n    system.state_machine.grant_access(ROLE_POPADMIN, STATE_VENDOR_ORDER, STATE_ADMIN_FAILURE);\r\n\r\n    // popadmin: transfer to admin_failure\r\n    system.state_machine.grant_access(ROLE_POPADMIN, STATE_TRANSFER, STATE_ADMIN_FAILURE);\r\n\r\n    // popadmin: custodian_delivery to admin_failure\r\n    system.state_machine.grant_access(ROLE_POPADMIN, STATE_CUSTODIAN_DELIVERY, STATE_ADMIN_FAILURE);\r\n\r\n    // popadmin: replacement_order to admin_failure\r\n    system.state_machine.grant_access(ROLE_POPADMIN, STATE_REPLACEMENT_ORDER, STATE_ADMIN_FAILURE);\r\n\r\n    // popadmin: replacement_delivery to admin_failure\r\n    system.state_machine.grant_access(ROLE_POPADMIN, STATE_REPLACEMENT_DELIVERY, STATE_ADMIN_FAILURE);\r\n\r\n    // custodian: replacement_delivery to minted\r\n    system.state_machine.grant_access(ROLE_CUSTODIAN, STATE_REPLACEMENT_DELIVERY, STATE_MINTED);\r\n\r\n    // any: minted to recasted\r\n    system.state_machine.grant_access(ROLE_ZERO_ANYONE, STATE_MINTED, STATE_RECASTED);\r\n\r\n    // popadmin: recasted to redeemed\r\n    system.state_machine.grant_access(ROLE_POPADMIN, STATE_RECASTED, STATE_REDEEMED);\r\n\r\n    // popadmin: recasted to minted\r\n    system.state_machine.grant_access(ROLE_POPADMIN, STATE_RECASTED, STATE_MINTED);\r\n\r\n    // kycrecaster: recasted to minted (only if reminted by recaster)\r\n    system.state_machine.grant_access(ROLE_KYC_RECASTER, STATE_RECASTED, STATE_MINTED);\r\n  }\r\n\r\n  function read_asset_info(bytes32 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _product_id, uint256 _ng_weight, uint256 _effective_ng_weight,\r\n                    bytes32 _serial, uint256 _state_id, uint256 _documents_count, uint256 _time_minted, uint256 _redeem_deadline)\r\n  {\r\n    _product_id = system.items_by_id[_item].product_id;\r\n    _ng_weight = system.items_by_id[_item].ng_weight;\r\n    _effective_ng_weight = system.items_by_id[_item].effective_ng_weight;\r\n    _serial = system.items_by_id[_item].serial;\r\n    _state_id = system.state_machine.get_item_state_id(_item);\r\n    _documents_count = read_total_asset_documents(_item);\r\n    _time_minted = system.items_by_id[_item].time_minted;\r\n    _redeem_deadline = system.items_by_id[_item].redeem_deadline;\r\n  }\r\n\r\n  function read_last_asset_with_serial(bytes32 _serial)\r\n           public\r\n           constant\r\n           returns (bytes32 _asset_id)\r\n  {\r\n    _asset_id = system.last_asset_with_serial[_serial];\r\n  }\r\n\r\n  function read_asset_state(bytes32 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _state_id)\r\n  {\r\n    _state_id = system.state_machine.get_item_state_id(_item);\r\n  }\r\n\r\n  function read_redeem_period()\r\n           public\r\n           constant\r\n           returns (uint256 _redeem_period)\r\n  {\r\n    _redeem_period = system.redeem_period;\r\n  }\r\n\r\n  function read_asset_details(bytes32 _item)\r\n           public\r\n           constant\r\n           returns (address _mint_target, address _redeem_for, bytes32 _replaced_by, bytes32 _replaces)\r\n  {\r\n    _mint_target = system.items_by_id[_item].mint_target;\r\n    _redeem_for = system.items_by_id[_item].redeem_for;\r\n    _replaced_by = system.items_by_id[_item].replaced_by;\r\n    _replaces = system.items_by_id[_item].replaces;\r\n  }\r\n\r\n  function read_last_global_audit_time()\r\n           public\r\n           constant\r\n           returns (uint256 _last_global_audit_time)\r\n  {\r\n    _last_global_audit_time = system.last_global_audit_time;\r\n  }\r\n\r\n  function read_state_name(uint256 _state_id)\r\n           public\r\n           constant\r\n           returns (bytes32 _state_name)\r\n  {\r\n    _state_name = system.state_machine.get_state_name(_state_id);\r\n  }\r\n\r\n  function read_item_state_name(bytes32 _item)\r\n           public\r\n           constant\r\n           returns (bytes32 _state_name)\r\n  {\r\n    _state_name = read_state_name(system.state_machine.get_item_state_id(_item));\r\n  }\r\n\r\n  function read_first_item_in_state(bytes32 _state_id)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = system.state_machine.get_first_in_state(uint256(_state_id));\r\n  }\r\n\r\n  function read_last_item_in_state(bytes32 _state_id)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = system.state_machine.get_last_in_state(uint256(_state_id));\r\n  }\r\n\r\n  function read_next_item_from_item_in_state(bytes32 _state_id, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = system.state_machine.get_next_from_in_state(uint256(_state_id), _current_item);\r\n  }\r\n\r\n  function read_previous_item_from_item_in_state(bytes32 _state_id, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = system.state_machine.get_previous_from_in_state(uint256(_state_id), _current_item);\r\n  }\r\n\r\n  function read_total_items_in_state(bytes32 _state_id)\r\n           public\r\n           constant\r\n           returns (uint256 _total_items)\r\n  {\r\n    _total_items = system.state_machine.total_in_state(uint256(_state_id));\r\n  }\r\n\r\n\r\n  function read_total_asset_documents(bytes32 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = read_total_indexed_bytesarray(system.asset_documents, _item);\r\n  }\r\n\r\n  function read_first_asset_document(bytes32 _item)\r\n           public\r\n           constant\r\n           returns (bytes32 _document)\r\n  {\r\n    _document = read_first_from_indexed_bytesarray(system.asset_documents, _item);\r\n  }\r\n\r\n  function read_last_asset_document(bytes32 _item)\r\n           public\r\n           constant\r\n           returns (bytes32 _document)\r\n  {\r\n    _document = read_last_from_indexed_bytesarray(system.asset_documents, _item);\r\n  }\r\n\r\n  function read_next_asset_document_from_document(bytes32 _item, bytes32 _current_document)\r\n           public\r\n           constant\r\n           returns (bytes32 _document)\r\n  {\r\n    _document = read_next_from_indexed_bytesarray(system.asset_documents, _item, _current_document);\r\n  }\r\n\r\n\r\n  function read_previous_asset_document_from_document(bytes32 _item, bytes32 _current_document)\r\n           public\r\n           constant\r\n           returns (bytes32 _document)\r\n  {\r\n    _document = read_previous_from_indexed_bytesarray(system.asset_documents, _item, _current_document);\r\n  }\r\n\r\n  function read_first_global_audit()\r\n           public\r\n           constant\r\n           returns (bytes32 _document)\r\n  {\r\n    _document = read_first_from_bytesarray(system.global_audit_documents);\r\n  }\r\n\r\n  function read_last_global_audit()\r\n           public\r\n           constant\r\n           returns (bytes32 _document)\r\n  {\r\n    _document = read_last_from_bytesarray(system.global_audit_documents);\r\n  }\r\n\r\n  function read_next_global_audit_from_audit(bytes32 _current_document)\r\n           public\r\n           constant\r\n           returns (bytes32 _document)\r\n  {\r\n    _document = read_next_from_bytesarray(system.global_audit_documents, _current_document);\r\n  }\r\n\r\n\r\n  function read_previous_global_audit_from_audit(bytes32 _current_document)\r\n           public\r\n           constant\r\n           returns (bytes32 _document)\r\n  {\r\n    _document = read_previous_from_bytesarray(system.global_audit_documents, _current_document);\r\n  }\r\n\r\n  function read_total_global_audits()\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = system.global_audit_documents.total();\r\n  }\r\n\r\n  function read_user_first_recast(bytes32 _user)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = read_first_from_indexed_bytesarray(system.user_recasts, _user);\r\n  }\r\n\r\n  function read_user_last_recast(bytes32 _user)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = read_last_from_indexed_bytesarray(system.user_recasts, _user);\r\n  }\r\n\r\n  function read_user_next_recast_from_item(bytes32 _user, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = read_next_from_indexed_bytesarray(system.user_recasts, _user, _current_item);\r\n  }\r\n\r\n  function read_user_previous_recast_from_item(bytes32 _user, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = read_previous_from_indexed_bytesarray(system.user_recasts, _user, _current_item);\r\n  }\r\n\r\n  function read_user_total_recasts(bytes32 _user)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = read_total_indexed_bytesarray(system.user_recasts, _user);\r\n  }\r\n\r\n  function create_global_audit(bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success)\r\n  {\r\n    _success = system.global_audit_documents.append(_document);\r\n    require(_success);\r\n    system.last_global_audit_time = now;\r\n  }\r\n\r\n  /**\r\n  @notice create a new asset item to the `vendor_order` state\r\n  */\r\n  function create_init_item(uint256 _role_id, uint256 _product_id, uint256 _ng_weight, uint256 _effective_ng_weight, address _mint_target)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success, bytes32 _item)\r\n  {\r\n    (_success, _item) = system.state_machine.create_item(_role_id);\r\n    require(_success);\r\n    system.state_machine.change_item_state(_role_id, _item, STATE_VENDOR_ORDER);\r\n    system.items_by_id[_item].product_id = _product_id;\r\n    system.items_by_id[_item].ng_weight = _ng_weight;\r\n    system.items_by_id[_item].effective_ng_weight = _effective_ng_weight;\r\n    system.items_by_id[_item].mint_target = _mint_target;\r\n  }\r\n\r\n  /**\r\n  @notice create a new asset item to be transfered in, set it to `transfer` state\r\n  */\r\n  function create_init_item_transfer(uint256 _role_id, uint256 _product_id, uint256 _ng_weight, uint256 _effective_ng_weight, address _mint_target)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success, bytes32 _item)\r\n  {\r\n    (_success, _item) = system.state_machine.create_item(_role_id);\r\n    require(_success);\r\n    system.state_machine.change_item_state(_role_id, _item, STATE_TRANSFER);\r\n    system.items_by_id[_item].product_id = _product_id;\r\n    system.items_by_id[_item].ng_weight = _ng_weight;\r\n    system.items_by_id[_item].effective_ng_weight = _effective_ng_weight;\r\n    system.items_by_id[_item].mint_target = _mint_target;\r\n  }\r\n\r\n  function internal_check_duplicate_serial_when_fulfilling_order(bytes32 _item, bytes32 _serial)\r\n           internal\r\n  {\r\n    bytes32 _last_asset_with_same_serial = system.last_asset_with_serial[_serial];\r\n    if (_last_asset_with_same_serial != bytes32(0x0)) {\r\n      uint256 _existing_asset_state_id = system.state_machine.get_item_state_id(_last_asset_with_same_serial);\r\n      require(_existing_asset_state_id == STATE_ADMIN_FAILURE\r\n        || _existing_asset_state_id == STATE_AUDIT_FAILURE\r\n        || _existing_asset_state_id == STATE_REDEEMED);\r\n    }\r\n    system.last_asset_with_serial[_serial] = _item;\r\n  }\r\n\r\n  /**\r\n  @notice Update an item from either `vendor_order` or `transfer` state to `custodian_delivery` state;\r\n          Save the asset's serial and the related document\r\n  */\r\n  function update_item_fulfill(uint256 _role_id, bytes32 _item, bytes32 _serial, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success, uint256 _from_state, uint256 _new_state)\r\n  {\r\n    (_success, _from_state, _new_state) = system.state_machine.change_item_state(_role_id, _item, STATE_CUSTODIAN_DELIVERY);\r\n    require(_success);\r\n    internal_check_duplicate_serial_when_fulfilling_order(_item, _serial);\r\n    system.asset_documents.append(_item, _document);\r\n    system.items_by_id[_item].serial = _serial;\r\n  }\r\n\r\n  /// @notice (custodian) accepts an asset item to the `minted` state\r\n  function update_item_mint(uint256 _role_id, bytes32 _item, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success, address _mint_target, uint256 _effective_ng_weight, uint256 _from_state, uint256 _new_state)\r\n  {\r\n    _mint_target = system.items_by_id[_item].mint_target;\r\n    _effective_ng_weight = system.items_by_id[_item].effective_ng_weight;\r\n    (_success, _from_state, _new_state) = system.state_machine.change_item_state(_role_id, _item, STATE_MINTED);\r\n    require(_success);\r\n    system.items_by_id[_item].time_minted = now;\r\n    system.asset_documents.append(_item, _document);\r\n  }\r\n\r\n  /// @notice update a minted asset to the `recasted` state\r\n  function update_item_recast(uint256 _role_id, bytes32 _item, address _redeem_for, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS_RECAST)\r\n           returns (bool _success)\r\n  {\r\n    (_success,,) = system.state_machine.change_item_state(_role_id, _item, STATE_RECASTED);\r\n    require(_success);\r\n    system.items_by_id[_item].redeem_for = _redeem_for;\r\n    system.items_by_id[_item].redeem_deadline = now + system.redeem_period * SECONDS_IN_A_DAY;\r\n    system.user_recasts.append(bytes32(_redeem_for), _item);\r\n    system.asset_documents.append(_item, _document);\r\n  }\r\n\r\n  /// @notice update a recasted item to the `redeemed` state\r\n  function update_item_redeem(uint256 _role_id, bytes32 _item, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success)\r\n  {\r\n    (_success,,) = system.state_machine.change_item_state(_role_id, _item, STATE_REDEEMED);\r\n    require(_success);\r\n    address _redeem_for = system.items_by_id[_item].redeem_for;\r\n    system.user_recasts.remove_item(bytes32(_redeem_for), _item);\r\n    system.asset_documents.append(_item, _document);\r\n  }\r\n\r\n  /// @notice update a recasted item to the `minted` state\r\n  function update_item_remint(uint256 _role_id, bytes32 _item, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success)\r\n  {\r\n    (_success,,) = system.state_machine.change_item_state(_role_id, _item, STATE_MINTED);\r\n    require(_success);\r\n    address _redeem_for = system.items_by_id[_item].redeem_for;\r\n    system.user_recasts.remove_item(bytes32(_redeem_for), _item);\r\n    system.items_by_id[_item].redeem_for = address(0x0); // reset the redeem_for field of this minted asset\r\n    system.asset_documents.append(_item, _document);\r\n  }\r\n\r\n  function update_item_to_audit_failure(uint256 _role_id, bytes32 _item, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success, uint256 _from_state, uint256 _new_state)\r\n  {\r\n    (_success, _from_state, _new_state) = system.state_machine.change_item_state(_role_id, _item, STATE_AUDIT_FAILURE);\r\n    require(_success);\r\n    system.asset_documents.append(_item, _document);\r\n  }\r\n\r\n  /// @notice (popadmin) create a new asset item to replace an item that failed audit, mark it as `replacement_order`\r\n  function create_init_item_as_replacement(uint256 _role_id, uint256 _product_id, uint256 _ng_weight, uint256 _effective_ng_weight, bytes32 _old_item)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success, bytes32 _replacement_item)\r\n  {\r\n    (_success, _replacement_item) = system.state_machine.create_item(_role_id);\r\n    require(_success);\r\n    system.state_machine.change_item_state(_role_id, _replacement_item, STATE_REPLACEMENT_ORDER);\r\n    system.items_by_id[_replacement_item].product_id = _product_id;\r\n    system.items_by_id[_replacement_item].ng_weight = _ng_weight;\r\n    system.items_by_id[_replacement_item].effective_ng_weight = _effective_ng_weight;\r\n    system.items_by_id[_replacement_item].replaces = _old_item;\r\n    system.items_by_id[_old_item].replaced_by = _replacement_item;\r\n  }\r\n\r\n  /// @notice (vendor) change the state of an asset item from `replacement_order` to `replacement_delivery`\r\n  function update_item_fulfill_replacement(uint256 _role_id, bytes32 _item, bytes32 _serial, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success)\r\n  {\r\n    (_success,,) = system.state_machine.change_item_state(_role_id, _item, STATE_REPLACEMENT_DELIVERY);\r\n    require(_success);\r\n    internal_check_duplicate_serial_when_fulfilling_order(_item, _serial);\r\n    system.asset_documents.append(_item, _document);\r\n    system.items_by_id[_item].serial = _serial;\r\n  }\r\n\r\n  /// @notice (custodian) accepts an asset item from `replacement_delivery` state to `minted` state\r\n  function update_item_mint_replacement(uint256 _role_id, bytes32 _item, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success, uint256 _effective_ng_weight)\r\n  {\r\n    _effective_ng_weight = system.items_by_id[_item].effective_ng_weight;\r\n    (_success,,) = system.state_machine.change_item_state(_role_id, _item, STATE_MINTED);\r\n    require(_success);\r\n    system.items_by_id[_item].time_minted = now;\r\n    system.asset_documents.append(_item, _document);\r\n  }\r\n\r\n  /// @notice (popadmin) fail an asset that has not been minted\r\n  function update_item_admin_fail(uint256 _role_id, bytes32 _item, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success)\r\n  {\r\n    (_success,,) = system.state_machine.change_item_state(_role_id, _item, STATE_ADMIN_FAILURE);\r\n    require(_success);\r\n    system.asset_documents.append(_item, _document);\r\n  }\r\n\r\n  function update_item_add_document(bytes32 _item, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success)\r\n  {\r\n    _success = system.asset_documents.append(_item, _document);\r\n    require(_success);\r\n  }\r\n\r\n  function update_redeem_period(uint256 _redeem_period)\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.redeem_period = _redeem_period;\r\n    _success = true;\r\n  }\r\n}\r\n\r\n// File: contracts/storage/AssetEventsStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\ncontract AssetEventsStorage is ResolverClient, DigixConstants {\r\n  struct PoPEvent {\r\n    uint256 event_type;\r\n    uint256 timestamp;\r\n  }\r\n\r\n  struct AssetEventsData {\r\n    PoPEvent[] events;\r\n    uint256 count;\r\n  }\r\n\r\n  mapping(bytes32 => AssetEventsData) system;\r\n\r\n  function AssetEventsStorage(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_STORAGE_ASSET_EVENTS, _resolver));\r\n  }\r\n\r\n  function add_asset_event(bytes32 _asset_item, uint256 _event_type)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    require(msg.sender == get_contract(CONTRACT_CONTROLLER_ASSETS) || msg.sender == get_contract(CONTRACT_CONTROLLER_ASSETS_RECAST));\r\n    uint256 _event_count = system[_asset_item].count;\r\n    system[_asset_item].events.push(PoPEvent(_event_type, now));\r\n    system[_asset_item].count = _event_count + 1;\r\n    _success = true;\r\n  }\r\n\r\n  function read_asset_events_count(bytes32 _asset_item)\r\n           public\r\n           constant\r\n           returns (uint256 _count)\r\n  {\r\n    _count = system[_asset_item].count;\r\n  }\r\n\r\n  function read_asset_event_details(bytes32 _asset_item, uint256 _index)\r\n           public\r\n           constant\r\n           returns (uint256 _event_type, uint256 _timestamp)\r\n  {\r\n    _event_type = system[_asset_item].events[_index].event_type;\r\n    _timestamp = system[_asset_item].events[_index].timestamp;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/storage/GoldTokenStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\ncontract GoldTokenStorage is ResolverClient, DigixConstants {\r\n\r\n  struct FeeConfiguration {\r\n    uint256 base;\r\n    uint256 rate;\r\n  }\r\n\r\n  struct GlobalConfig {\r\n    bytes32 current_version;\r\n    bool no_demurrage_fee;\r\n    bool no_transfer_fee;\r\n    uint256 minimum_transfer_amount;\r\n    Fees fees;\r\n  }\r\n\r\n  struct Fees {\r\n    FeeConfiguration demurrage;\r\n    FeeConfiguration recast;\r\n    FeeConfiguration transfer;\r\n  }\r\n\r\n  struct Collectors {\r\n    address demurrage;\r\n    address recast;\r\n    address transfer;\r\n  }\r\n\r\n  struct UserConfig {\r\n    bool no_demurrage_fee;\r\n    bool no_transfer_fee;\r\n    bool no_recast_fee;\r\n  }\r\n\r\n  struct UserData {\r\n    uint256 last_payment_date;\r\n    uint256 raw_balance;\r\n    mapping (address => uint256) spender_allowances;\r\n  }\r\n\r\n  struct User {\r\n    UserConfig config;\r\n    UserData data;\r\n  }\r\n\r\n  struct System {\r\n    Collectors collectors;\r\n    GlobalConfig config;\r\n    uint256 total_supply;\r\n    uint256 effective_total_supply;\r\n    mapping (address => User) users;\r\n  }\r\n\r\n  System system;\r\n\r\n  function GoldTokenStorage(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_STORAGE_GOLD_TOKEN, _resolver));\r\n\r\n    address _demurrage_collector;\r\n    address _transfer_collector;\r\n    address _recast_collector;\r\n\r\n    assembly {\r\n      _demurrage_collector := create(0,0,0)\r\n      _transfer_collector := create(0,0,0)\r\n      _recast_collector := create(0,0,0)\r\n    }\r\n    system.collectors.demurrage = _demurrage_collector;\r\n    system.collectors.recast = _recast_collector;\r\n    system.collectors.transfer = _transfer_collector;\r\n    system.config.fees.demurrage.base = 10000000;\r\n    system.config.fees.demurrage.rate = 165;\r\n    system.config.fees.recast.base = 100000000000;\r\n    system.config.fees.recast.rate = 1000000000;\r\n    system.config.fees.transfer.base = 10000;\r\n    system.config.fees.transfer.rate = 13;\r\n    system.config.minimum_transfer_amount = 1000000;\r\n    system.config.no_demurrage_fee = false;\r\n    system.config.no_transfer_fee = false;\r\n    system.config.current_version = \"1.0.0\";\r\n    system.total_supply = 0;\r\n    system.effective_total_supply = 0;\r\n  }\r\n\r\n\r\n /////////////////////////////////////////////////////\r\n///    functions to read global configs           ///\r\n/////////////////////////////////////////////////////\r\n\r\n  /// @notice read the total number of tokens\r\n  function read_total_supply()\r\n           constant\r\n           public\r\n           returns (uint256 _total_supply)\r\n  {\r\n    _total_supply = system.total_supply;\r\n  }\r\n\r\n  /// @notice read the effective total, which is the number of nanograms of gold that is backing the Gold tokens\r\n  function read_effective_total_supply()\r\n           constant\r\n           public\r\n           returns (uint256 _effective_total_supply)\r\n  {\r\n    _effective_total_supply = system.effective_total_supply;\r\n  }\r\n\r\n  /// @notice read both the total_supply and effective_total_supply\r\n  function read_supply()\r\n           constant\r\n           public\r\n           returns (uint256 _total_supply, uint256 _effective_total_supply)\r\n  {\r\n    _total_supply = read_total_supply();\r\n    _effective_total_supply = read_effective_total_supply();\r\n  }\r\n\r\n  /// @notice read general global configs: no_demurrage_fee, no_transfer_fee, minimum_transfer_amount, current_version\r\n  function read_general_config()\r\n           constant\r\n           public\r\n           returns (bytes32 _current_version, bool _no_demurrage_fee, bool _no_transfer_fee, uint256 _minimum_transfer_amount)\r\n  {\r\n    _current_version = system.config.current_version;\r\n    _no_demurrage_fee = system.config.no_demurrage_fee;\r\n    _no_transfer_fee = system.config.no_transfer_fee;\r\n    _minimum_transfer_amount = system.config.minimum_transfer_amount;\r\n  }\r\n\r\n  function read_collectors_addresses()\r\n           constant\r\n           public\r\n           returns (address[3] _collectors)\r\n  {\r\n    /* _collectors = new address[](3); */\r\n    _collectors[0] = system.collectors.demurrage;\r\n    _collectors[1] = system.collectors.recast;\r\n    _collectors[2] = system.collectors.transfer;\r\n  }\r\n\r\n\r\n ///////////////////////////////////////////////\r\n///    functions to read users' configs     ///\r\n///////////////////////////////////////////////\r\n\r\n  /// @notice read all details of a user\r\n  function read_user(address _account)\r\n           public\r\n           constant\r\n           returns (bool _exists,\r\n                    uint256 _raw_balance,\r\n                    uint256 _payment_date,\r\n                    bool _no_demurrage_fee,\r\n                    bool _no_recast_fee,\r\n                    bool _no_transfer_fee)\r\n  {\r\n    _exists = (system.users[_account].data.last_payment_date > 0);\r\n    _raw_balance = system.users[_account].data.raw_balance;\r\n    _payment_date = system.users[_account].data.last_payment_date;\r\n    (_no_demurrage_fee, _no_transfer_fee, _no_recast_fee) = read_user_fees_configs(_account);\r\n  }\r\n\r\n  function read_user_fees_configs(address _account)\r\n           public\r\n           constant\r\n           returns (bool _no_demurrage_fee,\r\n                    bool _no_transfer_fee,\r\n                    bool _no_recast_fee)\r\n  {\r\n    _no_demurrage_fee = system.users[_account].config.no_demurrage_fee;\r\n    _no_transfer_fee = system.users[_account].config.no_transfer_fee;\r\n    _no_recast_fee = system.users[_account].config.no_recast_fee;\r\n  }\r\n\r\n  /// @notice read a user's spender allowance\r\n  function read_account_spender_allowance(address _account,\r\n                                          address _spender)\r\n           public\r\n           constant\r\n           returns (uint256 _spender_allowance)\r\n  {\r\n    _spender_allowance = system.users[_account].data.spender_allowances[_spender];\r\n  }\r\n\r\n\r\n //////////////////////////////////////////////////\r\n///    Update functions regarding users        ///\r\n//////////////////////////////////////////////////\r\n\r\n  /// @notice called by TokenApprovalController to update an account's spender allowance of a _spender\r\n  function update_account_spender_allowance(address _account,\r\n                                            address _spender,\r\n                                            uint256 _new_allowance)\r\n           if_sender_is(CONTRACT_CONTROLLER_TOKEN_APPROVAL)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.users[_account].data.spender_allowances[_spender] = _new_allowance;\r\n    _success = true;\r\n  }\r\n\r\n  /// @notice update the _user balance and the global total supply after minting some tokens\r\n  function update_balances_after_mint(address _user, uint256 _user_new_balance, uint256 _new_total_supply, uint256 _new_effective_total_supply)\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.users[_user].data.raw_balance = _user_new_balance;\r\n    system.total_supply = _new_total_supply;\r\n    system.effective_total_supply = _new_effective_total_supply;\r\n    _success = true;\r\n  }\r\n\r\n  /// @notice update a user's fees configs\r\n  function update_user_fees_configs(address _user, bool _no_demurrage_fee, bool _no_transfer_fee, bool _no_recast_fee)\r\n           if_sender_is(CONTRACT_CONTROLLER_TOKEN_CONFIG)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.users[_user].config.no_demurrage_fee = _no_demurrage_fee;\r\n    system.users[_user].config.no_transfer_fee = _no_transfer_fee;\r\n    system.users[_user].config.no_recast_fee = _no_recast_fee;\r\n    _success = true;\r\n  }\r\n\r\n\r\n ///////////////////////////////////////////////////////////\r\n///    Update functions to change global configs        ///\r\n///////////////////////////////////////////////////////////\r\n\r\n  /// @notice called by AssetsController to update the effective supply (when an item failed audit or is replaced)\r\n  function update_effective_supply(uint256 _effective_total_supply)\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.effective_total_supply = _effective_total_supply;\r\n    _success = true;\r\n  }\r\n\r\n  /// @notice update configs for recast fees\r\n  function update_config_recast(uint256 _base, uint256 _rate)\r\n           if_sender_is(CONTRACT_CONTROLLER_TOKEN_CONFIG)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.config.fees.recast.base = _base;\r\n    system.config.fees.recast.rate = _rate;\r\n    _success = true;\r\n  }\r\n\r\n  /// @notice update configs for demurrage fees\r\n  function update_config_demurrage(uint256 _base, uint256 _rate, bool _no_demurrage_fee)\r\n           if_sender_is(CONTRACT_CONTROLLER_TOKEN_CONFIG)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.config.fees.demurrage.base = _base;\r\n    system.config.fees.demurrage.rate = _rate;\r\n    system.config.no_demurrage_fee = _no_demurrage_fee;\r\n    _success = true;\r\n  }\r\n\r\n  /// @notice update configs for transfer fees\r\n  function update_config_transfer(uint256 _base, uint256 _rate, bool _no_transfer_fee, uint256 _minimum_transfer_amount)\r\n           if_sender_is(CONTRACT_CONTROLLER_TOKEN_CONFIG)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.config.fees.transfer.base = _base;\r\n    system.config.fees.transfer.rate = _rate;\r\n    system.config.no_transfer_fee = _no_transfer_fee;\r\n    system.config.minimum_transfer_amount = _minimum_transfer_amount;\r\n    _success = true;\r\n  }\r\n\r\n\r\n /////////////////////////////////////////////\r\n///    Demurrage-related functions        ///\r\n/////////////////////////////////////////////\r\n\r\n  /// @notice called by TokenDemurrageService to get the global demurrage configs\r\n  function read_demurrage_config()\r\n           constant\r\n           public\r\n           returns (uint256 _collector_balance,\r\n                    uint256 _base,\r\n                    uint256 _rate,\r\n                    address _collector)\r\n  {\r\n    _collector_balance = system.users[system.collectors.demurrage].data.raw_balance;\r\n    bool _global_demurrage_disabled = system.config.no_demurrage_fee;\r\n    _collector = system.collectors.demurrage;\r\n\r\n    if (_global_demurrage_disabled) {\r\n      _base = 0;\r\n      _rate = 0;\r\n    } else {\r\n      _base = system.config.fees.demurrage.base;\r\n      _rate = system.config.fees.demurrage.rate;\r\n    }\r\n  }\r\n\r\n  function read_demurrage_config_underlying()\r\n           public\r\n           constant\r\n           returns (uint256 _base,\r\n                    uint256 _rate,\r\n                    address _collector,\r\n                    bool _no_demurrage_fee)\r\n  {\r\n    _base = system.config.fees.demurrage.base;\r\n    _rate = system.config.fees.demurrage.rate;\r\n    _collector = system.collectors.demurrage;\r\n    _no_demurrage_fee = system.config.no_demurrage_fee;\r\n  }\r\n\r\n  /// @notice called by TokenDemurrageService to get the user's information needed to deduct his demurrage fees\r\n  function read_user_for_demurrage(address _account)\r\n           public\r\n           constant\r\n           returns (uint256 _raw_balance, uint256 _payment_date, bool _no_demurrage_fee)\r\n  {\r\n    _raw_balance = system.users[_account].data.raw_balance;\r\n    _payment_date = system.users[_account].data.last_payment_date;\r\n    _no_demurrage_fee = system.users[_account].config.no_demurrage_fee || system.config.no_demurrage_fee;\r\n  }\r\n\r\n  /// @notice called by TokenDemurrageService to deduct demurrage fees from a user's balance\r\n  function update_user_for_demurrage(address _user, uint256 _user_new_balance, uint256 _user_new_payment_date, uint256 _collector_new_balance)\r\n           if_sender_is(CONTRACT_SERVICE_TOKEN_DEMURRAGE)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.users[system.collectors.demurrage].data.raw_balance = _collector_new_balance;\r\n    system.users[_user].data.raw_balance = _user_new_balance;\r\n    system.users[_user].data.last_payment_date = _user_new_payment_date;\r\n    _success = true;\r\n  }\r\n\r\n\r\n ////////////////////////////////////////\r\n///    Recast-related functions      ///\r\n////////////////////////////////////////\r\n\r\n  /// @notice called by AssetsController to read global info to recast an asset item\r\n  function read_recast_config()\r\n           constant\r\n           public\r\n           returns (uint256 _base,\r\n                    uint256 _rate,\r\n                    uint256 _total_supply,\r\n                    uint256 _effective_total_supply,\r\n                    address _collector,\r\n                    uint256 _collector_balance)\r\n  {\r\n    _base = system.config.fees.recast.base;\r\n    _rate = system.config.fees.recast.rate;\r\n    _total_supply = system.total_supply;\r\n    _effective_total_supply = system.effective_total_supply;\r\n    _collector = system.collectors.recast;\r\n    _collector_balance = system.users[system.collectors.recast].data.raw_balance;\r\n  }\r\n\r\n  /// @notice called by AssetsController to read a user's configs for recasting assets\r\n  function read_user_for_recast(address _account)\r\n           public\r\n           constant\r\n           returns (uint256 _raw_balance, bool _no_recast_fee)\r\n  {\r\n    _raw_balance = system.users[_account].data.raw_balance;\r\n    _no_recast_fee = system.users[_account].config.no_recast_fee;\r\n  }\r\n\r\n  /// @notice called by AssetsController to recast an asset item\r\n  function update_balances_after_recast(address _recaster,\r\n                               uint256 _recaster_new_balance,\r\n                               uint256 _recast_fee_collector_new_balance,\r\n                               uint256 _new_total_supply,\r\n                               uint256 _new_effective_total_supply)\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS_RECAST)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.users[_recaster].data.raw_balance = _recaster_new_balance;\r\n    system.users[system.collectors.recast].data.raw_balance = _recast_fee_collector_new_balance;\r\n    system.total_supply = _new_total_supply;\r\n    system.effective_total_supply = _new_effective_total_supply;\r\n    _success = true;\r\n  }\r\n\r\n\r\n ////////////////////////////////////////\r\n///    Transfer-related functions    ///\r\n////////////////////////////////////////\r\n\r\n  /// @notice called by TokenTransferController to read global configs for transfering tokens\r\n  function read_transfer_config()\r\n           public\r\n           constant\r\n           returns (uint256 _collector_balance,\r\n                    uint256 _base,\r\n                    uint256 _rate,\r\n                    address _collector,\r\n                    bool _no_transfer_fee,\r\n                    uint256 _minimum_transfer_amount)\r\n  {\r\n    _collector_balance = system.users[system.collectors.transfer].data.raw_balance;\r\n    _base = system.config.fees.transfer.base;\r\n    _rate = system.config.fees.transfer.rate;\r\n    _collector = system.collectors.transfer;\r\n    _no_transfer_fee = system.config.no_transfer_fee;\r\n    _minimum_transfer_amount = system.config.minimum_transfer_amount;\r\n  }\r\n\r\n  /// @notice called by TokenTransferController to read a user's configs for tranfering tokens\r\n  function read_user_for_transfer(address _account)\r\n           public\r\n           constant\r\n           returns (uint256 _raw_balance, bool _no_transfer_fee)\r\n  {\r\n    _raw_balance = system.users[_account].data.raw_balance;\r\n    _no_transfer_fee = system.users[_account].config.no_transfer_fee;\r\n  }\r\n\r\n  /// @notice called by TokenTransferController to update user balances after transfering\r\n  function update_transfer_balance(address _sender, uint256 _sender_new_balance, address _recipient,\r\n                                   uint256 _recipient_new_balance, uint256 _transfer_fee_collector_new_balance)\r\n           if_sender_is(CONTRACT_CONTROLLER_TOKEN_TRANSFER)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.users[_sender].data.raw_balance = _sender_new_balance;\r\n    system.users[_recipient].data.raw_balance = _recipient_new_balance;\r\n    system.users[system.collectors.transfer].data.raw_balance = _transfer_fee_collector_new_balance;\r\n    _success = true;\r\n  }\r\n\r\n  /// @notice called by TokenTransferController to update balances after transfering from\r\n  function update_transfer_from_balance(address _sender, uint256 _sender_new_balance, address _recipient,\r\n                                        uint256 _recipient_new_balance, uint256 _transfer_fee_collector_new_balance,\r\n                                        address _spender, uint256 _spender_new_allowance)\r\n           if_sender_is(CONTRACT_CONTROLLER_TOKEN_TRANSFER)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.users[_sender].data.raw_balance = _sender_new_balance;\r\n    system.users[_recipient].data.raw_balance = _recipient_new_balance;\r\n    system.users[system.collectors.transfer].data.raw_balance = _transfer_fee_collector_new_balance;\r\n    system.users[_sender].data.spender_allowances[_spender] = _spender_new_allowance;\r\n    _success = true;\r\n  }\r\n\r\n  ////////////////////////////////////////\r\n ///    transfer fees to distributors  ///\r\n ////////////////////////////////////////\r\n  function internal_move_balance(address _from, address _to)\r\n           internal\r\n           returns (uint256 _fees)\r\n  {\r\n    _fees = system.users[_from].data.raw_balance;\r\n    system.users[_to].data.raw_balance += _fees;\r\n    system.users[_from].data.raw_balance = 0;\r\n  }\r\n\r\n  function move_fees_to_distributors(address _demurrage_fees_distributor, address _recast_fees_distributor, address _transfer_fees_distributor)\r\n          if_sender_is(CONTRACT_CONTROLLER_TOKEN_CONFIG)\r\n          public\r\n          returns (bool _success, uint256[3] _fees_array)\r\n  {\r\n    /* _fees_array = new uint256[](3); */\r\n    _fees_array[0] = internal_move_balance(system.collectors.demurrage, _demurrage_fees_distributor);\r\n    _fees_array[1] = internal_move_balance(system.collectors.recast, _recast_fees_distributor);\r\n    _fees_array[2] = internal_move_balance(system.collectors.transfer, _transfer_fees_distributor);\r\n    _success = true;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/storage/IdentityStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\ncontract IdentityStorage is ResolverClient, DigixConstants {\r\n\r\n  struct User {\r\n    uint256 id_expiration;\r\n    bytes32 doc;  // Our current system doesnt use this yet, but we might need it in the future\r\n  }\r\n\r\n  mapping(address => User) users;\r\n\r\n  function IdentityStorage(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_STORAGE_IDENTITY, _resolver));\r\n  }\r\n\r\n  function read_user(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _id_expiration, bytes32 _doc)\r\n  {\r\n    _id_expiration = users[_user].id_expiration;\r\n    _doc = users[_user].doc;\r\n  }\r\n\r\n  function read_user_kyc_valid(address _user)\r\n           public\r\n           constant\r\n           returns (bool _kyc_valid)\r\n  {\r\n    _kyc_valid = users[_user].id_expiration > now;\r\n  }\r\n\r\n  function update_user_id_expiration(address _user, uint256 _id_expiration)\r\n           if_sender_is(CONTRACT_CONTROLLER_IDENTITY)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    users[_user].id_expiration = _id_expiration;\r\n    _success = true;\r\n  }\r\n\r\n  function update_user_doc(address _user, bytes32 _doc)\r\n           if_sender_is(CONTRACT_CONTROLLER_IDENTITY)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    users[_user].doc = _doc;\r\n    _success = true;\r\n  }\r\n\r\n}\r\n\r\n// File: @digix/solidity-core-libraries/contracts/MathUtils.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n/// @title Digix Math Library\r\n/// @author DigixGlobal\r\n\r\nlibrary MathUtils {\r\n\r\n  /*modifier if_safe_to_add(uint256 _x, uint256 _y) {\r\n    require(is_safe_to_add(_x, _y) == true);\r\n    _;\r\n  }\r\n\r\n  modifier if_safe_to_subtract(uint256 _x, uint256 _y) {\r\n    require(is_safe_to_subtract(_x, _y) == true);\r\n    _;\r\n  }*/\r\n\r\n  /*uint256 constant ONE_DAY = 1 days;*/\r\n\r\n  /// DEPRECATED\r\n  /// @notice Call with two integers to determine if they are safe to add\r\n  /// @dev Catches integer overflow\r\n  /// param _a Integer to add\r\n  /// param _b Integer to add\r\n  /// @return _issafe True if the integers are safe to add\r\n  /*function is_safe_to_add(uint256 _a, uint256 _b)\r\n           public\r\n           constant\r\n           returns (bool _is_safe)\r\n  {\r\n    _is_safe = (_a + _b >= _a);\r\n    return _is_safe;\r\n  }*/\r\n\r\n  /// @notice Returns sum of two safely-added integers\r\n  /// @dev Uses `safeToAdd` internally; throws if unsafe\r\n  /// @param _a Integer to add\r\n  /// @param _b Integer to add\r\n  /// @return _result Sum of inputs\r\n  function add(uint256 _a, uint256 _b)\r\n           public\r\n           pure\r\n           returns (uint256 _result)\r\n  {\r\n    _result = _a + _b;\r\n    require(_result > _a);\r\n  }\r\n\r\n  /// DEPRECATED\r\n  /// @notice Call with two integers to determine if they are safe to subtract\r\n  /// @dev Catches integer overflow\r\n  /// param _a Integer to subtract from\r\n  /// param _b Integer to subtract\r\n  /// @return _issafe True if the integers are safe to subtract\r\n  /*function is_safe_to_subtract(uint256 _a, uint256 _b)\r\n           public\r\n           constant\r\n           returns (bool _is_safe)\r\n  {\r\n    _is_safe = (_b <= _a);\r\n    return _is_safe;\r\n  }*/\r\n\r\n  /// @notice Returns result of two safely-subtracted integers\r\n  /// @dev Uses `safeToSubtract` internally; throws if unsafe\r\n  /// @param _a Integer to subtract from\r\n  /// @param _b Integer to subtract\r\n  /// @return _result Result of subtraction\r\n  function subtract(uint256 _a, uint256 _b)\r\n           public\r\n           pure\r\n           returns (uint _result)\r\n  {\r\n    require(_a >= _b);\r\n    _result = _a - _b;\r\n  }\r\n\r\n  /// DEPRECATED\r\n  ///# @notice Calculates the rate of ???\r\n  ///# @dev `((_unit * _a) + _b / 2) / _b`\r\n  ///# paramm _a ??\r\n  ///# paramm _b ??\r\n  ///# paramm _places Number of decimal places\r\n  ///# @return _result Result of subtraction\r\n  /*function rate_of(uint256 _a, uint256 _b, uint256 _places)\r\n           public\r\n           constant\r\n           returns (uint256 _result)\r\n  {\r\n    var _unit = 10 ** _places;\r\n    _result = add((_unit * _a), (_b / 2)) / _b;\r\n    return _result;\r\n  }*/\r\n\r\n  /// DEPRECATED\r\n  ///# @notice Calculates the rate from ???\r\n  ///# @dev `(_amount * _baserate) / (10 ** _places)`\r\n  ///# paramm _amount ??\r\n  ///# paramm _baserate ??\r\n  ///# paramm _places ??\r\n  ///# @return _fee Calculated Fee\r\n  /*function from_rate(uint256 _amount, uint256 _baserate, uint256 _places)\r\n           returns (uint256 _fee)\r\n  {\r\n    _fee = ((_amount * _baserate) / (10 ** _places));\r\n    return _fee;\r\n  }*/\r\n\r\n  /// DEPRECATED\r\n  ///# @notice Calculate demurrage time values\r\n  ///# paramm _current_time Current block time\r\n  ///# paramm _last_payment_date Last demurrage payment date\r\n  ///# @return {\r\n  ///   \"_next_payment_date\": \"Next payment date as unix time\",\r\n  ///   \"_demurrage_days\": \"Demurrage days calculated\"\r\n  /// }\r\n  /*function calculate_demurrage_time(uint256 _current_time, uint256 _last_payment_date)\r\n           returns (uint256 _next_payment_date, uint256 _demurrage_days)\r\n  {\r\n    var _time_difference = subtract(_current_time, _last_payment_date);\r\n    _demurrage_days = _time_difference / (1 days);\r\n    var _remainder = _time_difference % (1 days);\r\n    var _demurrage_seconds = _demurrage_days * (1 days);\r\n    _next_payment_date = subtract(add(_last_payment_date, _demurrage_seconds), _remainder);\r\n    return (_next_payment_date, _demurrage_days);\r\n  }*/\r\n\r\n  /// DEPRECATED\r\n  ///# @notice Calculate demurrage fee\r\n  ///# paramm _demurrage_days Days since last demurrage payment\r\n  ///# paramm _unit_size Minimum amount for demurrage fees\r\n  ///# paramm _fee_per_unit Amount of daily demurrage to deduct for every `_demurrage_minimum`\r\n  ///# paramm _raw_balance Account balance\r\n  ///# @return _demurrage_fee The demurrage fee due\r\n  /*function calculate_demurrage_fee(uint256 _demurrage_days, uint256 _unit_size, uint256 _fee_per_unit, uint256 _raw_balance)\r\n           returns (uint256 _demurrage_fee)\r\n  {\r\n    if (_demurrage_days == 0) {\r\n      _demurrage_fee = 0;\r\n    } else {\r\n      var _billable_amount = (_raw_balance / _unit_size);\r\n      _demurrage_fee = (_billable_amount * _demurrage_days * _fee_per_unit);\r\n    }\r\n    return _demurrage_fee;\r\n  }*/\r\n\r\n  /// DEPRECATED\r\n  ///# @notice Get demurrage info\r\n  ///# paramm _current_time Current block time\r\n  ///# paramm _last_payment_date Last demurrage payment date\r\n  ///# paramm _raw_balance Account balance\r\n  ///# paramm _unit_size Minimum amount needed to charge demurrage fees\r\n  ///# paramm _fee_per_unit The amount of daily demurrage deduct for every `_minimum_for_demurrage`\r\n  /// @return {\r\n  ///    \"_demurrage_fee\": \"Fee charged against current balance\",\r\n  ///    \"_demurrage_days\": \"Demurrage days calculated\",\r\n  ///    \"_billable_amount\": \"Amount eligible for demurrage calculation\",\r\n  ///    \"_next_payment_date\": \"Timestamp to use for next payment date\"\r\n  /// }\r\n  /*function get_demurrage_info(uint256 _current_time, uint256 _last_payment_date, uint256 _raw_balance, uint256 _unit_size, uint256 _fee_per_unit)\r\n           returns (uint256 _demurrage_fee, uint256 _demurrage_days, uint256 _balance_after, uint256 _next_payment_date)\r\n  {\r\n    _demurrage_days = (subtract(_current_time, _last_payment_date)) / ONE_DAY;\r\n    uint256 _billable_amount = (_raw_balance / _unit_size);\r\n    if (_demurrage_days == 0) {\r\n      _demurrage_fee = 0;\r\n      _next_payment_date = _last_payment_date;\r\n      _balance_after = _raw_balance;\r\n    } else {\r\n      _demurrage_fee = (_billable_amount * _demurrage_days * _fee_per_unit);\r\n      var _remainder = subtract(_current_time, _last_payment_date) % ONE_DAY;\r\n      _next_payment_date = subtract(add(_last_payment_date, (_demurrage_days * ONE_DAY)), _remainder);\r\n      _balance_after = subtract(_raw_balance, _demurrage_fee);\r\n    }\r\n    return (_demurrage_fee, _demurrage_days, _balance_after, _next_payment_date);\r\n  }*/\r\n\r\n  /// DEPRECATED\r\n  ///# @notice Calculate Transaction Fee\r\n  ///# paramm _sending_amount The amount being sent\r\n  ///# paramm _unit_size The minimum amount that can be sent\r\n  ///# paramm _fee_per_unit The fee per unit\r\n  ///# @return _tx_fee The transaction fee due\r\n  /*function get_tx_fee(uint256 _sending_amount, uint256 _unit_size, uint256 _fee_per_unit)\r\n           returns (uint256 _tx_fee)\r\n  {\r\n    _tx_fee = (_sending_amount / _unit_size) * _fee_per_unit;\r\n    return _tx_fee;\r\n  }*/\r\n\r\n  function calculate_recast_fee(uint256 _asset_weight, uint256 _unit_size, uint256 _fee_per_unit)\r\n           public\r\n           pure\r\n           returns (uint256 _recast_fee)\r\n  {\r\n    uint256 _weight_times_fee_per_unit = _asset_weight * _fee_per_unit;\r\n    require(_weight_times_fee_per_unit / _asset_weight == _fee_per_unit);\r\n    _recast_fee = _weight_times_fee_per_unit / _unit_size;\r\n    return _recast_fee;\r\n  }\r\n\r\n}\r\n\r\n// File: @digix/solidity-core-libraries/contracts/Types.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\nlibrary Types {\r\n\r\n  struct MutableUint {\r\n    uint256 pre;\r\n    uint256 post;\r\n  }\r\n\r\n  struct MutableTimestamp {\r\n    MutableUint time;\r\n    uint256 in_units;\r\n  }\r\n\r\n  function advance_by(MutableTimestamp memory _original, uint256 _units)\r\n           internal\r\n           constant\r\n           returns (MutableTimestamp _transformed)\r\n  {\r\n    _transformed = _original;\r\n    require(now >= _original.time.pre);\r\n    uint256 _lapsed = now - _original.time.pre;\r\n    _transformed.in_units = _lapsed / _units;\r\n    uint256 _ticks = _transformed.in_units * _units;\r\n    if (_transformed.in_units == 0) {\r\n      _transformed.time.post = _original.time.pre;\r\n    } else {\r\n      _transformed.time = add(_transformed.time, _ticks);\r\n    }\r\n  }\r\n\r\n  // DEPRECATED\r\n  /*function add_two(MutableUint memory _original, uint256 _first, uint256 _second)\r\n           internal\r\n           constant\r\n           returns (MutableUint _transformed)\r\n  {\r\n    require((_original.pre + _first + _second) >= _original.pre);\r\n    _transformed = _original;\r\n    _transformed.post = (_original.pre + _first + _second);\r\n  }*/\r\n\r\n  function subtract_two(MutableUint memory _original, uint256 _first, uint256 _second)\r\n           internal\r\n           pure\r\n           returns (MutableUint _transformed)\r\n  {\r\n    require(_original.pre >= _first);\r\n    uint256 _after_first = _original.pre - _first;\r\n    require(_after_first >= _second);\r\n    _transformed = _original;\r\n    _original.post = (_after_first - _second);\r\n  }\r\n\r\n  function subtract_and_add(MutableUint memory _original, uint256 _to_subtract, uint256 _to_add)\r\n           internal\r\n           pure\r\n           returns (MutableUint _transformed)\r\n  {\r\n    require(_original.pre >= _to_subtract);\r\n    uint256 _after_subtract = _original.pre - _to_subtract;\r\n    require((_after_subtract + _to_add) >= _after_subtract);\r\n    _transformed.post = _after_subtract + _to_add;\r\n  }\r\n\r\n  /// DEPRECATED\r\n  /*function increment(MutableUint memory _original)\r\n           internal\r\n           constant\r\n           returns (MutableUint _transformed)\r\n  {\r\n    _transformed = _original;\r\n    _transformed.post = _original.pre + 1;\r\n  }*/\r\n\r\n  /// DEPRECATED\r\n  /*function decrement(MutableUint memory _original)\r\n           internal\r\n           constant\r\n           returns (MutableUint _transformed)\r\n  {\r\n    _transformed = _original;\r\n    require((_original.pre + 1) > _original.pre);\r\n    _transformed.post = _original.pre - 1;\r\n  }*/\r\n\r\n  function add_and_subtract(MutableUint memory _original, uint256 _to_add, uint256 _to_subtract)\r\n           internal\r\n           pure\r\n           returns (MutableUint _transformed)\r\n  {\r\n    require((_original.pre + _to_add) >= _original.pre);\r\n    uint256 _after_add = _original.pre + _to_add;\r\n    require(_after_add >= _to_subtract);\r\n    _transformed = _original;\r\n    _transformed.post = (_after_add - _to_subtract);\r\n  }\r\n\r\n  function add(MutableUint memory _original, uint256 _amount)\r\n           internal\r\n           pure\r\n           returns (MutableUint _transformed)\r\n  {\r\n    require((_original.pre + _amount) >= _original.pre);\r\n    _transformed = _original;\r\n    _transformed.post = _original.pre + _amount;\r\n  }\r\n\r\n  function subtract(MutableUint memory _original, uint256 _amount)\r\n           internal\r\n           pure\r\n           returns (MutableUint _transformed)\r\n  {\r\n    require(_amount <= _original.pre);\r\n    _transformed = _original;\r\n    _transformed.post = _original.pre - _amount;\r\n  }\r\n\r\n  function swap(MutableUint memory _original_a, MutableUint memory _original_b)\r\n           internal\r\n           pure\r\n           returns (MutableUint _transformed_a, MutableUint _transformed_b)\r\n  {\r\n    _transformed_a = _original_a;\r\n    _transformed_b = _original_b;\r\n    _transformed_a.post = _original_b.pre;\r\n    _transformed_b.post = _original_a.pre;\r\n  }\r\n\r\n  /*function transfer(MutableUint memory _original_from, MutableUint memory _original_to, uint256 _amount)\r\n           internal\r\n           constant\r\n           returns (MutableUint _transformed_from, MutableUint _transformed_to)\r\n  {\r\n    _original_from = _transformed_from;\r\n    _original_to = _transformed_to;\r\n    _transformed_from.post = subtract(_transformed_from, _amount).post;\r\n    _transformed_to.post = add(_transformed_to, _amount).post;\r\n  }*/\r\n\r\n}\r\n\r\n// File: contracts/common/TokenLoggerCallback.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\ncontract TokenLoggerCallback is ResolverClient, DigixConstants {\r\n\r\n  event Transfer(address indexed _from,  address indexed _to,  uint256 _value);\r\n  event Approval(address indexed _owner,  address indexed _spender,  uint256 _value);\r\n\r\n  function log_mint(address _to, uint256 _value)\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           public\r\n  {\r\n    Transfer(address(0x0), _to, _value);\r\n  }\r\n\r\n  function log_recast_fees(address _from, address _to, uint256 _value)\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS_RECAST)\r\n           public\r\n  {\r\n    Transfer(_from, _to, _value);\r\n  }\r\n\r\n  function log_recast(address _from, uint256 _value)\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS_RECAST)\r\n           public\r\n  {\r\n    Transfer(_from, address(0x0), _value);\r\n  }\r\n\r\n  function log_demurrage_fees(address _from, address _to, uint256 _value)\r\n           if_sender_is(CONTRACT_SERVICE_TOKEN_DEMURRAGE)\r\n           public\r\n  {\r\n    Transfer(_from, _to, _value);\r\n  }\r\n\r\n  function log_move_fees(address _from, address _to, uint256 _value)\r\n           if_sender_is(CONTRACT_CONTROLLER_TOKEN_CONFIG)\r\n           public\r\n  {\r\n    Transfer(_from, _to, _value);\r\n  }\r\n\r\n  function log_transfer(address _from, address _to, uint256 _value)\r\n           if_sender_is(CONTRACT_CONTROLLER_TOKEN_TRANSFER)\r\n           public\r\n  {\r\n    Transfer(_from, _to, _value);\r\n  }\r\n\r\n  function log_approve(address _owner, address _spender, uint256 _value)\r\n           if_sender_is(CONTRACT_CONTROLLER_TOKEN_APPROVAL)\r\n           public\r\n  {\r\n    Approval(_owner, _spender, _value);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/service/TokenDemurrageService.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract TokenDemurrageService is ResolverClient, DigixConstants {\r\n\r\n  using Types for Types.MutableUint;\r\n  using Types for Types.MutableTimestamp;\r\n\r\n  struct User {\r\n    address account;\r\n    bool no_demurrage_fee;\r\n    Types.MutableUint balance;\r\n    Types.MutableTimestamp payment_date;\r\n  }\r\n\r\n  struct Config {\r\n    Types.MutableUint collector_balance;\r\n    uint256 base;\r\n    uint256 rate;\r\n    address collector;\r\n  }\r\n\r\n  struct Demurrage {\r\n    Config config;\r\n    User user;\r\n    uint256 collected_fee;\r\n  }\r\n\r\n  function TokenDemurrageService(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_SERVICE_TOKEN_DEMURRAGE, _resolver));\r\n  }\r\n\r\n  function gold_token_storage()\r\n           internal\r\n           constant\r\n           returns (GoldTokenStorage _contract)\r\n  {\r\n    _contract = GoldTokenStorage(get_contract(CONTRACT_STORAGE_GOLD_TOKEN));\r\n  }\r\n\r\n  function get_demurrage_data(address _user)\r\n           internal\r\n           constant\r\n           returns (Demurrage _demurrage)\r\n  {\r\n    (_demurrage.config.collector_balance.pre, _demurrage.config.base, _demurrage.config.rate, _demurrage.config.collector) =\r\n      gold_token_storage().read_demurrage_config();\r\n    _demurrage.user.account = _user;\r\n    (_demurrage.user.balance.pre, _demurrage.user.payment_date.time.pre, _demurrage.user.no_demurrage_fee) = gold_token_storage().read_user_for_demurrage(_user);\r\n  }\r\n\r\n  function calculate_demurrage(Demurrage memory _demurrage)\r\n           internal\r\n           constant\r\n           returns (Demurrage _calculated)\r\n  {\r\n    if (_demurrage.user.payment_date.time.pre == 0) {\r\n      _demurrage.user.payment_date.time.pre = now;\r\n    }\r\n    if (_demurrage.user.no_demurrage_fee == true || _demurrage.user.account == _demurrage.config.collector) { // demurrage collector is never deducted for demurrage\r\n      _demurrage.user.balance.post = _demurrage.user.balance.pre;\r\n      _demurrage.config.collector_balance.post = _demurrage.config.collector_balance.pre;\r\n      _demurrage.user.payment_date.time.post = now;\r\n    } else {\r\n      _demurrage.user.payment_date = _demurrage.user.payment_date.advance_by(1 days);\r\n      if (_demurrage.user.payment_date.in_units == 0) {\r\n        _demurrage.user.balance.post = _demurrage.user.balance.pre;\r\n        _demurrage.config.collector_balance.post = _demurrage.config.collector_balance.pre;\r\n      } else {\r\n        _demurrage.collected_fee = (_demurrage.user.payment_date.in_units * _demurrage.user.balance.pre * _demurrage.config.rate) / _demurrage.config.base;\r\n        _demurrage.user.balance = _demurrage.user.balance.subtract(_demurrage.collected_fee);\r\n        _demurrage.config.collector_balance = _demurrage.config.collector_balance.add(_demurrage.collected_fee);\r\n      }\r\n    }\r\n    _calculated = _demurrage;\r\n  }\r\n\r\n  function show_demurraged_balance(address _user)\r\n           public\r\n           constant\r\n           returns ( uint256 _actual_balance)\r\n  {\r\n    Demurrage memory _demurrage = get_demurrage_data(_user);\r\n    _demurrage = calculate_demurrage(_demurrage);\r\n    _actual_balance = _demurrage.user.balance.post;\r\n  }\r\n\r\n  function deduct_demurrage(address _user)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    Demurrage memory _demurrage = get_demurrage_data(_user);\r\n    _demurrage = calculate_demurrage(_demurrage);\r\n    require(gold_token_storage().update_user_for_demurrage(_demurrage.user.account, _demurrage.user.balance.post, _demurrage.user.payment_date.time.post, _demurrage.config.collector_balance.post) == true);\r\n    if (_demurrage.collected_fee > 0) {\r\n      TokenLoggerCallback(get_contract(CONTRACT_INTERACTIVE_TOKEN)).log_demurrage_fees(_user, _demurrage.config.collector, _demurrage.collected_fee);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  function bulk_deduct_demurrage(address[] _users)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    uint256 _length = _users.length;\r\n    for (uint256 i=0;i<_length; i++) {\r\n      deduct_demurrage(_users[i]);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/common/ERCTwenty.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\ncontract ERCTwenty {\r\n  function decimals() constant public returns (uint _decimals);\r\n  function totalSupply() constant public returns (uint supply);\r\n  function balanceOf( address who ) constant public returns (uint value);\r\n  function allowance( address owner, address spender ) constant public returns (uint _allowance);\r\n  function transfer( address to, uint value) public returns (bool ok);\r\n  function transferFrom( address from, address to, uint value) public returns (bool ok);\r\n  function approve( address spender, uint value ) public returns (bool ok);\r\n  event Transfer( address indexed from, address indexed to, uint value);\r\n  event Approval( address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n// File: contracts/storage/MarketplaceStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n// Contracts that need to be deployed for this contract to work:\r\n//    DoublyLinkedList, CoreStorage, MathUtils, TokenTransferController, TokenInfoController,\r\n//    TokenDemurrageService, TokenApprovalController, Token, ContractResolver\r\n\r\ncontract MarketplaceStorage is ResolverClient, DigixConstants {\r\n\r\n  struct Config {\r\n    uint256 global_daily_dgx_ng_limit;\r\n    uint256 minimum_purchase_dgx_ng;\r\n    uint256 maximum_block_drift;\r\n    address payment_collector;\r\n    uint256 max_dgx_available_daily;\r\n    uint256 price_floor_wei_per_dgx_mg;\r\n  }\r\n\r\n  struct Purchase {\r\n    address recipient; // the recipient is not necessarily the user who purchased\r\n    uint256 timestamp;\r\n    uint256 amount;\r\n    uint256 price;\r\n  }\r\n\r\n  struct User {\r\n    uint256 overwrite_daily_dgx_ng_limit;\r\n    Purchase[] purchases;\r\n  }\r\n\r\n  struct Marketplace {\r\n    Config config;\r\n    Purchase[] purchases;\r\n    mapping (address => User) users;\r\n    mapping (address => bool) approved_signers;\r\n    mapping (uint => mapping (uint => bool)) used_nonces;\r\n  }\r\n\r\n  Marketplace marketplace;\r\n\r\n  function MarketplaceStorage(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_STORAGE_MARKETPLACE, _resolver));\r\n    marketplace.config.global_daily_dgx_ng_limit = 102000000000;\r\n    marketplace.config.minimum_purchase_dgx_ng = 10000000;\r\n  }\r\n\r\n  function token_contract()\r\n           internal\r\n           constant\r\n           returns (ERCTwenty _contract)\r\n  {\r\n    _contract = ERCTwenty(get_contract(CONTRACT_INTERACTIVE_TOKEN));\r\n  }\r\n\r\n  function read_total_number_of_purchases()\r\n           public\r\n           constant\r\n           returns (uint256 _total_number_of_purchases)\r\n  {\r\n    _total_number_of_purchases = marketplace.purchases.length;\r\n  }\r\n\r\n  function read_total_number_of_user_purchases(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _total_number_of_user_purchases)\r\n  {\r\n    _total_number_of_user_purchases = marketplace.users[_user].purchases.length;\r\n  }\r\n\r\n  function read_purchase_at_index(uint256 _index)\r\n           public\r\n           constant\r\n           returns (address _recipient, uint256 _timestamp, uint256 _amount, uint256 _price)\r\n  {\r\n    Purchase memory _purchase = marketplace.purchases[_index];\r\n    _recipient = _purchase.recipient;\r\n    _timestamp = _purchase.timestamp;\r\n    _amount = _purchase.amount;\r\n    _price = _purchase.price;\r\n  }\r\n\r\n  function read_user_purchase_at_index(address _user, uint256 _index)\r\n           public\r\n           constant\r\n           returns (address _recipient, uint256 _timestamp, uint256 _amount, uint256 _price)\r\n  {\r\n    Purchase memory _purchase = marketplace.users[_user].purchases[_index];\r\n    _recipient = _purchase.recipient;\r\n    _timestamp = _purchase.timestamp;\r\n    _amount = _purchase.amount;\r\n    _price = _purchase.price;\r\n  }\r\n\r\n  function create_user(address _user, uint256 _overwrite_daily_dgx_ng_limit)\r\n           if_sender_is(CONTRACT_CONTROLLER_IDENTITY)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    marketplace.users[_user].overwrite_daily_dgx_ng_limit = _overwrite_daily_dgx_ng_limit;\r\n    _success = true;\r\n  }\r\n\r\n  function update_user_purchase(address _recipient_user, address _buyer, uint256 _purchase_amount, uint256 _purchase_price, uint256 _block_number, uint256 _nonce)\r\n           if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    marketplace.used_nonces[_block_number][_nonce] = true;\r\n    Purchase memory _purchase;\r\n    _purchase.recipient = _recipient_user;\r\n    _purchase.timestamp = now;\r\n    _purchase.amount = _purchase_amount;\r\n    _purchase.price = _purchase_price;\r\n    marketplace.users[_buyer].purchases.push(_purchase);\r\n    marketplace.purchases.push(_purchase);\r\n    require(token_contract().transfer(_recipient_user, _purchase_amount) == true);\r\n    _success = true;\r\n  }\r\n\r\n  function update_config(uint256 _global_daily_dgx_ng_limit, uint256 _minimum_purchase_dgx_ng, uint256 _maximum_block_drift, address _payment_collector)\r\n           if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    marketplace.config.global_daily_dgx_ng_limit = _global_daily_dgx_ng_limit;\r\n    marketplace.config.minimum_purchase_dgx_ng = _minimum_purchase_dgx_ng;\r\n    marketplace.config.payment_collector = _payment_collector;\r\n    marketplace.config.maximum_block_drift = _maximum_block_drift;\r\n    _success = true;\r\n  }\r\n\r\n  function move_inventory(address _destination, uint256 _amount)\r\n           if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    require(token_contract().transfer(_destination, _amount));\r\n    _success = true;\r\n  }\r\n\r\n  function update_max_dgx_available_daily(uint256 _max_dgx_available_daily)\r\n           if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    marketplace.config.max_dgx_available_daily = _max_dgx_available_daily;\r\n    _success = true;\r\n  }\r\n\r\n  function read_max_dgx_available_daily()\r\n           public\r\n           constant\r\n           returns (uint256 _max_dgx_available_daily)\r\n  {\r\n    _max_dgx_available_daily = marketplace.config.max_dgx_available_daily;\r\n  }\r\n\r\n  function update_price_floor(uint256 _price_floor_wei_per_dgx_mg)\r\n           if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    marketplace.config.price_floor_wei_per_dgx_mg = _price_floor_wei_per_dgx_mg;\r\n    _success = true;\r\n  }\r\n\r\n  function read_price_floor()\r\n           public\r\n           constant\r\n           returns (uint256 _price_floor_wei_per_dgx_mg)\r\n  {\r\n    _price_floor_wei_per_dgx_mg = marketplace.config.price_floor_wei_per_dgx_mg;\r\n  }\r\n\r\n  function update_signer_approval(address _signer, bool _approve)\r\n           if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    marketplace.approved_signers[_signer] = _approve;\r\n    _success = true;\r\n  }\r\n\r\n  function read_config()\r\n           public\r\n           constant\r\n           returns (uint256 _global_daily_dgx_ng_limit, uint256 _minimum_purchase_dgx_ng, uint256 _maximum_block_drift, address _payment_collector)\r\n  {\r\n    _global_daily_dgx_ng_limit = marketplace.config.global_daily_dgx_ng_limit;\r\n    _minimum_purchase_dgx_ng = marketplace.config.minimum_purchase_dgx_ng;\r\n    _maximum_block_drift = marketplace.config.maximum_block_drift;\r\n    _payment_collector = marketplace.config.payment_collector;\r\n  }\r\n\r\n  function read_is_approved_signer(address _signer)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = marketplace.approved_signers[_signer];\r\n  }\r\n\r\n  function read_total_purchased_today(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _total_purchased_today)\r\n  {\r\n    _total_purchased_today = 0;\r\n    uint256 _i = marketplace.users[_user].purchases.length;\r\n    while((_i >= 1) && (scope_timestamp_is_from_today(marketplace.users[_user].purchases[_i - 1].timestamp) == true)) {\r\n      _total_purchased_today += marketplace.users[_user].purchases[_i - 1].amount;\r\n      _i--;\r\n    }\r\n  }\r\n\r\n  function read_total_global_purchased_today()\r\n           public\r\n           constant\r\n           returns (uint256 _total_global_purchased_today)\r\n  {\r\n    _total_global_purchased_today = 0;\r\n    uint256 _i = marketplace.purchases.length;\r\n    while((_i >= 1) && (scope_timestamp_is_from_today(marketplace.purchases[_i - 1].timestamp) == true)) {\r\n      _total_global_purchased_today += marketplace.purchases[_i - 1].amount;\r\n      _i--;\r\n    }\r\n  }\r\n\r\n  function read_dgx_inventory_balance_ng()\r\n           public\r\n           constant\r\n           returns (uint256 _balance)\r\n  {\r\n    _balance = token_contract().balanceOf(address(this));\r\n  }\r\n\r\n  function scope_timestamp_is_from_today(uint256 _timestamp)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = (_timestamp >= (now - 1 days));\r\n  }\r\n\r\n  function read_for_purchase(address _user, uint256 _block_number, uint256 _nonce, address _signer)\r\n           public\r\n           constant\r\n           returns (uint256 _daily_dgx_limit, uint256 _total_purchased_today,\r\n                    bool _used_nonce, bool _approved_signer)\r\n  {\r\n    _daily_dgx_limit = read_user_daily_limit(_user);\r\n    _used_nonce = marketplace.used_nonces[_block_number][_nonce];\r\n    _approved_signer = marketplace.approved_signers[_signer];\r\n    _total_purchased_today = read_total_purchased_today(_user);\r\n  }\r\n\r\n  function read_user(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _daily_dgx_limit, uint256 _total_purchased_today)\r\n  {\r\n    _daily_dgx_limit = read_user_daily_limit(_user);\r\n    _total_purchased_today = read_total_purchased_today(_user);\r\n  }\r\n\r\n  /// user daily limit = max(user's overwrite_daily_dgx_ng_limit, global_daily_dgx_ng_limit)\r\n  function read_user_daily_limit(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _daily_dgx_limit)\r\n  {\r\n    _daily_dgx_limit = marketplace.users[_user].overwrite_daily_dgx_ng_limit;\r\n    if (_daily_dgx_limit < marketplace.config.global_daily_dgx_ng_limit) {\r\n      _daily_dgx_limit = marketplace.config.global_daily_dgx_ng_limit;\r\n    }\r\n  }\r\n\r\n  function read_user_purchases_count(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _count)\r\n  {\r\n    _count = marketplace.users[_user].purchases.length;\r\n  }\r\n\r\n  function read_user_purchase_details(address _user, uint256 _index)\r\n           public\r\n           constant\r\n           returns (address _recipient, uint256 _timestamp, uint256 _amount, uint256 _price)\r\n  {\r\n    _recipient = marketplace.users[_user].purchases[_index].recipient;\r\n    _timestamp = marketplace.users[_user].purchases[_index].timestamp;\r\n    _amount = marketplace.users[_user].purchases[_index].amount;\r\n    _price = marketplace.users[_user].purchases[_index].price;\r\n  }\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/abstract/UintIteratorStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n/**\r\n  @title Uint Iterator Storage\r\n  @author DigixGlobal Pte Ltd\r\n*/\r\ncontract UintIteratorStorage {\r\n\r\n  using DoublyLinkedList for DoublyLinkedList.Uint;\r\n\r\n  /**\r\n    @notice Returns the first item from a `DoublyLinkedList.Uint` list\r\n    @param _list The DoublyLinkedList.Uint list\r\n    @return {\"_item\": \"The first item\"}\r\n  */\r\n  function read_first_from_uints(DoublyLinkedList.Uint storage _list)\r\n           internal\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = _list.start_item();\r\n  }\r\n\r\n  /**\r\n    @notice Returns the last item from a `DoublyLinkedList.Uint` list\r\n    @param _list The DoublyLinkedList.Uint list\r\n    @return {\"_item\": \"The last item\"}\r\n  */\r\n  function read_last_from_uints(DoublyLinkedList.Uint storage _list)\r\n           internal\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = _list.end_item();\r\n  }\r\n\r\n  /**\r\n    @notice Returns the next item from a `DoublyLinkedList.Uint` list based on the specified `_current_item`\r\n    @param _list The DoublyLinkedList.Uint list\r\n    @param _current_item The current item\r\n    @return {\"_item\": \"The next item\"}\r\n  */\r\n  function read_next_from_uints(DoublyLinkedList.Uint storage _list, uint256 _current_item)\r\n           internal\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = _list.next_item(_current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Returns the previous item from a `DoublyLinkedList.Uint` list based on the specified `_current_item`\r\n    @param _list The DoublyLinkedList.Uint list\r\n    @param _current_item The current item\r\n    @return {\"_item\": \"The previous item\"}\r\n  */\r\n  function read_previous_from_uints(DoublyLinkedList.Uint storage _list, uint256 _current_item)\r\n           internal\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = _list.previous_item(_current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Returns the total count of itemsfrom a `DoublyLinkedList.Uint` list\r\n    @param _list The DoublyLinkedList.Uint list\r\n    @return {\"_count\": \"The total count of items\"}\r\n  */\r\n  function read_total_uints(DoublyLinkedList.Uint storage _list)\r\n           internal\r\n           constant\r\n           returns (uint256 _count)\r\n  {\r\n    _count = _list.total();\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/storage/ProductsListStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\ncontract ProductsListStorage is UintIteratorStorage, ResolverClient, DigixConstants {\r\n\r\n  using DoublyLinkedList for DoublyLinkedList.Uint;\r\n\r\n  struct System {\r\n    mapping (uint256 => Product) products_by_id;\r\n    DoublyLinkedList.Uint products_list;\r\n  }\r\n\r\n  struct Product {\r\n    bytes32 document;\r\n    bool enabled;\r\n    uint256 ng_weight;\r\n    uint256 effective_ng_weight;\r\n  }\r\n\r\n  System system;\r\n\r\n  function ProductsListStorage(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_STORAGE_PRODUCTS_LIST, _resolver));\r\n  }\r\n\r\n  /// @notice add a new product to the product list\r\n  /// @param _document the dijix ipfs document\r\n  /// @param _ng_weight the weight of the product\r\n  /// @param _effective_ng_weight the effective weight of the product\r\n  /// @return _success whether the product is successfully added\r\n  /// @return _product_id the product id of the newly created product\r\n  function create_product(bytes32 _document, uint256 _ng_weight, uint256 _effective_ng_weight)\r\n           if_sender_is(CONTRACT_CONTROLLER_PRODUCTS_LIST)\r\n           public\r\n           returns (bool _success, uint256 _product_id)\r\n  {\r\n    require(_ng_weight > 0);\r\n    require(_effective_ng_weight > 0);\r\n    _product_id = system.products_list.total() + 1;\r\n    system.products_by_id[_product_id].enabled = true;\r\n    system.products_by_id[_product_id].document = _document;\r\n    system.products_by_id[_product_id].ng_weight = _ng_weight;\r\n    system.products_by_id[_product_id].effective_ng_weight = _effective_ng_weight;\r\n    _success = system.products_list.append(_product_id);\r\n  }\r\n\r\n  /// @notice enable an existing disabled product in the product list\r\n  /// @param _product_id the product id\r\n  /// @return _success whether the product is successfully enabled\r\n  function enable_product(uint256 _product_id)\r\n           if_sender_is(CONTRACT_CONTROLLER_PRODUCTS_LIST)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    if (system.products_by_id[_product_id].enabled == true || system.products_by_id[_product_id].ng_weight == 0 ) {\r\n      // if product is already enabled or product doesnt exist\r\n      _success = false;\r\n    } else {\r\n      system.products_by_id[_product_id].enabled = true;\r\n      _success = true;\r\n    }\r\n  }\r\n\r\n  /// @notice disable an existing enabled product in the product list\r\n  /// @param _product_id the product id\r\n  /// @return _success whether the product is successfully disabled\r\n  function disable_product(uint256 _product_id)\r\n           if_sender_is(CONTRACT_CONTROLLER_PRODUCTS_LIST)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    if (system.products_by_id[_product_id].enabled == false) {\r\n      _success = false;\r\n    } else {\r\n      system.products_by_id[_product_id].enabled = false;\r\n      _success = true;\r\n    }\r\n  }\r\n\r\n\r\n  /// @notice read information of an existing product\r\n  /// @param _product_id the product id\r\n  /// @return _document the dijix ipfs document\r\n  /// @return _ng_weight the weight of the product\r\n  /// @return _effective_ng_weight the effective weight of the product\r\n  /// @return _enabled whether the product is enabled\r\n  function read_product(uint256 _product_id)\r\n           public\r\n           constant\r\n           returns (bytes32 _document, uint256 _ng_weight, uint256 _effective_ng_weight, bool _enabled)\r\n  {\r\n    if (system.products_by_id[_product_id].enabled == true) {\r\n      _ng_weight = system.products_by_id[_product_id].ng_weight;\r\n      _effective_ng_weight = system.products_by_id[_product_id].effective_ng_weight;\r\n      _enabled = system.products_by_id[_product_id].enabled;\r\n      _document = system.products_by_id[_product_id].document;\r\n    } else {\r\n      _ng_weight = 0;\r\n      _effective_ng_weight = 0;\r\n      _enabled = system.products_by_id[_product_id].enabled;\r\n      _document = \"\";\r\n    }\r\n  }\r\n\r\n  /// @notice read weight and effective weight of an existing product\r\n  /// @param _product_id the product id\r\n  /// @return _ng_weight the weight of the product\r\n  /// @return _effective_ng_weight the effective weight of the product\r\n  function read_product_ng_weight_and_effective_ng_weight(uint256 _product_id)\r\n           public\r\n           constant\r\n           returns (uint256 _ng_weight, uint256 _effective_ng_weight)\r\n  {\r\n    if (system.products_by_id[_product_id].enabled == true) {\r\n      _ng_weight = system.products_by_id[_product_id].ng_weight;\r\n      _effective_ng_weight = system.products_by_id[_product_id].effective_ng_weight;\r\n    } else {\r\n      _ng_weight = 0;\r\n      _effective_ng_weight = 0;\r\n    }\r\n  }\r\n\r\n  /// @notice read the total number of products in product list\r\n  /// @return _total_count total number of products\r\n  function read_products_total()\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = read_total_uints(system.products_list);\r\n  }\r\n\r\n  /// @notice read the first product in product list\r\n  /// @return _item first product\r\n  function read_first_product()\r\n           public\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = read_first_from_uints(system.products_list);\r\n  }\r\n\r\n  /// @notice read the last product in product list\r\n  /// @return _item last product\r\n  function read_last_product()\r\n           public\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = read_last_from_uints(system.products_list);\r\n  }\r\n\r\n  /// @notice read the next product after some product\r\n  /// @param _current_item the current item\r\n  /// @return _item next product\r\n  function read_next_from_product(uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = read_next_from_uints(system.products_list, _current_item);\r\n  }\r\n\r\n  /// @notice read the previous product after some product\r\n  /// @param _current_item the current item\r\n  /// @return _item previous product\r\n  function read_previous_from_product(uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = read_previous_from_uints(system.products_list, _current_item);\r\n  }\r\n}\r\n\r\n// File: @digix/cdap/contracts/service/DirectoryService.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n/**\r\n@title Directory Service\r\n@author DigixGlobal\r\n*/\r\ncontract DirectoryService {\r\n\r\n  /**\r\n  @notice Returns the user's role id\r\n  @param _read_role_id_function Function that returns a role id of a user\r\n  @param _user Id of the user\r\n  @return {\"_role_id\": \"Role id of the user\"}\r\n  */\r\n  function internal_get_user_role_id(function (address) external constant returns (uint256) _read_role_id_function, address _user)\r\n           internal\r\n           constant\r\n           returns (uint256 _role_id)\r\n  {\r\n    _role_id = _read_role_id_function(_user);\r\n  }\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/abstract/IndexedAddressIteratorStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n/**\r\n  @title Indexed Address IteratorStorage\r\n  @author DigixGlobal Pte Ltd\r\n  @notice This contract utilizes: [Doubly Linked List](/DoublyLinkedList)\r\n*/\r\ncontract IndexedAddressIteratorStorage {\r\n\r\n  using DoublyLinkedList for DoublyLinkedList.IndexedAddress;\r\n  /**\r\n    @notice Reads the first item from an Indexed Address Doubly Linked List\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @return {\"_item\" : \"First item on the list\"}\r\n  */\r\n  function read_first_from_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index)\r\n           internal\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = _list.start_item(_collection_index);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the last item from an Indexed Address Doubly Linked list\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @return {\"_item\" : \"First item on the list\"}\r\n  */\r\n  function read_last_from_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index)\r\n           internal\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = _list.end_item(_collection_index);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the next item from an Indexed Address Doubly Linked List based on the specified `_current_item`\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @param _current_item The current item to use as base line\r\n    @return {\"_item\": \"The next item on the list\"}\r\n  */\r\n  function read_next_from_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index, address _current_item)\r\n           internal\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = _list.next_item(_collection_index, _current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the previous item from an Index Address Doubly Linked List based on the specified `_current_item`\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @param _current_item The current item to use as base line\r\n    @return {\"_item\" : \"The previous item on the list\"}\r\n  */\r\n  function read_previous_from_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index, address _current_item)\r\n           internal\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = _list.previous_item(_collection_index, _current_item);\r\n  }\r\n\r\n\r\n  /**\r\n    @notice Reads the total number of items in an Indexed Address Doubly Linked List\r\n    @param _list  The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @return {\"_count\": \"Length of the Doubly Linked list\"}\r\n  */\r\n  function read_total_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index)\r\n           internal\r\n           constant\r\n           returns (uint256 _count)\r\n  {\r\n    _count = _list.total(_collection_index);\r\n  }\r\n\r\n}\r\n\r\n// File: @digix/cdap/contracts/storage/DirectoryStorage.sol\r\n\r\npragma solidity ^0.4.16;\r\n\r\n\r\n\r\n/**\r\n@title Directory Storage contains information of a directory\r\n@author DigixGlobal\r\n*/\r\ncontract DirectoryStorage is IndexedAddressIteratorStorage, UintIteratorStorage {\r\n\r\n  using DoublyLinkedList for DoublyLinkedList.IndexedAddress;\r\n  using DoublyLinkedList for DoublyLinkedList.Uint;\r\n\r\n  struct User {\r\n    bytes32 document;\r\n    bool active;\r\n  }\r\n\r\n  struct Group {\r\n    bytes32 name;\r\n    bytes32 document;\r\n    uint256 role_id;\r\n    mapping(address => User) members_by_address;\r\n  }\r\n\r\n  struct System {\r\n    DoublyLinkedList.Uint groups;\r\n    DoublyLinkedList.IndexedAddress groups_collection;\r\n    mapping (uint256 => Group) groups_by_id;\r\n    mapping (address => uint256) group_ids_by_address;\r\n    mapping (uint256 => bytes32) roles_by_id;\r\n    bool initialized;\r\n    uint256 total_groups;\r\n  }\r\n\r\n  System system;\r\n\r\n  /**\r\n  @notice Initializes directory settings\r\n  @return _success If directory initialization is successful\r\n  */\r\n  function initialize_directory()\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    require(system.initialized == false);\r\n    system.total_groups = 0;\r\n    system.initialized = true;\r\n    internal_create_role(1, \"root\");\r\n    internal_create_group(1, \"root\", \"\");\r\n    _success = internal_update_add_user_to_group(1, tx.origin, \"\");\r\n  }\r\n\r\n  /**\r\n  @notice Creates a new role with the given information\r\n  @param _role_id Id of the new role\r\n  @param _name Name of the new role\r\n  @return {\"_success\": \"If creation of new role is successful\"}\r\n  */\r\n  function internal_create_role(uint256 _role_id, bytes32 _name)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    require(_role_id > 0);\r\n    require(_name != bytes32(0x0));\r\n    system.roles_by_id[_role_id] = _name;\r\n    _success = true;\r\n  }\r\n\r\n  /**\r\n  @notice Returns the role's name of a role id\r\n  @param _role_id Id of the role\r\n  @return {\"_name\": \"Name of the role\"}\r\n  */\r\n  function read_role(uint256 _role_id)\r\n           public\r\n           constant\r\n           returns (bytes32 _name)\r\n  {\r\n    _name = system.roles_by_id[_role_id];\r\n  }\r\n\r\n  /**\r\n  @notice Creates a new group with the given information\r\n  @param _role_id Role id of the new group\r\n  @param _name Name of the new group\r\n  @param _document Document of the new group\r\n  @return {\r\n    \"_success\": \"If creation of the new group is successful\",\r\n    \"_group_id: \"Id of the new group\"\r\n  }\r\n  */\r\n  function internal_create_group(uint256 _role_id, bytes32 _name, bytes32 _document)\r\n           internal\r\n           returns (bool _success, uint256 _group_id)\r\n  {\r\n    require(_role_id > 0);\r\n    require(read_role(_role_id) != bytes32(0x0));\r\n    _group_id = ++system.total_groups;\r\n    system.groups.append(_group_id);\r\n    system.groups_by_id[_group_id].role_id = _role_id;\r\n    system.groups_by_id[_group_id].name = _name;\r\n    system.groups_by_id[_group_id].document = _document;\r\n    _success = true;\r\n  }\r\n\r\n  /**\r\n  @notice Returns the group's information\r\n  @param _group_id Id of the group\r\n  @return {\r\n    \"_role_id\": \"Role id of the group\",\r\n    \"_name: \"Name of the group\",\r\n    \"_document: \"Document of the group\"\r\n  }\r\n  */\r\n  function read_group(uint256 _group_id)\r\n           public\r\n           constant\r\n           returns (uint256 _role_id, bytes32 _name, bytes32 _document, uint256 _members_count)\r\n  {\r\n    if (system.groups.valid_item(_group_id)) {\r\n      _role_id = system.groups_by_id[_group_id].role_id;\r\n      _name = system.groups_by_id[_group_id].name;\r\n      _document = system.groups_by_id[_group_id].document;\r\n      _members_count = read_total_indexed_addresses(system.groups_collection, bytes32(_group_id));\r\n    } else {\r\n      _role_id = 0;\r\n      _name = \"invalid\";\r\n      _document = \"\";\r\n      _members_count = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n  @notice Adds new user with the given information to a group\r\n  @param _group_id Id of the group\r\n  @param _user Address of the new user\r\n  @param _document Information of the new user\r\n  @return {\"_success\": \"If adding new user to a group is successful\"}\r\n  */\r\n  function internal_update_add_user_to_group(uint256 _group_id, address _user, bytes32 _document)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (system.groups_by_id[_group_id].members_by_address[_user].active == false && system.group_ids_by_address[_user] == 0 && system.groups_by_id[_group_id].role_id != 0) {\r\n\r\n      system.groups_by_id[_group_id].members_by_address[_user].active = true;\r\n      system.group_ids_by_address[_user] = _group_id;\r\n      system.groups_collection.append(bytes32(_group_id), _user);\r\n      system.groups_by_id[_group_id].members_by_address[_user].document = _document;\r\n      _success = true;\r\n    } else {\r\n      _success = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n  @notice Removes user from its group\r\n  @param _user Address of the user\r\n  @return {\"_success\": \"If removing of user is successful\"}\r\n  */\r\n  function internal_destroy_group_user(address _user)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    uint256 _group_id = system.group_ids_by_address[_user];\r\n    if ((_group_id == 1) && (system.groups_collection.total(bytes32(_group_id)) == 1)) {\r\n      _success = false;\r\n    } else {\r\n      system.groups_by_id[_group_id].members_by_address[_user].active = false;\r\n      system.group_ids_by_address[_user] = 0;\r\n      delete system.groups_by_id[_group_id].members_by_address[_user];\r\n      _success = system.groups_collection.remove_item(bytes32(_group_id), _user);\r\n    }\r\n  }\r\n\r\n  /**\r\n  @notice Returns the role id of a user\r\n  @param _user Address of a user\r\n  @return {\"_role_id\": \"Role id of the user\"}\r\n  */\r\n  function read_user_role_id(address _user)\r\n           constant\r\n           public\r\n           returns (uint256 _role_id)\r\n  {\r\n    uint256 _group_id = system.group_ids_by_address[_user];\r\n    _role_id = system.groups_by_id[_group_id].role_id;\r\n  }\r\n\r\n  /**\r\n  @notice Returns the user's information\r\n  @param _user Address of the user\r\n  @return {\r\n    \"_group_id\": \"Group id of the user\",\r\n    \"_role_id\": \"Role id of the user\",\r\n    \"_document\": \"Information of the user\"\r\n  }\r\n  */\r\n  function read_user(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _group_id, uint256 _role_id, bytes32 _document)\r\n  {\r\n    _group_id = system.group_ids_by_address[_user];\r\n    _role_id = system.groups_by_id[_group_id].role_id;\r\n    _document = system.groups_by_id[_group_id].members_by_address[_user].document;\r\n  }\r\n\r\n  /**\r\n  @notice Returns the id of the first group\r\n  @return {\"_group_id\": \"Id of the first group\"}\r\n  */\r\n  function read_first_group()\r\n           view\r\n           external\r\n           returns (uint256 _group_id)\r\n  {\r\n    _group_id = read_first_from_uints(system.groups);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the id of the last group\r\n  @return {\"_group_id\": \"Id of the last group\"}\r\n  */\r\n  function read_last_group()\r\n           view\r\n           external\r\n           returns (uint256 _group_id)\r\n  {\r\n    _group_id = read_last_from_uints(system.groups);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the id of the previous group depending on the given current group\r\n  @param _current_group_id Id of the current group\r\n  @return {\"_group_id\": \"Id of the previous group\"}\r\n  */\r\n  function read_previous_group_from_group(uint256 _current_group_id)\r\n           view\r\n           external\r\n           returns (uint256 _group_id)\r\n  {\r\n    _group_id = read_previous_from_uints(system.groups, _current_group_id);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the id of the next group depending on the given current group\r\n  @param _current_group_id Id of the current group\r\n  @return {\"_group_id\": \"Id of the next group\"}\r\n  */\r\n  function read_next_group_from_group(uint256 _current_group_id)\r\n           view\r\n           external\r\n           returns (uint256 _group_id)\r\n  {\r\n    _group_id = read_next_from_uints(system.groups, _current_group_id);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the total number of groups\r\n  @return {\"_total_groups\": \"Total number of groups\"}\r\n  */\r\n  function read_total_groups()\r\n           view\r\n           external\r\n           returns (uint256 _total_groups)\r\n  {\r\n    _total_groups = read_total_uints(system.groups);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the first user of a group\r\n  @param _group_id Id of the group\r\n  @return {\"_user\": \"Address of the user\"}\r\n  */\r\n  function read_first_user_in_group(bytes32 _group_id)\r\n           view\r\n           external\r\n           returns (address _user)\r\n  {\r\n    _user = read_first_from_indexed_addresses(system.groups_collection, bytes32(_group_id));\r\n  }\r\n\r\n  /**\r\n  @notice Returns the last user of a group\r\n  @param _group_id Id of the group\r\n  @return {\"_user\": \"Address of the user\"}\r\n  */\r\n  function read_last_user_in_group(bytes32 _group_id)\r\n           view\r\n           external\r\n           returns (address _user)\r\n  {\r\n    _user = read_last_from_indexed_addresses(system.groups_collection, bytes32(_group_id));\r\n  }\r\n\r\n  /**\r\n  @notice Returns the next user of a group depending on the given current user\r\n  @param _group_id Id of the group\r\n  @param _current_user Address of the current user\r\n  @return {\"_user\": \"Address of the next user\"}\r\n  */\r\n  function read_next_user_in_group(bytes32 _group_id, address _current_user)\r\n           view\r\n           external\r\n           returns (address _user)\r\n  {\r\n    _user = read_next_from_indexed_addresses(system.groups_collection, bytes32(_group_id), _current_user);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the previous user of a group depending on the given current user\r\n  @param _group_id Id of the group\r\n  @param _current_user Address of the current user\r\n  @return {\"_user\": \"Address of the last user\"}\r\n  */\r\n  function read_previous_user_in_group(bytes32 _group_id, address _current_user)\r\n           view\r\n           external\r\n           returns (address _user)\r\n  {\r\n    _user = read_previous_from_indexed_addresses(system.groups_collection, bytes32(_group_id), _current_user);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the total number of users of a group\r\n  @param _group_id Id of the group\r\n  @return {\"_total_users\": \"Total number of users\"}\r\n  */\r\n  function read_total_users_in_group(bytes32 _group_id)\r\n           view\r\n           external\r\n           returns (uint256 _total_users)\r\n  {\r\n    _total_users = read_total_indexed_addresses(system.groups_collection, bytes32(_group_id));\r\n  }\r\n}\r\n\r\n// File: contracts/storage/DigixDirectoryStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\ncontract DigixDirectoryStorage is DirectoryStorage, ResolverClient, DigixConstants {\r\n\r\n  function DigixDirectoryStorage(address _resolver) public {\r\n    require(init(CONTRACT_STORAGE_DIGIX_DIRECTORY, _resolver));\r\n    require(initialize_directory());\r\n  }\r\n\r\n  function create_group(uint256 _role_id, bytes32 _name, bytes32 _document)\r\n           if_sender_is(CONTRACT_CONTROLLER_DIGIX_DIRECTORY)\r\n           public\r\n           returns (bool _success, uint256 _group_id)\r\n  {\r\n    (_success, _group_id) = internal_create_group(_role_id, _name, _document);\r\n    require(_success);\r\n  }\r\n\r\n  function create_role(uint256 _role_id, bytes32 _name)\r\n           if_sender_is(CONTRACT_CONTROLLER_DIGIX_DIRECTORY)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = internal_create_role(_role_id, _name);\r\n    require(_success);\r\n  }\r\n\r\n  function update_add_user_to_group(uint256 _group_id, address _user, bytes32 _document)\r\n           if_sender_is(CONTRACT_CONTROLLER_DIGIX_DIRECTORY)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = internal_update_add_user_to_group(_group_id, _user, _document);\r\n    require(_success);\r\n  }\r\n\r\n  function update_remove_group_user(address _user)\r\n           if_sender_is(CONTRACT_CONTROLLER_DIGIX_DIRECTORY)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = internal_destroy_group_user(_user);\r\n    require(_success);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/service/DigixDirectoryService.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n\r\ncontract DigixDirectoryService is DirectoryService, ResolverClient, DigixConstants {\r\n\r\n  function DigixDirectoryService(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_SERVICE_DIRECTORY, _resolver));\r\n  }\r\n\r\n  function directory_storage()\r\n           internal\r\n           constant\r\n           returns (DigixDirectoryStorage _contract)\r\n  {\r\n    _contract = DigixDirectoryStorage(get_contract(CONTRACT_STORAGE_DIGIX_DIRECTORY));\r\n  }\r\n\r\n  function get_user_role_id(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _role_id)\r\n  {\r\n    _role_id = internal_get_user_role_id(directory_storage().read_user_role_id, _user);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/common/Controller.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n/// @title Common controller functions\r\n/// @author DigixGlobal Pte Ltd\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Controller is ResolverClient, DigixConstants {\r\n\r\n  function products_list_storage()\r\n           internal\r\n           constant\r\n           returns (ProductsListStorage _contract)\r\n  {\r\n    _contract = ProductsListStorage(get_contract(CONTRACT_STORAGE_PRODUCTS_LIST));\r\n  }\r\n\r\n  function digix_directory_service()\r\n           internal\r\n           constant\r\n           returns (DigixDirectoryService _contract)\r\n  {\r\n    _contract = DigixDirectoryService(get_contract(CONTRACT_SERVICE_DIRECTORY));\r\n  }\r\n\r\n  function token_demurrage_service()\r\n           internal\r\n           constant\r\n           returns (TokenDemurrageService _contract)\r\n  {\r\n    _contract = TokenDemurrageService(get_contract(CONTRACT_SERVICE_TOKEN_DEMURRAGE));\r\n  }\r\n\r\n  function assets_storage()\r\n           internal\r\n           constant\r\n           returns (AssetsStorage _contract)\r\n  {\r\n    _contract = AssetsStorage(get_contract(CONTRACT_STORAGE_ASSETS));\r\n  }\r\n\r\n  function marketplace_storage()\r\n           internal\r\n           constant\r\n           returns (MarketplaceStorage _contract)\r\n  {\r\n    _contract = MarketplaceStorage(get_contract(CONTRACT_STORAGE_MARKETPLACE));\r\n  }\r\n\r\n  function gold_token_storage()\r\n           internal\r\n           constant\r\n           returns (GoldTokenStorage _contract)\r\n  {\r\n    _contract = GoldTokenStorage(get_contract(CONTRACT_STORAGE_GOLD_TOKEN));\r\n  }\r\n\r\n  function asset_events_storage()\r\n           internal\r\n           constant\r\n           returns (AssetEventsStorage _contract)\r\n  {\r\n    _contract = AssetEventsStorage(get_contract(CONTRACT_STORAGE_ASSET_EVENTS));\r\n  }\r\n\r\n  function identity_storage()\r\n           internal\r\n           constant\r\n           returns (IdentityStorage _contract)\r\n  {\r\n    _contract = IdentityStorage(get_contract(CONTRACT_STORAGE_IDENTITY));\r\n  }\r\n\r\n\r\n  modifier if_caller_is_role(address _caller, uint256 _intended_role_id) {\r\n    uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n    require(_role_id == _intended_role_id);\r\n    _;\r\n  }\r\n\r\n}\r\n\r\n// File: @digix/cacp-contracts/contracts/ACConditions.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n/// @title Condition based access control\r\n/// @author DigixGlobal\r\n\r\ncontract ACConditions is Constants {\r\n\r\n  modifier not_null_address(address _item) {\r\n    require(_item != NULL_ADDRESS);\r\n    _;\r\n  }\r\n\r\n  modifier if_null_address(address _item) {\r\n    require(_item == NULL_ADDRESS);\r\n    _;\r\n  }\r\n\r\n  modifier not_null_uint(uint256 _item) {\r\n    require(_item != ZERO);\r\n    _;\r\n  }\r\n\r\n  modifier if_null_uint(uint256 _item) {\r\n    require(_item == ZERO);\r\n    _;\r\n  }\r\n\r\n  modifier not_empty_bytes(bytes32 _item) {\r\n    require(_item != EMPTY);\r\n    _;\r\n  }\r\n\r\n  modifier if_empty_bytes(bytes32 _item) {\r\n    require(_item == EMPTY);\r\n    _;\r\n  }\r\n\r\n  modifier not_null_string(string _item) {\r\n    bytes memory _i = bytes(_item);\r\n    require(_i.length > 0);\r\n    _;\r\n  }\r\n\r\n  modifier if_null_string(string _item) {\r\n    bytes memory _i = bytes(_item);\r\n    require(_i.length == 0);\r\n    _;\r\n  }\r\n\r\n  modifier require_gas(uint256 _requiredgas) {\r\n    require(msg.gas  >= (_requiredgas - 22000));\r\n    _;\r\n  }\r\n\r\n  function is_contract(address _contract)\r\n           public\r\n           constant\r\n           returns (bool _is_contract)\r\n  {\r\n    uint32 _code_length;\r\n\r\n    assembly {\r\n      _code_length := extcodesize(_contract)\r\n    }\r\n\r\n    if(_code_length > 1) {\r\n      _is_contract = true;\r\n    } else {\r\n      _is_contract = false;\r\n    }\r\n  }\r\n\r\n  modifier if_contract(address _contract) {\r\n    require(is_contract(_contract) == true);\r\n    _;\r\n  }\r\n\r\n  modifier unless_contract(address _contract) {\r\n    require(is_contract(_contract) == false);\r\n    _;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/lib/ECVerify.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\nlibrary ECVerify {\r\n\r\n  struct Signature {\r\n    bytes32 hash;\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n  }\r\n\r\n  function parse_signature(bytes32 _hash, bytes _sigbytes) internal pure returns (Signature _signature) {\r\n    bytes32 _r;\r\n    bytes32 _s;\r\n    uint8 _v;\r\n\r\n    assembly {\r\n      _r := mload(add(_sigbytes, 32))\r\n      _s := mload(add(_sigbytes, 64))\r\n      _v := byte(0, mload(add(_sigbytes, 96)))\r\n    }\r\n    if (_v < 27) {\r\n      _v += 27;\r\n    }\r\n    if ((_v == 27) || (_v == 28)) {\r\n      _signature.hash = _hash;\r\n      _signature.r = _r;\r\n      _signature.s = _s;\r\n      _signature.v = _v;\r\n    } else {\r\n      _signature.hash = 0x0;\r\n      _signature.r = 0x0;\r\n      _signature.s = 0x0;\r\n      _signature.v = 0;\r\n    }\r\n    delete _sigbytes;\r\n  }\r\n\r\n  function safe_ecrecover(Signature memory _signature) internal returns (bool _verifies, address _signer) {\r\n    bytes32 _hash = _signature.hash;\r\n    bytes32 _r = _signature.r;\r\n    bytes32 _s = _signature.s;\r\n    uint8 _v = _signature.v;\r\n\r\n    assembly {\r\n      let _size := mload(0x40)\r\n      mstore(_size, _hash)\r\n      mstore(add(_size, 32), _v)\r\n      mstore(add(_size, 64), _r)\r\n      mstore(add(_size, 96), _s)\r\n      _verifies := call(3000, 1, 0, _size, 128, _size, 32)\r\n      _signer := mload(_size)\r\n    }\r\n    delete _hash;\r\n    delete _r;\r\n    delete _s;\r\n    delete _v;\r\n\r\n    if (_verifies == true) {\r\n      return (_verifies, _signer);\r\n    } else {\r\n      return (_verifies, address(0x0));\r\n    }\r\n  }\r\n\r\n  function ecrecovery(bytes32 _hash, bytes _sigbytes) public returns (bool _verifies, address _signer) {\r\n    Signature memory _signature = parse_signature(_hash, _sigbytes);\r\n    (_verifies, _signer) = safe_ecrecover(_signature);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/service/MarketplaceService.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\ncontract MarketplaceService is ResolverClient, DigixConstants  {\r\n\r\n  mapping (uint => mapping(uint => bool)) used_nonces;\r\n\r\n  function MarketplaceService(address _resolver) public {\r\n    require(init(CONTRACT_SERVICE_MARKETPLACE, _resolver));\r\n  }\r\n\r\n  function verify_signed_price(uint _block_number, uint _nonce, uint _price, address _signer, bytes _signature)\r\n           public\r\n           returns (bool _verified, address _actual_signer)\r\n  {\r\n   bytes32 _hash;\r\n   bool _verifies;\r\n   _hash = hash_price_data(_block_number, _nonce, _price);\r\n   (_verifies,_actual_signer) = ECVerify.ecrecovery(_hash, _signature);\r\n   _verified = (_verifies && (_actual_signer == _signer));\r\n  }\r\n\r\n  function concat_price_data(uint _a, uint _b, uint _c) internal pure returns (string _result) {\r\n    uint maxlength = 100;\r\n    bytes memory _reversed = new bytes(maxlength);\r\n    uint i = 0;\r\n    uint t = 0;\r\n    uint _remainder;\r\n    while(_c != 0) {\r\n      _remainder = _c % 10;\r\n      _c = _c / 10;\r\n      _reversed[i++] = byte(48 + _remainder);\r\n      t++;\r\n    }\r\n    _reversed[i++] = byte(0x3a);\r\n    t++;\r\n    while(_b != 0) {\r\n      _remainder = _b % 10;\r\n      _b = _b / 10;\r\n      _reversed[i++] = byte(48 + _remainder);\r\n      t++;\r\n    }\r\n    _reversed[i++] = byte(0x3a);\r\n    t++;\r\n    while(_a != 0) {\r\n      _remainder = _a % 10;\r\n      _a = _a / 10;\r\n      _reversed[i++] = byte(48 + _remainder);\r\n      t++;\r\n    }\r\n\r\n    uint _x = t;\r\n\r\n    while(_x != 0) {\r\n      uint _rem_x = _x % 10;\r\n      _x = _x / 10;\r\n      _reversed[i++] = byte(48 + _rem_x);\r\n      t++;\r\n    }\r\n\r\n    bytes memory _correct = new bytes(t);\r\n    uint k = 0;\r\n    uint j = t - 1;\r\n\r\n    while(t > 0) {\r\n      _correct[k] = _reversed[--t];\r\n      k++;\r\n      j--;\r\n    }\r\n    _result = string(_correct);\r\n  }\r\n\r\n  function hash_price_data(uint _block_number, uint _nonce, uint _price) public pure returns (bytes32 _keccak_hash) {\r\n    string memory _message = concat_price_data(_block_number, _nonce, _price);\r\n    bytes memory _prefix = \"\\x19Ethereum Signed Message:\\n\";\r\n    _keccak_hash = keccak256(_prefix, _message);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/common/MarketplaceControllerCommon.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n\r\ncontract MarketplaceControllerCommon is Controller, ACConditions {\r\n\r\n  uint256 constant public MILLIGRAM_TO_NANOGRAMS = 1000000;\r\n\r\n  function marketplace_service()\r\n           internal\r\n           constant\r\n           returns (MarketplaceService _contract)\r\n  {\r\n    _contract = MarketplaceService(get_contract(CONTRACT_SERVICE_MARKETPLACE));\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/controller/MarketplaceAdminController.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n/// @title DigixCore Marketplace Controller\r\n/// @author DigixGlobal Pte Ltd\r\n\r\n\r\n\r\n\r\ncontract MarketplaceAdminController is MarketplaceControllerCommon {\r\n\r\n  function MarketplaceAdminController(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN, _resolver));\r\n  }\r\n\r\n  function gold_token_storage()\r\n           internal\r\n           constant\r\n           returns (GoldTokenStorage _contract)\r\n  {\r\n    _contract = GoldTokenStorage(get_contract(CONTRACT_STORAGE_GOLD_TOKEN));\r\n  }\r\n\r\n  function digix_directory_service()\r\n           internal\r\n           constant\r\n           returns (DigixDirectoryService _contract)\r\n  {\r\n    _contract = DigixDirectoryService(get_contract(CONTRACT_SERVICE_DIRECTORY));\r\n  }\r\n\r\n  function put_config(address _caller, uint256 _global_daily_dgx_ng_limit, uint256 _minimum_purchase_dgx_ng, uint256 _maximum_block_drift, address _payment_collector)\r\n           unless_contract(_payment_collector)\r\n           if_sender_is(CONTRACT_INTERACTIVE_MARKETPLACE_ADMIN)\r\n           if_caller_is_role(_caller, ROLE_MARKETPLACE_ADMIN)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = marketplace_storage().update_config(_global_daily_dgx_ng_limit, _minimum_purchase_dgx_ng, _maximum_block_drift, _payment_collector);\r\n  }\r\n\r\n  function put_approve_signer(address _caller, address _signer)\r\n           if_sender_is(CONTRACT_INTERACTIVE_MARKETPLACE_ADMIN)\r\n           if_caller_is_role(_caller, ROLE_MARKETPLACE_ADMIN)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = marketplace_storage().update_signer_approval(_signer, true);\r\n  }\r\n\r\n  function put_revoke_signer(address _caller, address _signer)\r\n           if_sender_is(CONTRACT_INTERACTIVE_MARKETPLACE_ADMIN)\r\n           if_caller_is_role(_caller, ROLE_MARKETPLACE_ADMIN)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = marketplace_storage().update_signer_approval(_signer, false);\r\n  }\r\n\r\n  function put_price_floor(address _caller, uint256 _price_floor_wei_per_dgx_mg)\r\n           if_sender_is(CONTRACT_INTERACTIVE_MARKETPLACE_ADMIN)\r\n           if_caller_is_role(_caller, ROLE_MARKETPLACE_ADMIN)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = marketplace_storage().update_price_floor(_price_floor_wei_per_dgx_mg);\r\n  }\r\n\r\n  function put_max_dgx_available_daily(address _caller, uint256 _max_dgx_available_daily)\r\n           if_sender_is(CONTRACT_INTERACTIVE_MARKETPLACE_ADMIN)\r\n           if_caller_is_role(_caller, ROLE_MARKETPLACE_ADMIN)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = marketplace_storage().update_max_dgx_available_daily(_max_dgx_available_daily);\r\n  }\r\n\r\n  function move_inventory(address _caller, address _destination, uint256 _amount)\r\n           if_sender_is(CONTRACT_INTERACTIVE_MARKETPLACE_ADMIN)\r\n           if_caller_is_role(_caller, ROLE_MARKETPLACE_ADMIN)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = marketplace_storage().move_inventory(_destination, _amount);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/controller/MarketplaceController.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n/// @title DigixCore Marketplace Controller\r\n/// @author DigixGlobal Pte Ltd\r\n/// Contracts that need to be deployed for this contract to work:\r\n///   MathUtils, DoublyLinkedList, ECVerify, ContractResolver, CoreStorage\r\n///   TokenTransferController, TokenInfoController, TokenDemurrageService, TokenApprovalController,\r\n///   Token, MarketplaceStorage, MarketplaceService\r\n\r\n\r\ncontract MarketplaceController is MarketplaceControllerCommon {\r\n\r\n  function MarketplaceController(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_CONTROLLER_MARKETPLACE, _resolver));\r\n  }\r\n\r\n  struct UintData {\r\n    uint256 pre;\r\n    uint256 post;\r\n  }\r\n\r\n  struct Config {\r\n    uint256 global_dgx_ng_limit;\r\n    uint256 minimum_purchase_dgx_ng;\r\n    uint256 maximum_block_drift;\r\n    address payment_collector;\r\n    uint256 max_dgx_available_daily;\r\n    uint256 price_floor_wei_per_dgx_mg;\r\n  }\r\n\r\n  struct Verification {\r\n    uint256 amount_dgx_ng;\r\n    uint256 block_number;\r\n    address signer;\r\n    bool valid_signature;\r\n    bool used_nonce;\r\n    bool approved_signer;\r\n  }\r\n\r\n  struct Purchase {\r\n    User buyer;\r\n    User recipient;\r\n    Verification verification;\r\n    Config config;\r\n    uint256 wei_sent;\r\n    uint256 wei_per_dgx_mg;\r\n    uint256 block_number;\r\n    uint256 nonce;\r\n    address signer;\r\n    bytes signature;\r\n  }\r\n\r\n  struct User {\r\n    address account;\r\n    uint256 total_purchased_today;\r\n    bool valid_kyc;\r\n    uint256 daily_dgx_limit;\r\n  }\r\n\r\n  function put_purchase_for(uint256 _wei_sent, address _buyer, address _recipient, uint256 _block_number, uint256 _nonce, uint256 _wei_per_dgx_mg, address _signer, bytes _signature)\r\n           if_sender_is(CONTRACT_INTERACTIVE_MARKETPLACE)\r\n           payable\r\n           public\r\n           returns (bool _success, uint256 _purchased_amount)\r\n  {\r\n    Purchase memory _purchase;\r\n\r\n    (_purchase.config.global_dgx_ng_limit, _purchase.config.minimum_purchase_dgx_ng, _purchase.config.maximum_block_drift, _purchase.config.payment_collector) = marketplace_storage().read_config();\r\n    _purchase.config.max_dgx_available_daily = marketplace_storage().read_max_dgx_available_daily();\r\n    _purchase.config.price_floor_wei_per_dgx_mg = marketplace_storage().read_price_floor();\r\n\r\n    _purchase.buyer.account = _buyer;\r\n    _purchase.recipient.account = _recipient;\r\n    _purchase.block_number = _block_number;\r\n    _purchase.nonce = _nonce;\r\n    _purchase.wei_per_dgx_mg = _wei_per_dgx_mg;\r\n    _purchase.signer = _signer;\r\n    _purchase.signature = _signature;\r\n    _purchase.wei_sent = _wei_sent;\r\n\r\n    Purchase memory _processed;\r\n    (_processed, _success) = verify_purchase(_purchase);\r\n    _purchased_amount = _processed.verification.amount_dgx_ng;\r\n  }\r\n\r\n  function verify_purchase(Purchase memory _purchase)\r\n           internal\r\n           returns (Purchase memory _processed, bool _success)\r\n  {\r\n    _processed = _purchase;\r\n    _processed.verification.amount_dgx_ng = (_purchase.wei_sent * MILLIGRAM_TO_NANOGRAMS) / _purchase.wei_per_dgx_mg;\r\n\r\n    (_processed.verification.valid_signature,\r\n     _processed.verification.signer)\r\n     = marketplace_service().verify_signed_price(_purchase.block_number,\r\n                                                 _purchase.nonce,\r\n                                                 _purchase.wei_per_dgx_mg,\r\n                                                 _purchase.signer,\r\n                                                 _purchase.signature);\r\n\r\n    (_processed.buyer.daily_dgx_limit,\r\n     _processed.buyer.total_purchased_today,\r\n     _processed.verification.used_nonce,\r\n     _processed.verification.approved_signer)\r\n     = marketplace_storage().read_for_purchase(_processed.buyer.account,\r\n                                               _processed.block_number,\r\n                                               _processed.nonce,\r\n                                               _processed.signer);\r\n    _processed.buyer.valid_kyc = identity_storage().read_user_kyc_valid(_processed.buyer.account);\r\n    require(_processed.buyer.valid_kyc);\r\n\r\n    require(_processed.wei_per_dgx_mg >= _processed.config.price_floor_wei_per_dgx_mg);\r\n    require(marketplace_storage().read_total_global_purchased_today() + _processed.verification.amount_dgx_ng <= _processed.config.max_dgx_available_daily);\r\n    require(marketplace_storage().read_is_approved_signer(_processed.verification.signer));\r\n    require(_processed.verification.signer == _processed.signer);\r\n    require(_processed.verification.used_nonce == false);\r\n    require(_processed.verification.amount_dgx_ng  >= _processed.config.minimum_purchase_dgx_ng);\r\n    require((_processed.buyer.total_purchased_today + _processed.verification.amount_dgx_ng) <= _processed.buyer.daily_dgx_limit);\r\n    require(_processed.verification.valid_signature);\r\n    require((_processed.block_number + _purchase.config.maximum_block_drift) >= block.number);\r\n    require(marketplace_storage().update_user_purchase(_processed.recipient.account, _processed.buyer.account, _processed.verification.amount_dgx_ng, _processed.wei_per_dgx_mg, _processed.block_number, _processed.nonce));\r\n    _processed.config.payment_collector.transfer(_processed.wei_sent);\r\n    _success = true;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/common/MarketplaceCommon.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract MarketplaceCommon is ResolverClient, ACConditions, DigixConstants {\r\n\r\n  function marketplace_admin_controller()\r\n           internal\r\n           constant\r\n           returns (MarketplaceAdminController _contract)\r\n  {\r\n    _contract = MarketplaceAdminController(get_contract(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN));\r\n  }\r\n\r\n  function marketplace_storage()\r\n           internal\r\n           constant\r\n           returns (MarketplaceStorage _contract)\r\n  {\r\n    _contract = MarketplaceStorage(get_contract(CONTRACT_STORAGE_MARKETPLACE));\r\n  }\r\n\r\n  function marketplace_controller()\r\n           internal\r\n           constant\r\n           returns (MarketplaceController _contract)\r\n  {\r\n    _contract = MarketplaceController(get_contract(CONTRACT_CONTROLLER_MARKETPLACE));\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/common/DigixConstantsElectron.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\ncontract DigixConstantsElectron {\r\n    uint256 constant ROLE_ELECTRON_MARKETPLACE_ADMIN = 13; // This role is for confirming the fiat purchases in Electron\r\n    uint256 constant ROLE_ASSET_RECAST_SIGNER = 14; // This role is for signing KYC information during a recast operation\r\n\r\n    /// storage contracts\r\n    bytes32 constant CONTRACT_STORAGE_MARKETPLACE_ELECTRON = \"s:mp:electron\";\r\n    bytes32 constant CONTRACT_STORAGE_ASSETS_ELECTRON = \"s:assets:electron\";\r\n    bytes32 constant CONTRACT_SERVICE_VERIFICATION = \"service:verification\";\r\n    bytes32 constant CONTRACT_CONTROLLER_ASSETS_ELECTRON = \"c:assets:electron\";\r\n    bytes32 constant CONTRACT_CONTROLLER_MARKETPLACE_ADMIN_ELECTRON = \"c:mpadmin:electron\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_ELECTRON = \"i:mp:electron\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_ADMIN_ELECTRON = \"i:mpadmin:electron\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_ASSETS_EXPLORER_ELECTRON = \"i:assets:explorer:electron\";\r\n\r\n    uint256 constant TOKEN_INDEX_FIAT = 1;\r\n    uint256 constant TOKEN_INDEX_ETHER = 2;\r\n    uint256 constant TOKEN_INDEX_DAI = 3;\r\n\r\n    uint256 constant MAX_INTEGER = uint256(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n\r\n    uint256 constant DUMMY_NONCE = 123;\r\n    /* bytes32 constant CONTRACT_CONTROLLER_MARKETPLACE_ADMIN_EXTRAS = \"c:mpadmin:extras\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_V2 = \"i:mp:v2\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_ADMIN_EXTRAS = \"i:mpadmin:extras\"; */\r\n}\r\n\r\n// File: contracts/common/DigixConstantsExtras.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\ncontract DigixConstantsExtras {\r\n    /// storage contracts\r\n    bytes32 constant CONTRACT_STORAGE_MARKETPLACE_EXTRAS = \"s:mp:extras\";\r\n    bytes32 constant CONTRACT_CONTROLLER_MARKETPLACE_ADMIN_EXTRAS = \"c:mpadmin:extras\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_V2 = \"i:mp:v2\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_ADMIN_EXTRAS = \"i:mpadmin:extras\";\r\n}\r\n\r\n// File: contracts/storage/MarketplaceStorageExtras.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n// Contracts that need to be deployed for this contract to work:\r\n//    DoublyLinkedList, CoreStorage, MathUtils, TokenTransferController, TokenInfoController,\r\n//    TokenDemurrageService, TokenApprovalController, Token, ContractResolver\r\n\r\ncontract MarketplaceStorageExtras is ResolverClient, DigixConstants, DigixConstantsExtras {\r\n\r\n\r\n  struct User {\r\n    uint256[] dai_purchases;\r\n    mapping(uint256 => bool) is_dai_purchase;\r\n  }\r\n\r\n  address public dai_payment_collector;\r\n  mapping (address => uint256) public eth_signers_minimum_order; // if this is non-zero, the signer is approved and can be used for order size >= the value\r\n  mapping (address => uint256) public dai_signers_minimum_order; // if this is non-zero, the signer is approved and can be used for order size >= the value\r\n  address[] public all_eth_signers;\r\n  address[] public all_dai_signers;\r\n\r\n  uint256[] public all_dai_purchases;  // indexes of all the dai purchases in MarketplaceStorage\r\n  mapping(uint256 => bool) public is_dai_purchase; // mapping of purchaseIndex => whether it is a dai purchase\r\n\r\n  mapping (address => User) users;\r\n\r\n  function MarketplaceStorageExtras(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_STORAGE_MARKETPLACE_EXTRAS, _resolver));\r\n  }\r\n\r\n  function read_total_number_of_dai_purchases()\r\n           public\r\n           constant\r\n           returns (uint256 _total_number_of_dai_purchases)\r\n  {\r\n    _total_number_of_dai_purchases = all_dai_purchases.length;\r\n  }\r\n\r\n  function read_total_number_of_user_dai_purchases(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _total_number_of_user_dai_purchases)\r\n  {\r\n    _total_number_of_user_dai_purchases = users[_user].dai_purchases.length;\r\n  }\r\n\r\n  function read_user_dai_purchase_at_index(address _user, uint256 _index)\r\n           public\r\n           constant\r\n           returns (uint256 _purchase_index)\r\n  {\r\n    _purchase_index = users[_user].dai_purchases[_index];\r\n  }\r\n\r\n  function read_all_eth_signers_count() public constant returns (uint256 _count) {\r\n    _count = all_eth_signers.length;\r\n  }\r\n\r\n  function read_all_dai_signers_count() public constant returns (uint256 _count) {\r\n    _count = all_dai_signers.length;\r\n  }\r\n\r\n  function add_dai_purchase(address _user, uint256 _user_purchase_index, uint256 _global_purchase_index)\r\n           if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    users[_user].dai_purchases.push(_user_purchase_index);\r\n    users[_user].is_dai_purchase[_user_purchase_index] = true;\r\n    all_dai_purchases.push(_global_purchase_index);\r\n    is_dai_purchase[_global_purchase_index] = true;\r\n    _success = true;\r\n  }\r\n\r\n  function update_dai_collector(address _dai_payment_collector)\r\n           if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN_EXTRAS)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    dai_payment_collector = _dai_payment_collector;\r\n    _success = true;\r\n  }\r\n\r\n  function update_eth_signer_minimum_order(address _signer, uint256 _min_order)\r\n           if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN_EXTRAS)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    eth_signers_minimum_order[_signer] = _min_order;\r\n    if (address_not_in_array(_signer, all_eth_signers)) {\r\n      all_eth_signers.push(_signer);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  function update_dai_signer_minimum_order(address _signer, uint256 _min_order)\r\n           if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN_EXTRAS)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    dai_signers_minimum_order[_signer] = _min_order;\r\n    if (address_not_in_array(_signer, all_dai_signers)) {\r\n      all_dai_signers.push(_signer);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  function read_eth_signer_info(address _signer)\r\n           public\r\n           constant\r\n           returns (bool _signer_approved, uint256 _signer_minimum_order)\r\n  {\r\n    _signer_minimum_order = eth_signers_minimum_order[_signer];\r\n    _signer_approved = _signer_minimum_order != 0;\r\n  }\r\n\r\n  function read_dai_signer_info(address _signer)\r\n           public\r\n           constant\r\n           returns (bool _signer_approved, uint256 _signer_minimum_order)\r\n  {\r\n    _signer_minimum_order = dai_signers_minimum_order[_signer];\r\n    _signer_approved = _signer_minimum_order != 0;\r\n  }\r\n\r\n  function address_not_in_array(address _address, address[] _array)\r\n           internal\r\n           pure\r\n           returns (bool _not_in)\r\n  {\r\n    _not_in = true;\r\n    for (uint256 i=0;i<_array.length;i++) {\r\n      if (_array[i] == _address) {\r\n        _not_in = false;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/storage/MarketplaceStorageElectron.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract MarketplaceStorageElectron is ResolverClient, DigixConstants, DigixConstantsExtras, DigixConstantsElectron {\r\n\r\n    struct User {\r\n        uint256 daily_limit;\r\n        uint256 lifetime_limit;\r\n        uint256 lifetime_total_purchased;\r\n        address previous_address;\r\n        address next_address;\r\n    }\r\n\r\n    mapping (address => uint256) public token_of_signer;\r\n    mapping (address => uint256) public min_order_of_signer;\r\n    mapping (address => User) users;\r\n\r\n    // token_payment_collector[token_index] is the payment collector for the token\r\n    mapping (uint256 => address) public token_payment_collector;\r\n    // mapping of purchase_index => what tokenIndex is the token of the purchase\r\n    mapping (uint256 => uint256) token_of_purchase;\r\n    // token 0 is unused (DUMMY)\r\n    // token 1 is reserved for fiat purchases (PayPal, etc.)\r\n    // token 2 is reserved for ETH purchases\r\n    // token 3 is reserved for DAI purchases\r\n    address[] public all_tokens;\r\n    address[] public all_signers;\r\n    uint256 public default_tier1_lifetime_limit;\r\n    uint256 public default_tier1_daily_limit;\r\n    uint256 public default_tier2_daily_limit;\r\n\r\n    function MarketplaceStorageElectron(address _resolver, address _dai_address) public {\r\n        require(init(CONTRACT_STORAGE_MARKETPLACE_ELECTRON, _resolver));\r\n        default_tier2_daily_limit = 110e9;\r\n        default_tier1_daily_limit = 10e9;\r\n        default_tier1_lifetime_limit = 110e9;\r\n        all_tokens.push(0x0); // token_index 0 is a dummy one\r\n        all_tokens.push(0x0); // token_index 1 is for Fiat purchases\r\n        all_tokens.push(0x0); // token_index 2 is for ETH purchases\r\n        all_tokens.push(_dai_address); // token_index 3 is for DAI purchases\r\n    }\r\n\r\n    function marketplace_storage()\r\n        internal\r\n        constant\r\n        returns (MarketplaceStorage _contract)\r\n    {\r\n        _contract = MarketplaceStorage(get_contract(CONTRACT_STORAGE_MARKETPLACE));\r\n    }\r\n\r\n    function marketplace_storage_extras()\r\n        internal\r\n        constant\r\n        returns (MarketplaceStorageExtras _contract)\r\n    {\r\n        _contract = MarketplaceStorageExtras(get_contract(CONTRACT_STORAGE_MARKETPLACE_EXTRAS));\r\n    }\r\n\r\n    function identity_storage()\r\n        internal\r\n        constant\r\n        returns (IdentityStorage _contract)\r\n    {\r\n        _contract = IdentityStorage(get_contract(CONTRACT_STORAGE_IDENTITY));\r\n    }\r\n\r\n    function migrate_users(address[] old_users)\r\n        public\r\n        returns (uint256 processed)\r\n    {\r\n        address user;\r\n        uint256 purchase_count;\r\n        uint256 purchase_amount;\r\n\r\n        for (uint256 i = 0; i < old_users.length; i++) {\r\n            user = old_users[i];\r\n            if (users[user].lifetime_total_purchased == 0 && identity_storage().read_user_kyc_valid(user)) {\r\n                // if this user has no record in Electron, and has a valid KYC, that means it can be migrated\r\n                // what if a user is KYCed to tier2 in Electron, and call this function ? Does it affect anything?\r\n\r\n                purchase_count = marketplace_storage().read_total_number_of_user_purchases(user);\r\n                for (uint purchase_index = 0; purchase_index < purchase_count; purchase_index++) {\r\n                    (,,purchase_amount,) = marketplace_storage().read_user_purchase_at_index(user, purchase_index);\r\n                    users[user].lifetime_total_purchased += purchase_amount;\r\n                }\r\n                (users[user].daily_limit,) = marketplace_storage().read_user(user);\r\n\r\n                processed++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function signers_count()\r\n        public\r\n        constant\r\n        returns (uint256 _count)\r\n    {\r\n        _count = all_signers.length;\r\n    }\r\n\r\n    function tokens_count()\r\n        public\r\n        constant\r\n        returns (uint256 _count)\r\n    {\r\n        _count = all_tokens.length;\r\n    }\r\n\r\n    function read_user(address _user)\r\n        public\r\n        constant\r\n        returns (\r\n            uint256 _lifetime_limit,\r\n            uint256 _daily_limit,\r\n            uint256 _lifetime_total_purchased,\r\n            address _previous_address,\r\n            address _next_address\r\n        )\r\n    {\r\n        _lifetime_limit = users[_user].lifetime_limit;\r\n        _daily_limit = users[_user].daily_limit;\r\n        _lifetime_total_purchased = users[_user].lifetime_total_purchased;\r\n        _previous_address = users[_user].previous_address;\r\n        _next_address = users[_user].next_address;\r\n    }\r\n\r\n    function update_default_daily_limit(uint256 _default_tier1_daily_limit, uint256 _default_tier2_daily_limit)\r\n        if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN_ELECTRON)\r\n        public\r\n    {\r\n        default_tier1_daily_limit = _default_tier1_daily_limit;\r\n        default_tier2_daily_limit = _default_tier2_daily_limit;\r\n    }\r\n\r\n    function update_user_limits(address _user, uint256 _new_lifetime_limit, uint256 _new_daily_limit)\r\n        if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN_ELECTRON)\r\n        public\r\n    {\r\n        users[_user].lifetime_limit = _new_lifetime_limit;\r\n        users[_user].daily_limit = _new_daily_limit;\r\n    }\r\n\r\n    function change_user_address(address _old_user, address _new_user)\r\n        if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN_ELECTRON)\r\n        public\r\n    {\r\n        users[_old_user].next_address = _new_user;\r\n        users[_new_user].previous_address = _old_user;\r\n        users[_new_user].daily_limit = users[_old_user].daily_limit;\r\n        users[_new_user].lifetime_total_purchased = users[_old_user].lifetime_total_purchased;\r\n        users[_new_user].lifetime_limit = users[_old_user].lifetime_limit;\r\n    }\r\n\r\n    function add_purchase(address _user, uint256 _purchase_index, uint256 _token_index, uint256 _amount)\r\n        if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE)\r\n        public\r\n    {\r\n        users[_user].lifetime_total_purchased += _amount;\r\n        token_of_purchase[_purchase_index] = _token_index;\r\n    }\r\n\r\n    function read_token_of_purchase(uint256 _purchase_index)\r\n        public\r\n        constant\r\n        returns (uint256 _token_index)\r\n    {\r\n        _token_index = token_of_purchase[_purchase_index];\r\n        if (marketplace_storage_extras().is_dai_purchase(_purchase_index)) {\r\n            _token_index = TOKEN_INDEX_DAI; // 3 is for Dai\r\n        }\r\n        if (_token_index == 0) {\r\n            // this means it has been an ETH purchase, pre-Electron\r\n            _token_index == TOKEN_INDEX_ETHER;\r\n        }\r\n    }\r\n\r\n    function update_token_collector(uint256 _token_index, address _collector)\r\n        if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN_ELECTRON)\r\n        public\r\n    {\r\n        token_payment_collector[_token_index] = _collector;\r\n    }\r\n\r\n    function add_token(address _token_address)\r\n        if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN_ELECTRON)\r\n        public\r\n    {\r\n        all_tokens.push(_token_address);\r\n    }\r\n\r\n    function update_default_tier1_lifetime_limit(uint256 _new_limit)\r\n        if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN_ELECTRON)\r\n        public\r\n    {\r\n        default_tier1_lifetime_limit = _new_limit;\r\n    }\r\n\r\n    function update_signer(address _signer, uint256 _token_index, uint256 _min_order)\r\n        if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN_ELECTRON)\r\n        public\r\n    {\r\n        require(_token_index > TOKEN_INDEX_FIAT);\r\n        if (token_of_signer[_signer] == 0) {\r\n            all_signers.push(_signer);\r\n        }\r\n        token_of_signer[_signer] = _token_index;\r\n        min_order_of_signer[_signer] = _min_order;\r\n    }\r\n}\r\n\r\n// File: contracts/service/VerificationService.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\ncontract VerificationService is ResolverClient, DigixConstantsElectron  {\r\n\r\n    function VerificationService(address _resolver) public {\r\n        require(init(CONTRACT_SERVICE_VERIFICATION, _resolver));\r\n    }\r\n\r\n    struct Message {\r\n        bytes userAddress;\r\n        bytes kycTier;\r\n        bytes kycExpiry;\r\n        bytes blockNumber;\r\n        bytes price;\r\n    }\r\n\r\n    struct KycMessage {\r\n        bytes userAddress;\r\n        bytes kycTier;\r\n        bytes kycExpiry;\r\n        bytes blockNumber;\r\n    }\r\n\r\n    struct Signature {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n    }\r\n\r\n    function convertToBytes(\r\n        address user_address,\r\n        uint kyc_tier,\r\n        uint kyc_expiry,\r\n        uint block_number,\r\n        uint price\r\n    )\r\n        internal\r\n        pure\r\n        returns (Message)\r\n    {\r\n        return Message(\r\n            addressToBytes(user_address),\r\n            intToBytes(kyc_tier),\r\n            intToBytes(kyc_expiry),\r\n            intToBytes(block_number),\r\n            intToBytes(price)\r\n        );\r\n    }\r\n\r\n    function convertKycMessageToBytes(\r\n        address user_address,\r\n        uint kyc_tier,\r\n        uint kyc_expiry,\r\n        uint block_number\r\n    )\r\n        internal\r\n        pure\r\n        returns (KycMessage)\r\n    {\r\n        return KycMessage(\r\n            addressToBytes(user_address),\r\n            intToBytes(kyc_tier),\r\n            intToBytes(kyc_expiry),\r\n            intToBytes(block_number)\r\n        );\r\n    }\r\n\r\n    function verify_user_kyc(\r\n        address user_address,\r\n        uint kyc_tier,\r\n        uint kyc_expiry,\r\n        uint block_number,\r\n        bytes signature,\r\n        address signer\r\n    )\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        bytes memory delimiter = new bytes(1);\r\n        delimiter[0] = 0x3a;\r\n\r\n        KycMessage memory _m = convertKycMessageToBytes(user_address, kyc_tier, kyc_expiry, block_number);\r\n\r\n        bytes memory lengthBytes = intToBytes(_m.userAddress.length + _m.kycTier.length + _m.kycExpiry.length + _m.blockNumber.length + 4);\r\n\r\n        bytes memory message = concat_bytes(\r\n            concat_bytes(\r\n                concat_bytes(\"\\x19Ethereum Signed Message:\\n\", lengthBytes),\r\n                concat_bytes(delimiter, _m.userAddress)\r\n            ),\r\n            concat_bytes(\r\n                concat_bytes(\r\n                    concat_bytes(delimiter, _m.kycTier),\r\n                    concat_bytes(delimiter, _m.kycExpiry)\r\n                ),\r\n                concat_bytes(delimiter, _m.blockNumber)\r\n            )\r\n        );\r\n\r\n        Signature memory _s = parse_signature(signature);\r\n        return ecrecover(keccak256(message), _s.v, _s.r, _s.s) == signer;\r\n    }\r\n\r\n    function verify_signed_price(\r\n        address user_address,\r\n        uint kyc_tier,\r\n        uint kyc_expiry,\r\n        uint block_number,\r\n        uint price,\r\n        bytes signature,\r\n        address signer\r\n    )\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        bytes memory delimiter = new bytes(1);\r\n        delimiter[0] = 0x3a;\r\n\r\n        Message memory _m = convertToBytes(user_address, kyc_tier, kyc_expiry, block_number, price);\r\n\r\n        bytes memory lengthBytes = intToBytes(_m.userAddress.length + _m.kycTier.length + _m.kycExpiry.length + _m.blockNumber.length + _m.price.length + 5);\r\n\r\n        bytes memory message = concat_bytes(\r\n            concat_bytes(\r\n                concat_bytes(\"\\x19Ethereum Signed Message:\\n\", lengthBytes),\r\n                concat_bytes(\r\n                    concat_bytes(delimiter, _m.userAddress),\r\n                      concat_bytes(delimiter, _m.kycTier)\r\n                )\r\n            ),\r\n            concat_bytes(\r\n                concat_bytes(\r\n                    concat_bytes(delimiter, _m.kycExpiry),\r\n                    concat_bytes(delimiter, _m.blockNumber)\r\n                ),\r\n                concat_bytes(delimiter, _m.price)\r\n            )\r\n        );\r\n\r\n        Signature memory _s = parse_signature(signature);\r\n        return ecrecover(keccak256(message), _s.v, _s.r, _s.s) == signer;\r\n    }\r\n\r\n    function parse_signature(bytes _sigbytes) internal pure returns (Signature) {\r\n        bytes32 _r;\r\n        bytes32 _s;\r\n        uint8 _v;\r\n\r\n        assembly {\r\n            _r := mload(add(_sigbytes, 32))\r\n            _s := mload(add(_sigbytes, 64))\r\n            _v := byte(0, mload(add(_sigbytes, 96)))\r\n        }\r\n        if (_v < 27) {\r\n            _v += 27;\r\n        }\r\n\r\n        require(_v == 27 || _v == 28);\r\n        return Signature(_r, _s, _v);\r\n    }\r\n\r\n    function concat_bytes(bytes b1, bytes b2) internal pure returns (bytes b) {\r\n        b = new bytes(b1.length + b2.length);\r\n\r\n        for (uint i=0; i<b1.length;i++) {\r\n            b[i] = b1[i];\r\n        }\r\n        for (i=0; i<b2.length; i++) {\r\n            b[i + b1.length] = b2[i];\r\n        }\r\n    }\r\n\r\n    function addressToBytes(address a) internal pure returns (bytes result) {\r\n        bytes32 temp = bytes32(a);\r\n        result = new bytes(40);\r\n        for (uint i=0;i<20;i++) {\r\n            result[i*2] = hexToChar(uint8(temp[12+i]) / 16);\r\n            result[i*2+1] = hexToChar(uint8(temp[12+i]) % 16);\r\n        }\r\n    }\r\n\r\n    function hexToChar(uint8 hexadecimal) internal pure returns (byte c) {\r\n        if (hexadecimal >= 10) {\r\n            c = byte(hexadecimal + 97 - 10); // 97 = 'a'\r\n        } else {\r\n            c = byte(hexadecimal + 48); // 48 = '0'\r\n        }\r\n    }\r\n\r\n    function intToBytes(uint256 number) internal pure returns (bytes result) {\r\n        require(number > 0);\r\n        bytes memory fullString = new bytes(32);\r\n        uint l = 0;\r\n        while (number != 0) {\r\n            fullString[l++] = byte(number % 10 + 48);\r\n            number = number / 10;\r\n        }\r\n\r\n        result = new bytes(l);\r\n\r\n        for (uint i=0;i<l;i++) {\r\n            result[i] = fullString[l-i-1];\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/controller/IdentityController.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\ncontract IdentityController is Controller {\r\n\r\n  function IdentityController(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_CONTROLLER_IDENTITY, _resolver));\r\n  }\r\n\r\n  function put_user_kyc_approve(address _caller, address _user, uint256 _id_expiration, uint256 _daily_dgx_ng_limit)\r\n           if_sender_is(CONTRACT_INTERACTIVE_IDENTITY)\r\n           if_caller_is_role(_caller, ROLE_KYC_ADMIN)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = marketplace_storage().create_user(_user, _daily_dgx_ng_limit);\r\n    _success = _success && identity_storage().update_user_id_expiration(_user, _id_expiration);\r\n  }\r\n\r\n  function put_user_kyc_revoke(address _caller, address _user)\r\n           if_sender_is(CONTRACT_INTERACTIVE_IDENTITY)\r\n           if_caller_is_role(_caller, ROLE_KYC_ADMIN)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = marketplace_storage().create_user(_user, 0);\r\n    _success = _success && identity_storage().update_user_id_expiration(_user, now);\r\n  }\r\n\r\n  function put_user_doc(address _caller, address _user, bytes32 _doc)\r\n           if_sender_is(CONTRACT_INTERACTIVE_IDENTITY)\r\n           if_caller_is_role(_caller, ROLE_KYC_ADMIN)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = identity_storage().update_user_doc(_user, _doc);\r\n  }\r\n}\r\n\r\n// File: contracts/interactive/Identity.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n\r\n/// @title User KYC information\r\n/// @author Digix Holdings Pte Ltd\r\n/// @notice Use this contract for interactive functions to update to or read information regarding user KYCs\r\ncontract Identity is ResolverClient, DigixConstants {\r\n\r\n  function Identity(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_INTERACTIVE_IDENTITY, _resolver));\r\n  }\r\n\r\n  function identity_controller()\r\n           internal\r\n           constant\r\n           returns (IdentityController _contract)\r\n  {\r\n    _contract = IdentityController(get_contract(CONTRACT_CONTROLLER_IDENTITY));\r\n  }\r\n\r\n  function identity_storage()\r\n           internal\r\n           constant\r\n           returns (IdentityStorage _contract)\r\n  {\r\n    _contract = IdentityStorage(get_contract(CONTRACT_STORAGE_IDENTITY));\r\n  }\r\n\r\n  function approveKyc(address _caller, address _user, uint256 _id_expiration, uint256 _daily_dgx_ng_limit)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = identity_controller().put_user_kyc_approve(_caller, _user, _id_expiration, _daily_dgx_ng_limit);\r\n  }\r\n\r\n  /// @dev approve kyc of users in bulk\r\n  /// @param _users addresses of users\r\n  /// @return _success true if successfully approved, throw otherwise\r\n  function bulkApproveKyc(address[] _users, uint256[] _id_expirations, uint256[] _daily_dgx_ng_limits)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    address _caller = msg.sender;\r\n    uint256 length = _users.length;\r\n    for (uint256 i = 0; i < length; i += 1) {\r\n      require(approveKyc(_caller, _users[i], _id_expirations[i], _daily_dgx_ng_limits[i]));\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  function revokeKyc(address _caller, address _user)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = identity_controller().put_user_kyc_revoke(_caller, _user);\r\n  }\r\n\r\n  /// @dev revoke kyc of users in bulk\r\n  /// @param _users addresses of users\r\n  /// @return _success true if successfully revoked, throw otherwise\r\n  function bulkRevokeKyc(address[] _users)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    uint256 length = _users.length;\r\n    address _caller = msg.sender;\r\n    for (uint256 i = 0; i < length; i += 1) {\r\n      require(revokeKyc(_caller, _users[i]));\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  function changeUserDoc(address _caller, address _user, bytes32 _doc)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = identity_controller().put_user_doc(_caller, _user, _doc);\r\n  }\r\n\r\n  /// @dev change KYC documents of users in bulk\r\n  /// @param _users addresses of users\r\n  /// @param _docs IPFS hashes of KYC documents\r\n  /// @return _success true if docs added successfully, throw otherwise\r\n  function bulkChangeUserDoc(address[] _users, bytes32[] _docs)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    uint256 length = _users.length;\r\n    address _caller = msg.sender;\r\n    for (uint256 i = 0; i < length; i += 1) {\r\n      require(changeUserDoc(_caller, _users[i], _docs[i]));\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  /// @dev show user KYC information\r\n  /// @param _user address of the user\r\n  /// @return {\r\n  ///   \"_id_expiration\": \"expiry time of the user's KYC status\",\r\n  ///   \"_doc\": \"IPFS hash of any information linked to user's KYC\"\r\n  /// }\r\n  function showUser(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _id_expiration, bytes32 _doc)\r\n  {\r\n    (_id_expiration, _doc) = identity_storage().read_user(_user);\r\n  }\r\n\r\n  /// @dev check if user KYC is valid\r\n  /// @param _user address of user\r\n  /// @return _valid_kyc true if user has valid KYC, otherwise false\r\n  function checkUserKyc(address _user)\r\n           public\r\n           constant\r\n           returns (bool _valid_kyc)\r\n  {\r\n    _valid_kyc = identity_storage().read_user_kyc_valid(_user);\r\n  }\r\n}\r\n\r\n// File: contracts/controller_electron/MarketplaceControllerElectron.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n/// @title DigixCore Marketplace Controller\r\n/// @author DigixGlobal Pte Ltd\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract MarketplaceControllerElectron is MarketplaceControllerCommon, DigixConstantsExtras, DigixConstantsElectron {\r\n\r\n    function MarketplaceControllerElectron(address _resolver) public\r\n    {\r\n        require(init(CONTRACT_CONTROLLER_MARKETPLACE, _resolver));\r\n    }\r\n\r\n    struct UintData {\r\n        uint256 pre;\r\n        uint256 post;\r\n    }\r\n\r\n    struct Config {\r\n        uint256 minimum_purchase_dgx_ng;\r\n        uint256 maximum_block_drift;\r\n        address eth_payment_collector;\r\n        address token_payment_collector;\r\n\r\n        uint256 max_dgx_available_daily;\r\n        uint256 price_floor_wei_per_dgx_mg;\r\n    }\r\n\r\n    struct Verification {\r\n        uint256 token_of_signer;\r\n        uint256 signer_min_order;\r\n    }\r\n\r\n    struct Purchase {\r\n        uint256 amount_dgx_ng;\r\n        uint256 token_index;\r\n        User buyer;\r\n        Verification verification;\r\n        Config config;\r\n        uint256 payment_sent;\r\n        uint256 price;\r\n        uint256 block_number;\r\n        address signer;\r\n        bytes signature;\r\n    }\r\n\r\n    struct User {\r\n        address account;\r\n        uint256 kyc_tier;\r\n        uint256 kyc_expiry;\r\n        uint256 total_purchased_today;\r\n        uint256 lifetime_limit;\r\n        uint256 daily_limit;\r\n        uint256 lifetime_total_purchased;\r\n        address next_address;\r\n    }\r\n\r\n    function marketplace_storage_electron()\r\n        internal\r\n        constant\r\n        returns (MarketplaceStorageElectron _contract)\r\n    {\r\n        _contract = MarketplaceStorageElectron(get_contract(CONTRACT_STORAGE_MARKETPLACE_ELECTRON));\r\n    }\r\n\r\n    function verification_service()\r\n        internal\r\n        constant\r\n        returns (VerificationService _contract)\r\n    {\r\n        _contract = VerificationService(get_contract(CONTRACT_SERVICE_VERIFICATION));\r\n    }\r\n\r\n    function identity()\r\n        internal\r\n        constant\r\n        returns (Identity _contract)\r\n    {\r\n        _contract = Identity(get_contract(CONTRACT_INTERACTIVE_IDENTITY));\r\n    }\r\n\r\n    function token_contract(uint256 _token_index)\r\n        internal\r\n        constant\r\n        returns (ERCTwenty _token_contract)\r\n    {\r\n        _token_contract = ERCTwenty(marketplace_storage_electron().all_tokens(_token_index));\r\n    }\r\n\r\n\r\n    function purchase_with_eth(\r\n        uint256 _wei_sent,\r\n        address _buyer,\r\n        uint256 _kyc_tier,\r\n        uint256 _kyc_expiry,\r\n        uint256 _block_number,\r\n        uint256 _wei_per_dgx_mg,\r\n        address _signer,\r\n        bytes _signature\r\n    )\r\n        if_sender_is(CONTRACT_INTERACTIVE_MARKETPLACE_ELECTRON)\r\n        payable\r\n        public\r\n        returns (bool _success, uint256 _purchased_amount)\r\n    {\r\n        _purchased_amount = process_purchase_onchain(\r\n            _wei_sent,\r\n            _buyer,\r\n            _kyc_tier,\r\n            _kyc_expiry,\r\n            _block_number,\r\n            _wei_per_dgx_mg,\r\n            _signer,\r\n            TOKEN_INDEX_ETHER,\r\n            _signature\r\n        );\r\n        _success = true;\r\n    }\r\n\r\n    function purchase_with_token(\r\n        uint256 _tokens_sent,\r\n        address _buyer,\r\n        uint256 _kyc_tier,\r\n        uint256 _kyc_expiry,\r\n        uint256 _block_number,\r\n        uint256 _token_per_1000ton,\r\n        address _signer,\r\n        uint256 _token_index,\r\n        bytes _signature\r\n    )\r\n        if_sender_is(CONTRACT_INTERACTIVE_MARKETPLACE_ELECTRON)\r\n        public\r\n        returns (bool _success, uint256 _purchased_amount)\r\n    {\r\n        // Before calling this, user needs to approve this MarketplaceControllerElectron contract to withdraw the ERC20 token\r\n        require(token_contract(_token_index).allowance(_buyer, address(this)) >= _tokens_sent);\r\n        require(_token_index != TOKEN_INDEX_FIAT); // must not be a fiat purchase\r\n\r\n        _purchased_amount = process_purchase_onchain(\r\n            _tokens_sent,\r\n            _buyer,\r\n            _kyc_tier,\r\n            _kyc_expiry,\r\n            _block_number,\r\n            _token_per_1000ton,\r\n            _signer,\r\n            _token_index,\r\n            _signature\r\n        );\r\n        _success = true;\r\n    }\r\n\r\n    // to be called by ROLE_ELECTRON_MARKETPLACE_ADMIN to confirm a user purchase using fiat\r\n    function add_purchase_with_fiat(\r\n        address _caller,\r\n        address _buyer,\r\n        uint256 _kyc_tier,\r\n        uint256 _kyc_expiry,\r\n        uint256 _amount_dgx_ng\r\n    )\r\n        if_sender_is(CONTRACT_INTERACTIVE_MARKETPLACE_ELECTRON)\r\n        if_caller_is_role(_caller, ROLE_ELECTRON_MARKETPLACE_ADMIN)\r\n        public\r\n    {\r\n        Purchase memory _purchase = get_basic_purchase_object(_buyer, _kyc_tier, _kyc_expiry, TOKEN_INDEX_FIAT);\r\n        _purchase.amount_dgx_ng = _amount_dgx_ng;\r\n\r\n        Purchase memory _processed;\r\n        _processed = verify_purchase_limits(_purchase);\r\n        update_purchase_in_storages(_processed);\r\n    }\r\n\r\n    function process_purchase_onchain(\r\n        uint256 _payment_sent,\r\n        address _buyer,\r\n        uint256 _kyc_tier,\r\n        uint256 _kyc_expiry,\r\n        uint256 _block_number,\r\n        uint256 _price,\r\n        address _signer,\r\n        uint256 _token_index,\r\n        bytes _signature\r\n    )\r\n        internal\r\n        returns (uint256 _purchase_amount)\r\n    {\r\n        // get basic common information required for all purchase types\r\n        Purchase memory _purchase = get_basic_purchase_object(_buyer, _kyc_tier, _kyc_expiry, _token_index);\r\n\r\n        // more information that will only be required for\r\n        // purchases done using ETH or ERC-20 tokens\r\n        _purchase.payment_sent = _payment_sent;\r\n        _purchase.price = _price;\r\n        _purchase.block_number = _block_number;\r\n        _purchase.signer = _signer;\r\n        _purchase.signature = _signature;\r\n\r\n        // get information about the price signer\r\n        _purchase.verification.token_of_signer = marketplace_storage_electron().token_of_signer(_signer);\r\n        _purchase.verification.signer_min_order = marketplace_storage_electron().min_order_of_signer(_signer);\r\n\r\n        if (_token_index > TOKEN_INDEX_ETHER) {\r\n            // amount is:  (amount of tokens * 10^18) / (token_per_1000_ton * 1000_TON_TO_NG_which_is_10^18)\r\n            // if this ERC-20 token doesn't have 18 decimal places, then we take care of that by\r\n            // taking the ratio of (10^18 / 10^(decimals_in_that_token))\r\n            // (for instance, USDT has only 6 decimal places)\r\n            // which is actually:  (amount of tokens) / (token_per_1000_ton)\r\n            _purchase.amount_dgx_ng = (_purchase.payment_sent * (10 ** 18)) / (_purchase.price * (10 ** token_contract(_token_index).decimals()));\r\n        } else {\r\n            // amount is the wei_sent * MILLIGRAM_TO_NANOGRAMS / (price in terms of wei_per_dgx_mg)\r\n            _purchase.amount_dgx_ng = (_purchase.payment_sent * MILLIGRAM_TO_NANOGRAMS) / _purchase.price;\r\n            _purchase.config.price_floor_wei_per_dgx_mg = marketplace_storage().read_price_floor();\r\n            require(_purchase.price >= _purchase.config.price_floor_wei_per_dgx_mg);\r\n        }\r\n\r\n        Purchase memory _processed;\r\n\r\n        // verifies purchase limits as well as KYC information\r\n        _processed = verify_purchase_limits(verify_purchase_onchain(_purchase));\r\n\r\n        // update information in the storage contracts\r\n        update_purchase_in_storages(_processed);\r\n\r\n        if (_token_index > TOKEN_INDEX_ETHER) {\r\n            // this is a token purchase\r\n            _purchase.config.token_payment_collector = marketplace_storage_electron().token_payment_collector(_token_index);\r\n            require(\r\n                token_contract(_token_index)\r\n                .transferFrom(\r\n                    _purchase.buyer.account,\r\n                    _purchase.config.token_payment_collector,\r\n                    _purchase.payment_sent\r\n                )\r\n            );\r\n        } else {\r\n            // this is an ETH purchase\r\n            _processed.config.eth_payment_collector.transfer(_purchase.payment_sent);\r\n        }\r\n\r\n        _purchase_amount = _purchase.amount_dgx_ng;\r\n    }\r\n\r\n    function get_basic_purchase_object(address _buyer, uint256 _kyc_tier, uint256 _kyc_expiry, uint256 _token_index)\r\n        internal\r\n        constant\r\n        returns (Purchase memory)\r\n    {\r\n        // common information required to be checked for all kinds of purchases\r\n        Purchase memory _purchase;\r\n        (, _purchase.config.minimum_purchase_dgx_ng, _purchase.config.maximum_block_drift, _purchase.config.eth_payment_collector) = marketplace_storage().read_config();\r\n        _purchase.config.max_dgx_available_daily = marketplace_storage().read_max_dgx_available_daily();\r\n        _purchase.buyer.account = _buyer;\r\n        _purchase.buyer.kyc_tier = _kyc_tier;\r\n        _purchase.buyer.kyc_expiry = _kyc_expiry;\r\n        _purchase.token_index = _token_index;\r\n        return _purchase;\r\n    }\r\n\r\n    function update_purchase_in_storages(Purchase memory _processed)\r\n        internal\r\n    {\r\n        // update the marketplace storage contract\r\n        require(marketplace_storage().update_user_purchase(\r\n            _processed.buyer.account,\r\n            _processed.buyer.account,\r\n            _processed.amount_dgx_ng,\r\n            _processed.price,\r\n            _processed.block_number,\r\n            DUMMY_NONCE)\r\n        );\r\n\r\n        // update the marketplace storage electron contract\r\n        // this contract stores information regarding which token was used\r\n        // for the purchase, and updates the buyer's information\r\n        marketplace_storage_electron().add_purchase(\r\n            _processed.buyer.account,\r\n            marketplace_storage().read_total_number_of_purchases() - 1,\r\n            _processed.token_index,\r\n            _processed.amount_dgx_ng\r\n        );\r\n    }\r\n\r\n    function verify_purchase_onchain(Purchase memory _purchase)\r\n        internal\r\n        constant\r\n        returns (Purchase memory _processed)\r\n    {\r\n        _processed = _purchase;\r\n\r\n        // the pricefeed signer should be a valid signer for the purchase token\r\n        require(_purchase.verification.token_of_signer == _purchase.token_index);\r\n        // the number of DGX bought should be greater than the minimum DGX for the signer's price level\r\n        require(_purchase.amount_dgx_ng >= _purchase.verification.signer_min_order);\r\n\r\n        // verify all arguments of the signed pricefeed\r\n        require(\r\n            verification_service().verify_signed_price(\r\n                _purchase.buyer.account,\r\n                _purchase.buyer.kyc_tier,\r\n                _purchase.buyer.kyc_expiry,\r\n                _purchase.block_number,\r\n                _purchase.price,\r\n                _purchase.signature,\r\n                _purchase.signer\r\n            )\r\n        );\r\n\r\n        // the current block number should be within the threshold\r\n        require((_processed.block_number + _purchase.config.maximum_block_drift) >= block.number);\r\n    }\r\n\r\n    function verify_purchase_limits(Purchase memory _purchase)\r\n        internal\r\n        constant\r\n        returns (Purchase memory _processed)\r\n    {\r\n        _processed = _purchase;\r\n\r\n        // collect information about the user's limits\r\n        (\r\n            ,, _processed.buyer.lifetime_total_purchased,\r\n            , _processed.buyer.next_address\r\n        ) = marketplace_storage_electron().read_user(_processed.buyer.account);\r\n        (,_processed.buyer.total_purchased_today) = marketplace_storage().read_user(_processed.buyer.account);\r\n\r\n        // get user's limits depending on the tier. Note that Kyc valid = tier 2, not valid = tier 1\r\n        (_processed.buyer.daily_limit, _processed.buyer.lifetime_limit) = get_user_limits(\r\n            _processed.buyer.account,\r\n            _processed.buyer.kyc_tier,\r\n            _processed.buyer.kyc_expiry\r\n        );\r\n\r\n        // the user should be either in tier 1 (with additional checks on limits)\r\n        // or any upper kyc tier with an expiry beyond time now\r\n        require(\r\n            (_processed.buyer.kyc_tier == 1) ||\r\n            (_processed.buyer.kyc_expiry > now)\r\n        );\r\n        // including this purchase, the total DGXs purchased today should be within max available for purchase daily\r\n        require(marketplace_storage().read_total_global_purchased_today() + _processed.amount_dgx_ng <= _processed.config.max_dgx_available_daily);\r\n        // number of DGXs to be purchased should be more than the minimum purchase amount\r\n        require(_processed.amount_dgx_ng >= _processed.config.minimum_purchase_dgx_ng);\r\n        // including this purchase, the total DGXs purchased today by this user should be within their daily purchase limits\r\n        require((_processed.buyer.total_purchased_today + _processed.amount_dgx_ng) <= _processed.buyer.daily_limit);\r\n        // including this purchase, the total DGXs purchased by this user should be within their lifetime purchase limits\r\n        require((_processed.buyer.lifetime_total_purchased + _processed.amount_dgx_ng) <= _processed.buyer.lifetime_limit);\r\n        // This user address must not have been replaced\r\n        require(_processed.buyer.next_address == address(0x0));\r\n    }\r\n\r\n    function get_user_limits(address _user, uint256 _kyc_tier, uint256 _kyc_expiry)\r\n        public\r\n        constant\r\n        returns (\r\n            uint256 _daily_limit,\r\n            uint256 _lifetime_limit\r\n        )\r\n    {\r\n        // get DGX purchase limits for this user\r\n        (\r\n            _lifetime_limit,\r\n            _daily_limit,,,\r\n        ) = marketplace_storage_electron().read_user(_user);\r\n\r\n        // check if user KYC is valid\r\n        bool _valid_kyc = ((_kyc_tier > 1) && (_kyc_expiry > now));\r\n\r\n        if (!_valid_kyc) {\r\n            // if the user is in tier 1\r\n            _daily_limit = max(_daily_limit, marketplace_storage_electron().default_tier1_daily_limit());\r\n            _lifetime_limit = max(_lifetime_limit, marketplace_storage_electron().default_tier1_lifetime_limit());\r\n        } else {\r\n            // this user is in tier 2\r\n            _daily_limit = max(_daily_limit, marketplace_storage_electron().default_tier2_daily_limit());\r\n            _lifetime_limit = MAX_INTEGER;\r\n        }\r\n    }\r\n\r\n    function max(uint a, uint b)\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        if (a < b) {\r\n            return b;\r\n        }\r\n        return a;\r\n    }\r\n}\r\n\r\n// File: contracts/interactive_electron/MarketplaceElectron.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n/// @title Digix's Marketplace\r\n/// @author Digix Holdings Pte Ltd\r\n/// @notice This contract is for KYC-approved users to purchase DGX using ETH\r\ncontract MarketplaceElectron is MarketplaceCommon, DigixConstantsElectron {\r\n\r\n    function MarketplaceElectron(address _resolver) public\r\n    {\r\n        require(init(CONTRACT_INTERACTIVE_MARKETPLACE_ELECTRON, _resolver));\r\n    }\r\n\r\n    function marketplace_controller_electron()\r\n        internal\r\n        constant\r\n        returns (MarketplaceControllerElectron _contract)\r\n    {\r\n        _contract = MarketplaceControllerElectron(get_contract(CONTRACT_CONTROLLER_MARKETPLACE));\r\n    }\r\n\r\n    function marketplace_storage_electron()\r\n        internal\r\n        constant\r\n        returns (MarketplaceStorageElectron _contract)\r\n    {\r\n        _contract = MarketplaceStorageElectron(get_contract(CONTRACT_STORAGE_MARKETPLACE_ELECTRON));\r\n    }\r\n\r\n    function token_contract()\r\n        internal\r\n        constant\r\n        returns (ERCTwenty _contract)\r\n    {\r\n        _contract = ERCTwenty(get_contract(CONTRACT_INTERACTIVE_TOKEN));\r\n    }\r\n\r\n    /// @dev purchase DGX gold using ETH\r\n    /// @param _kyc_tier KYC tier of the user\r\n    /// @param _kyc_expiry KYC expiry of the user\r\n    /// @param _block_number Block number from DTPO (Digix Trusted Price Oracle)\r\n    /// @param _wei_per_dgx_mg Price in wei for one milligram of DGX\r\n    /// @param _signer Address of the DTPO signer\r\n    /// @param _signature Signature of the payload\r\n    /// @return {\r\n    ///   \"_success\": \"returns true if operation is successful\",\r\n    ///   \"_purchased_amount\": \"DGX nanograms received\"\r\n    /// }\r\n    function purchaseWithEth(\r\n        uint256 _kyc_tier,\r\n        uint256 _kyc_expiry,\r\n        uint256 _block_number,\r\n        uint256 _wei_per_dgx_mg,\r\n        address _signer,\r\n        bytes _signature\r\n    )\r\n        payable\r\n        public\r\n        returns (bool _success, uint256 _purchased_amount)\r\n    {\r\n        address _sender = msg.sender;\r\n\r\n        (_success, _purchased_amount) = marketplace_controller_electron()\r\n            .purchase_with_eth\r\n            .value(msg.value)(\r\n                msg.value,\r\n                _sender,\r\n                _kyc_tier,\r\n                _kyc_expiry,\r\n                _block_number,\r\n                _wei_per_dgx_mg,\r\n                _signer,\r\n                _signature\r\n            );\r\n\r\n        require(_success);\r\n    }\r\n\r\n    /// @dev purchase DGX gold using erc20 tokens\r\n    /// @param _tokens_sent amount of erc20 tokens sent\r\n    /// @param _kyc_tier KYC tier of the buyer\r\n    /// @param _kyc_expiry KYC expiry (UTC timestamp in seconds) of the buyer\r\n    /// @param _block_number Block number from DTPO (Digix Trusted Price Oracle)\r\n    /// @param _token_per_1000ton Price in dai for one ton of DGX\r\n    /// @param _signer Address of the DTPO signer\r\n    /// @param _token_index Index of the ERC-20 paid with\r\n    /// @param _signature Signature of the payload\r\n    /// @return {\r\n    ///   \"_success\": \"returns true if operation is successful\",\r\n    ///   \"_purchased_amount\": \"DGX nanograms received\"\r\n    /// }\r\n    function purchaseWithToken(\r\n        uint256 _tokens_sent,\r\n        uint256 _kyc_tier,\r\n        uint256 _kyc_expiry,\r\n        uint256 _block_number,\r\n        uint256 _token_per_1000ton,\r\n        address _signer,\r\n        uint256 _token_index,\r\n        bytes _signature\r\n    )\r\n        public\r\n        returns (bool _success, uint256 _purchased_amount)\r\n    {\r\n        address _sender = msg.sender;\r\n\r\n        (_success, _purchased_amount) =\r\n            marketplace_controller_electron().purchase_with_token(\r\n                _tokens_sent,\r\n                _sender,\r\n                _kyc_tier,\r\n                _kyc_expiry,\r\n                _block_number,\r\n                _token_per_1000ton,\r\n                _signer,\r\n                _token_index,\r\n                _signature\r\n            );\r\n\r\n        require(_success);\r\n    }\r\n\r\n    /// @dev purchase DGX gold using fiat methods\r\n    ///      verification is done in one of the servers\r\n    ///      this method is supposed to be called by a key with designated role\r\n    /// @param _buyer Ethereum address of the user who has made the fiat purchase\r\n    /// @param _kyc_tier KYC tier of the user\r\n    /// @param _kyc_expiry KYC expiry of the user\r\n    /// @param _amount_dgx_ng nanograms of DGX purchased by the user\r\n    function addFiatPurchase(\r\n        address _buyer,\r\n        uint256 _kyc_tier,\r\n        uint256 _kyc_expiry,\r\n        uint256 _amount_dgx_ng\r\n    )\r\n        public\r\n    {\r\n        marketplace_controller_electron().add_purchase_with_fiat(msg.sender, _buyer, _kyc_tier, _kyc_expiry, _amount_dgx_ng);\r\n    }\r\n\r\n    /// @dev get purchase limits for a buyer\r\n    /// @param _buyer ethereum address of user who wants to buy DGX\r\n    /// @param _kyc_tier kyc tier of the buyer\r\n    /// @param _kyc_expiry kyc expiry of the buyer\r\n    /// @return {\r\n    ///   \"_daily_limit\": \"\"\r\n    ///   \"_lifetime_limit\": \"\"\r\n    ///   \"_purchased_today\": \"\"\r\n    ///   \"_purchased_lifetime\": \"\"\r\n    ///   \"_marketplace_balance\": \"\"\r\n    ///   \"_marketplace_daily_limit\": \"\"\r\n    ///   \"_minimum_purchase_amount\": \"\"\r\n    /// }\r\n    function getPurchaseLimits(\r\n        address _buyer,\r\n        uint256 _kyc_tier,\r\n        uint256 _kyc_expiry\r\n    )\r\n        public\r\n        returns (\r\n            uint256 _daily_limit,\r\n            uint256 _lifetime_limit,\r\n            uint256 _purchased_today,\r\n            uint256 _purchased_lifetime,\r\n            uint256 _marketplace_balance,\r\n            uint256 _marketplace_daily_limit,\r\n            uint256 _minimum_purchase_amount,\r\n            uint256 _maximum_block_drift\r\n        )\r\n    {\r\n        (_daily_limit, _lifetime_limit) = marketplace_controller_electron().get_user_limits(_buyer, _kyc_tier, _kyc_expiry);\r\n        (, _purchased_today) = marketplace_storage().read_user(_buyer);\r\n        (,, _purchased_lifetime,,) = marketplace_storage_electron().read_user(_buyer);\r\n        _marketplace_balance = token_contract().balanceOf(get_contract(CONTRACT_STORAGE_MARKETPLACE));\r\n        (_marketplace_daily_limit, _minimum_purchase_amount, _maximum_block_drift,) = marketplace_storage().read_config();\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kyc_tier\",\"type\":\"uint256\"},{\"name\":\"_kyc_expiry\",\"type\":\"uint256\"},{\"name\":\"_block_number\",\"type\":\"uint256\"},{\"name\":\"_wei_per_dgx_mg\",\"type\":\"uint256\"},{\"name\":\"_signer\",\"type\":\"address\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"purchaseWithEth\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"},{\"name\":\"_purchased_amount\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_kyc_tier\",\"type\":\"uint256\"},{\"name\":\"_kyc_expiry\",\"type\":\"uint256\"}],\"name\":\"getPurchaseLimits\",\"outputs\":[{\"name\":\"_daily_limit\",\"type\":\"uint256\"},{\"name\":\"_lifetime_limit\",\"type\":\"uint256\"},{\"name\":\"_purchased_today\",\"type\":\"uint256\"},{\"name\":\"_purchased_lifetime\",\"type\":\"uint256\"},{\"name\":\"_marketplace_balance\",\"type\":\"uint256\"},{\"name\":\"_marketplace_daily_limit\",\"type\":\"uint256\"},{\"name\":\"_minimum_purchase_amount\",\"type\":\"uint256\"},{\"name\":\"_maximum_block_drift\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_kyc_tier\",\"type\":\"uint256\"},{\"name\":\"_kyc_expiry\",\"type\":\"uint256\"},{\"name\":\"_amount_dgx_ng\",\"type\":\"uint256\"}],\"name\":\"addFiatPurchase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"key\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"get_contract\",\"outputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"is_contract\",\"outputs\":[{\"name\":\"_is_contract\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens_sent\",\"type\":\"uint256\"},{\"name\":\"_kyc_tier\",\"type\":\"uint256\"},{\"name\":\"_kyc_expiry\",\"type\":\"uint256\"},{\"name\":\"_block_number\",\"type\":\"uint256\"},{\"name\":\"_token_per_1000ton\",\"type\":\"uint256\"},{\"name\":\"_signer\",\"type\":\"address\"},{\"name\":\"_token_index\",\"type\":\"uint256\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"purchaseWithToken\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"},{\"name\":\"_purchased_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_resolver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"MarketplaceElectron","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000db2ddb220b8a55e0e4412130e6ae74d136c04ba2","Library":"","LicenseType":"BSD-3-Clause","SwarmSource":"bzzr://86ca56802be5f4414d0be2c708f3fb10e2f9c88301bc5c28583434193055f861"}]}