{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/commons/SigUtils.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\nlibrary SigUtils {\r\n    /**\r\n      @dev Recovers address who signed the message \r\n      @param _hash operation ethereum signed message hash\r\n      @param _signature message `hash` signature  \r\n    */\r\n    function ecrecover2 (\r\n        bytes32 _hash, \r\n        bytes memory _signature\r\n    ) internal pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        assembly {\r\n            r := mload(add(_signature, 32))\r\n            s := mload(add(_signature, 64))\r\n            v := and(mload(add(_signature, 65)), 255)\r\n        }\r\n\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        return ecrecover(\r\n            _hash,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/Marmo.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\n/*\r\n    Marmo wallet\r\n\r\n    It has a signer, and it accepts signed messages ´Intents´ (Meta-Txs)\r\n    all messages are composed by an interpreter and a ´data´ field.\r\n*/\r\ncontract Marmo {\r\n    event Relayed(bytes32 indexed _id, address _implementation, bytes _data);\r\n    event Canceled(bytes32 indexed _id);\r\n\r\n    // Random Invalid signer address\r\n    // Intents signed with this address are invalid\r\n    address private constant INVALID_ADDRESS = address(0x9431Bab00000000000000000000000039bD955c9);\r\n\r\n    // Random slot to store signer\r\n    bytes32 private constant SIGNER_SLOT = keccak256(\"marmo.wallet.signer\");\r\n\r\n    // [1 bit (canceled) 95 bits (block) 160 bits (relayer)]\r\n    mapping(bytes32 => bytes32) private intentReceipt;\r\n\r\n    function() external payable {}\r\n\r\n    // Inits the wallet, any address can Init\r\n    // it must be called using another contract\r\n    function init(address _signer) external payable {\r\n        address signer;\r\n        bytes32 signerSlot = SIGNER_SLOT;\r\n        assembly { signer := sload(signerSlot) }\r\n        require(signer == address(0), \"Signer already defined\");\r\n        assembly { sstore(signerSlot, _signer) }\r\n    }\r\n\r\n    // Signer of the Marmo wallet\r\n    // can perform transactions by signing Intents\r\n    function signer() public view returns (address _signer) {\r\n        bytes32 signerSlot = SIGNER_SLOT;\r\n        assembly { _signer := sload(signerSlot) }\r\n    } \r\n\r\n    // Address that relayed the `_id` intent\r\n    // address(0) if the intent was not relayed\r\n    function relayedBy(bytes32 _id) external view returns (address _relayer) {\r\n        (,,_relayer) = _decodeReceipt(intentReceipt[_id]);\r\n    }\r\n\r\n    // Block when the intent was relayed\r\n    // 0 if the intent was not relayed\r\n    function relayedAt(bytes32 _id) external view returns (uint256 _block) {\r\n        (,_block,) = _decodeReceipt(intentReceipt[_id]);\r\n    }\r\n\r\n    // True if the intent was canceled\r\n    // An executed intent can't be canceled and\r\n    // a Canceled intent can't be executed\r\n    function isCanceled(bytes32 _id) external view returns (bool _canceled) {\r\n        (_canceled,,) = _decodeReceipt(intentReceipt[_id]);\r\n    }\r\n\r\n    // Relay a signed intent\r\n    //\r\n    // The implementation receives data containing the id of the 'intent' and its data,\r\n    // and it will perform all subsequent calls.\r\n    //\r\n    // The same _implementation and _data combination can only be relayed once\r\n    //\r\n    // Returns the result of the 'delegatecall' execution\r\n    function relay(\r\n        address _implementation,\r\n        bytes calldata _data,\r\n        bytes calldata _signature\r\n    ) external payable returns (\r\n        bytes memory result\r\n    ) {\r\n        // Calculate ID from\r\n        // (this, _implementation, data)\r\n        // Any change in _data results in a different ID\r\n        bytes32 id = keccak256(\r\n            abi.encodePacked(\r\n                address(this),\r\n                _implementation,\r\n                keccak256(_data)\r\n            )\r\n        );\r\n\r\n        // Read receipt only once\r\n        // if the receipt is 0, the Intent was not canceled or relayed\r\n        if (intentReceipt[id] != bytes32(0)) {\r\n            // Decode the receipt and determine if the Intent was canceled or relayed\r\n            (bool canceled, , address relayer) = _decodeReceipt(intentReceipt[id]);\r\n            require(relayer == address(0), \"Intent already relayed\");\r\n            require(!canceled, \"Intent was canceled\");\r\n            revert(\"Unknown error\");\r\n        }\r\n\r\n        // Read the signer from storage, avoid multiples 'sload' ops\r\n        address _signer = signer();\r\n\r\n        // The signer 'INVALID_ADDRESS' is considered invalid and it will always throw\r\n        // this is meant to disable the wallet safely\r\n        require(_signer != INVALID_ADDRESS, \"Signer is not a valid address\");\r\n\r\n        // Validate is the msg.sender is the signer or if the provided signature is valid\r\n        require(_signer == msg.sender || _signer == SigUtils.ecrecover2(id, _signature), \"Invalid signature\");\r\n\r\n        // Save the receipt before performing any other action\r\n        intentReceipt[id] = _encodeReceipt(false, block.number, msg.sender);\r\n\r\n        // Emit the 'relayed' event\r\n        emit Relayed(id, _implementation, _data);\r\n\r\n        // Perform 'delegatecall' to _implementation, appending the id of the intent\r\n        // to the beginning of the _data.\r\n\r\n        bool success;\r\n        (success, result) = _implementation.delegatecall(abi.encode(id, _data));\r\n\r\n        // If the 'delegatecall' failed, reverts the transaction\r\n        // forwarding the revert message\r\n        if (!success) {\r\n            assembly {\r\n                revert(add(result, 32), mload(result))\r\n            }\r\n        }\r\n    }\r\n\r\n    // Cancels a not executed Intent '_id'\r\n    // a canceled intent can't be executed\r\n    function cancel(bytes32 _id) external {\r\n        require(msg.sender == address(this), \"Only wallet can cancel txs\");\r\n\r\n        if (intentReceipt[_id] != bytes32(0)) {\r\n            (bool canceled, , address relayer) = _decodeReceipt(intentReceipt[_id]);\r\n            require(relayer == address(0), \"Intent already relayed\");\r\n            require(!canceled, \"Intent was canceled\");\r\n            revert(\"Unknown error\");\r\n        }\r\n\r\n        emit Canceled(_id);\r\n        intentReceipt[_id] = _encodeReceipt(true, 0, address(0));\r\n    }\r\n\r\n    // Encodes an Intent receipt\r\n    // into a single bytes32\r\n    // canceled (1 bit) + block (95 bits) + relayer (160 bits)\r\n    // notice: Does not validate the _block length,\r\n    // a _block overflow would not corrupt the wallet state\r\n    function _encodeReceipt(\r\n        bool _canceled,\r\n        uint256 _block,\r\n        address _relayer\r\n    ) internal pure returns (bytes32 _receipt) {\r\n        assembly {\r\n            _receipt := or(shl(255, _canceled), or(shl(160, _block), _relayer))\r\n        }\r\n    }\r\n    \r\n    // Decodes an Intent receipt\r\n    // reverse of _encodeReceipt(bool,uint256,address)\r\n    function _decodeReceipt(bytes32 _receipt) internal pure returns (\r\n        bool _canceled,\r\n        uint256 _block,\r\n        address _relayer\r\n    ) {\r\n        assembly {\r\n            _canceled := shr(255, _receipt)\r\n            _block := and(shr(160, _receipt), 0x7fffffffffffffffffffffff)\r\n            _relayer := and(_receipt, 0xffffffffffffffffffffffffffffffffffffffff)\r\n        }\r\n    }\r\n\r\n    // Used to receive ERC721 tokens\r\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\r\n        return bytes4(0x150b7a02);\r\n    }\r\n}\r\n\r\n// File: contracts/utils/DepsUtils.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\n// Utils Toolset to use as dependencies\r\n// in a Marmo Intent\r\ncontract DepsUtils {\r\n    // Validates if a list of 'intents' was relayed\r\n    // Returns true if all intents where relayed, false otherwise\r\n    function multipleDeps(Marmo[] calldata _wallets, bytes32[] calldata _ids) external view returns (bool) {\r\n        uint256 size = _wallets.length;\r\n\r\n        require(\r\n            size == _ids.length,\r\n            \"_wallets and _ids should have equal length\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < size; i++) {\r\n            if (_wallets[i].relayedBy(_ids[i]) == address(0)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"contract Marmo[]\",\"name\":\"_wallets\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_ids\",\"type\":\"bytes32[]\"}],\"name\":\"multipleDeps\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DepsUtils","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://9ab5386f7c79600a4b6e873d6e5541435102ce649218afa918eef71aa7b9c156"}]}