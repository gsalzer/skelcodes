{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.12;\npragma experimental ABIEncoderV2;\n// File: @airswap/indexer/contracts/interfaces/IIndexer.sol\n/*\n  Copyright 2019 Swap Holdings Ltd.\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\ninterface IIndexer {\n  event CreateIndex(\n    address indexed signerToken,\n    address indexed senderToken,\n    address indexAddress\n  );\n  event Stake(\n    address indexed staker,\n    address indexed signerToken,\n    address indexed senderToken,\n    uint256 stakeAmount\n  );\n  event Unstake(\n    address indexed staker,\n    address indexed signerToken,\n    address indexed senderToken,\n    uint256 stakeAmount\n  );\n  event AddTokenToBlacklist(\n    address token\n  );\n  event RemoveTokenFromBlacklist(\n    address token\n  );\n  function setLocatorWhitelist(\n    address newLocatorWhitelist\n  ) external;\n  function createIndex(\n    address signerToken,\n    address senderToken\n  ) external returns (address);\n  function addTokenToBlacklist(\n    address token\n  ) external;\n  function removeTokenFromBlacklist(\n    address token\n  ) external;\n  function setIntent(\n    address signerToken,\n    address senderToken,\n    uint256 stakingAmount,\n    bytes32 locator\n  ) external;\n  function unsetIntent(\n    address signerToken,\n    address senderToken\n  ) external;\n  function stakingToken() external view returns (address);\n  function indexes(address, address) external view returns (address);\n  function tokenBlacklist(address) external view returns (bool);\n  function getStakedAmount(\n    address user,\n    address signerToken,\n    address senderToken\n  ) external view returns (uint256);\n  function getLocators(\n    address signerToken,\n    address senderToken,\n    address cursor,\n    uint256 limit\n  ) external view returns (\n    bytes32[] memory,\n    uint256[] memory,\n    address\n  );\n}\n// File: @airswap/indexer/contracts/interfaces/ILocatorWhitelist.sol\n/*\n  Copyright 2019 Swap Holdings Ltd.\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\ninterface ILocatorWhitelist {\n  function has(\n    bytes32 locator\n  ) external view returns (bool);\n}\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n// File: @airswap/index/contracts/Index.sol\n/*\n  Copyright 2019 Swap Holdings Ltd.\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n/**\n  * @title Index: A List of Locators\n  * @notice The Locators are sorted in reverse order based on the score\n  * meaning that the first element in the list has the largest score\n  * and final element has the smallest\n  * @dev A mapping is used to mimic a circular linked list structure\n  * where every mapping Entry contains a pointer to the next\n  * and the previous\n  */\ncontract Index is Ownable {\n  // The number of entries in the index\n  uint256 public length;\n  // Identifier to use for the head of the list\n  address constant internal HEAD = address(uint160(2**160-1));\n  // Mapping of an identifier to its entry\n  mapping(address => Entry) public entries;\n  /**\n    * @notice Index Entry\n    * @param score uint256\n    * @param locator bytes32\n    * @param prev address Previous address in the linked list\n    * @param next address Next address in the linked list\n    */\n  struct Entry {\n    bytes32 locator;\n    uint256 score;\n    address prev;\n    address next;\n  }\n  /**\n    * @notice Contract Events\n    */\n  event SetLocator(\n    address indexed identifier,\n    uint256 score,\n    bytes32 indexed locator\n  );\n  event UnsetLocator(\n    address indexed identifier\n  );\n  /**\n    * @notice Contract Constructor\n    */\n  constructor() public {\n    // Create initial entry.\n    entries[HEAD] = Entry(bytes32(0), 0, HEAD, HEAD);\n  }\n  /**\n    * @notice Set a Locator\n    * @param identifier address On-chain address identifying the owner of a locator\n    * @param score uint256 Score for the locator being set\n    * @param locator bytes32 Locator\n    */\n  function setLocator(\n    address identifier,\n    uint256 score,\n    bytes32 locator\n  ) external onlyOwner {\n    // Ensure the entry does not already exist.\n    require(!_hasEntry(identifier), \"ENTRY_ALREADY_EXISTS\");\n    // Find the first entry with a lower score.\n    address nextEntry = _getEntryLowerThan(score);\n    // Link the new entry between previous and next.\n    address prevEntry = entries[nextEntry].prev;\n    entries[prevEntry].next = identifier;\n    entries[nextEntry].prev = identifier;\n    entries[identifier] = Entry(locator, score, prevEntry, nextEntry);\n    // Increment the index length.\n    length = length + 1;\n    emit SetLocator(identifier, score, locator);\n  }\n  /**\n    * @notice Unset a Locator\n    * @param identifier address On-chain address identifying the owner of a locator\n    */\n  function unsetLocator(\n    address identifier\n  ) external onlyOwner {\n    // Ensure the entry exists.\n    require(_hasEntry(identifier), \"ENTRY_DOES_NOT_EXIST\");\n    // Link the previous and next entries together.\n    address prevUser = entries[identifier].prev;\n    address nextUser = entries[identifier].next;\n    entries[prevUser].next = nextUser;\n    entries[nextUser].prev = prevUser;\n    // Delete entry from the index.\n    delete entries[identifier];\n    // Decrement the index length.\n    length = length - 1;\n    emit UnsetLocator(identifier);\n  }\n  /**\n    * @notice Get a Score\n    * @param identifier address On-chain address identifying the owner of a locator\n    * @return uint256 Score corresponding to the identifier\n    */\n  function getScore(\n    address identifier\n  ) external view returns (uint256) {\n    return entries[identifier].score;\n  }\n    /**\n    * @notice Get a Locator\n    * @param identifier address On-chain address identifying the owner of a locator\n    * @return bytes32 Locator information\n    */\n  function getLocator(\n    address identifier\n  ) external view returns (bytes32) {\n    return entries[identifier].locator;\n  }\n  /**\n    * @notice Get a Range of Locators\n    * @dev start value of 0x0 starts at the head\n    * @param cursor address Cursor to start with\n    * @param limit uint256 Maximum number of locators to return\n    * @return bytes32[] List of locators\n    * @return uint256[] List of scores corresponding to locators\n    * @return address The next cursor to provide for pagination\n    */\n  function getLocators(\n    address cursor,\n    uint256 limit\n  ) external view returns (\n    bytes32[] memory locators,\n    uint256[] memory scores,\n    address nextCursor\n  ) {\n    address identifier;\n    // If a valid cursor is provided, start there.\n    if (cursor != address(0) && cursor != HEAD) {\n      // Check that the provided cursor exists.\n      if (!_hasEntry(cursor)) {\n        return (new bytes32[](0), new uint256[](0), address(0));\n      }\n      // Set the starting identifier to the provided cursor.\n      identifier = cursor;\n    } else {\n      identifier = entries[HEAD].next;\n    }\n    // Although it's not known how many entries are between `cursor` and the end\n    // We know that it is no more than `length`\n    uint256 size = (length < limit) ? length : limit;\n    locators = new bytes32[](size);\n    scores = new uint256[](size);\n    // Iterate over the list until the end or size.\n    uint256 i;\n    while (i < size && identifier != HEAD) {\n      locators[i] = entries[identifier].locator;\n      scores[i] = entries[identifier].score;\n      i = i + 1;\n      identifier = entries[identifier].next;\n    }\n    return (locators, scores, identifier);\n  }\n  /**\n    * @notice Check if the Index has an Entry\n    * @param identifier address On-chain address identifying the owner of a locator\n    * @return bool True if the identifier corresponds to an Entry in the list\n    */\n  function _hasEntry(\n    address identifier\n  ) internal view returns (bool) {\n    return entries[identifier].locator != bytes32(0);\n  }\n  /**\n    * @notice Returns the largest scoring Entry Lower than a Score\n    * @param score uint256 Score in question\n    * @return address Identifier of the largest score lower than score\n    */\n  function _getEntryLowerThan(\n    uint256 score\n  ) internal view returns (address) {\n    address identifier = entries[HEAD].next;\n    // Head indicates last because the list is circular.\n    if (score == 0) {\n      return HEAD;\n    }\n    // Iterate until a lower score is found.\n    while (score <= entries[identifier].score) {\n      identifier = entries[identifier].next;\n    }\n    return identifier;\n  }\n}\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n// File: contracts/Indexer.sol\n/*\n  Copyright 2019 Swap Holdings Ltd.\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n/**\n  * @title Indexer: A Collection of Index contracts by Token Pair\n  */\ncontract Indexer is IIndexer, Ownable {\n  // Token to be used for staking (ERC-20)\n  IERC20 public stakingToken;\n  // Mapping of signer token to sender token to index\n  mapping (address => mapping (address => Index)) public indexes;\n  // Mapping of token address to boolean\n  mapping (address => bool) public tokenBlacklist;\n  // The whitelist contract for checking whether a peer is whitelisted\n  address public locatorWhitelist;\n  /**\n    * @notice Contract Constructor\n    * @param indexerStakingToken address\n    */\n  constructor(\n    address indexerStakingToken\n  ) public {\n    stakingToken = IERC20(indexerStakingToken);\n  }\n  /**\n    * @notice Modifier to check an index exists\n    */\n  modifier indexExists(address signerToken, address senderToken) {\n    require(indexes[signerToken][senderToken] != Index(0),\n      \"INDEX_DOES_NOT_EXIST\");\n    _;\n  }\n  /**\n    * @notice Set the address of an ILocatorWhitelist to use\n    * @dev Allows removal of locatorWhitelist by passing 0x0\n    * @param newLocatorWhitelist address Locator whitelist\n    */\n  function setLocatorWhitelist(\n    address newLocatorWhitelist\n  ) external onlyOwner {\n    locatorWhitelist = newLocatorWhitelist;\n  }\n  /**\n    * @notice Create an Index (List of Locators for a Token Pair)\n    * @dev Deploys a new Index contract and stores the address. If the Index already\n    * @dev exists, returns its address, and does not emit a CreateIndex event\n    * @param signerToken address Signer token for the Index\n    * @param senderToken address Sender token for the Index\n    */\n  function createIndex(\n    address signerToken,\n    address senderToken\n  ) external returns (address) {\n    // If the Index does not exist, create it.\n    if (indexes[signerToken][senderToken] == Index(0)) {\n      // Create a new Index contract for the token pair.\n      indexes[signerToken][senderToken] = new Index();\n      emit CreateIndex(signerToken, senderToken, address(indexes[signerToken][senderToken]));\n    }\n    // Return the address of the Index contract.\n    return address(indexes[signerToken][senderToken]);\n  }\n  /**\n    * @notice Add a Token to the Blacklist\n    * @param token address Token to blacklist\n    */\n  function addTokenToBlacklist(\n    address token\n  ) external onlyOwner {\n    if (!tokenBlacklist[token]) {\n      tokenBlacklist[token] = true;\n      emit AddTokenToBlacklist(token);\n    }\n  }\n  /**\n    * @notice Remove a Token from the Blacklist\n    * @param token address Token to remove from the blacklist\n    */\n  function removeTokenFromBlacklist(\n    address token\n  ) external onlyOwner {\n    if (tokenBlacklist[token]) {\n      tokenBlacklist[token] = false;\n      emit RemoveTokenFromBlacklist(token);\n    }\n  }\n  /**\n    * @notice Set an Intent to Trade\n    * @dev Requires approval to transfer staking token for sender\n    *\n    * @param signerToken address Signer token of the Index being staked\n    * @param senderToken address Sender token of the Index being staked\n    * @param stakingAmount uint256 Amount being staked\n    * @param locator bytes32 Locator of the staker\n    */\n  function setIntent(\n    address signerToken,\n    address senderToken,\n    uint256 stakingAmount,\n    bytes32 locator\n  ) external indexExists(signerToken, senderToken) {\n    // If whitelist set, ensure the locator is valid.\n    if (locatorWhitelist != address(0)) {\n      require(ILocatorWhitelist(locatorWhitelist).has(locator),\n      \"LOCATOR_NOT_WHITELISTED\");\n    }\n    // Ensure neither of the tokens are blacklisted.\n    require(!tokenBlacklist[signerToken] && !tokenBlacklist[senderToken],\n      \"PAIR_IS_BLACKLISTED\");\n    bool notPreviouslySet = (indexes[signerToken][senderToken].getLocator(msg.sender) == bytes32(0));\n    if (notPreviouslySet) {\n      // Only transfer for staking if stakingAmount is set.\n      if (stakingAmount > 0) {\n        // Transfer the stakingAmount for staking.\n        require(stakingToken.transferFrom(msg.sender, address(this), stakingAmount),\n          \"UNABLE_TO_STAKE\");\n      }\n      // Set the locator on the index.\n      indexes[signerToken][senderToken].setLocator(msg.sender, stakingAmount, locator);\n      emit Stake(msg.sender, signerToken, senderToken, stakingAmount);\n    } else {\n      uint256 oldStake = indexes[signerToken][senderToken].getScore(msg.sender);\n      _updateIntent(msg.sender, signerToken, senderToken, stakingAmount, locator, oldStake);\n    }\n  }\n  /**\n    * @notice Unset an Intent to Trade\n    * @dev Users are allowed to unstake from blacklisted indexes\n    *\n    * @param signerToken address Signer token of the Index being unstaked\n    * @param senderToken address Sender token of the Index being staked\n    */\n  function unsetIntent(\n    address signerToken,\n    address senderToken\n  ) external {\n    _unsetIntent(msg.sender, signerToken, senderToken);\n  }\n  /**\n    * @notice Get the locators of those trading a token pair\n    * @dev Users are allowed to unstake from blacklisted indexes\n    *\n    * @param signerToken address Signer token of the trading pair\n    * @param senderToken address Sender token of the trading pair\n    * @param cursor address Address to start from\n    * @param limit uint256 Total number of locators to return\n    * @return bytes32[] List of locators\n    * @return uint256[] List of scores corresponding to locators\n    * @return address The next cursor to provide for pagination\n    */\n  function getLocators(\n    address signerToken,\n    address senderToken,\n    address cursor,\n    uint256 limit\n  ) external view returns (\n    bytes32[] memory locators,\n    uint256[] memory scores,\n    address nextCursor\n  ) {\n    // Ensure neither token is blacklisted.\n    if (tokenBlacklist[signerToken] || tokenBlacklist[senderToken]) {\n      return (new bytes32[](0), new uint256[](0), address(0));\n    }\n    // Ensure the index exists.\n    if (indexes[signerToken][senderToken] == Index(0)) {\n      return (new bytes32[](0), new uint256[](0), address(0));\n    }\n    return indexes[signerToken][senderToken].getLocators(cursor, limit);\n  }\n  /**\n    * @notice Gets the Stake Amount for a User\n    * @param user address User who staked\n    * @param signerToken address Signer token the user staked on\n    * @param senderToken address Sender token the user staked on\n    * @return uint256 Amount the user staked\n    */\n  function getStakedAmount(\n    address user,\n    address signerToken,\n    address senderToken\n  ) public view returns (uint256 stakedAmount) {\n    if (indexes[signerToken][senderToken] == Index(0)) {\n      return 0;\n    }\n    // Return the score, equivalent to the stake amount.\n    return indexes[signerToken][senderToken].getScore(user);\n  }\n  function _updateIntent(\n    address user,\n    address signerToken,\n    address senderToken,\n    uint256 newAmount,\n    bytes32 newLocator,\n    uint256 oldAmount\n  ) internal {\n    // If the new stake is bigger, collect the difference.\n    if (oldAmount < newAmount) {\n      // Note: SafeMath not required due to the inequality check above\n      require(stakingToken.transferFrom(user, address(this), newAmount - oldAmount),\n        \"UNABLE_TO_STAKE\");\n    }\n    // If the old stake is bigger, return the excess.\n    if (newAmount < oldAmount) {\n      // Note: SafeMath not required due to the inequality check above\n      require(stakingToken.transfer(user, oldAmount - newAmount));\n    }\n    // Unset their old intent, and set their new intent.\n    indexes[signerToken][senderToken].unsetLocator(user);\n    indexes[signerToken][senderToken].setLocator(user, newAmount, newLocator);\n    emit Stake(user, signerToken, senderToken, newAmount);\n  }\n  /**\n    * @notice Unset intents and return staked tokens\n    * @param user address Address of the user who staked\n    * @param signerToken address Signer token of the trading pair\n    * @param senderToken address Sender token of the trading pair\n    */\n  function _unsetIntent(\n    address user,\n    address signerToken,\n    address senderToken\n  ) internal indexExists(signerToken, senderToken) {\n     // Get the score for the user.\n    uint256 score = indexes[signerToken][senderToken].getScore(user);\n    // Unset the locator on the index.\n    indexes[signerToken][senderToken].unsetLocator(user);\n    if (score > 0) {\n      // Return the staked tokens. Reverts on failure.\n      require(stakingToken.transfer(user, score));\n    }\n    emit Unstake(user, signerToken, senderToken, score);\n  }\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"indexerStakingToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"AddTokenToBlacklist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signerToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"senderToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"indexAddress\",\"type\":\"address\"}],\"name\":\"CreateIndex\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"RemoveTokenFromBlacklist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signerToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"senderToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signerToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"senderToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"addTokenToBlacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"signerToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderToken\",\"type\":\"address\"}],\"name\":\"createIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"signerToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cursor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getLocators\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"locators\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"scores\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"nextCursor\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signerToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderToken\",\"type\":\"address\"}],\"name\":\"getStakedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"indexes\",\"outputs\":[{\"internalType\":\"contract Index\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locatorWhitelist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"removeTokenFromBlacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"signerToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakingAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"locator\",\"type\":\"bytes32\"}],\"name\":\"setIntent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLocatorWhitelist\",\"type\":\"address\"}],\"name\":\"setLocatorWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenBlacklist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"signerToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderToken\",\"type\":\"address\"}],\"name\":\"unsetIntent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Indexer","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"00000000000000000000000027054b13b1b798b345b591a4d22e6562d47ea75a","Library":"","LicenseType":"","SwarmSource":"bzzr://6f075f99db0c36de75d67d6614cc9d2d3a31f8c451685edecde4ff830f0216f6"}]}