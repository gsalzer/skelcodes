{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.2;\r\n\r\n\r\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/GSN/GSNRecipient.sol\r\n// But kept minimalist.\r\ncontract MsgSender {\r\n\r\n    address public relayHub;\r\n\r\n    /**\r\n     * @dev Replacement for msg.sender. Returns the actual sender of a transaction: msg.sender for regular transactions,\r\n     * and the end-user for GSN relayed calls (where msg.sender is actually `RelayHub`).\r\n     *\r\n     * IMPORTANT: Contracts derived from {MsgSender} should never use `msg.sender`, and use {_msgSender} instead.\r\n     */\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        if (msg.sender != relayHub) {\r\n            return msg.sender;\r\n        } else {\r\n            return _getRelayedCallSender();\r\n        }\r\n    }\r\n\r\n    function _getRelayedCallSender() private pure returns (address payable result) {\r\n        // We need to read 20 bytes (an address) located at array index msg.data.length - 20. In memory, the array\r\n        // is prefixed with a 32-byte length value, so we first add 32 to get the memory read index. However, doing\r\n        // so would leave the address in the upper 20 bytes of the 32-byte word, which is inconvenient and would\r\n        // require bit shifting. We therefore subtract 12 from the read index so the address lands on the lower 20\r\n        // bytes. This can always be done due to the 32-byte prefix.\r\n\r\n        // The final memory read index is msg.data.length - 20 + 32 - 12 = msg.data.length. Using inline assembly is the\r\n        // easiest/most-efficient way to perform this operation.\r\n\r\n        // These fields are not accessible from assembly\r\n        bytes memory array = msg.data;\r\n        uint256 index = msg.data.length;\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\r\n            result := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\r\n        }\r\n        return result;\r\n    }\r\n}\r\n// Fetch beacon\r\ncontract CommunityOracle is MsgSender {\r\n\r\n  // Used to count submissions\r\n  mapping (address => bool) public appointedOracle;\r\n  mapping (address => bool) public oracleSubmitted;\r\n  mapping (string => uint) public proposals;\r\n  string[] public proposalList;\r\n  uint public submitted;\r\n  uint public minimumOracles;\r\n\r\n  address public admin; // For installing the oracles.\r\n  event Beacon(string bls, uint beacon);\r\n\r\n  /**\r\n   * Sets up the community oracle service for CyberDice.\r\n   * @param _minimumOracles Minimum number of votes required for a beacon proposal.\r\n   * @param _relayHub RelayHub for replay protection\r\n   **/\r\n  constructor(uint _minimumOracles, address _relayHub) public {\r\n    admin = msg.sender;\r\n    minimumOracles = _minimumOracles;\r\n    relayHub = _relayHub;\r\n  }\r\n\r\n  /**\r\n   * Only the community admin (paddy) can install oracles\r\n   * @param _oracle Oracle address\r\n   */\r\n  function installOracle(address _oracle) public {\r\n    require(admin == _msgSender(), \"Only admin can install oracle\");\r\n    appointedOracle[_oracle] = true;\r\n  }\r\n\r\n  /**\r\n   * Collect beacon proposal from an appointed oracle\r\n   */\r\n  function submitBeacon(string memory _proposal) public {\r\n      require(appointedOracle[_msgSender()], \"Only appointed oracle\");\r\n      require(!oracleSubmitted[_msgSender()], \"Appointed oracle has already submitted\");\r\n      oracleSubmitted[_msgSender()] = true;\r\n      submitted = submitted + 1;\r\n\r\n      // Easy to iterate list.\r\n      if(proposals[_proposal] == 0) {\r\n          proposalList.push(_proposal);\r\n      }\r\n\r\n      proposals[_proposal] = proposals[_proposal] + 1;\r\n  }\r\n\r\n  // Count submissions by the oracles\r\n  // Returns 0 if beacon is not yet ready.\r\n  function getBeacon() public returns (uint) {\r\n    require(submitted >= minimumOracles, \"A minimum number of oracles must respond before fetching beacon\");\r\n\r\n    string memory winningProposal = proposalList[0];\r\n\r\n    // Compare votes for each unique solution sent\r\n    for(uint i=1; i<proposalList.length; i++) {\r\n      string memory proposal = proposalList[i];\r\n\r\n      // More votes?\r\n      if(proposals[proposal] > proposals[winningProposal]) {\r\n        winningProposal = proposal;\r\n      }\r\n    }\r\n\r\n    uint beacon = uint(keccak256(abi.encode(winningProposal)));\r\n    emit Beacon(winningProposal, beacon);\r\n    return beacon;\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimumOracles\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_relayHub\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"bls\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"beacon\",\"type\":\"uint256\"}],\"name\":\"Beacon\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"appointedOracle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBeacon\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"installOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumOracles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"oracleSubmitted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalList\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relayHub\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_proposal\",\"type\":\"string\"}],\"name\":\"submitBeacon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"submitted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CommunityOracle","CompilerVersion":"v0.6.2+commit.bacdbe57","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000300000000000000000000000070107abb312db18bd9addec39ce711374b09ebc1","Library":"","LicenseType":"MIT","SwarmSource":"ipfs://8b22060d461f0ec192896f05c5ba34f30e6e02a3028bfaf35989448510da40e6"}]}