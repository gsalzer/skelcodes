{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    require(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract Ownable {\r\n  address payable public owner;\r\n  address private manager;\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n    manager = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"only for owner\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyOwnerOrManager() {\r\n     require((msg.sender == owner)||(msg.sender == manager), \"only for owner or manager\");\r\n      _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    owner = address(uint160(newOwner));\r\n  }\r\n\r\n  function setManager(address _manager) public onlyOwnerOrManager {\r\n      manager = _manager;\r\n  }\r\n \r\n}\r\n\r\ncontract BigFamily is Ownable {\r\n    event eventJoin(address indexed _user, address indexed _father);\r\n    event eventPay(address indexed _from, address indexed _to, uint256 _amount);\r\n    //event eventDebug(uint number);\r\n    \r\n    uint256 constant public DEFAULT_JOIN_FEE = 0.5 ether;\r\n    uint256 constant private DEFAULT_JOIN_FEE_1 = DEFAULT_JOIN_FEE - 0.05 ether;\r\n    uint256 constant private DEFAULT_JOIN_FEE_2 = DEFAULT_JOIN_FEE - 0.1 ether;\r\n    uint256 constant private DEFAULT_JOIN_FEE_3 = DEFAULT_JOIN_FEE - 0.15 ether;\r\n    uint256 constant private DEFAULT_JOIN_FEE_4 = DEFAULT_JOIN_FEE - 0.2 ether;\r\n    uint256 constant private DEFAULT_JOIN_FEE_5 = DEFAULT_JOIN_FEE - 0.25 ether;\r\n    uint256 constant private MIN_JOIN_FEE = 0.2 ether;\r\n\r\n    struct Family{\r\n        address[] mOffsprings;\r\n        address mGrandParent;\r\n        uint256 mJoinFee;\r\n        uint256 mIncome;\r\n    }\r\n    \r\n    mapping (address => Family) private mFamilies;\r\n    address[] private mParents;//for mapping keys\r\n    \r\n    //////////////////////////////////////////////////////////////////////////////\r\n\r\n    constructor() public {\r\n        mParents.push(msg.sender);\r\n        mFamilies[msg.sender].mJoinFee = DEFAULT_JOIN_FEE_1;\r\n    }\r\n    \r\n    function getJoinFee(address _parent) public view returns(uint256){\r\n        uint256 NS = mFamilies[_parent].mOffsprings.length;\r\n        if(NS > 0) {\r\n            if (NS <= 5) return DEFAULT_JOIN_FEE_1;\r\n            else if(NS <= 20) return DEFAULT_JOIN_FEE_2;\r\n            else if(NS <= 50) return DEFAULT_JOIN_FEE_3;\r\n            else if(NS <= 100) return DEFAULT_JOIN_FEE_4;\r\n            else if(NS <= 500) return DEFAULT_JOIN_FEE_5;\r\n            else return MIN_JOIN_FEE;\r\n        }else if(checkJoined(_parent)){\r\n            return DEFAULT_JOIN_FEE_1;\r\n        }\r\n        else{\r\n            return DEFAULT_JOIN_FEE;\r\n        }\r\n    }\r\n    \r\n    function getLowestJoinFee() public view returns(uint256){\r\n        uint256 minFee = DEFAULT_JOIN_FEE;\r\n        for(uint i=0; i<mParents.length; i++){\r\n            address father = mParents[i];\r\n            uint256 fee = mFamilies[father].mJoinFee;\r\n            if (fee < minFee)\r\n                minFee = fee;\r\n            if (minFee == MIN_JOIN_FEE) //Note the lenght could be large\r\n                return MIN_JOIN_FEE;\r\n         }\r\n         return minFee;\r\n    }\r\n\r\n    function selectParentWithFee(uint256 _fee) internal view returns(address){\r\n        if(_fee < MIN_JOIN_FEE) return address(0);\r\n        \r\n        uint PN = mParents.length; //Note the mParent lenght could increase at anytime; fee could decrease at anytime\r\n        uint256 N = 0;\r\n        for(uint i=0; i<PN; i++){\r\n             address father = mParents[i];\r\n             uint256 fee = mFamilies[father].mJoinFee;\r\n             if (_fee >= fee){\r\n                N += 1;\r\n             }\r\n        }\r\n        if (N > 0){\r\n            uint256 index = 0;\r\n            address[] memory candidates = new address[](N);\r\n            for(uint i=0; i<PN; i++){\r\n                 address father = mParents[i];\r\n                 uint256 fee = mFamilies[father].mJoinFee;\r\n                 if (_fee >= fee){\r\n                    candidates[index] = father;\r\n                    index += 1;\r\n                 }\r\n                 if (index >= N)\r\n                    break;\r\n            }\r\n            index = block.timestamp % N;\r\n            return candidates[index];\r\n        }else{\r\n            return address(0);\r\n        }\r\n    }\r\n    \r\n    function checkParentExist(address _parent) public view returns(bool){\r\n        for(uint i=0; i< mParents.length; i++){\r\n            if(mParents[i] == _parent)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function findParent(address _offspring) public view returns(address){\r\n        for(uint i=0; i<mParents.length; i++){\r\n            address[] memory sons = mFamilies[mParents[i]].mOffsprings;\r\n            for(uint j=0; j<sons.length; j++){\r\n                if (_offspring == sons[j]) return mParents[i];\r\n            }\r\n        }\r\n        \r\n        return address(0);\r\n    }\r\n    \r\n    function checkJoined(address _from) public view returns(bool) {\r\n        if (checkParentExist(_from)) return true;\r\n        \r\n        for(uint i=0; i<mParents.length; i++){\r\n            address[] memory sons = mFamilies[mParents[i]].mOffsprings;\r\n            for(uint j=0; j<sons.length; j++){\r\n                if (_from == sons[j]) return true;\r\n            }\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    \r\n    function joinFamily(address payable _parent) public payable {\r\n        require(_parent != msg.sender, \"Father can't be yourself.\");\r\n        require(!checkJoined(msg.sender), \"You already joined.\"); \r\n        uint256 fee = getJoinFee(_parent);\r\n        require(msg.value >= fee, \"insufficient joining fee\");\r\n        \r\n        emit eventPay(msg.sender, address(this), msg.value);\r\n         \r\n        if(!checkParentExist(_parent)){\r\n            //then the sender is the ancestor\r\n            mParents.push(msg.sender);\r\n            mFamilies[msg.sender].mJoinFee = DEFAULT_JOIN_FEE_1;\r\n            emit eventJoin(msg.sender, address(0));\r\n        }else{\r\n            mFamilies[_parent].mOffsprings.push(msg.sender);\r\n            if (mFamilies[_parent].mGrandParent == address(0)){\r\n                address gp = findParent(_parent);\r\n                if (gp != address(0))\r\n                    mFamilies[_parent].mGrandParent = gp;\r\n            }\r\n            mFamilies[_parent].mJoinFee = getJoinFee(_parent);\r\n            \r\n            //pay for parent \r\n            uint256 ff = SafeMath.div(SafeMath.mul(fee, 7), 10);\r\n            _parent.transfer(ff);\r\n            mFamilies[_parent].mIncome += ff;\r\n            emit eventPay(address(this), _parent, ff);\r\n            \r\n            //pay for grandparent if exists\r\n            address payable gp = address(uint160(mFamilies[_parent].mGrandParent));\r\n            if (gp != address(0)){\r\n                uint256 gf = SafeMath.div(SafeMath.mul(fee, 2), 10);\r\n                gp.transfer(gf);\r\n                emit eventPay(address(this), gp, gf);\r\n            }\r\n            \r\n            emit eventJoin(msg.sender, _parent);\r\n        }\r\n        \r\n    }\r\n    \r\n    function becomeAncestor() public payable{\r\n        joinFamily(address(0));\r\n    }\r\n    \r\n    function autoSelectParent() public view returns(address){\r\n        uint256 minFee = getLowestJoinFee();\r\n        require(minFee>=MIN_JOIN_FEE, \"Joining fee calculation error!\");\r\n        address father = selectParentWithFee(minFee);\r\n        return father;\r\n    }\r\n    \r\n     //onlyOwnerOrManager will cause error in main network\r\n    function withdraw() public {\r\n        address payable self = address(uint160(address(this)));\r\n        if (self.balance >= 0.1 ether)\r\n            owner.transfer(self.balance);\r\n    }\r\n    \r\n    //onlyOwnerOrManager will cause error in main network\r\n    function checkBalance() public view returns(uint256){\r\n        address payable self = address(uint160(address(this)));\r\n        return self.balance;\r\n    }\r\n    \r\n    function countChildern(address _from) public view returns(uint256){\r\n        if (checkParentExist(_from)){\r\n            uint cn = 0;\r\n            for(uint i=0; i<mParents.length; i++){\r\n                cn += mFamilies[mParents[i]].mOffsprings.length;\r\n            }\r\n            return cn;\r\n        }else{\r\n            return 0;\r\n        }\r\n    }\r\n    \r\n    function countGrandChildern(address _from) public view returns(uint256){\r\n        if (checkParentExist(_from)){\r\n            uint cn = 0;\r\n            for(uint i=0; i<mParents.length; i++){\r\n                address parent = mParents[i];\r\n                for (uint j=0; j<mFamilies[parent].mOffsprings.length; j++){\r\n                    address child = mFamilies[parent].mOffsprings[j];\r\n                    if (checkParentExist(child)){\r\n                        cn += mFamilies[child].mOffsprings.length;\r\n                    }\r\n                }\r\n            }\r\n            return cn;\r\n        }else{\r\n            return 0;\r\n        }\r\n    }\r\n    \r\n    function getIncome(address _from) public view returns(uint256){\r\n        if (checkParentExist(_from)){\r\n            for(uint i=0; i<mParents.length; i++){\r\n                if(mParents[i] == _from)\r\n                    return mFamilies[mParents[i]].mIncome;\r\n            }\r\n            return 0;\r\n        }else{\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function countFamily() public view returns(uint256){\r\n        return mParents.length;\r\n    }\r\n\r\n    function checkChild(address _from, address _child) public view returns(bool){\r\n        if (checkParentExist(_from)){\r\n            for(uint i=0; i<mParents.length; i++){\r\n                if(mParents[i] == _from){\r\n                    address[] memory children = mFamilies[mParents[i]].mOffsprings;\r\n                    for(uint j=0; j<children.length; j++){\r\n                        if(children[j] == _child)\r\n                            return true;\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function checkOwner(address _from) public view returns(bool){\r\n        if(_from == owner) return true;\r\n        else return false;\r\n    }\r\n    \r\n\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_father\",\"type\":\"address\"}],\"name\":\"eventJoin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"eventPay\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEFAULT_JOIN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"autoSelectParent\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"becomeAncestor\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_child\",\"type\":\"address\"}],\"name\":\"checkChild\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"checkJoined\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"checkOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_parent\",\"type\":\"address\"}],\"name\":\"checkParentExist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"countChildern\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countFamily\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"countGrandChildern\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_offspring\",\"type\":\"address\"}],\"name\":\"findParent\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"getIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_parent\",\"type\":\"address\"}],\"name\":\"getJoinFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLowestJoinFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_parent\",\"type\":\"address\"}],\"name\":\"joinFamily\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BigFamily","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://0411c4bf5b84eb32d17a55efb5a6f9f684016f168b2c9c346aad3af617290c46"}]}