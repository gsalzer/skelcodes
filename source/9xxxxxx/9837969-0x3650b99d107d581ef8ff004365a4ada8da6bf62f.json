{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * Abstract contract, requires implementation to specify who can commit blocks and what\r\n *   happens when a successful proof is presented\r\n * Verifies Merkle-tree inclusion proofs that show that certain address has\r\n *   certain earnings balance, according to hash published (\"signed\") by a\r\n *   sidechain operator or similar authority\r\n *\r\n * ABOUT Merkle-tree inclusion proof: Merkle-tree inclusion proof is an algorithm to prove memebership\r\n * in a set using minimal [ie log(N)] inputs. The hashes of the items are arranged by hash value in a binary Merkle tree where\r\n * each node contains a hash of the hashes of nodes below. The root node (ie \"root hash\") contains hash information\r\n * about the entire set, and that is the data that BalanceVerifier posts to the blockchain. To prove membership, you walk up the\r\n * tree from the node in question, and use the supplied hashes (the \"proof\") to fill in the hashes from the adjacent nodes. The proof\r\n * succeeds iff you end up with the known root hash when you get to the top of the tree.\r\n * See https://medium.com/crypto-0-nite/merkle-proofs-explained-6dd429623dc5\r\n *\r\n * Merkle-tree inclusion proof is a related concept to the blockchain Merkle tree, but a somewhat different application.\r\n * BalanceVerifier posts the root hash of the current ledger only, and this does not depend on the hash of previous ledgers.\r\n * This is different from the blockchain, where each block contains the hash of the previous block.\r\n *\r\n * TODO: see if it could be turned into a library, so many contracts could use it\r\n */\r\ncontract BalanceVerifier {\r\n    event NewCommit(uint blockNumber, bytes32 rootHash, string ipfsHash);\r\n\r\n    /**\r\n     * Root hashes of merkle-trees constructed from its balances\r\n     * @param uint root-chain block number after which the balances were committed\r\n     * @return bytes32 root of the balances merkle-tree at that time\r\n     */\r\n    mapping (uint => bytes32) public committedHash;\r\n\r\n    /**\r\n     * Handler for proof of off-chain balances\r\n     * It is up to the implementing contract to actually distribute out the balances\r\n     * @param blockNumber the block whose hash was used for verification\r\n     * @param account whose balances were successfully verified\r\n     * @param balance the off-chain account balance\r\n     */\r\n    function onVerifySuccess(uint blockNumber, address account, uint balance) internal;\r\n\r\n    /**\r\n     * Implementing contract should should do access controls for committing\r\n     */\r\n    function onCommit(uint blockNumber, bytes32 rootHash, string memory ipfsHash) internal;\r\n\r\n    /**\r\n     * Monoplasma operator submits commitments to root-chain.\r\n     * For convenience, also publish the ipfsHash of the balance book JSON object\r\n     * @param blockNumber the root-chain block after which the balances were recorded\r\n     * @param rootHash root of the balances merkle-tree\r\n     * @param ipfsHash where the whole balances object can be retrieved in JSON format\r\n     */\r\n    function commit(uint blockNumber, bytes32 rootHash, string calldata ipfsHash) external {\r\n        require(committedHash[blockNumber] == 0, \"error_overwrite\");\r\n        string memory _hash = ipfsHash;\r\n        onCommit(blockNumber, rootHash, _hash); // Access control delegated to implementing class\r\n        committedHash[blockNumber] = rootHash;\r\n        emit NewCommit(blockNumber, rootHash, _hash);\r\n    }\r\n\r\n    /**\r\n     * Proving can be used to record the sidechain balances permanently into root chain\r\n     * @param blockNumber the block after which the balances were recorded\r\n     * @param account whose balances will be verified\r\n     * @param balance off-chain account balance\r\n     * @param proof list of hashes to prove the totalEarnings\r\n     */\r\n    function prove(uint blockNumber, address account, uint balance, bytes32[] memory proof) public {\r\n        require(proofIsCorrect(blockNumber, account, balance, proof), \"error_proof\");\r\n        onVerifySuccess(blockNumber, account, balance);\r\n    }\r\n\r\n    /**\r\n     * Check the merkle proof of balance in the given commit (after blockNumber in root-chain) for given account\r\n     * @param blockNumber the block after which the balances were recorded\r\n     * @param account whose balances will be verified\r\n     * @param balance off-chain account balance\r\n     * @param proof list of hashes to prove the totalEarnings\r\n     */\r\n    function proofIsCorrect(uint blockNumber, address account, uint balance, bytes32[] memory proof) public view returns(bool) {\r\n        bytes32 leafHash = keccak256(abi.encodePacked(account, balance, blockNumber));\r\n        bytes32 rootHash = committedHash[blockNumber];\r\n        require(rootHash != 0x0, \"error_blockNotFound\");\r\n        return rootHash == calculateRootHash(leafHash, proof);\r\n    }\r\n\r\n    /**\r\n     * Calculate root hash of a Merkle tree, given\r\n     * @param leafHash of the member whose balances are being be verified\r\n     * @param others list of hashes of \"other\" branches\r\n     */\r\n    function calculateRootHash(bytes32 leafHash, bytes32[] memory others) public pure returns (bytes32 root) {\r\n        root = leafHash;\r\n        for (uint8 i = 0; i < others.length; i++) {\r\n            bytes32 other = others[i];\r\n            if (root < other) {\r\n                // TODO: consider hashing in i to defend from https://en.wikipedia.org/wiki/Merkle_tree#Second_preimage_attack\r\n                root = keccak256(abi.encodePacked(root, other));\r\n            } else {\r\n                root = keccak256(abi.encodePacked(other, root));\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n    address public pendingOwner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"error_onlyOwner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to set the pendingOwner address.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the pendingOwner address to finalize the transfer.\r\n     */\r\n    function claimOwnership() public {\r\n        require(msg.sender == pendingOwner, \"error_onlyPendingOwner\");\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * Monoplasma that is managed by an owner, who also appoints a trusted (but verifiable) operator.\r\n * Owner should be able to add and remove recipients through an off-chain mechanism not specified here.\r\n */\r\ncontract Monoplasma is BalanceVerifier, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    event OperatorChanged(address indexed newOperator);\r\n    event AdminFeeChanged(uint adminFee);\r\n\r\n    /**\r\n     * Freeze period during which all participants should be able to\r\n     *   acquire the whole balance book from IPFS (or HTTP server, or elsewhere)\r\n     *   and validate that the published rootHash is correct.\r\n     * In case of incorrect rootHash, all members should issue withdrawals from the\r\n     *   latest block they have validated (that is older than blockFreezeSeconds).\r\n     * So: too short freeze period `+` bad availability `=>` ether (needlessly) spent withdrawing earnings.\r\n     *     Long freeze period `==` lag between purchase and withdrawal `=>` bad UX.\r\n     * Blocks older than blockFreezeSeconds can be used to withdraw funds.\r\n     */\r\n    uint public blockFreezeSeconds;\r\n\r\n    /**\r\n     * Block number => timestamp\r\n     * Publish time of a block, where the block freeze period starts from.\r\n     * Note that block number points to the block after which the root hash is calculated,\r\n     *   not the block where NewCommit was emitted (event must come later)\r\n     */\r\n    mapping (uint => uint) public blockTimestamp;\r\n\r\n    /// operator is the address who is allowed to commit the earnings\r\n    address public operator;\r\n\r\n    /// fee fraction = adminFee/10^18\r\n    uint public adminFee;\r\n\r\n    IERC20 public token;\r\n\r\n    /// track lifetime total of tokens withdrawn from contract\r\n    uint public totalWithdrawn;\r\n\r\n    /**\r\n     * Track lifetime total of earnings proven, as extra protection from malicious operator.\r\n     * The difference of what CAN be withdrawn and what HAS been withdrawn must be covered with tokens in contract,\r\n     *   in other words: `totalProven - totalWithdrawn <= token.balanceOf(this)`.\r\n     * This is to prevent a \"bank run\" situation where more earnings have been proven in the contract than there are tokens to cover them.\r\n     * Of course this only moves the \"bank run\" outside the contract, to a race to prove earnings,\r\n     *   but at least the contract should never go into a state where it couldn't cover what's been proven.\r\n     */\r\n    uint public totalProven;\r\n\r\n    /// earnings for which proof has been submitted\r\n    mapping (address => uint) public earnings;\r\n\r\n    /// earnings that have been sent out already\r\n    mapping (address => uint) public withdrawn;\r\n\r\n    constructor(address tokenAddress, uint blockFreezePeriodSeconds, uint initialAdminFee) public {\r\n        blockFreezeSeconds = blockFreezePeriodSeconds;\r\n        token = IERC20(tokenAddress);\r\n        operator = msg.sender;\r\n        setAdminFee(initialAdminFee);\r\n    }\r\n\r\n    /**\r\n     * Admin can appoint the operator.\r\n     * @param newOperator that is allowed to commit the off-chain balances\r\n     */\r\n    function setOperator(address newOperator) public onlyOwner {\r\n        operator = newOperator;\r\n        emit OperatorChanged(newOperator);\r\n    }\r\n\r\n    /**\r\n     * Admin fee as a fraction of revenue.\r\n     * Smart contract doesn't use it, it's here just for storing purposes.\r\n     * @param newAdminFee fixed-point decimal in the same way as ether: 50% === 0.5 ether === \"500000000000000000\"\r\n     */\r\n    function setAdminFee(uint newAdminFee) public onlyOwner {\r\n        require(newAdminFee <= 1 ether, \"error_adminFee\");\r\n        adminFee = newAdminFee;\r\n        emit AdminFeeChanged(adminFee);\r\n    }\r\n\r\n    /**\r\n     * Operator commits the off-chain balances.\r\n     * This starts the freeze period (measured from block.timestamp).\r\n     * See README under \"Threat model\" for discussion on safety of using \"now\".\r\n     * @param blockNumber after which balances were submitted\r\n     */\r\n    function onCommit(uint blockNumber, bytes32, string memory) internal {\r\n        require(msg.sender == operator, \"error_notPermitted\");\r\n        blockTimestamp[blockNumber] = now; // solium-disable-line security/no-block-members\r\n    }\r\n\r\n    /**\r\n     * Called from BalanceVerifier.prove.\r\n     * Prove can be called directly to withdraw less than the whole share,\r\n     *   or just \"cement\" the earnings so far into root chain even without withdrawing.\r\n     * Missing balance test is an extra layer of defense against fraudulent operator who tries to steal ALL tokens.\r\n     * If any member can exit within freeze period, that fraudulent commit will fail.\r\n     * Only earnings that have been committed longer than blockFreezeSeconds ago can be proven, see `onCommit`.\r\n     * See README under \"Threat model\" for discussion on safety of using \"now\".\r\n     * @param blockNumber after which balances were submitted in {onCommit}\r\n     * @param account whose earnings were successfully proven and updated\r\n     * @param newEarnings the updated total lifetime earnings\r\n     */\r\n    function onVerifySuccess(uint blockNumber, address account, uint newEarnings) internal {\r\n        uint blockFreezeStart = blockTimestamp[blockNumber];\r\n        require(now > blockFreezeStart + blockFreezeSeconds, \"error_frozen\"); // solium-disable-line security/no-block-members\r\n        require(earnings[account] < newEarnings, \"error_oldEarnings\");\r\n        totalProven = totalProven.add(newEarnings).sub(earnings[account]);\r\n        require(totalProven.sub(totalWithdrawn) <= token.balanceOf(address(this)), \"error_missingBalance\");\r\n        earnings[account] = newEarnings;\r\n    }\r\n\r\n    /**\r\n     * Prove and withdraw the whole revenue share from sidechain in one transaction.\r\n     * @param blockNumber of the commit that contains the earnings to verify\r\n     * @param totalEarnings in the off-chain balance book\r\n     * @param proof list of hashes to prove the totalEarnings\r\n     */\r\n    function withdrawAll(uint blockNumber, uint totalEarnings, bytes32[] calldata proof) external {\r\n        withdrawAllFor(msg.sender, blockNumber, totalEarnings, proof);\r\n    }\r\n\r\n    /**\r\n     * Prove and withdraw the whole revenue share on behalf of someone else.\r\n     * Validator needs to exit those it's watching out for, in case\r\n     *   it detects Operator malfunctioning.\r\n     * @param recipient the address we're proving and withdrawing to\r\n     * @param blockNumber of the commit that contains the earnings to verify\r\n     * @param totalEarnings in the off-chain balance book\r\n     * @param proof list of hashes to prove the totalEarnings\r\n     */\r\n    function withdrawAllFor(address recipient, uint blockNumber, uint totalEarnings, bytes32[] memory proof) public {\r\n        prove(blockNumber, recipient, totalEarnings, proof);\r\n        uint withdrawable = totalEarnings.sub(withdrawn[recipient]);\r\n        withdrawFor(recipient, withdrawable);\r\n    }\r\n\r\n    /**\r\n     * Prove and \"donate withdraw\" function that allows you to prove and transfer\r\n     *   your earnings to a another address in one transaction.\r\n     * @param recipient the address the tokens will be sent to (instead of msg.sender)\r\n     * @param blockNumber of the commit that contains the earnings to verify\r\n     * @param totalEarnings in the off-chain balance book\r\n     * @param proof list of hashes to prove the totalEarnings\r\n     */\r\n    function withdrawAllTo(address recipient, uint blockNumber, uint totalEarnings, bytes32[] calldata proof) external {\r\n        prove(blockNumber, msg.sender, totalEarnings, proof);\r\n        uint withdrawable = totalEarnings.sub(withdrawn[msg.sender]);\r\n        withdrawTo(recipient, withdrawable);\r\n    }\r\n\r\n    /**\r\n     * Prove and do an \"unlimited donate withdraw\" on behalf of someone else, to an address they've specified.\r\n     * Sponsored withdraw is paid by e.g. admin, but target account could be whatever the member specifies.\r\n     * The signature gives a \"blank cheque\" for admin to withdraw all tokens to `recipient` in the future,\r\n     *   and it's valid until next withdraw (and so can be nullified by withdrawing any amount).\r\n     * A new signature needs to be obtained for each subsequent future withdraw.\r\n     * @param recipient the address the tokens will be sent to (instead of `msg.sender`)\r\n     * @param signer whose earnings are being withdrawn\r\n     * @param signature from the community member, see `signatureIsValid` how signature generated for unlimited amount\r\n     * @param blockNumber of the commit that contains the earnings to verify\r\n     * @param totalEarnings in the off-chain balance book\r\n     * @param proof list of hashes to prove the totalEarnings\r\n     */\r\n    function withdrawAllToSigned(\r\n        address recipient,\r\n        address signer, bytes calldata signature,                       // signature arguments\r\n        uint blockNumber, uint totalEarnings, bytes32[] calldata proof  // proof arguments\r\n    )\r\n        external\r\n    {\r\n        require(signatureIsValid(recipient, signer, 0, signature), \"error_badSignature\");\r\n        prove(blockNumber, signer, totalEarnings, proof);\r\n        uint withdrawable = totalEarnings.sub(withdrawn[signer]);\r\n        _withdraw(recipient, signer, withdrawable);\r\n    }\r\n\r\n    /**\r\n     * Prove and do a \"donate withdraw\" on behalf of someone else, to an address they've specified.\r\n     * Sponsored withdraw is paid by e.g. admin, but target account could be whatever the member specifies.\r\n     * The signature is valid only for given amount of tokens that may be different from maximum withdrawable tokens.\r\n     * @param recipient the address the tokens will be sent to (instead of msg.sender)\r\n     * @param signer whose earnings are being withdrawn\r\n     * @param amount of tokens to withdraw\r\n     * @param signature from the community member, see `signatureIsValid` how it's generated\r\n     * @param blockNumber of the commit that contains the earnings to verify\r\n     * @param totalEarnings in the off-chain balance book\r\n     * @param proof list of hashes to prove the totalEarnings\r\n     */\r\n    function proveAndWithdrawToSigned(\r\n        address recipient,\r\n        address signer, uint amount, bytes calldata signature,          // signature arguments\r\n        uint blockNumber, uint totalEarnings, bytes32[] calldata proof  // proof arguments\r\n    )\r\n        external\r\n    {\r\n        require(signatureIsValid(recipient, signer, amount, signature), \"error_badSignature\");\r\n        prove(blockNumber, signer, totalEarnings, proof);\r\n        _withdraw(recipient, signer, amount);\r\n    }\r\n\r\n    /**\r\n     * Withdraw a specified amount of your own proven earnings (see `function prove`).\r\n     * @param amount of tokens to withdraw\r\n     */\r\n    function withdraw(uint amount) public {\r\n        _withdraw(msg.sender, msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * Withdraw a specified amount on behalf of someone else.\r\n     * Validator needs to exit those it's watching out for, in case it detects Operator malfunctioning.\r\n     * @param recipient whose tokens will be withdrawn (instead of msg.sender)\r\n     * @param amount of tokens to withdraw\r\n     */\r\n    function withdrawFor(address recipient, uint amount) public {\r\n        _withdraw(recipient, recipient, amount);\r\n    }\r\n\r\n    /**\r\n     * \"Donate withdraw\":\r\n     * Withdraw and transfer proven earnings to a another address in one transaction,\r\n     *   instead of withdrawing and then transfering the tokens.\r\n     * @param recipient the address the tokens will be sent to (instead of `msg.sender`)\r\n     * @param amount of tokens to withdraw\r\n     */\r\n    function withdrawTo(address recipient, uint amount) public {\r\n        _withdraw(recipient, msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * Signed \"donate withdraw\":\r\n     * Withdraw and transfer proven earnings to a third address on behalf of someone else.\r\n     * Sponsored withdraw is paid by e.g. admin, but target account could be whatever the member specifies.\r\n     * @param recipient of the tokens\r\n     * @param signer whose earnings are being withdrawn\r\n     * @param amount how much is authorized for withdrawing by the signature\r\n     * @param signature from the community member, see `signatureIsValid` how it's generated\r\n     */\r\n    function withdrawToSigned(address recipient, address signer, uint amount, bytes memory signature) public {\r\n        require(signatureIsValid(recipient, signer, amount, signature), \"error_badSignature\");\r\n        _withdraw(recipient, signer, amount);\r\n    }\r\n\r\n    /**\r\n     * Execute token withdrawal into specified recipient address from specified member account.\r\n     * To prevent \"bank runs\", it is up to the sidechain implementation to make sure that always:\r\n     * `sum of committed earnings <= token.balanceOf(this) + totalWithdrawn`.\r\n     * Smart contract can't verify that, because it can't see inside the commit hash.\r\n     * @param recipient of the tokens\r\n     * @param account whose earnings are being debited\r\n     * @param amount of tokens that is sent out\r\n     */\r\n    function _withdraw(address recipient, address account, uint amount) internal {\r\n        require(amount > 0, \"error_zeroWithdraw\");\r\n        uint w = withdrawn[account].add(amount);\r\n        require(w <= earnings[account], \"error_overdraft\");\r\n        withdrawn[account] = w;\r\n        totalWithdrawn = totalWithdrawn.add(amount);\r\n        require(token.transfer(recipient, amount), \"error_transfer\");\r\n    }\r\n\r\n    /**\r\n     * Check signature from a member authorizing withdrawing its earnings to another account.\r\n     * Throws if the signature is badly formatted or doesn't match the given signer and amount.\r\n     * Signature has parts the act as replay protection:\r\n     * 1) `address(this)`: signature can't be used for other contracts;\r\n     * 2) `withdrawn[signer]`: signature only works once (for unspecified amount), and can be \"cancelled\" by sending a withdraw tx.\r\n     * Generated in Javascript with: `web3.eth.accounts.sign(recipientAddress + amount.toString(16, 64) + contractAddress.slice(2) + withdrawnTokens.toString(16, 64), signerPrivateKey)`,\r\n     * or for unlimited amount: `web3.eth.accounts.sign(recipientAddress + \"0\".repeat(64) + contractAddress.slice(2) + withdrawnTokens.toString(16, 64), signerPrivateKey)`.\r\n     * @param recipient of the tokens\r\n     * @param signer whose earnings are being withdrawn\r\n     * @param amount how much is authorized for withdraw, or zero for unlimited (withdrawAll)\r\n     * @param signature byte array from `web3.eth.accounts.sign`\r\n     * @return true iff signer of the authorization (member whose earnings are going to be withdrawn) matches the signature\r\n     */\r\n    function signatureIsValid(address recipient, address signer, uint amount, bytes memory signature) public view returns (bool isValid) {\r\n        require(signature.length == 65, \"error_badSignatureLength\");\r\n\r\n        bytes32 r; bytes32 s; uint8 v;\r\n        assembly {      // solium-disable-line security/no-inline-assembly\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n            v := byte(0, mload(add(signature, 96)))\r\n        }\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n        require(v == 27 || v == 28, \"error_badSignatureVersion\");\r\n\r\n        // When changing the message, remember to double-check that message length is correct!\r\n        bytes32 messageHash = keccak256(abi.encodePacked(\r\n            \"\\x19Ethereum Signed Message:\\n104\", recipient, amount, address(this), withdrawn[signer]));\r\n        address calculatedSigner = ecrecover(messageHash, v, r, s);\r\n\r\n        return calculatedSigner == signer;\r\n    }\r\n}\r\n\r\n\r\ncontract DataunionVault is Monoplasma {\r\n\r\n    string public joinPartStream;\r\n\r\n    /** Server version. This must be kept in sync with src/server.js */\r\n    uint public version = 1;\r\n\r\n    constructor(address operator, string memory joinPartStreamId, address tokenAddress, uint blockFreezePeriodSeconds, uint adminFeeFraction)\r\n    Monoplasma(tokenAddress, blockFreezePeriodSeconds, adminFeeFraction) public {\r\n        setOperator(operator);\r\n        joinPartStream = joinPartStreamId;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"joinPartStreamId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockFreezePeriodSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"adminFeeFraction\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"adminFee\",\"type\":\"uint256\"}],\"name\":\"AdminFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"rootHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"}],\"name\":\"NewCommit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"OperatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockFreezeSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"blockTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"leafHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"others\",\"type\":\"bytes32[]\"}],\"name\":\"calculateRootHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"rootHash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"}],\"name\":\"commit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"committedHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"earnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"joinPartStream\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"proofIsCorrect\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"prove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEarnings\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"proveAndWithdrawToSigned\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAdminFee\",\"type\":\"uint256\"}],\"name\":\"setAdminFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"signatureIsValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalProven\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEarnings\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"withdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEarnings\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"withdrawAllFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEarnings\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"withdrawAllTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEarnings\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"withdrawAllToSigned\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"withdrawToSigned\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DataunionVault","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000c0aa4dc0763550161a6b59fa430361b5a26df28c00000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000cf0ee63788a0849fe5297f3407f701e122cc0230000000000000000000000000000000000000000000000000000000000000e100000000000000000000000000000000000000000000000000429d069189e00000000000000000000000000000000000000000000000000000000000000000016737a5a6b3274324a545a796c7252774e3643594a4e6700000000000000000000","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://6640614c1e318d8144727db96b3e60f3980eab48f5ee5fb614332bd1b358b384"}]}