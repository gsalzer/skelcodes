{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\nlibrary FixedPoint {\r\n\r\n    using SafeMath for uint;\r\n\r\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\r\n    // Can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint 10^77.\r\n    uint private constant FP_SCALING_FACTOR = 10**18;\r\n\r\n    struct Unsigned {\r\n        uint rawValue;\r\n    }\r\n\r\n    /** @dev Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5**18`. */\r\n    function fromUnscaledUint(uint a) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.mul(FP_SCALING_FACTOR));\r\n    }\r\n\r\n    /** @dev Whether `a` is greater than `b`. */\r\n    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\r\n        return a.rawValue > b.rawValue;\r\n    }\r\n\r\n    /** @dev Whether `a` is greater than `b`. */\r\n    function isGreaterThan(Unsigned memory a, uint b) internal pure returns (bool) {\r\n        return a.rawValue > fromUnscaledUint(b).rawValue;\r\n    }\r\n\r\n    /** @dev Whether `a` is greater than `b`. */\r\n    function isGreaterThan(uint a, Unsigned memory b) internal pure returns (bool) {\r\n        return fromUnscaledUint(a).rawValue > b.rawValue;\r\n    }\r\n\r\n    /** @dev Whether `a` is less than `b`. */\r\n    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\r\n        return a.rawValue < b.rawValue;\r\n    }\r\n\r\n    /** @dev Whether `a` is less than `b`. */\r\n    function isLessThan(Unsigned memory a, uint b) internal pure returns (bool) {\r\n        return a.rawValue < fromUnscaledUint(b).rawValue;\r\n    }\r\n\r\n    /** @dev Whether `a` is less than `b`. */\r\n    function isLessThan(uint a, Unsigned memory b) internal pure returns (bool) {\r\n        return fromUnscaledUint(a).rawValue < b.rawValue;\r\n    }\r\n\r\n    /** @dev Adds two `Unsigned`s, reverting on overflow. */\r\n    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.rawValue.add(b.rawValue));\r\n    }\r\n\r\n    /** @dev Adds an `Unsigned` to an unscaled uint, reverting on overflow. */\r\n    function add(Unsigned memory a, uint b) internal pure returns (Unsigned memory) {\r\n        return add(a, fromUnscaledUint(b));\r\n    }\r\n\r\n    /** @dev Subtracts two `Unsigned`s, reverting on underflow. */\r\n    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.rawValue.sub(b.rawValue));\r\n    }\r\n\r\n    /** @dev Subtracts an unscaled uint from an `Unsigned`, reverting on underflow. */\r\n    function sub(Unsigned memory a, uint b) internal pure returns (Unsigned memory) {\r\n        return sub(a, fromUnscaledUint(b));\r\n    }\r\n\r\n    /** @dev Subtracts an `Unsigned` from an unscaled uint, reverting on underflow. */\r\n    function sub(uint a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return sub(fromUnscaledUint(a), b);\r\n    }\r\n\r\n    /** @dev Multiplies two `Unsigned`s, reverting on overflow. */\r\n    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        // There are two caveats with this computation:\r\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\r\n        // stored internally as a uint ~10^59.\r\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\r\n        // would round to 3, but this computation produces the result 2.\r\n        // No need to use SafeMath because FP_SCALING_FACTOR != 0.\r\n        return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\r\n    }\r\n\r\n    /** @dev Multiplies an `Unsigned` by an unscaled uint, reverting on overflow. */\r\n    function mul(Unsigned memory a, uint b) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.rawValue.mul(b));\r\n    }\r\n\r\n    /** @dev Divides with truncation two `Unsigned`s, reverting on overflow or division by 0. */\r\n    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        // There are two caveats with this computation:\r\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\r\n        // 10^41 is stored internally as a uint 10^59.\r\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\r\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\r\n        return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\r\n    }\r\n\r\n    /** @dev Divides with truncation an `Unsigned` by an unscaled uint, reverting on division by 0. */\r\n    function div(Unsigned memory a, uint b) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.rawValue.div(b));\r\n    }\r\n\r\n    /** @dev Divides with truncation an unscaled uint by an `Unsigned`, reverting on overflow or division by 0. */\r\n    function div(uint a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return div(fromUnscaledUint(a), b);\r\n    }\r\n\r\n    /** @dev Raises an `Unsigned` to the power of an unscaled uint, reverting on overflow. E.g., `b=2` squares `a`. */\r\n    function pow(Unsigned memory a, uint b) internal pure returns (Unsigned memory output) {\r\n        // TODO(ptare): Consider using the exponentiation by squaring technique instead:\r\n        // https://en.wikipedia.org/wiki/Exponentiation_by_squaring\r\n        output = fromUnscaledUint(1);\r\n        for (uint i = 0; i < b; i = i.add(1)) {\r\n            output = mul(output, a);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary Exclusive {\r\n    struct RoleMembership {\r\n        address member;\r\n    }\r\n\r\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\r\n        return roleMembership.member == memberToCheck;\r\n    }\r\n\r\n    function resetMember(RoleMembership storage roleMembership, address newMember) internal {\r\n        require(newMember != address(0x0), \"Cannot set an exclusive role to 0x0\");\r\n        roleMembership.member = newMember;\r\n    }\r\n\r\n    function getMember(RoleMembership storage roleMembership) internal view returns (address) {\r\n        return roleMembership.member;\r\n    }\r\n\r\n    function init(RoleMembership storage roleMembership, address initialMember) internal {\r\n        resetMember(roleMembership, initialMember);\r\n    }\r\n}\r\n\r\nlibrary Shared {\r\n    struct RoleMembership {\r\n        mapping(address => bool) members;\r\n    }\r\n\r\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\r\n        return roleMembership.members[memberToCheck];\r\n    }\r\n\r\n    function addMember(RoleMembership storage roleMembership, address memberToAdd) internal {\r\n        roleMembership.members[memberToAdd] = true;\r\n    }\r\n\r\n    function removeMember(RoleMembership storage roleMembership, address memberToRemove) internal {\r\n        roleMembership.members[memberToRemove] = false;\r\n    }\r\n\r\n    function init(RoleMembership storage roleMembership, address[] memory initialMembers) internal {\r\n        for (uint i = 0; i < initialMembers.length; i++) {\r\n            addMember(roleMembership, initialMembers[i]);\r\n        }\r\n    }\r\n}\r\n\r\ncontract MultiRole {\r\n    using Exclusive for Exclusive.RoleMembership;\r\n    using Shared for Shared.RoleMembership;\r\n\r\n    enum RoleType { Invalid, Exclusive, Shared }\r\n\r\n    struct Role {\r\n        uint managingRole;\r\n        RoleType roleType;\r\n        Exclusive.RoleMembership exclusiveRoleMembership;\r\n        Shared.RoleMembership sharedRoleMembership;\r\n    }\r\n\r\n    mapping(uint => Role) private roles;\r\n\r\n    /**\r\n     * @notice Reverts unless the caller is a member of the specified roleId.\r\n     */\r\n    modifier onlyRoleHolder(uint roleId) {\r\n        require(holdsRole(roleId, msg.sender), \"Sender does not hold required role\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts unless the caller is a member of the manager role for the specified roleId.\r\n     */\r\n    modifier onlyRoleManager(uint roleId) {\r\n        require(holdsRole(roles[roleId].managingRole, msg.sender), \"Can only be called by a role manager\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts unless the roleId represents an initialized, exclusive roleId.\r\n     */\r\n    modifier onlyExclusive(uint roleId) {\r\n        require(roles[roleId].roleType == RoleType.Exclusive, \"Must be called on an initialized Exclusive role\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts unless the roleId represents an initialized, shared roleId.\r\n     */\r\n    modifier onlyShared(uint roleId) {\r\n        require(roles[roleId].roleType == RoleType.Shared, \"Must be called on an initialized Shared role\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `memberToCheck` is a member of roleId.\r\n     * @dev Reverts if roleId does not correspond to an initialized role.\r\n     */\r\n    function holdsRole(uint roleId, address memberToCheck) public view returns (bool) {\r\n        Role storage role = roles[roleId];\r\n        if (role.roleType == RoleType.Exclusive) {\r\n            return role.exclusiveRoleMembership.isMember(memberToCheck);\r\n        } else if (role.roleType == RoleType.Shared) {\r\n            return role.sharedRoleMembership.isMember(memberToCheck);\r\n        }\r\n        require(false, \"Invalid roleId\");\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the exclusive role holder of `roleId` to `newMember`.\r\n     * @dev Reverts if the caller is not a member of the managing role for `roleId` or if `roleId` is not an\r\n     * initialized, exclusive role.\r\n     */\r\n    function resetMember(uint roleId, address newMember) public onlyExclusive(roleId) onlyRoleManager(roleId) {\r\n        roles[roleId].exclusiveRoleMembership.resetMember(newMember);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current holder of the exclusive role, `roleId`.\r\n     * @dev Reverts if `roleId` does not represent an initialized, exclusive role.\r\n     */\r\n    function getMember(uint roleId) public view onlyExclusive(roleId) returns (address) {\r\n        return roles[roleId].exclusiveRoleMembership.getMember();\r\n    }\r\n\r\n    /**\r\n     * @notice Adds `newMember` to the shared role, `roleId`.\r\n     * @dev Reverts if `roleId` does not represent an initialized, shared role or if the caller is not a member of the\r\n     * managing role for `roleId`.\r\n     */\r\n    function addMember(uint roleId, address newMember) public onlyShared(roleId) onlyRoleManager(roleId) {\r\n        roles[roleId].sharedRoleMembership.addMember(newMember);\r\n    }\r\n\r\n    /**\r\n     * @notice Removes `memberToRemove` from the shared role, `roleId`.\r\n     * @dev Reverts if `roleId` does not represent an initialized, shared role or if the caller is not a member of the\r\n     * managing role for `roleId`.\r\n     */\r\n    function removeMember(uint roleId, address memberToRemove) public onlyShared(roleId) onlyRoleManager(roleId) {\r\n        roles[roleId].sharedRoleMembership.removeMember(memberToRemove);\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if `roleId` is not initialized.\r\n     */\r\n    modifier onlyValidRole(uint roleId) {\r\n        require(roles[roleId].roleType != RoleType.Invalid, \"Attempted to use an invalid roleId\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if `roleId` is initialized.\r\n     */\r\n    modifier onlyInvalidRole(uint roleId) {\r\n        require(roles[roleId].roleType == RoleType.Invalid, \"Cannot use a pre-existing role\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Internal method to initialize a shared role, `roleId`, which will be managed by `managingRoleId`.\r\n     * `initialMembers` will be immediately added to the role.\r\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\r\n     * initialized.\r\n     */\r\n    function _createSharedRole(uint roleId, uint managingRoleId, address[] memory initialMembers)\r\n        internal\r\n        onlyInvalidRole(roleId)\r\n    {\r\n        Role storage role = roles[roleId];\r\n        role.roleType = RoleType.Shared;\r\n        role.managingRole = managingRoleId;\r\n        role.sharedRoleMembership.init(initialMembers);\r\n        require(roles[managingRoleId].roleType != RoleType.Invalid,\r\n            \"Attempted to use an invalid role to manage a shared role\");\r\n    }\r\n\r\n    /**\r\n     * @notice Internal method to initialize a exclusive role, `roleId`, which will be managed by `managingRoleId`.\r\n     * `initialMembers` will be immediately added to the role.\r\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\r\n     * initialized.\r\n     */\r\n    function _createExclusiveRole(uint roleId, uint managingRoleId, address initialMember)\r\n        internal\r\n        onlyInvalidRole(roleId)\r\n    {\r\n        Role storage role = roles[roleId];\r\n        role.roleType = RoleType.Exclusive;\r\n        role.managingRole = managingRoleId;\r\n        role.exclusiveRoleMembership.init(initialMember);\r\n        require(roles[managingRoleId].roleType != RoleType.Invalid,\r\n            \"Attempted to use an invalid role to manage an exclusive role\");\r\n    }\r\n}\r\n\r\ninterface StoreInterface {\r\n\r\n    /** \r\n     * @dev Pays Oracle fees in ETH to the store. To be used by contracts whose margin currency is ETH.\r\n     */\r\n    function payOracleFees() external payable;\r\n\r\n    /**\r\n     * @dev Pays oracle fees in the margin currency, erc20Address, to the store. To be used if the margin\r\n     * currency is an ERC20 token rather than ETH> All approved tokens are transfered.\r\n     */\r\n    function payOracleFeesErc20(address erc20Address) external; \r\n\r\n    /**\r\n     * @dev Computes the regular oracle fees that a contract should pay for a period. \r\n     * pfc` is the \"profit from corruption\", or the maximum amount of margin currency that a\r\n     * token sponsor could extract from the contract through corrupting the price feed\r\n     * in their favor.\r\n     */\r\n    function computeRegularFee(uint startTime, uint endTime, FixedPoint.Unsigned calldata pfc) \r\n    external view returns (FixedPoint.Unsigned memory regularFee, FixedPoint.Unsigned memory latePenalty);\r\n    \r\n    /**\r\n     * @dev Computes the final oracle fees that a contract should pay at settlement.\r\n     */\r\n    function computeFinalFee(address currency) external view returns (FixedPoint.Unsigned memory finalFee);\r\n}\r\n\r\ncontract Withdrawable is MultiRole {\r\n\r\n    uint private _roleId;\r\n\r\n    /**\r\n     * @notice Withdraws ETH from the contract.\r\n     */\r\n    function withdraw(uint amount) external onlyRoleHolder(_roleId) {\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraws ERC20 tokens from the contract.\r\n     */\r\n    function withdrawErc20(address erc20Address, uint amount) external onlyRoleHolder(_roleId) {\r\n        IERC20 erc20 = IERC20(erc20Address);\r\n        require(erc20.transfer(msg.sender, amount));\r\n    }\r\n\r\n    /**\r\n     * @notice Internal method that allows derived contracts to create a role for withdrawal.\r\n     * @dev Either this method or `setWithdrawRole` must be called by the derived class for this contract to function\r\n     * properly.\r\n     */\r\n    function createWithdrawRole(uint roleId, uint managingRoleId, address owner) internal {\r\n        _roleId = roleId;\r\n        _createExclusiveRole(roleId, managingRoleId, owner);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal method that allows derived contracts to choose the role for withdrawal.\r\n     * @dev The role `roleId` must exist. Either this method or `createWithdrawRole` must be called by the derived class\r\n     * for this contract to function properly.\r\n     */\r\n    function setWithdrawRole(uint roleId) internal {\r\n        _roleId = roleId;\r\n    }\r\n}\r\n\r\ncontract Store is StoreInterface, MultiRole, Withdrawable {\r\n\r\n    using SafeMath for uint;\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n    using FixedPoint for uint;\r\n\r\n    enum Roles {\r\n        Owner,\r\n        Withdrawer\r\n    }\r\n\r\n    FixedPoint.Unsigned private fixedOracleFeePerSecond; // Percentage of 1 E.g., .1 is 10% Oracle fee.\r\n\r\n    FixedPoint.Unsigned private weeklyDelayFee; // Percentage of 1 E.g., .1 is 10% weekly delay fee.\r\n    mapping(address => FixedPoint.Unsigned) private finalFees;\r\n    uint private constant SECONDS_PER_WEEK = 604800;\r\n\r\n    event NewFixedOracleFeePerSecond(FixedPoint.Unsigned newOracleFee);\r\n\r\n    constructor() public {\r\n        _createExclusiveRole(uint(Roles.Owner), uint(Roles.Owner), msg.sender);\r\n        createWithdrawRole(uint(Roles.Withdrawer), uint(Roles.Owner), msg.sender);\r\n    }\r\n\r\n    function payOracleFees() external payable {\r\n        require(msg.value > 0);\r\n    }\r\n\r\n    function payOracleFeesErc20(address erc20Address) external {\r\n        IERC20 erc20 = IERC20(erc20Address);\r\n        uint authorizedAmount = erc20.allowance(msg.sender, address(this));\r\n        require(authorizedAmount > 0);\r\n        require(erc20.transferFrom(msg.sender, address(this), authorizedAmount));\r\n    }\r\n\r\n    function computeRegularFee(uint startTime, uint endTime, FixedPoint.Unsigned calldata pfc) \r\n        external \r\n        view \r\n        returns (FixedPoint.Unsigned memory regularFee, FixedPoint.Unsigned memory latePenalty) \r\n    {\r\n        uint timeDiff = endTime.sub(startTime);\r\n\r\n        // Multiply by the unscaled `timeDiff` first, to get more accurate results.\r\n        regularFee = pfc.mul(timeDiff).mul(fixedOracleFeePerSecond);\r\n        // `weeklyDelayFee` is already scaled up.\r\n        latePenalty = pfc.mul(weeklyDelayFee.mul(timeDiff.div(SECONDS_PER_WEEK)));\r\n\r\n        return (regularFee, latePenalty);\r\n    }\r\n\r\n    function computeFinalFee(address currency) \r\n        external \r\n        view \r\n        returns (FixedPoint.Unsigned memory finalFee) \r\n    {\r\n        finalFee = finalFees[currency];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets a new oracle fee per second\r\n     */ \r\n    function setFixedOracleFeePerSecond(FixedPoint.Unsigned memory newOracleFee) \r\n        public \r\n        onlyRoleHolder(uint(Roles.Owner)) \r\n    {\r\n        // Oracle fees at or over 100% don't make sense.\r\n        require(newOracleFee.isLessThan(1));\r\n        fixedOracleFeePerSecond = newOracleFee;\r\n        emit NewFixedOracleFeePerSecond(newOracleFee);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets a new weekly delay fee\r\n     */ \r\n    function setWeeklyDelayFee(FixedPoint.Unsigned memory newWeeklyDelayFee) \r\n        public \r\n        onlyRoleHolder(uint(Roles.Owner)) \r\n    {\r\n        weeklyDelayFee = newWeeklyDelayFee;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets a new final fee for a particular currency\r\n     */ \r\n    function setFinalFee(address currency, FixedPoint.Unsigned memory finalFee) \r\n        public \r\n        onlyRoleHolder(uint(Roles.Owner))\r\n    {\r\n        finalFees[currency] = finalFee;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"newOracleFee\",\"type\":\"tuple\"}],\"name\":\"NewFixedOracleFeePerSecond\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roleId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newMember\",\"type\":\"address\"}],\"name\":\"addMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"computeFinalFee\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"finalFee\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"pfc\",\"type\":\"tuple\"}],\"name\":\"computeRegularFee\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"regularFee\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"latePenalty\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roleId\",\"type\":\"uint256\"}],\"name\":\"getMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roleId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"memberToCheck\",\"type\":\"address\"}],\"name\":\"holdsRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payOracleFees\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"}],\"name\":\"payOracleFeesErc20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roleId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"memberToRemove\",\"type\":\"address\"}],\"name\":\"removeMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roleId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newMember\",\"type\":\"address\"}],\"name\":\"resetMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"finalFee\",\"type\":\"tuple\"}],\"name\":\"setFinalFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"newOracleFee\",\"type\":\"tuple\"}],\"name\":\"setFixedOracleFeePerSecond\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"newWeeklyDelayFee\",\"type\":\"tuple\"}],\"name\":\"setWeeklyDelayFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawErc20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Store","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://3eeebf19070b9ea0cb4b47b1cd1741eb473b5740c6545a00af77ee6e29c9318a"}]}