{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\nEtrix 2.0 \r\nDeveloped and created with love\r\n*/\r\n\r\npragma solidity 0.5.11;\r\n\r\n\r\ncontract Etrix {\r\n\r\n    address public _owner;\r\n    Etrix public oldSC = Etrix(0xCB8E1352034b97Fb60fDD891c0b23A32AF29d25d);\r\n    Etrix public newSC = Etrix(0x81c51a0B5c22dcA578039C7401B245aFd34F52F4);\r\n    uint public oldSCUserId = 2;\r\n\r\n      //Structure to store the user related data\r\n      struct UserStruct {\r\n        bool isExist;\r\n        uint id;\r\n        uint referrerIDMatrix1;\r\n        uint referrerIDMatrix2;\r\n        address[] referralMatrix1;\r\n        address[] referralMatrix2;\r\n        uint referralCounter;\r\n        mapping(uint => uint) levelExpiredMatrix1;\r\n        mapping(uint => uint) levelExpiredMatrix2;\r\n        mapping(uint => uint) levelExpiredMatrix3; \r\n    }\r\n\r\n    //A person can have maximum 2 branches\r\n    uint constant private REFERRER_1_LEVEL_LIMIT = 2;\r\n    //period of a particular level\r\n    uint constant private PERIOD_LENGTH = 90 days;\r\n    //person where the new user will be joined\r\n    uint public availablePersonID;\r\n    //Addresses of the Team   \r\n    address [] public shareHoldersM1;\r\n    //Addresses of the Team   \r\n    address [] public shareHoldersM2;\r\n    //Addresses of the Team   \r\n    address [] public shareHoldersM3;\r\n    //cost of each level\r\n    mapping(uint => uint) public LEVEL_PRICE;\r\n    mapping(uint => uint) public LEVEL_PRICEM3;\r\n    uint public REFERRAL_COMMISSION;\r\n\r\n    mapping (uint => uint) public uplinesToRcvEth;\r\n\r\n    //data of each user from the address\r\n    mapping (address => UserStruct) public users;\r\n    //user address by their id\r\n    mapping (uint => address) public userList;\r\n    //to track latest user ID\r\n    uint public currUserID = 0;\r\n\r\n    event regLevelEvent(address indexed _user, address indexed _referrer, uint _time);\r\n    event buyLevelEvent(address indexed _user, uint _level, uint _time, uint _matrix);\r\n    event prolongateLevelEvent(address indexed _user, uint _level, uint _time);\r\n    event getMoneyForLevelEvent(address indexed _user, address indexed _referral, uint _level, uint _time, uint _matrix);\r\n    event lostMoneyForLevelEvent(address indexed _user, address indexed _referral, uint _level, uint _time, uint _matrix);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event syncComplete();\r\n\r\n    constructor() public {\r\n        _owner = msg.sender;\r\n\r\n        LEVEL_PRICE[1] = 0.05 ether;\r\n        LEVEL_PRICE[2] = 0.1 ether;\r\n        LEVEL_PRICE[3] = 0.3 ether;\r\n        LEVEL_PRICE[4] = 1.25 ether;\r\n        LEVEL_PRICE[5] = 5 ether;\r\n        LEVEL_PRICE[6] = 10 ether;\r\n        \r\n        LEVEL_PRICEM3[1] = 0.05 ether;\r\n        LEVEL_PRICEM3[2] = 0.12 ether;\r\n        LEVEL_PRICEM3[3] = 0.35 ether;\r\n        LEVEL_PRICEM3[4] = 1.24 ether;\r\n        LEVEL_PRICEM3[5] = 5.4 ether;\r\n        LEVEL_PRICEM3[6] = 10 ether;\r\n\r\n        REFERRAL_COMMISSION = 0.03 ether;\r\n\r\n        uplinesToRcvEth[1] = 5;\r\n        uplinesToRcvEth[2] = 6;\r\n        uplinesToRcvEth[3] = 7;\r\n        uplinesToRcvEth[4] = 8;\r\n        uplinesToRcvEth[5] = 9;\r\n        uplinesToRcvEth[6] = 10;\r\n        \r\n        availablePersonID = 1;\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev allows only the user to run the function\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owner, \"only Owner\");\r\n        _;\r\n    }\r\n\r\n    function () external payable {\r\n      \r\n        uint level;\r\n\r\n        //check the level on the basis of amount sent\r\n        if(msg.value == LEVEL_PRICE[1]) level = 1;\r\n        else if(msg.value == LEVEL_PRICE[2]) level = 2;\r\n        else if(msg.value == LEVEL_PRICE[3]) level = 3;\r\n        else if(msg.value == LEVEL_PRICE[4]) level = 4;\r\n        else if(msg.value == LEVEL_PRICE[5]) level = 5;\r\n        else if(msg.value == LEVEL_PRICE[6]) level = 6;\r\n        \r\n        else revert('Incorrect Value send, please check');\r\n\r\n        //if user has already registered previously\r\n        if(users[msg.sender].isExist) \r\n            buyLevelMatrix2(level);\r\n\r\n        else if(level == 1) {\r\n            uint refId = 0;\r\n            address referrer = bytesToAddress(msg.data);\r\n\r\n            if(users[referrer].isExist) refId = users[referrer].id;\r\n            else revert('Incorrect referrer id');\r\n\r\n            regUser(refId);\r\n        }\r\n        else revert('Please buy first level for 0.05 ETH and then proceed');\r\n    }\r\n\r\n    /**\r\n        * @dev function to register the user after the pre registration\r\n        * @param _referrerID id of the referrer\r\n    */\r\n    function regUser(uint _referrerID) public payable {\r\n\r\n        require(!users[msg.sender].isExist, 'User exist');\r\n        require(address(oldSC) == address(0), 'Initialize Still Open');\r\n        require(_referrerID > 0 && _referrerID <= currUserID, 'Incorrect referrer Id');\r\n        require(msg.value == LEVEL_PRICE[1] + REFERRAL_COMMISSION, 'Incorrect Value');\r\n        \r\n\r\n        uint _referrerIDMatrix1;\r\n        uint _referrerIDMatrix2 = _referrerID;\r\n\r\n        _referrerIDMatrix1 = findAvailablePersonMatrix1();\r\n\r\n        if(users[userList[_referrerIDMatrix2]].referralMatrix2.length >= REFERRER_1_LEVEL_LIMIT) \r\n            _referrerIDMatrix2 = users[findAvailablePersonMatrix2(userList[_referrerIDMatrix2])].id;\r\n        \r\n\r\n        UserStruct memory userStruct;\r\n        currUserID++;\r\n\r\n        userStruct = UserStruct({\r\n            isExist: true,\r\n            id: currUserID,\r\n            referrerIDMatrix1: _referrerIDMatrix1,\r\n            referrerIDMatrix2: _referrerIDMatrix2,\r\n            referralCounter: 0,\r\n            referralMatrix1: new address[](0),\r\n            referralMatrix2: new address[](0)\r\n        });\r\n\r\n        users[msg.sender] = userStruct;\r\n        userList[currUserID] = msg.sender;\r\n\r\n        \r\n        users[msg.sender].levelExpiredMatrix2[1] = now + PERIOD_LENGTH;\r\n\r\n        users[userList[_referrerIDMatrix1]].referralMatrix1.push(msg.sender);\r\n        users[userList[_referrerIDMatrix2]].referralMatrix2.push(msg.sender);\r\n        \r\n        address(uint160(userList[_referrerID])).transfer(REFERRAL_COMMISSION);\r\n\r\n        payForLevelMatrix2(1,msg.sender);\r\n\r\n        //increase the referrer counter of the referrer\r\n        users[userList[_referrerID]].referralCounter++;\r\n\r\n        emit regLevelEvent(msg.sender, userList[_referrerID], now);\r\n    }\r\n    \r\n    /**\r\n        * @dev function to register the user after the pre registration\r\n        * @param _referrerID id of the referrer\r\n    */\r\n    function regExtraUsers(uint [] memory _referrerID, address [] memory _userAddress) public onlyOwner {\r\n\r\n        \r\n        require(address(oldSC) != address(0), 'Initialize close');\r\n        require(_referrerID.length == _userAddress.length);\r\n\r\n        uint _referrerIDMatrix1;\r\n        uint _referrerIDMatrix2;\r\n        for(uint i = 0; i < _referrerID.length; i++){\r\n            \r\n            (,,,,uint _referralCounter) = newSC.users(_userAddress[i]);\r\n            \r\n        _referrerIDMatrix2 = _referrerID[i];\r\n        _referrerIDMatrix1 = findAvailablePersonMatrix1();\r\n\r\n        if(users[userList[_referrerIDMatrix2]].referralMatrix2.length >= REFERRER_1_LEVEL_LIMIT) \r\n            _referrerIDMatrix2 = users[findAvailablePersonMatrix2(userList[_referrerIDMatrix2])].id;\r\n        \r\n\r\n        UserStruct memory userStruct;\r\n        currUserID++;\r\n\r\n        userStruct = UserStruct({\r\n            isExist: true,\r\n            id: currUserID++,\r\n            referrerIDMatrix1: _referrerIDMatrix1,\r\n            referrerIDMatrix2: _referrerIDMatrix2,\r\n            referralCounter: _referralCounter,\r\n            referralMatrix1: new address[](0),\r\n            referralMatrix2: new address[](0)\r\n        });\r\n\r\n        users[_userAddress[i]] = userStruct;\r\n        userList[currUserID] = _userAddress[i];\r\n        \r\n         for(uint j = 1; j <= 6; j++) {\r\n\r\n                users[_userAddress[i]].levelExpiredMatrix1[j] = newSC.viewUserLevelExpiredMatrix1(_userAddress[i], j);\r\n                users[_userAddress[i]].levelExpiredMatrix2[j] = newSC.viewUserLevelExpiredMatrix2(_userAddress[i], j);\r\n                users[_userAddress[i]].levelExpiredMatrix3[j] = newSC.viewUserLevelExpiredMatrix3(_userAddress[i], j);\r\n         }\r\n\r\n        users[userList[_referrerIDMatrix1]].referralMatrix1.push(_userAddress[i]);\r\n        users[userList[_referrerIDMatrix2]].referralMatrix2.push(_userAddress[i]);\r\n        \r\n        \r\n        //increase the referrer counter of the referrer\r\n        users[userList[_referrerID[i]]].referralCounter++;\r\n\r\n        emit regLevelEvent(msg.sender, userList[_referrerID[i]], now);\r\n    }\r\n}\r\n\r\n/**\r\n        * @dev function to register the user in the pre registration\r\n    */\r\n    function preRegAdmins(address [] memory _adminAddress) public onlyOwner{\r\n\r\n        require(currUserID <= 100, \"No more admins can be registered\");\r\n\r\n        UserStruct memory userStruct;\r\n\r\n        for(uint i = 0; i < _adminAddress.length; i++){\r\n\r\n            require(!users[_adminAddress[i]].isExist, 'One of the users exist');\r\n            currUserID++;\r\n\r\n            if(currUserID == 1){\r\n                userStruct = UserStruct({\r\n                isExist: true,\r\n                id: currUserID,\r\n                referrerIDMatrix1: 1,\r\n                referrerIDMatrix2: 1,\r\n                referralCounter: 87,\r\n                referralMatrix1: new address[](0),\r\n                referralMatrix2: new address[](0)\r\n        });\r\n\r\n            users[_adminAddress[i]] = userStruct;\r\n            userList[currUserID] = _adminAddress[i];\r\n\r\n            for(uint j = 1; j <= 6; j++) {\r\n                users[_adminAddress[i]].levelExpiredMatrix1[j] = 66666666666;\r\n                users[_adminAddress[i]].levelExpiredMatrix2[j] = 66666666666;\r\n                users[_adminAddress[i]].levelExpiredMatrix3[j] = 66666666666;\r\n            }\r\n            \r\n        }\r\n            else {\r\n                    uint _referrerIDMatrix1;\r\n                    uint _referrerIDMatrix2 = 1;\r\n\r\n                    _referrerIDMatrix1 = findAvailablePersonMatrix1();\r\n\r\n                    if(users[userList[_referrerIDMatrix2]].referralMatrix2.length >= REFERRER_1_LEVEL_LIMIT) \r\n                        _referrerIDMatrix2 = users[findAvailablePersonMatrix2(userList[_referrerIDMatrix2])].id;\r\n\r\n                                       \r\n                    userStruct = UserStruct({\r\n                        isExist: true,\r\n                        id: currUserID,\r\n                        referrerIDMatrix1: _referrerIDMatrix1,\r\n                        referrerIDMatrix2: _referrerIDMatrix2,\r\n                        referralCounter: 2,\r\n                        referralMatrix1: new address[](0),\r\n                        referralMatrix2: new address[](0)\r\n                    });\r\n\r\n                    users[_adminAddress[i]] = userStruct;\r\n                    userList[currUserID] = _adminAddress[i];\r\n\r\n                    for(uint j = 1; j <= 6; j++) {\r\n                        users[_adminAddress[i]].levelExpiredMatrix1[j] = 66666666666;\r\n                        users[_adminAddress[i]].levelExpiredMatrix2[j] = 66666666666;\r\n                        users[_adminAddress[i]].levelExpiredMatrix3[j] = 66666666666;\r\n                    }\r\n\r\n                    users[userList[_referrerIDMatrix1]].referralMatrix1.push(_adminAddress[i]);\r\n                    users[userList[_referrerIDMatrix2]].referralMatrix2.push(_adminAddress[i]);\r\n\r\n                }\r\n                emit regLevelEvent(_adminAddress[i], address(0x0), block.timestamp);\r\n    }\r\n}\r\n    \r\n    function changeAvailablePerson(uint _availablePersonID) public onlyOwner{\r\n        \r\n        availablePersonID = _availablePersonID;\r\n    }\r\n\r\n    function syncClose() external onlyOwner {\r\n        require(address(oldSC) != address(0), 'Initialize already closed');\r\n        oldSC = Etrix(0);\r\n    }\r\n\r\n    function syncWithOldSC(uint limit) public onlyOwner {\r\n        require(address(oldSC) != address(0), 'Initialize closed');\r\n        \r\n        address refM1;\r\n        address refM2;\r\n        \r\n        //UserStruct memory userStruct;\r\n\r\n        for(uint i = 0; i < limit; i++) {\r\n            address user = oldSC.userList(oldSCUserId);\r\n            (,, uint referrerIDM1, uint referrerIDM2,uint _referralCounter) = oldSC.users(user);\r\n\r\n            \r\n                oldSCUserId++;\r\n                \r\n                 refM1 = oldSC.userList(referrerIDM1);\r\n                 refM2 = oldSC.userList(referrerIDM2);\r\n\r\n                    users[user].isExist= true;\r\n                    users[user].id= ++currUserID;\r\n                    users[user].referrerIDMatrix1= referrerIDM1;\r\n                    users[user].referrerIDMatrix2= referrerIDM2;\r\n                    users[user].referralCounter= _referralCounter;\r\n                    \r\n                \r\n                userList[currUserID] = user;\r\n\r\n                users[refM1].referralMatrix1.push(user);\r\n                users[refM2].referralMatrix2.push(user);\r\n                \r\n                    for(uint j = 1; j <= 6; j++) {\r\n                         \r\n                         users[user].levelExpiredMatrix1[j] = newSC.viewUserLevelExpiredMatrix1(user, j);\r\n                         users[user].levelExpiredMatrix2[j] = newSC.viewUserLevelExpiredMatrix2(user, j);\r\n                         users[user].levelExpiredMatrix3[j] = newSC.viewUserLevelExpiredMatrix3(user, j);\r\n                    }\r\n\r\n                    emit regLevelEvent(user, address(0x0), block.timestamp);\r\n        }\r\n        emit syncComplete();\r\n    }\r\n\r\n\r\n    function addShareHolderM1(address [] memory _shareHolderAddress) public onlyOwner returns(address[] memory){\r\n\r\n        for(uint i=0; i < _shareHolderAddress.length; i++){\r\n\r\n            if(shareHoldersM1.length < 20) {\r\n                shareHoldersM1.push(_shareHolderAddress[i]);\r\n            }\r\n        }\r\n        return shareHoldersM1;\r\n    }\r\n\r\n    function removeShareHolderM1(address  _shareHolderAddress) public onlyOwner returns(address[] memory){\r\n\r\n        for(uint i=0; i < shareHoldersM1.length; i++){\r\n            if(shareHoldersM1[i] == _shareHolderAddress) {\r\n                shareHoldersM1[i] = shareHoldersM1[shareHoldersM1.length-1];\r\n                delete shareHoldersM1[shareHoldersM1.length-1];\r\n                shareHoldersM1.length--;\r\n            }\r\n        }\r\n        return shareHoldersM1;\r\n\r\n    }\r\n\r\n    function addShareHolderM2(address [] memory _shareHolderAddress) public onlyOwner returns(address[] memory){\r\n\r\n        for(uint i=0; i < _shareHolderAddress.length; i++){\r\n\r\n            if(shareHoldersM2.length < 20) {\r\n                shareHoldersM2.push(_shareHolderAddress[i]);\r\n            }\r\n        }\r\n        return shareHoldersM2;\r\n    }\r\n\r\n    function removeShareHolderM2(address  _shareHolderAddress) public onlyOwner returns(address[] memory){\r\n\r\n        for(uint i=0; i < shareHoldersM2.length; i++){\r\n            if(shareHoldersM2[i] == _shareHolderAddress) {\r\n                shareHoldersM2[i] = shareHoldersM2[shareHoldersM2.length-1];\r\n                delete shareHoldersM2[shareHoldersM2.length-1];\r\n                shareHoldersM2.length--;\r\n            }\r\n        }\r\n        return shareHoldersM2;\r\n\r\n    }\r\n\r\n    function addShareHolderM3(address [] memory _shareHolderAddress) public onlyOwner returns(address[] memory){\r\n\r\n        for(uint i=0; i < _shareHolderAddress.length; i++){\r\n\r\n            if(shareHoldersM3.length < 20) {\r\n                shareHoldersM3.push(_shareHolderAddress[i]);\r\n            }\r\n        }\r\n        return shareHoldersM3;\r\n    }\r\n\r\n    function removeShareHolderM3(address  _shareHolderAddress) public onlyOwner returns(address[] memory){\r\n\r\n        for(uint i=0; i < shareHoldersM3.length; i++){\r\n            if(shareHoldersM3[i] == _shareHolderAddress) {\r\n                shareHoldersM3[i] = shareHoldersM3[shareHoldersM3.length-1];\r\n                delete shareHoldersM3[shareHoldersM3.length-1];\r\n                shareHoldersM3.length--;\r\n            }\r\n        }\r\n        return shareHoldersM3;\r\n\r\n    }\r\n\r\n    /**\r\n        * @dev function to find the next available person in the complete binary tree\r\n        * @return id of the available person in the tree.\r\n    */\r\n    function findAvailablePersonMatrix1() internal returns(uint){\r\n       \r\n        uint _referrerID;\r\n        uint _referralLength = users[userList[availablePersonID]].referralMatrix1.length;\r\n        \r\n         if(_referralLength >= REFERRER_1_LEVEL_LIMIT) {       \r\n             availablePersonID++;\r\n             _referrerID = availablePersonID;\r\n        }\r\n        else if( _referralLength == 1) {\r\n            _referrerID = availablePersonID;\r\n            availablePersonID++;            \r\n        }\r\n        else{\r\n             _referrerID = availablePersonID;\r\n        }\r\n\r\n        return _referrerID;\r\n    }\r\n\r\n    function findAvailablePersonMatrix2(address _user) public view returns(address) {\r\n        if(users[_user].referralMatrix2.length < REFERRER_1_LEVEL_LIMIT) return _user;\r\n\r\n        address[] memory referrals = new address[](1022);\r\n        referrals[0] = users[_user].referralMatrix2[0];\r\n        referrals[1] = users[_user].referralMatrix2[1];\r\n\r\n        address freeReferrer;\r\n        bool noFreeReferrer = true;\r\n\r\n        for(uint i = 0; i < 1022; i++) {\r\n            if(users[referrals[i]].referralMatrix2.length >= REFERRER_1_LEVEL_LIMIT) {\r\n                if(i < 510) {\r\n                    referrals[(i+1)*2] = users[referrals[i]].referralMatrix2[0];\r\n                    referrals[(i+1)*2+1] = users[referrals[i]].referralMatrix2[1];\r\n                }\r\n            }\r\n            else {\r\n                noFreeReferrer = false;\r\n                freeReferrer = referrals[i];\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(!noFreeReferrer, 'No Free Referrer');\r\n\r\n        return freeReferrer;\r\n    }\r\n\r\n\r\n    function getUserUpline(address _user, uint height)\r\n    public\r\n    view\r\n    returns (address)\r\n  {\r\n    if (height <= 0 || _user == address(0)) {\r\n      return _user;\r\n    }\r\n\r\n    return this.getUserUpline(userList[users[_user].referrerIDMatrix2], height - 1);\r\n  }\r\n\r\n   \r\n\r\n    /**\r\n        * @dev function to buy the level for Company forced matrix\r\n        * @param _level level which a user wants to buy\r\n    */\r\n    function buyLevelMatrix1(uint _level) public payable {\r\n\r\n        require(users[msg.sender].isExist, 'User not exist'); \r\n        require(_level > 0 && _level <= 6, 'Incorrect level');\r\n\r\n        if(_level == 1) {\r\n            require(msg.value == LEVEL_PRICE[1], 'Incorrect Value');\r\n\r\n            if(users[msg.sender].levelExpiredMatrix1[1] > now)             \r\n                users[msg.sender].levelExpiredMatrix1[1] += PERIOD_LENGTH;\r\n                            \r\n            else \r\n                users[msg.sender].levelExpiredMatrix1[1] = now + PERIOD_LENGTH;\r\n            \r\n        }\r\n        else {\r\n            require(msg.value == LEVEL_PRICE[_level], 'Incorrect Value');\r\n\r\n            for(uint l =_level - 1; l > 0; l--) require(users[msg.sender].levelExpiredMatrix1[l] >= now, 'Buy the previous level');\r\n\r\n            if(users[msg.sender].levelExpiredMatrix1[_level] == 0 || now > users[msg.sender].levelExpiredMatrix1[_level])\r\n                users[msg.sender].levelExpiredMatrix1[_level] = now + PERIOD_LENGTH;\r\n            else users[msg.sender].levelExpiredMatrix1[_level] += PERIOD_LENGTH;\r\n        }\r\n\r\n        payForLevelMatrix1(_level, msg.sender);\r\n\r\n        emit buyLevelEvent(msg.sender, _level, now, 1);\r\n    }\r\n\r\n    /**\r\n        * @dev function to buy the level for Team matrix\r\n        * @param _level level which a user wants to buy\r\n    */\r\n    function buyLevelMatrix2(uint _level) public payable {\r\n        \r\n        require(users[msg.sender].isExist, 'User not exist'); \r\n        require(_level > 0 && _level <= 6, 'Incorrect level');\r\n\r\n        if(_level == 1) {\r\n            require(msg.value == LEVEL_PRICE[1], 'Incorrect Value');\r\n\r\n            if(users[msg.sender].levelExpiredMatrix2[1] > now)               \r\n                users[msg.sender].levelExpiredMatrix2[1] += PERIOD_LENGTH;\r\n                            \r\n            else \r\n                users[msg.sender].levelExpiredMatrix2[1] = now + PERIOD_LENGTH;\r\n            \r\n       }\r\n        else {\r\n            require(msg.value == LEVEL_PRICE[_level], 'Incorrect Value');\r\n\r\n            for(uint l =_level - 1; l > 0; l--) require(users[msg.sender].levelExpiredMatrix2[l] >= now, 'Buy the previous level');\r\n\r\n            if(users[msg.sender].levelExpiredMatrix2[_level] == 0 || now > users[msg.sender].levelExpiredMatrix2[_level]) \r\n                users[msg.sender].levelExpiredMatrix2[_level] = now + PERIOD_LENGTH;\r\n            \r\n            else users[msg.sender].levelExpiredMatrix2[_level] += PERIOD_LENGTH;\r\n        }\r\n\r\n        payForLevelMatrix2(_level, msg.sender);\r\n\r\n        emit buyLevelEvent(msg.sender, _level, now, 2);\r\n    }\r\n\r\n    /**\r\n        * @dev function to buy the level for Hybrid matrix\r\n        * @param _level level which a user wants to buy\r\n    */\r\n    function buyLevelMatrix3(uint _level) public payable {\r\n        \r\n        require(users[msg.sender].isExist, 'User not exist'); \r\n        require(_level > 0 && _level <= 6, 'Incorrect level');\r\n\r\n        if(_level == 1) {\r\n            require(msg.value == LEVEL_PRICEM3[1], 'Incorrect Value');\r\n\r\n            if(users[msg.sender].levelExpiredMatrix3[1] > now)               \r\n                users[msg.sender].levelExpiredMatrix3[1] += PERIOD_LENGTH;\r\n                            \r\n            else \r\n                users[msg.sender].levelExpiredMatrix3[1] = now + PERIOD_LENGTH;\r\n            \r\n       }\r\n        else {\r\n            require(msg.value == LEVEL_PRICEM3[_level], 'Incorrect Value');\r\n\r\n            for(uint l =_level - 1; l > 0; l--) require(users[msg.sender].levelExpiredMatrix3[l] >= now, 'Buy the previous level');\r\n\r\n            if(users[msg.sender].levelExpiredMatrix3[_level] == 0 || now > users[msg.sender].levelExpiredMatrix3[_level]) \r\n                users[msg.sender].levelExpiredMatrix3[_level] = now + PERIOD_LENGTH;\r\n            \r\n            else users[msg.sender].levelExpiredMatrix3[_level] += PERIOD_LENGTH;\r\n        }\r\n\r\n        payForLevelMatrix3(_level, msg.sender);\r\n\r\n        emit buyLevelEvent(msg.sender, _level, now, 3);\r\n    }\r\n\r\n    function payForLevelMatrix1(uint _level, address _user) internal {\r\n        address actualReferer;\r\n        address tempReferer1;\r\n        address tempReferer2;\r\n        uint userID;\r\n\r\n        if(_level == 1) {\r\n            actualReferer = userList[users[_user].referrerIDMatrix1];\r\n            userID = users[actualReferer].id;\r\n        }\r\n        else if(_level == 2) {\r\n            tempReferer1 = userList[users[_user].referrerIDMatrix1];\r\n            actualReferer = userList[users[tempReferer1].referrerIDMatrix1];\r\n            userID = users[actualReferer].id;\r\n        }\r\n        else if(_level == 3) {\r\n            tempReferer1 = userList[users[_user].referrerIDMatrix1];\r\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix1];\r\n            actualReferer = userList[users[tempReferer2].referrerIDMatrix1];\r\n            userID = users[actualReferer].id;\r\n        }\r\n        else if(_level == 4) {\r\n            tempReferer1 = userList[users[_user].referrerIDMatrix1];\r\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix1];\r\n            tempReferer1 = userList[users[tempReferer2].referrerIDMatrix1];\r\n            actualReferer = userList[users[tempReferer1].referrerIDMatrix1];\r\n            userID = users[actualReferer].id;\r\n        }\r\n        else if(_level == 5) {\r\n            tempReferer1 = userList[users[_user].referrerIDMatrix1];\r\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix1];\r\n            tempReferer1 = userList[users[tempReferer2].referrerIDMatrix1];\r\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix1];\r\n            actualReferer = userList[users[tempReferer2].referrerIDMatrix1];\r\n            userID = users[actualReferer].id;\r\n        }\r\n        else if(_level == 6) {\r\n            tempReferer1 = userList[users[_user].referrerIDMatrix1];\r\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix1];\r\n            tempReferer1 = userList[users[tempReferer2].referrerIDMatrix1];\r\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix1];\r\n            tempReferer1 = userList[users[tempReferer2].referrerIDMatrix1];\r\n            actualReferer = userList[users[tempReferer1].referrerIDMatrix1];\r\n            userID = users[actualReferer].id;\r\n        }\r\n\r\n        if(!users[actualReferer].isExist) actualReferer = userList[1];\r\n\r\n        bool sent = false;\r\n        \r\n        if(userID > 0 && userID <= 63) {\r\n           for(uint i=0; i < shareHoldersM1.length; i++) {\r\n                address(uint160(shareHoldersM1[i])).transfer(LEVEL_PRICE[_level]/(shareHoldersM1.length));\r\n                emit getMoneyForLevelEvent(shareHoldersM1[i], msg.sender, _level, now, 1);\r\n            }\r\n            if(address(this).balance > 0)\r\n                address(uint160(userList[1])).transfer(address(this).balance);\r\n          }\r\n        \r\n        else{\r\n          if(users[actualReferer].levelExpiredMatrix1[_level] >= now && users[actualReferer].referralCounter >= 2) {\r\n              sent = address(uint160(actualReferer)).send(LEVEL_PRICE[_level]);\r\n                if (sent) {\r\n                        emit getMoneyForLevelEvent(actualReferer, msg.sender, _level, now, 1);\r\n                    }\r\n                }\r\n            if(!sent) {\r\n              emit lostMoneyForLevelEvent(actualReferer, msg.sender, _level, now, 1);\r\n                payForLevelMatrix1(_level, actualReferer);\r\n             }\r\n\r\n        }\r\n            \r\n    }\r\n\r\n    function payForLevelMatrix2(uint _level, address _user) internal {\r\n        address actualReferer;\r\n        address tempReferer1;\r\n        address tempReferer2;\r\n        uint userID;\r\n\r\n        if(_level == 1) {\r\n            actualReferer = userList[users[_user].referrerIDMatrix2];\r\n            userID = users[actualReferer].id;\r\n        }\r\n        else if(_level == 2) {\r\n            tempReferer1 = userList[users[_user].referrerIDMatrix2];\r\n            actualReferer = userList[users[tempReferer1].referrerIDMatrix2];\r\n            userID = users[actualReferer].id;\r\n        }\r\n        else if(_level == 3) {\r\n            tempReferer1 = userList[users[_user].referrerIDMatrix2];\r\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix2];\r\n            actualReferer = userList[users[tempReferer2].referrerIDMatrix2];\r\n            userID = users[actualReferer].id;\r\n        }\r\n        else if(_level == 4) {\r\n            tempReferer1 = userList[users[_user].referrerIDMatrix2];\r\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix2];\r\n            tempReferer1 = userList[users[tempReferer2].referrerIDMatrix2];\r\n            actualReferer = userList[users[tempReferer1].referrerIDMatrix2];\r\n            userID = users[actualReferer].id;\r\n        }\r\n        else if(_level == 5) {\r\n            tempReferer1 = userList[users[_user].referrerIDMatrix2];\r\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix2];\r\n            tempReferer1 = userList[users[tempReferer2].referrerIDMatrix2];\r\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix2];\r\n            actualReferer = userList[users[tempReferer2].referrerIDMatrix2];\r\n            userID = users[actualReferer].id;\r\n        }\r\n        else if(_level == 6) {\r\n            tempReferer1 = userList[users[_user].referrerIDMatrix2];\r\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix2];\r\n            tempReferer1 = userList[users[tempReferer2].referrerIDMatrix2];\r\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix2];\r\n            tempReferer1 = userList[users[tempReferer2].referrerIDMatrix2];\r\n            actualReferer = userList[users[tempReferer1].referrerIDMatrix2];\r\n            userID = users[actualReferer].id;\r\n        }\r\n\r\n        if(!users[actualReferer].isExist) actualReferer = userList[1];\r\n\r\n        bool sent = false;\r\n        \r\n        if(userID > 0 && userID <= 63) {\r\n           for(uint i=0; i < shareHoldersM2.length; i++) {\r\n                address(uint160(shareHoldersM2[i])).transfer(LEVEL_PRICE[_level]/(shareHoldersM2.length));\r\n                emit getMoneyForLevelEvent(shareHoldersM2[i], msg.sender, _level, now, 2);\r\n            }\r\n            if(address(this).balance > 0)\r\n                address(uint160(userList[1])).transfer(address(this).balance);\r\n          }\r\n        \r\n        else{\r\n          if(users[actualReferer].levelExpiredMatrix2[_level] >= now) {\r\n              sent = address(uint160(actualReferer)).send(LEVEL_PRICE[_level]);\r\n                if (sent) {\r\n                        emit getMoneyForLevelEvent(actualReferer, msg.sender, _level, now, 2);\r\n                    }\r\n                }\r\n            if(!sent) {\r\n              emit lostMoneyForLevelEvent(actualReferer, msg.sender, _level, now, 2);\r\n                payForLevelMatrix2(_level, actualReferer);\r\n             }\r\n        }\r\n            \r\n    }\r\n\r\n    function payForLevelMatrix3(uint _level, address _user) internal {\r\n        uint height = _level;\r\n        address referrer = getUserUpline(_user, height);\r\n\r\n        if (referrer == address(0)) { referrer = userList[1]; }\r\n    \r\n        uint uplines = uplinesToRcvEth[_level];\r\n        bool chkLostProfit = false;\r\n        for (uint i = 1; i <= uplines; i++) {\r\n            referrer = getUserUpline(_user, i);\r\n          \r\n            if (viewUserLevelExpiredMatrix3(referrer, _level) < now) {\r\n                chkLostProfit = true;\r\n                uplines++;\r\n                emit lostMoneyForLevelEvent(referrer, msg.sender, _level, now, 3);\r\n                continue;\r\n            }\r\n            else {chkLostProfit = false;}\r\n            \r\n            if (referrer == address(0)) { referrer = userList[1]; }\r\n\r\n            if(users[referrer].id >0 && users[referrer].id <= 63){\r\n                \r\n                uint test = (uplines - i) + 1;\r\n                uint totalValue = test * (LEVEL_PRICEM3[_level]/uplinesToRcvEth[_level]);\r\n                \r\n                for(uint j=0; j < shareHoldersM3.length; j++) {\r\n                        address(uint160(shareHoldersM3[j])).transfer(totalValue/(shareHoldersM3.length));\r\n                        emit getMoneyForLevelEvent(shareHoldersM3[j], msg.sender, _level, now, 3);\r\n                    }\r\n                    break;\r\n                    \r\n            }\r\n            else {\r\n                if (address(uint160(referrer)).send( LEVEL_PRICEM3[_level] / uplinesToRcvEth[_level] )) {               \r\n                    emit getMoneyForLevelEvent(referrer, msg.sender, _level, now, 3);\r\n                }\r\n            }               \r\n    }\r\n            if(address(this).balance > 0)\r\n                address(uint160(userList[1])).transfer(address(this).balance);\r\n          \r\n  }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n     /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"New owner cannot be the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Read only function to see the 2 children of a node in Company forced matrix\r\n     * @return 2 branches\r\n     */\r\n    function viewUserReferralMatrix1(address _user) public view returns(address[] memory) {\r\n        return users[_user].referralMatrix1;\r\n    }\r\n\r\n    /**\r\n     * @dev Read only function to see the 2 children of a node in Team Matrix\r\n     * @return 2 branches\r\n     */\r\n    function viewUserReferralMatrix2(address _user) public view returns(address[] memory) {\r\n        return users[_user].referralMatrix2;\r\n    }\r\n    \r\n    /**\r\n     * @dev Read only function to see the expiration time of a particular level in Company forced Matrix\r\n     * @return unix timestamp\r\n     */\r\n    function viewUserLevelExpiredMatrix1(address _user, uint _level) public view returns(uint256) {\r\n        return users[_user].levelExpiredMatrix1[_level];\r\n    }\r\n\r\n    /**\r\n     * @dev Read only function to see the expiration time of a particular level in Team Matrix\r\n     * @return unix timestamp\r\n     */\r\n    function viewUserLevelExpiredMatrix2(address _user, uint _level) public view returns(uint256) {\r\n        return users[_user].levelExpiredMatrix2[_level];\r\n    }\r\n\r\n    /**\r\n     * @dev Read only function to see the expiration time of a particular level in Hybrid Matrix\r\n     * @return unix timestamp\r\n     */\r\n    function viewUserLevelExpiredMatrix3(address _user, uint _level) public view returns(uint256) {\r\n        return users[_user].levelExpiredMatrix3[_level];\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_shareHolderAddress\",\"type\":\"address\"}],\"name\":\"removeShareHolderM2\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LEVEL_PRICEM3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availablePersonID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"shareHoldersM1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newSC\",\"outputs\":[{\"internalType\":\"contract Etrix\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_shareHolderAddress\",\"type\":\"address\"}],\"name\":\"removeShareHolderM3\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"viewUserLevelExpiredMatrix3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"shareHoldersM2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"buyLevelMatrix2\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"syncClose\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_availablePersonID\",\"type\":\"uint256\"}],\"name\":\"changeAvailablePerson\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_shareHolderAddress\",\"type\":\"address[]\"}],\"name\":\"addShareHolderM3\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"buyLevelMatrix1\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"findAvailablePersonMatrix2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"buyLevelMatrix3\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewUserReferralMatrix1\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"viewUserLevelExpiredMatrix2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LEVEL_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_referrerID\",\"type\":\"uint256\"}],\"name\":\"regUser\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_referrerID\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_userAddress\",\"type\":\"address[]\"}],\"name\":\"regExtraUsers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oldSC\",\"outputs\":[{\"internalType\":\"contract Etrix\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_shareHolderAddress\",\"type\":\"address[]\"}],\"name\":\"addShareHolderM2\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"viewUserLevelExpiredMatrix1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REFERRAL_COMMISSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currUserID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isExist\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerIDMatrix1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerIDMatrix2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralCounter\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"shareHoldersM3\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oldSCUserId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_shareHolderAddress\",\"type\":\"address[]\"}],\"name\":\"addShareHolderM1\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_adminAddress\",\"type\":\"address[]\"}],\"name\":\"preRegAdmins\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"height\",\"type\":\"uint256\"}],\"name\":\"getUserUpline\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"syncWithOldSC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_shareHolderAddress\",\"type\":\"address\"}],\"name\":\"removeShareHolderM1\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uplinesToRcvEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewUserReferralMatrix2\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"regLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_matrix\",\"type\":\"uint256\"}],\"name\":\"buyLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"prolongateLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_matrix\",\"type\":\"uint256\"}],\"name\":\"getMoneyForLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_matrix\",\"type\":\"uint256\"}],\"name\":\"lostMoneyForLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"syncComplete\",\"type\":\"event\"}]","ContractName":"Etrix","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://38a76470c67802c92d64568113862ea495ad29e68d42efe011670b592923d6df"}]}