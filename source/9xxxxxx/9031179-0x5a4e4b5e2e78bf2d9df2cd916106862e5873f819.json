{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.13;\r\n\r\n/* Start of the Oraclize API, search for '<ENDORACLIZE>' to get to the main contract */\r\n\r\n/*\r\n\r\nORACLIZE_API\r\n\r\nCopyright (c) 2015-2016 Oraclize SRL\r\nCopyright (c) 2016 Oraclize LTD\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n\r\n*/\r\npragma solidity >= 0.5.0 < 0.6.0; // Incompatible compiler version - please select a compiler within the stated pragma range, or use a different version of the oraclizeAPI!\r\n\r\n// Dummy contract only used to emit to end-user they are using wrong solc\r\ncontract solcChecker {\r\n/* INCOMPATIBLE SOLC: import the following instead: \"github.com/oraclize/ethereum-api/oraclizeAPI_0.4.sol\" */ function f(bytes calldata x) external;\r\n}\r\n\r\ncontract OraclizeI {\r\n\r\n\t\taddress public cbAddress;\r\n\r\n\t\tfunction setProofType(byte _proofType) external;\r\n\t\tfunction setCustomGasPrice(uint _gasPrice) external;\r\n\t\tfunction getPrice(string memory _datasource) public returns (uint _dsprice);\r\n\t\tfunction randomDS_getSessionPubKeyHash() external view returns (bytes32 _sessionKeyHash);\r\n\t\tfunction getPrice(string memory _datasource, uint _gasLimit) public returns (uint _dsprice);\r\n\t\tfunction queryN(uint _timestamp, string memory _datasource, bytes memory _argN) public payable returns (bytes32 _id);\r\n\t\tfunction query(uint _timestamp, string calldata _datasource, string calldata _arg) external payable returns (bytes32 _id);\r\n\t\tfunction query2(uint _timestamp, string memory _datasource, string memory _arg1, string memory _arg2) public payable returns (bytes32 _id);\r\n\t\tfunction query_withGasLimit(uint _timestamp, string calldata _datasource, string calldata _arg, uint _gasLimit) external payable returns (bytes32 _id);\r\n\t\tfunction queryN_withGasLimit(uint _timestamp, string calldata _datasource, bytes calldata _argN, uint _gasLimit) external payable returns (bytes32 _id);\r\n\t\tfunction query2_withGasLimit(uint _timestamp, string calldata _datasource, string calldata _arg1, string calldata _arg2, uint _gasLimit) external payable returns (bytes32 _id);\r\n}\r\n\r\ncontract OraclizeAddrResolverI {\r\n\t\tfunction getAddress() public returns (address _address);\r\n}\r\n/*\r\n\r\nBegin solidity-cborutils\r\n\r\nhttps://github.com/smartcontractkit/solidity-cborutils\r\n\r\nMIT License\r\n\r\nCopyright (c) 2018 SmartContract ChainLink, Ltd.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n\r\n*/\r\nlibrary Buffer {\r\n\r\n\t\tstruct buffer {\r\n\t\t\t\tbytes buf;\r\n\t\t\t\tuint capacity;\r\n\t\t}\r\n\r\n\t\tfunction init(buffer memory _buf, uint _capacity) internal pure {\r\n\t\t\t\tuint capacity = _capacity;\r\n\t\t\t\tif (capacity % 32 != 0) {\r\n\t\t\t\t\t\tcapacity += 32 - (capacity % 32);\r\n\t\t\t\t}\r\n\t\t\t\t_buf.capacity = capacity; // Allocate space for the buffer data\r\n\t\t\t\tassembly {\r\n\t\t\t\t\t\tlet ptr := mload(0x40)\r\n\t\t\t\t\t\tmstore(_buf, ptr)\r\n\t\t\t\t\t\tmstore(ptr, 0)\r\n\t\t\t\t\t\tmstore(0x40, add(ptr, capacity))\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction resize(buffer memory _buf, uint _capacity) private pure {\r\n\t\t\t\tbytes memory oldbuf = _buf.buf;\r\n\t\t\t\tinit(_buf, _capacity);\r\n\t\t\t\tappend(_buf, oldbuf);\r\n\t\t}\r\n\r\n\t\tfunction max(uint _a, uint _b) private pure returns (uint _max) {\r\n\t\t\t\tif (_a > _b) {\r\n\t\t\t\t\t\treturn _a;\r\n\t\t\t\t}\r\n\t\t\t\treturn _b;\r\n\t\t}\r\n\t\t/**\r\n\t\t\t* @dev Appends a byte array to the end of the buffer. Resizes if doing so\r\n\t\t\t*      would exceed the capacity of the buffer.\r\n\t\t\t* @param _buf The buffer to append to.\r\n\t\t\t* @param _data The data to append.\r\n\t\t\t* @return The original buffer.\r\n\t\t\t*\r\n\t\t\t*/\r\n\t\tfunction append(buffer memory _buf, bytes memory _data) internal pure returns (buffer memory _buffer) {\r\n\t\t\t\tif (_data.length + _buf.buf.length > _buf.capacity) {\r\n\t\t\t\t\t\tresize(_buf, max(_buf.capacity, _data.length) * 2);\r\n\t\t\t\t}\r\n\t\t\t\tuint dest;\r\n\t\t\t\tuint src;\r\n\t\t\t\tuint len = _data.length;\r\n\t\t\t\tassembly {\r\n\t\t\t\t\t\tlet bufptr := mload(_buf) // Memory address of the buffer data\r\n\t\t\t\t\t\tlet buflen := mload(bufptr) // Length of existing buffer data\r\n\t\t\t\t\t\tdest := add(add(bufptr, buflen), 32) // Start address = buffer address + buffer length + sizeof(buffer length)\r\n\t\t\t\t\t\tmstore(bufptr, add(buflen, mload(_data))) // Update buffer length\r\n\t\t\t\t\t\tsrc := add(_data, 32)\r\n\t\t\t\t}\r\n\t\t\t\tfor(; len >= 32; len -= 32) { // Copy word-length chunks while possible\r\n\t\t\t\t\t\tassembly {\r\n\t\t\t\t\t\t\t\tmstore(dest, mload(src))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tdest += 32;\r\n\t\t\t\t\t\tsrc += 32;\r\n\t\t\t\t}\r\n\t\t\t\tuint mask = 256 ** (32 - len) - 1; // Copy remaining bytes\r\n\t\t\t\tassembly {\r\n\t\t\t\t\t\tlet srcpart := and(mload(src), not(mask))\r\n\t\t\t\t\t\tlet destpart := and(mload(dest), mask)\r\n\t\t\t\t\t\tmstore(dest, or(destpart, srcpart))\r\n\t\t\t\t}\r\n\t\t\t\treturn _buf;\r\n\t\t}\r\n\t\t/**\r\n\t\t\t*\r\n\t\t\t* @dev Appends a byte to the end of the buffer. Resizes if doing so would\r\n\t\t\t* exceed the capacity of the buffer.\r\n\t\t\t* @param _buf The buffer to append to.\r\n\t\t\t* @param _data The data to append.\r\n\t\t\t* @return The original buffer.\r\n\t\t\t*\r\n\t\t\t*/\r\n\t\tfunction append(buffer memory _buf, uint8 _data) internal pure {\r\n\t\t\t\tif (_buf.buf.length + 1 > _buf.capacity) {\r\n\t\t\t\t\t\tresize(_buf, _buf.capacity * 2);\r\n\t\t\t\t}\r\n\t\t\t\tassembly {\r\n\t\t\t\t\t\tlet bufptr := mload(_buf) // Memory address of the buffer data\r\n\t\t\t\t\t\tlet buflen := mload(bufptr) // Length of existing buffer data\r\n\t\t\t\t\t\tlet dest := add(add(bufptr, buflen), 32) // Address = buffer address + buffer length + sizeof(buffer length)\r\n\t\t\t\t\t\tmstore8(dest, _data)\r\n\t\t\t\t\t\tmstore(bufptr, add(buflen, 1)) // Update buffer length\r\n\t\t\t\t}\r\n\t\t}\r\n\t\t/**\r\n\t\t\t*\r\n\t\t\t* @dev Appends a byte to the end of the buffer. Resizes if doing so would\r\n\t\t\t* exceed the capacity of the buffer.\r\n\t\t\t* @param _buf The buffer to append to.\r\n\t\t\t* @param _data The data to append.\r\n\t\t\t* @return The original buffer.\r\n\t\t\t*\r\n\t\t\t*/\r\n\t\tfunction appendInt(buffer memory _buf, uint _data, uint _len) internal pure returns (buffer memory _buffer) {\r\n\t\t\t\tif (_len + _buf.buf.length > _buf.capacity) {\r\n\t\t\t\t\t\tresize(_buf, max(_buf.capacity, _len) * 2);\r\n\t\t\t\t}\r\n\t\t\t\tuint mask = 256 ** _len - 1;\r\n\t\t\t\tassembly {\r\n\t\t\t\t\t\tlet bufptr := mload(_buf) // Memory address of the buffer data\r\n\t\t\t\t\t\tlet buflen := mload(bufptr) // Length of existing buffer data\r\n\t\t\t\t\t\tlet dest := add(add(bufptr, buflen), _len) // Address = buffer address + buffer length + sizeof(buffer length) + len\r\n\t\t\t\t\t\tmstore(dest, or(and(mload(dest), not(mask)), _data))\r\n\t\t\t\t\t\tmstore(bufptr, add(buflen, _len)) // Update buffer length\r\n\t\t\t\t}\r\n\t\t\t\treturn _buf;\r\n\t\t}\r\n}\r\n\r\nlibrary CBOR {\r\n\r\n\t\tusing Buffer for Buffer.buffer;\r\n\r\n\t\tuint8 private constant MAJOR_TYPE_INT = 0;\r\n\t\tuint8 private constant MAJOR_TYPE_MAP = 5;\r\n\t\tuint8 private constant MAJOR_TYPE_BYTES = 2;\r\n\t\tuint8 private constant MAJOR_TYPE_ARRAY = 4;\r\n\t\tuint8 private constant MAJOR_TYPE_STRING = 3;\r\n\t\tuint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\r\n\t\tuint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\r\n\r\n\t\tfunction encodeType(Buffer.buffer memory _buf, uint8 _major, uint _value) private pure {\r\n\t\t\t\tif (_value <= 23) {\r\n\t\t\t\t\t\t_buf.append(uint8((_major << 5) | _value));\r\n\t\t\t\t} else if (_value <= 0xFF) {\r\n\t\t\t\t\t\t_buf.append(uint8((_major << 5) | 24));\r\n\t\t\t\t\t\t_buf.appendInt(_value, 1);\r\n\t\t\t\t} else if (_value <= 0xFFFF) {\r\n\t\t\t\t\t\t_buf.append(uint8((_major << 5) | 25));\r\n\t\t\t\t\t\t_buf.appendInt(_value, 2);\r\n\t\t\t\t} else if (_value <= 0xFFFFFFFF) {\r\n\t\t\t\t\t\t_buf.append(uint8((_major << 5) | 26));\r\n\t\t\t\t\t\t_buf.appendInt(_value, 4);\r\n\t\t\t\t} else if (_value <= 0xFFFFFFFFFFFFFFFF) {\r\n\t\t\t\t\t\t_buf.append(uint8((_major << 5) | 27));\r\n\t\t\t\t\t\t_buf.appendInt(_value, 8);\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction encodeIndefiniteLengthType(Buffer.buffer memory _buf, uint8 _major) private pure {\r\n\t\t\t\t_buf.append(uint8((_major << 5) | 31));\r\n\t\t}\r\n\r\n\t\tfunction encodeUInt(Buffer.buffer memory _buf, uint _value) internal pure {\r\n\t\t\t\tencodeType(_buf, MAJOR_TYPE_INT, _value);\r\n\t\t}\r\n\r\n\t\tfunction encodeInt(Buffer.buffer memory _buf, int _value) internal pure {\r\n\t\t\t\tif (_value >= 0) {\r\n\t\t\t\t\t\tencodeType(_buf, MAJOR_TYPE_INT, uint(_value));\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\tencodeType(_buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - _value));\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction encodeBytes(Buffer.buffer memory _buf, bytes memory _value) internal pure {\r\n\t\t\t\tencodeType(_buf, MAJOR_TYPE_BYTES, _value.length);\r\n\t\t\t\t_buf.append(_value);\r\n\t\t}\r\n\r\n\t\tfunction encodeString(Buffer.buffer memory _buf, string memory _value) internal pure {\r\n\t\t\t\tencodeType(_buf, MAJOR_TYPE_STRING, bytes(_value).length);\r\n\t\t\t\t_buf.append(bytes(_value));\r\n\t\t}\r\n\r\n\t\tfunction startArray(Buffer.buffer memory _buf) internal pure {\r\n\t\t\t\tencodeIndefiniteLengthType(_buf, MAJOR_TYPE_ARRAY);\r\n\t\t}\r\n\r\n\t\tfunction startMap(Buffer.buffer memory _buf) internal pure {\r\n\t\t\t\tencodeIndefiniteLengthType(_buf, MAJOR_TYPE_MAP);\r\n\t\t}\r\n\r\n\t\tfunction endSequence(Buffer.buffer memory _buf) internal pure {\r\n\t\t\t\tencodeIndefiniteLengthType(_buf, MAJOR_TYPE_CONTENT_FREE);\r\n\t\t}\r\n}\r\n/*\r\n\r\nEnd solidity-cborutils\r\n\r\n*/\r\ncontract usingOraclize {\r\n\r\n\t\tusing CBOR for Buffer.buffer;\r\n\r\n\t\tOraclizeI oraclize;\r\n\t\tOraclizeAddrResolverI OAR;\r\n\r\n\t\tuint constant day = 60 * 60 * 24;\r\n\t\tuint constant week = 60 * 60 * 24 * 7;\r\n\t\tuint constant month = 60 * 60 * 24 * 30;\r\n\r\n\t\tbyte constant proofType_NONE = 0x00;\r\n\t\tbyte constant proofType_Ledger = 0x30;\r\n\t\tbyte constant proofType_Native = 0xF0;\r\n\t\tbyte constant proofStorage_IPFS = 0x01;\r\n\t\tbyte constant proofType_Android = 0x40;\r\n\t\tbyte constant proofType_TLSNotary = 0x10;\r\n\r\n\t\tstring oraclize_network_name;\r\n\t\tuint8 constant networkID_auto = 0;\r\n\t\tuint8 constant networkID_morden = 2;\r\n\t\tuint8 constant networkID_mainnet = 1;\r\n\t\tuint8 constant networkID_testnet = 2;\r\n\t\tuint8 constant networkID_consensys = 161;\r\n\r\n\t\tmapping(bytes32 => bytes32) oraclize_randomDS_args;\r\n\t\tmapping(bytes32 => bool) oraclize_randomDS_sessionKeysHashVerified;\r\n\r\n\t\tmodifier oraclizeAPI {\r\n\t\t\t\tif ((address(OAR) == address(0)) || (getCodeSize(address(OAR)) == 0)) {\r\n\t\t\t\t\t\toraclize_setNetwork(networkID_auto);\r\n\t\t\t\t}\r\n\t\t\t\tif (address(oraclize) != OAR.getAddress()) {\r\n\t\t\t\t\t\toraclize = OraclizeI(OAR.getAddress());\r\n\t\t\t\t}\r\n\t\t\t\t_;\r\n\t\t}\r\n\r\n\t\tmodifier oraclize_randomDS_proofVerify(bytes32 _queryId, string memory _result, bytes memory _proof) {\r\n\t\t\t\t// RandomDS Proof Step 1: The prefix has to match 'LP\\x01' (Ledger Proof version 1)\r\n\t\t\t\trequire((_proof[0] == \"L\") && (_proof[1] == \"P\") && (uint8(_proof[2]) == uint8(1)));\r\n\t\t\t\tbool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\r\n\t\t\t\trequire(proofVerified);\r\n\t\t\t\t_;\r\n\t\t}\r\n\r\n\t\tfunction oraclize_setNetwork(uint8 _networkID) internal returns (bool _networkSet) {\r\n\t\t\t_networkID; // NOTE: Silence the warning and remain backwards compatible\r\n\t\t\treturn oraclize_setNetwork();\r\n\t\t}\r\n\r\n\t\tfunction oraclize_setNetworkName(string memory _network_name) internal {\r\n\t\t\t\toraclize_network_name = _network_name;\r\n\t\t}\r\n\r\n\t\tfunction oraclize_getNetworkName() internal view returns (string memory _networkName) {\r\n\t\t\t\treturn oraclize_network_name;\r\n\t\t}\r\n\r\n\t\tfunction oraclize_setNetwork() internal returns (bool _networkSet) {\r\n\t\t\t\tif (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed) > 0) { //mainnet\r\n\t\t\t\t\t\tOAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\r\n\t\t\t\t\t\toraclize_setNetworkName(\"eth_mainnet\");\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\tif (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1) > 0) { //ropsten testnet\r\n\t\t\t\t\t\tOAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\r\n\t\t\t\t\t\toraclize_setNetworkName(\"eth_ropsten3\");\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\tif (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e) > 0) { //kovan testnet\r\n\t\t\t\t\t\tOAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\r\n\t\t\t\t\t\toraclize_setNetworkName(\"eth_kovan\");\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\tif (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48) > 0) { //rinkeby testnet\r\n\t\t\t\t\t\tOAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\r\n\t\t\t\t\t\toraclize_setNetworkName(\"eth_rinkeby\");\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\tif (getCodeSize(0xa2998EFD205FB9D4B4963aFb70778D6354ad3A41) > 0) { //goerli testnet\r\n\t\t\t\t\t\tOAR = OraclizeAddrResolverI(0xa2998EFD205FB9D4B4963aFb70778D6354ad3A41);\r\n\t\t\t\t\t\toraclize_setNetworkName(\"eth_goerli\");\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\tif (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475) > 0) { //ethereum-bridge\r\n\t\t\t\t\t\tOAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\tif (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF) > 0) { //ether.camp ide\r\n\t\t\t\t\t\tOAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\tif (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA) > 0) { //browser-solidity\r\n\t\t\t\t\t\tOAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t\t/**\r\n\t\t * @dev The following `__callback` functions are just placeholders ideally\r\n\t\t *      meant to be defined in child contract when proofs are used.\r\n\t\t *      The function bodies simply silence compiler warnings.\r\n\t\t */\r\n\t\tfunction __callback(bytes32 _myid, string memory _result) public {\r\n\t\t\t\t__callback(_myid, _result, new bytes(0));\r\n\t\t}\r\n\r\n\t\tfunction __callback(bytes32 _myid, string memory _result, bytes memory _proof) public {\r\n\t\t\t_myid; _result; _proof;\r\n\t\t\toraclize_randomDS_args[bytes32(0)] = bytes32(0);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_getPrice(string memory _datasource) oraclizeAPI internal returns (uint _queryPrice) {\r\n\t\t\t\treturn oraclize.getPrice(_datasource);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_getPrice(string memory _datasource, uint _gasLimit) oraclizeAPI internal returns (uint _queryPrice) {\r\n\t\t\t\treturn oraclize.getPrice(_datasource, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, string memory _arg) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tuint price = oraclize.getPrice(_datasource);\r\n\t\t\t\tif (price > 1 ether + tx.gasprice * 200000) {\r\n\t\t\t\t\t\treturn 0; // Unexpectedly high price\r\n\t\t\t\t}\r\n\t\t\t\treturn oraclize.query.value(price)(0, _datasource, _arg);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, string memory _arg) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tuint price = oraclize.getPrice(_datasource);\r\n\t\t\t\tif (price > 1 ether + tx.gasprice * 200000) {\r\n\t\t\t\t\t\treturn 0; // Unexpectedly high price\r\n\t\t\t\t}\r\n\t\t\t\treturn oraclize.query.value(price)(_timestamp, _datasource, _arg);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, string memory _arg, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tuint price = oraclize.getPrice(_datasource,_gasLimit);\r\n\t\t\t\tif (price > 1 ether + tx.gasprice * _gasLimit) {\r\n\t\t\t\t\t\treturn 0; // Unexpectedly high price\r\n\t\t\t\t}\r\n\t\t\t\treturn oraclize.query_withGasLimit.value(price)(_timestamp, _datasource, _arg, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, string memory _arg, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tuint price = oraclize.getPrice(_datasource, _gasLimit);\r\n\t\t\t\tif (price > 1 ether + tx.gasprice * _gasLimit) {\r\n\t\t\t\t\t return 0; // Unexpectedly high price\r\n\t\t\t\t}\r\n\t\t\t\treturn oraclize.query_withGasLimit.value(price)(0, _datasource, _arg, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, string memory _arg1, string memory _arg2) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tuint price = oraclize.getPrice(_datasource);\r\n\t\t\t\tif (price > 1 ether + tx.gasprice * 200000) {\r\n\t\t\t\t\t\treturn 0; // Unexpectedly high price\r\n\t\t\t\t}\r\n\t\t\t\treturn oraclize.query2.value(price)(0, _datasource, _arg1, _arg2);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, string memory _arg1, string memory _arg2) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tuint price = oraclize.getPrice(_datasource);\r\n\t\t\t\tif (price > 1 ether + tx.gasprice * 200000) {\r\n\t\t\t\t\t\treturn 0; // Unexpectedly high price\r\n\t\t\t\t}\r\n\t\t\t\treturn oraclize.query2.value(price)(_timestamp, _datasource, _arg1, _arg2);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, string memory _arg1, string memory _arg2, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tuint price = oraclize.getPrice(_datasource, _gasLimit);\r\n\t\t\t\tif (price > 1 ether + tx.gasprice * _gasLimit) {\r\n\t\t\t\t\t\treturn 0; // Unexpectedly high price\r\n\t\t\t\t}\r\n\t\t\t\treturn oraclize.query2_withGasLimit.value(price)(_timestamp, _datasource, _arg1, _arg2, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, string memory _arg1, string memory _arg2, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tuint price = oraclize.getPrice(_datasource, _gasLimit);\r\n\t\t\t\tif (price > 1 ether + tx.gasprice * _gasLimit) {\r\n\t\t\t\t\t\treturn 0; // Unexpectedly high price\r\n\t\t\t\t}\r\n\t\t\t\treturn oraclize.query2_withGasLimit.value(price)(0, _datasource, _arg1, _arg2, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, string[] memory _argN) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tuint price = oraclize.getPrice(_datasource);\r\n\t\t\t\tif (price > 1 ether + tx.gasprice * 200000) {\r\n\t\t\t\t\t\treturn 0; // Unexpectedly high price\r\n\t\t\t\t}\r\n\t\t\t\tbytes memory args = stra2cbor(_argN);\r\n\t\t\t\treturn oraclize.queryN.value(price)(0, _datasource, args);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, string[] memory _argN) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tuint price = oraclize.getPrice(_datasource);\r\n\t\t\t\tif (price > 1 ether + tx.gasprice * 200000) {\r\n\t\t\t\t\t\treturn 0; // Unexpectedly high price\r\n\t\t\t\t}\r\n\t\t\t\tbytes memory args = stra2cbor(_argN);\r\n\t\t\t\treturn oraclize.queryN.value(price)(_timestamp, _datasource, args);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, string[] memory _argN, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tuint price = oraclize.getPrice(_datasource, _gasLimit);\r\n\t\t\t\tif (price > 1 ether + tx.gasprice * _gasLimit) {\r\n\t\t\t\t\t\treturn 0; // Unexpectedly high price\r\n\t\t\t\t}\r\n\t\t\t\tbytes memory args = stra2cbor(_argN);\r\n\t\t\t\treturn oraclize.queryN_withGasLimit.value(price)(_timestamp, _datasource, args, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, string[] memory _argN, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tuint price = oraclize.getPrice(_datasource, _gasLimit);\r\n\t\t\t\tif (price > 1 ether + tx.gasprice * _gasLimit) {\r\n\t\t\t\t\t\treturn 0; // Unexpectedly high price\r\n\t\t\t\t}\r\n\t\t\t\tbytes memory args = stra2cbor(_argN);\r\n\t\t\t\treturn oraclize.queryN_withGasLimit.value(price)(0, _datasource, args, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, string[1] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tstring[] memory dynargs = new string[](1);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\treturn oraclize_query(_datasource, dynargs);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, string[1] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tstring[] memory dynargs = new string[](1);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\treturn oraclize_query(_timestamp, _datasource, dynargs);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, string[1] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tstring[] memory dynargs = new string[](1);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\treturn oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, string[1] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tstring[] memory dynargs = new string[](1);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\treturn oraclize_query(_datasource, dynargs, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, string[2] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tstring[] memory dynargs = new string[](2);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\treturn oraclize_query(_datasource, dynargs);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, string[2] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tstring[] memory dynargs = new string[](2);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\treturn oraclize_query(_timestamp, _datasource, dynargs);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, string[2] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tstring[] memory dynargs = new string[](2);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\treturn oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, string[2] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tstring[] memory dynargs = new string[](2);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\treturn oraclize_query(_datasource, dynargs, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, string[3] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tstring[] memory dynargs = new string[](3);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\treturn oraclize_query(_datasource, dynargs);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, string[3] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tstring[] memory dynargs = new string[](3);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\treturn oraclize_query(_timestamp, _datasource, dynargs);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, string[3] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tstring[] memory dynargs = new string[](3);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\treturn oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, string[3] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tstring[] memory dynargs = new string[](3);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\treturn oraclize_query(_datasource, dynargs, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, string[4] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tstring[] memory dynargs = new string[](4);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\tdynargs[3] = _args[3];\r\n\t\t\t\treturn oraclize_query(_datasource, dynargs);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, string[4] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tstring[] memory dynargs = new string[](4);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\tdynargs[3] = _args[3];\r\n\t\t\t\treturn oraclize_query(_timestamp, _datasource, dynargs);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, string[4] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tstring[] memory dynargs = new string[](4);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\tdynargs[3] = _args[3];\r\n\t\t\t\treturn oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, string[4] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tstring[] memory dynargs = new string[](4);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\tdynargs[3] = _args[3];\r\n\t\t\t\treturn oraclize_query(_datasource, dynargs, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, string[5] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tstring[] memory dynargs = new string[](5);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\tdynargs[3] = _args[3];\r\n\t\t\t\tdynargs[4] = _args[4];\r\n\t\t\t\treturn oraclize_query(_datasource, dynargs);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, string[5] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tstring[] memory dynargs = new string[](5);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\tdynargs[3] = _args[3];\r\n\t\t\t\tdynargs[4] = _args[4];\r\n\t\t\t\treturn oraclize_query(_timestamp, _datasource, dynargs);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, string[5] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tstring[] memory dynargs = new string[](5);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\tdynargs[3] = _args[3];\r\n\t\t\t\tdynargs[4] = _args[4];\r\n\t\t\t\treturn oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, string[5] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tstring[] memory dynargs = new string[](5);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\tdynargs[3] = _args[3];\r\n\t\t\t\tdynargs[4] = _args[4];\r\n\t\t\t\treturn oraclize_query(_datasource, dynargs, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, bytes[] memory _argN) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tuint price = oraclize.getPrice(_datasource);\r\n\t\t\t\tif (price > 1 ether + tx.gasprice * 200000) {\r\n\t\t\t\t\t\treturn 0; // Unexpectedly high price\r\n\t\t\t\t}\r\n\t\t\t\tbytes memory args = ba2cbor(_argN);\r\n\t\t\t\treturn oraclize.queryN.value(price)(0, _datasource, args);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, bytes[] memory _argN) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tuint price = oraclize.getPrice(_datasource);\r\n\t\t\t\tif (price > 1 ether + tx.gasprice * 200000) {\r\n\t\t\t\t\t\treturn 0; // Unexpectedly high price\r\n\t\t\t\t}\r\n\t\t\t\tbytes memory args = ba2cbor(_argN);\r\n\t\t\t\treturn oraclize.queryN.value(price)(_timestamp, _datasource, args);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, bytes[] memory _argN, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tuint price = oraclize.getPrice(_datasource, _gasLimit);\r\n\t\t\t\tif (price > 1 ether + tx.gasprice * _gasLimit) {\r\n\t\t\t\t\t\treturn 0; // Unexpectedly high price\r\n\t\t\t\t}\r\n\t\t\t\tbytes memory args = ba2cbor(_argN);\r\n\t\t\t\treturn oraclize.queryN_withGasLimit.value(price)(_timestamp, _datasource, args, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, bytes[] memory _argN, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tuint price = oraclize.getPrice(_datasource, _gasLimit);\r\n\t\t\t\tif (price > 1 ether + tx.gasprice * _gasLimit) {\r\n\t\t\t\t\t\treturn 0; // Unexpectedly high price\r\n\t\t\t\t}\r\n\t\t\t\tbytes memory args = ba2cbor(_argN);\r\n\t\t\t\treturn oraclize.queryN_withGasLimit.value(price)(0, _datasource, args, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, bytes[1] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tbytes[] memory dynargs = new bytes[](1);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\treturn oraclize_query(_datasource, dynargs);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, bytes[1] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tbytes[] memory dynargs = new bytes[](1);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\treturn oraclize_query(_timestamp, _datasource, dynargs);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, bytes[1] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tbytes[] memory dynargs = new bytes[](1);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\treturn oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, bytes[1] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tbytes[] memory dynargs = new bytes[](1);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\treturn oraclize_query(_datasource, dynargs, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, bytes[2] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tbytes[] memory dynargs = new bytes[](2);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\treturn oraclize_query(_datasource, dynargs);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, bytes[2] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tbytes[] memory dynargs = new bytes[](2);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\treturn oraclize_query(_timestamp, _datasource, dynargs);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, bytes[2] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tbytes[] memory dynargs = new bytes[](2);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\treturn oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, bytes[2] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tbytes[] memory dynargs = new bytes[](2);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\treturn oraclize_query(_datasource, dynargs, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, bytes[3] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tbytes[] memory dynargs = new bytes[](3);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\treturn oraclize_query(_datasource, dynargs);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, bytes[3] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tbytes[] memory dynargs = new bytes[](3);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\treturn oraclize_query(_timestamp, _datasource, dynargs);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, bytes[3] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tbytes[] memory dynargs = new bytes[](3);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\treturn oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, bytes[3] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tbytes[] memory dynargs = new bytes[](3);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\treturn oraclize_query(_datasource, dynargs, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, bytes[4] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tbytes[] memory dynargs = new bytes[](4);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\tdynargs[3] = _args[3];\r\n\t\t\t\treturn oraclize_query(_datasource, dynargs);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, bytes[4] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tbytes[] memory dynargs = new bytes[](4);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\tdynargs[3] = _args[3];\r\n\t\t\t\treturn oraclize_query(_timestamp, _datasource, dynargs);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, bytes[4] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tbytes[] memory dynargs = new bytes[](4);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\tdynargs[3] = _args[3];\r\n\t\t\t\treturn oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, bytes[4] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tbytes[] memory dynargs = new bytes[](4);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\tdynargs[3] = _args[3];\r\n\t\t\t\treturn oraclize_query(_datasource, dynargs, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, bytes[5] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tbytes[] memory dynargs = new bytes[](5);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\tdynargs[3] = _args[3];\r\n\t\t\t\tdynargs[4] = _args[4];\r\n\t\t\t\treturn oraclize_query(_datasource, dynargs);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, bytes[5] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tbytes[] memory dynargs = new bytes[](5);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\tdynargs[3] = _args[3];\r\n\t\t\t\tdynargs[4] = _args[4];\r\n\t\t\t\treturn oraclize_query(_timestamp, _datasource, dynargs);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(uint _timestamp, string memory _datasource, bytes[5] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tbytes[] memory dynargs = new bytes[](5);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\tdynargs[3] = _args[3];\r\n\t\t\t\tdynargs[4] = _args[4];\r\n\t\t\t\treturn oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_query(string memory _datasource, bytes[5] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n\t\t\t\tbytes[] memory dynargs = new bytes[](5);\r\n\t\t\t\tdynargs[0] = _args[0];\r\n\t\t\t\tdynargs[1] = _args[1];\r\n\t\t\t\tdynargs[2] = _args[2];\r\n\t\t\t\tdynargs[3] = _args[3];\r\n\t\t\t\tdynargs[4] = _args[4];\r\n\t\t\t\treturn oraclize_query(_datasource, dynargs, _gasLimit);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_setProof(byte _proofP) oraclizeAPI internal {\r\n\t\t\t\treturn oraclize.setProofType(_proofP);\r\n\t\t}\r\n\r\n\r\n\t\tfunction oraclize_cbAddress() oraclizeAPI internal returns (address _callbackAddress) {\r\n\t\t\t\treturn oraclize.cbAddress();\r\n\t\t}\r\n\r\n\t\tfunction getCodeSize(address _addr) view internal returns (uint _size) {\r\n\t\t\t\tassembly {\r\n\t\t\t\t\t\t_size := extcodesize(_addr)\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction oraclize_setCustomGasPrice(uint _gasPrice) oraclizeAPI internal {\r\n\t\t\t\treturn oraclize.setCustomGasPrice(_gasPrice);\r\n\t\t}\r\n\r\n\t\tfunction oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32 _sessionKeyHash) {\r\n\t\t\t\treturn oraclize.randomDS_getSessionPubKeyHash();\r\n\t\t}\r\n\r\n\t\tfunction parseAddr(string memory _a) internal pure returns (address _parsedAddress) {\r\n\t\t\t\tbytes memory tmp = bytes(_a);\r\n\t\t\t\tuint160 iaddr = 0;\r\n\t\t\t\tuint160 b1;\r\n\t\t\t\tuint160 b2;\r\n\t\t\t\tfor (uint i = 2; i < 2 + 2 * 20; i += 2) {\r\n\t\t\t\t\t\tiaddr *= 256;\r\n\t\t\t\t\t\tb1 = uint160(uint8(tmp[i]));\r\n\t\t\t\t\t\tb2 = uint160(uint8(tmp[i + 1]));\r\n\t\t\t\t\t\tif ((b1 >= 97) && (b1 <= 102)) {\r\n\t\t\t\t\t\t\t\tb1 -= 87;\r\n\t\t\t\t\t\t} else if ((b1 >= 65) && (b1 <= 70)) {\r\n\t\t\t\t\t\t\t\tb1 -= 55;\r\n\t\t\t\t\t\t} else if ((b1 >= 48) && (b1 <= 57)) {\r\n\t\t\t\t\t\t\t\tb1 -= 48;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ((b2 >= 97) && (b2 <= 102)) {\r\n\t\t\t\t\t\t\t\tb2 -= 87;\r\n\t\t\t\t\t\t} else if ((b2 >= 65) && (b2 <= 70)) {\r\n\t\t\t\t\t\t\t\tb2 -= 55;\r\n\t\t\t\t\t\t} else if ((b2 >= 48) && (b2 <= 57)) {\r\n\t\t\t\t\t\t\t\tb2 -= 48;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tiaddr += (b1 * 16 + b2);\r\n\t\t\t\t}\r\n\t\t\t\treturn address(iaddr);\r\n\t\t}\r\n\r\n\t\tfunction strCompare(string memory _a, string memory _b) internal pure returns (int _returnCode) {\r\n\t\t\t\tbytes memory a = bytes(_a);\r\n\t\t\t\tbytes memory b = bytes(_b);\r\n\t\t\t\tuint minLength = a.length;\r\n\t\t\t\tif (b.length < minLength) {\r\n\t\t\t\t\t\tminLength = b.length;\r\n\t\t\t\t}\r\n\t\t\t\tfor (uint i = 0; i < minLength; i ++) {\r\n\t\t\t\t\t\tif (a[i] < b[i]) {\r\n\t\t\t\t\t\t\t\treturn -1;\r\n\t\t\t\t\t\t} else if (a[i] > b[i]) {\r\n\t\t\t\t\t\t\t\treturn 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (a.length < b.length) {\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t} else if (a.length > b.length) {\r\n\t\t\t\t\t\treturn 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction indexOf(string memory _haystack, string memory _needle) internal pure returns (int _returnCode) {\r\n\t\t\t\tbytes memory h = bytes(_haystack);\r\n\t\t\t\tbytes memory n = bytes(_needle);\r\n\t\t\t\tif (h.length < 1 || n.length < 1 || (n.length > h.length)) {\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t} else if (h.length > (2 ** 128 - 1)) {\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\tuint subindex = 0;\r\n\t\t\t\t\t\tfor (uint i = 0; i < h.length; i++) {\r\n\t\t\t\t\t\t\t\tif (h[i] == n[0]) {\r\n\t\t\t\t\t\t\t\t\t\tsubindex = 1;\r\n\t\t\t\t\t\t\t\t\t\twhile(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tsubindex++;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tif (subindex == n.length) {\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn int(i);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction strConcat(string memory _a, string memory _b) internal pure returns (string memory _concatenatedString) {\r\n\t\t\t\treturn strConcat(_a, _b, \"\", \"\", \"\");\r\n\t\t}\r\n\r\n\t\tfunction strConcat(string memory _a, string memory _b, string memory _c) internal pure returns (string memory _concatenatedString) {\r\n\t\t\t\treturn strConcat(_a, _b, _c, \"\", \"\");\r\n\t\t}\r\n\r\n\t\tfunction strConcat(string memory _a, string memory _b, string memory _c, string memory _d) internal pure returns (string memory _concatenatedString) {\r\n\t\t\t\treturn strConcat(_a, _b, _c, _d, \"\");\r\n\t\t}\r\n\r\n\t\tfunction strConcat(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e) internal pure returns (string memory _concatenatedString) {\r\n\t\t\t\tbytes memory _ba = bytes(_a);\r\n\t\t\t\tbytes memory _bb = bytes(_b);\r\n\t\t\t\tbytes memory _bc = bytes(_c);\r\n\t\t\t\tbytes memory _bd = bytes(_d);\r\n\t\t\t\tbytes memory _be = bytes(_e);\r\n\t\t\t\tstring memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n\t\t\t\tbytes memory babcde = bytes(abcde);\r\n\t\t\t\tuint k = 0;\r\n\t\t\t\tuint i = 0;\r\n\t\t\t\tfor (i = 0; i < _ba.length; i++) {\r\n\t\t\t\t\t\tbabcde[k++] = _ba[i];\r\n\t\t\t\t}\r\n\t\t\t\tfor (i = 0; i < _bb.length; i++) {\r\n\t\t\t\t\t\tbabcde[k++] = _bb[i];\r\n\t\t\t\t}\r\n\t\t\t\tfor (i = 0; i < _bc.length; i++) {\r\n\t\t\t\t\t\tbabcde[k++] = _bc[i];\r\n\t\t\t\t}\r\n\t\t\t\tfor (i = 0; i < _bd.length; i++) {\r\n\t\t\t\t\t\tbabcde[k++] = _bd[i];\r\n\t\t\t\t}\r\n\t\t\t\tfor (i = 0; i < _be.length; i++) {\r\n\t\t\t\t\t\tbabcde[k++] = _be[i];\r\n\t\t\t\t}\r\n\t\t\t\treturn string(babcde);\r\n\t\t}\r\n\r\n\t\tfunction safeParseInt(string memory _a) internal pure returns (uint _parsedInt) {\r\n\t\t\t\treturn safeParseInt(_a, 0);\r\n\t\t}\r\n\r\n\t\tfunction safeParseInt(string memory _a, uint _b) internal pure returns (uint _parsedInt) {\r\n\t\t\t\tbytes memory bresult = bytes(_a);\r\n\t\t\t\tuint mint = 0;\r\n\t\t\t\tbool decimals = false;\r\n\t\t\t\tfor (uint i = 0; i < bresult.length; i++) {\r\n\t\t\t\t\t\tif ((uint(uint8(bresult[i])) >= 48) && (uint(uint8(bresult[i])) <= 57)) {\r\n\t\t\t\t\t\t\t\tif (decimals) {\r\n\t\t\t\t\t\t\t\t\t if (_b == 0) break;\r\n\t\t\t\t\t\t\t\t\t\telse _b--;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tmint *= 10;\r\n\t\t\t\t\t\t\t\tmint += uint(uint8(bresult[i])) - 48;\r\n\t\t\t\t\t\t} else if (uint(uint8(bresult[i])) == 46) {\r\n\t\t\t\t\t\t\t\trequire(!decimals, 'More than one decimal encountered in string!');\r\n\t\t\t\t\t\t\t\tdecimals = true;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\trevert(\"Non-numeral character encountered in string!\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (_b > 0) {\r\n\t\t\t\t\t\tmint *= 10 ** _b;\r\n\t\t\t\t}\r\n\t\t\t\treturn mint;\r\n\t\t}\r\n\r\n\t\tfunction parseInt(string memory _a) internal pure returns (uint _parsedInt) {\r\n\t\t\t\treturn parseInt(_a, 0);\r\n\t\t}\r\n\r\n\t\tfunction parseInt(string memory _a, uint _b) internal pure returns (uint _parsedInt) {\r\n\t\t\t\tbytes memory bresult = bytes(_a);\r\n\t\t\t\tuint mint = 0;\r\n\t\t\t\tbool decimals = false;\r\n\t\t\t\tfor (uint i = 0; i < bresult.length; i++) {\r\n\t\t\t\t\t\tif ((uint(uint8(bresult[i])) >= 48) && (uint(uint8(bresult[i])) <= 57)) {\r\n\t\t\t\t\t\t\t\tif (decimals) {\r\n\t\t\t\t\t\t\t\t\t if (_b == 0) {\r\n\t\t\t\t\t\t\t\t\t\t\t break;\r\n\t\t\t\t\t\t\t\t\t } else {\r\n\t\t\t\t\t\t\t\t\t\t\t _b--;\r\n\t\t\t\t\t\t\t\t\t }\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tmint *= 10;\r\n\t\t\t\t\t\t\t\tmint += uint(uint8(bresult[i])) - 48;\r\n\t\t\t\t\t\t} else if (uint(uint8(bresult[i])) == 46) {\r\n\t\t\t\t\t\t\t\tdecimals = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (_b > 0) {\r\n\t\t\t\t\t\tmint *= 10 ** _b;\r\n\t\t\t\t}\r\n\t\t\t\treturn mint;\r\n\t\t}\r\n\r\n\t\tfunction uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n\t\t\t\tif (_i == 0) {\r\n\t\t\t\t\t\treturn \"0\";\r\n\t\t\t\t}\r\n\t\t\t\tuint j = _i;\r\n\t\t\t\tuint len;\r\n\t\t\t\twhile (j != 0) {\r\n\t\t\t\t\t\tlen++;\r\n\t\t\t\t\t\tj /= 10;\r\n\t\t\t\t}\r\n\t\t\t\tbytes memory bstr = new bytes(len);\r\n\t\t\t\tuint k = len - 1;\r\n\t\t\t\twhile (_i != 0) {\r\n\t\t\t\t\t\tbstr[k--] = byte(uint8(48 + _i % 10));\r\n\t\t\t\t\t\t_i /= 10;\r\n\t\t\t\t}\r\n\t\t\t\treturn string(bstr);\r\n\t\t}\r\n\r\n\t\tfunction stra2cbor(string[] memory _arr) internal pure returns (bytes memory _cborEncoding) {\r\n\t\t\t\tsafeMemoryCleaner();\r\n\t\t\t\tBuffer.buffer memory buf;\r\n\t\t\t\tBuffer.init(buf, 1024);\r\n\t\t\t\tbuf.startArray();\r\n\t\t\t\tfor (uint i = 0; i < _arr.length; i++) {\r\n\t\t\t\t\t\tbuf.encodeString(_arr[i]);\r\n\t\t\t\t}\r\n\t\t\t\tbuf.endSequence();\r\n\t\t\t\treturn buf.buf;\r\n\t\t}\r\n\r\n\t\tfunction ba2cbor(bytes[] memory _arr) internal pure returns (bytes memory _cborEncoding) {\r\n\t\t\t\tsafeMemoryCleaner();\r\n\t\t\t\tBuffer.buffer memory buf;\r\n\t\t\t\tBuffer.init(buf, 1024);\r\n\t\t\t\tbuf.startArray();\r\n\t\t\t\tfor (uint i = 0; i < _arr.length; i++) {\r\n\t\t\t\t\t\tbuf.encodeBytes(_arr[i]);\r\n\t\t\t\t}\r\n\t\t\t\tbuf.endSequence();\r\n\t\t\t\treturn buf.buf;\r\n\t\t}\r\n\r\n\t\tfunction oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32 _queryId) {\r\n\t\t\t\trequire((_nbytes > 0) && (_nbytes <= 32));\r\n\t\t\t\t_delay *= 10; // Convert from seconds to ledger timer ticks\r\n\t\t\t\tbytes memory nbytes = new bytes(1);\r\n\t\t\t\tnbytes[0] = byte(uint8(_nbytes));\r\n\t\t\t\tbytes memory unonce = new bytes(32);\r\n\t\t\t\tbytes memory sessionKeyHash = new bytes(32);\r\n\t\t\t\tbytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\r\n\t\t\t\tassembly {\r\n\t\t\t\t\t\tmstore(unonce, 0x20)\r\n\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t The following variables can be relaxed.\r\n\t\t\t\t\t\t Check the relaxed random contract at https://github.com/oraclize/ethereum-examples\r\n\t\t\t\t\t\t for an idea on how to override and replace commit hash variables.\r\n\t\t\t\t\t\t*/\r\n\t\t\t\t\t\tmstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\r\n\t\t\t\t\t\tmstore(sessionKeyHash, 0x20)\r\n\t\t\t\t\t\tmstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\r\n\t\t\t\t}\r\n\t\t\t\tbytes memory delay = new bytes(32);\r\n\t\t\t\tassembly {\r\n\t\t\t\t\t\tmstore(add(delay, 0x20), _delay)\r\n\t\t\t\t}\r\n\t\t\t\tbytes memory delay_bytes8 = new bytes(8);\r\n\t\t\t\tcopyBytes(delay, 24, 8, delay_bytes8, 0);\r\n\t\t\t\tbytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\r\n\t\t\t\tbytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\r\n\t\t\t\tbytes memory delay_bytes8_left = new bytes(8);\r\n\t\t\t\tassembly {\r\n\t\t\t\t\t\tlet x := mload(add(delay_bytes8, 0x20))\r\n\t\t\t\t\t\tmstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\r\n\t\t\t\t\t\tmstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\r\n\t\t\t\t\t\tmstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\r\n\t\t\t\t\t\tmstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\r\n\t\t\t\t\t\tmstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\r\n\t\t\t\t\t\tmstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\r\n\t\t\t\t\t\tmstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\r\n\t\t\t\t\t\tmstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\r\n\t\t\t\t}\r\n\t\t\t\toraclize_randomDS_setCommitment(queryId, keccak256(abi.encodePacked(delay_bytes8_left, args[1], sha256(args[0]), args[2])));\r\n\t\t\t\treturn queryId;\r\n\t\t}\r\n\r\n\t\tfunction oraclize_randomDS_setCommitment(bytes32 _queryId, bytes32 _commitment) internal {\r\n\t\t\t\toraclize_randomDS_args[_queryId] = _commitment;\r\n\t\t}\r\n\r\n\t\tfunction verifySig(bytes32 _tosignh, bytes memory _dersig, bytes memory _pubkey) internal returns (bool _sigVerified) {\r\n\t\t\t\tbool sigok;\r\n\t\t\t\taddress signer;\r\n\t\t\t\tbytes32 sigr;\r\n\t\t\t\tbytes32 sigs;\r\n\t\t\t\tbytes memory sigr_ = new bytes(32);\r\n\t\t\t\tuint offset = 4 + (uint(uint8(_dersig[3])) - 0x20);\r\n\t\t\t\tsigr_ = copyBytes(_dersig, offset, 32, sigr_, 0);\r\n\t\t\t\tbytes memory sigs_ = new bytes(32);\r\n\t\t\t\toffset += 32 + 2;\r\n\t\t\t\tsigs_ = copyBytes(_dersig, offset + (uint(uint8(_dersig[offset - 1])) - 0x20), 32, sigs_, 0);\r\n\t\t\t\tassembly {\r\n\t\t\t\t\t\tsigr := mload(add(sigr_, 32))\r\n\t\t\t\t\t\tsigs := mload(add(sigs_, 32))\r\n\t\t\t\t}\r\n\t\t\t\t(sigok, signer) = safer_ecrecover(_tosignh, 27, sigr, sigs);\r\n\t\t\t\tif (address(uint160(uint256(keccak256(_pubkey)))) == signer) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\t(sigok, signer) = safer_ecrecover(_tosignh, 28, sigr, sigs);\r\n\t\t\t\t\t\treturn (address(uint160(uint256(keccak256(_pubkey)))) == signer);\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction oraclize_randomDS_proofVerify__sessionKeyValidity(bytes memory _proof, uint _sig2offset) internal returns (bool _proofVerified) {\r\n\t\t\t\tbool sigok;\r\n\t\t\t\t// Random DS Proof Step 6: Verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\r\n\t\t\t\tbytes memory sig2 = new bytes(uint(uint8(_proof[_sig2offset + 1])) + 2);\r\n\t\t\t\tcopyBytes(_proof, _sig2offset, sig2.length, sig2, 0);\r\n\t\t\t\tbytes memory appkey1_pubkey = new bytes(64);\r\n\t\t\t\tcopyBytes(_proof, 3 + 1, 64, appkey1_pubkey, 0);\r\n\t\t\t\tbytes memory tosign2 = new bytes(1 + 65 + 32);\r\n\t\t\t\ttosign2[0] = byte(uint8(1)); //role\r\n\t\t\t\tcopyBytes(_proof, _sig2offset - 65, 65, tosign2, 1);\r\n\t\t\t\tbytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\r\n\t\t\t\tcopyBytes(CODEHASH, 0, 32, tosign2, 1 + 65);\r\n\t\t\t\tsigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\r\n\t\t\t\tif (!sigok) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t// Random DS Proof Step 7: Verify the APPKEY1 provenance (must be signed by Ledger)\r\n\t\t\t\tbytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\r\n\t\t\t\tbytes memory tosign3 = new bytes(1 + 65);\r\n\t\t\t\ttosign3[0] = 0xFE;\r\n\t\t\t\tcopyBytes(_proof, 3, 65, tosign3, 1);\r\n\t\t\t\tbytes memory sig3 = new bytes(uint(uint8(_proof[3 + 65 + 1])) + 2);\r\n\t\t\t\tcopyBytes(_proof, 3 + 65, sig3.length, sig3, 0);\r\n\t\t\t\tsigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\r\n\t\t\t\treturn sigok;\r\n\t\t}\r\n\r\n\t\tfunction oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string memory _result, bytes memory _proof) internal returns (uint8 _returnCode) {\r\n\t\t\t\t// Random DS Proof Step 1: The prefix has to match 'LP\\x01' (Ledger Proof version 1)\r\n\t\t\t\tif ((_proof[0] != \"L\") || (_proof[1] != \"P\") || (uint8(_proof[2]) != uint8(1))) {\r\n\t\t\t\t\t\treturn 1;\r\n\t\t\t\t}\r\n\t\t\t\tbool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\r\n\t\t\t\tif (!proofVerified) {\r\n\t\t\t\t\t\treturn 2;\r\n\t\t\t\t}\r\n\t\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tfunction matchBytes32Prefix(bytes32 _content, bytes memory _prefix, uint _nRandomBytes) internal pure returns (bool _matchesPrefix) {\r\n\t\t\t\tbool match_ = true;\r\n\t\t\t\trequire(_prefix.length == _nRandomBytes);\r\n\t\t\t\tfor (uint256 i = 0; i< _nRandomBytes; i++) {\r\n\t\t\t\t\t\tif (_content[i] != _prefix[i]) {\r\n\t\t\t\t\t\t\t\tmatch_ = false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn match_;\r\n\t\t}\r\n\r\n\t\tfunction oraclize_randomDS_proofVerify__main(bytes memory _proof, bytes32 _queryId, bytes memory _result, string memory _contextName) internal returns (bool _proofVerified) {\r\n\t\t\t\t// Random DS Proof Step 2: The unique keyhash has to match with the sha256 of (context name + _queryId)\r\n\t\t\t\tuint ledgerProofLength = 3 + 65 + (uint(uint8(_proof[3 + 65 + 1])) + 2) + 32;\r\n\t\t\t\tbytes memory keyhash = new bytes(32);\r\n\t\t\t\tcopyBytes(_proof, ledgerProofLength, 32, keyhash, 0);\r\n\t\t\t\tif (!(keccak256(keyhash) == keccak256(abi.encodePacked(sha256(abi.encodePacked(_contextName, _queryId)))))) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tbytes memory sig1 = new bytes(uint(uint8(_proof[ledgerProofLength + (32 + 8 + 1 + 32) + 1])) + 2);\r\n\t\t\t\tcopyBytes(_proof, ledgerProofLength + (32 + 8 + 1 + 32), sig1.length, sig1, 0);\r\n\t\t\t\t// Random DS Proof Step 3: We assume sig1 is valid (it will be verified during step 5) and we verify if '_result' is the _prefix of sha256(sig1)\r\n\t\t\t\tif (!matchBytes32Prefix(sha256(sig1), _result, uint(uint8(_proof[ledgerProofLength + 32 + 8])))) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t// Random DS Proof Step 4: Commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\r\n\t\t\t\t// This is to verify that the computed args match with the ones specified in the query.\r\n\t\t\t\tbytes memory commitmentSlice1 = new bytes(8 + 1 + 32);\r\n\t\t\t\tcopyBytes(_proof, ledgerProofLength + 32, 8 + 1 + 32, commitmentSlice1, 0);\r\n\t\t\t\tbytes memory sessionPubkey = new bytes(64);\r\n\t\t\t\tuint sig2offset = ledgerProofLength + 32 + (8 + 1 + 32) + sig1.length + 65;\r\n\t\t\t\tcopyBytes(_proof, sig2offset - 64, 64, sessionPubkey, 0);\r\n\t\t\t\tbytes32 sessionPubkeyHash = sha256(sessionPubkey);\r\n\t\t\t\tif (oraclize_randomDS_args[_queryId] == keccak256(abi.encodePacked(commitmentSlice1, sessionPubkeyHash))) { //unonce, nbytes and sessionKeyHash match\r\n\t\t\t\t\t\tdelete oraclize_randomDS_args[_queryId];\r\n\t\t\t\t} else return false;\r\n\t\t\t\t// Random DS Proof Step 5: Validity verification for sig1 (keyhash and args signed with the sessionKey)\r\n\t\t\t\tbytes memory tosign1 = new bytes(32 + 8 + 1 + 32);\r\n\t\t\t\tcopyBytes(_proof, ledgerProofLength, 32 + 8 + 1 + 32, tosign1, 0);\r\n\t\t\t\tif (!verifySig(sha256(tosign1), sig1, sessionPubkey)) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t// Verify if sessionPubkeyHash was verified already, if not.. let's do it!\r\n\t\t\t\tif (!oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash]) {\r\n\t\t\t\t\t\toraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(_proof, sig2offset);\r\n\t\t\t\t}\r\n\t\t\t\treturn oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\r\n\t\t}\r\n\t\t/*\r\n\t\t The following function has been written by Alex Beregszaszi, use it under the terms of the MIT license\r\n\t\t*/\r\n\t\tfunction copyBytes(bytes memory _from, uint _fromOffset, uint _length, bytes memory _to, uint _toOffset) internal pure returns (bytes memory _copiedBytes) {\r\n\t\t\t\tuint minLength = _length + _toOffset;\r\n\t\t\t\trequire(_to.length >= minLength); // Buffer too small. Should be a better way?\r\n\t\t\t\tuint i = 32 + _fromOffset; // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\r\n\t\t\t\tuint j = 32 + _toOffset;\r\n\t\t\t\twhile (i < (32 + _fromOffset + _length)) {\r\n\t\t\t\t\t\tassembly {\r\n\t\t\t\t\t\t\t\tlet tmp := mload(add(_from, i))\r\n\t\t\t\t\t\t\t\tmstore(add(_to, j), tmp)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ti += 32;\r\n\t\t\t\t\t\tj += 32;\r\n\t\t\t\t}\r\n\t\t\t\treturn _to;\r\n\t\t}\r\n\t\t/*\r\n\t\t The following function has been written by Alex Beregszaszi, use it under the terms of the MIT license\r\n\t\t Duplicate Solidity's ecrecover, but catching the CALL return value\r\n\t\t*/\r\n\t\tfunction safer_ecrecover(bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s) internal returns (bool _success, address _recoveredAddress) {\r\n\t\t\t\t/*\r\n\t\t\t\t We do our own memory management here. Solidity uses memory offset\r\n\t\t\t\t 0x40 to store the current end of memory. We write past it (as\r\n\t\t\t\t writes are memory extensions), but don't update the offset so\r\n\t\t\t\t Solidity will reuse it. The memory used here is only needed for\r\n\t\t\t\t this context.\r\n\t\t\t\t FIXME: inline assembly can't access return values\r\n\t\t\t\t*/\r\n\t\t\t\tbool ret;\r\n\t\t\t\taddress addr;\r\n\t\t\t\tassembly {\r\n\t\t\t\t\t\tlet size := mload(0x40)\r\n\t\t\t\t\t\tmstore(size, _hash)\r\n\t\t\t\t\t\tmstore(add(size, 32), _v)\r\n\t\t\t\t\t\tmstore(add(size, 64), _r)\r\n\t\t\t\t\t\tmstore(add(size, 96), _s)\r\n\t\t\t\t\t\tret := call(3000, 1, 0, size, 128, size, 32) // NOTE: we can reuse the request memory because we deal with the return code.\r\n\t\t\t\t\t\taddr := mload(size)\r\n\t\t\t\t}\r\n\t\t\t\treturn (ret, addr);\r\n\t\t}\r\n\t\t/*\r\n\t\t The following function has been written by Alex Beregszaszi, use it under the terms of the MIT license\r\n\t\t*/\r\n\t\tfunction ecrecovery(bytes32 _hash, bytes memory _sig) internal returns (bool _success, address _recoveredAddress) {\r\n\t\t\t\tbytes32 r;\r\n\t\t\t\tbytes32 s;\r\n\t\t\t\tuint8 v;\r\n\t\t\t\tif (_sig.length != 65) {\r\n\t\t\t\t\t\treturn (false, address(0));\r\n\t\t\t\t}\r\n\t\t\t\t/*\r\n\t\t\t\t The signature format is a compact form of:\r\n\t\t\t\t\t {bytes32 r}{bytes32 s}{uint8 v}\r\n\t\t\t\t Compact means, uint8 is not padded to 32 bytes.\r\n\t\t\t\t*/\r\n\t\t\t\tassembly {\r\n\t\t\t\t\t\tr := mload(add(_sig, 32))\r\n\t\t\t\t\t\ts := mload(add(_sig, 64))\r\n\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t Here we are loading the last 32 bytes. We exploit the fact that\r\n\t\t\t\t\t\t 'mload' will pad with zeroes if we overread.\r\n\t\t\t\t\t\t There is no 'mload8' to do this, but that would be nicer.\r\n\t\t\t\t\t\t*/\r\n\t\t\t\t\t\tv := byte(0, mload(add(_sig, 96)))\r\n\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t\tAlternative solution:\r\n\t\t\t\t\t\t\t'byte' is not working due to the Solidity parser, so lets\r\n\t\t\t\t\t\t\tuse the second best option, 'and'\r\n\t\t\t\t\t\t\tv := and(mload(add(_sig, 65)), 255)\r\n\t\t\t\t\t\t*/\r\n\t\t\t\t}\r\n\t\t\t\t/*\r\n\t\t\t\t albeit non-transactional signatures are not specified by the YP, one would expect it\r\n\t\t\t\t to match the YP range of [27, 28]\r\n\t\t\t\t geth uses [0, 1] and some clients have followed. This might change, see:\r\n\t\t\t\t https://github.com/ethereum/go-ethereum/issues/2053\r\n\t\t\t\t*/\r\n\t\t\t\tif (v < 27) {\r\n\t\t\t\t\t\tv += 27;\r\n\t\t\t\t}\r\n\t\t\t\tif (v != 27 && v != 28) {\r\n\t\t\t\t\t\treturn (false, address(0));\r\n\t\t\t\t}\r\n\t\t\t\treturn safer_ecrecover(_hash, v, r, s);\r\n\t\t}\r\n\r\n\t\tfunction safeMemoryCleaner() internal pure {\r\n\t\t\t\tassembly {\r\n\t\t\t\t\t\tlet fmem := mload(0x40)\r\n\t\t\t\t\t\tcodecopy(fmem, codesize, sub(msize, fmem))\r\n\t\t\t\t}\r\n\t\t}\r\n}\r\n/*\r\n\r\nEND ORACLIZE_API\r\n\r\n*/\r\n\r\n/**************************************************************/\r\n/* <ENDORACLIZE> */\r\n\r\n\r\ninterface Caller {\r\n\tfunction randomCallback(bytes32 _queryId, bytes32 _randomData) external;\r\n\tfunction modulusCallback(bytes32 _queryId, uint256 _resolution, uint256 _result) external;\r\n\tfunction seriesCallback(bytes32 _queryId, uint256 _resolution, uint256[] calldata _results) external;\r\n\tfunction queryFailed(bytes32 _queryId) external;\r\n}\r\n\r\ncontract RNGOracle is usingOraclize {\r\n\r\n\tuint256 constant private UINT256_MAX = uint256(-1);\r\n\tuint256 constant private FLOAT_SCALAR = 2**64;\r\n\r\n\tmapping(address => uint256) public queryWallet;\r\n\r\n\tenum RequestType {\r\n\t\tRANDOM,\r\n\t\tMODULUS,\r\n\t\tSERIES\r\n\t}\r\n\r\n\tstruct RequestInfo {\r\n\t\tbytes32 seed;\r\n\t\tCaller caller;\r\n\t\tuint32 placedBlockNumber;\r\n\t\tRequestType requestType;\r\n\t\tuint32 requestIndex;\r\n\t}\r\n\tmapping(bytes32 => RequestInfo) private requestMap;\r\n\r\n\tstruct ModulusInfo {\r\n\t\tuint256 modulus;\r\n\t\tuint256 betmask;\r\n\t}\r\n\tModulusInfo[] private modulusInfo;\r\n\r\n\tstruct SeriesInfo {\r\n\t\tuint128 seriesIndex;\r\n\t\tuint128 runs;\r\n\t}\r\n\tSeriesInfo[] private seriesInfo;\r\n\r\n\tstruct Series {\r\n\t\tuint256 sum;\r\n\t\tuint256 maxRuns;\r\n\t\tuint256[] series;\r\n\t\tuint256[] cumulativeSum;\r\n\t\tuint256[] resolutions;\r\n\t}\r\n\tSeries[] private series;\r\n\r\n\r\n\tconstructor() public {\r\n\t\toraclize_setProof(proofType_Ledger);\r\n\t}\r\n\r\n\tfunction addQueryBalance() public payable {\r\n\t\tqueryWallet[msg.sender] += msg.value;\r\n\t}\r\n\r\n\tfunction withdrawAllQueryBalance() public {\r\n\t\twithdrawQueryBalance(queryWallet[msg.sender]);\r\n\t}\r\n\r\n\tfunction withdrawQueryBalance(uint256 _amount) public {\r\n\t\trequire(queryWallet[msg.sender] >= _amount);\r\n\t\tqueryWallet[msg.sender] -= _amount;\r\n\t\tmsg.sender.transfer(_amount);\r\n\t}\r\n\r\n\tfunction createSeries(uint256[] memory _newSeries) public returns (uint256 seriesIndex) {\r\n\t\trequire(_newSeries.length > 0);\r\n\r\n\t\tuint256 _sum = 0;\r\n\t\tuint256 _zeros = 0;\r\n\t\tuint256 _length = _newSeries.length;\r\n\t\tuint256[] memory _cumulativeSum = new uint256[](_length);\r\n\t\tfor (uint256 i = 0; i < _length; i++) {\r\n\t\t\t_sum += _newSeries[i];\r\n\t\t\t_cumulativeSum[i] = _sum;\r\n\t\t\tif (_newSeries[i] == 0) {\r\n\t\t\t\t_zeros++;\r\n\t\t\t}\r\n\t\t}\r\n\t\trequire(_sum > 1);\r\n\r\n\t\tuint256 _maxRuns = 0;\r\n\t\tuint256 _tmp = UINT256_MAX;\r\n\t\twhile (_tmp > _sum) {\r\n\t\t\t_tmp /= _sum;\r\n\t\t\t_maxRuns++;\r\n\t\t}\r\n\t\tif (_tmp == _sum - 1) {\r\n\t\t\t_maxRuns++;\r\n\t\t}\r\n\r\n\t\tuint256[] memory _resolutions = new uint256[](_length);\r\n\t\tfor (uint256 i = 0; i < _length; i++) {\r\n\t\t\t_resolutions[i] = (_newSeries[i] == 0 ? 0 : FLOAT_SCALAR * _sum / _newSeries[i] / (_length - _zeros));\r\n\t\t}\r\n\r\n\t\tSeries memory _series = Series({\r\n\t\t\tsum: _sum,\r\n\t\t\tmaxRuns: _maxRuns,\r\n\t\t\tseries: _newSeries,\r\n\t\t\tcumulativeSum: _cumulativeSum,\r\n\t\t\tresolutions: _resolutions\r\n\t\t});\r\n\t\treturn series.push(_series) - 1;\r\n\t}\r\n\r\n\tfunction randomRequest(bytes32 _seed, uint256 _callbackGasLimit) public returns (bytes32 queryId) {\r\n\t\treturn _request(RequestType.RANDOM, 0, _seed, _callbackGasLimit);\r\n\t}\r\n\r\n\tfunction modulusRequest(uint256 _modulus, uint256 _betmask, bytes32 _seed, uint256 _callbackGasLimit) public returns (bytes32 queryId) {\r\n\t\trequire(_modulus >= 2 && _modulus <= 256);\r\n\t\trequire(_betmask > 0 && _betmask < 2**_modulus - 1);\r\n\r\n\t\tModulusInfo memory _modulusInfo = ModulusInfo({\r\n\t\t\tmodulus: _modulus,\r\n\t\t\tbetmask: _betmask\r\n\t\t});\r\n\t\tuint256 _requestIndex = modulusInfo.push(_modulusInfo) - 1;\r\n\t\treturn _request(RequestType.MODULUS, _requestIndex, _seed, _callbackGasLimit);\r\n\t}\r\n\r\n\tfunction seriesRequest(uint256 _seriesIndex, uint256 _runs, bytes32 _seed, uint256 _callbackGasLimit) public returns (bytes32 queryId) {\r\n\t\trequire(_seriesIndex < series.length);\r\n\t\trequire(_runs > 0 && _runs <= series[_seriesIndex].maxRuns);\r\n\r\n\t\tSeriesInfo memory _seriesInfo = SeriesInfo({\r\n\t\t\tseriesIndex: uint128(_seriesIndex),\r\n\t\t\truns: uint128(_runs)\r\n\t\t});\r\n\t\tuint256 _requestIndex = seriesInfo.push(_seriesInfo) - 1;\r\n\t\treturn _request(RequestType.SERIES, _requestIndex, _seed, _callbackGasLimit);\r\n\t}\r\n\r\n\tfunction resolveQuery(bytes32 _queryId) public {\r\n\t\trequire(block.number - requestMap[_queryId].placedBlockNumber > 256);\r\n\t\t_queryFailed(_queryId);\r\n\t}\r\n\r\n\tfunction __callback(bytes32 _queryId, string memory _result, bytes memory _proof) public {\r\n\t\trequire(msg.sender == oraclize_cbAddress());\r\n\t\tif (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) == 0) {\r\n\t\t\t_handleCallback(_queryId, _result);\r\n\t\t} else {\r\n\t\t\t_queryFailed(_queryId);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction getSeries(uint256 _seriesIndex) public view returns (uint256 sum, uint256 maxRuns, uint256[] memory values, uint256[] memory cumulativeSum, uint256[] memory resolutions) {\r\n\t\trequire(_seriesIndex < series.length);\r\n\t\tSeries memory _series = series[_seriesIndex];\r\n\t\treturn (_series.sum, _series.maxRuns, _series.series, _series.cumulativeSum, _series.resolutions);\r\n\t}\r\n\r\n\r\n\tfunction _request(RequestType _requestType, uint256 _requestIndex, bytes32 _seed, uint256 _callbackGasLimit) internal returns (bytes32 queryId) {\r\n\t\toraclize_setCustomGasPrice(tx.gasprice + 1e9);\r\n\t\tuint256 _queryFee = oraclize_getPrice(\"random\", _callbackGasLimit);\r\n\t\trequire(queryWallet[tx.origin] >= _queryFee);\r\n\t\tqueryWallet[tx.origin] -= _queryFee;\r\n\r\n\t\tqueryId = oraclize_newRandomDSQuery(0, 32, _callbackGasLimit);\r\n\t\tRequestInfo memory _requestInfo = RequestInfo({\r\n\t\t\tseed: keccak256(abi.encodePacked(_seed, queryId)),\r\n\t\t\tcaller: Caller(msg.sender),\r\n\t\t\tplacedBlockNumber: uint32(block.number),\r\n\t\t\trequestType: _requestType,\r\n\t\t\trequestIndex: uint32(_requestIndex)\r\n\t\t});\r\n\t\trequestMap[queryId] = _requestInfo;\r\n\t}\r\n\r\n\tfunction _handleCallback(bytes32 _queryId, string memory _result) internal {\r\n\t\tRequestInfo memory _requestInfo = requestMap[_queryId];\r\n\t\trequire(address(_requestInfo.caller) != address(0x0));\r\n\r\n\t\tif (_requestInfo.placedBlockNumber < block.number && block.number - _requestInfo.placedBlockNumber < 256) {\r\n\t\t\tif (_requestInfo.requestType == RequestType.RANDOM) { _randomCallback(_queryId, _result); }\r\n\t\t\telse if (_requestInfo.requestType == RequestType.MODULUS) { _modulusCallback(_queryId, _result); }\r\n\t\t\telse if (_requestInfo.requestType == RequestType.SERIES) { _seriesCallback(_queryId, _result); }\r\n\t\t} else {\r\n\t\t\t_queryFailed(_queryId);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _randomCallback(bytes32 _queryId, string memory _result) internal {\r\n\t\tCaller _caller = requestMap[_queryId].caller;\r\n\t\tbytes32 _randomData = _generateRNG(_queryId, _result);\r\n\t\tdelete requestMap[_queryId];\r\n\t\t_caller.randomCallback(_queryId, _randomData);\r\n\t}\r\n\r\n\tfunction _modulusCallback(bytes32 _queryId, string memory _result) internal {\r\n\t\tRequestInfo memory _requestInfo = requestMap[_queryId];\r\n\t\tuint256 _rng = uint256(_generateRNG(_queryId, _result));\r\n\r\n\t\tModulusInfo memory _modulusInfo = modulusInfo[_requestInfo.requestIndex];\r\n\t\tuint256 _roll = _rng % _modulusInfo.modulus;\r\n\t\tuint256 _resolution = 0;\r\n\t\tif (2**_roll & _modulusInfo.betmask != 0) {\r\n\t\t\tuint256 _selected = 0;\r\n\t\t\tuint256 _n = _modulusInfo.betmask;\r\n\t\t\twhile (_n > 0) {\r\n\t\t\t\tif (_n % 2 == 1) _selected++;\r\n\t\t\t\t_n /= 2;\r\n\t\t\t}\r\n\t\t\t_resolution = FLOAT_SCALAR * _modulusInfo.modulus / _selected;\r\n\t\t}\r\n\r\n\t\tCaller _caller = _requestInfo.caller;\r\n\t\tdelete modulusInfo[_requestInfo.requestIndex];\r\n\t\tdelete requestMap[_queryId];\r\n\t\t_caller.modulusCallback(_queryId, _resolution, _roll);\r\n\t}\r\n\r\n\tfunction _seriesCallback(bytes32 _queryId, string memory _result) internal {\r\n\t\tRequestInfo memory _requestInfo = requestMap[_queryId];\r\n\t\tuint256 _rng = uint256(_generateRNG(_queryId, _result));\r\n\r\n\t\tSeriesInfo memory _seriesInfo = seriesInfo[_requestInfo.requestIndex];\r\n\t\tSeries memory _series = series[_seriesInfo.seriesIndex];\r\n\r\n\t\tuint256[] memory _results = new uint256[](_seriesInfo.runs);\r\n\t\tuint256 _resolution = 0;\r\n\t\tfor (uint256 i = 0; i < _seriesInfo.runs; i++) {\r\n\t\t\tuint256 _roll = _rng % _series.sum;\r\n\t\t\t_rng /= _series.sum;\r\n\r\n\t\t\tuint256 _outcome;\r\n\t\t\tfor (uint256 j = 0; j < _series.cumulativeSum.length; j++) {\r\n\t\t\t\tif (_roll < _series.cumulativeSum[j]) {\r\n\t\t\t\t\t_outcome = j;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t_results[i] = _outcome;\r\n\t\t\t_resolution += _series.resolutions[_outcome];\r\n\t\t}\r\n\t\t_resolution /= _seriesInfo.runs;\r\n\r\n\t\tCaller _caller = _requestInfo.caller;\r\n\t\tdelete seriesInfo[_requestInfo.requestIndex];\r\n\t\tdelete requestMap[_queryId];\r\n\t\t_caller.seriesCallback(_queryId, _resolution, _results);\r\n\t}\r\n\r\n\tfunction _queryFailed(bytes32 _queryId) internal {\r\n\t\tRequestInfo memory _requestInfo = requestMap[_queryId];\r\n\t\trequire(address(_requestInfo.caller) != address(0x0));\r\n\r\n\t\tCaller _caller = _requestInfo.caller;\r\n\t\tif (_requestInfo.requestType == RequestType.MODULUS) { delete modulusInfo[_requestInfo.requestIndex]; }\r\n\t\telse if (_requestInfo.requestType == RequestType.SERIES) { delete seriesInfo[_requestInfo.requestIndex]; }\r\n\t\tdelete requestMap[_queryId];\r\n\t\t_caller.queryFailed(_queryId);\r\n\t}\r\n\r\n\r\n\tfunction _generateRNG(bytes32 _queryId, string memory _result) internal view returns (bytes32 _randomData) {\r\n\t\tRequestInfo memory _requestInfo = requestMap[_queryId];\r\n\t\tbytes32 _staticData = keccak256(abi.encodePacked(_requestInfo.seed, _queryId, blockhash(_requestInfo.placedBlockNumber), blockhash(block.number - 1)));\r\n\t\treturn keccak256(abi.encodePacked(_staticData, _result));\r\n\t}\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_myid\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"_result\",\"type\":\"string\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"_result\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addQueryBalance\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_newSeries\",\"type\":\"uint256[]\"}],\"name\":\"createSeries\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"seriesIndex\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_seriesIndex\",\"type\":\"uint256\"}],\"name\":\"getSeries\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxRuns\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"cumulativeSum\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"resolutions\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_modulus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_betmask\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_seed\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_callbackGasLimit\",\"type\":\"uint256\"}],\"name\":\"modulusRequest\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"queryId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"queryWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_seed\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_callbackGasLimit\",\"type\":\"uint256\"}],\"name\":\"randomRequest\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"queryId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"}],\"name\":\"resolveQuery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_seriesIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_runs\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_seed\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_callbackGasLimit\",\"type\":\"uint256\"}],\"name\":\"seriesRequest\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"queryId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAllQueryBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawQueryBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RNGOracle","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://e94046ed595850be2c735de4c9284b92e58acd7b22bce704c64dfbf39d0c3eff"}]}