{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.12;\r\n\r\n/// @title Ownable\r\n/// @dev Provide a simple access control with a single authority: the owner\r\ncontract Ownable {\r\n\r\n    // Ethereum address of current owner\r\n    address public owner;\r\n\r\n    // Ethereum address of the next owner\r\n    // (has to claim ownership first to become effective owner)\r\n    address public newOwner;\r\n\r\n    // @dev Log event on ownership transferred\r\n    // @param previousOwner Ethereum address of previous owner\r\n    // @param newOwner Ethereum address of new owner\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /// @dev Forbid call by anyone but owner\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Restricted to owner\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Deployer account becomes initial owner\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev  Transfer ownership to a new Ethereum account (safe method)\r\n    ///       Note: the new owner has to claim his ownership to become effective owner.\r\n    /// @param _newOwner  Ethereum address to transfer ownership to\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0x0), \"New owner is zero\");\r\n\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /// @dev  Transfer ownership to a new Ethereum account (unsafe method)\r\n    ///       Note: It's strongly recommended to use the safe variant via transferOwnership\r\n    ///             and claimOwnership, to prevent accidental transfers to a wrong address.\r\n    /// @param _newOwner  Ethereum address to transfer ownership to\r\n    function transferOwnershipUnsafe(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0x0), \"New owner is zero\");\r\n\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    /// @dev  Become effective owner (if dedicated so by previous owner)\r\n    function claimOwnership() public {\r\n        require(msg.sender == newOwner, \"Restricted to new owner\");\r\n\r\n        _transferOwnership(msg.sender);\r\n    }\r\n\r\n    /// @dev  Transfer ownership (internal method)\r\n    /// @param _newOwner  Ethereum address to transfer ownership to\r\n    function _transferOwnership(address _newOwner) private {\r\n        if (_newOwner != owner) {\r\n            emit OwnershipTransferred(owner, _newOwner);\r\n\r\n            owner = _newOwner;\r\n        }\r\n        newOwner = address(0x0);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/whitelist/Whitelist.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n/// @title Whitelist\r\n/// @author STOKR\r\ncontract Whitelist is Ownable {\r\n\r\n    // Set of admins\r\n    mapping(address => bool) public admins;\r\n\r\n    // Set of Whitelisted addresses\r\n    mapping(address => bool) public isWhitelisted;\r\n\r\n    /// @dev Log entry on admin added to set\r\n    /// @param admin An Ethereum address\r\n    event AdminAdded(address indexed admin);\r\n\r\n    /// @dev Log entry on admin removed from set\r\n    /// @param admin An Ethereum address\r\n    event AdminRemoved(address indexed admin);\r\n\r\n    /// @dev Log entry on investor added set\r\n    /// @param admin An Ethereum address\r\n    /// @param investor An Ethereum address\r\n    event InvestorAdded(address indexed admin, address indexed investor);\r\n\r\n    /// @dev Log entry on investor removed from set\r\n    /// @param admin An Ethereum address\r\n    /// @param investor An Ethereum address\r\n    event InvestorRemoved(address indexed admin, address indexed investor);\r\n\r\n    /// @dev Only admin\r\n    modifier onlyAdmin() {\r\n        require(admins[msg.sender], \"Restricted to whitelist admin\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Add admin to set\r\n    /// @param _admin An Ethereum address\r\n    function addAdmin(address _admin) public onlyOwner {\r\n        require(_admin != address(0x0), \"Whitelist admin is zero\");\r\n\r\n        if (!admins[_admin]) {\r\n            admins[_admin] = true;\r\n\r\n            emit AdminAdded(_admin);\r\n        }\r\n    }\r\n\r\n    /// @dev Remove admin from set\r\n    /// @param _admin An Ethereum address\r\n    function removeAdmin(address _admin) public onlyOwner {\r\n        require(_admin != address(0x0), \"Whitelist admin is zero\");  // Necessary?\r\n\r\n        if (admins[_admin]) {\r\n            admins[_admin] = false;\r\n\r\n            emit AdminRemoved(_admin);\r\n        }\r\n    }\r\n\r\n    /// @dev Add investor to set of whitelisted addresses\r\n    /// @param _investors A list where each entry is an Ethereum address\r\n    function addToWhitelist(address[] calldata _investors) external onlyAdmin {\r\n        for (uint256 i = 0; i < _investors.length; i++) {\r\n            if (!isWhitelisted[_investors[i]]) {\r\n                isWhitelisted[_investors[i]] = true;\r\n\r\n                emit InvestorAdded(msg.sender, _investors[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Remove investor from set of whitelisted addresses\r\n    /// @param _investors A list where each entry is an Ethereum address\r\n    function removeFromWhitelist(address[] calldata _investors) external onlyAdmin {\r\n        for (uint256 i = 0; i < _investors.length; i++) {\r\n            if (isWhitelisted[_investors[i]]) {\r\n                isWhitelisted[_investors[i]] = false;\r\n\r\n                emit InvestorRemoved(msg.sender, _investors[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/whitelist/Whitelisted.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n\r\n/// @title Whitelisted\r\n/// @author STOKR\r\ncontract Whitelisted is Ownable {\r\n\r\n    Whitelist public whitelist;\r\n\r\n    /// @dev  Log entry on change of whitelist contract instance\r\n    /// @param previous  Ethereum address of previous whitelist\r\n    /// @param current   Ethereum address of new whitelist\r\n    event WhitelistChange(address indexed previous, address indexed current);\r\n\r\n    /// @dev Ensure only whitelisted addresses can call\r\n    modifier onlyWhitelisted(address _address) {\r\n        require(whitelist.isWhitelisted(_address), \"Address is not whitelisted\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Constructor\r\n    /// @param _whitelist address of whitelist contract\r\n    constructor(Whitelist _whitelist) public {\r\n        setWhitelist(_whitelist);\r\n    }\r\n\r\n    /// @dev Set the address of whitelist\r\n    /// @param _newWhitelist An Ethereum address\r\n    function setWhitelist(Whitelist _newWhitelist) public onlyOwner {\r\n        require(address(_newWhitelist) != address(0x0), \"Whitelist address is zero\");\r\n\r\n        if (address(_newWhitelist) != address(whitelist)) {\r\n            emit WhitelistChange(address(whitelist), address(_newWhitelist));\r\n\r\n            whitelist = Whitelist(_newWhitelist);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/token/TokenRecoverable.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n/// @title TokenRecoverable\r\n/// @author STOKR\r\ncontract TokenRecoverable is Ownable {\r\n\r\n    // Address that can do the TokenRecovery\r\n    address public tokenRecoverer;\r\n\r\n    /// @dev  Event emitted when the TokenRecoverer changes\r\n    /// @param previous  Ethereum address of previous token recoverer\r\n    /// @param current   Ethereum address of new token recoverer\r\n    event TokenRecovererChange(address indexed previous, address indexed current);\r\n\r\n    /// @dev Event emitted in case of a TokenRecovery\r\n    /// @param oldAddress Ethereum address of old account\r\n    /// @param newAddress Ethereum address of new account\r\n    event TokenRecovery(address indexed oldAddress, address indexed newAddress);\r\n\r\n    /// @dev Restrict operation to token recoverer\r\n    modifier onlyTokenRecoverer() {\r\n        require(msg.sender == tokenRecoverer, \"Restricted to token recoverer\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Constructor\r\n    /// @param _tokenRecoverer Ethereum address of token recoverer\r\n    constructor(address _tokenRecoverer) public {\r\n        setTokenRecoverer(_tokenRecoverer);\r\n    }\r\n\r\n    /// @dev Set token recoverer\r\n    /// @param _newTokenRecoverer Ethereum address of new token recoverer\r\n    function setTokenRecoverer(address _newTokenRecoverer) public onlyOwner {\r\n        require(_newTokenRecoverer != address(0x0), \"New token recoverer is zero\");\r\n\r\n        if (_newTokenRecoverer != tokenRecoverer) {\r\n            emit TokenRecovererChange(tokenRecoverer, _newTokenRecoverer);\r\n\r\n            tokenRecoverer = _newTokenRecoverer;\r\n        }\r\n    }\r\n\r\n    /// @dev Recover token\r\n    /// @param _oldAddress address\r\n    /// @param _newAddress address\r\n    function recoverToken(address _oldAddress, address _newAddress) public;\r\n\r\n}\r\n\r\n// File: contracts/token/ERC20.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n/// @title ERC20 interface\r\n/// @dev see https://github.com/ethereum/EIPs/issues/20\r\ninterface ERC20 {\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address _owner) external view returns (uint);\r\n    function allowance(address _owner, address _spender) external view returns (uint);\r\n    function approve(address _spender, uint _value) external returns (bool);\r\n    function transfer(address _to, uint _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/math/SafeMath.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n/// @title SafeMath\r\n/// @dev Math operations with safety checks that throw on error\r\nlibrary SafeMath {\r\n\r\n    /// @dev Add two integers\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n\r\n        assert(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /// @dev Subtract two integers\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n\r\n        return a - b;\r\n    }\r\n\r\n    /// @dev Multiply tow integers\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint c = a * b;\r\n\r\n        assert(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /// @dev Floor divide two integers\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        return a / b;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/token/ProfitSharing.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n\r\n/// @title ProfitSharing\r\n/// @author STOKR\r\ncontract ProfitSharing is Ownable {\r\n\r\n    using SafeMath for uint;\r\n\r\n\r\n    // An InvestorAccount object keeps track of the investor's\r\n    // - balance: amount of tokens he/she holds (always up-to-date)\r\n    // - profitShare: amount of wei this token owed him/her at the last update\r\n    // - lastTotalProfits: determines when his/her profitShare was updated\r\n    // Note, this construction requires:\r\n    // - totalProfits to never decrease\r\n    // - totalSupply to be fixed\r\n    // - profitShare of all involved parties to get updated prior to any token transfer\r\n    // - lastTotalProfits to be set to current totalProfits upon profitShare update\r\n    struct InvestorAccount {\r\n        uint balance;           // token balance\r\n        uint lastTotalProfits;  // totalProfits [wei] at the time of last profit share update\r\n        uint profitShare;       // profit share [wei] of last update\r\n    }\r\n\r\n\r\n    // Investor account database\r\n    mapping(address => InvestorAccount) public accounts;\r\n\r\n    // Authority who is allowed to deposit profits [wei] on this\r\n    address public profitDepositor;\r\n\r\n    // Authority who is allowed to distribute profit shares [wei] to investors\r\n    // (so, that they don't need to withdraw it by themselves)\r\n    address public profitDistributor;\r\n\r\n    // Amount of total profits [wei] stored to this token\r\n    // In contrast to the wei balance (which may be reduced due to profit share withdrawal)\r\n    // this value will never decrease\r\n    uint public totalProfits;\r\n\r\n    // As long as the total supply isn't fixed, i.e. new tokens can appear out of thin air,\r\n    // the investors' profit shares aren't determined\r\n    bool public totalSupplyIsFixed;\r\n\r\n    // Total amount of tokens\r\n    uint internal totalSupply_;\r\n\r\n\r\n    /// @dev  Log entry on change of profit deposit authority\r\n    /// @param previous  Ethereum address of previous profit depositor\r\n    /// @param current   Ethereum address of new profit depositor\r\n    event ProfitDepositorChange(\r\n        address indexed previous,\r\n        address indexed current\r\n    );\r\n\r\n    /// @dev  Log entry on change of profit distribution authority\r\n    /// @param previous  Ethereum address of previous profit distributor\r\n    /// @param current   Ethereum address of new profit distributor\r\n    event ProfitDistributorChange(\r\n        address indexed previous,\r\n        address indexed current\r\n    );\r\n\r\n    /// @dev Log entry on profit deposit\r\n    /// @param depositor Profit depositor's address\r\n    /// @param amount Deposited profits in wei\r\n    event ProfitDeposit(\r\n        address indexed depositor,\r\n        uint amount\r\n    );\r\n\r\n    /// @dev Log entry on profit share update\r\n    /// @param investor Investor's address\r\n    /// @param amount New wei amount the token owes the investor\r\n    event ProfitShareUpdate(\r\n        address indexed investor,\r\n        uint amount\r\n    );\r\n\r\n    /// @dev Log entry on profit withdrawal\r\n    /// @param investor Investor's address\r\n    /// @param amount Wei amount the investor withdrew from this token\r\n    event ProfitShareWithdrawal(\r\n        address indexed investor,\r\n        address indexed beneficiary,\r\n        uint amount\r\n    );\r\n\r\n\r\n    /// @dev Restrict operation to profit deposit authority only\r\n    modifier onlyProfitDepositor() {\r\n        require(msg.sender == profitDepositor, \"Restricted to profit depositor\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Restrict operation to profit distribution authority only\r\n    modifier onlyProfitDistributor() {\r\n        require(msg.sender == profitDistributor, \"Restricted to profit distributor\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Restrict operation to when total supply doesn't change anymore\r\n    modifier onlyWhenTotalSupplyIsFixed() {\r\n        require(totalSupplyIsFixed, \"Total supply may change\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Constructor\r\n    /// @param _profitDepositor Profit deposit authority\r\n    constructor(address _profitDepositor, address _profitDistributor) public {\r\n        setProfitDepositor(_profitDepositor);\r\n        setProfitDistributor(_profitDistributor);\r\n    }\r\n\r\n    /// @dev Profit deposit if possible via fallback function\r\n    function () external payable {\r\n        require(msg.data.length == 0, \"Fallback call with data\");\r\n\r\n        depositProfit();\r\n    }\r\n\r\n    /// @dev Change profit depositor\r\n    /// @param _newProfitDepositor An Ethereum address\r\n    function setProfitDepositor(address _newProfitDepositor) public onlyOwner {\r\n        require(_newProfitDepositor != address(0x0), \"New profit depositor is zero\");\r\n\r\n        if (_newProfitDepositor != profitDepositor) {\r\n            emit ProfitDepositorChange(profitDepositor, _newProfitDepositor);\r\n\r\n            profitDepositor = _newProfitDepositor;\r\n        }\r\n    }\r\n\r\n    /// @dev Change profit distributor\r\n    /// @param _newProfitDistributor An Ethereum address\r\n    function setProfitDistributor(address _newProfitDistributor) public onlyOwner {\r\n        require(_newProfitDistributor != address(0x0), \"New profit distributor is zero\");\r\n\r\n        if (_newProfitDistributor != profitDistributor) {\r\n            emit ProfitDistributorChange(profitDistributor, _newProfitDistributor);\r\n\r\n            profitDistributor = _newProfitDistributor;\r\n        }\r\n    }\r\n\r\n    /// @dev Deposit profit\r\n    function depositProfit() public payable onlyProfitDepositor onlyWhenTotalSupplyIsFixed {\r\n        require(totalSupply_ > 0, \"Total supply is zero\");\r\n\r\n        totalProfits = totalProfits.add(msg.value);\r\n\r\n        emit ProfitDeposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /// @dev Profit share owing\r\n    /// @param _investor An Ethereum address\r\n    /// @return A positive number\r\n    function profitShareOwing(address _investor) public view returns (uint) {\r\n        if (!totalSupplyIsFixed || totalSupply_ == 0) {\r\n            return 0;\r\n        }\r\n\r\n        InvestorAccount memory account = accounts[_investor];\r\n\r\n        return totalProfits.sub(account.lastTotalProfits)\r\n                           .mul(account.balance)\r\n                           .div(totalSupply_)\r\n                           .add(account.profitShare);\r\n    }\r\n\r\n    /// @dev Update profit share\r\n    /// @param _investor An Ethereum address\r\n    function updateProfitShare(address _investor) public onlyWhenTotalSupplyIsFixed {\r\n        uint newProfitShare = profitShareOwing(_investor);\r\n\r\n        accounts[_investor].lastTotalProfits = totalProfits;\r\n        accounts[_investor].profitShare = newProfitShare;\r\n\r\n        emit ProfitShareUpdate(_investor, newProfitShare);\r\n    }\r\n\r\n    /// @dev Withdraw profit share\r\n    function withdrawProfitShare() public {\r\n        _withdrawProfitShare(msg.sender, msg.sender);\r\n    }\r\n\r\n    function withdrawProfitShareTo(address payable _beneficiary) public {\r\n        _withdrawProfitShare(msg.sender, _beneficiary);\r\n    }\r\n\r\n    /// @dev Withdraw profit share\r\n    function withdrawProfitShares(address payable[] calldata _investors)\r\n        external\r\n        onlyProfitDistributor\r\n    {\r\n        for (uint i = 0; i < _investors.length; ++i) {\r\n            _withdrawProfitShare(_investors[i], _investors[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev Withdraw profit share\r\n    function _withdrawProfitShare(address _investor, address payable _beneficiary) internal {\r\n        updateProfitShare(_investor);\r\n\r\n        uint withdrawnProfitShare = accounts[_investor].profitShare;\r\n\r\n        accounts[_investor].profitShare = 0;\r\n        _beneficiary.transfer(withdrawnProfitShare);\r\n\r\n        emit ProfitShareWithdrawal(_investor, _beneficiary, withdrawnProfitShare);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/token/MintableToken.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n\r\n\r\n/// @title MintableToken\r\n/// @author STOKR\r\n/// @dev Extension of the ERC20 compliant ProfitSharing Token\r\n///      that allows the creation of tokens via minting for a\r\n///      limited time period (until minting gets finished).\r\ncontract MintableToken is ERC20, ProfitSharing, Whitelisted {\r\n\r\n    address public minter;\r\n    uint public numberOfInvestors = 0;\r\n\r\n    /// @dev Log entry on mint\r\n    /// @param to Beneficiary who received the newly minted tokens\r\n    /// @param amount The amount of minted token units\r\n    event Minted(address indexed to, uint amount);\r\n\r\n    /// @dev Log entry on mint finished\r\n    event MintFinished();\r\n\r\n    /// @dev Restrict an operation to be callable only by the minter\r\n    modifier onlyMinter() {\r\n        require(msg.sender == minter, \"Restricted to minter\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Restrict an operation to be executable only while minting was not finished\r\n    modifier canMint() {\r\n        require(!totalSupplyIsFixed, \"Total supply has been fixed\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Set minter authority\r\n    /// @param _minter Ethereum address of minter authority\r\n    function setMinter(address _minter) public onlyOwner {\r\n        require(minter == address(0x0), \"Minter has already been set\");\r\n        require(_minter != address(0x0), \"Minter is zero\");\r\n\r\n        minter = _minter;\r\n    }\r\n\r\n    /// @dev Mint tokens, i.e. create tokens out of thin air\r\n    /// @param _to Beneficiary who will receive the newly minted tokens\r\n    /// @param _amount The amount of minted token units\r\n    function mint(address _to, uint _amount) public onlyMinter canMint onlyWhitelisted(_to) {\r\n        if (accounts[_to].balance == 0) {\r\n            numberOfInvestors++;\r\n        }\r\n\r\n        totalSupply_ = totalSupply_.add(_amount);\r\n        accounts[_to].balance = accounts[_to].balance.add(_amount);\r\n\r\n        emit Minted(_to, _amount);\r\n        emit Transfer(address(0x0), _to, _amount);\r\n    }\r\n\r\n    /// @dev Finish minting -- this should be irreversible\r\n    function finishMinting() public onlyMinter canMint {\r\n        totalSupplyIsFixed = true;\r\n\r\n        emit MintFinished();\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/token/StokrToken.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n\r\n\r\n/// @title StokrToken\r\n/// @author Stokr\r\ncontract StokrToken is MintableToken, TokenRecoverable {\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public constant decimals = 18;\r\n\r\n    mapping(address => mapping(address => uint)) internal allowance_;\r\n\r\n    /// @dev Log entry on self destruction of the token\r\n    event TokenDestroyed();\r\n\r\n    /// @dev Constructor\r\n    /// @param _whitelist       Ethereum address of whitelist contract\r\n    /// @param _tokenRecoverer  Ethereum address of token recoverer\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        Whitelist _whitelist,\r\n        address _profitDepositor,\r\n        address _profitDistributor,\r\n        address _tokenRecoverer\r\n    )\r\n        public\r\n        Whitelisted(_whitelist)\r\n        ProfitSharing(_profitDepositor, _profitDistributor)\r\n        TokenRecoverable(_tokenRecoverer)\r\n    {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n\r\n    /// @dev  Self destruct can only be called by crowdsale contract in case the goal wasn't reached\r\n    function destruct() public onlyMinter {\r\n        emit TokenDestroyed();\r\n        selfdestruct(address(uint160(owner)));\r\n    }\r\n\r\n    /// @dev Recover token\r\n    /// @param _oldAddress  address of old account\r\n    /// @param _newAddress  address of new account\r\n    function recoverToken(address _oldAddress, address _newAddress)\r\n        public\r\n        onlyTokenRecoverer\r\n        onlyWhitelisted(_newAddress)\r\n    {\r\n        // Ensure that new address is *not* an existing account.\r\n        // Check for account.profitShare is not needed because of following implication:\r\n        //   (account.lastTotalProfits == 0) ==> (account.profitShare == 0)\r\n        require(accounts[_newAddress].balance == 0 && accounts[_newAddress].lastTotalProfits == 0,\r\n                \"New address exists already\");\r\n\r\n        updateProfitShare(_oldAddress);\r\n\r\n        accounts[_newAddress] = accounts[_oldAddress];\r\n        delete accounts[_oldAddress];\r\n\r\n        emit TokenRecovery(_oldAddress, _newAddress);\r\n        emit Transfer(_oldAddress, _newAddress, accounts[_newAddress].balance);\r\n    }\r\n\r\n    /// @dev  Total supply of this token\r\n    /// @return  Token amount\r\n    function totalSupply() public view returns (uint) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    /// @dev  Token balance\r\n    /// @param _investor  Ethereum address of token holder\r\n    /// @return           Token amount\r\n    function balanceOf(address _investor) public view returns (uint) {\r\n        return accounts[_investor].balance;\r\n    }\r\n\r\n    /// @dev  Allowed token amount a third party trustee may transfer\r\n    /// @param _investor  Ethereum address of token holder\r\n    /// @param _spender   Ethereum address of third party\r\n    /// @return           Allowed token amount\r\n    function allowance(address _investor, address _spender) public view returns (uint) {\r\n        return allowance_[_investor][_spender];\r\n    }\r\n\r\n    /// @dev  Approve a third party trustee to transfer tokens\r\n    ///       Note: additional requirements are enforced within internal function.\r\n    /// @param _spender  Ethereum address of third party\r\n    /// @param _value    Maximum token amount that is allowed to get transferred\r\n    /// @return          Always true\r\n    function approve(address _spender, uint _value) public returns (bool) {\r\n        return _approve(msg.sender, _spender, _value);\r\n    }\r\n\r\n    /// @dev  Increase the amount of tokens a third party trustee may transfer\r\n    ///       Note: additional requirements are enforces within internal function.\r\n    /// @param _spender  Ethereum address of third party\r\n    /// @param _amount   Additional token amount that is allowed to get transferred\r\n    /// @return          Always true\r\n    function increaseAllowance(address _spender, uint _amount) public returns (bool) {\r\n        require(allowance_[msg.sender][_spender] + _amount >= _amount, \"Allowance overflow\");\r\n\r\n        return _approve(msg.sender, _spender, allowance_[msg.sender][_spender].add(_amount));\r\n    }\r\n\r\n    /// @dev  Decrease the amount of tokens a third party trustee may transfer\r\n    ///       Note: additional requirements are enforces within internal function.\r\n    /// @param _spender  Ethereum address of third party\r\n    /// @param _amount   Reduced token amount that is allowed to get transferred\r\n    /// @return          Always true\r\n    function decreaseAllowance(address _spender, uint _amount) public returns (bool) {\r\n        require(_amount <= allowance_[msg.sender][_spender], \"Amount exceeds allowance\");\r\n\r\n        return _approve(msg.sender, _spender, allowance_[msg.sender][_spender].sub(_amount));\r\n    }\r\n\r\n    /// @dev  Check if a token transfer is possible\r\n    /// @param _from   Ethereum address of token sender\r\n    /// @param _to     Ethereum address of token recipient\r\n    /// @param _value  Token amount to transfer\r\n    /// @return        True iff a transfer with given pramaters would succeed\r\n    function canTransfer(address _from, address _to, uint _value)\r\n        public view returns (bool)\r\n    {\r\n        return totalSupplyIsFixed\r\n            && _from != address(0x0)\r\n            && _to != address(0x0)\r\n            && _value <= accounts[_from].balance\r\n            && whitelist.isWhitelisted(_from)\r\n            && whitelist.isWhitelisted(_to);\r\n    }\r\n\r\n    /// @dev  Check if a token transfer by third party is possible\r\n    /// @param _spender  Ethereum address of third party trustee\r\n    /// @param _from     Ethereum address of token holder\r\n    /// @param _to       Ethereum address of token recipient\r\n    /// @param _value    Token amount to transfer\r\n    /// @return          True iff a transfer with given pramaters would succeed\r\n    function canTransferFrom(address _spender, address _from, address _to, uint _value)\r\n        public view returns (bool)\r\n    {\r\n        return canTransfer(_from, _to, _value) && _value <= allowance_[_from][_spender];\r\n    }\r\n\r\n    /// @dev  Token transfer\r\n    ///       Note: additional requirements are enforces within internal function.\r\n    /// @param _to     Ethereum address of token recipient\r\n    /// @param _value  Token amount to transfer\r\n    /// @return        Always true\r\n    function transfer(address _to, uint _value) public returns (bool) {\r\n        return _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    /// @dev  Token transfer by a third party\r\n    ///       Note: additional requirements are enforces within internal function.\r\n    /// @param _from   Ethereum address of token holder\r\n    /// @param _to     Ethereum address of token recipient\r\n    /// @param _value  Token amount to transfer\r\n    /// @return        Always true\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\r\n        require(_value <= allowance_[_from][msg.sender], \"Amount exceeds allowance\");\r\n\r\n        return _approve(_from, msg.sender, allowance_[_from][msg.sender].sub(_value))\r\n            && _transfer(_from, _to, _value);\r\n    }\r\n\r\n    /// @dev  Approve a third party trustee to transfer tokens (internal implementation)\r\n    /// @param _from     Ethereum address of token holder\r\n    /// @param _spender  Ethereum address of third party\r\n    /// @param _value    Maximum token amount the trustee is allowed to transfer\r\n    /// @return          Always true\r\n    function _approve(address _from, address _spender, uint _value)\r\n        internal\r\n        onlyWhitelisted(_from)\r\n        onlyWhenTotalSupplyIsFixed\r\n        returns (bool)\r\n    {\r\n        allowance_[_from][_spender] = _value;\r\n\r\n        emit Approval(_from, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev  Token transfer (internal implementation)\r\n    /// @param _from   Ethereum address of token sender\r\n    /// @param _to     Ethereum address of token recipient\r\n    /// @param _value  Token amount to transfer\r\n    /// @return        Always true\r\n    function _transfer(address _from, address _to, uint _value)\r\n        internal\r\n        onlyWhitelisted(_from)\r\n        onlyWhitelisted(_to)\r\n        onlyWhenTotalSupplyIsFixed\r\n        returns (bool)\r\n    {\r\n        require(_to != address(0x0), \"Recipient is zero\");\r\n        require(_value <= accounts[_from].balance, \"Amount exceeds balance\");\r\n\r\n        updateProfitShare(_from);\r\n        updateProfitShare(_to);\r\n\r\n        accounts[_from].balance = accounts[_from].balance.sub(_value);\r\n        accounts[_to].balance = accounts[_to].balance.add(_value);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/token/StokrTokenFactory.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n// Helper contract to deploy a new StokrToken contract\r\n\r\ncontract StokrTokenFactory {\r\n\r\n    function createNewToken(\r\n        string memory name,\r\n        string memory symbol,\r\n        Whitelist whitelist,\r\n        address profitDepositor,\r\n        address profitDistributor,\r\n        address tokenRecoverer\r\n    )\r\n        public\r\n        returns (StokrToken)\r\n    {\r\n        StokrToken token = new StokrToken(\r\n            name,\r\n            symbol,\r\n            whitelist,\r\n            profitDepositor,\r\n            profitDistributor,\r\n            tokenRecoverer);\r\n\r\n        token.transferOwnershipUnsafe(msg.sender);\r\n\r\n        return token;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"contract Whitelist\",\"name\":\"whitelist\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"profitDepositor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"profitDistributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenRecoverer\",\"type\":\"address\"}],\"name\":\"createNewToken\",\"outputs\":[{\"internalType\":\"contract StokrToken\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StokrTokenFactory","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://34f006b5db0245e4f48f2a50373ad5400b482601ac6b61c5a367972a33003db1"}]}