{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/E20Incentive.sol\r\n\r\npragma solidity 0.5.11;\r\n\r\n\r\n\r\n/**\r\n * @title E20 Incentive contract\r\n * @dev This contract manages the logic for a compensation scheme as an incentive for token transfers and sharing.\r\n */\r\ncontract E20Incentive {\r\n    //This contract uses a library for Safe Maths from OpenZeppelin\r\n    using SafeMath for uint;\r\n    //SetUp Variables\r\n    uint public ethFee; //Fee amount in ETH for subscription\r\n    uint public minToken; //Minimum amount of tokens required to get a subscription\r\n    uint public maxToken; //Maximum amount of tokens allowed to get a subscription\r\n    uint public intRate; //Fixed interest rate expressed from 0 to 1000 (0-100%) (ex: 1% = 10)\r\n    uint public intRounds; //Number of rounds to be allowed on a session\r\n    uint public bonusRate; //Fixed bonus rate expressed from 0 to 1000 (0-100%) (ex: 1% = 10)\r\n    IERC20 public tokenAddress; //Address of token to be used\r\n    address payable public platformWallet; //Address of platform manager\r\n    address payable public nextPlatformWallet; //Address of platform manager\r\n    uint public claimTime; //Time for each round\r\n\r\n    //Definition of a user account\r\n    struct UserAccount {\r\n        uint userBalance; //How much the user have deposited\r\n        uint intPaid; //How much interest the contract have paid to the user\r\n        uint intRound; //Which round is currently running\r\n        uint lastClaim; //Last claim time stamp\r\n        bool bonusClaimed; //Bonus claim flag\r\n        bool extension; //Session extension flag\r\n    }\r\n    //Mapping to register users' accounts\r\n    mapping (address=>UserAccount) public userAccounts;\r\n\r\n    //Total contract balance handler\r\n    uint private contractUsersBalance;\r\n\r\n    //EVENTS\r\n    event SessionClaim(address indexed _user, uint _amount, uint round);\r\n    event SessionBegin(address indexed _user, uint _balance);\r\n    event SessionExtended(address indexed _user, uint _balance);\r\n    event SessionEnd(address indexed _user, uint _intPaid);\r\n\r\n    /**\r\n     * @dev Constructor for the main contract\r\n     * @param _tokenAddress Adress of token to be incentivized\r\n     * @param _ethFee eth fee to be used for contract transactions\r\n     * @param _minToken minimum amount of tokens to be deposited\r\n     * @param _maxToken maximum amount of tokens to be deposited\r\n     * @param _intRate interest rate multiplied by 1000\r\n     * @param _intRounds interest rounds per session\r\n     * @param _bonusRate bonus interest rate multiplied by 1000\r\n     * @param _claimTime time per round in epoch format\r\n     * @param _platformWallet initial address of platform manager\r\n     */\r\n    constructor(\r\n        IERC20 _tokenAddress,\r\n        uint _ethFee,\r\n        uint _minToken,\r\n        uint _maxToken,\r\n        uint _intRate,\r\n        uint _intRounds,\r\n        uint _bonusRate,\r\n        uint _claimTime,\r\n        address payable _platformWallet\r\n        ) public {\r\n        tokenAddress = _tokenAddress;\r\n        ethFee = _ethFee;\r\n        minToken = _minToken;\r\n        maxToken = _maxToken;\r\n        intRate = _intRate;\r\n        intRounds = _intRounds;\r\n        bonusRate = _bonusRate;\r\n        claimTime = _claimTime;\r\n        platformWallet = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev This function allows a token holder to open an account on this contract and benefit from it\r\n     * @param _amount is the number of tokens to be deposited on the contract\r\n     */\r\n    function deposit(uint _amount) public payable {\r\n        //Require the eth fee\r\n        require(msg.value == ethFee, \"Please send the required fee amount for transactions\");\r\n        //Require the amount of tokens to be deposited to be between limits\r\n        require(_amount >= minToken && _amount <= maxToken, \"The amount of tokens must be between the set limits\");\r\n        //Require user to provide allowance on the amount of tokens to be deposited\r\n        require(tokenAddress.allowance(msg.sender,address(this)) >= _amount, \"Please assign the required allowance to the contract address\");\r\n        //Require the transfer from user's wallet to be successful\r\n        require(tokenAddress.transferFrom(msg.sender,address(this),_amount), \"Error on token transfer using function transferFrom\");\r\n        //Send ETH to Platform Wallet\r\n        platformWallet.transfer(address(this).balance);\r\n        //Update contract user's balance\r\n        contractUsersBalance = contractUsersBalance.add(_amount);\r\n        //Check if the user is getting registered for the first time\r\n        if (userAccounts[msg.sender].intRound == 0) {\r\n            //If it is, create a new user account\r\n            userAccounts[msg.sender] = UserAccount({\r\n                userBalance: _amount,\r\n                intPaid: 0,\r\n                intRound: 0,\r\n                lastClaim: now,\r\n                bonusClaimed: false,\r\n                extension: false});\r\n\r\n            emit SessionBegin(msg.sender,_amount);\r\n\r\n        } else if (userAccounts[msg.sender].intRound == intRounds && userAccounts[msg.sender].extension == false) {\r\n            //If it's not but the user is allowed to claim an extension, update it's account\r\n            userAccounts[msg.sender].userBalance = _amount;\r\n            userAccounts[msg.sender].lastClaim = now;\r\n            userAccounts[msg.sender].extension = true;\r\n\r\n            emit SessionExtended(msg.sender, _amount);\r\n\r\n        } else {\r\n            //If doesn't fall in any case, revert the transaction\r\n            revert(\"You cannot renew your suscription\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev A function to allow users to claim their benefits from the contract\r\n     */\r\n    function claim() public {\r\n        //Require the user to hold some balance ont he contract\r\n        require(userAccounts[msg.sender].userBalance != 0, \"You don't have anything to claim\");\r\n        //Require te user to have passed the minimum round time\r\n        require(now.sub(userAccounts[msg.sender].lastClaim) >= claimTime, \"The claimTime have not passed yet, try again later\");\r\n\r\n        uint intToPay; //Aux variable to handle interest calculation\r\n        uint toTransfer; //Aux variable to handle total transfer amount\r\n        userAccounts[msg.sender].lastClaim = now; //Update last claim time\r\n        userAccounts[msg.sender].intRound = userAccounts[msg.sender].intRound.add(1); //Update round\r\n\r\n        //Check if the user have claimed the bonus\r\n        if(userAccounts[msg.sender].bonusClaimed == false) {\r\n            //If it's not, update the account flag\r\n            userAccounts[msg.sender].bonusClaimed = true;\r\n            //Calculate the bonus\r\n            intToPay = userAccounts[msg.sender].userBalance.mul(bonusRate);\r\n            intToPay = intToPay.div(1000);\r\n        } else {\r\n            //If it already claimed the bonus, calculate normal interest\r\n            intToPay = userAccounts[msg.sender].userBalance.mul(intRate);\r\n            intToPay = intToPay.div(1000);\r\n        }\r\n\r\n        //Update interest paid\r\n        userAccounts[msg.sender].intPaid = userAccounts[msg.sender].intPaid.add(intToPay);\r\n\r\n        //Check if user is on final round\r\n        if((userAccounts[msg.sender].extension == false && userAccounts[msg.sender].intRound == intRounds) ||\r\n           (userAccounts[msg.sender].extension == true && userAccounts[msg.sender].intRound == intRounds.mul(2))\r\n        ){\r\n            //If it is, get user balance on contract\r\n            toTransfer = userAccounts[msg.sender].userBalance;\r\n            //Update contract user's balance\r\n            contractUsersBalance = contractUsersBalance.sub(userAccounts[msg.sender].userBalance);\r\n            //And reset user balance on contract to 0\r\n            userAccounts[msg.sender].userBalance = 0;\r\n\r\n            emit SessionEnd(msg.sender, userAccounts[msg.sender].intPaid);\r\n        }\r\n\r\n        //SumUp amount to transfer\r\n        toTransfer = toTransfer.add(intToPay);\r\n\r\n        //Require transfer to be done\r\n        require(tokenAddress.transfer(msg.sender,toTransfer), \"Error on token transfer using function transfer\");\r\n\r\n        emit SessionClaim(msg.sender, userAccounts[msg.sender].intPaid, userAccounts[msg.sender].intRound);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Function to retrieve any stuck token on the contract, it can only be used by the platform wallet owner\r\n     * @param _tokenAddress Token contract address\r\n     * @param _value amount of tokens to move\r\n     * @param _to address to move tokens to\r\n     */\r\n    function ERC20Recovery(IERC20 _tokenAddress, uint _value, address _to) public{\r\n        //Only the contract platform wallet owner is allowed to use this function\r\n        require(msg.sender == platformWallet, \"You are not allowed to use this function\");\r\n\r\n        if(tokenAddress == _tokenAddress){\r\n            //Check that the platform manager is not retrieven user's tokens\r\n            uint currentContractsBalance = tokenAddress.balanceOf(address(this));\r\n            require(currentContractsBalance.sub(_value) >= contractUsersBalance, \"You are not allowed to retrieve user's tokens\");\r\n            tokenAddress.transfer(_to,_value);\r\n        } else {\r\n            _tokenAddress.transfer(_to,_value);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Function to allow the manager to propose a new manager wallet\r\n    * @param _newPlatformWallet the new wallet to be used as manager one\r\n    */\r\n    function proposePlatformWallet(address payable _newPlatformWallet) public {\r\n        //Only the contract platform wallet owner is allowed to use this function\r\n        require(msg.sender == platformWallet, \"You are not allowed to use this function\");\r\n        require(_newPlatformWallet != address(0), \"New wallet must be different from zero\");\r\n        nextPlatformWallet = _newPlatformWallet;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to accept or reject the contract management ownership\r\n     * @param _accept boolean answer: Accep = true, Reject = false\r\n     */\r\n    function acceptPlatformWallet(bool _accept) public {\r\n        //Only the new contract platform wallet owner is allowed to use this function\r\n        require(msg.sender == nextPlatformWallet, \"You are not allowed to use this function\");\r\n        if(_accept) {\r\n            platformWallet = nextPlatformWallet;\r\n            nextPlatformWallet = address(0);\r\n        } else {\r\n            nextPlatformWallet = address(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev FallBack function will forward to claim function\r\n     */\r\n    function() external {\r\n        claim();\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"claimTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"ERC20Recovery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"userBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"intPaid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"intRound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaim\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"bonusClaimed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"extension\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextPlatformWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"intRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newPlatformWallet\",\"type\":\"address\"}],\"name\":\"proposePlatformWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_accept\",\"type\":\"bool\"}],\"name\":\"acceptPlatformWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"intRounds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"platformWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_ethFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_intRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_intRounds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bonusRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimTime\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_platformWallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"SessionClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"SessionBegin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"SessionExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_intPaid\",\"type\":\"uint256\"}],\"name\":\"SessionEnd\",\"type\":\"event\"}]","ContractName":"E20Incentive","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000cfd6ae8bf13f42de14867351eaff7a8a3b9fbbe7000000000000000000000000000000000000000000000000008e1bc9bf04000000000000000000000000000000000000000000000000000000000004a817c800000000000000000000000000000000000000000000000000000000174876e800000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000070000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000001518000000000000000000000000060fe9b4f8239b5d804af3855fd101c4b759d245b","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://191e75815b5143b9ddae81bb85b0f24e72cb568b7caea663d3e6fc409c006ec1"}]}