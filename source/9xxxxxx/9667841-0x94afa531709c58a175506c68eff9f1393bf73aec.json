{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    require(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    require(token.approve(spender, value));\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n// DAI and ETH have different implements of this methods but we require implement this method\r\ncontract SmartFundOverrideInterface {\r\n  function calculateFundValue() public view returns (uint256);\r\n  function getTokenValue(ERC20 _token) public view returns (uint256);\r\n}\r\ncontract PermittedPoolsInterface {\r\n  mapping (address => bool) public permittedAddresses;\r\n}\r\ncontract PermittedExchangesInterface {\r\n  mapping (address => bool) public permittedAddresses;\r\n}\r\n\r\n\r\ncontract PoolPortalInterface {\r\n  function buyPool\r\n  (\r\n    uint256 _amount,\r\n    uint _type,\r\n    ERC20 _poolToken\r\n  )\r\n  external\r\n  payable;\r\n\r\n  function sellPool\r\n  (\r\n    uint256 _amount,\r\n    uint _type,\r\n    ERC20 _poolToken\r\n  )\r\n  external\r\n  payable;\r\n\r\n  function getBacorConverterAddressByRelay(address relay)\r\n  public\r\n  view\r\n  returns(address converter);\r\n\r\n  function getBancorConnectorsAmountByRelayAmount\r\n  (\r\n    uint256 _amount,\r\n    ERC20 _relay\r\n  )\r\n  public view returns(uint256 bancorAmount, uint256 connectorAmount);\r\n\r\n  function getBancorConnectorsByRelay(address relay)\r\n  public\r\n  view\r\n  returns(\r\n    ERC20 BNTConnector,\r\n    ERC20 ERCConnector\r\n  );\r\n\r\n  function getBancorRatio(address _from, address _to, uint256 _amount)\r\n  public\r\n  view\r\n  returns(uint256);\r\n\r\n  function getUniswapConnectorsAmountByPoolAmount(\r\n    uint256 _amount,\r\n    address _exchange\r\n  )\r\n  public\r\n  view\r\n  returns(uint256 ethAmount, uint256 ercAmount);\r\n\r\n  function getUniswapTokenAmountByETH(address _token, uint256 _amount)\r\n  public\r\n  view\r\n  returns(uint256);\r\n\r\n  function getTokenByUniswapExchange(address _exchange)\r\n  public\r\n  view\r\n  returns(address);\r\n}\r\n\r\n\r\ncontract ExchangePortalInterface {\r\n\r\n  event Trade(address src, uint256 srcAmount, address dest, uint256 destReceived);\r\n\r\n  function trade(\r\n    ERC20 _source,\r\n    uint256 _sourceAmount,\r\n    ERC20 _destination,\r\n    uint256 _type,\r\n    bytes32[] _additionalArgs,\r\n    bytes _additionalData\r\n  )\r\n    external\r\n    payable\r\n    returns (uint256);\r\n\r\n  function getValue(address _from, address _to, uint256 _amount) public view returns (uint256);\r\n  function getTotalValue(address[] _fromAddresses, uint256[] _amounts, address _to) public view returns (uint256);\r\n}\r\n\r\n\r\ncontract CToken {\r\n    address public underlying;\r\n    function transfer(address dst, uint256 amount) external returns (bool);\r\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function repayBorrow(uint repayAmount) external returns (uint);\r\n    function liquidateBorrow(address borrower, uint repayAmount, CToken cTokenCollateral) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function exchangeRateCurrent() external view returns (uint);\r\n    function totalSupply() external view returns(uint);\r\n    function balanceOfUnderlying(address account) external view returns (uint);\r\n}\r\n\r\n\r\ncontract SmartFundInterface {\r\n  // the total number of shares in the fund\r\n  uint256 totalShares;\r\n\r\n  // how many shares belong to each address\r\n  mapping (address => uint256) public addressToShares;\r\n  // sends percentage of fund tokens to the user\r\n  // function withdraw() external;\r\n  function withdraw(uint256 _percentageWithdraw) external;\r\n\r\n  // for smart fund owner to trade tokens\r\n  function trade(\r\n    ERC20 _source,\r\n    uint256 _sourceAmount,\r\n    ERC20 _destination,\r\n    uint256 _type,\r\n    bytes32[] additionalArgs,\r\n    bytes _additionalData\r\n  )\r\n    external;\r\n\r\n  function buyPool(\r\n    uint256 _amount,\r\n    uint _type,\r\n    ERC20 _poolToken\r\n  )\r\n    external;\r\n\r\n  function sellPool(\r\n    uint256 _amount,\r\n    uint _type,\r\n    ERC20 _poolToken\r\n  )\r\n    external;\r\n\r\n  // calculates the number of shares a buyer will receive for depositing `amount` of ether\r\n  function calculateDepositToShares(uint256 _amount) public view returns (uint256);\r\n}\r\n\r\n\r\n\r\ncontract CEther{\r\n    function transfer(address dst, uint256 amount) external returns (bool);\r\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function mint() external payable;\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function repayBorrow() external payable;\r\n    function liquidateBorrow(address borrower, CToken cTokenCollateral) external payable;\r\n    function exchangeRateCurrent() external view returns (uint);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOfUnderlying(address account) external view returns (uint);\r\n}\r\n// due eip-170 error we should create 2 factory one for ETH another for USD\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n* This contract inherits logic of SmartFundCore and implements logic of Compound.\r\n* Perhaps in the future we will need select for inherit the logic of Lend or not,\r\n* therefore, this logic must be separate\r\n*\r\n* NOTE: maybe in future, if we don't need implement borrow logic, and no need bind\r\n* debt with msg.sender, we can do Compound logic as addition portal\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n  The SmartFund contract is what holds all the tokens and ether, and contains all the logic\r\n  for calculating its value (and ergo profit), allows users to deposit/withdraw their funds,\r\n  and calculates the fund managers cut of the funds profit among other things.\r\n  The SmartFund gets the value of its token holdings (in Ether) and trades through the ExchangePortal\r\n  contract. This means that as new exchange capabalities are added to new exchange portals, the\r\n  SmartFund will be able to upgrade to a new exchange portal, and trade a wider variety of assets\r\n  with a wider variety of exchanges. The SmartFund is also connected to a PermittedExchanges contract,\r\n  which determines which exchange portals the SmartFund is allowed to connect to, restricting\r\n  the fund owners ability to connect to a potentially malicious contract.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\ncontract SmartFundCore is SmartFundOverrideInterface, Ownable, ERC20 {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for ERC20;\r\n\r\n  // Total amount of ether or stable deposited by all users\r\n  uint256 public totalWeiDeposited = 0;\r\n\r\n  // Total amount of ether or stable withdrawn by all users\r\n  uint256 public totalWeiWithdrawn = 0;\r\n\r\n  // The Interface of the Exchange Portal\r\n  ExchangePortalInterface public exchangePortal;\r\n\r\n  // The Interface of pool portall\r\n  PoolPortalInterface public poolPortal;\r\n\r\n  // The Smart Contract which stores the addresses of all the authorized Exchange Portals\r\n  PermittedExchangesInterface public permittedExchanges;\r\n\r\n  // The Smart Contract which stores the addresses of all the authorized Pools Portals\r\n  PermittedPoolsInterface public permittedPools;\r\n\r\n  // KyberExchange recognizes ETH by this address\r\n  ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n\r\n  // For ERC20 compliance\r\n  string public name;\r\n\r\n  // The maximum amount of tokens that can be traded via the smart fund\r\n  uint256 public MAX_TOKENS = 50;\r\n\r\n  // Percentages are rounded to 3 decimal places\r\n  uint256 public TOTAL_PERCENTAGE = 10000;\r\n\r\n  // Address of the platform that takes a cut from the fund manager success cut\r\n  address public platformAddress;\r\n\r\n  // The percentage of earnings paid to the fund manager. 10000 = 100%\r\n  // e.g. 10% is 1000\r\n  uint256 public successFee;\r\n\r\n  // The percentage of fund manager earnings paid to the platform. 10000 = 100%\r\n  // e.g. 10% is 1000\r\n  uint256 public platformFee;\r\n\r\n  // An array of all the erc20 token addresses the smart fund holds\r\n  address[] public tokenAddresses;\r\n\r\n  // mapping for check certain token is relay or not\r\n  mapping(address => bool) public isRelay;\r\n\r\n  // Boolean value that determines whether the fund accepts deposits from anyone or\r\n  // only specific addresses approved by the manager\r\n  bool public onlyWhitelist = false;\r\n\r\n  // Mapping of addresses that are approved to deposit if the manager only want's specific\r\n  // addresses to be able to invest in their fund\r\n  mapping (address => bool) public whitelist;\r\n\r\n  uint public version = 5;\r\n\r\n  // the total number of shares in the fund\r\n  uint256 public totalShares = 0;\r\n\r\n  // Denomination of initial shares\r\n  uint256 constant internal INITIAL_SHARES = 10 ** 18;\r\n\r\n  // The earnings the fund manager has already cashed out\r\n  uint256 public fundManagerCashedOut = 0;\r\n\r\n  // how many shares belong to each address\r\n  mapping (address => uint256) public addressToShares;\r\n\r\n  // so that we can easily check that we don't add duplicates to our array\r\n  mapping (address => bool) public tokensTraded;\r\n\r\n  // this is really only being used to more easily show profits, but may not be necessary\r\n  // if we do a lot of this offchain using events to track everything\r\n  // total `depositToken` deposited - total `depositToken` withdrawn\r\n  mapping (address => int256) public addressesNetDeposit;\r\n\r\n  // Events\r\n  event BuyPool(address poolToken, uint256 amount);\r\n  event SellPool(address poolToken, uint256 amount);\r\n  event Deposit(address indexed user, uint256 amount, uint256 sharesReceived, uint256 totalShares);\r\n  event Withdraw(address indexed user, uint256 sharesRemoved, uint256 totalShares);\r\n  event Trade(address src, uint256 srcAmount, address dest, uint256 destReceived);\r\n  event SmartFundCreated(address indexed owner);\r\n\r\n  // enum\r\n  enum PortalType { Bancor, Uniswap }\r\n\r\n  constructor(\r\n    address _owner,\r\n    string _name,\r\n    uint256 _successFee,\r\n    uint256 _platformFee,\r\n    address _platformAddress,\r\n    address _exchangePortalAddress,\r\n    address _permittedExchangesAddress,\r\n    address _permittedPoolsAddress,\r\n    address _poolPortalAddress\r\n  )public{\r\n    // never allow a 100% fee\r\n    require(_successFee < TOTAL_PERCENTAGE);\r\n    require(_platformFee < TOTAL_PERCENTAGE);\r\n\r\n    name = _name;\r\n    successFee = _successFee;\r\n    platformFee = _platformFee;\r\n\r\n    if(_owner == address(0)){\r\n      owner = msg.sender;\r\n    }\r\n    else{\r\n      owner = _owner;\r\n    }\r\n\r\n    if(_platformAddress == address(0)){\r\n      platformAddress = msg.sender;\r\n    }\r\n    else{\r\n      platformAddress = _platformAddress;\r\n    }\r\n\r\n    // Initial Token is Ether\r\n    tokenAddresses.push(address(ETH_TOKEN_ADDRESS));\r\n\r\n    // Initial interfaces\r\n    exchangePortal = ExchangePortalInterface(_exchangePortalAddress);\r\n    permittedExchanges = PermittedExchangesInterface(_permittedExchangesAddress);\r\n    permittedPools = PermittedPoolsInterface(_permittedPoolsAddress);\r\n    poolPortal = PoolPortalInterface(_poolPortalAddress);\r\n\r\n    emit SmartFundCreated(owner);\r\n  }\r\n\r\n  /**\r\n  * @dev Sends (_mul/_div) of every token (and ether) the funds holds to _withdrawAddress\r\n  *\r\n  * @param _mul                The numerator\r\n  * @param _div                The denominator\r\n  * @param _withdrawAddress    Address to send the tokens/ether to\r\n  *\r\n  * NOTE: _withdrawAddress changed from address to address[] arrays because balance calculation should be performed\r\n  * once for all usesr who wants to withdraw from the current balance.\r\n  *\r\n  */\r\n  function _withdraw(uint256[] _mul, uint256[] _div, address[] memory _withdrawAddress) internal returns (uint256) {\r\n    for (uint8 i = 1; i < tokenAddresses.length; i++) {\r\n      // Transfer that _mul/_div of each token we hold to the user\r\n      ERC20 token = ERC20(tokenAddresses[i]);\r\n      uint256 fundAmount = token.balanceOf(address(this));\r\n\r\n      // Transfer ERC20 to _withdrawAddress\r\n      for(uint8 j = 0; j < _withdrawAddress.length; j++){\r\n        uint256 payoutAmount = fundAmount.mul(_mul[j]).div(_div[j]);\r\n        token.transfer(_withdrawAddress[j], payoutAmount);\r\n      }\r\n    }\r\n     uint256 etherBalance = address(this).balance;\r\n     // Transfer ETH to _withdrawAddress\r\n     for(uint8 k = 0; k < _withdrawAddress.length; k++){\r\n       uint256 etherPayoutAmount = (etherBalance).mul(_mul[k]).div(_div[k]);\r\n       _withdrawAddress[k].transfer(etherPayoutAmount);\r\n     }\r\n  }\r\n\r\n  /**\r\n  * @dev Withdraws users fund holdings, sends (userShares/totalShares) of every held token\r\n  * to msg.sender, defaults to 100% of users shares.\r\n  *\r\n  * @param _percentageWithdraw    The percentage of the users shares to withdraw.\r\n  */\r\n  function withdraw(uint256 _percentageWithdraw) external {\r\n    require(totalShares != 0);\r\n\r\n    uint256 percentageWithdraw = (_percentageWithdraw == 0) ? TOTAL_PERCENTAGE : _percentageWithdraw;\r\n\r\n    uint256 addressShares = addressToShares[msg.sender];\r\n\r\n    uint256 numberOfWithdrawShares = addressShares.mul(percentageWithdraw).div(TOTAL_PERCENTAGE);\r\n\r\n    uint256 fundManagerCut;\r\n    uint256 fundValue;\r\n\r\n    // Withdraw the users share minus the fund manager's success fee\r\n    (fundManagerCut, fundValue, ) = calculateFundManagerCut();\r\n\r\n    uint256 withdrawShares = numberOfWithdrawShares.mul(fundValue.sub(fundManagerCut)).div(fundValue);\r\n\r\n    // prepare call data for _withdarw\r\n    address[] memory spenders = new address[](1);\r\n    spenders[0] = msg.sender;\r\n\r\n    uint256[] memory value = new uint256[](1);\r\n    value[0] = totalShares;\r\n\r\n    uint256[] memory cut = new uint256[](1);\r\n    cut[0] = withdrawShares;\r\n\r\n    // do withdraw\r\n    _withdraw(cut, value, spenders);\r\n\r\n    // Store the value we are withdrawing in ether\r\n    uint256 valueWithdrawn = fundValue.mul(withdrawShares).div(totalShares);\r\n\r\n    totalWeiWithdrawn = totalWeiWithdrawn.add(valueWithdrawn);\r\n    addressesNetDeposit[msg.sender] -= int256(valueWithdrawn);\r\n\r\n    // Subtract from total shares the number of withdrawn shares\r\n    totalShares = totalShares.sub(numberOfWithdrawShares);\r\n    addressToShares[msg.sender] = addressToShares[msg.sender].sub(numberOfWithdrawShares);\r\n\r\n    emit Withdraw(msg.sender, numberOfWithdrawShares, totalShares);\r\n  }\r\n\r\n  /**\r\n  * @dev Facilitates a trade of the funds holdings via the exchange portal\r\n  *\r\n  * @param _source            ERC20 token to convert from\r\n  * @param _sourceAmount      Amount to convert (in _source token)\r\n  * @param _destination       ERC20 token to convert to\r\n  * @param _type              The type of exchange to trade with\r\n  * @param _additionalArgs    Array of bytes32 additional arguments\r\n  * @param _additionalData    For any size data (if not used set just 0x0)\r\n  */\r\n  function trade(\r\n    ERC20 _source,\r\n    uint256 _sourceAmount,\r\n    ERC20 _destination,\r\n    uint256 _type,\r\n    bytes32[] _additionalArgs,\r\n    bytes _additionalData\r\n  ) external onlyOwner {\r\n\r\n    uint256 receivedAmount;\r\n\r\n    if (_source == ETH_TOKEN_ADDRESS) {\r\n      // Make sure fund contains enough ether\r\n      require(address(this).balance >= _sourceAmount);\r\n      // Call trade on ExchangePortal along with ether\r\n      receivedAmount = exchangePortal.trade.value(_sourceAmount)(\r\n        _source,\r\n        _sourceAmount,\r\n        _destination,\r\n        _type,\r\n        _additionalArgs,\r\n        _additionalData\r\n      );\r\n    } else {\r\n      _source.approve(exchangePortal, _sourceAmount);\r\n      receivedAmount = exchangePortal.trade(\r\n        _source,\r\n        _sourceAmount,\r\n        _destination,\r\n        _type,\r\n        _additionalArgs,\r\n        _additionalData\r\n      );\r\n    }\r\n\r\n    if (receivedAmount > 0)\r\n      _addToken(_destination);\r\n\r\n    emit Trade(_source, _sourceAmount, _destination, receivedAmount);\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev buy pool via pool portal\r\n  *\r\n  * @param _amount        For Bancor amount it's relay, for Uniswap amount it's ETH\r\n  * @param _type          type of pool (0 - Bancor, 1 - Uniswap)\r\n  * @param _poolToken     address of relay for Bancor and exchange for Uniswap\r\n  */\r\n  function buyPool(\r\n   uint256 _amount,\r\n   uint _type,\r\n   ERC20 _poolToken\r\n  )\r\n  external onlyOwner {\r\n   // buy Bancor or Uniswap pool\r\n   if(_type == uint(PortalType.Bancor))\r\n    _buyBancorPool(_amount, _type, _poolToken);\r\n   if(_type == uint(PortalType.Uniswap))\r\n    _buyUniswapPool(_amount, _type, _poolToken);\r\n\r\n   // add new pool in fund\r\n   uint256 poolBalance = _poolToken.balanceOf(address(this));\r\n   if(poolBalance > 0){\r\n     // Add relay as ERC20 for withdraw assets\r\n     _addToken(address(_poolToken));\r\n     // Mark this token as relay\r\n     _markAsRelay(address(_poolToken));\r\n   }\r\n\r\n   // emit event\r\n   emit BuyPool(_poolToken, _amount);\r\n  }\r\n\r\n  // Helper for buy Uniswap pool\r\n  function _buyUniswapPool(\r\n    uint256 _amount,\r\n    uint _type,\r\n    ERC20 _poolToken\r\n  )\r\n  private\r\n  {\r\n    // approve connector\r\n    ERC20 token = ERC20(poolPortal.getTokenByUniswapExchange(_poolToken));\r\n    token.approve(address(poolPortal), token.balanceOf(address(this)));\r\n\r\n    // buy pool via ETH amount payable\r\n    poolPortal.buyPool.value(_amount)(\r\n     _amount,\r\n     _type,\r\n    _poolToken\r\n    );\r\n\r\n    //reset approve\r\n    token.approve(address(poolPortal), 0);\r\n  }\r\n\r\n  // Helper for buy Bancor pool\r\n  function _buyBancorPool(\r\n    uint256 _amount,\r\n    uint _type,\r\n    ERC20 _poolToken\r\n  ) private\r\n  {\r\n    // get connectors\r\n    (ERC20 bancorConnector,\r\n       ERC20 ercConnector) = poolPortal.getBancorConnectorsByRelay(address(_poolToken));\r\n\r\n    // Approve all connectors to pool portal (pool calculates the required amount dynamicly)\r\n    bancorConnector.approve(address(poolPortal), bancorConnector.balanceOf(address(this)));\r\n    ercConnector.approve(address(poolPortal), ercConnector.balanceOf(address(this)));\r\n\r\n    // buy pool(relay) via relay amount not payable\r\n    poolPortal.buyPool(\r\n     _amount,\r\n     _type,\r\n    _poolToken\r\n    );\r\n\r\n    // reset approve\r\n    bancorConnector.approve(address(poolPortal), 0);\r\n    ercConnector.approve(address(poolPortal), 0);\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev sell pool via pool portal\r\n  *\r\n  * @param _amount        amount of Bancor relay or Uniswap exchange to sell\r\n  * @param _type          type of pool (0 - Bancor, 1 - Uniswap)\r\n  * @param _poolToken     address of Bancor relay or Uniswap exchange\r\n  */\r\n  function sellPool(\r\n    uint256 _amount,\r\n    uint _type,\r\n    ERC20 _poolToken\r\n  )\r\n  external onlyOwner {\r\n    // approve\r\n    _poolToken.approve(address(poolPortal), _amount);\r\n\r\n    // sell\r\n    poolPortal.sellPool(\r\n      _amount,\r\n      _type,\r\n     _poolToken\r\n    );\r\n\r\n    // add to fund pool connectors\r\n    if(_type == uint(PortalType.Bancor))\r\n     _addBancorResereve(_poolToken);\r\n\r\n    if(_type == uint(PortalType.Uniswap))\r\n     _addUniswapReserve(_poolToken);\r\n\r\n    // event\r\n    emit SellPool(_poolToken, _amount);\r\n  }\r\n\r\n  // Helper for exctract Bancor pool connectos and add this connectors to fund\r\n  function _addBancorResereve(address _poolToken)\r\n  private\r\n  {\r\n    // get bancor connectors addresses\r\n    (ERC20 bancorConnector,\r\n      ERC20 ercConnector) = poolPortal.getBancorConnectorsByRelay(\r\n        address(_poolToken));\r\n\r\n    // add returned assets in fund as tokens (for case if manager removed this assets)\r\n    _addToken(address(bancorConnector));\r\n    _addToken(address(ercConnector));\r\n  }\r\n\r\n  // Helper for exctract Uniswap pool connector and add this connector to fund\r\n  function _addUniswapReserve(address _poolToken)\r\n  private\r\n  {\r\n    // extract Uniswap connector\r\n    address tokenAddress = poolPortal.getTokenByUniswapExchange(_poolToken);\r\n    // add returned asset to fund(for case if manager removed this asset)\r\n    _addToken(tokenAddress);\r\n  }\r\n\r\n  function getAllTokenAddresses() public view returns (address[]) {\r\n    return tokenAddresses;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds a token to tokensTraded if it's not already there\r\n  * @param _token    The token to add\r\n  */\r\n  function _addToken(address _token) internal {\r\n    // don't add token to if we already have it in our list\r\n    if (tokensTraded[_token] || (_token == address(ETH_TOKEN_ADDRESS)))\r\n      return;\r\n\r\n    tokensTraded[_token] = true;\r\n    uint256 tokenCount = tokenAddresses.push(_token);\r\n\r\n    // we can't hold more than MAX_TOKENS tokens\r\n    require(tokenCount <= MAX_TOKENS);\r\n  }\r\n\r\n  /**\r\n  * @dev Removes a token from tokensTraded\r\n  *\r\n  * @param _token         The address of the token to be removed\r\n  * @param _tokenIndex    The index of the token to be removed\r\n  *\r\n  */\r\n  function removeToken(address _token, uint256 _tokenIndex) public onlyOwner {\r\n    require(_token != address(ETH_TOKEN_ADDRESS));\r\n    require(tokensTraded[_token]);\r\n    require(ERC20(_token).balanceOf(address(this)) == 0);\r\n    require(tokenAddresses[_tokenIndex] == _token);\r\n\r\n    tokensTraded[_token] = false;\r\n\r\n    // remove token from array\r\n    uint256 arrayLength = tokenAddresses.length - 1;\r\n    tokenAddresses[_tokenIndex] = tokenAddresses[arrayLength];\r\n    delete tokenAddresses[arrayLength];\r\n    tokenAddresses.length--;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n  * @dev mark ERC20 as relay\r\n  * @param _token   The token address to mark as relay\r\n  */\r\n  function _markAsRelay(address _token) internal {\r\n    isRelay[_token] = true;\r\n  }\r\n\r\n  // get all fund data in one call\r\n  function getSmartFundData() public view returns (\r\n    address _owner,\r\n    string _name,\r\n    uint256 _totalShares,\r\n    address[] _tokenAddresses,\r\n    uint256 _successFee\r\n  ) {\r\n    _owner = owner;\r\n    _name = name;\r\n    _totalShares = totalShares;\r\n    _tokenAddresses = tokenAddresses;\r\n    _successFee = successFee;\r\n  }\r\n\r\n  /**\r\n  * @dev Calculates the funds profit\r\n  *\r\n  * @return The funds profit in deposit token (Ether)\r\n  */\r\n  function calculateFundProfit() public view returns (int256) {\r\n    uint256 fundValue = calculateFundValue();\r\n\r\n    return int256(fundValue) + int256(totalWeiWithdrawn) - int256(totalWeiDeposited);\r\n  }\r\n\r\n  /**\r\n  * @dev Calculates the amount of shares received according to ether deposited\r\n  *\r\n  * @param _amount    Amount of ether to convert to shares\r\n  *\r\n  * @return Amount of shares to be received\r\n  */\r\n  function calculateDepositToShares(uint256 _amount) public view returns (uint256) {\r\n    uint256 fundManagerCut;\r\n    uint256 fundValue;\r\n\r\n    // If there are no shares in the contract, whoever deposits owns 100% of the fund\r\n    // we will set this to 10^18 shares, but this could be any amount\r\n    if (totalShares == 0)\r\n      return INITIAL_SHARES;\r\n\r\n    (fundManagerCut, fundValue, ) = calculateFundManagerCut();\r\n\r\n    uint256 fundValueBeforeDeposit = fundValue.sub(_amount).sub(fundManagerCut);\r\n\r\n    if (fundValueBeforeDeposit == 0)\r\n      return 0;\r\n\r\n    return _amount.mul(totalShares).div(fundValueBeforeDeposit);\r\n\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev Calculates the fund managers cut, depending on the funds profit and success fee\r\n  *\r\n  * @return fundManagerRemainingCut    The fund managers cut that they have left to withdraw\r\n  * @return fundValue                  The funds current value\r\n  * @return fundManagerTotalCut        The fund managers total cut of the profits until now\r\n  */\r\n  function calculateFundManagerCut() public view returns (\r\n    uint256 fundManagerRemainingCut, // fm's cut of the profits that has yet to be cashed out (in `depositToken`)\r\n    uint256 fundValue, // total value of fund (in `depositToken`)\r\n    uint256 fundManagerTotalCut // fm's total cut of the profits (in `depositToken`)\r\n  ) {\r\n    fundValue = calculateFundValue();\r\n    // The total amount of ether currently deposited into the fund, takes into account the total ether\r\n    // withdrawn by investors as well as ether withdrawn by the fund manager\r\n    // NOTE: value can be negative if the manager performs well and investors withdraw more\r\n    // ether than they deposited\r\n    int256 curtotalWeiDeposited = int256(totalWeiDeposited) - int256(totalWeiWithdrawn.add(fundManagerCashedOut));\r\n\r\n    // If profit < 0, the fund managers totalCut and remainingCut are 0\r\n    if (int256(fundValue) <= curtotalWeiDeposited) {\r\n      fundManagerTotalCut = 0;\r\n      fundManagerRemainingCut = 0;\r\n    } else {\r\n      // calculate profit. profit = current fund value - total deposited + total withdrawn + total withdrawn by fm\r\n      uint256 profit = uint256(int256(fundValue) - curtotalWeiDeposited);\r\n      // remove the money already taken by the fund manager and take percentage\r\n      fundManagerTotalCut = profit.mul(successFee).div(TOTAL_PERCENTAGE);\r\n      fundManagerRemainingCut = fundManagerTotalCut.sub(fundManagerCashedOut);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Allows the fund manager to withdraw their cut of the funds profit\r\n  */\r\n  function fundManagerWithdraw() public onlyOwner {\r\n    uint256 fundManagerCut;\r\n    uint256 fundValue;\r\n\r\n    (fundManagerCut, fundValue, ) = calculateFundManagerCut();\r\n\r\n    uint256 platformCut = (platformFee == 0) ? 0 : fundManagerCut.mul(platformFee).div(TOTAL_PERCENTAGE);\r\n\r\n    // prepare call data for _withdarw\r\n    address[] memory spenders = new address[](2);\r\n    spenders[0] = platformAddress;\r\n    spenders[1] = owner;\r\n\r\n    uint256[] memory value = new uint256[](2);\r\n    value[0] = fundValue;\r\n    value[1] = fundValue;\r\n\r\n    uint256[] memory cut = new uint256[](2);\r\n    cut[0] = platformCut;\r\n    cut[1] = fundManagerCut - platformCut;\r\n\r\n    // do withdraw\r\n    _withdraw(cut, value, spenders);\r\n\r\n    // add report\r\n    fundManagerCashedOut = fundManagerCashedOut.add(fundManagerCut);\r\n  }\r\n\r\n  // calculate the current value of an address's shares in the fund\r\n  function calculateAddressValue(address _address) public view returns (uint256) {\r\n    if (totalShares == 0)\r\n      return 0;\r\n\r\n    return calculateFundValue().mul(addressToShares[_address]).div(totalShares);\r\n  }\r\n\r\n  // calculate the net profit/loss for an address in this fund\r\n  function calculateAddressProfit(address _address) public view returns (int256) {\r\n    uint256 currentAddressValue = calculateAddressValue(_address);\r\n\r\n    return int256(currentAddressValue) - addressesNetDeposit[_address];\r\n  }\r\n\r\n  // This method was added to easily record the funds token balances, may (should?) be removed in the future\r\n  function getFundTokenHolding(ERC20 _token) external view returns (uint256) {\r\n    if (_token == ETH_TOKEN_ADDRESS)\r\n      return address(this).balance;\r\n    return _token.balanceOf(address(this));\r\n  }\r\n\r\n  /**\r\n  * @dev Allows the manager to set whether or not only whitelisted addresses can deposit into\r\n  * their fund\r\n  *\r\n  * @param _onlyWhitelist    boolean representing whether only whitelisted addresses can deposit\r\n  */\r\n  function setWhitelistOnly(bool _onlyWhitelist) external onlyOwner {\r\n    onlyWhitelist = _onlyWhitelist;\r\n  }\r\n\r\n  /**\r\n  * @dev Allows the fund manager to whitelist specific addresses to control\r\n  * whos allowed to deposit into the fund\r\n  *\r\n  * @param _user       The user address to whitelist\r\n  * @param _allowed    The status of _user, true means allowed to deposit, false means not allowed\r\n  */\r\n  function setWhitelistAddress(address _user, bool _allowed) external onlyOwner {\r\n    whitelist[_user] = _allowed;\r\n  }\r\n\r\n  /**\r\n  * @dev Allows the fund manager to connect to a new [poolPortal\r\n  *\r\n  * @param _newPoolPortal   The address of the new pool portal to use\r\n  */\r\n  function setNewPoolPortal(address _newPoolPortal) public onlyOwner {\r\n    // Require that the new pool portal is permitted by permittedPools\r\n    require(permittedPools.permittedAddresses(_newPoolPortal));\r\n\r\n    poolPortal = PoolPortalInterface(_newPoolPortal);\r\n  }\r\n\r\n  /**\r\n  * @dev Allows the fund manager to connect to a new exchange portal\r\n  *\r\n  * @param _newExchangePortalAddress    The address of the new exchange portal to use\r\n  */\r\n  function setNewExchangePortal(address _newExchangePortalAddress) public onlyOwner {\r\n    // Require that the new exchange portal is permitted by permittedExchanges\r\n    require(permittedExchanges.permittedAddresses(_newExchangePortalAddress));\r\n\r\n    exchangePortal = ExchangePortalInterface(_newExchangePortalAddress);\r\n  }\r\n\r\n  /**\r\n  * @dev This method is present in the alpha testing phase in case for some reason there are funds\r\n  * left in the SmartFund after all shares were withdrawn\r\n  *\r\n  * @param _token    The address of the token to withdraw\r\n  */\r\n  function emergencyWithdraw(address _token) external onlyOwner {\r\n    require(totalShares == 0);\r\n    if (_token == address(ETH_TOKEN_ADDRESS)) {\r\n      msg.sender.transfer(address(this).balance);\r\n    } else {\r\n      ERC20(_token).transfer(msg.sender, ERC20(_token).balanceOf(address(this)));\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Approve 0 for a certain address\r\n  *\r\n  * NOTE: Some ERC20 has no standard approve logic, and not allow do new approve\r\n  * if alredy approved.\r\n  *\r\n  * @param _token                   address of ERC20\r\n  * @param _spender                 address of spender\r\n  */\r\n  function resetApprove(address _token, address _spender) external onlyOwner {\r\n    ERC20(_token).approve(_spender, 0);\r\n  }\r\n\r\n  // Fallback payable function in order to be able to receive ether from other contracts\r\n  function() public payable {}\r\n\r\n  /**\r\n    **************************** ERC20 Compliance ****************************\r\n  **/\r\n\r\n  // Note that addressesNetDeposit does not get updated when transferring shares, since\r\n  // this is used for updating off-chain data it doesn't affect the smart contract logic,\r\n  // but is an issue that currently exists\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  uint8 public decimals = 18;\r\n\r\n  string public symbol = \"FND\";\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n  /**\r\n  * @dev Total number of shares in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalShares;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  *\r\n  * @param _who    The address to query the the balance of.\r\n  *\r\n  * @return A uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _who) public view returns (uint256) {\r\n    return addressToShares[_who];\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer shares for a specified address\r\n  *\r\n  * @param _to       The address to transfer to.\r\n  * @param _value    The amount to be transferred.\r\n  *\r\n  * @return true upon success\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= addressToShares[msg.sender]);\r\n\r\n    addressToShares[msg.sender] = addressToShares[msg.sender].sub(_value);\r\n    addressToShares[_to] = addressToShares[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer shares from one address to another\r\n   *\r\n   * @param _from     The address which you want to send tokens from\r\n   * @param _to       The address which you want to transfer to\r\n   * @param _value    The amount of shares to be transferred\r\n   *\r\n   * @return true upon success\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= addressToShares[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    addressToShares[_from] = addressToShares[_from].sub(_value);\r\n    addressToShares[_to] = addressToShares[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of shares on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * @param _spender    The address which will spend the funds.\r\n   * @param _value      The amount of shares to be spent.\r\n   *\r\n   * @return true upon success\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of shares that an owner allowed to a spender.\r\n   *\r\n   * @param _owner      The address which owns the funds.\r\n   * @param _spender    The address which will spend the funds.\r\n   *\r\n   * @return A uint256 specifying the amount of shares still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n}\r\n\r\n\r\ncontract SmartFundAdvanced is SmartFundCore {\r\n  using SafeMath for uint256;\r\n\r\n  CEther public cEther;\r\n  mapping(address => bool) public isCTOKEN;\r\n  address[] public compoundTokenAddresses;\r\n\r\n\r\n  /**\r\n  * @dev constructor\r\n  * @param _owner                        Owner of new smart fund\r\n  * @param _name                         Name of new smart fund\r\n  * @param _successFee                   Initial success fee\r\n  * @param _platformFee                  Initial platform fee\r\n  * @param _platformAddress              Address of smart fund registry\r\n  * @param _exchangePortalAddress        Address of the initial ExchangePortal contract\r\n  * @param _permittedExchangesAddress    Address of the permittedExchanges contract\r\n  * @param _poolPortalAddress            Address of the initial PoolPortal contract\r\n  * @param _permittedPoolsAddress        Address of the permittedPool contract\r\n  * @param _cEther                       Address of the cEther\r\n  */\r\n  constructor(\r\n    address _owner,\r\n    string  _name,\r\n    uint256 _successFee,\r\n    uint256 _platformFee,\r\n    address _platformAddress,\r\n    address _exchangePortalAddress,\r\n    address _permittedExchangesAddress,\r\n    address _permittedPoolsAddress,\r\n    address _poolPortalAddress,\r\n    address _cEther\r\n  )\r\n  SmartFundCore(\r\n    _owner,\r\n    _name,\r\n    _successFee,\r\n    _platformFee,\r\n    _platformAddress,\r\n    _exchangePortalAddress,\r\n    _permittedExchangesAddress,\r\n    _permittedPoolsAddress,\r\n    _poolPortalAddress\r\n  )\r\n  public\r\n  {\r\n    cEther = CEther(_cEther);\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev buy Compound cTokens\r\n  *\r\n  * @param _amount       amount of ERC20 or ETH\r\n  * @param _cToken       cToken address\r\n  */\r\n  function compoundMint(uint256 _amount, address _cToken) external onlyOwner{\r\n    if(_cToken == address(cEther)){\r\n      // mint cETH\r\n      cEther.mint.value(_amount)();\r\n      // Add token to ERC list\r\n      _addToken(address(cEther));\r\n      // Add to c token list\r\n      _addCompoundToken(address(cEther));\r\n    }else{\r\n      CToken cToken = CToken(_cToken);\r\n      address underlyingAddress = cToken.underlying();\r\n      ERC20(underlyingAddress).approve(address(_cToken), _amount);\r\n      // mint cERC\r\n      cToken.mint(_amount);\r\n      // Add cToken\r\n      _addToken(_cToken);\r\n      // Add to c token list\r\n      _addCompoundToken(_cToken);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev sell certain percent of Ctokens to Compound\r\n  *\r\n  * @param _percent      percent from 1 to 100\r\n  * @param _cToken       cToken address\r\n  */\r\n  function compoundRedeemByPercent(uint _percent, address _cToken) external onlyOwner {\r\n    uint256 amount = (_percent == 100)\r\n    // if 100 return all\r\n    ? ERC20(address(_cToken)).balanceOf(address(this))\r\n    // else calculate percent\r\n    : getPercentFromCTokenBalance(_percent, address(_cToken));\r\n\r\n    if(_cToken == address(cEther)){\r\n      cEther.redeem(amount);\r\n    }else{\r\n      CToken cToken = CToken(_cToken);\r\n      cToken.redeem(amount);\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev return percent of compound cToken balance\r\n  *\r\n  * @param _percent       amount of ERC20 or ETH\r\n  * @param _cToken       cToken address\r\n  */\r\n  function getPercentFromCTokenBalance(uint _percent, address _cToken)\r\n  public\r\n  view\r\n  returns(uint256)\r\n  {\r\n    if(_percent > 0 && _percent <= 100){\r\n      uint256 currectBalance = ERC20(_cToken).balanceOf(address(this));\r\n      return currectBalance.div(100).mul(_percent);\r\n    }\r\n    else{\r\n      // not correct percent\r\n      revert();\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev sell Compound cToken by cToken amount\r\n  *\r\n  * @param _amount       amount of ERC20 or ETH\r\n  * @param _cToken       cToken address\r\n  */\r\n  function compoundRedeem(uint256 _amount, address _cToken) external onlyOwner {\r\n    if(_cToken == address(cEther)){\r\n      cEther.redeem(_amount);\r\n    }else{\r\n      CToken cToken = CToken(_cToken);\r\n      cToken.redeem(_amount);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev sell Compound cToken by underlying (ERC20 or ETH) amount\r\n  *\r\n  * @param _amount       amount of ERC20 or ETH\r\n  * @param _cToken       cToken address\r\n  */\r\n  function compoundRedeemUnderlying(uint256 _amount, address _cToken) external onlyOwner {\r\n    if(_cToken == address(cEther)){\r\n      cEther.redeemUnderlying(_amount);\r\n    }else{\r\n      CToken cToken = CToken(_cToken);\r\n      cToken.redeemUnderlying(_amount);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev get value for cToken in base asset (ERC20 or ETH) ratio for this smart fund address\r\n  *\r\n  * @param _cToken       cToken address\r\n  */\r\n  function compoundGetCTokenValue(\r\n    address _cToken\r\n  )\r\n    public\r\n    view\r\n    returns(uint256 result)\r\n  {\r\n    result = CToken(_cToken).balanceOfUnderlying(address(this));\r\n  }\r\n\r\n  /**\r\n  * @dev get value for all cTokens for this smart fund address in ETH ratio\r\n  *\r\n  */\r\n  function compoundGetAllFundCtokensinETH()\r\n    public\r\n    view\r\n    returns(uint256)\r\n  {\r\n    if(compoundTokenAddresses.length > 0){\r\n      uint256 balance = 0;\r\n      for (uint256 i = 0; i < compoundTokenAddresses.length; i++) {\r\n        balance = balance.add(compoundGetCTokenValue(compoundTokenAddresses[i]));\r\n      }\r\n      return balance;\r\n    }\r\n    else{\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  function _addCompoundToken(address _cToken) private {\r\n    if(!isCTOKEN[_cToken]){\r\n      // Mark this tokens as Ctoken\r\n      isCTOKEN[_cToken] = true;\r\n      // Add compound token\r\n      compoundTokenAddresses.push(_cToken);\r\n    }\r\n  }\r\n\r\n  // return length of all trade available Compound tokens in fund\r\n  function compoundCTokensLength() public view returns(uint){\r\n    uint8 count;\r\n    for (uint8 i = 1; i < tokenAddresses.length; i++) {\r\n      if(isCTOKEN[tokenAddresses[i]])\r\n        count++;\r\n    }\r\n\r\n    return count;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\ncontract SmartFundETHInterface is SmartFundInterface{\r\n  // deposit `amount` of tokens.\r\n  // returns number of shares the user receives\r\n  function deposit() external payable returns (uint256);\r\n}\r\n\r\n\r\n/*\r\n  Note: this smart fund inherits SmartFundAdvanced and make core operations like deposit,\r\n  calculate fund value etc in ETH\r\n*/\r\ncontract SmartFundETH is SmartFundETHInterface, SmartFundAdvanced {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for ERC20;\r\n\r\n  /**\r\n  * @dev constructor\r\n  *\r\n  * @param _owner                        Address of the fund manager\r\n  * @param _name                         Name of the fund, required for DetailedERC20 compliance\r\n  * @param _successFee                   Percentage of profit that the fund manager receives\r\n  * @param _platformFee                  Percentage of the success fee that goes to the platform\r\n  * @param _platformAddress              Address of platform to send fees to\r\n  * @param _exchangePortalAddress        Address of initial exchange portal\r\n  * @param _permittedExchangesAddress    Address of PermittedExchanges contract\r\n  * @param _permittedPoolsAddress        Address of PermittedPools contract\r\n  * @param _poolPortalAddress            Address of initial pool portal\r\n  * @param _cEther                       Address of the cEther\r\n  */\r\n  constructor(\r\n    address _owner,\r\n    string _name,\r\n    uint256 _successFee,\r\n    uint256 _platformFee,\r\n    address _platformAddress,\r\n    address _exchangePortalAddress,\r\n    address _permittedExchangesAddress,\r\n    address _permittedPoolsAddress,\r\n    address _poolPortalAddress,\r\n    address _cEther\r\n  )\r\n  SmartFundAdvanced(\r\n    _owner,\r\n    _name,\r\n    _successFee,\r\n    _platformFee,\r\n    _platformAddress,\r\n    _exchangePortalAddress,\r\n    _permittedExchangesAddress,\r\n    _permittedPoolsAddress,\r\n    _poolPortalAddress,\r\n    _cEther\r\n  )\r\n  public{}\r\n\r\n  /**\r\n  * @dev Deposits ether into the fund and allocates a number of shares to the sender\r\n  * depending on the current number of shares, the funds value, and amount deposited\r\n  *\r\n  * @return The amount of shares allocated to the depositor\r\n  */\r\n  function deposit() external payable returns (uint256) {\r\n    // Check if the sender is allowed to deposit into the fund\r\n    if (onlyWhitelist)\r\n      require(whitelist[msg.sender]);\r\n\r\n    // Require that the amount sent is not 0\r\n    require(msg.value != 0);\r\n\r\n    totalWeiDeposited += msg.value;\r\n\r\n    // Calculate number of shares\r\n    uint256 shares = calculateDepositToShares(msg.value);\r\n\r\n    // If user would receive 0 shares, don't continue with deposit\r\n    require(shares != 0);\r\n\r\n    // Add shares to total\r\n    totalShares = totalShares.add(shares);\r\n\r\n    // Add shares to address\r\n    addressToShares[msg.sender] = addressToShares[msg.sender].add(shares);\r\n\r\n    addressesNetDeposit[msg.sender] += int256(msg.value);\r\n\r\n    emit Deposit(msg.sender, msg.value, shares, totalShares);\r\n\r\n    return shares;\r\n  }\r\n\r\n  /**\r\n  * @dev Calculates the funds value in deposit token (Ether)\r\n  *\r\n  * @return The current total fund value\r\n  */\r\n  function calculateFundValue() public view returns (uint256) {\r\n    uint256 ethBalance = address(this).balance;\r\n\r\n    // If the fund only contains ether, return the funds ether balance\r\n    if (tokenAddresses.length == 1)\r\n      return ethBalance;\r\n\r\n    // Otherwise, we get the value of all the other tokens in ether via exchangePortal\r\n\r\n    // Calculate value for ERC20\r\n    // Sub cTokens + ETH\r\n    uint cTokensAndETHlength = compoundCTokensLength() + 1;\r\n    address[] memory fromAddresses = new address[](tokenAddresses.length - cTokensAndETHlength);\r\n    uint256[] memory amounts = new uint256[](tokenAddresses.length - cTokensAndETHlength);\r\n    uint8 ercIndex = 0;\r\n\r\n    for (uint256 i = 1; i < tokenAddresses.length; i++) {\r\n      // No need for cToken\r\n      if(!isCTOKEN[tokenAddresses[i]]){\r\n        fromAddresses[ercIndex] = tokenAddresses[i];\r\n        amounts[ercIndex] = ERC20(tokenAddresses[i]).balanceOf(address(this));\r\n        ercIndex++;\r\n      }\r\n    }\r\n    // Ask the Exchange Portal for the value of all the funds tokens in eth\r\n    uint256 tokensValue = exchangePortal.getTotalValue(fromAddresses, amounts, ETH_TOKEN_ADDRESS);\r\n\r\n    // get compound c tokens in ETH\r\n    uint256 compoundCTokensValueInETH = compoundGetAllFundCtokensinETH();\r\n\r\n    // Sum ETH + ERC20 + cTokens\r\n    return ethBalance + tokensValue + compoundCTokensValueInETH;\r\n  }\r\n\r\n  /**\r\n  * @dev get balance of input asset address in ETH ratio\r\n  *\r\n  * @param _token     token address\r\n  *\r\n  * @return balance in ETH\r\n  */\r\n  function getTokenValue(ERC20 _token) public view returns (uint256) {\r\n    // return ETH\r\n    if (_token == ETH_TOKEN_ADDRESS){\r\n      return address(this).balance;\r\n    }\r\n    // return CToken in ETH\r\n    else if(isCTOKEN[_token]){\r\n      return compoundGetCTokenValue(_token);\r\n    }\r\n    // return ERC20 in ETH\r\n    else{\r\n      uint256 tokenBalance = _token.balanceOf(address(this));\r\n      return exchangePortal.getValue(_token, ETH_TOKEN_ADDRESS, tokenBalance);\r\n    }\r\n  }\r\n}\r\n\r\n\r\ncontract SmartFundETHFactory {\r\n  function createSmartFund(\r\n    address _owner,\r\n    string  _name,\r\n    uint256 _successFee,\r\n    uint256 _platformFee,\r\n    address _platfromAddress,\r\n    address _exchangePortalAddress,\r\n    address _permittedExchanges,\r\n    address _permittedPools,\r\n    address _poolPortalAddress,\r\n    address _cEther\r\n    )\r\n  public\r\n  returns(address)\r\n  {\r\n    SmartFundETH smartFundETH = new SmartFundETH(\r\n      _owner,\r\n      _name,\r\n      _successFee,\r\n      _platformFee,\r\n      _platfromAddress,\r\n      _exchangePortalAddress,\r\n      _permittedExchanges,\r\n      _permittedPools,\r\n      _poolPortalAddress,\r\n      _cEther\r\n    );\r\n\r\n    return address(smartFundETH);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_successFee\",\"type\":\"uint256\"},{\"name\":\"_platformFee\",\"type\":\"uint256\"},{\"name\":\"_platfromAddress\",\"type\":\"address\"},{\"name\":\"_exchangePortalAddress\",\"type\":\"address\"},{\"name\":\"_permittedExchanges\",\"type\":\"address\"},{\"name\":\"_permittedPools\",\"type\":\"address\"},{\"name\":\"_poolPortalAddress\",\"type\":\"address\"},{\"name\":\"_cEther\",\"type\":\"address\"}],\"name\":\"createSmartFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SmartFundETHFactory","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://3366b8c9c600d79b5ad3f822cbb733a8e48d444a2dc7298008c239b6f7d9a3f2"}]}