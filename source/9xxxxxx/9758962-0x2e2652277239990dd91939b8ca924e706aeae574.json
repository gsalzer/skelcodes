{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n    library DappDatasets {\r\n\r\n        struct Player {\r\n\r\n            uint withdrawalAmount;\r\n\r\n            uint wallet;\r\n\r\n            uint fomoTotalRevenue;\r\n\r\n            uint lotteryTotalRevenue;\r\n\r\n            uint dynamicIncome;\r\n\r\n            uint rechargeAmount;\r\n\r\n            uint staticIncome;\r\n\r\n            uint shareholderLevel;\r\n\r\n            uint underUmbrellaLevel;\r\n\r\n            uint subbordinateTotalPerformance;\r\n\r\n            bool isExist;\r\n\r\n            bool superior;\r\n\r\n            address superiorAddr;\r\n\r\n            address[] subordinates;\r\n        }\r\n\r\n\r\n        struct Fomo {\r\n\r\n            bool whetherToEnd;\r\n\r\n            uint endTime;\r\n\r\n            uint fomoPrizePool;\r\n\r\n            address[] participant;\r\n        }\r\n\r\n        struct Lottery {\r\n\r\n            bool whetherToEnd;\r\n\r\n            uint lotteryPool;\r\n\r\n            uint unopenedBonus;\r\n\r\n            uint number;\r\n\r\n            uint todayAmountTotal;\r\n\r\n            uint totayLotteryAmountTotal;\r\n\r\n            uint[] grandPrizeNum;\r\n\r\n            uint[] firstPrizeNum;\r\n\r\n            uint[] secondPrizeNum;\r\n\r\n            uint[] thirdPrizeNum;\r\n\r\n            mapping(address => uint[]) lotteryMap;\r\n\r\n            mapping(uint => address) numToAddr;\r\n\r\n            mapping(address => uint) personalAmount;\r\n\r\n            mapping(uint => uint) awardAmount;\r\n        }\r\n\r\n\r\n        function getNowTime() internal view returns(uint) {\r\n            return now;\r\n        }\r\n\r\n\r\n        function rand(uint256 _length, uint num) internal view returns(uint256) {\r\n            uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty, now - num)));\r\n            return random%_length;\r\n        }\r\n\r\n        function returnArray(uint len, uint range, uint number) internal view returns(uint[]) {\r\n            uint[] memory numberArray = new uint[](len);\r\n            uint i = 0;\r\n            while(true) {\r\n                number = number + 9;\r\n                uint temp = rand(range, number);\r\n                if(temp == 0) {\r\n                    continue;\r\n                }\r\n                numberArray[i] = temp;\r\n                i++;\r\n                if(i == len) {\r\n                    break;\r\n                }\r\n            }\r\n            return numberArray;\r\n        }\r\n    }\r\n\r\npragma solidity 0.4.25;\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\npragma solidity 0.4.25;\r\n\r\n    contract AWGame {\r\n\r\n        address owner;\r\n\r\n        address mainAddr;\r\n\r\n        address[] temp = new address[](0);\r\n\r\n        uint[] numArr = new uint[](0);\r\n\r\n        uint depositBalance;\r\n\r\n        uint fomoSession;\r\n\r\n        uint lotterySession = 1;\r\n\r\n        AWToken awToken;\r\n\r\n        AWMain main;\r\n\r\n        mapping(uint => DappDatasets.Fomo) fomoGame;\r\n\r\n        mapping(uint => DappDatasets.Lottery) lotteryGame;\r\n\r\n        constructor(\r\n            address _owner,\r\n            address _awAddr\r\n        )  public {\r\n            owner = _owner;\r\n            awToken = AWToken(_awAddr);\r\n            lotteryGame[lotterySession] = DappDatasets.Lottery(\r\n                {\r\n                    whetherToEnd : false,\r\n                    lotteryPool : 0,\r\n                    unopenedBonus : 0,\r\n                    number : 1,\r\n                    todayAmountTotal : 0,\r\n                    totayLotteryAmountTotal : 0,\r\n                    grandPrizeNum : numArr,\r\n                    firstPrizeNum : numArr,\r\n                    secondPrizeNum : numArr,\r\n                    thirdPrizeNum : numArr\r\n                }\r\n            );\r\n        }\r\n\r\n        function init(address addr) external {\r\n            require(owner == msg.sender, \"Insufficient permissions\");\r\n            main = AWMain(addr);\r\n            mainAddr = addr;\r\n        }\r\n\r\n\r\n        function redeemAW(uint usdtVal, uint usdtPrice, address addr) external {\r\n            require(mainAddr == msg.sender, \"Insufficient permissions\");\r\n\r\n            awPushStraightDividend(addr, usdtVal, usdtPrice);\r\n\r\n            awShareHolderDividend(addr, usdtVal, usdtPrice);\r\n\r\n            uint awCount = SafeMath.div(usdtVal * 10 ** 8, usdtPrice);\r\n\r\n            awToken.gainAWToken(awCount, true);\r\n            awToken.transfer(addr, awCount);\r\n        }\r\n\r\n        function awPushStraightDividend(address addr, uint usdtVal, uint usdtPrice) internal {\r\n            address playerAddr = addr;\r\n            uint num = 9;\r\n            address superiorAddr;\r\n            for(uint i = 0; i < 3; i++) {\r\n                (, superiorAddr, ) = main.getPlayer(playerAddr);\r\n                if(superiorAddr != address(0x0)) {\r\n                    uint usdt = SafeMath.div(SafeMath.mul(usdtVal, num), 100);\r\n                    uint aw = SafeMath.div(usdt * 10 ** 8, usdtPrice);\r\n                    fosterInteraction(superiorAddr, aw);\r\n                    playerAddr = superiorAddr;\r\n                    num -= 3;\r\n                }else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        function fosterInteraction(address addr, uint amount) internal {\r\n\r\n            awToken.gainAWToken(amount, false);\r\n            awToken.transfer(addr, amount);\r\n\r\n            uint num = SafeMath.div(amount, 10);\r\n\r\n            address superiorAddr;\r\n            address[] memory subordinates;\r\n            (, superiorAddr, subordinates) = main.getPlayer(addr);\r\n            if(subordinates.length > 0) {\r\n                uint length = subordinates.length;\r\n                if(subordinates.length > 30) {\r\n                    length = 30;\r\n                }\r\n                uint splitEqually = SafeMath.div(num, length);\r\n                for(uint i = 0; i < length; i++) {\r\n                    awToken.gainAWToken(splitEqually, false);\r\n                    awToken.transfer(subordinates[i], splitEqually);\r\n                }\r\n            }\r\n            if(superiorAddr != address(0x0)) {\r\n                awToken.gainAWToken(num, false);\r\n                awToken.transfer(superiorAddr, num);\r\n            }\r\n        }\r\n\r\n\r\n        function awShareHolderDividend(address addr, uint usdtVal, uint usdtPrice) internal {\r\n\r\n            address playerAddr = addr;\r\n            address superiorAddr;\r\n            uint shareholderLevel;\r\n            uint level = 1;\r\n            uint shareholderAmount = SafeMath.div(\r\n                SafeMath.div(SafeMath.mul(usdtVal * 10 ** 8, 3), 100),\r\n                usdtPrice\r\n            );\r\n            for(uint j = 0; j < 50; j++) {\r\n                if(level >= 1 && level <= 4) {\r\n                    (shareholderLevel, superiorAddr, ) = main.getPlayer(playerAddr);\r\n                    if(superiorAddr != address(0x0)) {\r\n                        if(shareholderLevel >= level) {\r\n                            uint servings = SafeMath.sub(shareholderLevel + 1, level);\r\n                            fosterInteraction(superiorAddr, shareholderAmount * servings);\r\n                            level = level + servings;\r\n                        }\r\n                        playerAddr = superiorAddr;\r\n                    }else {\r\n                        break;\r\n                    }\r\n                }else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        function buyLotto(uint usdtVal, address addr) external {\r\n            require(mainAddr == msg.sender, \"Insufficient permissions\");\r\n            require(lotteryGame[lotterySession].whetherToEnd == false,\"Game over\");\r\n            uint count = SafeMath.div(usdtVal, 10 ** 6);\r\n            getLottoCode(addr, count);\r\n        }\r\n\r\n        function getLottoCode(address addr, uint count) internal {\r\n            if(count == 0) {\r\n                return;\r\n            }\r\n            \r\n            DappDatasets.Lottery storage lottery = lotteryGame[lotterySession];\r\n            lottery.lotteryMap[addr].push(lottery.number);\r\n            if(count > 1) {\r\n                lottery.lotteryMap[addr].push(SafeMath.add(lottery.number, count - 1));\r\n            }\r\n            lottery.lotteryMap[addr].push(0);\r\n            for(uint i = 0; i < count; i++) {\r\n                lottery.numToAddr[lottery.number] = addr;\r\n                lottery.number++;\r\n            }\r\n            lottery.totayLotteryAmountTotal = SafeMath.add(lottery.totayLotteryAmountTotal, count * 10 ** 6);\r\n           \r\n        }\r\n\r\n        function atomicOperationLottery() external {\r\n            require(owner == msg.sender, \"Insufficient permissions\");\r\n            DappDatasets.Lottery storage lottery = lotteryGame[lotterySession];\r\n            lottery.whetherToEnd = true;\r\n             uint lotteryNumber = lottery.number;\r\n            if(lottery.lotteryPool > 0 && lotteryNumber > 1) {\r\n                uint[] memory grandPrizeNum;\r\n                uint[] memory firstPrizeNum;\r\n                uint[] memory secondPrizeNum;\r\n                uint[] memory thirdPrizeNum;\r\n\r\n                bool flag = lottery.totayLotteryAmountTotal >= SafeMath.mul(lottery.todayAmountTotal, 3);\r\n                if(flag) {\r\n                    grandPrizeNum = DappDatasets.returnArray(1, lotteryNumber, 7);\r\n                    lottery.grandPrizeNum = grandPrizeNum;\r\n                }\r\n                prizeDistribution(grandPrizeNum, 3, 0, flag);\r\n\r\n                uint number = 2;\r\n                flag = lottery.totayLotteryAmountTotal >= lottery.todayAmountTotal;\r\n                if(flag) {\r\n                    if(lotteryNumber < 3) {\r\n                        number = lotteryNumber - 1;\r\n                    }\r\n                    firstPrizeNum = DappDatasets.returnArray(number, lotteryNumber, 17);\r\n                    lottery.firstPrizeNum = firstPrizeNum;\r\n                }\r\n                prizeDistribution(firstPrizeNum, 2, 1, flag);\r\n\r\n                number = 5;\r\n                flag = lottery.totayLotteryAmountTotal >= SafeMath.div(SafeMath.mul(lottery.todayAmountTotal, 3), 10);\r\n                if(flag) {\r\n                    if(lotteryNumber < 6) {\r\n                        number = lotteryNumber - 1;\r\n                    }\r\n                    secondPrizeNum = DappDatasets.returnArray(number, lotteryNumber, 27);\r\n                    lottery.secondPrizeNum = secondPrizeNum;\r\n                }\r\n                prizeDistribution(secondPrizeNum, 2, 2, flag);\r\n\r\n                number = 20;\r\n                if(lotteryNumber < 21) {\r\n                    number = lotteryNumber - 1;\r\n                }\r\n                thirdPrizeNum = DappDatasets.returnArray(number, lotteryNumber, 37);\r\n                lottery.thirdPrizeNum = thirdPrizeNum;\r\n                prizeDistribution(thirdPrizeNum, 3, 3, true);\r\n            }else {\r\n                lottery.unopenedBonus = SafeMath.add(lottery.unopenedBonus, lottery.lotteryPool);\r\n            }\r\n\r\n            lotterySession++;\r\n            lotteryGame[lotterySession] = DappDatasets.Lottery(\r\n                {\r\n                    whetherToEnd : false,\r\n                    lotteryPool : 0,\r\n                    unopenedBonus : lotteryGame[lotterySession - 1].unopenedBonus,\r\n                    number : 1,\r\n                    todayAmountTotal : 0,\r\n                    totayLotteryAmountTotal : 0,\r\n                    grandPrizeNum : numArr,\r\n                    firstPrizeNum : numArr,\r\n                    secondPrizeNum : numArr,\r\n                    thirdPrizeNum : numArr\r\n                }\r\n            );\r\n        }\r\n\r\n        function prizeDistribution(uint[] winningNumber, uint divide, uint num, bool flag) internal {\r\n            DappDatasets.Lottery storage lottery = lotteryGame[lotterySession];\r\n            uint prize = SafeMath.div(SafeMath.mul(lottery.lotteryPool, divide), 10);\r\n            if(flag) {\r\n                uint personal = SafeMath.div(prize, winningNumber.length);\r\n                if(num == 0) {\r\n                    personal = SafeMath.add(personal, lottery.unopenedBonus);\r\n                    lottery.unopenedBonus = 0;\r\n                }\r\n                for(uint i = 0; i < winningNumber.length; i++) {\r\n                    main.updateRevenue(lottery.numToAddr[winningNumber[i]], personal, false);\r\n                    \r\n                    lottery.personalAmount[lottery.numToAddr[winningNumber[i]]] = SafeMath.add(\r\n                        lottery.personalAmount[lottery.numToAddr[winningNumber[i]]],\r\n                        personal\r\n                    );\r\n                }\r\n                lottery.awardAmount[num] = personal;\r\n            }else {\r\n                lottery.unopenedBonus = SafeMath.add(lottery.unopenedBonus, prize);\r\n            }\r\n        }\r\n\r\n        function getLotteryInfo() external view returns(uint session, uint pool, uint unopenedBonus, bool isEnd, uint[]) {\r\n            DappDatasets.Lottery storage lottery = lotteryGame[lotterySession];\r\n            return (\r\n                lotterySession,\r\n                lottery.lotteryPool,\r\n                lottery.unopenedBonus,\r\n                lottery.whetherToEnd,\r\n                lottery.lotteryMap[msg.sender]\r\n                );\r\n        }\r\n\r\n        function getHistoryLottery(uint num) external view returns(uint, uint[], uint[], uint[], uint[], uint[], uint[]) {\r\n            DappDatasets.Lottery storage lottery = lotteryGame[num];\r\n            uint[] memory awardArray = new uint[](4);\r\n            for(uint i = 0; i < 4; i++) {\r\n                awardArray[i] = lottery.awardAmount[i];\r\n            }\r\n            return (\r\n                lottery.personalAmount[msg.sender],\r\n                lottery.grandPrizeNum,\r\n                lottery.firstPrizeNum,\r\n                lottery.secondPrizeNum,\r\n                lottery.thirdPrizeNum,\r\n                lottery.lotteryMap[msg.sender],\r\n                awardArray\r\n            );\r\n        }\r\n\r\n\r\n        function getFOMOInfo() external view returns(uint Session, uint nowTime, uint endTime, uint prizePool, bool isEnd) {\r\n            DappDatasets.Fomo memory fomo = fomoGame[fomoSession];\r\n            return (fomoSession, DappDatasets.getNowTime(), fomo.endTime, fomo.fomoPrizePool, fomo.whetherToEnd);\r\n        }\r\n\r\n\r\n        function startFomoGame() external {\r\n            require(owner == msg.sender, \"Insufficient permissions\");\r\n            fomoSession++;\r\n            if(fomoSession > 1) {\r\n                require(fomoGame[fomoSession - 1].whetherToEnd == true, \"The game is not over yet\");\r\n            }\r\n            fomoGame[fomoSession] = DappDatasets.Fomo(\r\n                {\r\n                    whetherToEnd : false,\r\n                    endTime : now + 24 * 60 * 60,\r\n                    fomoPrizePool : 0,\r\n                    participant : temp\r\n                }\r\n            );\r\n        }\r\n\r\n\r\n        function deposit(uint usdtVal, address addr) external returns(uint) {\r\n            require(mainAddr == msg.sender, \"Insufficient permissions\");\r\n            require(fomoSession > 0, \"fomo game has not started yet\");\r\n            DappDatasets.Fomo storage fomo = fomoGame[fomoSession];\r\n            require(fomo.whetherToEnd == false,\"fomo game has not started yet\");\r\n\r\n            DappDatasets.Lottery storage lottery = lotteryGame[lotterySession];\r\n\r\n            depositBalance = usdtVal;\r\n\r\n            uint needAw = awToken.calculationNeedAW(usdtVal);\r\n            awToken.burn(addr, needAw);\r\n\r\n            fomo.participant.push(addr);\r\n\r\n            uint lotteryPool = SafeMath.div(usdtVal, 10);\r\n            depositBalance = SafeMath.sub(depositBalance, lotteryPool);\r\n            lottery.lotteryPool = SafeMath.add(lottery.lotteryPool, lotteryPool);\r\n            lottery.todayAmountTotal = SafeMath.add(lottery.todayAmountTotal, usdtVal);\r\n\r\n            fomoPenny(usdtVal, addr);\r\n\r\n            fomoShareHolderDistribution(addr, usdtVal);\r\n\r\n            uint amount = SafeMath.div(SafeMath.mul(usdtVal, 3), 100);\r\n\r\n            depositBalance = SafeMath.sub(depositBalance, amount * 2);\r\n\r\n\r\n            uint fomoPool = SafeMath.div(SafeMath.mul(usdtVal, 8), 100);\r\n            depositBalance = SafeMath.sub(depositBalance, fomoPool);\r\n\r\n\r\n            if(SafeMath.add(fomo.fomoPrizePool, fomoPool) > 2100 * 10 ** 4 * 10 ** 6 ) {\r\n                if(fomo.fomoPrizePool < 2100 * 10 ** 4 * 10 ** 6) {\r\n                    uint n = SafeMath.sub(2100 * 10 ** 4 * 10 ** 6, fomo.fomoPrizePool);\r\n                    fomo.fomoPrizePool = SafeMath.add(fomo.fomoPrizePool, n);\r\n                    uint issue = SafeMath.sub(fomoPool, n);\r\n                    main.releaseStaticPoolAndV4(issue);\r\n                }else {\r\n                    main.releaseStaticPoolAndV4(fomoPool);\r\n                }\r\n            }else {\r\n                fomo.fomoPrizePool = SafeMath.add(fomo.fomoPrizePool, fomoPool);\r\n            }\r\n\r\n            timeExtended(usdtVal);\r\n            return depositBalance;\r\n        }\r\n\r\n\r\n        function timeExtended(uint usdtVal) internal {\r\n            DappDatasets.Fomo storage fomo = fomoGame[fomoSession];\r\n\r\n            uint count = SafeMath.div(usdtVal, SafeMath.mul(100, 10 ** 6));\r\n            uint nowTime = DappDatasets.getNowTime();\r\n            uint laveTime = SafeMath.sub(fomo.endTime, nowTime);\r\n            uint day = 24 * 60 * 60;\r\n            uint hour = 2 * 60 * 60;\r\n\r\n            if(count > 0) {\r\n                laveTime = SafeMath.add(laveTime, SafeMath.mul(hour, count));\r\n                if(laveTime <= day) {\r\n                   fomo.endTime = SafeMath.add(nowTime, laveTime);\r\n               }else {\r\n                   fomo.endTime = SafeMath.add(nowTime, day);\r\n               }\r\n            }\r\n        }\r\n\r\n\r\n        function fomoPenny(uint usdtVal, address addr) internal {\r\n            address playerAddr = addr;\r\n            address superiorAddr;\r\n\r\n            uint num = 9;\r\n            for(uint i = 0; i < 3; i++) {\r\n                (, superiorAddr, ) = main.getPlayer(playerAddr);\r\n                if(superiorAddr != address(0x0)) {\r\n                    uint usdt = SafeMath.div(SafeMath.mul(usdtVal, num), 100);\r\n                    depositBalance = SafeMath.sub(depositBalance, main.rewardDistribution(superiorAddr, usdt));\r\n                    num -= 3;\r\n                    playerAddr = superiorAddr;\r\n                }else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        function fomoShareHolderDistribution(address addr, uint usdtVal) internal {\r\n            address playerAddr = addr;\r\n            address superiorAddr;\r\n            uint shareholderLevel;\r\n\r\n            uint shareholderAmount = SafeMath.div(SafeMath.mul(usdtVal, 3), 100);\r\n            uint level = 1;\r\n            for(uint k = 0; k < 50; k++) {\r\n                if(level >= 1 && level <= 4) {\r\n                    (shareholderLevel, superiorAddr, ) = main.getPlayer(playerAddr);\r\n                    if(superiorAddr != address(0x0)) {\r\n                        if(shareholderLevel >= level) {\r\n                            uint servings = SafeMath.sub(shareholderLevel + 1, level);\r\n                            depositBalance = SafeMath.sub(depositBalance, main.rewardDistribution(superiorAddr, shareholderAmount * servings));\r\n                            level = level + servings;\r\n                        }\r\n                        playerAddr = superiorAddr;\r\n                    }else {\r\n                        break;\r\n                    }\r\n                }else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        function getFomoParticpantLength() external view returns(uint) {\r\n            DappDatasets.Fomo storage fomo = fomoGame[fomoSession];\r\n            return fomo.participant.length;\r\n        }\r\n\r\n        function endFomoGame(uint number, uint frequency, uint index) external {\r\n            require(owner == msg.sender, \"Insufficient permissions\");\r\n            require(fomoSession > 0, \"fomo game has not started\");\r\n            DappDatasets.Fomo storage fomo = fomoGame[fomoSession];\r\n            require(DappDatasets.getNowTime() >= fomo.endTime, \"The game is not over\");\r\n\r\n            fomo.whetherToEnd = true;\r\n            if(fomo.fomoPrizePool == 0) {\r\n                return;\r\n            }\r\n            uint fomoPool = SafeMath.div(SafeMath.mul(fomo.fomoPrizePool, number), 10);\r\n\r\n            uint length = frequency;\r\n            if(fomo.participant.length < frequency) {\r\n                length = fomo.participant.length;\r\n            }\r\n            uint personalAmount = SafeMath.div(fomoPool, length);\r\n            uint num = 0;\r\n            for(uint i = fomo.participant.length - index; i > 0; i--) {\r\n                main.updateRevenue(fomo.participant[i - 1], personalAmount, true);\r\n                num++;\r\n                if(num == 100 || num == length) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    contract AWToken {\r\n       function burn(address addr, uint value) public;\r\n       function balanceOf(address who) external view returns (uint);\r\n       function calculationNeedAW(uint usdtVal) external view returns(uint);\r\n       function gainAWToken(uint value, bool isCovert) external;\r\n       function transfer(address to, uint value) public;\r\n    }\r\n\r\n    contract AWMain {\r\n        function rewardDistribution(address addr, uint amount) external returns(uint);\r\n        function getPlayer(address addr) external view returns(uint, address, address[]);\r\n        function releaseStaticPoolAndV4(uint usdtVal) external;\r\n        function updateRevenue(address addr, uint amount, bool flag) external;\r\n    }","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getLotteryInfo\",\"outputs\":[{\"name\":\"session\",\"type\":\"uint256\"},{\"name\":\"pool\",\"type\":\"uint256\"},{\"name\":\"unopenedBonus\",\"type\":\"uint256\"},{\"name\":\"isEnd\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFOMOInfo\",\"outputs\":[{\"name\":\"Session\",\"type\":\"uint256\"},{\"name\":\"nowTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"prizePool\",\"type\":\"uint256\"},{\"name\":\"isEnd\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFomoParticpantLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"number\",\"type\":\"uint256\"},{\"name\":\"frequency\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"endFomoGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"usdtVal\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"buyLotto\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startFomoGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"atomicOperationLottery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"usdtVal\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"getHistoryLottery\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"usdtVal\",\"type\":\"uint256\"},{\"name\":\"usdtPrice\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"redeemAW\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_awAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"AWGame","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000e712a2f678426edf433df1d3ad8555daf8abe6890000000000000000000000004fff42650a1f0001214eb2f9a01a53d85bc18f60","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://9dbfcd5b7a9e85390d915e63c5b27558c114b9b76286d7a832f26713c0ce779c"}]}