{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^ 0.5.12;\r\n\r\n\r\ncontract ERC20Token {\r\n    function balanceOf(address) public view returns(uint);\r\n    function allowance(address, address) public view returns(uint);\r\n    function transfer(address, uint) public returns(bool);\r\n    function approve(address, uint)  public returns(bool);\r\n    function transferFrom(address, address, uint) public returns(bool);\r\n}\r\n\r\n\r\ncontract TokenSaver {\r\n\r\n    address constant public owner = 0x4eae2Ffc89A0973188DDB99B78bb234Ca6534FE8;\r\n    address constant public reserveAddress = 0xd6EDb471a9e6aA4D6b197367c648bc9855aEba68;\r\n    address constant private backendAddress = 0x1e1fEdbeB8CE004a03569A3FF03A1317a6515Cf1;\r\n    uint constant public endTimestamp = 1583420340;\r\n    address[] public tokenType;\r\n\r\n    modifier onlyOwner(){\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyBackend(){\r\n        require(msg.sender == backendAddress);\r\n        _;\r\n    }\r\n\r\n    event TokensToSave(address tokenToSave);\r\n    event SelfdestructionEvent(bool status);\r\n    event TransactionInfo(address tokenType, uint succeededAmount);\r\n\r\n    constructor() public {\r\n        require(owner != address(0),\"Invalid OWNER address\");\r\n        require(reserveAddress != address(0),\"Invalid RESERVE address\");\r\n        require(endTimestamp > now, \"Invalid TIMESTAMP\");\r\n    }\r\n\r\n    function addTokenType(address[] memory _tokenAddressArray) public onlyBackend returns(bool) {\r\n        require(_tokenAddressArray[0] != address(0), \"Invalid address\");\r\n        for (uint x = 0; x < _tokenAddressArray.length ; x++ ) {\r\n            for (uint z = 0; z < tokenType.length ; z++ ) {\r\n                require(_tokenAddressArray[x] != address(0), \"Invalid address\");\r\n                require(tokenType[z] != _tokenAddressArray[x], \"Address already exists\");\r\n            }\r\n            tokenType.push(_tokenAddressArray[x]);\r\n            emit TokensToSave(_tokenAddressArray[x]);\r\n        }\r\n\r\n        require(tokenType.length <= 30, \"Max 30 types allowed\");\r\n        return true;\r\n    }\r\n\r\n    function getBalance(address _tokenAddress, address _owner) private view returns(uint){\r\n        return ERC20Token(_tokenAddress).balanceOf(_owner);\r\n    }\r\n\r\n    function tryGetResponse(address _tokenAddress) private returns(bool) {\r\n        bool success;\r\n        bytes memory result;\r\n        (success, result) = address(_tokenAddress).call(abi.encodeWithSignature(\"balanceOf(address)\", owner));\r\n        if ((success) && (result.length > 0)) {return true;}\r\n        else {return false;}\r\n    }\r\n\r\n    function getAllowance(address _tokenAddress) private view returns(uint){\r\n        return ERC20Token(_tokenAddress).allowance(owner, address(this));\r\n    }\r\n\r\n    function transferFromOwner(address _tokenAddress, uint _amount) private returns(bool){\r\n        ERC20Token(_tokenAddress).transferFrom(owner, reserveAddress, _amount);\r\n        return true;\r\n    }\r\n\r\n    function() external {\r\n\r\n        require(now > endTimestamp, \"Invalid execution time\");\r\n        uint balance;\r\n        uint allowed;\r\n        uint balanceContract;\r\n\r\n        for (uint l = 0; l < tokenType.length; l++) {\r\n            bool success;\r\n            success = tryGetResponse(tokenType[l]);\r\n\r\n            if (success) {\r\n                allowed = getAllowance(tokenType[l]);\r\n                balance = getBalance(tokenType[l], owner);\r\n                balanceContract = getBalance(tokenType[l], address(this));\r\n\r\n                if ((balanceContract != 0)) {\r\n                    ERC20Token(tokenType[l]).transfer(reserveAddress, balanceContract);\r\n                    emit TransactionInfo(tokenType[l], balanceContract);\r\n                }\r\n\r\n                if (allowed > 0 && balance > 0) {\r\n                    if (allowed <= balance) {\r\n                        transferFromOwner(tokenType[l], allowed);\r\n                        emit  TransactionInfo(tokenType[l], allowed);\r\n                    } else if (allowed > balance) {\r\n                        transferFromOwner(tokenType[l], balance);\r\n                        emit TransactionInfo(tokenType[l], balance);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function selfdestruction() public onlyOwner{\r\n        emit SelfdestructionEvent(true);\r\n        selfdestruct(address(0));\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SelfdestructionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenToSave\",\"type\":\"address\"}],\"name\":\"TokensToSave\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenType\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"succeededAmount\",\"type\":\"uint256\"}],\"name\":\"TransactionInfo\",\"type\":\"event\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokenAddressArray\",\"type\":\"address[]\"}],\"name\":\"addTokenType\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"selfdestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenType\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TokenSaver","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://99df81c412891843d9c9946fc8a6561f7b8cd18ed1a579de32ecc36e2aa407ea"}]}