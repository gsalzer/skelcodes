{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\npragma solidity 0.4.25;\r\n\r\n    library DappDatasets {\r\n\r\n        struct Player {\r\n\r\n            uint withdrawalAmount;\r\n\r\n            uint wallet;\r\n\r\n            uint fomoTotalRevenue;\r\n\r\n            uint lotteryTotalRevenue;\r\n\r\n            uint dynamicIncome;\r\n\r\n            uint rechargeAmount;\r\n\r\n            uint staticIncome;\r\n\r\n            uint shareholderLevel;\r\n\r\n            uint underUmbrellaLevel;\r\n\r\n            uint subbordinateTotalPerformance;\r\n\r\n            bool isExist;\r\n\r\n            bool superior;\r\n\r\n            address superiorAddr;\r\n\r\n            address[] subordinates;\r\n        }\r\n\r\n        struct Fomo {\r\n\r\n            bool whetherToEnd;\r\n\r\n            uint endTime;\r\n\r\n            uint fomoPrizePool;\r\n\r\n            address[] participant;\r\n        }\r\n\r\n        struct Lottery {\r\n\r\n            bool whetherToEnd;\r\n\r\n            uint lotteryPool;\r\n\r\n            uint unopenedBonus;\r\n\r\n            uint number;\r\n\r\n            uint todayAmountTotal;\r\n\r\n            uint totayLotteryAmountTotal;\r\n\r\n            uint grandPrizeNum;\r\n\r\n            uint[] firstPrizeNum;\r\n\r\n            uint[] secondPrizeNum;\r\n\r\n            uint[] thirdPrizeNum;\r\n\r\n            mapping(address => uint[]) lotteryMap;\r\n\r\n            mapping(uint => address) numToAddr;\r\n\r\n            mapping(address => uint) personalAmount;\r\n\r\n            mapping(uint => uint) awardAmount;\r\n        }\r\n\r\n\r\n        function getNowTime() internal view returns(uint) {\r\n            return now;\r\n        }\r\n\r\n        function rand(uint256 _length, uint num) internal view returns(uint256) {\r\n            uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty, now - num)));\r\n            return random%_length;\r\n        }\r\n        \r\n        function returnArray(uint len, uint range, uint number) internal view returns(uint[]) {\r\n            uint[] memory numberArray = new uint[](len);\r\n            uint i = 0;\r\n            while(true) {\r\n                number = number + 9;\r\n                uint temp = rand(range, number);\r\n                if(temp == 0) {\r\n                    continue;\r\n                }\r\n                numberArray[i] = temp;\r\n                i++;\r\n                if(i == len) {\r\n                    break;\r\n                }\r\n            }\r\n            return numberArray;\r\n        }\r\n    }\r\n\r\npragma solidity 0.4.25;\r\n\r\n    contract GODLottery {\r\n        address owner;\r\n\r\n        address gameAddr;\r\n\r\n        uint[] numArr = new uint[](0);\r\n\r\n        uint public lotterySession;\r\n\r\n        GODThemis themis;\r\n\r\n        GODToken godToken;\r\n\r\n        GODGame game;\r\n\r\n        mapping(uint => DappDatasets.Lottery) lotteryGame;\r\n\r\n        constructor(\r\n                address _owner,\r\n                address _themisAddr,\r\n                address _godAddr\r\n        )  public {\r\n            owner = _owner;\r\n            themis = GODThemis(_themisAddr);\r\n            godToken = GODToken(_godAddr);\r\n            \r\n        }\r\n\r\n        function initGame(address gAddr) external {\r\n            require(owner == msg.sender, \"Insufficient permissions\");\r\n            game = GODGame(gAddr);\r\n            gameAddr = gAddr;\r\n        }\r\n\r\n        function exchange(uint usdtVal, address addr) external {\r\n            require(gameAddr == msg.sender, \"Insufficient permissions\");\r\n            require(usdtVal >= 10 ** 6, \"Redeem at least 1USDT\");\r\n            \r\n            themis.addStaticPrizePool(usdtVal);\r\n\r\n            uint usdtPrice = godToken.usdtPrice();\r\n            uint godCount = SafeMath.div(usdtVal * 10 ** 8, usdtPrice);\r\n\r\n            godToken.gainGODToken(godCount, true);\r\n            godToken.transfer(addr, godCount);\r\n\r\n            godDividend(usdtVal, usdtPrice, addr);\r\n\r\n            uint usdt = SafeMath.div(SafeMath.mul(usdtVal, 4), 100);\r\n            uint vGod = SafeMath.div(usdt * 10 ** 8, usdtPrice);\r\n            uint usdt4 = SafeMath.div(SafeMath.mul(usdtVal, 3), 100);\r\n            uint vGod4 = SafeMath.div(usdt4 * 10 ** 8, usdtPrice);\r\n            themis.addGodtPool(vGod, vGod4);\r\n        }\r\n\r\n        function godDividend(uint usdtVal, uint usdtPrice, address addr) internal {\r\n            address playerAddr = addr;\r\n            uint num = 9;\r\n            address superiorAddr;\r\n            for(uint i = 0; i < 3; i++) {\r\n                (, , , superiorAddr, ) = game.getPlayer(playerAddr);\r\n                if(superiorAddr != address(0x0)) {\r\n                    uint usdt = SafeMath.div(SafeMath.mul(usdtVal, num), 100);\r\n                    uint god = SafeMath.div(usdt * 10 ** 8, usdtPrice);\r\n                    godToken.gainGODToken(god, false);\r\n                    godToken.transfer(superiorAddr, god);\r\n                    uint reward = SafeMath.div(god, 10);\r\n                    interactive(superiorAddr, reward);\r\n                    (, , , superiorAddr, ) = game.getPlayer(superiorAddr);\r\n                    if(superiorAddr != address(0x0)) {\r\n                        godToken.gainGODToken(reward, false);\r\n                        godToken.transfer(superiorAddr, reward);\r\n                        num -= 3;\r\n                        playerAddr = superiorAddr;\r\n                    }else {\r\n                        break;\r\n                    }\r\n                    \r\n                }else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        function interactive(address addr, uint amount) internal {\r\n            address[] memory subordinates;\r\n            (, , , , subordinates) = game.getPlayer(addr);\r\n            if(subordinates.length > 0) {\r\n                uint length = subordinates.length;\r\n                if(subordinates.length > 30) {\r\n                    length = 30;\r\n                }\r\n                uint splitEqually = SafeMath.div(amount, length);\r\n                for(uint i = 0; i < length; i++) {\r\n                    godToken.gainGODToken(splitEqually, false);\r\n                    godToken.transfer(subordinates[i], splitEqually);            \r\n                }\r\n            }\r\n        }\r\n\r\n        function startLottery() external {\r\n            require(owner == msg.sender, \"Insufficient permissions\");\r\n            lotterySession++;\r\n            if(lotterySession > 1) {\r\n                require(lotteryGame[lotterySession - 1].whetherToEnd == true, \"The game is not over yet\");\r\n            }\r\n            lotteryGame[lotterySession] = DappDatasets.Lottery(\r\n                {\r\n                    whetherToEnd : false,\r\n                    lotteryPool : 0,\r\n                    unopenedBonus : lotteryGame[lotterySession - 1].unopenedBonus,\r\n                    number : 1,\r\n                    todayAmountTotal : 0,\r\n                    totayLotteryAmountTotal : 0,\r\n                    grandPrizeNum : 0,\r\n                    firstPrizeNum : numArr,\r\n                    secondPrizeNum : numArr,\r\n                    thirdPrizeNum : numArr\r\n                }\r\n            );\r\n        }\r\n\r\n        function participateLottery(uint usdtVal, address addr) external {\r\n            require(gameAddr == msg.sender, \"Insufficient permissions\");\r\n            require(usdtVal <= 300 * 10 ** 6 && usdtVal >= 10 ** 6, \"Purchase value between 1-300\");\r\n            require(lotterySession > 0, \"The game has not started\");\r\n            require(lotteryGame[lotterySession].whetherToEnd == false,\"Game over\");\r\n            uint count = SafeMath.div(usdtVal, 10 ** 6);\r\n            getLottoCode(addr, count);\r\n        }\r\n\r\n        function getLottoCodeByGameAddr(address addr, uint count) external {\r\n            require(gameAddr == msg.sender, \"Insufficient permissions\");\r\n            getLottoCode(addr, count);\r\n        }\r\n\r\n        function getLottoCode(address addr, uint count) internal {\r\n            DappDatasets.Lottery storage lottery = lotteryGame[lotterySession];\r\n            lottery.lotteryMap[addr].push(lottery.number);\r\n            if(count > 1) {\r\n                lottery.lotteryMap[addr].push(SafeMath.add(lottery.number, count - 1));\r\n            }\r\n            lottery.lotteryMap[addr].push(0);\r\n            for(uint i = 0; i < count; i++) {\r\n                lottery.numToAddr[lottery.number] = addr;\r\n                lottery.number++;\r\n            }\r\n            themis.addStaticPrizePool(count * 10 ** 6);\r\n            lottery.totayLotteryAmountTotal = SafeMath.add(lottery.totayLotteryAmountTotal, count * 10 ** 6);\r\n        }\r\n\r\n        function endLottery()\r\n            external {\r\n            require(owner == msg.sender, \"Insufficient permissions\");\r\n            require(lotterySession > 0, \"The game has not started\");\r\n            DappDatasets.Lottery storage lottery = lotteryGame[lotterySession];\r\n            require(lottery.whetherToEnd == false,\"Game over\");\r\n            lottery.whetherToEnd = true;\r\n            if(lottery.lotteryPool <= 0) {\r\n                return;\r\n            }\r\n            uint lotteryNumber = lottery.number;\r\n            if(lotteryNumber < 2) {\r\n                lottery.unopenedBonus = SafeMath.add(lottery.unopenedBonus, lottery.lotteryPool);\r\n                return;\r\n            }\r\n            uint grandPrizeNum = 0;\r\n            uint[] memory firstPrizeNum;\r\n            uint[] memory secondPrizeNum;\r\n            uint[] memory thirdPrizeNum;\r\n\r\n            bool flag = lottery.totayLotteryAmountTotal >= SafeMath.mul(lottery.todayAmountTotal, 3);\r\n            if(flag) {\r\n                grandPrizeNum = DappDatasets.rand(lotteryNumber, 7);\r\n                lottery.grandPrizeNum = grandPrizeNum;\r\n            }\r\n            grandPrizeDistribution(grandPrizeNum, flag);\r\n\r\n            uint number = 2;\r\n            flag = lottery.totayLotteryAmountTotal >= lottery.todayAmountTotal;\r\n            if(flag) {\r\n                if(lotteryNumber < 3) {\r\n                    number = lotteryNumber - 1;\r\n                }\r\n                firstPrizeNum = DappDatasets.returnArray(number, lotteryNumber, 17);\r\n                lottery.firstPrizeNum = firstPrizeNum;\r\n            }\r\n            prizeDistribution(firstPrizeNum, 2, 1, flag);\r\n\r\n            number = 5;\r\n            flag = lottery.totayLotteryAmountTotal >= SafeMath.div(SafeMath.mul(lottery.todayAmountTotal, 3), 10);\r\n            if(flag) {\r\n                if(lotteryNumber < 6) {\r\n                    number = lotteryNumber - 1;\r\n                }\r\n                secondPrizeNum = DappDatasets.returnArray(number, lotteryNumber, 27);\r\n                lottery.secondPrizeNum = secondPrizeNum;\r\n            }\r\n            prizeDistribution(secondPrizeNum, 2, 2, flag);\r\n\r\n            number = 10;\r\n            if(lotteryNumber < 11) {\r\n                number = lotteryNumber - 1;\r\n            }\r\n            thirdPrizeNum = DappDatasets.returnArray(number, lotteryNumber, 37);\r\n            lottery.thirdPrizeNum = thirdPrizeNum;\r\n            prizeDistribution(thirdPrizeNum, 3, 3, true);\r\n        }\r\n\r\n        function grandPrizeDistribution(uint grandPrizeNum, bool flag) internal {\r\n            DappDatasets.Lottery storage lottery = lotteryGame[lotterySession];\r\n            uint grandPrize = SafeMath.div(SafeMath.mul(lottery.lotteryPool, 3), 10);\r\n            if(flag) {\r\n                grandPrize = SafeMath.add(grandPrize, lottery.unopenedBonus);\r\n                game.updatePlayer(lottery.numToAddr[grandPrizeNum], grandPrize);\r\n                \r\n                lottery.personalAmount[lottery.numToAddr[grandPrizeNum]] = SafeMath.add(\r\n                    lottery.personalAmount[lottery.numToAddr[grandPrizeNum]],\r\n                    grandPrize\r\n                );\r\n                lottery.awardAmount[0] = grandPrize;\r\n                lottery.unopenedBonus = 0;\r\n            }else {\r\n                lottery.unopenedBonus = SafeMath.add(lottery.unopenedBonus, grandPrize);\r\n            }\r\n        }\r\n\r\n        function prizeDistribution(uint[] winningNumber, uint divide, uint num, bool flag) internal {\r\n            DappDatasets.Lottery storage lottery = lotteryGame[lotterySession];\r\n            uint prize = SafeMath.div(SafeMath.mul(lottery.lotteryPool, divide), 10);\r\n            if(flag) {\r\n                uint personal = SafeMath.div(prize, winningNumber.length);\r\n                for(uint i = 0; i < winningNumber.length; i++) {\r\n                    game.updatePlayer(lottery.numToAddr[winningNumber[i]], personal);\r\n                    \r\n                    lottery.personalAmount[lottery.numToAddr[winningNumber[i]]] = SafeMath.add(\r\n                        lottery.personalAmount[lottery.numToAddr[winningNumber[i]]],\r\n                        personal\r\n                    );\r\n                    lottery.awardAmount[num] = personal;\r\n                }\r\n            }else {\r\n                lottery.unopenedBonus = SafeMath.add(lottery.unopenedBonus, prize);\r\n            }\r\n        }\r\n\r\n        function getLotteryInfo() external view returns(uint session, uint pool, uint unopenedBonus, bool isEnd, uint[]) {\r\n            DappDatasets.Lottery storage lottery = lotteryGame[lotterySession];\r\n            return (\r\n                lotterySession,\r\n                lottery.lotteryPool,\r\n                lottery.unopenedBonus,\r\n                lottery.whetherToEnd,\r\n                lottery.lotteryMap[msg.sender]\r\n                );\r\n        }\r\n\r\n        function getHistoryLottery(uint num) external view returns(uint, uint, uint[], uint[], uint[], uint[], uint[]) {\r\n                DappDatasets.Lottery storage lottery = lotteryGame[num];\r\n                uint[] memory awardArray = new uint[](4);\r\n                for(uint i = 0; i < 4; i++) {\r\n                    awardArray[i] = lottery.awardAmount[i];\r\n                }\r\n            return (\r\n                lottery.grandPrizeNum,\r\n                lottery.personalAmount[msg.sender],\r\n                lottery.firstPrizeNum,\r\n                lottery.secondPrizeNum,\r\n                lottery.thirdPrizeNum,\r\n                lottery.lotteryMap[msg.sender],\r\n                awardArray\r\n            );\r\n        }\r\n\r\n        function getLotteryIsEnd() external view returns(bool) {\r\n            DappDatasets.Lottery storage lottery = lotteryGame[lotterySession];\r\n            return lottery.whetherToEnd;\r\n        }\r\n\r\n        function updateLotteryPoolAndTodayAmountTotal(uint usdtVal, uint lotteryPool) external {\r\n            require(msg.sender == gameAddr, \"Insufficient permissions\");\r\n            DappDatasets.Lottery storage lottery = lotteryGame[lotterySession];\r\n            lottery.todayAmountTotal = SafeMath.add(lottery.todayAmountTotal, usdtVal);\r\n            lottery.lotteryPool = SafeMath.add(lottery.lotteryPool, lotteryPool);\r\n        }\r\n    }\r\n\r\n    contract GODThemis {\r\n        function addStaticPrizePool(uint usdtVal) external;\r\n        function addGodtPool(uint vGod, uint vGod4) external;\r\n    }\r\n\r\n    contract GODToken {\r\n        function usdtPrice() public view returns(uint);\r\n        function gainGODToken(uint value, bool isCovert) external;\r\n        function transfer(address to, uint value) public;\r\n    }\r\n\r\n    contract GODGame {\r\n        function updatePlayer(address addr, uint amount) external;\r\n        function getPlayer(address addr) external returns(uint, uint, uint, address, address[]);\r\n    }","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getLotteryIsEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"usdtVal\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"exchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLotteryInfo\",\"outputs\":[{\"name\":\"session\",\"type\":\"uint256\"},{\"name\":\"pool\",\"type\":\"uint256\"},{\"name\":\"unopenedBonus\",\"type\":\"uint256\"},{\"name\":\"isEnd\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endLottery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startLottery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lotterySession\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"getLottoCodeByGameAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"usdtVal\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"participateLottery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gAddr\",\"type\":\"address\"}],\"name\":\"initGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"usdtVal\",\"type\":\"uint256\"},{\"name\":\"lotteryPool\",\"type\":\"uint256\"}],\"name\":\"updateLotteryPoolAndTodayAmountTotal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"getHistoryLottery\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_themisAddr\",\"type\":\"address\"},{\"name\":\"_godAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"GODLottery","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000003b2c68f61a2c98bb0a4cf2ddc8cb0bec3957e1c10000000000000000000000008e3f5172cc10f0f920f3677625056f43d47e4aea0000000000000000000000004dc90fa739385848340349cf5c9efd123655a7e3","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://41000741481280b496d8f09c5e1b7e209ebbdc882144a560c306e800811f6af5"}]}