{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/loopring/iface/IBrokerRegistry.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity 0.5.7;\r\n\r\n\r\n/// @title IBrokerRegistry\r\n/// @dev A broker is an account that can submit orders on behalf of other\r\n///      accounts. When registering a broker, the owner can also specify a\r\n///      pre-deployed BrokerInterceptor to hook into the exchange smart contracts.\r\n/// @author Daniel Wang - <daniel@loopring.org>.\r\ncontract IBrokerRegistry {\r\n    event BrokerRegistered(\r\n        address owner,\r\n        address broker,\r\n        address interceptor\r\n    );\r\n\r\n    event BrokerUnregistered(\r\n        address owner,\r\n        address broker,\r\n        address interceptor\r\n    );\r\n\r\n    event AllBrokersUnregistered(\r\n        address owner\r\n    );\r\n\r\n    /// @dev   Validates if the broker was registered for the order owner and\r\n    ///        returns the possible BrokerInterceptor to be used.\r\n    /// @param owner The owner of the order\r\n    /// @param broker The broker of the order\r\n    /// @return True if the broker was registered for the owner\r\n    ///         and the BrokerInterceptor to use.\r\n    function getBroker(\r\n        address owner,\r\n        address broker\r\n        )\r\n        external\r\n        view\r\n        returns(\r\n            bool registered,\r\n            address interceptor\r\n        );\r\n\r\n    /// @dev   Gets all registered brokers for an owner.\r\n    /// @param owner The owner\r\n    /// @param start The start index of the list of brokers\r\n    /// @param count The number of brokers to return\r\n    /// @return The list of requested brokers and corresponding BrokerInterceptors\r\n    function getBrokers(\r\n        address owner,\r\n        uint    start,\r\n        uint    count\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            address[] memory brokers,\r\n            address[] memory interceptors\r\n        );\r\n\r\n    /// @dev   Registers a broker for msg.sender and an optional\r\n    ///        corresponding BrokerInterceptor.\r\n    /// @param broker The broker to register\r\n    /// @param interceptor The optional BrokerInterceptor to use (0x0 allowed)\r\n    function registerBroker(\r\n        address broker,\r\n        address interceptor\r\n        )\r\n        external;\r\n\r\n    /// @dev   Unregisters a broker for msg.sender\r\n    /// @param broker The broker to unregister\r\n    function unregisterBroker(\r\n        address broker\r\n        )\r\n        external;\r\n\r\n    /// @dev   Unregisters all brokers for msg.sender\r\n    function unregisterAllBrokers(\r\n        )\r\n        external;\r\n}\r\n\r\n// File: contracts/loopring/iface/IBurnRateTable.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity 0.5.7;\r\n\r\n\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @title IBurnRateTable - A contract for managing burn rates for tokens\r\ncontract IBurnRateTable {\r\n\r\n    struct TokenData {\r\n        uint    tier;\r\n        uint    validUntil;\r\n    }\r\n\r\n    mapping(address => TokenData) public tokens;\r\n\r\n    uint public constant YEAR_TO_SECONDS = 31556952;\r\n\r\n    // Tiers\r\n    uint8 public constant TIER_4 = 0;\r\n    uint8 public constant TIER_3 = 1;\r\n    uint8 public constant TIER_2 = 2;\r\n    uint8 public constant TIER_1 = 3;\r\n\r\n    uint16 public constant BURN_BASE_PERCENTAGE           =                 100 * 10; // 100%\r\n\r\n    // Cost of upgrading the tier level of a token in a percentage of the total LRC supply\r\n    uint16 public constant TIER_UPGRADE_COST_PERCENTAGE   =                        1; // 0.1%\r\n\r\n    // Burn rates\r\n    // Matching\r\n    uint16 public constant BURN_MATCHING_TIER1            =                       25; // 2.5%\r\n    uint16 public constant BURN_MATCHING_TIER2            =                  15 * 10; //  15%\r\n    uint16 public constant BURN_MATCHING_TIER3            =                  30 * 10; //  30%\r\n    uint16 public constant BURN_MATCHING_TIER4            =                  50 * 10; //  50%\r\n    // P2P\r\n    uint16 public constant BURN_P2P_TIER1                 =                       25; // 2.5%\r\n    uint16 public constant BURN_P2P_TIER2                 =                  15 * 10; //  15%\r\n    uint16 public constant BURN_P2P_TIER3                 =                  30 * 10; //  30%\r\n    uint16 public constant BURN_P2P_TIER4                 =                  50 * 10; //  50%\r\n\r\n    event TokenTierUpgraded(\r\n        address indexed addr,\r\n        uint            tier\r\n    );\r\n\r\n    /// @dev   Returns the P2P and matching burn rate for the token.\r\n    /// @param token The token to get the burn rate for.\r\n    /// @return The burn rate. The P2P burn rate and matching burn rate\r\n    ///         are packed together in the lowest 4 bytes.\r\n    ///         (2 bytes P2P, 2 bytes matching)\r\n    function getBurnRate(\r\n        address token\r\n        )\r\n        external\r\n        view\r\n        returns (uint32 burnRate);\r\n\r\n    /// @dev   Returns the tier of a token.\r\n    /// @param token The token to get the token tier for.\r\n    /// @return The tier of the token\r\n    function getTokenTier(\r\n        address token\r\n        )\r\n        public\r\n        view\r\n        returns (uint);\r\n\r\n    /// @dev   Upgrades the tier of a token. Before calling this function,\r\n    ///        msg.sender needs to approve this contract for the neccessary funds.\r\n    /// @param token The token to upgrade the tier for.\r\n    /// @return True if successful, false otherwise.\r\n    function upgradeTokenTier(\r\n        address token\r\n        )\r\n        external\r\n        returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/loopring/iface/IFeeHolder.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity 0.5.7;\r\n\r\n\r\n/// @author Kongliang Zhong - <kongliang@loopring.org>\r\n/// @title IFeeHolder - A contract holding fees.\r\ncontract IFeeHolder {\r\n\r\n    event TokenWithdrawn(\r\n        address owner,\r\n        address token,\r\n        uint value\r\n    );\r\n\r\n    // A map of all fee balances\r\n    mapping(address => mapping(address => uint)) public feeBalances;\r\n\r\n    // A map of all the nonces for a withdrawTokenFor request\r\n    mapping(address => uint) public nonces;\r\n\r\n    /// @dev   Allows withdrawing the tokens to be burned by\r\n    ///        authorized contracts.\r\n    /// @param token The token to be used to burn buy and burn LRC\r\n    /// @param value The amount of tokens to withdraw\r\n    function withdrawBurned(\r\n        address token,\r\n        uint value\r\n        )\r\n        external\r\n        returns (bool success);\r\n\r\n    /// @dev   Allows withdrawing the fee payments funds\r\n    ///        msg.sender is the recipient of the fee and the address\r\n    ///        to which the tokens will be sent.\r\n    /// @param token The token to withdraw\r\n    /// @param value The amount of tokens to withdraw\r\n    function withdrawToken(\r\n        address token,\r\n        uint value\r\n        )\r\n        external\r\n        returns (bool success);\r\n\r\n    /// @dev   Allows withdrawing the fee payments funds by providing a\r\n    ///        a signature\r\n    function withdrawTokenFor(\r\n      address owner,\r\n      address token,\r\n      uint value,\r\n      address recipient,\r\n      uint feeValue,\r\n      address feeRecipient,\r\n      uint nonce,\r\n      bytes calldata signature\r\n      )\r\n      external\r\n      returns (bool success);\r\n\r\n    function batchAddFeeBalances(\r\n        bytes32[] calldata batch\r\n        )\r\n        external;\r\n}\r\n\r\n// File: contracts/loopring/iface/IOrderBook.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity 0.5.7;\r\n\r\n\r\n/// @title IOrderBook\r\n/// @author Daniel Wang - <daniel@loopring.org>.\r\n/// @author Kongliang Zhong - <kongliang@loopring.org>.\r\ncontract IOrderBook {\r\n    // The map of registered order hashes\r\n    mapping(bytes32 => bool) public orderSubmitted;\r\n\r\n    /// @dev  Event emitted when an order was successfully submitted\r\n    ///        orderHash      The hash of the order\r\n    ///        orderData      The data of the order as passed to submitOrder()\r\n    event OrderSubmitted(\r\n        bytes32 orderHash,\r\n        bytes   orderData\r\n    );\r\n\r\n    /// @dev   Submits an order to the on-chain order book.\r\n    ///        No signature is needed. The order can only be sumbitted by its\r\n    ///        owner or its broker (the owner can be the address of a contract).\r\n    /// @param orderData The data of the order. Contains all fields that are used\r\n    ///        for the order hash calculation.\r\n    ///        See OrderHelper.updateHash() for detailed information.\r\n    function submitOrder(\r\n        bytes calldata orderData\r\n        )\r\n        external\r\n        returns (bytes32);\r\n}\r\n\r\n// File: contracts/loopring/iface/IOrderRegistry.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity 0.5.7;\r\n\r\n\r\n/// @title IOrderRegistry\r\n/// @author Daniel Wang - <daniel@loopring.org>.\r\ncontract IOrderRegistry {\r\n\r\n    /// @dev   Returns wether the order hash was registered in the registry.\r\n    /// @param broker The broker of the order\r\n    /// @param orderHash The hash of the order\r\n    /// @return True if the order hash was registered, else false.\r\n    function isOrderHashRegistered(\r\n        address broker,\r\n        bytes32 orderHash\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev   Registers an order in the registry.\r\n    ///        msg.sender needs to be the broker of the order.\r\n    /// @param orderHash The hash of the order\r\n    function registerOrderHash(\r\n        bytes32 orderHash\r\n        )\r\n        external;\r\n}\r\n\r\n// File: contracts/loopring/impl/BrokerData.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\nlibrary BrokerData {\r\n\r\n  struct BrokerOrder {\r\n    address owner;\r\n    bytes32 orderHash;\r\n    uint fillAmountB;\r\n    uint requestedAmountS;\r\n    uint requestedFeeAmount;\r\n    address tokenRecipient;\r\n    bytes extraData;\r\n  }\r\n\r\n  struct BrokerApprovalRequest {\r\n    BrokerOrder[] orders;\r\n    address tokenS;\r\n    address tokenB;\r\n    address feeToken;\r\n    uint totalFillAmountB;\r\n    uint totalRequestedAmountS;\r\n    uint totalRequestedFeeAmount;\r\n  }\r\n\r\n  struct BrokerInterceptorReport {\r\n    address owner;\r\n    address broker;\r\n    bytes32 orderHash;\r\n    address tokenB;\r\n    address tokenS;\r\n    address feeToken;\r\n    uint fillAmountB;\r\n    uint spentAmountS;\r\n    uint spentFeeAmount;\r\n    address tokenRecipient;\r\n    bytes extraData;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/loopring/iface/ITradeDelegate.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity 0.5.7;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/// @title ITradeDelegate\r\n/// @dev Acts as a middle man to transfer ERC20 tokens on behalf of different\r\n/// versions of Loopring protocol to avoid ERC20 re-authorization.\r\n/// @author Daniel Wang - <daniel@loopring.org>.\r\ncontract ITradeDelegate {\r\n\r\n    function isTrustedSubmitter(address submitter) public view returns (bool);\r\n\r\n    function addTrustedSubmitter(address submitter) public;\r\n\r\n    function removeTrustedSubmitter(address submitter) public;\r\n\r\n    function batchTransfer(\r\n        bytes32[] calldata batch\r\n    ) external;\r\n\r\n    function brokerTransfer(\r\n        address token,\r\n        address broker,\r\n        address recipient,\r\n        uint amount\r\n    ) external;\r\n\r\n    function proxyBrokerRequestAllowance(\r\n        BrokerData.BrokerApprovalRequest memory request,\r\n        address broker\r\n    ) public returns (bool);\r\n\r\n\r\n    /// @dev Add a Loopring protocol address.\r\n    /// @param addr A loopring protocol address.\r\n    function authorizeAddress(\r\n        address addr\r\n        )\r\n        external;\r\n\r\n    /// @dev Remove a Loopring protocol address.\r\n    /// @param addr A loopring protocol address.\r\n    function deauthorizeAddress(\r\n        address addr\r\n        )\r\n        external;\r\n\r\n    function isAddressAuthorized(\r\n        address addr\r\n        )\r\n        public\r\n        view\r\n        returns (bool);\r\n\r\n\r\n    function suspend()\r\n        external;\r\n\r\n    function resume()\r\n        external;\r\n\r\n    function kill()\r\n        external;\r\n}\r\n\r\n// File: contracts/loopring/iface/ITradeHistory.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity 0.5.7;\r\n\r\n\r\n/// @title ITradeHistory\r\n/// @dev Stores the trade history and cancelled data of orders\r\n/// @author Brecht Devos - <brecht@loopring.org>.\r\ncontract ITradeHistory {\r\n\r\n    // The following map is used to keep trace of order fill and cancellation\r\n    // history.\r\n    mapping (bytes32 => uint) public filled;\r\n\r\n    // This map is used to keep trace of order's cancellation history.\r\n    mapping (address => mapping (bytes32 => bool)) public cancelled;\r\n\r\n    // A map from a broker to its cutoff timestamp.\r\n    mapping (address => uint) public cutoffs;\r\n\r\n    // A map from a broker to its trading-pair cutoff timestamp.\r\n    mapping (address => mapping (bytes20 => uint)) public tradingPairCutoffs;\r\n\r\n    // A map from a broker to an order owner to its cutoff timestamp.\r\n    mapping (address => mapping (address => uint)) public cutoffsOwner;\r\n\r\n    // A map from a broker to an order owner to its trading-pair cutoff timestamp.\r\n    mapping (address => mapping (address => mapping (bytes20 => uint))) public tradingPairCutoffsOwner;\r\n\r\n\r\n    function batchUpdateFilled(\r\n        bytes32[] calldata filledInfo\r\n        )\r\n        external;\r\n\r\n    function setCancelled(\r\n        address broker,\r\n        bytes32 orderHash\r\n        )\r\n        external;\r\n\r\n    function setCutoffs(\r\n        address broker,\r\n        uint cutoff\r\n        )\r\n        external;\r\n\r\n    function setTradingPairCutoffs(\r\n        address broker,\r\n        bytes20 tokenPair,\r\n        uint cutoff\r\n        )\r\n        external;\r\n\r\n    function setCutoffsOfOwner(\r\n        address broker,\r\n        address owner,\r\n        uint cutoff\r\n        )\r\n        external;\r\n\r\n    function setTradingPairCutoffsOfOwner(\r\n        address broker,\r\n        address owner,\r\n        bytes20 tokenPair,\r\n        uint cutoff\r\n        )\r\n        external;\r\n\r\n    function batchGetFilledAndCheckCancelled(\r\n        bytes32[] calldata orderInfo\r\n        )\r\n        external\r\n        view\r\n        returns (uint[] memory fills);\r\n\r\n\r\n    /// @dev Add a Loopring protocol address.\r\n    /// @param addr A loopring protocol address.\r\n    function authorizeAddress(\r\n        address addr\r\n        )\r\n        external;\r\n\r\n    /// @dev Remove a Loopring protocol address.\r\n    /// @param addr A loopring protocol address.\r\n    function deauthorizeAddress(\r\n        address addr\r\n        )\r\n        external;\r\n\r\n    function isAddressAuthorized(\r\n        address addr\r\n        )\r\n        public\r\n        view\r\n        returns (bool);\r\n\r\n\r\n    function suspend()\r\n        external;\r\n\r\n    function resume()\r\n        external;\r\n\r\n    function kill()\r\n        external;\r\n}\r\n\r\n// File: contracts/loopring/impl/Data.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary Data {\r\n\r\n    enum TokenType { ERC20 }\r\n\r\n    struct Header {\r\n        uint version;\r\n        uint numOrders;\r\n        uint numRings;\r\n        uint numSpendables;\r\n    }\r\n\r\n    struct BrokerAction {\r\n        bytes32 hash;\r\n        address broker;\r\n        uint[] orderIndices;\r\n        uint numOrders;\r\n        uint[] transferIndices;\r\n        uint numTransfers;\r\n        address tokenS;\r\n        address tokenB;\r\n        address feeToken;\r\n        address delegate;\r\n    }\r\n\r\n    struct BrokerTransfer {\r\n        bytes32 hash;\r\n        address token;\r\n        uint amount;\r\n        address recipient;\r\n    }\r\n\r\n    struct Context {\r\n        address lrcTokenAddress;\r\n        ITradeDelegate  delegate;\r\n        ITradeHistory   tradeHistory;\r\n        IBrokerRegistry orderBrokerRegistry;\r\n        IOrderRegistry  orderRegistry;\r\n        IFeeHolder feeHolder;\r\n        IOrderBook orderBook;\r\n        IBurnRateTable burnRateTable;\r\n        uint64 ringIndex;\r\n        uint feePercentageBase;\r\n        bytes32[] tokenBurnRates;\r\n        uint feeData;\r\n        uint feePtr;\r\n        uint transferData;\r\n        uint transferPtr;\r\n        BrokerData.BrokerOrder[] brokerOrders;\r\n        BrokerAction[] brokerActions;\r\n        BrokerTransfer[] brokerTransfers;\r\n        uint numBrokerOrders;\r\n        uint numBrokerActions;\r\n        uint numBrokerTransfers;\r\n    }\r\n\r\n    struct Mining {\r\n        // required fields\r\n        address feeRecipient;\r\n\r\n        // optional fields\r\n        address miner;\r\n        bytes   sig;\r\n\r\n        // computed fields\r\n        bytes32 hash;\r\n        address interceptor;\r\n    }\r\n\r\n    struct Spendable {\r\n        bool initialized;\r\n        uint amount;\r\n        uint reserved;\r\n    }\r\n\r\n    struct Order {\r\n        uint      version;\r\n\r\n        // required fields\r\n        address   owner;\r\n        address   tokenS;\r\n        address   tokenB;\r\n        uint      amountS;\r\n        uint      amountB;\r\n        uint      validSince;\r\n        Spendable tokenSpendableS;\r\n        Spendable tokenSpendableFee;\r\n\r\n        // optional fields\r\n        address   dualAuthAddr;\r\n        address   broker;\r\n        Spendable brokerSpendableS;\r\n        Spendable brokerSpendableFee;\r\n        address   orderInterceptor;\r\n        address   wallet;\r\n        uint      validUntil;\r\n        bytes     sig;\r\n        bytes     dualAuthSig;\r\n        bool      allOrNone;\r\n        address   feeToken;\r\n        uint      feeAmount;\r\n        int16     waiveFeePercentage;\r\n        uint16    tokenSFeePercentage;    // Pre-trading\r\n        uint16    tokenBFeePercentage;   // Post-trading\r\n        address   tokenRecipient;\r\n        uint16    walletSplitPercentage;\r\n\r\n        // computed fields\r\n        bool    P2P;\r\n        bytes32 hash;\r\n        address brokerInterceptor;\r\n        uint    filledAmountS;\r\n        uint    initialFilledAmountS;\r\n        bool    valid;\r\n\r\n        TokenType tokenTypeS;\r\n        TokenType tokenTypeB;\r\n        TokenType tokenTypeFee;\r\n        bytes32 trancheS;\r\n        bytes32 trancheB;\r\n        uint    maxPrimaryFillAmount;\r\n        bool    transferFirstAsMaker;\r\n        bytes   transferDataS;\r\n    }\r\n\r\n    struct Participation {\r\n        // required fields\r\n        Order order;\r\n\r\n        // computed fields\r\n        uint splitS;\r\n        uint feeAmount;\r\n        uint feeAmountS;\r\n        uint feeAmountB;\r\n        uint rebateFee;\r\n        uint rebateS;\r\n        uint rebateB;\r\n        uint fillAmountS;\r\n        uint fillAmountB;\r\n    }\r\n\r\n    struct Ring {\r\n        uint size;\r\n        Participation[] participations;\r\n        bytes32 hash;\r\n        uint minerFeesToOrdersPercentage;\r\n        bool valid;\r\n    }\r\n\r\n    struct RingIndices {\r\n        uint index0;\r\n        uint index1;\r\n    }\r\n\r\n    struct FeeContext {\r\n        Data.Ring ring;\r\n        Data.Context ctx;\r\n        address feeRecipient;\r\n        uint walletPercentage;\r\n        int16 waiveFeePercentage;\r\n        address owner;\r\n        address wallet;\r\n        bool P2P;\r\n    }\r\n\r\n//    struct SubmitRingsRequest {\r\n//        Data.Mining  mining;\r\n//        Data.Order[] orders;\r\n//        Data.RingIndices[]  ringIndices;\r\n//    }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/market-making/sources/ERC20.sol\r\n\r\ncontract ERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => uint256) internal _balances;\r\n  mapping (address => mapping (address => uint256)) internal _allowed;\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  uint256 internal _totalSupply;\r\n\r\n  function totalSupply() public view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  function balanceOf(address owner) public view returns (uint256) {\r\n    return _balances[owner];\r\n  }\r\n\r\n  function allowance(address owner, address spender) public view returns (uint256) {\r\n    return _allowed[owner][spender];\r\n  }\r\n\r\n  function transfer(address to, uint256 value) public returns (bool) {\r\n    _transfer(msg.sender, to, value);\r\n    return true;\r\n  }\r\n\r\n  function approve(address spender, uint256 value) public returns (bool) {\r\n    _approve(msg.sender, spender, value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n    _transfer(from, to, value);\r\n    _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\r\n    return true;\r\n  }\r\n\r\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n    _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\r\n    return true;\r\n  }\r\n\r\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n    _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\r\n    return true;\r\n  }\r\n\r\n  function _transfer(address from, address to, uint256 value) internal {\r\n    require(to != address(0));\r\n\r\n    _balances[from] = _balances[from].sub(value);\r\n    _balances[to] = _balances[to].add(value);\r\n    emit Transfer(from, to, value);\r\n  }\r\n\r\n  function _mint(address account, uint256 value) internal {\r\n    require(account != address(0));\r\n\r\n    _totalSupply = _totalSupply.add(value);\r\n    _balances[account] = _balances[account].add(value);\r\n    emit Transfer(address(0), account, value);\r\n  }\r\n\r\n  function _burn(address account, uint256 value) internal {\r\n    require(account != address(0));\r\n\r\n    _totalSupply = _totalSupply.sub(value);\r\n    _balances[account] = _balances[account].sub(value);\r\n    emit Transfer(account, address(0), value);\r\n  }\r\n\r\n  function _approve(address owner, address spender, uint256 value) internal {\r\n    require(spender != address(0));\r\n    require(owner != address(0));\r\n\r\n    _allowed[owner][spender] = value;\r\n    emit Approval(owner, spender, value);\r\n  }\r\n\r\n  function _burnFrom(address account, uint256 value) internal {\r\n    _burn(account, value);\r\n    _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\r\n  }\r\n}\r\n\r\n// File: contracts/market-making/helper/MakerBrokerBase.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract MakerBrokerBase {\r\n  address public owner;\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"NOT_OWNER\");\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0x0), \"ZERO_ADDRESS\");\r\n    owner = newOwner;\r\n  }\r\n\r\n  function withdrawDust(address token) external {\r\n    require(msg.sender == owner, \"UNAUTHORIZED\");\r\n    ERC20(token).transfer(msg.sender, ERC20(token).balanceOf(address(this)));\r\n  }\r\n\r\n  function withdrawEthDust() external {\r\n    require(msg.sender == owner, \"UNAUTHORIZED\");\r\n    msg.sender.transfer(address(this).balance);\r\n  }\r\n}\r\n\r\n// File: contracts/market-making/OasisMakerBroker.sol\r\n\r\n/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\ncontract Oasis {\r\n  struct OfferInfo {\r\n    uint pay_amt;\r\n    ERC20 pay_gem;\r\n    uint buy_amt;\r\n    ERC20 buy_gem;\r\n    address owner;\r\n    uint64 timestamp;\r\n  }\r\n\r\n  mapping(uint => OfferInfo) public offers;\r\n\r\n  function getOfferCount(ERC20 sell_gem, ERC20 buy_gem) public view returns (uint);\r\n\r\n  function getBestOffer(ERC20 sell_gem, ERC20 buy_gem) public view returns (uint);\r\n\r\n  function getWorseOffer(uint id) public view returns (uint);\r\n\r\n  function isActive(uint id) public view returns (bool active);\r\n\r\n  function buy(uint id, uint amount) external returns (bool);\r\n}\r\n\r\n/*\r\n * Inherits Loopring's IBrokerDelegate and sources liquidity from Oasis\r\n * when the Loopring protocol requests a token approval. Because the Loopring\r\n * protocol expects the taker order to precede maker orders, and non-brokered\r\n * transfers occur before before brokered transfers, it is guaranteed that this\r\n * broker contract will receive the necessary WETH/DAI to convert to DAI/WETH\r\n * right before it sets the approval and the Loopring protocol transfers the tokens\r\n * out. Thus, liquidity can be sourced on-chain with no money down!\r\n */\r\ncontract OasisMakerBroker is MakerBrokerBase {\r\n\r\n  Oasis public oasis;\r\n  address public loopringProtocol;\r\n\r\n  constructor(address _loopringProtocol, address _oasis) public {\r\n    oasis = Oasis(_oasis);\r\n    loopringProtocol = _loopringProtocol;\r\n  }\r\n\r\n  function setLoopringProtocol(address _loopringProtocol) external onlyOwner {\r\n    loopringProtocol = _loopringProtocol;\r\n  }\r\n\r\n  function setOasis(address _oasis) external onlyOwner {\r\n    oasis = Oasis(_oasis);\r\n  }\r\n\r\n  // --------------------------------\r\n  // Loopring Broker Delegate\r\n\r\n  function enableToken(address token) external {\r\n    ERC20(token).approve(address(loopringProtocol), 10 ** 70);\r\n    ERC20(token).approve(address(oasis), 10 ** 70);\r\n  }\r\n\r\n  function enableTokens(address[] calldata tokens) external {\r\n    for (uint i = 0; i < tokens.length; i++) {\r\n      address token = tokens[i];\r\n      ERC20(token).approve(address(loopringProtocol), 10 ** 70);\r\n      ERC20(token).approve(address(oasis), 10 ** 70);\r\n    }\r\n  }\r\n\r\n  // --------------------------------\r\n\r\n  function brokerRequestAllowance(BrokerData.BrokerApprovalRequest memory request) public returns (bool) {\r\n    require(msg.sender == loopringProtocol, \"Oasis MakerBroker: Unauthorized caller\");\r\n    require(request.totalRequestedFeeAmount == 0, \"Oasis MakerBroker: Cannot be charged a fee\");\r\n\r\n    for (uint i = 0; i < request.orders.length; i++) {\r\n      BrokerData.BrokerOrder memory order = request.orders[i];\r\n      require(order.tokenRecipient == address(this), \"Oasis MakerBroker: Order tokenRecipient must be this broker\");\r\n      require(order.owner == owner, \"Oasis MakerBroker: Order owner must be the owner of this contract\");\r\n\r\n      (uint offerId) = abi.decode(order.extraData, (uint));\r\n      (bool success, bytes memory returnData) = address(oasis).call(\r\n        abi.encodePacked(\r\n          oasis.buy.selector,\r\n          abi.encode(offerId, order.requestedAmountS)\r\n        )\r\n      );\r\n      require(success, \"Oasis MakerBroker: Oasis matching failed\");\r\n    }\r\n\r\n    return false;\r\n    // Does not use onOrderFillReport\r\n  }\r\n\r\n  function onOrderFillReport(BrokerData.BrokerInterceptorReport memory fillReport) public {\r\n    // Do nothing\r\n  }\r\n\r\n  /*\r\n   * Balance is unknown as it is entirely dependent on the offer in Oasis being filled.\r\n   * Thus we send down a very large number to ensure the relayer/matching engine believes\r\n   * orders from this broker have enough WETH/DAI to be filled\r\n   */\r\n  function brokerBalanceOf(address owner, address tokenAddress) public view returns (uint) {\r\n    return 10 ** 70;\r\n  }\r\n\r\n  // ================================\r\n\r\n  uint public constant PAGE_SIZE = 20;\r\n\r\n  function getOrderBookRowCount(address tokenS, address tokenB) public view returns (uint) {\r\n    return oasis.getOfferCount(ERC20(tokenS), ERC20(tokenB));\r\n  }\r\n\r\n  function getOrderBookPageCount(address tokenS, address tokenB) public view returns (uint) {\r\n    uint numRows = getOrderBookRowCount(tokenS, tokenB);\r\n    if (numRows % PAGE_SIZE == 0) return numRows / PAGE_SIZE;\r\n    return (numRows / PAGE_SIZE) + 1;\r\n  }\r\n\r\n  function getOrderBookRows(address tokenS, address tokenB, uint pointer)\r\n  public\r\n  view\r\n  returns (\r\n    uint[] memory ids,\r\n    uint[] memory sellAmounts,\r\n    uint[] memory buyAmounts,\r\n    bool[] memory isActives\r\n  )\r\n  {\r\n    ERC20 sellToken = ERC20(tokenS);\r\n    ERC20 buyToken = ERC20(tokenB);\r\n\r\n    uint lastOfferId = pointer == 0\r\n    ? oasis.getBestOffer(sellToken, buyToken)\r\n    : oasis.getWorseOffer(pointer);\r\n\r\n    ids = new uint[](PAGE_SIZE);\r\n    sellAmounts = new uint[](PAGE_SIZE);\r\n    buyAmounts = new uint[](PAGE_SIZE);\r\n    isActives = new bool[](PAGE_SIZE);\r\n\r\n    for (uint i = 0; i < PAGE_SIZE; i++) {\r\n      ids[i] = lastOfferId;\r\n      (sellAmounts[i], , buyAmounts[i],,,) = oasis.offers(lastOfferId);\r\n      isActives[i] = oasis.isActive(lastOfferId);\r\n      lastOfferId = oasis.getWorseOffer(lastOfferId);\r\n    }\r\n  }\r\n\r\n  function getOrderBookRowById(uint id) public view returns (uint sellAmount, uint buyAmount) {\r\n    (sellAmount,, buyAmount,,,) = oasis.offers(id);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawDust\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PAGE_SIZE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenS\",\"type\":\"address\"},{\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getOrderBookPageCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenS\",\"type\":\"address\"},{\"name\":\"tokenB\",\"type\":\"address\"},{\"name\":\"pointer\",\"type\":\"uint256\"}],\"name\":\"getOrderBookRows\",\"outputs\":[{\"name\":\"ids\",\"type\":\"uint256[]\"},{\"name\":\"sellAmounts\",\"type\":\"uint256[]\"},{\"name\":\"buyAmounts\",\"type\":\"uint256[]\"},{\"name\":\"isActives\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEthDust\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getOrderBookRowById\",\"outputs\":[{\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"name\":\"buyAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"broker\",\"type\":\"address\"},{\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"name\":\"tokenB\",\"type\":\"address\"},{\"name\":\"tokenS\",\"type\":\"address\"},{\"name\":\"feeToken\",\"type\":\"address\"},{\"name\":\"fillAmountB\",\"type\":\"uint256\"},{\"name\":\"spentAmountS\",\"type\":\"uint256\"},{\"name\":\"spentFeeAmount\",\"type\":\"uint256\"},{\"name\":\"tokenRecipient\",\"type\":\"address\"},{\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"fillReport\",\"type\":\"tuple\"}],\"name\":\"onOrderFillReport\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oasis\",\"type\":\"address\"}],\"name\":\"setOasis\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"brokerBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"enableTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oasis\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenS\",\"type\":\"address\"},{\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getOrderBookRowCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_loopringProtocol\",\"type\":\"address\"}],\"name\":\"setLoopringProtocol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"enableToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"components\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"name\":\"fillAmountB\",\"type\":\"uint256\"},{\"name\":\"requestedAmountS\",\"type\":\"uint256\"},{\"name\":\"requestedFeeAmount\",\"type\":\"uint256\"},{\"name\":\"tokenRecipient\",\"type\":\"address\"},{\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"orders\",\"type\":\"tuple[]\"},{\"name\":\"tokenS\",\"type\":\"address\"},{\"name\":\"tokenB\",\"type\":\"address\"},{\"name\":\"feeToken\",\"type\":\"address\"},{\"name\":\"totalFillAmountB\",\"type\":\"uint256\"},{\"name\":\"totalRequestedAmountS\",\"type\":\"uint256\"},{\"name\":\"totalRequestedFeeAmount\",\"type\":\"uint256\"}],\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"brokerRequestAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loopringProtocol\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_loopringProtocol\",\"type\":\"address\"},{\"name\":\"_oasis\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"OasisMakerBroker","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e2466deb9536a69bf8131ecd0c267ee41dd1cda0000000000000000000000000794e6e91555438afc3ccf1c5076a74f42133d08d","Library":"","LicenseType":"None","SwarmSource":"bzzr://3e40bc8508abb0c2a6a372b5aaac4f0f46d48907a244beaa87b4d02ebbe19216"}]}