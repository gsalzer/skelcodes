{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n\r\n  Source code of Opium Protocol\r\n  Web https://opium.network\r\n  Telegram https://t.me/opium_network\r\n  Twitter https://twitter.com/opium_network\r\n\r\n */\r\n\r\n// File: LICENSE\r\n\r\n/**\r\n\r\nThe software and documentation available in this repository (the \"Software\") is protected by copyright law and accessible pursuant to the license set forth below. Copyright © 2020 Blockeys BV. All rights reserved.\r\n\r\nPermission is hereby granted, free of charge, to any person or organization obtaining the Software (the “Licensee”) to privately study, review, and analyze the Software. Licensee shall not use the Software for any other purpose. Licensee shall not modify, transfer, assign, share, or sub-license the Software or any derivative works of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n\r\n\r\n// File: contracts/Lib/LibDerivative.sol\r\n\r\npragma solidity 0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\n/// @title Opium.Lib.LibDerivative contract should be inherited by contracts that use Derivative structure and calculate derivativeHash\r\ncontract LibDerivative {\r\n    // Opium derivative structure (ticker) definition\r\n    struct Derivative {\r\n        // Margin parameter for syntheticId\r\n        uint256 margin;\r\n        // Maturity of derivative\r\n        uint256 endTime;\r\n        // Additional parameters for syntheticId\r\n        uint256[] params;\r\n        // oracleId of derivative\r\n        address oracleId;\r\n        // Margin token address of derivative\r\n        address token;\r\n        // syntheticId of derivative\r\n        address syntheticId;\r\n    }\r\n\r\n    /// @notice Calculates hash of provided Derivative\r\n    /// @param _derivative Derivative Instance of derivative to hash\r\n    /// @return derivativeHash bytes32 Derivative hash\r\n    function getDerivativeHash(Derivative memory _derivative) public pure returns (bytes32 derivativeHash) {\r\n        derivativeHash = keccak256(abi.encodePacked(\r\n            _derivative.margin,\r\n            _derivative.endTime,\r\n            _derivative.params,\r\n            _derivative.oracleId,\r\n            _derivative.token,\r\n            _derivative.syntheticId\r\n        ));\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard {\r\n    // counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\n// File: erc721o/contracts/Libs/LibPosition.sol\r\n\r\npragma solidity ^0.5.4;\r\n\r\nlibrary LibPosition {\r\n  function getLongTokenId(bytes32 _hash) public pure returns (uint256 tokenId) {\r\n    tokenId = uint256(keccak256(abi.encodePacked(_hash, \"LONG\")));\r\n  }\r\n\r\n  function getShortTokenId(bytes32 _hash) public pure returns (uint256 tokenId) {\r\n    tokenId = uint256(keccak256(abi.encodePacked(_hash, \"SHORT\")));\r\n  }\r\n}\r\n\r\n// File: contracts/Interface/IDerivativeLogic.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n/// @title Opium.Interface.IDerivativeLogic contract is an interface that every syntheticId should implement\r\ncontract IDerivativeLogic is LibDerivative {\r\n    /// @notice Validates ticker\r\n    /// @param _derivative Derivative Instance of derivative to validate\r\n    /// @return Returns boolean whether ticker is valid\r\n    function validateInput(Derivative memory _derivative) public view returns (bool);\r\n\r\n    /// @notice Calculates margin required for derivative creation\r\n    /// @param _derivative Derivative Instance of derivative\r\n    /// @return buyerMargin uint256 Margin needed from buyer (LONG position)\r\n    /// @return sellerMargin uint256 Margin needed from seller (SHORT position)\r\n    function getMargin(Derivative memory _derivative) public view returns (uint256 buyerMargin, uint256 sellerMargin);\r\n\r\n    /// @notice Calculates payout for derivative execution\r\n    /// @param _derivative Derivative Instance of derivative\r\n    /// @param _result uint256 Data retrieved from oracleId on the maturity\r\n    /// @return buyerPayout uint256 Payout in ratio for buyer (LONG position holder)\r\n    /// @return sellerPayout uint256 Payout in ratio for seller (SHORT position holder)\r\n    function getExecutionPayout(Derivative memory _derivative, uint256 _result)\tpublic view returns (uint256 buyerPayout, uint256 sellerPayout);\r\n\r\n    /// @notice Returns syntheticId author address for Opium commissions\r\n    /// @return authorAddress address The address of syntheticId address\r\n    function getAuthorAddress() public view returns (address authorAddress);\r\n\r\n    /// @notice Returns syntheticId author commission in base of COMMISSION_BASE\r\n    /// @return commission uint256 Author commission\r\n    function getAuthorCommission() public view returns (uint256 commission);\r\n\r\n    /// @notice Returns whether thirdparty could execute on derivative's owner's behalf\r\n    /// @param _derivativeOwner address Derivative owner address\r\n    /// @return Returns boolean whether _derivativeOwner allowed third party execution\r\n    function thirdpartyExecutionAllowed(address _derivativeOwner) public view returns (bool);\r\n\r\n    /// @notice Returns whether syntheticId implements pool logic\r\n    /// @return Returns whether syntheticId implements pool logic\r\n    function isPool() public view returns (bool);\r\n\r\n    /// @notice Sets whether thirds parties are allowed or not to execute derivative's on msg.sender's behalf\r\n    /// @param _allow bool Flag for execution allowance\r\n    function allowThirdpartyExecution(bool _allow) public;\r\n\r\n    // Event with syntheticId metadata JSON string (for DIB.ONE derivative explorer)\r\n    event MetadataSet(string metadata);\r\n}\r\n\r\n// File: contracts/Errors/CoreErrors.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ncontract CoreErrors {\r\n    string constant internal ERROR_CORE_NOT_POOL = \"CORE:NOT_POOL\";\r\n    string constant internal ERROR_CORE_CANT_BE_POOL = \"CORE:CANT_BE_POOL\";\r\n\r\n    string constant internal ERROR_CORE_TICKER_WAS_CANCELLED = \"CORE:TICKER_WAS_CANCELLED\";\r\n    string constant internal ERROR_CORE_SYNTHETIC_VALIDATION_ERROR = \"CORE:SYNTHETIC_VALIDATION_ERROR\";\r\n    string constant internal ERROR_CORE_NOT_ENOUGH_TOKEN_ALLOWANCE = \"CORE:NOT_ENOUGH_TOKEN_ALLOWANCE\";\r\n\r\n    string constant internal ERROR_CORE_TOKEN_IDS_AND_QUANTITIES_LENGTH_DOES_NOT_MATCH = \"CORE:TOKEN_IDS_AND_QUANTITIES_LENGTH_DOES_NOT_MATCH\";\r\n    string constant internal ERROR_CORE_TOKEN_IDS_AND_DERIVATIVES_LENGTH_DOES_NOT_MATCH = \"CORE:TOKEN_IDS_AND_DERIVATIVES_LENGTH_DOES_NOT_MATCH\";\r\n\r\n    string constant internal ERROR_CORE_EXECUTION_BEFORE_MATURITY_NOT_ALLOWED = \"CORE:EXECUTION_BEFORE_MATURITY_NOT_ALLOWED\";\r\n    string constant internal ERROR_CORE_SYNTHETIC_EXECUTION_WAS_NOT_ALLOWED = \"CORE:SYNTHETIC_EXECUTION_WAS_NOT_ALLOWED\";\r\n    string constant internal ERROR_CORE_INSUFFICIENT_POOL_BALANCE = \"CORE:INSUFFICIENT_POOL_BALANCE\";\r\n\r\n    string constant internal ERROR_CORE_CANT_CANCEL_DUMMY_ORACLE_ID = \"CORE:CANT_CANCEL_DUMMY_ORACLE_ID\";\r\n    string constant internal ERROR_CORE_CANCELLATION_IS_NOT_ALLOWED = \"CORE:CANCELLATION_IS_NOT_ALLOWED\";\r\n\r\n    string constant internal ERROR_CORE_UNKNOWN_POSITION_TYPE = \"CORE:UNKNOWN_POSITION_TYPE\";\r\n}\r\n\r\n// File: contracts/Errors/RegistryErrors.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ncontract RegistryErrors {\r\n    string constant internal ERROR_REGISTRY_ONLY_INITIALIZER = \"REGISTRY:ONLY_INITIALIZER\";\r\n    string constant internal ERROR_REGISTRY_ONLY_OPIUM_ADDRESS_ALLOWED = \"REGISTRY:ONLY_OPIUM_ADDRESS_ALLOWED\";\r\n\r\n    string constant internal ERROR_REGISTRY_CANT_BE_ZERO_ADDRESS = \"REGISTRY:CANT_BE_ZERO_ADDRESS\";\r\n\r\n    string constant internal ERROR_REGISTRY_ALREADY_SET = \"REGISTRY:ALREADY_SET\";\r\n}\r\n\r\n// File: contracts/Registry.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n/// @title Opium.Registry contract keeps addresses of deployed Opium contracts set to allow them route and communicate to each other\r\ncontract Registry is RegistryErrors {\r\n\r\n    // Address of Opium.TokenMinter contract\r\n    address private minter;\r\n\r\n    // Address of Opium.Core contract\r\n    address private core;\r\n\r\n    // Address of Opium.OracleAggregator contract\r\n    address private oracleAggregator;\r\n\r\n    // Address of Opium.SyntheticAggregator contract\r\n    address private syntheticAggregator;\r\n\r\n    // Address of Opium.TokenSpender contract\r\n    address private tokenSpender;\r\n\r\n    // Address of Opium commission receiver\r\n    address private opiumAddress;\r\n\r\n    // Address of Opium contract set deployer\r\n    address public initializer;\r\n\r\n    /// @notice This modifier restricts access to functions, which could be called only by initializer\r\n    modifier onlyInitializer() {\r\n        require(msg.sender == initializer, ERROR_REGISTRY_ONLY_INITIALIZER);\r\n        _;\r\n    }\r\n\r\n    /// @notice Sets initializer\r\n    constructor() public {\r\n        initializer = msg.sender;\r\n    }\r\n\r\n    // SETTERS\r\n\r\n    /// @notice Sets Opium.TokenMinter, Opium.Core, Opium.OracleAggregator, Opium.SyntheticAggregator, Opium.TokenSpender, Opium commission receiver addresses and allows to do it only once\r\n    /// @param _minter address Address of Opium.TokenMinter\r\n    /// @param _core address Address of Opium.Core\r\n    /// @param _oracleAggregator address Address of Opium.OracleAggregator\r\n    /// @param _syntheticAggregator address Address of Opium.SyntheticAggregator\r\n    /// @param _tokenSpender address Address of Opium.TokenSpender\r\n    /// @param _opiumAddress address Address of Opium commission receiver\r\n    function init(\r\n        address _minter,\r\n        address _core,\r\n        address _oracleAggregator,\r\n        address _syntheticAggregator,\r\n        address _tokenSpender,\r\n        address _opiumAddress\r\n    ) external onlyInitializer {\r\n        require(\r\n            minter == address(0) &&\r\n            core == address(0) &&\r\n            oracleAggregator == address(0) &&\r\n            syntheticAggregator == address(0) &&\r\n            tokenSpender == address(0) &&\r\n            opiumAddress == address(0),\r\n            ERROR_REGISTRY_ALREADY_SET\r\n        );\r\n\r\n        require(\r\n            _minter != address(0) &&\r\n            _core != address(0) &&\r\n            _oracleAggregator != address(0) &&\r\n            _syntheticAggregator != address(0) &&\r\n            _tokenSpender != address(0) &&\r\n            _opiumAddress != address(0),\r\n            ERROR_REGISTRY_CANT_BE_ZERO_ADDRESS\r\n        );\r\n\r\n        minter = _minter;\r\n        core = _core;\r\n        oracleAggregator = _oracleAggregator;\r\n        syntheticAggregator = _syntheticAggregator;\r\n        tokenSpender = _tokenSpender;\r\n        opiumAddress = _opiumAddress;\r\n    }\r\n\r\n    /// @notice Allows opium commission receiver address to change itself\r\n    /// @param _opiumAddress address New opium commission receiver address\r\n    function changeOpiumAddress(address _opiumAddress) external {\r\n        require(opiumAddress == msg.sender, ERROR_REGISTRY_ONLY_OPIUM_ADDRESS_ALLOWED);\r\n        require(_opiumAddress != address(0), ERROR_REGISTRY_CANT_BE_ZERO_ADDRESS);\r\n        opiumAddress = _opiumAddress;\r\n    }\r\n\r\n    // GETTERS\r\n\r\n    /// @notice Returns address of Opium.TokenMinter\r\n    /// @param result address Address of Opium.TokenMinter\r\n    function getMinter() external view returns (address result) {\r\n        return minter;\r\n    }\r\n\r\n    /// @notice Returns address of Opium.Core\r\n    /// @param result address Address of Opium.Core\r\n    function getCore() external view returns (address result) {\r\n        return core;\r\n    }\r\n\r\n    /// @notice Returns address of Opium.OracleAggregator\r\n    /// @param result address Address of Opium.OracleAggregator\r\n    function getOracleAggregator() external view returns (address result) {\r\n        return oracleAggregator;\r\n    }\r\n\r\n    /// @notice Returns address of Opium.SyntheticAggregator\r\n    /// @param result address Address of Opium.SyntheticAggregator\r\n    function getSyntheticAggregator() external view returns (address result) {\r\n        return syntheticAggregator;\r\n    }\r\n\r\n    /// @notice Returns address of Opium.TokenSpender\r\n    /// @param result address Address of Opium.TokenSpender\r\n    function getTokenSpender() external view returns (address result) {\r\n        return tokenSpender;\r\n    }\r\n\r\n    /// @notice Returns address of Opium commission receiver\r\n    /// @param result address Address of Opium commission receiver\r\n    function getOpiumAddress() external view returns (address result) {\r\n        return opiumAddress;\r\n    }\r\n}\r\n\r\n// File: contracts/Errors/UsingRegistryErrors.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ncontract UsingRegistryErrors {\r\n    string constant internal ERROR_USING_REGISTRY_ONLY_CORE_ALLOWED = \"USING_REGISTRY:ONLY_CORE_ALLOWED\";\r\n}\r\n\r\n// File: contracts/Lib/UsingRegistry.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n/// @title Opium.Lib.UsingRegistry contract should be inherited by contracts, that are going to use Opium.Registry\r\ncontract UsingRegistry is UsingRegistryErrors {\r\n    // Emitted when registry instance is set\r\n    event RegistrySet(address registry);\r\n\r\n    // Instance of Opium.Registry contract\r\n    Registry internal registry;\r\n\r\n    /// @notice This modifier restricts access to functions, which could be called only by Opium.Core\r\n    modifier onlyCore() {\r\n        require(msg.sender == registry.getCore(), ERROR_USING_REGISTRY_ONLY_CORE_ALLOWED);\r\n        _;\r\n    }\r\n\r\n    /// @notice Defines registry instance and emits appropriate event\r\n    constructor(address _registry) public {\r\n        registry = Registry(_registry);\r\n        emit RegistrySet(_registry);\r\n    }\r\n\r\n    /// @notice Getter for registry variable\r\n    /// @return address Address of registry set in current contract\r\n    function getRegistry() external view returns (address) {\r\n        return address(registry);\r\n    }\r\n}\r\n\r\n// File: contracts/Lib/LibCommission.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n/// @title Opium.Lib.LibCommission contract defines constants for Opium commissions\r\ncontract LibCommission {\r\n    // Represents 100% base for commissions calculation\r\n    uint256 constant public COMMISSION_BASE = 10000;\r\n\r\n    // Represents 100% base for Opium commission\r\n    uint256 constant public OPIUM_COMMISSION_BASE = 10;\r\n\r\n    // Represents which part of `syntheticId` author commissions goes to opium\r\n    uint256 constant public OPIUM_COMMISSION_PART = 1;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\r\n    public returns (bytes4);\r\n}\r\n\r\n// File: erc721o/contracts/Libs/UintArray.sol\r\n\r\npragma solidity ^0.5.4;\r\n\r\nlibrary UintArray {\r\n  function indexOf(uint256[] memory A, uint256 a) internal pure returns (uint256, bool) {\r\n    uint256 length = A.length;\r\n    for (uint256 i = 0; i < length; i++) {\r\n      if (A[i] == a) {\r\n        return (i, true);\r\n      }\r\n    }\r\n    return (0, false);\r\n  }\r\n\r\n  function contains(uint256[] memory A, uint256 a) internal pure returns (bool) {\r\n    (, bool isIn) = indexOf(A, a);\r\n    return isIn;\r\n  }\r\n\r\n  function difference(uint256[] memory A, uint256[] memory B) internal pure returns (uint256[] memory, uint256[] memory) {\r\n    uint256 length = A.length;\r\n    bool[] memory includeMap = new bool[](length);\r\n    uint256 count = 0;\r\n    // First count the new length because can't push for in-memory arrays\r\n    for (uint256 i = 0; i < length; i++) {\r\n      uint256 e = A[i];\r\n      if (!contains(B, e)) {\r\n        includeMap[i] = true;\r\n        count++;\r\n      }\r\n    }\r\n    uint256[] memory newUints = new uint256[](count);\r\n    uint256[] memory newUintsIdxs = new uint256[](count);\r\n    uint256 j = 0;\r\n    for (uint256 i = 0; i < length; i++) {\r\n      if (includeMap[i]) {\r\n        newUints[j] = A[i];\r\n        newUintsIdxs[j] = i;\r\n        j++;\r\n      }\r\n    }\r\n    return (newUints, newUintsIdxs);\r\n  }\r\n\r\n  function intersect(uint256[] memory A, uint256[] memory B) internal pure returns (uint256[] memory, uint256[] memory, uint256[] memory) {\r\n    uint256 length = A.length;\r\n    bool[] memory includeMap = new bool[](length);\r\n    uint256 newLength = 0;\r\n    for (uint256 i = 0; i < length; i++) {\r\n      if (contains(B, A[i])) {\r\n        includeMap[i] = true;\r\n        newLength++;\r\n      }\r\n    }\r\n    uint256[] memory newUints = new uint256[](newLength);\r\n    uint256[] memory newUintsAIdxs = new uint256[](newLength);\r\n    uint256[] memory newUintsBIdxs = new uint256[](newLength);\r\n    uint256 j = 0;\r\n    for (uint256 i = 0; i < length; i++) {\r\n      if (includeMap[i]) {\r\n        newUints[j] = A[i];\r\n        newUintsAIdxs[j] = i;\r\n        (newUintsBIdxs[j], ) = indexOf(B, A[i]);\r\n        j++;\r\n      }\r\n    }\r\n    return (newUints, newUintsAIdxs, newUintsBIdxs);\r\n  }\r\n\r\n  function isUnique(uint256[] memory A) internal pure returns (bool) {\r\n    uint256 length = A.length;\r\n\r\n    for (uint256 i = 0; i < length; i++) {\r\n      (uint256 idx, bool isIn) = indexOf(A, A[i]);\r\n\r\n      if (isIn && idx < i) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts may inherit from this and call {_registerInterface} to declare\r\n * their support of an interface.\r\n */\r\ncontract ERC165 is IERC165 {\r\n    /*\r\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev Mapping of interface ids to whether or not it's supported.\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () internal {\r\n        // Derived contracts need only register support for their own interfaces,\r\n        // we register support for ERC165 itself here\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     *\r\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the contract as an implementer of the interface defined by\r\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\r\n     * registering its interface id is not required.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of NFTs in `owner`'s account.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the NFT specified by `tokenId`.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     *\r\n     *\r\n     * Requirements:\r\n     * - `from`, `to` cannot be zero.\r\n     * - `tokenId` must be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this\r\n     * NFT by either {approve} or {setApprovalForAll}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Requirements:\r\n     * - If the caller is not `from`, it must be approved to move this NFT by\r\n     * either {approve} or {setApprovalForAll}.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n// File: erc721o/contracts/Interfaces/IERC721O.sol\r\n\r\npragma solidity ^0.5.4;\r\n\r\ncontract IERC721O {\r\n  function name() external view returns (string memory);\r\n  function symbol() external view returns (string memory);\r\n\r\n  function implementsERC721O() public pure returns (bool);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function balanceOf(address owner) public view returns (uint256);\r\n  function balanceOf(address owner, uint256 tokenId) public view returns (uint256);\r\n  function tokensOwned(address owner) public view returns (uint256[] memory, uint256[] memory);\r\n\r\n  function transfer(address to, uint256 tokenId, uint256 quantity) public;\r\n  function transferFrom(address from, address to, uint256 tokenId, uint256 quantity) public;\r\n\r\n  // Fungible Safe Transfer From\r\n  function safeTransferFrom(address from, address to, uint256 tokenId, uint256 _amount) public;\r\n  function safeTransferFrom(address from, address to, uint256 tokenId, uint256 _amount, bytes memory data) public;\r\n\r\n  // Batch Safe Transfer From\r\n  function safeBatchTransferFrom(address _from, address _to, uint256[] memory tokenIds, uint256[] memory _amounts, bytes memory _data) public;\r\n\r\n  // Required Events\r\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n  event TransferWithQuantity(address indexed from, address indexed to, uint256 indexed tokenId, uint256 quantity);\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n  event BatchTransfer(address indexed from, address indexed to, uint256[] tokenTypes, uint256[] amounts);\r\n  event Composition(uint256 portfolioId, uint256[] tokenIds, uint256[] tokenRatio);\r\n}\r\n\r\n// File: erc721o/contracts/Interfaces/IERC721OReceiver.sol\r\n\r\npragma solidity ^0.5.4;\r\n\r\n/**\r\n * @title ERC721O token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n *  from ERC721O contracts.\r\n */\r\ncontract IERC721OReceiver {\r\n  /**\r\n    * @dev Magic value to be returned upon successful reception of an amount of ERC721O tokens\r\n    *  ERC721O_RECEIVED = `bytes4(keccak256(\"onERC721OReceived(address,address,uint256,uint256,bytes)\"))` = 0xf891ffe0\r\n    *  ERC721O_BATCH_RECEIVED = `bytes4(keccak256(\"onERC721OBatchReceived(address,address,uint256[],uint256[],bytes)\"))` = 0xd0e17c0b\r\n    */\r\n  bytes4 constant internal ERC721O_RECEIVED = 0xf891ffe0;\r\n  bytes4 constant internal ERC721O_BATCH_RECEIVED = 0xd0e17c0b;\r\n\r\n  function onERC721OReceived(\r\n    address _operator,\r\n    address _from,\r\n    uint256 tokenId,\r\n    uint256 amount,\r\n    bytes memory data\r\n  ) public returns(bytes4);\r\n\r\n  function onERC721OBatchReceived(\r\n    address _operator,\r\n    address _from,\r\n    uint256[] memory _types,\r\n    uint256[] memory _amounts,\r\n    bytes memory _data\r\n  ) public returns (bytes4);\r\n}\r\n\r\n// File: erc721o/contracts/Libs/ObjectsLib.sol\r\n\r\npragma solidity ^0.5.4;\r\n\r\n\r\nlibrary ObjectLib {\r\n  // Libraries\r\n  using SafeMath for uint256;\r\n\r\n  enum Operations { ADD, SUB, REPLACE }\r\n\r\n  // Constants regarding bin or chunk sizes for balance packing\r\n  uint256 constant TYPES_BITS_SIZE   = 32;                     // Max size of each object\r\n  uint256 constant TYPES_PER_UINT256 = 256 / TYPES_BITS_SIZE; // Number of types per uint256\r\n\r\n  //\r\n  // Objects and Tokens Functions\r\n  //\r\n\r\n  /**\r\n  * @dev Return the bin number and index within that bin where ID is\r\n  * @param _tokenId Object type\r\n  * @return (Bin number, ID's index within that bin)\r\n  */\r\n  function getTokenBinIndex(uint256 _tokenId) internal pure returns (uint256 bin, uint256 index) {\r\n    bin = _tokenId * TYPES_BITS_SIZE / 256;\r\n    index = _tokenId % TYPES_PER_UINT256;\r\n    return (bin, index);\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev update the balance of a type provided in _binBalances\r\n  * @param _binBalances Uint256 containing the balances of objects\r\n  * @param _index Index of the object in the provided bin\r\n  * @param _amount Value to update the type balance\r\n  * @param _operation Which operation to conduct :\r\n  *     Operations.REPLACE : Replace type balance with _amount\r\n  *     Operations.ADD     : ADD _amount to type balance\r\n  *     Operations.SUB     : Substract _amount from type balance\r\n  */\r\n  function updateTokenBalance(\r\n    uint256 _binBalances,\r\n    uint256 _index,\r\n    uint256 _amount,\r\n    Operations _operation) internal pure returns (uint256 newBinBalance)\r\n  {\r\n    uint256 objectBalance;\r\n    if (_operation == Operations.ADD) {\r\n      objectBalance = getValueInBin(_binBalances, _index);\r\n      newBinBalance = writeValueInBin(_binBalances, _index, objectBalance.add(_amount));\r\n    } else if (_operation == Operations.SUB) {\r\n      objectBalance = getValueInBin(_binBalances, _index);\r\n      newBinBalance = writeValueInBin(_binBalances, _index, objectBalance.sub(_amount));\r\n    } else if (_operation == Operations.REPLACE) {\r\n      newBinBalance = writeValueInBin(_binBalances, _index, _amount);\r\n    } else {\r\n      revert(\"Invalid operation\"); // Bad operation\r\n    }\r\n\r\n    return newBinBalance;\r\n  }\r\n\r\n  /*\r\n  * @dev return value in _binValue at position _index\r\n  * @param _binValue uint256 containing the balances of TYPES_PER_UINT256 types\r\n  * @param _index index at which to retrieve value\r\n  * @return Value at given _index in _bin\r\n  */\r\n  function getValueInBin(uint256 _binValue, uint256 _index) internal pure returns (uint256) {\r\n\r\n    // Mask to retrieve data for a given binData\r\n    uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\r\n\r\n    // Shift amount\r\n    uint256 rightShift = 256 - TYPES_BITS_SIZE * (_index + 1);\r\n    return (_binValue >> rightShift) & mask;\r\n  }\r\n\r\n  /**\r\n  * @dev return the updated _binValue after writing _amount at _index\r\n  * @param _binValue uint256 containing the balances of TYPES_PER_UINT256 types\r\n  * @param _index Index at which to retrieve value\r\n  * @param _amount Value to store at _index in _bin\r\n  * @return Value at given _index in _bin\r\n  */\r\n  function writeValueInBin(uint256 _binValue, uint256 _index, uint256 _amount) internal pure returns (uint256) {\r\n    require(_amount < 2**TYPES_BITS_SIZE, \"Amount to write in bin is too large\");\r\n\r\n    // Mask to retrieve data for a given binData\r\n    uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\r\n\r\n    // Shift amount\r\n    uint256 leftShift = 256 - TYPES_BITS_SIZE * (_index + 1);\r\n    return (_binValue & ~(mask << leftShift) ) | (_amount << leftShift);\r\n  }\r\n\r\n}\r\n\r\n// File: erc721o/contracts/ERC721OBase.sol\r\n\r\npragma solidity ^0.5.4;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ERC721OBase is IERC721O, ERC165, IERC721 {\r\n  // Libraries\r\n  using ObjectLib for ObjectLib.Operations;\r\n  using ObjectLib for uint256;\r\n\r\n  // Array with all tokenIds\r\n  uint256[] internal allTokens;\r\n\r\n  // Packed balances\r\n  mapping(address => mapping(uint256 => uint256)) internal packedTokenBalance;\r\n\r\n  // Operators\r\n  mapping(address => mapping(address => bool)) internal operators;\r\n\r\n  // Keeps aprovals for tokens from owner to approved address\r\n  // tokenApprovals[tokenId][owner] = approved\r\n  mapping (uint256 => mapping (address => address)) internal tokenApprovals;\r\n\r\n  // Token Id state\r\n  mapping(uint256 => uint256) internal tokenTypes;\r\n\r\n  uint256 constant internal INVALID = 0;\r\n  uint256 constant internal POSITION = 1;\r\n  uint256 constant internal PORTFOLIO = 2;\r\n\r\n  // Interface constants\r\n  bytes4 internal constant INTERFACE_ID_ERC721O = 0x12345678;\r\n\r\n  // EIP712 constants\r\n  bytes32 public DOMAIN_SEPARATOR;\r\n  bytes32 public PERMIT_TYPEHASH;\r\n\r\n  // mapping holds nonces for approval permissions\r\n  // nonces[holder] => nonce\r\n  mapping (address => uint) public nonces;\r\n\r\n  modifier isOperatorOrOwner(address _from) {\r\n    require((msg.sender == _from) || operators[_from][msg.sender], \"msg.sender is neither _from nor operator\");\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n    _registerInterface(INTERFACE_ID_ERC721O);\r\n\r\n    // Calculate EIP712 constants\r\n    DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n      keccak256(\"EIP712Domain(string name,string version,address verifyingContract)\"),\r\n      keccak256(bytes(\"ERC721o\")),\r\n      keccak256(bytes(\"1\")),\r\n      address(this)\r\n    ));\r\n    PERMIT_TYPEHASH = keccak256(\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\");\r\n  }\r\n\r\n  function implementsERC721O() public pure returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether the specified token exists\r\n   * @param _tokenId uint256 ID of the token to query the existence of\r\n   * @return whether the token exists\r\n   */\r\n  function exists(uint256 _tokenId) public view returns (bool) {\r\n    return tokenTypes[_tokenId] != INVALID;\r\n  }\r\n\r\n  /**\r\n   * @dev return the _tokenId type' balance of _address\r\n   * @param _address Address to query balance of\r\n   * @param _tokenId type to query balance of\r\n   * @return Amount of objects of a given type ID\r\n   */\r\n  function balanceOf(address _address, uint256 _tokenId) public view returns (uint256) {\r\n    (uint256 bin, uint256 index) = _tokenId.getTokenBinIndex();\r\n    return packedTokenBalance[_address][bin].getValueInBin(index);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the total amount of tokens stored by the contract\r\n   * @return uint256 representing the total amount of tokens\r\n   */\r\n  function totalSupply() public view returns (uint256) {\r\n    return allTokens.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets Iterate through the list of existing tokens and return the indexes\r\n   *        and balances of the tokens owner by the user\r\n   * @param _owner The adddress we are checking\r\n   * @return indexes The tokenIds\r\n   * @return balances The balances of each token\r\n   */\r\n  function tokensOwned(address _owner) public view returns (uint256[] memory indexes, uint256[] memory balances) {\r\n    uint256 numTokens = totalSupply();\r\n    uint256[] memory tokenIndexes = new uint256[](numTokens);\r\n    uint256[] memory tempTokens = new uint256[](numTokens);\r\n\r\n    uint256 count;\r\n    for (uint256 i = 0; i < numTokens; i++) {\r\n      uint256 tokenId = allTokens[i];\r\n      if (balanceOf(_owner, tokenId) > 0) {\r\n        tempTokens[count] = balanceOf(_owner, tokenId);\r\n        tokenIndexes[count] = tokenId;\r\n        count++;\r\n      }\r\n    }\r\n\r\n    // copy over the data to a correct size array\r\n    uint256[] memory _ownedTokens = new uint256[](count);\r\n    uint256[] memory _ownedTokensIndexes = new uint256[](count);\r\n\r\n    for (uint256 i = 0; i < count; i++) {\r\n      _ownedTokens[i] = tempTokens[i];\r\n      _ownedTokensIndexes[i] = tokenIndexes[i];\r\n    }\r\n\r\n    return (_ownedTokensIndexes, _ownedTokens);\r\n  }\r\n\r\n  /**\r\n   * @dev Will set _operator operator status to true or false\r\n   * @param _operator Address to changes operator status.\r\n   * @param _approved  _operator's new operator status (true or false)\r\n   */\r\n  function setApprovalForAll(address _operator, bool _approved) public {\r\n    // Update operator status\r\n    operators[msg.sender][_operator] = _approved;\r\n    emit ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n  /// @notice Approve for all by signature\r\n  function permit(address _holder, address _spender, uint256 _nonce, uint256 _expiry, bool _allowed, bytes calldata _signature) external {\r\n    // Calculate hash\r\n    bytes32 digest =\r\n      keccak256(abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        keccak256(abi.encode(\r\n          PERMIT_TYPEHASH,\r\n          _holder,\r\n          _spender,\r\n          _nonce,\r\n          _expiry,\r\n          _allowed\r\n        ))\r\n    ));\r\n\r\n    // Divide the signature in r, s and v variables\r\n    // ecrecover takes the signature parameters, and the only way to get them\r\n    // currently is to use assembly.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    bytes memory signature = _signature;\r\n\r\n    assembly {\r\n      r := mload(add(signature, 32))\r\n      s := mload(add(signature, 64))\r\n      v := byte(0, mload(add(signature, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    address recoveredAddress;\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      recoveredAddress = address(0);\r\n    } else {\r\n      // solium-disable-next-line arg-overflow\r\n      recoveredAddress = ecrecover(digest, v, r, s);\r\n    }\r\n\r\n    require(_holder != address(0), \"Holder can't be zero address\");\r\n    require(_holder == recoveredAddress, \"Signer address is invalid\");\r\n    require(_expiry == 0 || now <= _expiry, \"Permission expired\");\r\n    require(_nonce == nonces[_holder]++, \"Nonce is invalid\");\r\n\r\n    // Update operator status\r\n    operators[_holder][_spender] = _allowed;\r\n    emit ApprovalForAll(_holder, _spender, _allowed);\r\n  }\r\n\r\n  /**\r\n   * @dev Approves another address to transfer the given token ID\r\n   * The zero address indicates there is no approved address.\r\n   * There can only be one approved address per token at a given time.\r\n   * Can only be called by the token owner or an approved operator.\r\n   * @param _to address to be approved for the given token ID\r\n   * @param _tokenId uint256 ID of the token to be approved\r\n   */\r\n  function approve(address _to, uint256 _tokenId) public {\r\n    require(_to != msg.sender, \"Can't approve to yourself\");\r\n    tokenApprovals[_tokenId][msg.sender] = _to;\r\n    emit Approval(msg.sender, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the approved address for a token ID, or zero if no address set\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return address currently approved for the given token ID\r\n   */\r\n  function getApproved(uint256 _tokenId, address _tokenOwner) public view returns (address) {\r\n    return tokenApprovals[_tokenId][_tokenOwner];\r\n  }\r\n\r\n  /**\r\n   * @dev Function that verifies whether _operator is an authorized operator of _tokenHolder.\r\n   * @param _operator The address of the operator to query status of\r\n   * @param _owner Address of the tokenHolder\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool isOperator) {\r\n    return operators[_owner][_operator];\r\n  }\r\n\r\n  function isApprovedOrOwner(\r\n    address _spender,\r\n    address _owner,\r\n    uint256 _tokenId\r\n  ) public view returns (bool) {\r\n    return (\r\n      _spender == _owner ||\r\n      getApproved(_tokenId, _owner) == _spender ||\r\n      isApprovedForAll(_owner, _spender)\r\n    );\r\n  }\r\n\r\n  function _updateTokenBalance(\r\n    address _from,\r\n    uint256 _tokenId,\r\n    uint256 _amount,\r\n    ObjectLib.Operations op\r\n  ) internal {\r\n    (uint256 bin, uint256 index) = _tokenId.getTokenBinIndex();\r\n    packedTokenBalance[_from][bin] = packedTokenBalance[_from][bin].updateTokenBalance(\r\n      index, _amount, op\r\n    );\r\n  }\r\n}\r\n\r\n// File: erc721o/contracts/ERC721OTransferable.sol\r\n\r\npragma solidity ^0.5.4;\r\n\r\n\r\n\r\n\r\ncontract ERC721OTransferable is ERC721OBase, ReentrancyGuard {\r\n  // Libraries\r\n  using Address for address;\r\n\r\n  // safeTransfer constants\r\n  bytes4 internal constant ERC721O_RECEIVED = 0xf891ffe0;\r\n  bytes4 internal constant ERC721O_BATCH_RECEIVED = 0xd0e17c0b;\r\n\r\n  function batchTransferFrom(address _from, address _to, uint256[] memory _tokenIds, uint256[] memory _amounts) public {\r\n    // Batch Transfering\r\n    _batchTransferFrom(_from, _to, _tokenIds, _amounts);\r\n  }\r\n\r\n  /**\r\n    * @dev transfer objects from different tokenIds to specified address\r\n    * @param _from The address to BatchTransfer objects from.\r\n    * @param _to The address to batchTransfer objects to.\r\n    * @param _tokenIds Array of tokenIds to update balance of\r\n    * @param _amounts Array of amount of object per type to be transferred.\r\n    * @param _data Data to pass to onERC721OReceived() function if recipient is contract\r\n    * Note:  Arrays should be sorted so that all tokenIds in a same bin are adjacent (more efficient).\r\n    */\r\n  function safeBatchTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256[] memory _tokenIds,\r\n    uint256[] memory _amounts,\r\n    bytes memory _data\r\n  ) public nonReentrant {\r\n    // Batch Transfering\r\n    _batchTransferFrom(_from, _to, _tokenIds, _amounts);\r\n\r\n    // Pass data if recipient is contract\r\n    if (_to.isContract()) {\r\n      bytes4 retval = IERC721OReceiver(_to).onERC721OBatchReceived(\r\n        msg.sender, _from, _tokenIds, _amounts, _data\r\n      );\r\n      require(retval == ERC721O_BATCH_RECEIVED);\r\n    }\r\n  }\r\n\r\n  function safeBatchTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256[] memory _tokenIds,\r\n    uint256[] memory _amounts\r\n  ) public {\r\n    safeBatchTransferFrom(_from, _to, _tokenIds, _amounts, \"\");\r\n  }\r\n\r\n  function transfer(address _to, uint256 _tokenId, uint256 _amount) public {\r\n    _transferFrom(msg.sender, _to, _tokenId, _amount);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {\r\n    _transferFrom(_from, _to, _tokenId, _amount);\r\n  }\r\n\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {\r\n    safeTransferFrom(_from, _to, _tokenId, _amount, \"\");\r\n  }\r\n\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount, bytes memory _data) public nonReentrant {\r\n    _transferFrom(_from, _to, _tokenId, _amount);\r\n    require(\r\n      _checkAndCallSafeTransfer(_from, _to, _tokenId, _amount, _data),\r\n      \"Sent to a contract which is not an ERC721O receiver\"\r\n    );\r\n  }\r\n\r\n  /**\r\n    * @dev transfer objects from different tokenIds to specified address\r\n    * @param _from The address to BatchTransfer objects from.\r\n    * @param _to The address to batchTransfer objects to.\r\n    * @param _tokenIds Array of tokenIds to update balance of\r\n    * @param _amounts Array of amount of object per type to be transferred.\r\n    * Note:  Arrays should be sorted so that all tokenIds in a same bin are adjacent (more efficient).\r\n    */\r\n  function _batchTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256[] memory _tokenIds,\r\n    uint256[] memory _amounts\r\n  ) internal isOperatorOrOwner(_from) {\r\n    // Requirements\r\n    require(_tokenIds.length == _amounts.length, \"Inconsistent array length between args\");\r\n    require(_to != address(0), \"Invalid recipient\");\r\n\r\n    // Load first bin and index where the object balance exists\r\n    (uint256 bin, uint256 index) = ObjectLib.getTokenBinIndex(_tokenIds[0]);\r\n\r\n    // Balance for current bin in memory (initialized with first transfer)\r\n    // Written with bad library syntax instead of as below to bypass stack limit error\r\n    uint256 balFrom = ObjectLib.updateTokenBalance(\r\n      packedTokenBalance[_from][bin], index, _amounts[0], ObjectLib.Operations.SUB\r\n    );\r\n    uint256 balTo = ObjectLib.updateTokenBalance(\r\n      packedTokenBalance[_to][bin], index, _amounts[0], ObjectLib.Operations.ADD\r\n    );\r\n\r\n    emit Transfer(_from, _to, _tokenIds[0]);\r\n    emit TransferWithQuantity(_from, _to, _tokenIds[0], _amounts[0]);\r\n\r\n    // Number of transfers to execute\r\n    uint256 nTransfer = _tokenIds.length;\r\n\r\n    // Last bin updated\r\n    uint256 lastBin = bin;\r\n\r\n    for (uint256 i = 1; i < nTransfer; i++) {\r\n      (bin, index) = _tokenIds[i].getTokenBinIndex();\r\n\r\n      // If new bin\r\n      if (bin != lastBin) {\r\n        // Update storage balance of previous bin\r\n        packedTokenBalance[_from][lastBin] = balFrom;\r\n        packedTokenBalance[_to][lastBin] = balTo;\r\n\r\n        // Load current bin balance in memory\r\n        balFrom = packedTokenBalance[_from][bin];\r\n        balTo = packedTokenBalance[_to][bin];\r\n\r\n        // Bin will be the most recent bin\r\n        lastBin = bin;\r\n      }\r\n\r\n      // Update memory balance\r\n      balFrom = balFrom.updateTokenBalance(index, _amounts[i], ObjectLib.Operations.SUB);\r\n      balTo = balTo.updateTokenBalance(index, _amounts[i], ObjectLib.Operations.ADD);\r\n\r\n      emit Transfer(_from, _to, _tokenIds[i]);\r\n      emit TransferWithQuantity(_from, _to, _tokenIds[i], _amounts[i]);\r\n    }\r\n\r\n    // Update storage of the last bin visited\r\n    packedTokenBalance[_from][bin] = balFrom;\r\n    packedTokenBalance[_to][bin] = balTo;\r\n\r\n    // Emit batchTransfer event\r\n    emit BatchTransfer(_from, _to, _tokenIds, _amounts);\r\n  }\r\n\r\n  function _transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) internal {\r\n    require(isApprovedOrOwner(msg.sender, _from, _tokenId), \"Not approved\");\r\n    require(_amount <= balanceOf(_from, _tokenId), \"Quantity greater than from balance\");\r\n    require(_to != address(0), \"Invalid to address\");\r\n\r\n    _updateTokenBalance(_from, _tokenId, _amount, ObjectLib.Operations.SUB);\r\n    _updateTokenBalance(_to, _tokenId, _amount, ObjectLib.Operations.ADD);\r\n    emit Transfer(_from, _to, _tokenId);\r\n    emit TransferWithQuantity(_from, _to, _tokenId, _amount);\r\n  }\r\n\r\n  function _checkAndCallSafeTransfer(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    uint256 _amount,\r\n    bytes memory _data\r\n  ) internal returns (bool) {\r\n    if (!_to.isContract()) {\r\n      return true;\r\n    }\r\n\r\n    bytes4 retval = IERC721OReceiver(_to).onERC721OReceived(msg.sender, _from, _tokenId, _amount, _data);\r\n    return(retval == ERC721O_RECEIVED);\r\n  }\r\n}\r\n\r\n// File: erc721o/contracts/ERC721OMintable.sol\r\n\r\npragma solidity ^0.5.4;\r\n\r\n\r\n\r\ncontract ERC721OMintable is ERC721OTransferable {\r\n  // Libraries\r\n  using LibPosition for bytes32;\r\n\r\n  // Internal functions\r\n  function _mint(uint256 _tokenId, address _to, uint256 _supply) internal {\r\n    // If the token doesn't exist, add it to the tokens array\r\n    if (!exists(_tokenId)) {\r\n      tokenTypes[_tokenId] = POSITION;\r\n      allTokens.push(_tokenId);\r\n    }\r\n\r\n    _updateTokenBalance(_to, _tokenId, _supply, ObjectLib.Operations.ADD);\r\n    emit Transfer(address(0), _to, _tokenId);\r\n    emit TransferWithQuantity(address(0), _to, _tokenId, _supply);\r\n  }\r\n\r\n  function _burn(address _tokenOwner, uint256 _tokenId, uint256 _quantity) internal {\r\n    uint256 ownerBalance = balanceOf(_tokenOwner, _tokenId);\r\n    require(ownerBalance >= _quantity, \"TOKEN_MINTER:NOT_ENOUGH_POSITIONS\");\r\n\r\n    _updateTokenBalance(_tokenOwner, _tokenId, _quantity, ObjectLib.Operations.SUB);\r\n    emit Transfer(_tokenOwner, address(0), _tokenId);\r\n    emit TransferWithQuantity(_tokenOwner, address(0), _tokenId, _quantity);\r\n  }\r\n\r\n  function _mint(address _buyer, address _seller, bytes32 _derivativeHash, uint256 _quantity) internal {\r\n    _mintLong(_buyer, _derivativeHash, _quantity);\r\n    _mintShort(_seller, _derivativeHash, _quantity);\r\n  }\r\n\r\n  function _mintLong(address _buyer, bytes32 _derivativeHash, uint256 _quantity) internal {\r\n    uint256 longTokenId = _derivativeHash.getLongTokenId();\r\n    _mint(longTokenId, _buyer, _quantity);\r\n  }\r\n\r\n  function _mintShort(address _seller, bytes32 _derivativeHash, uint256 _quantity) internal {\r\n    uint256 shortTokenId = _derivativeHash.getShortTokenId();\r\n    _mint(shortTokenId, _seller, _quantity);\r\n  }\r\n\r\n  function _registerPortfolio(uint256 _portfolioId, uint256[] memory _tokenIds, uint256[] memory _tokenRatio) internal {\r\n    if (!exists(_portfolioId)) {\r\n      tokenTypes[_portfolioId] = PORTFOLIO;\r\n      emit Composition(_portfolioId, _tokenIds, _tokenRatio);\r\n    }\r\n  }\r\n}\r\n\r\n// File: erc721o/contracts/ERC721OComposable.sol\r\n\r\npragma solidity ^0.5.4;\r\n\r\n\r\n\r\ncontract ERC721OComposable is ERC721OMintable {\r\n  // Libraries\r\n  using UintArray for uint256[];\r\n\r\n  function compose(uint256[] memory _tokenIds, uint256[] memory _tokenRatio, uint256 _quantity) public {\r\n    require(_tokenIds.length == _tokenRatio.length, \"TOKEN_MINTER:TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH\");\r\n    require(_quantity > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\r\n    require(_tokenIds.length > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\r\n    require(_tokenIds.isUnique(), \"TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE\");\r\n\r\n    for (uint256 i = 0; i < _tokenIds.length; i++) {\r\n      _burn(msg.sender, _tokenIds[i], _tokenRatio[i] * _quantity);\r\n    }\r\n\r\n    uint256 portfolioId = uint256(keccak256(abi.encodePacked(\r\n      _tokenIds,\r\n      _tokenRatio\r\n    )));\r\n\r\n    _registerPortfolio(portfolioId, _tokenIds, _tokenRatio);\r\n    _mint(portfolioId, msg.sender, _quantity);\r\n  }\r\n\r\n  function decompose(uint256 _portfolioId, uint256[] memory _tokenIds, uint256[] memory _tokenRatio, uint256 _quantity) public {\r\n    require(_tokenIds.length == _tokenRatio.length, \"TOKEN_MINTER:TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH\");\r\n    require(_quantity > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\r\n    require(_tokenIds.length > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\r\n    require(_tokenIds.isUnique(), \"TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE\");\r\n\r\n    uint256 portfolioId = uint256(keccak256(abi.encodePacked(\r\n      _tokenIds,\r\n      _tokenRatio\r\n    )));\r\n\r\n    require(portfolioId == _portfolioId, \"TOKEN_MINTER:WRONG_PORTFOLIO_ID\");\r\n    _burn(msg.sender, _portfolioId, _quantity);\r\n\r\n    for (uint256 i = 0; i < _tokenIds.length; i++) {\r\n      _mint(_tokenIds[i], msg.sender, _tokenRatio[i] * _quantity);\r\n    }\r\n  }\r\n\r\n  function recompose(\r\n    uint256 _portfolioId,\r\n    uint256[] memory _initialTokenIds,\r\n    uint256[] memory _initialTokenRatio,\r\n    uint256[] memory _finalTokenIds,\r\n    uint256[] memory _finalTokenRatio,\r\n    uint256 _quantity\r\n  ) public {\r\n    require(_initialTokenIds.length == _initialTokenRatio.length, \"TOKEN_MINTER:INITIAL_TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH\");\r\n    require(_finalTokenIds.length == _finalTokenRatio.length, \"TOKEN_MINTER:FINAL_TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH\");\r\n    require(_quantity > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\r\n    require(_initialTokenIds.length > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\r\n    require(_finalTokenIds.length > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\r\n    require(_initialTokenIds.isUnique(), \"TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE\");\r\n    require(_finalTokenIds.isUnique(), \"TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE\");\r\n\r\n    uint256 oldPortfolioId = uint256(keccak256(abi.encodePacked(\r\n      _initialTokenIds,\r\n      _initialTokenRatio\r\n    )));\r\n\r\n    require(oldPortfolioId == _portfolioId, \"TOKEN_MINTER:WRONG_PORTFOLIO_ID\");\r\n    _burn(msg.sender, _portfolioId, _quantity);\r\n\r\n    _removedIds(_initialTokenIds, _initialTokenRatio, _finalTokenIds, _finalTokenRatio, _quantity);\r\n    _addedIds(_initialTokenIds, _initialTokenRatio, _finalTokenIds, _finalTokenRatio, _quantity);\r\n    _keptIds(_initialTokenIds, _initialTokenRatio, _finalTokenIds, _finalTokenRatio, _quantity);\r\n\r\n    uint256 newPortfolioId = uint256(keccak256(abi.encodePacked(\r\n      _finalTokenIds,\r\n      _finalTokenRatio\r\n    )));\r\n\r\n    _registerPortfolio(newPortfolioId, _finalTokenIds, _finalTokenRatio);\r\n    _mint(newPortfolioId, msg.sender, _quantity);\r\n  }\r\n\r\n  function _removedIds(\r\n    uint256[] memory _initialTokenIds,\r\n    uint256[] memory _initialTokenRatio,\r\n    uint256[] memory _finalTokenIds,\r\n    uint256[] memory _finalTokenRatio,\r\n    uint256 _quantity\r\n  ) private {\r\n    (uint256[] memory removedIds, uint256[] memory removedIdsIdxs) = _initialTokenIds.difference(_finalTokenIds);\r\n\r\n    for (uint256 i = 0; i < removedIds.length; i++) {\r\n      uint256 index = removedIdsIdxs[i];\r\n      _mint(_initialTokenIds[index], msg.sender, _initialTokenRatio[index] * _quantity);\r\n    }\r\n\r\n    _finalTokenRatio;\r\n  }\r\n\r\n  function _addedIds(\r\n      uint256[] memory _initialTokenIds,\r\n      uint256[] memory _initialTokenRatio,\r\n      uint256[] memory _finalTokenIds,\r\n      uint256[] memory _finalTokenRatio,\r\n      uint256 _quantity\r\n  ) private {\r\n    (uint256[] memory addedIds, uint256[] memory addedIdsIdxs) = _finalTokenIds.difference(_initialTokenIds);\r\n\r\n    for (uint256 i = 0; i < addedIds.length; i++) {\r\n      uint256 index = addedIdsIdxs[i];\r\n      _burn(msg.sender, _finalTokenIds[index], _finalTokenRatio[index] * _quantity);\r\n    }\r\n\r\n    _initialTokenRatio;\r\n  }\r\n\r\n  function _keptIds(\r\n      uint256[] memory _initialTokenIds,\r\n      uint256[] memory _initialTokenRatio,\r\n      uint256[] memory _finalTokenIds,\r\n      uint256[] memory _finalTokenRatio,\r\n      uint256 _quantity\r\n  ) private {\r\n    (uint256[] memory keptIds, uint256[] memory keptInitialIdxs, uint256[] memory keptFinalIdxs) = _initialTokenIds.intersect(_finalTokenIds);\r\n\r\n    for (uint256 i = 0; i < keptIds.length; i++) {\r\n      uint256 initialIndex = keptInitialIdxs[i];\r\n      uint256 finalIndex = keptFinalIdxs[i];\r\n\r\n      if (_initialTokenRatio[initialIndex] > _finalTokenRatio[finalIndex]) {\r\n        uint256 diff = _initialTokenRatio[initialIndex] - _finalTokenRatio[finalIndex];\r\n        _mint(_initialTokenIds[initialIndex], msg.sender, diff * _quantity);\r\n      } else if (_initialTokenRatio[initialIndex] < _finalTokenRatio[finalIndex]) {\r\n        uint256 diff = _finalTokenRatio[finalIndex] - _initialTokenRatio[initialIndex];\r\n        _burn(msg.sender, _initialTokenIds[initialIndex], diff * _quantity);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// File: erc721o/contracts/Libs/UintsLib.sol\r\n\r\npragma solidity ^0.5.4;\r\n\r\nlibrary UintsLib {\r\n  function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n    if (_i == 0) {\r\n      return \"0\";\r\n    }\r\n\r\n    uint j = _i;\r\n    uint len;\r\n    while (j != 0) {\r\n      len++;\r\n      j /= 10;\r\n    }\r\n\r\n    bytes memory bstr = new bytes(len);\r\n    uint k = len - 1;\r\n    while (_i != 0) {\r\n      bstr[k--] = byte(uint8(48 + _i % 10));\r\n      _i /= 10;\r\n    }\r\n\r\n    return string(bstr);\r\n  }\r\n}\r\n\r\n// File: erc721o/contracts/ERC721OBackwardCompatible.sol\r\n\r\npragma solidity ^0.5.4;\r\n\r\n\r\n\r\n\r\ncontract ERC721OBackwardCompatible is ERC721OComposable {\r\n  using UintsLib for uint256;\r\n\r\n  // Interface constants\r\n  bytes4 internal constant INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n  bytes4 internal constant INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\r\n  bytes4 internal constant INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\r\n\r\n  // Reciever constants\r\n  bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  // Metadata URI\r\n  string internal baseTokenURI;\r\n\r\n  constructor(string memory _baseTokenURI) public ERC721OBase() {\r\n    baseTokenURI = _baseTokenURI;\r\n    _registerInterface(INTERFACE_ID_ERC721);\r\n    _registerInterface(INTERFACE_ID_ERC721_ENUMERABLE);\r\n    _registerInterface(INTERFACE_ID_ERC721_METADATA);\r\n  }\r\n\r\n  // ERC721 compatibility\r\n  function implementsERC721() public pure returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n    * @dev Gets the owner of a given NFT\r\n    * @param _tokenId uint256 representing the unique token identifier\r\n    * @return address the owner of the token\r\n    */\r\n  function ownerOf(uint256 _tokenId) public view returns (address) {\r\n    if (exists(_tokenId)) {\r\n      return address(this);\r\n    }\r\n\r\n    return address(0);\r\n  }\r\n\r\n  /**\r\n   *  @dev Gets the number of tokens owned by the address we are checking\r\n   *  @param _owner The adddress we are checking\r\n   *  @return balance The unique amount of tokens owned\r\n   */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    (, uint256[] memory tokens) = tokensOwned(_owner);\r\n    return tokens.length;\r\n  }\r\n\r\n  // ERC721 - Enumerable compatibility\r\n  /**\r\n   * @dev Gets the token ID at a given index of all the tokens in this contract\r\n   * Reverts if the index is greater or equal to the total number of tokens\r\n   * @param _index uint256 representing the index to be accessed of the tokens list\r\n   * @return uint256 token ID at the given index of the tokens list\r\n   */\r\n  function tokenByIndex(uint256 _index) public view returns (uint256) {\r\n    require(_index < totalSupply());\r\n    return allTokens[_index];\r\n  }\r\n\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId) {\r\n    (, uint256[] memory tokens) = tokensOwned(_owner);\r\n    require(_index < tokens.length);\r\n    return tokens[_index];\r\n  }\r\n\r\n  // ERC721 - Metadata compatibility\r\n  function tokenURI(uint256 _tokenId) public view returns (string memory tokenUri) {\r\n    require(exists(_tokenId), \"Token doesn't exist\");\r\n    return string(abi.encodePacked(\r\n      baseTokenURI,\r\n      _tokenId.uint2str(),\r\n      \".json\"\r\n    ));\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the approved address for a token ID, or zero if no address set\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return address currently approved for the given token ID\r\n   */\r\n  function getApproved(uint256 _tokenId) public view returns (address) {\r\n    if (exists(_tokenId)) {\r\n      return address(this);\r\n    }\r\n\r\n    return address(0);\r\n  }\r\n\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public {\r\n    safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public nonReentrant {\r\n    _transferFrom(_from, _to, _tokenId, 1);\r\n    require(\r\n      _checkAndCallSafeTransfer(_from, _to, _tokenId, _data),\r\n      \"Sent to a contract which is not an ERC721 receiver\"\r\n    );\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public {\r\n    _transferFrom(_from, _to, _tokenId, 1);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to invoke `onERC721Received` on a target address\r\n   * The call is not executed if the target address is not a contract\r\n   * @param _from address representing the previous owner of the given token ID\r\n   * @param _to target address that will receive the tokens\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   * @param _data bytes optional data to send along with the call\r\n   * @return whether the call correctly returned the expected magic value\r\n   */\r\n  function _checkAndCallSafeTransfer(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes memory _data\r\n  ) internal returns (bool) {\r\n    if (!_to.isContract()) {\r\n      return true;\r\n    }\r\n    bytes4 retval = IERC721Receiver(_to).onERC721Received(\r\n        msg.sender, _from, _tokenId, _data\r\n    );\r\n    return (retval == ERC721_RECEIVED);\r\n  }\r\n}\r\n\r\n// File: contracts/TokenMinter.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n/// @title Opium.TokenMinter contract implements ERC721O token standard for minting, burning and transferring position tokens\r\ncontract TokenMinter is ERC721OBackwardCompatible, UsingRegistry {\r\n    /// @notice Calls constructors of super-contracts\r\n    /// @param _baseTokenURI string URI for token explorers\r\n    /// @param _registry address Address of Opium.registry\r\n    constructor(string memory _baseTokenURI, address _registry) public ERC721OBackwardCompatible(_baseTokenURI) UsingRegistry(_registry) {}\r\n\r\n    /// @notice Mints LONG and SHORT position tokens\r\n    /// @param _buyer address Address of LONG position receiver\r\n    /// @param _seller address Address of SHORT position receiver\r\n    /// @param _derivativeHash bytes32 Hash of derivative (ticker) of position\r\n    /// @param _quantity uint256 Quantity of positions to mint\r\n    function mint(address _buyer, address _seller, bytes32 _derivativeHash, uint256 _quantity) external onlyCore {\r\n        _mint(_buyer, _seller, _derivativeHash, _quantity);\r\n    }\r\n\r\n    /// @notice Mints only LONG position tokens for \"pooled\" derivatives\r\n    /// @param _buyer address Address of LONG position receiver\r\n    /// @param _derivativeHash bytes32 Hash of derivative (ticker) of position\r\n    /// @param _quantity uint256 Quantity of positions to mint\r\n    function mint(address _buyer, bytes32 _derivativeHash, uint256 _quantity) external onlyCore {\r\n        _mintLong(_buyer, _derivativeHash, _quantity);\r\n    }\r\n\r\n    /// @notice Burns position tokens\r\n    /// @param _tokenOwner address Address of tokens owner\r\n    /// @param _tokenId uint256 tokenId of positions to burn\r\n    /// @param _quantity uint256 Quantity of positions to burn\r\n    function burn(address _tokenOwner, uint256 _tokenId, uint256 _quantity) external onlyCore {\r\n        _burn(_tokenOwner, _tokenId, _quantity);\r\n    }\r\n\r\n    /// @notice ERC721 interface compatible function for position token name retrieving\r\n    /// @return Returns name of token\r\n    function name() external view returns (string memory) {\r\n        return \"Opium Network Position Token\";\r\n    }\r\n\r\n    /// @notice ERC721 interface compatible function for position token symbol retrieving\r\n    /// @return Returns symbol of token\r\n    function symbol() external view returns (string memory) {\r\n        return \"ONP\";\r\n    }\r\n\r\n    /// VIEW FUNCTIONS\r\n\r\n    /// @notice Checks whether _spender is approved to spend tokens on _owners behalf or owner itself\r\n    /// @param _spender address Address of spender\r\n    /// @param _owner address Address of owner\r\n    /// @param _tokenId address tokenId of interest\r\n    /// @return Returns whether _spender is approved to spend tokens\r\n    function isApprovedOrOwner(\r\n        address _spender,\r\n        address _owner,\r\n        uint256 _tokenId\r\n    ) public view returns (bool) {\r\n        return (\r\n        _spender == _owner ||\r\n        getApproved(_tokenId, _owner) == _spender ||\r\n        isApprovedForAll(_owner, _spender) ||\r\n        isOpiumSpender(_spender)\r\n        );\r\n    }\r\n\r\n    /// @notice Checks whether _spender is Opium.TokenSpender\r\n    /// @return Returns whether _spender is Opium.TokenSpender\r\n    function isOpiumSpender(address _spender) public view returns (bool) {\r\n        return _spender == registry.getTokenSpender();\r\n    }\r\n}\r\n\r\n// File: contracts/Errors/OracleAggregatorErrors.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ncontract OracleAggregatorErrors {\r\n    string constant internal ERROR_ORACLE_AGGREGATOR_NOT_ENOUGH_ETHER = \"ORACLE_AGGREGATOR:NOT_ENOUGH_ETHER\";\r\n\r\n    string constant internal ERROR_ORACLE_AGGREGATOR_QUERY_WAS_ALREADY_MADE = \"ORACLE_AGGREGATOR:QUERY_WAS_ALREADY_MADE\";\r\n\r\n    string constant internal ERROR_ORACLE_AGGREGATOR_DATA_DOESNT_EXIST = \"ORACLE_AGGREGATOR:DATA_DOESNT_EXIST\";\r\n\r\n    string constant internal ERROR_ORACLE_AGGREGATOR_DATA_ALREADY_EXIST = \"ORACLE_AGGREGATOR:DATA_ALREADY_EXIST\";\r\n}\r\n\r\n// File: contracts/Interface/IOracleId.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n/// @title Opium.Interface.IOracleId contract is an interface that every oracleId should implement\r\ninterface IOracleId {\r\n    /// @notice Requests data from `oracleId` one time\r\n    /// @param timestamp uint256 Timestamp at which data are needed\r\n    function fetchData(uint256 timestamp) external payable;\r\n\r\n    /// @notice Requests data from `oracleId` multiple times\r\n    /// @param timestamp uint256 Timestamp at which data are needed for the first time\r\n    /// @param period uint256 Period in seconds between multiple timestamps\r\n    /// @param times uint256 How many timestamps are requested\r\n    function recursivelyFetchData(uint256 timestamp, uint256 period, uint256 times) external payable;\r\n\r\n    /// @notice Requests and returns price in ETH for one request. This function could be called as `view` function. Oraclize API for price calculations restricts making this function as view.\r\n    /// @return fetchPrice uint256 Price of one data request in ETH\r\n    function calculateFetchPrice() external returns (uint256 fetchPrice);\r\n\r\n    // Event with oracleId metadata JSON string (for DIB.ONE derivative explorer)\r\n    event MetadataSet(string metadata);\r\n}\r\n\r\n// File: contracts/OracleAggregator.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n/// @title Opium.OracleAggregator contract requests and caches the data from `oracleId`s and provides them to the Core for positions execution\r\ncontract OracleAggregator is OracleAggregatorErrors, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    // Storage for the `oracleId` results\r\n    // dataCache[oracleId][timestamp] => data\r\n    mapping (address => mapping(uint256 => uint256)) public dataCache;\r\n\r\n    // Flags whether data were provided\r\n    // dataExist[oracleId][timestamp] => bool\r\n    mapping (address => mapping(uint256 => bool)) public dataExist;\r\n\r\n    // Flags whether data were requested\r\n    // dataRequested[oracleId][timestamp] => bool\r\n    mapping (address => mapping(uint256 => bool)) public dataRequested;\r\n\r\n    // MODIFIERS\r\n\r\n    /// @notice Checks whether enough ETH were provided withing data request to proceed\r\n    /// @param oracleId address Address of the `oracleId` smart contract\r\n    /// @param times uint256 How many times the `oracleId` is being requested\r\n    modifier enoughEtherProvided(address oracleId, uint256 times) {\r\n        // Calling Opium.IOracleId function to get the data fetch price per one request\r\n        uint256 oneTimePrice = calculateFetchPrice(oracleId);\r\n\r\n        // Checking if enough ether was provided for `times` amount of requests\r\n        require(msg.value >= oneTimePrice.mul(times), ERROR_ORACLE_AGGREGATOR_NOT_ENOUGH_ETHER);\r\n        _;\r\n    }\r\n\r\n    // PUBLIC FUNCTIONS\r\n\r\n    /// @notice Requests data from `oracleId` one time\r\n    /// @param oracleId address Address of the `oracleId` smart contract\r\n    /// @param timestamp uint256 Timestamp at which data are needed\r\n    function fetchData(address oracleId, uint256 timestamp) public payable nonReentrant enoughEtherProvided(oracleId, 1) {\r\n        // Check if was not requested before and mark as requested\r\n        _registerQuery(oracleId, timestamp);\r\n\r\n        // Call the `oracleId` contract and transfer ETH\r\n        IOracleId(oracleId).fetchData.value(msg.value)(timestamp);\r\n    }\r\n\r\n    /// @notice Requests data from `oracleId` multiple times\r\n    /// @param oracleId address Address of the `oracleId` smart contract\r\n    /// @param timestamp uint256 Timestamp at which data are needed for the first time\r\n    /// @param period uint256 Period in seconds between multiple timestamps\r\n    /// @param times uint256 How many timestamps are requested\r\n    function recursivelyFetchData(address oracleId, uint256 timestamp, uint256 period, uint256 times) public payable nonReentrant enoughEtherProvided(oracleId, times) {\r\n        // Check if was not requested before and mark as requested in loop for each timestamp\r\n        for (uint256 i = 0; i < times; i++) {\r\n            _registerQuery(oracleId, timestamp + period * i);\r\n        }\r\n\r\n        // Call the `oracleId` contract and transfer ETH\r\n        IOracleId(oracleId).recursivelyFetchData.value(msg.value)(timestamp, period, times);\r\n    }\r\n\r\n    /// @notice Receives and caches data from `msg.sender`\r\n    /// @param timestamp uint256 Timestamp of data\r\n    /// @param data uint256 Data itself\r\n    function __callback(uint256 timestamp, uint256 data) public {\r\n        // Don't allow to push data twice\r\n        require(!dataExist[msg.sender][timestamp], ERROR_ORACLE_AGGREGATOR_DATA_ALREADY_EXIST);\r\n\r\n        // Saving data\r\n        dataCache[msg.sender][timestamp] = data;\r\n\r\n        // Flagging that data were received\r\n        dataExist[msg.sender][timestamp] = true;\r\n    }\r\n\r\n    /// @notice Requests and returns price in ETH for one request. This function could be called as `view` function. Oraclize API for price calculations restricts making this function as view.\r\n    /// @param oracleId address Address of the `oracleId` smart contract\r\n    /// @return fetchPrice uint256 Price of one data request in ETH\r\n    function calculateFetchPrice(address oracleId) public returns(uint256 fetchPrice) {\r\n        fetchPrice = IOracleId(oracleId).calculateFetchPrice();\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @notice Checks if data was not requested and provided before and marks as requested\r\n    /// @param oracleId address Address of the `oracleId` smart contract\r\n    /// @param timestamp uint256 Timestamp at which data are requested\r\n    function _registerQuery(address oracleId, uint256 timestamp) private {\r\n        // Check if data was not requested and provided yet\r\n        require(!dataRequested[oracleId][timestamp] && !dataExist[oracleId][timestamp], ERROR_ORACLE_AGGREGATOR_QUERY_WAS_ALREADY_MADE);\r\n\r\n        // Mark as requested\r\n        dataRequested[oracleId][timestamp] = true;\r\n    }\r\n\r\n    // VIEW FUNCTIONS\r\n\r\n    /// @notice Returns cached data if they exist, or reverts with an error\r\n    /// @param oracleId address Address of the `oracleId` smart contract\r\n    /// @param timestamp uint256 Timestamp at which data were requested\r\n    /// @return dataResult uint256 Cached data provided by `oracleId`\r\n    function getData(address oracleId, uint256 timestamp) public view returns(uint256 dataResult) {\r\n        // Check if Opium.OracleAggregator has data\r\n        require(hasData(oracleId, timestamp), ERROR_ORACLE_AGGREGATOR_DATA_DOESNT_EXIST);\r\n\r\n        // Return cached data\r\n        dataResult = dataCache[oracleId][timestamp];\r\n    }\r\n\r\n    /// @notice Getter for dataExist mapping\r\n    /// @param oracleId address Address of the `oracleId` smart contract\r\n    /// @param timestamp uint256 Timestamp at which data were requested\r\n    /// @param result bool Returns whether data were provided already\r\n    function hasData(address oracleId, uint256 timestamp) public view returns(bool result) {\r\n        return dataExist[oracleId][timestamp];\r\n    }\r\n}\r\n\r\n// File: contracts/Errors/SyntheticAggregatorErrors.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ncontract SyntheticAggregatorErrors {\r\n    string constant internal ERROR_SYNTHETIC_AGGREGATOR_DERIVATIVE_HASH_NOT_MATCH = \"SYNTHETIC_AGGREGATOR:DERIVATIVE_HASH_NOT_MATCH\";\r\n    string constant internal ERROR_SYNTHETIC_AGGREGATOR_WRONG_MARGIN = \"SYNTHETIC_AGGREGATOR:WRONG_MARGIN\";\r\n    string constant internal ERROR_SYNTHETIC_AGGREGATOR_COMMISSION_TOO_BIG = \"SYNTHETIC_AGGREGATOR:COMMISSION_TOO_BIG\";\r\n}\r\n\r\n// File: contracts/SyntheticAggregator.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @notice Opium.SyntheticAggregator contract initialized, identifies and caches syntheticId sensitive data\r\ncontract SyntheticAggregator is SyntheticAggregatorErrors, LibDerivative, LibCommission, ReentrancyGuard {\r\n    // Emitted when new ticker is initialized\r\n    event Create(Derivative derivative, bytes32 derivativeHash);\r\n\r\n    // Enum for types of syntheticId\r\n    // Invalid - syntheticId is not initialized yet\r\n    // NotPool - syntheticId with p2p logic\r\n    // Pool - syntheticId with pooled logic\r\n    enum SyntheticTypes { Invalid, NotPool, Pool }\r\n\r\n    // Cache of buyer margin by ticker\r\n    // buyerMarginByHash[derivativeHash] = buyerMargin\r\n    mapping (bytes32 => uint256) public buyerMarginByHash;\r\n\r\n    // Cache of seller margin by ticker\r\n    // sellerMarginByHash[derivativeHash] = sellerMargin\r\n    mapping (bytes32 => uint256) public sellerMarginByHash;\r\n\r\n    // Cache of type by ticker\r\n    // typeByHash[derivativeHash] = type\r\n    mapping (bytes32 => SyntheticTypes) public typeByHash;\r\n\r\n    // Cache of commission by ticker\r\n    // commissionByHash[derivativeHash] = commission\r\n    mapping (bytes32 => uint256) public commissionByHash;\r\n\r\n    // Cache of author addresses by ticker\r\n    // authorAddressByHash[derivativeHash] = authorAddress\r\n    mapping (bytes32 => address) public authorAddressByHash;\r\n\r\n    // PUBLIC FUNCTIONS\r\n\r\n    /// @notice Initializes ticker, if was not initialized and returns `syntheticId` author commission from cache\r\n    /// @param _derivativeHash bytes32 Hash of derivative\r\n    /// @param _derivative Derivative Derivative itself\r\n    /// @return commission uint256 Synthetic author commission\r\n    function getAuthorCommission(bytes32 _derivativeHash, Derivative memory _derivative) public nonReentrant returns (uint256 commission) {\r\n        // Initialize derivative if wasn't initialized before\r\n        _initDerivative(_derivativeHash, _derivative);\r\n        commission = commissionByHash[_derivativeHash];\r\n    }\r\n\r\n    /// @notice Initializes ticker, if was not initialized and returns `syntheticId` author address from cache\r\n    /// @param _derivativeHash bytes32 Hash of derivative\r\n    /// @param _derivative Derivative Derivative itself\r\n    /// @return authorAddress address Synthetic author address\r\n    function getAuthorAddress(bytes32 _derivativeHash, Derivative memory _derivative) public nonReentrant returns (address authorAddress) {\r\n        // Initialize derivative if wasn't initialized before\r\n        _initDerivative(_derivativeHash, _derivative);\r\n        authorAddress = authorAddressByHash[_derivativeHash];\r\n    }\r\n\r\n    /// @notice Initializes ticker, if was not initialized and returns buyer and seller margin from cache\r\n    /// @param _derivativeHash bytes32 Hash of derivative\r\n    /// @param _derivative Derivative Derivative itself\r\n    /// @return buyerMargin uint256 Margin of buyer\r\n    /// @return sellerMargin uint256 Margin of seller\r\n    function getMargin(bytes32 _derivativeHash, Derivative memory _derivative) public nonReentrant returns (uint256 buyerMargin, uint256 sellerMargin) {\r\n        // If it's a pool, just return margin from syntheticId contract\r\n        if (_isPool(_derivativeHash, _derivative)) {\r\n            return IDerivativeLogic(_derivative.syntheticId).getMargin(_derivative);\r\n        }\r\n\r\n        // Initialize derivative if wasn't initialized before\r\n        _initDerivative(_derivativeHash, _derivative);\r\n\r\n        // Check if margins for _derivativeHash were already cached\r\n        buyerMargin = buyerMarginByHash[_derivativeHash];\r\n        sellerMargin = sellerMarginByHash[_derivativeHash];\r\n    }\r\n\r\n    /// @notice Checks whether `syntheticId` implements pooled logic\r\n    /// @param _derivativeHash bytes32 Hash of derivative\r\n    /// @param _derivative Derivative Derivative itself\r\n    /// @return result bool Returns whether synthetic implements pooled logic\r\n    function isPool(bytes32 _derivativeHash, Derivative memory _derivative) public nonReentrant returns (bool result) {\r\n        result = _isPool(_derivativeHash, _derivative);\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @notice Initializes ticker, if was not initialized and returns whether `syntheticId` implements pooled logic\r\n    /// @param _derivativeHash bytes32 Hash of derivative\r\n    /// @param _derivative Derivative Derivative itself\r\n    /// @return result bool Returns whether synthetic implements pooled logic\r\n    function _isPool(bytes32 _derivativeHash, Derivative memory _derivative) private returns (bool result) {\r\n        // Initialize derivative if wasn't initialized before\r\n        _initDerivative(_derivativeHash, _derivative);\r\n        result = typeByHash[_derivativeHash] == SyntheticTypes.Pool;\r\n    }\r\n\r\n    /// @notice Initializes ticker: caches syntheticId type, margin, author address and commission\r\n    /// @param _derivativeHash bytes32 Hash of derivative\r\n    /// @param _derivative Derivative Derivative itself\r\n    function _initDerivative(bytes32 _derivativeHash, Derivative memory _derivative) private {\r\n        // Check if type for _derivativeHash was already cached\r\n        SyntheticTypes syntheticType = typeByHash[_derivativeHash];\r\n\r\n        // Type could not be Invalid, thus this condition says us that type was not cached before\r\n        if (syntheticType != SyntheticTypes.Invalid) {\r\n            return;\r\n        }\r\n\r\n        // For security reasons we calculate hash of provided _derivative\r\n        bytes32 derivativeHash = getDerivativeHash(_derivative);\r\n        require(derivativeHash == _derivativeHash, ERROR_SYNTHETIC_AGGREGATOR_DERIVATIVE_HASH_NOT_MATCH);\r\n\r\n        // POOL\r\n        // Get isPool from SyntheticId\r\n        bool result = IDerivativeLogic(_derivative.syntheticId).isPool();\r\n        // Cache type returned from synthetic\r\n        typeByHash[derivativeHash] = result ? SyntheticTypes.Pool : SyntheticTypes.NotPool;\r\n\r\n        // MARGIN\r\n        // Get margin from SyntheticId\r\n        (uint256 buyerMargin, uint256 sellerMargin) = IDerivativeLogic(_derivative.syntheticId).getMargin(_derivative);\r\n        // We are not allowing both margins to be equal to 0\r\n        require(buyerMargin != 0 || sellerMargin != 0, ERROR_SYNTHETIC_AGGREGATOR_WRONG_MARGIN);\r\n        // Cache margins returned from synthetic\r\n        buyerMarginByHash[derivativeHash] = buyerMargin;\r\n        sellerMarginByHash[derivativeHash] = sellerMargin;\r\n\r\n        // AUTHOR ADDRESS\r\n        // Cache author address returned from synthetic\r\n        authorAddressByHash[derivativeHash] = IDerivativeLogic(_derivative.syntheticId).getAuthorAddress();\r\n\r\n        // AUTHOR COMMISSION\r\n        // Get commission from syntheticId\r\n        uint256 commission = IDerivativeLogic(_derivative.syntheticId).getAuthorCommission();\r\n        // Check if commission is not set > 100%\r\n        require(commission <= COMMISSION_BASE, ERROR_SYNTHETIC_AGGREGATOR_COMMISSION_TOO_BIG);\r\n        // Cache commission\r\n        commissionByHash[derivativeHash] = commission;\r\n\r\n        // If we are here, this basically means this ticker was not used before, so we emit an event for Dapps developers about new ticker (derivative) and it's hash\r\n        emit Create(_derivative, derivativeHash);\r\n    }\r\n}\r\n\r\n// File: contracts/Lib/Whitelisted.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n/// @title Opium.Lib.Whitelisted contract implements whitelist with modifier to restrict access to only whitelisted addresses\r\ncontract Whitelisted {\r\n    // Whitelist array\r\n    address[] internal whitelist;\r\n\r\n    /// @notice This modifier restricts access to functions, which could be called only by whitelisted addresses\r\n    modifier onlyWhitelisted() {\r\n        // Allowance flag\r\n        bool allowed = false;\r\n\r\n        // Going through whitelisted addresses array\r\n        uint256 whitelistLength = whitelist.length;\r\n        for (uint256 i = 0; i < whitelistLength; i++) {\r\n            // If `msg.sender` is met within whitelisted addresses, raise the flag and exit the loop\r\n            if (whitelist[i] == msg.sender) {\r\n                allowed = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Check if flag was raised\r\n        require(allowed, \"Only whitelisted allowed\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Getter for whitelisted addresses array\r\n    /// @return Array of whitelisted addresses\r\n    function getWhitelist() public view returns (address[] memory) {\r\n        return whitelist;\r\n    }\r\n}\r\n\r\n// File: contracts/Lib/WhitelistedWithGovernance.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n/// @title Opium.Lib.WhitelistedWithGovernance contract implements Opium.Lib.Whitelisted and adds governance for whitelist controlling\r\ncontract WhitelistedWithGovernance is Whitelisted {\r\n    // Emitted when new governor is set\r\n    event GovernorSet(address governor);\r\n\r\n    // Emitted when new whitelist is proposed\r\n    event Proposed(address[] whitelist);\r\n    // Emitted when proposed whitelist is committed (set)\r\n    event Committed(address[] whitelist);\r\n\r\n    // Proposal life timelock interval\r\n    uint256 public timeLockInterval;\r\n\r\n    // Governor address\r\n    address public governor;\r\n\r\n    // Timestamp of last proposal\r\n    uint256 public proposalTime;\r\n\r\n    // Proposed whitelist\r\n    address[] public proposedWhitelist;\r\n\r\n    /// @notice This modifier restricts access to functions, which could be called only by governor\r\n    modifier onlyGovernor() {\r\n        require(msg.sender == governor, \"Only governor allowed\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Contract constructor\r\n    /// @param _timeLockInterval uint256 Initial value for timelock interval\r\n    /// @param _governor address Initial value for governor\r\n    constructor(uint256 _timeLockInterval, address _governor) public {\r\n        timeLockInterval = _timeLockInterval;\r\n        governor = _governor;\r\n        emit GovernorSet(governor);\r\n    }\r\n\r\n    /// @notice Calling this function governor could propose new whitelist addresses array. Also it allows to initialize first whitelist if it was not initialized yet.\r\n    function proposeWhitelist(address[] memory _whitelist) public onlyGovernor {\r\n        // Restrict empty proposals\r\n        require(_whitelist.length != 0, \"Can't be empty\");\r\n\r\n        // Consider empty whitelist as not initialized, as proposing of empty whitelists is not allowed\r\n        // If whitelist has never been initialized, we set whitelist right away without proposal\r\n        if (whitelist.length == 0) {\r\n            whitelist = _whitelist;\r\n            emit Committed(_whitelist);\r\n\r\n        // Otherwise save current time as timestamp of proposal, save proposed whitelist and emit event\r\n        } else {\r\n            proposalTime = now;\r\n            proposedWhitelist = _whitelist;\r\n            emit Proposed(_whitelist);\r\n        }\r\n    }\r\n\r\n    /// @notice Calling this function governor commits proposed whitelist if timelock interval of proposal was passed\r\n    function commitWhitelist() public onlyGovernor {\r\n        // Check if proposal was made\r\n        require(proposalTime != 0, \"Didn't proposed yet\");\r\n\r\n        // Check if timelock interval was passed\r\n        require((proposalTime + timeLockInterval) < now, \"Can't commit yet\");\r\n\r\n        // Set new whitelist and emit event\r\n        whitelist = proposedWhitelist;\r\n        emit Committed(whitelist);\r\n\r\n        // Reset proposal time lock\r\n        proposalTime = 0;\r\n    }\r\n\r\n    /// @notice This function allows governor to transfer governance to a new governor and emits event\r\n    /// @param _governor address Address of new governor\r\n    function setGovernor(address _governor) public onlyGovernor {\r\n        require(_governor != address(0), \"Can't set zero address\");\r\n        governor = _governor;\r\n        emit GovernorSet(governor);\r\n    }\r\n}\r\n\r\n// File: contracts/Lib/WhitelistedWithGovernanceAndChangableTimelock.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n/// @notice Opium.Lib.WhitelistedWithGovernanceAndChangableTimelock contract implements Opium.Lib.WhitelistedWithGovernance and adds possibility for governor to change timelock interval within timelock interval\r\ncontract WhitelistedWithGovernanceAndChangableTimelock is WhitelistedWithGovernance {\r\n    // Emitted when new timelock is proposed\r\n    event Proposed(uint256 timelock);\r\n    // Emitted when new timelock is committed (set)\r\n    event Committed(uint256 timelock);\r\n\r\n    // Timestamp of last timelock proposal\r\n    uint256 public timeLockProposalTime;\r\n    // Proposed timelock\r\n    uint256 public proposedTimeLock;\r\n\r\n    /// @notice Calling this function governor could propose new timelock\r\n    /// @param _timelock uint256 New timelock value\r\n    function proposeTimelock(uint256 _timelock) public onlyGovernor {\r\n        timeLockProposalTime = now;\r\n        proposedTimeLock = _timelock;\r\n        emit Proposed(_timelock);\r\n    }\r\n\r\n    /// @notice Calling this function governor could commit previously proposed new timelock if timelock interval of proposal was passed\r\n    function commitTimelock() public onlyGovernor {\r\n        // Check if proposal was made\r\n        require(timeLockProposalTime != 0, \"Didn't proposed yet\");\r\n        // Check if timelock interval was passed\r\n        require((timeLockProposalTime + timeLockInterval) < now, \"Can't commit yet\");\r\n\r\n        // Set new timelock and emit event\r\n        timeLockInterval = proposedTimeLock;\r\n        emit Committed(proposedTimeLock);\r\n\r\n        // Reset timelock time lock\r\n        timeLockProposalTime = 0;\r\n    }\r\n}\r\n\r\n// File: contracts/TokenSpender.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n/// @title Opium.TokenSpender contract holds users ERC20 approvals and allows whitelisted contracts to use tokens\r\ncontract TokenSpender is WhitelistedWithGovernanceAndChangableTimelock {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // Initial timelock period\r\n    uint256 public constant WHITELIST_TIMELOCK = 1 hours;\r\n\r\n    /// @notice Calls constructors of super-contracts\r\n    /// @param _governor address Address of governor, who is allowed to adjust whitelist\r\n    constructor(address _governor) public WhitelistedWithGovernance(WHITELIST_TIMELOCK, _governor) {}\r\n\r\n    /// @notice Using this function whitelisted contracts could call ERC20 transfers\r\n    /// @param token IERC20 Instance of token\r\n    /// @param from address Address from which tokens are transferred\r\n    /// @param to address Address of tokens receiver\r\n    /// @param amount uint256 Amount of tokens to be transferred\r\n    function claimTokens(IERC20 token, address from, address to, uint256 amount) external onlyWhitelisted {\r\n        token.safeTransferFrom(from, to, amount);\r\n    }\r\n\r\n    /// @notice Using this function whitelisted contracts could call ERC721O transfers\r\n    /// @param token IERC721O Instance of token\r\n    /// @param from address Address from which tokens are transferred\r\n    /// @param to address Address of tokens receiver\r\n    /// @param tokenId uint256 Token ID to be transferred\r\n    /// @param amount uint256 Amount of tokens to be transferred\r\n    function claimPositions(IERC721O token, address from, address to, uint256 tokenId, uint256 amount) external onlyWhitelisted {\r\n        token.safeTransferFrom(from, to, tokenId, amount);\r\n    }\r\n}\r\n\r\n// File: contracts/Core.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Opium.Core contract creates positions, holds and distributes margin at the maturity\r\ncontract Core is LibDerivative, LibCommission, UsingRegistry, CoreErrors, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    using LibPosition for bytes32;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // Emitted when Core creates new position\r\n    event Created(address buyer, address seller, bytes32 derivativeHash, uint256 quantity);\r\n    // Emitted when Core executes positions\r\n    event Executed(address tokenOwner, uint256 tokenId, uint256 quantity);\r\n    // Emitted when Core cancels ticker for the first time\r\n    event Canceled(bytes32 derivativeHash);\r\n\r\n    // Period of time after which ticker could be canceled if no data was provided to the `oracleId`\r\n    uint256 public constant NO_DATA_CANCELLATION_PERIOD = 2 weeks;\r\n\r\n    // Vaults for pools\r\n    // This mapping holds balances of pooled positions\r\n    // poolVaults[syntheticAddress][tokenAddress] => availableBalance\r\n    mapping (address => mapping(address => uint256)) public poolVaults;\r\n\r\n    // Vaults for fees\r\n    // This mapping holds balances of fee recipients\r\n    // feesVaults[feeRecipientAddress][tokenAddress] => availableBalance\r\n    mapping (address => mapping(address => uint256)) public feesVaults;\r\n\r\n    // Hashes of cancelled tickers\r\n    mapping (bytes32 => bool) public cancelled;\r\n\r\n    /// @notice Calls Core.Lib.UsingRegistry constructor\r\n    constructor(address _registry) public UsingRegistry(_registry) {}\r\n\r\n    // PUBLIC FUNCTIONS\r\n\r\n    /// @notice This function allows fee recipients to withdraw their fees\r\n    /// @param _tokenAddress address Address of an ERC20 token to withdraw\r\n    function withdrawFee(address _tokenAddress) public nonReentrant {\r\n        uint256 balance = feesVaults[msg.sender][_tokenAddress];\r\n        feesVaults[msg.sender][_tokenAddress] = 0;\r\n        IERC20(_tokenAddress).safeTransfer(msg.sender, balance);\r\n    }\r\n\r\n    /// @notice Creates derivative contracts (positions)\r\n    /// @param _derivative Derivative Derivative definition\r\n    /// @param _quantity uint256 Quantity of derivatives to be created\r\n    /// @param _addresses address[2] Addresses of buyer and seller\r\n    /// [0] - buyer address\r\n    /// [1] - seller address - if seller is set to `address(0)`, consider as pooled position\r\n    function create(Derivative memory _derivative, uint256 _quantity, address[2] memory _addresses) public nonReentrant {\r\n        if (_addresses[1] == address(0)) {\r\n            _createPooled(_derivative, _quantity, _addresses[0]);\r\n        } else {\r\n            _create(_derivative, _quantity, _addresses);\r\n        }\r\n    }\r\n\r\n    /// @notice Executes several positions of `msg.sender` with same `tokenId`\r\n    /// @param _tokenId uint256 `tokenId` of positions that needs to be executed\r\n    /// @param _quantity uint256 Quantity of positions to execute\r\n    /// @param _derivative Derivative Derivative definition\r\n    function execute(uint256 _tokenId, uint256 _quantity, Derivative memory _derivative) public nonReentrant {\r\n        uint256[] memory tokenIds = new uint256[](1);\r\n        uint256[] memory quantities = new uint256[](1);\r\n        Derivative[] memory derivatives = new Derivative[](1);\r\n\r\n        tokenIds[0] = _tokenId;\r\n        quantities[0] = _quantity;\r\n        derivatives[0] = _derivative;\r\n\r\n        _execute(msg.sender, tokenIds, quantities, derivatives);\r\n    }\r\n\r\n    /// @notice Executes several positions of `_tokenOwner` with same `tokenId`\r\n    /// @param _tokenOwner address Address of the owner of positions\r\n    /// @param _tokenId uint256 `tokenId` of positions that needs to be executed\r\n    /// @param _quantity uint256 Quantity of positions to execute\r\n    /// @param _derivative Derivative Derivative definition\r\n    function execute(address _tokenOwner, uint256 _tokenId, uint256 _quantity, Derivative memory _derivative) public nonReentrant {\r\n        uint256[] memory tokenIds = new uint256[](1);\r\n        uint256[] memory quantities = new uint256[](1);\r\n        Derivative[] memory derivatives = new Derivative[](1);\r\n\r\n        tokenIds[0] = _tokenId;\r\n        quantities[0] = _quantity;\r\n        derivatives[0] = _derivative;\r\n\r\n        _execute(_tokenOwner, tokenIds, quantities, derivatives);\r\n    }\r\n\r\n    /// @notice Executes several positions of `msg.sender` with different `tokenId`s\r\n    /// @param _tokenIds uint256[] `tokenId`s of positions that needs to be executed\r\n    /// @param _quantities uint256[] Quantity of positions to execute for each `tokenId`\r\n    /// @param _derivatives Derivative[] Derivative definitions for each `tokenId`\r\n    function execute(uint256[] memory _tokenIds, uint256[] memory _quantities, Derivative[] memory _derivatives) public nonReentrant {\r\n        _execute(msg.sender, _tokenIds, _quantities, _derivatives);\r\n    }\r\n\r\n    /// @notice Executes several positions of `_tokenOwner` with different `tokenId`s\r\n    /// @param _tokenOwner address Address of the owner of positions\r\n    /// @param _tokenIds uint256[] `tokenId`s of positions that needs to be executed\r\n    /// @param _quantities uint256[] Quantity of positions to execute for each `tokenId`\r\n    /// @param _derivatives Derivative[] Derivative definitions for each `tokenId`\r\n    function execute(address _tokenOwner, uint256[] memory _tokenIds, uint256[] memory _quantities, Derivative[] memory _derivatives) public nonReentrant {\r\n        _execute(_tokenOwner, _tokenIds, _quantities, _derivatives);\r\n    }\r\n\r\n    /// @notice Cancels tickers, burns positions and returns margins to positions owners in case no data were provided within `NO_DATA_CANCELLATION_PERIOD`\r\n    /// @param _tokenId uint256 `tokenId` of positions that needs to be canceled\r\n    /// @param _quantity uint256 Quantity of positions to cancel\r\n    /// @param _derivative Derivative Derivative definition\r\n    function cancel(uint256 _tokenId, uint256 _quantity, Derivative memory _derivative) public nonReentrant {\r\n        uint256[] memory tokenIds = new uint256[](1);\r\n        uint256[] memory quantities = new uint256[](1);\r\n        Derivative[] memory derivatives = new Derivative[](1);\r\n\r\n        tokenIds[0] = _tokenId;\r\n        quantities[0] = _quantity;\r\n        derivatives[0] = _derivative;\r\n\r\n        _cancel(tokenIds, quantities, derivatives);\r\n    }\r\n\r\n    /// @notice Cancels tickers, burns positions and returns margins to positions owners in case no data were provided within `NO_DATA_CANCELLATION_PERIOD`\r\n    /// @param _tokenIds uint256[] `tokenId` of positions that needs to be canceled\r\n    /// @param _quantities uint256[] Quantity of positions to cancel for each `tokenId`\r\n    /// @param _derivatives Derivative[] Derivative definitions for each `tokenId`\r\n    function cancel(uint256[] memory _tokenIds, uint256[] memory _quantities, Derivative[] memory _derivatives) public nonReentrant {\r\n        _cancel(_tokenIds, _quantities, _derivatives);\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    struct CreatePooledLocalVars {\r\n        SyntheticAggregator syntheticAggregator;\r\n        IDerivativeLogic derivativeLogic;\r\n        IERC20 marginToken;\r\n        TokenSpender tokenSpender;\r\n        TokenMinter tokenMinter;\r\n    }\r\n\r\n    /// @notice This function creates pooled positions\r\n    /// @param _derivative Derivative Derivative definition\r\n    /// @param _quantity uint256 Quantity of positions to create\r\n    /// @param _address address Address of position receiver\r\n    function _createPooled(Derivative memory _derivative, uint256 _quantity, address _address) private {\r\n        // Local variables\r\n        CreatePooledLocalVars memory vars;\r\n\r\n        // Create instance of Opium.SyntheticAggregator\r\n        // Create instance of Opium.IDerivativeLogic\r\n        // Create instance of margin token\r\n        // Create instance of Opium.TokenSpender\r\n        // Create instance of Opium.TokenMinter\r\n        vars.syntheticAggregator = SyntheticAggregator(registry.getSyntheticAggregator());\r\n        vars.derivativeLogic = IDerivativeLogic(_derivative.syntheticId);\r\n        vars.marginToken = IERC20(_derivative.token);\r\n        vars.tokenSpender = TokenSpender(registry.getTokenSpender());\r\n        vars.tokenMinter = TokenMinter(registry.getMinter());\r\n\r\n        // Generate hash for derivative\r\n        bytes32 derivativeHash = getDerivativeHash(_derivative);\r\n\r\n        // Check with Opium.SyntheticAggregator if syntheticId is a pool\r\n        require(vars.syntheticAggregator.isPool(derivativeHash, _derivative), ERROR_CORE_NOT_POOL);\r\n\r\n        // Check if ticker was canceled\r\n        require(!cancelled[derivativeHash], ERROR_CORE_TICKER_WAS_CANCELLED);\r\n\r\n        // Validate input data against Derivative logic (`syntheticId`)\r\n        require(vars.derivativeLogic.validateInput(_derivative), ERROR_CORE_SYNTHETIC_VALIDATION_ERROR);\r\n\r\n        // Get cached margin required according to logic from Opium.SyntheticAggregator\r\n        (uint256 margin, ) = vars.syntheticAggregator.getMargin(derivativeHash, _derivative);\r\n\r\n        // Check ERC20 tokens allowance: margin * quantity\r\n        // `msg.sender` must provide margin for position creation\r\n        require(vars.marginToken.allowance(msg.sender, address(vars.tokenSpender)) >= margin.mul(_quantity), ERROR_CORE_NOT_ENOUGH_TOKEN_ALLOWANCE);\r\n\r\n    \t// Take ERC20 tokens from msg.sender, should never revert in correct ERC20 implementation\r\n        vars.tokenSpender.claimTokens(vars.marginToken, msg.sender, address(this), margin.mul(_quantity));\r\n\r\n        // Since it's a pooled position, we add transferred margin to pool balance\r\n        poolVaults[_derivative.syntheticId][_derivative.token] = poolVaults[_derivative.syntheticId][_derivative.token].add(margin.mul(_quantity));\r\n\r\n        // Mint LONG position tokens\r\n        vars.tokenMinter.mint(_address, derivativeHash, _quantity);\r\n\r\n        emit Created(_address, address(0), derivativeHash, _quantity);\r\n    }\r\n\r\n    struct CreateLocalVars {\r\n        SyntheticAggregator syntheticAggregator;\r\n        IDerivativeLogic derivativeLogic;\r\n        IERC20 marginToken;\r\n        TokenSpender tokenSpender;\r\n        TokenMinter tokenMinter;\r\n    }\r\n\r\n    /// @notice This function creates p2p positions\r\n    /// @param _derivative Derivative Derivative definition\r\n    /// @param _quantity uint256 Quantity of positions to create\r\n    /// @param _addresses address[2] Addresses of buyer and seller\r\n    /// [0] - buyer address\r\n    /// [1] - seller address\r\n    function _create(Derivative memory _derivative, uint256 _quantity, address[2] memory _addresses) private {\r\n        // Local variables\r\n        CreateLocalVars memory vars;\r\n\r\n        // Create instance of Opium.SyntheticAggregator\r\n        // Create instance of Opium.IDerivativeLogic\r\n        // Create instance of margin token\r\n        // Create instance of Opium.TokenSpender\r\n        // Create instance of Opium.TokenMinter\r\n        vars.syntheticAggregator = SyntheticAggregator(registry.getSyntheticAggregator());\r\n        vars.derivativeLogic = IDerivativeLogic(_derivative.syntheticId);\r\n        vars.marginToken = IERC20(_derivative.token);\r\n        vars.tokenSpender = TokenSpender(registry.getTokenSpender());\r\n        vars.tokenMinter = TokenMinter(registry.getMinter());\r\n\r\n        // Generate hash for derivative\r\n        bytes32 derivativeHash = getDerivativeHash(_derivative);\r\n\r\n        // Check with Opium.SyntheticAggregator if syntheticId is not a pool\r\n        require(!vars.syntheticAggregator.isPool(derivativeHash, _derivative), ERROR_CORE_CANT_BE_POOL);\r\n\r\n        // Check if ticker was canceled\r\n        require(!cancelled[derivativeHash], ERROR_CORE_TICKER_WAS_CANCELLED);\r\n\r\n        // Validate input data against Derivative logic (`syntheticId`)\r\n        require(vars.derivativeLogic.validateInput(_derivative), ERROR_CORE_SYNTHETIC_VALIDATION_ERROR);\r\n\r\n        uint256[2] memory margins;\r\n        // Get cached margin required according to logic from Opium.SyntheticAggregator\r\n        // margins[0] - buyerMargin\r\n        // margins[1] - sellerMargin\r\n        (margins[0], margins[1]) = vars.syntheticAggregator.getMargin(derivativeHash, _derivative);\r\n\r\n        // Check ERC20 tokens allowance: (margins[0] + margins[1]) * quantity\r\n        // `msg.sender` must provide margin for position creation\r\n        require(vars.marginToken.allowance(msg.sender, address(vars.tokenSpender)) >= margins[0].add(margins[1]).mul(_quantity), ERROR_CORE_NOT_ENOUGH_TOKEN_ALLOWANCE);\r\n\r\n    \t// Take ERC20 tokens from msg.sender, should never revert in correct ERC20 implementation\r\n        vars.tokenSpender.claimTokens(vars.marginToken, msg.sender, address(this), margins[0].add(margins[1]).mul(_quantity));\r\n\r\n        // Mint LONG and SHORT positions tokens\r\n        vars.tokenMinter.mint(_addresses[0], _addresses[1], derivativeHash, _quantity);\r\n\r\n        emit Created(_addresses[0], _addresses[1], derivativeHash, _quantity);\r\n    }\r\n\r\n    struct ExecuteAndCancelLocalVars {\r\n        TokenMinter tokenMinter;\r\n        OracleAggregator oracleAggregator;\r\n        SyntheticAggregator syntheticAggregator;\r\n    }\r\n\r\n    /// @notice Executes several positions of `_tokenOwner` with different `tokenId`s\r\n    /// @param _tokenOwner address Address of the owner of positions\r\n    /// @param _tokenIds uint256[] `tokenId`s of positions that needs to be executed\r\n    /// @param _quantities uint256[] Quantity of positions to execute for each `tokenId`\r\n    /// @param _derivatives Derivative[] Derivative definitions for each `tokenId`\r\n    function _execute(address _tokenOwner, uint256[] memory _tokenIds, uint256[] memory _quantities, Derivative[] memory _derivatives) private {\r\n        require(_tokenIds.length == _quantities.length, ERROR_CORE_TOKEN_IDS_AND_QUANTITIES_LENGTH_DOES_NOT_MATCH);\r\n        require(_tokenIds.length == _derivatives.length, ERROR_CORE_TOKEN_IDS_AND_DERIVATIVES_LENGTH_DOES_NOT_MATCH);\r\n\r\n        // Local variables\r\n        ExecuteAndCancelLocalVars memory vars;\r\n\r\n        // Create instance of Opium.TokenMinter\r\n        // Create instance of Opium.OracleAggregator\r\n        // Create instance of Opium.SyntheticAggregator\r\n        vars.tokenMinter = TokenMinter(registry.getMinter());\r\n        vars.oracleAggregator = OracleAggregator(registry.getOracleAggregator());\r\n        vars.syntheticAggregator = SyntheticAggregator(registry.getSyntheticAggregator());\r\n\r\n        for (uint256 i; i < _tokenIds.length; i++) {\r\n            // Check if execution is performed after endTime\r\n            require(now > _derivatives[i].endTime, ERROR_CORE_EXECUTION_BEFORE_MATURITY_NOT_ALLOWED);\r\n\r\n            // Checking whether execution is performed by `_tokenOwner` or `_tokenOwner` allowed third party executions on it's behalf\r\n            require(\r\n                _tokenOwner == msg.sender ||\r\n                IDerivativeLogic(_derivatives[i].syntheticId).thirdpartyExecutionAllowed(_tokenOwner),\r\n                ERROR_CORE_SYNTHETIC_EXECUTION_WAS_NOT_ALLOWED\r\n            );\r\n\r\n            // Returns payout for all positions\r\n            uint256 payout = _getPayout(_derivatives[i], _tokenIds[i], _quantities[i], vars);\r\n\r\n            // Transfer payout\r\n            if (payout > 0) {\r\n                IERC20(_derivatives[i].token).safeTransfer(_tokenOwner, payout);\r\n            }\r\n\r\n            // Burn executed position tokens\r\n            vars.tokenMinter.burn(_tokenOwner, _tokenIds[i], _quantities[i]);\r\n\r\n            emit Executed(_tokenOwner, _tokenIds[i], _quantities[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice Cancels tickers, burns positions and returns margins to positions owners in case no data were provided within `NO_DATA_CANCELLATION_PERIOD`\r\n    /// @param _tokenIds uint256[] `tokenId` of positions that needs to be canceled\r\n    /// @param _quantities uint256[] Quantity of positions to cancel for each `tokenId`\r\n    /// @param _derivatives Derivative[] Derivative definitions for each `tokenId`\r\n    function _cancel(uint256[] memory _tokenIds, uint256[] memory _quantities, Derivative[] memory _derivatives) private {\r\n        require(_tokenIds.length == _quantities.length, ERROR_CORE_TOKEN_IDS_AND_QUANTITIES_LENGTH_DOES_NOT_MATCH);\r\n        require(_tokenIds.length == _derivatives.length, ERROR_CORE_TOKEN_IDS_AND_DERIVATIVES_LENGTH_DOES_NOT_MATCH);\r\n\r\n        // Local variables\r\n        ExecuteAndCancelLocalVars memory vars;\r\n\r\n        // Create instance of Opium.TokenMinter\r\n        // Create instance of Opium.OracleAggregator\r\n        // Create instance of Opium.SyntheticAggregator\r\n        vars.tokenMinter = TokenMinter(registry.getMinter());\r\n        vars.oracleAggregator = OracleAggregator(registry.getOracleAggregator());\r\n        vars.syntheticAggregator = SyntheticAggregator(registry.getSyntheticAggregator());\r\n\r\n        for (uint256 i; i < _tokenIds.length; i++) {\r\n            // Don't allow to cancel tickers with \"dummy\" oracleIds\r\n            require(_derivatives[i].oracleId != address(0), ERROR_CORE_CANT_CANCEL_DUMMY_ORACLE_ID);\r\n\r\n            // Check if cancellation is called after `NO_DATA_CANCELLATION_PERIOD` and `oracleId` didn't provided data\r\n            require(\r\n                _derivatives[i].endTime + NO_DATA_CANCELLATION_PERIOD <= now &&\r\n                !vars.oracleAggregator.hasData(_derivatives[i].oracleId, _derivatives[i].endTime),\r\n                ERROR_CORE_CANCELLATION_IS_NOT_ALLOWED\r\n            );\r\n\r\n            // Generate hash for derivative\r\n            bytes32 derivativeHash = getDerivativeHash(_derivatives[i]);\r\n\r\n            // Emit `Canceled` event only once and mark ticker as canceled\r\n            if (!cancelled[derivativeHash]) {\r\n                cancelled[derivativeHash] = true;\r\n                emit Canceled(derivativeHash);\r\n            }\r\n\r\n            uint256[2] memory margins;\r\n            // Get cached margin required according to logic from Opium.SyntheticAggregator\r\n            // margins[0] - buyerMargin\r\n            // margins[1] - sellerMargin\r\n            (margins[0], margins[1]) = vars.syntheticAggregator.getMargin(derivativeHash, _derivatives[i]);\r\n\r\n            uint256 payout;\r\n            // Check if `_tokenId` is an ID of LONG position\r\n            if (derivativeHash.getLongTokenId() == _tokenIds[i]) {\r\n                // Set payout to buyerPayout\r\n                payout = margins[0];\r\n\r\n            // Check if `_tokenId` is an ID of SHORT position\r\n            } else if (derivativeHash.getShortTokenId() == _tokenIds[i]) {\r\n                // Set payout to sellerPayout\r\n                payout = margins[1];\r\n            } else {\r\n                // Either portfolioId, hack or bug\r\n                revert(ERROR_CORE_UNKNOWN_POSITION_TYPE);\r\n            }\r\n\r\n            // Transfer payout * _quantities[i]\r\n            if (payout > 0) {\r\n                IERC20(_derivatives[i].token).safeTransfer(msg.sender, payout.mul(_quantities[i]));\r\n            }\r\n\r\n            // Burn canceled position tokens\r\n            vars.tokenMinter.burn(msg.sender, _tokenIds[i], _quantities[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates payout for position and gets fees\r\n    /// @param _derivative Derivative Derivative definition\r\n    /// @param _tokenId uint256 `tokenId` of positions\r\n    /// @param _quantity uint256 Quantity of positions\r\n    /// @param _vars ExecuteAndCancelLocalVars Helping local variables\r\n    /// @return payout uint256 Payout for all tokens\r\n    function _getPayout(Derivative memory _derivative, uint256 _tokenId, uint256 _quantity, ExecuteAndCancelLocalVars memory _vars) private returns (uint256 payout) {\r\n        // Trying to getData from Opium.OracleAggregator, could be reverted\r\n        // Opium allows to use \"dummy\" oracleIds, in this case data is set to `0`\r\n        uint256 data;\r\n        if (_derivative.oracleId != address(0)) {\r\n            data = _vars.oracleAggregator.getData(_derivative.oracleId, _derivative.endTime);\r\n        } else {\r\n            data = 0;\r\n        }\r\n\r\n        uint256[2] memory payoutRatio;\r\n        // Get payout ratio from Derivative logic\r\n        // payoutRatio[0] - buyerPayout\r\n        // payoutRatio[1] - sellerPayout\r\n        (payoutRatio[0], payoutRatio[1]) = IDerivativeLogic(_derivative.syntheticId).getExecutionPayout(_derivative, data);\r\n\r\n        // Generate hash for derivative\r\n        bytes32 derivativeHash = getDerivativeHash(_derivative);\r\n\r\n        // Check if ticker was canceled\r\n        require(!cancelled[derivativeHash], ERROR_CORE_TICKER_WAS_CANCELLED);\r\n\r\n        uint256[2] memory margins;\r\n        // Get cached total margin required from Opium.SyntheticAggregator\r\n        // margins[0] - buyerMargin\r\n        // margins[1] - sellerMargin\r\n        (margins[0], margins[1]) = _vars.syntheticAggregator.getMargin(derivativeHash, _derivative);\r\n\r\n        uint256[2] memory payouts;\r\n        // Calculate payouts from ratio\r\n        // payouts[0] -> buyerPayout = (buyerMargin + sellerMargin) * buyerPayoutRatio / (buyerPayoutRatio + sellerPayoutRatio)\r\n        // payouts[1] -> sellerPayout = (buyerMargin + sellerMargin) * sellerPayoutRatio / (buyerPayoutRatio + sellerPayoutRatio)\r\n        payouts[0] = margins[0].add(margins[1]).mul(payoutRatio[0]).div(payoutRatio[0].add(payoutRatio[1]));\r\n        payouts[1] = margins[0].add(margins[1]).mul(payoutRatio[1]).div(payoutRatio[0].add(payoutRatio[1]));\r\n\r\n        // Check if `_tokenId` is an ID of LONG position\r\n        if (derivativeHash.getLongTokenId() == _tokenId) {\r\n            // Check if it's a pooled position\r\n            if (_vars.syntheticAggregator.isPool(derivativeHash, _derivative)) {\r\n                // Pooled position payoutRatio is considered as full payout, not as payoutRatio\r\n                payout = payoutRatio[0];\r\n\r\n                // Multiply payout by quantity\r\n                payout = payout.mul(_quantity);\r\n\r\n                // Check sufficiency of syntheticId balance in poolVaults\r\n                require(\r\n                    poolVaults[_derivative.syntheticId][_derivative.token] >= payout\r\n                    ,\r\n                    ERROR_CORE_INSUFFICIENT_POOL_BALANCE\r\n                );\r\n\r\n                // Subtract paid out margin from poolVault\r\n                poolVaults[_derivative.syntheticId][_derivative.token] = poolVaults[_derivative.syntheticId][_derivative.token].sub(payout);\r\n            } else {\r\n                // Set payout to buyerPayout\r\n                payout = payouts[0];\r\n\r\n                // Multiply payout by quantity\r\n                payout = payout.mul(_quantity);\r\n            }\r\n\r\n            // Take fees only from profit makers\r\n            // Check: payout > buyerMargin * quantity\r\n            if (payout > margins[0].mul(_quantity)) {\r\n                // Get Opium and `syntheticId` author fees and subtract it from payout\r\n                payout = payout.sub(_getFees(_vars.syntheticAggregator, derivativeHash, _derivative, payout - margins[0].mul(_quantity)));\r\n            }\r\n\r\n        // Check if `_tokenId` is an ID of SHORT position\r\n        } else if (derivativeHash.getShortTokenId() == _tokenId) {\r\n            // Set payout to sellerPayout\r\n            payout = payouts[1];\r\n\r\n            // Multiply payout by quantity\r\n            payout = payout.mul(_quantity);\r\n\r\n            // Take fees only from profit makers\r\n            // Check: payout > sellerMargin * quantity\r\n            if (payout > margins[1].mul(_quantity)) {\r\n                // Get Opium fees and subtract it from payout\r\n                payout = payout.sub(_getFees(_vars.syntheticAggregator, derivativeHash, _derivative, payout - margins[1].mul(_quantity)));\r\n            }\r\n        } else {\r\n            // Either portfolioId, hack or bug\r\n            revert(ERROR_CORE_UNKNOWN_POSITION_TYPE);\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates `syntheticId` author and opium fees from profit makers\r\n    /// @param _syntheticAggregator SyntheticAggregator Instance of Opium.SyntheticAggregator\r\n    /// @param _derivativeHash bytes32 Derivative hash\r\n    /// @param _derivative Derivative Derivative definition\r\n    /// @param _profit uint256 payout of one position\r\n    /// @return fee uint256 Opium and `syntheticId` author fee\r\n    function _getFees(SyntheticAggregator _syntheticAggregator, bytes32 _derivativeHash, Derivative memory _derivative, uint256 _profit) private returns (uint256 fee) {\r\n        // Get cached `syntheticId` author address from Opium.SyntheticAggregator\r\n        address authorAddress = _syntheticAggregator.getAuthorAddress(_derivativeHash, _derivative);\r\n        // Get cached `syntheticId` fee percentage from Opium.SyntheticAggregator\r\n        uint256 commission = _syntheticAggregator.getAuthorCommission(_derivativeHash, _derivative);\r\n\r\n        // Calculate fee\r\n        // fee = profit * commission / COMMISSION_BASE\r\n        fee = _profit.mul(commission).div(COMMISSION_BASE);\r\n\r\n        // If commission is zero, finish\r\n        if (fee == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // Calculate opium fee\r\n        // opiumFee = fee * OPIUM_COMMISSION_PART / OPIUM_COMMISSION_BASE\r\n        uint256 opiumFee = fee.mul(OPIUM_COMMISSION_PART).div(OPIUM_COMMISSION_BASE);\r\n\r\n        // Calculate author fee\r\n        // authorFee = fee - opiumFee\r\n        uint256 authorFee = fee.sub(opiumFee);\r\n\r\n        // Get opium address\r\n        address opiumAddress = registry.getOpiumAddress();\r\n\r\n        // Update feeVault for Opium team\r\n        // feesVault[opium][token] += opiumFee\r\n        feesVaults[opiumAddress][_derivative.token] = feesVaults[opiumAddress][_derivative.token].add(opiumFee);\r\n\r\n        // Update feeVault for `syntheticId` author\r\n        // feeVault[author][token] += authorFee\r\n        feesVaults[authorAddress][_derivative.token] = feesVaults[authorAddress][_derivative.token].add(authorFee);\r\n    }\r\n}\r\n\r\n// File: contracts/Errors/MatchingErrors.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ncontract MatchingErrors {\r\n    string constant internal ERROR_MATCH_CANCELLATION_NOT_ALLOWED = \"MATCH:CANCELLATION_NOT_ALLOWED\";\r\n    string constant internal ERROR_MATCH_ALREADY_CANCELED = \"MATCH:ALREADY_CANCELED\";\r\n    string constant internal ERROR_MATCH_ORDER_WAS_CANCELED = \"MATCH:ORDER_WAS_CANCELED\";\r\n\r\n    string constant internal ERROR_MATCH_TAKER_ADDRESS_WRONG = \"MATCH:TAKER_ADDRESS_WRONG\";\r\n    string constant internal ERROR_MATCH_ORDER_IS_EXPIRED = \"MATCH:ORDER_IS_EXPIRED\";\r\n    string constant internal ERROR_MATCH_SENDER_ADDRESS_WRONG = \"MATCH:SENDER_ADDRESS_WRONG\";\r\n    string constant internal ERROR_MATCH_SIGNATURE_NOT_VERIFIED = \"MATCH:SIGNATURE_NOT_VERIFIED\";\r\n    string constant internal ERROR_MATCH_NOT_ENOUGH_ALLOWED_FEES = \"MATCH:NOT_ENOUGH_ALLOWED_FEES\";\r\n}\r\n\r\n// File: contracts/Lib/LibEIP712.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n/// @title Opium.Lib.LibEIP712 contract implements the domain of EIP712 for meta transactions\r\ncontract LibEIP712 {\r\n    // EIP712Domain structure\r\n    // name - protocol name\r\n    // version - protocol version\r\n    // verifyingContract - signed message verifying contract\r\n    struct EIP712Domain {\r\n        string  name;\r\n        string  version;\r\n        address verifyingContract;\r\n    }\r\n\r\n    // Calculate typehash of ERC712Domain\r\n    bytes32 constant internal EIP712DOMAIN_TYPEHASH = keccak256(abi.encodePacked(\r\n        \"EIP712Domain(\",\r\n        \"string name,\",\r\n        \"string version,\",\r\n        \"address verifyingContract\",\r\n        \")\"\r\n    ));\r\n\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    bytes32 internal DOMAIN_SEPARATOR;\r\n\r\n    // Calculate domain separator at creation\r\n    constructor () public {\r\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n            EIP712DOMAIN_TYPEHASH,\r\n            keccak256(\"Opium Network\"),\r\n            keccak256(\"1\"),\r\n            address(this)\r\n        ));\r\n    }\r\n\r\n    /// @notice Hashes EIP712Message\r\n    /// @param hashStruct bytes32 Hash of structured message\r\n    /// @return result bytes32 Hash of EIP712Message\r\n    function hashEIP712Message(bytes32 hashStruct) internal view returns (bytes32 result) {\r\n        bytes32 domainSeparator = DOMAIN_SEPARATOR;\r\n\r\n        assembly {\r\n            // Load free memory pointer\r\n            let memPtr := mload(64)\r\n\r\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\r\n            mstore(add(memPtr, 2), domainSeparator)                                            // EIP712 domain hash\r\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\r\n\r\n            // Compute hash\r\n            result := keccak256(memPtr, 66)\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n// File: contracts/Matching/SwaprateMatch/LibSwaprateOrder.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n/// @title Opium.Matching.SwaprateMatch.LibSwaprateOrder contract implements EIP712 signed SwaprateOrder for Opium.Matching.SwaprateMatch\r\ncontract LibSwaprateOrder is LibEIP712 {\r\n    /**\r\n        Structure of order\r\n        Description should be considered from the order signer (maker) perspective\r\n\r\n        syntheticId - address of derivative syntheticId\r\n        oracleId - address of derivative oracleId\r\n        token - address of derivative margin token\r\n\r\n        makerMarginAddress - address of token that maker is willing to pay with\r\n        takerMarginAddress - address of token that maker is willing to receive\r\n\r\n        makerAddress - address of maker\r\n        takerAddress - address of counterparty (taker). If zero address, then taker could be anyone\r\n\r\n        senderAddress - address which is allowed to settle the order on-chain. If zero address, then anyone could settle\r\n\r\n        relayerAddress - address of the relayer fee recipient\r\n        affiliateAddress - address of the affiliate fee recipient\r\n\r\n        feeTokenAddress - address of token which is used for fees\r\n\r\n        endTime - timestamp of derivative maturity\r\n\r\n        quantity - quantity of positions maker wants to receive\r\n        partialFill - whether maker allows partial fill of it's order\r\n\r\n        param0...param9 - additional params to pass it to syntheticId\r\n\r\n        relayerFee - amount of fee in feeToken that should be paid to relayer\r\n        affiliateFee - amount of fee in feeToken that should be paid to affiliate\r\n\r\n        nonce - unique order ID\r\n\r\n        signature - Signature of EIP712 message. Not used in hash, but then set for order processing purposes\r\n\r\n     */\r\n    struct SwaprateOrder {\r\n        address syntheticId;\r\n        address oracleId;\r\n        address token;\r\n\r\n        address makerAddress;\r\n        address takerAddress;\r\n\r\n        address senderAddress;\r\n\r\n        address relayerAddress;\r\n        address affiliateAddress;\r\n\r\n        address feeTokenAddress;\r\n\r\n        uint256 endTime;\r\n\r\n        uint256 quantity;\r\n        uint256 partialFill;\r\n\r\n        uint256 param0;\r\n        uint256 param1;\r\n        uint256 param2;\r\n        uint256 param3;\r\n        uint256 param4;\r\n        uint256 param5;\r\n        uint256 param6;\r\n        uint256 param7;\r\n        uint256 param8;\r\n        uint256 param9;\r\n\r\n        uint256 relayerFee;\r\n        uint256 affiliateFee;\r\n\r\n        uint256 nonce;\r\n\r\n        // Not used in hash\r\n        bytes signature;\r\n    }\r\n\r\n    // Calculate typehash of Order\r\n    bytes32 constant internal EIP712_ORDER_TYPEHASH = keccak256(abi.encodePacked(\r\n        \"Order(\",\r\n        \"address syntheticId,\",\r\n        \"address oracleId,\",\r\n        \"address token,\",\r\n\r\n        \"address makerAddress,\",\r\n        \"address takerAddress,\",\r\n\r\n        \"address senderAddress,\",\r\n\r\n        \"address relayerAddress,\",\r\n        \"address affiliateAddress,\",\r\n\r\n        \"address feeTokenAddress,\",\r\n\r\n        \"uint256 endTime,\",\r\n\r\n        \"uint256 quantity,\",\r\n        \"uint256 partialFill,\",\r\n\r\n        \"uint256 param0,\",\r\n        \"uint256 param1,\",\r\n        \"uint256 param2,\",\r\n        \"uint256 param3,\",\r\n        \"uint256 param4,\",\r\n        \"uint256 param5,\",\r\n        \"uint256 param6,\",\r\n        \"uint256 param7,\",\r\n        \"uint256 param8,\",\r\n        \"uint256 param9,\",\r\n\r\n        \"uint256 relayerFee,\",\r\n        \"uint256 affiliateFee,\",\r\n\r\n        \"uint256 nonce\",\r\n        \")\"\r\n    ));\r\n\r\n    /// @notice Hashes the order\r\n    /// @param _order SwaprateOrder Order to hash\r\n    /// @return hash bytes32 Order hash\r\n    function hashOrder(SwaprateOrder memory _order) public pure returns (bytes32 hash) {\r\n        hash = keccak256(\r\n            abi.encodePacked(\r\n                abi.encodePacked(\r\n                    EIP712_ORDER_TYPEHASH,\r\n                    uint256(_order.syntheticId),\r\n                    uint256(_order.oracleId),\r\n                    uint256(_order.token),\r\n\r\n                    uint256(_order.makerAddress),\r\n                    uint256(_order.takerAddress),\r\n\r\n                    uint256(_order.senderAddress),\r\n\r\n                    uint256(_order.relayerAddress),\r\n                    uint256(_order.affiliateAddress),\r\n\r\n                    uint256(_order.feeTokenAddress)\r\n                ),\r\n                abi.encodePacked(\r\n                    _order.endTime,\r\n                    _order.quantity,\r\n                    _order.partialFill\r\n                ),\r\n                abi.encodePacked(\r\n                    _order.param0,\r\n                    _order.param1,\r\n                    _order.param2,\r\n                    _order.param3,\r\n                    _order.param4\r\n                ),\r\n                abi.encodePacked(\r\n                    _order.param5,\r\n                    _order.param6,\r\n                    _order.param7,\r\n                    _order.param8,\r\n                    _order.param9\r\n                ),\r\n                abi.encodePacked(\r\n                    _order.relayerFee,\r\n                    _order.affiliateFee,\r\n\r\n                    _order.nonce\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    /// @notice Verifies order signature\r\n    /// @param _hash bytes32 Hash of the order\r\n    /// @param _signature bytes Signature of the order\r\n    /// @param _address address Address of the order signer\r\n    /// @return bool Returns whether `_signature` is valid and was created by `_address`\r\n    function verifySignature(bytes32 _hash, bytes memory _signature, address _address) internal view returns (bool) {\r\n        require(_signature.length == 65, \"ORDER:INVALID_SIGNATURE_LENGTH\");\r\n\r\n        bytes32 digest = hashEIP712Message(_hash);\r\n        address recovered = retrieveAddress(digest, _signature);\r\n        return _address == recovered;\r\n    }\r\n\r\n    /// @notice Helping function to recover signer address\r\n    /// @param _hash bytes32 Hash for signature\r\n    /// @param _signature bytes Signature\r\n    /// @return address Returns address of signature creator\r\n    function retrieveAddress(bytes32 _hash, bytes memory _signature) private pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // Divide the signature in r, s and v variables\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            r := mload(add(_signature, 32))\r\n            s := mload(add(_signature, 64))\r\n            v := byte(0, mload(add(_signature, 96)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            // solium-disable-next-line arg-overflow\r\n            return ecrecover(_hash, v, r, s);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Matching/SwaprateMatch/SwaprateMatchBase.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Opium.Matching.SwaprateMatchBase contract implements logic for order validation and cancelation\r\ncontract SwaprateMatchBase is MatchingErrors, LibSwaprateOrder, UsingRegistry, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    using LibPosition for bytes32;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // Emmitted when order was canceled\r\n    event Canceled(bytes32 orderHash);\r\n\r\n    // Canceled orders\r\n    // This mapping holds hashes of canceled orders\r\n    // canceled[orderHash] => canceled\r\n    mapping (bytes32 => bool) public canceled;\r\n\r\n    // Verified orders\r\n    // This mapping holds hashes of verified orders to verify only once\r\n    // verified[orderHash] => verified\r\n    mapping (bytes32 => bool) public verified;\r\n\r\n    // Vaults for fees\r\n    // This mapping holds balances of relayers and affiliates fees to withdraw\r\n    // balances[feeRecipientAddress][tokenAddress] => balances\r\n    mapping (address => mapping (address => uint256)) public balances;\r\n\r\n    // Keeps whether fee was already taken\r\n    mapping (bytes32 => bool) public feeTaken;\r\n\r\n    /// @notice Calling this function maker of the order could cancel it on-chain\r\n    /// @param _order SwaprateOrder\r\n    function cancel(SwaprateOrder memory _order) public {\r\n        require(msg.sender == _order.makerAddress, ERROR_MATCH_CANCELLATION_NOT_ALLOWED);\r\n        bytes32 orderHash = hashOrder(_order);\r\n        require(!canceled[orderHash], ERROR_MATCH_ALREADY_CANCELED);\r\n        canceled[orderHash] = true;\r\n\r\n        emit Canceled(orderHash);\r\n    }\r\n\r\n    /// @notice Function to withdraw fees from orders for relayer and affiliates\r\n    /// @param _token IERC20 Instance of token to withdraw\r\n    function withdraw(IERC20 _token) public nonReentrant {\r\n        uint256 balance = balances[msg.sender][address(_token)];\r\n        balances[msg.sender][address(_token)] = 0;\r\n        _token.safeTransfer(msg.sender, balance);\r\n    }\r\n\r\n    /// @notice This function checks whether order was canceled\r\n    /// @param _hash bytes32 Hash of the order\r\n    function validateNotCanceled(bytes32 _hash) internal view {\r\n        require(!canceled[_hash], ERROR_MATCH_ORDER_WAS_CANCELED);\r\n    }\r\n\r\n    /// @notice This function validates takerAddress of _leftOrder. It should match either with _rightOrder.makerAddress or be set to zero address\r\n    /// @param _leftOrder SwaprateOrder Left order\r\n    /// @param _rightOrder SwaprateOrder Right order\r\n    function validateTakerAddress(SwaprateOrder memory _leftOrder, SwaprateOrder memory _rightOrder) pure internal {\r\n        require(\r\n            _leftOrder.takerAddress == address(0) ||\r\n            _leftOrder.takerAddress == _rightOrder.makerAddress,\r\n            ERROR_MATCH_TAKER_ADDRESS_WRONG\r\n        );\r\n    }\r\n\r\n    /// @notice This function validates whether sender address equals to `msg.sender` or set to zero address\r\n    /// @param _order SwaprateOrder\r\n    function validateSenderAddress(SwaprateOrder memory _order) internal view {\r\n        require(\r\n            _order.senderAddress == address(0) ||\r\n            _order.senderAddress == msg.sender,\r\n            ERROR_MATCH_SENDER_ADDRESS_WRONG\r\n        );\r\n    }\r\n\r\n    /// @notice This function validates order signature if not validated before\r\n    /// @param orderHash bytes32 Hash of the order\r\n    /// @param _order SwaprateOrder\r\n    function validateSignature(bytes32 orderHash, SwaprateOrder memory _order) internal {\r\n        if (verified[orderHash]) {\r\n            return;\r\n        }\r\n\r\n        bool result = verifySignature(orderHash, _order.signature, _order.makerAddress);\r\n\r\n        require(result, ERROR_MATCH_SIGNATURE_NOT_VERIFIED);\r\n\r\n        verified[orderHash] = true;\r\n    }\r\n\r\n    /// @notice This function is responsible for taking relayer and affiliate fees, if they were not taken already\r\n    /// @param _orderHash bytes32 Hash of the order\r\n    /// @param _order Order Order itself\r\n    function takeFees(bytes32 _orderHash, SwaprateOrder memory _order) internal {\r\n        // Check if fee was already taken\r\n        if (feeTaken[_orderHash]) {\r\n            return;\r\n        }\r\n\r\n        // Check if feeTokenAddress is not set to zero address\r\n        if (_order.feeTokenAddress == address(0)) {\r\n            return;\r\n        }\r\n\r\n        // Calculate total amount of fees needs to be transfered\r\n        uint256 fees = _order.relayerFee.add(_order.affiliateFee);\r\n\r\n        // If total amount of fees is non-zero\r\n        if (fees == 0) {\r\n            return;\r\n        }\r\n\r\n        // Create instance of fee token\r\n        IERC20 feeToken = IERC20(_order.feeTokenAddress);\r\n\r\n        // Create instance of TokenSpender\r\n        TokenSpender tokenSpender = TokenSpender(registry.getTokenSpender());\r\n\r\n        // Check if user has enough token approval to pay the fees\r\n        require(feeToken.allowance(_order.makerAddress, address(tokenSpender)) >= fees, ERROR_MATCH_NOT_ENOUGH_ALLOWED_FEES);\r\n        // Transfer fee\r\n        tokenSpender.claimTokens(feeToken, _order.makerAddress, address(this), fees);\r\n\r\n        // Get opium address\r\n        address opiumAddress = registry.getOpiumAddress();\r\n\r\n        // Add commission to relayer balance, or to opium balance if relayer is not set\r\n        if (_order.relayerAddress != address(0)) {\r\n            balances[_order.relayerAddress][_order.feeTokenAddress] = balances[_order.relayerAddress][_order.feeTokenAddress].add(_order.relayerFee);\r\n        } else {\r\n            balances[opiumAddress][_order.feeTokenAddress] = balances[opiumAddress][_order.feeTokenAddress].add(_order.relayerFee);\r\n        }\r\n\r\n        // Add commission to affiliate balance, or to opium balance if affiliate is not set\r\n        if (_order.affiliateAddress != address(0)) {\r\n            balances[_order.affiliateAddress][_order.feeTokenAddress] = balances[_order.affiliateAddress][_order.feeTokenAddress].add(_order.affiliateFee);\r\n        } else {\r\n            balances[opiumAddress][_order.feeTokenAddress] = balances[opiumAddress][_order.feeTokenAddress].add(_order.affiliateFee);\r\n        }\r\n\r\n        // Mark the fee of token as taken\r\n        feeTaken[_orderHash] = true;\r\n    }\r\n\r\n    /// @notice Helper to get minimal of two integers\r\n    /// @param _a uint256 First integer\r\n    /// @param _b uint256 Second integer\r\n    /// @return uint256 Minimal integer\r\n    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        return _a < _b ? _a : _b;\r\n    }\r\n}\r\n\r\n// File: contracts/Matching/SwaprateMatch/SwaprateMatch.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n/// @title Opium.Matching.SwaprateMatch contract implements create() function to settle a pair of orders and create derivatives for order makers\r\ncontract SwaprateMatch is SwaprateMatchBase, LibDerivative {\r\n\r\n    // Orders filled quantity\r\n    // This mapping holds orders filled quantity\r\n    // filled[orderHash] => filled\r\n    mapping (bytes32 => uint256) public filled;\r\n\r\n    /// @notice Calls constructors of super-contracts\r\n    /// @param _registry address Address of Opium.registry\r\n    constructor (address _registry) public UsingRegistry(_registry) {}\r\n\r\n    /// @notice This function receives left and right orders, derivative related to it\r\n    /// @param _leftOrder Order\r\n    /// @param _rightOrder Order\r\n    /// @param _derivative Derivative Data of derivative for validation and calculation purposes\r\n    function create(SwaprateOrder memory _leftOrder, SwaprateOrder memory _rightOrder, Derivative memory _derivative) public nonReentrant {\r\n        // New deals must not offer tokenIds\r\n        require(\r\n            _leftOrder.syntheticId == _rightOrder.syntheticId,\r\n            \"MATCH:NOT_CREATION\"\r\n        );\r\n\r\n        // Check if it's not pool\r\n        require(!IDerivativeLogic(_derivative.syntheticId).isPool(), \"MATCH:CANT_BE_POOL\");\r\n\r\n        // Validate taker if set\r\n        validateTakerAddress(_leftOrder, _rightOrder);\r\n        validateTakerAddress(_rightOrder, _leftOrder);\r\n\r\n        // Validate sender if set\r\n        validateSenderAddress(_leftOrder);\r\n        validateSenderAddress(_rightOrder);\r\n\r\n        // Validate if was canceled\r\n        // orderHashes[0] - leftOrderHash\r\n        // orderHashes[1] - rightOrderHash\r\n        bytes32[2] memory orderHashes;\r\n        orderHashes[0] = hashOrder(_leftOrder);\r\n        validateNotCanceled(orderHashes[0]);\r\n        validateSignature(orderHashes[0], _leftOrder);\r\n\r\n        orderHashes[1] = hashOrder(_rightOrder);\r\n        validateNotCanceled(orderHashes[1]);\r\n        validateSignature(orderHashes[1], _rightOrder);\r\n\r\n        // Calculate derivative hash and get margin\r\n        // margins[0] - leftMargin\r\n        // margins[1] - rightMargin\r\n        (uint256[2] memory margins, ) = _calculateDerivativeAndGetMargin(_derivative);\r\n\r\n        // Calculate and validate availabilities of orders and fill them\r\n        uint256 fillable = _checkFillability(orderHashes[0], _leftOrder, orderHashes[1], _rightOrder);\r\n\r\n        // Validate derivative parameters with orders\r\n        _verifyDerivative(_leftOrder, _rightOrder, _derivative);\r\n\r\n        // Take fees\r\n        takeFees(orderHashes[0], _leftOrder);\r\n        takeFees(orderHashes[1], _rightOrder);\r\n\r\n        // Send margin to Core\r\n        _distributeFunds(_leftOrder, _rightOrder, _derivative, margins, fillable);\r\n\r\n        // Settle contracts\r\n        Core(registry.getCore()).create(_derivative, fillable, [_leftOrder.makerAddress, _rightOrder.makerAddress]);\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @notice Calculates derivative hash and gets margin\r\n    /// @param _derivative Derivative\r\n    /// @return margins uint256[2] left and right margin\r\n    /// @return derivativeHash bytes32 Hash of the derivative\r\n    function _calculateDerivativeAndGetMargin(Derivative memory _derivative) private returns (uint256[2] memory margins, bytes32 derivativeHash) {\r\n        // Calculate derivative related data for validation\r\n        derivativeHash = getDerivativeHash(_derivative);\r\n\r\n        // Get cached total margin required according to logic\r\n        // margins[0] - leftMargin\r\n        // margins[1] - rightMargin\r\n        (margins[0], margins[1]) = SyntheticAggregator(registry.getSyntheticAggregator()).getMargin(derivativeHash, _derivative);\r\n    }\r\n\r\n    /// @notice Calculate and validate availabilities of orders and fill them\r\n    /// @param _leftOrderHash bytes32\r\n    /// @param _leftOrder SwaprateOrder\r\n    /// @param _rightOrderHash bytes32\r\n    /// @param _rightOrder SwaprateOrder\r\n    /// @return fillable uint256\r\n    function _checkFillability(bytes32 _leftOrderHash, SwaprateOrder memory _leftOrder, bytes32 _rightOrderHash, SwaprateOrder memory _rightOrder) private returns (uint256 fillable) {\r\n        // Calculate availabilities of orders\r\n        uint256 leftAvailable = _leftOrder.quantity.sub(filled[_leftOrderHash]);\r\n        uint256 rightAvailable = _rightOrder.quantity.sub(filled[_rightOrderHash]);\r\n\r\n        require(leftAvailable != 0 && rightAvailable !=0, \"MATCH:NO_AVAILABLE\");\r\n\r\n        // We could only fill minimum available of both counterparties\r\n        fillable = min(leftAvailable, rightAvailable);\r\n\r\n        // Check fillable with order conditions about partial fill requirements\r\n        if (_leftOrder.partialFill == 0 && _rightOrder.partialFill == 0) {\r\n            require(_leftOrder.quantity == _rightOrder.quantity, \"MATCH:FULL_FILL_NOT_POSSIBLE\");\r\n        } else if (_leftOrder.partialFill == 0 && _rightOrder.partialFill == 1) {\r\n            require(_leftOrder.quantity <= rightAvailable, \"MATCH:FULL_FILL_NOT_POSSIBLE\");\r\n        } else if (_leftOrder.partialFill == 1 && _rightOrder.partialFill == 0) {\r\n            require(leftAvailable >= _rightOrder.quantity, \"MATCH:FULL_FILL_NOT_POSSIBLE\");\r\n        }\r\n\r\n        // Update filled\r\n        filled[_leftOrderHash] = filled[_leftOrderHash].add(fillable);\r\n        filled[_rightOrderHash] = filled[_rightOrderHash].add(fillable);\r\n    }\r\n\r\n    /// @notice Validate derivative parameters with orders\r\n    /// @param _leftOrder SwaprateOrder\r\n    /// @param _rightOrder SwaprateOrder\r\n    /// @param _derivative Derivative\r\n    function _verifyDerivative(SwaprateOrder memory _leftOrder, SwaprateOrder memory _rightOrder, Derivative memory _derivative) private pure {\r\n        string memory orderError = \"MATCH:DERIVATIVE_PARAM_IS_WRONG\";\r\n\r\n        // Validate derivative endTime\r\n        require(\r\n            _derivative.endTime == _leftOrder.endTime &&\r\n            _derivative.endTime == _rightOrder.endTime,\r\n            orderError\r\n        );\r\n\r\n        // Validate derivative syntheticId\r\n        require(\r\n            _derivative.syntheticId == _leftOrder.syntheticId &&\r\n            _derivative.syntheticId == _rightOrder.syntheticId,\r\n            orderError\r\n        );\r\n\r\n        // Validate derivative oracleId\r\n        require(\r\n            _derivative.oracleId == _leftOrder.oracleId &&\r\n            _derivative.oracleId == _rightOrder.oracleId,\r\n            orderError\r\n        );\r\n\r\n        // Validate derivative token\r\n        require(\r\n            _derivative.token == _leftOrder.token &&\r\n            _derivative.token == _rightOrder.token,\r\n            orderError\r\n        );\r\n\r\n        // Validate derivative params\r\n        require(_derivative.params.length >= 20, \"MATCH:DERIVATIVE_PARAMS_LENGTH_IS_WRONG\");\r\n\r\n        // Validate left order params\r\n        require(_leftOrder.param0 == _derivative.params[0], orderError);\r\n        require(_leftOrder.param1 == _derivative.params[1], orderError);\r\n        require(_leftOrder.param2 == _derivative.params[2], orderError);\r\n        require(_leftOrder.param3 == _derivative.params[3], orderError);\r\n        require(_leftOrder.param4 == _derivative.params[4], orderError);\r\n        require(_leftOrder.param5 == _derivative.params[5], orderError);\r\n        require(_leftOrder.param6 == _derivative.params[6], orderError);\r\n        require(_leftOrder.param7 == _derivative.params[7], orderError);\r\n        require(_leftOrder.param8 == _derivative.params[8], orderError);\r\n        require(_leftOrder.param9 == _derivative.params[9], orderError);\r\n\r\n        // Validate right order params\r\n        require(_rightOrder.param0 == _derivative.params[10], orderError);\r\n        require(_rightOrder.param1 == _derivative.params[11], orderError);\r\n        require(_rightOrder.param2 == _derivative.params[12], orderError);\r\n        require(_rightOrder.param3 == _derivative.params[13], orderError);\r\n        require(_rightOrder.param4 == _derivative.params[14], orderError);\r\n        require(_rightOrder.param5 == _derivative.params[15], orderError);\r\n        require(_rightOrder.param6 == _derivative.params[16], orderError);\r\n        require(_rightOrder.param7 == _derivative.params[17], orderError);\r\n        require(_rightOrder.param8 == _derivative.params[18], orderError);\r\n        require(_rightOrder.param9 == _derivative.params[19], orderError);\r\n    }\r\n\r\n    /// @notice Distributes funds to core\r\n    /// @param _leftOrder SwaprateOrder\r\n    /// @param _rightOrder SwaprateOrder\r\n    /// @param _derivative Derivative\r\n    /// @param margins uint256[2] left and right margin\r\n    /// @param _fillable uint256 How many positions are fillable\r\n    function _distributeFunds(SwaprateOrder memory _leftOrder, SwaprateOrder memory _rightOrder, Derivative memory _derivative, uint256[2] memory margins, uint256 _fillable) private {\r\n        IERC20 marginToken = IERC20(_derivative.token);\r\n        TokenSpender tokenSpender = TokenSpender(registry.getTokenSpender());\r\n\r\n        // Transfer margin from left to Match and send to Core\r\n        if (margins[0] != 0) {\r\n            // Check allowance for margins\r\n            require(marginToken.allowance(_leftOrder.makerAddress, address(tokenSpender)) >= margins[0].mul(_fillable), \"MATCH:NOT_ENOUGH_ALLOWED_MARGIN\");\r\n\r\n            // Transfer margins from buyer to Match\r\n            tokenSpender.claimTokens(marginToken, _leftOrder.makerAddress, address(this), margins[0].mul(_fillable));\r\n        }\r\n\r\n        // Transfer margin from right to Match and send to Core\r\n        if (margins[1] != 0) {\r\n            // Check allowance for premiums + margin\r\n            require(marginToken.allowance(_rightOrder.makerAddress, address(tokenSpender)) >= margins[1].mul(_fillable), \"MATCH:NOT_ENOUGH_ALLOWED_MARGIN\");\r\n\r\n            // Transfer margins from seller to Match\r\n            tokenSpender.claimTokens(marginToken, _rightOrder.makerAddress, address(this), margins[1].mul(_fillable));\r\n        }\r\n\r\n        if (margins[0].add(margins[1]) != 0) {\r\n            // Approve margin to Core for derivative creation\r\n            require(marginToken.approve(address(tokenSpender), margins[0].add(margins[1]).mul(_fillable)), \"MATCH:COULDNT_APPROVE_MARGIN_FOR_CORE\");\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"Canceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"}],\"name\":\"RegistrySet\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"syntheticId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracleId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"takerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"partialFill\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param5\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param6\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param7\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param8\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param9\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"relayerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"affiliateFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct LibSwaprateOrder.SwaprateOrder\",\"name\":\"_order\",\"type\":\"tuple\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"canceled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"syntheticId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracleId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"takerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"partialFill\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param5\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param6\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param7\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param8\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param9\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"relayerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"affiliateFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct LibSwaprateOrder.SwaprateOrder\",\"name\":\"_leftOrder\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"syntheticId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracleId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"takerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"partialFill\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param5\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param6\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param7\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param8\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param9\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"relayerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"affiliateFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct LibSwaprateOrder.SwaprateOrder\",\"name\":\"_rightOrder\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"margin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"params\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"oracleId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"syntheticId\",\"type\":\"address\"}],\"internalType\":\"struct LibDerivative.Derivative\",\"name\":\"_derivative\",\"type\":\"tuple\"}],\"name\":\"create\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"feeTaken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"filled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"margin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"params\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"oracleId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"syntheticId\",\"type\":\"address\"}],\"internalType\":\"struct LibDerivative.Derivative\",\"name\":\"_derivative\",\"type\":\"tuple\"}],\"name\":\"getDerivativeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"derivativeHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"syntheticId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracleId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"takerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"partialFill\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param5\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param6\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param7\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param8\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param9\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"relayerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"affiliateFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct LibSwaprateOrder.SwaprateOrder\",\"name\":\"_order\",\"type\":\"tuple\"}],\"name\":\"hashOrder\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"verified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SwaprateMatch","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c955f3c0d5a87710996d13b1f9aa3a77552d7a7e","Library":"","LicenseType":"None","SwarmSource":"bzzr://5954dbcb54a17d8a58594685ce1fb91fab7c5ef8ceaf900cfe50bbac7ab7b91c"}]}