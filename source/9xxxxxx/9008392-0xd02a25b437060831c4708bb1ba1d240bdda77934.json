{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\r\\n     * execution of a contract\\u0027s constructor, its address will be reported as\\r\\n     * not containing a contract.\\r\\n     *\\r\\n     * IMPORTANT: It is unsafe to assume that an address for which this\\r\\n     * function returns false is an externally-owned account (EOA) and not a\\r\\n     * contract.\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies in extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != 0x0 \\u0026\\u0026 codehash != accountHash);\\r\\n    }\\r\\n\\r\\n        /**\\r\\n     * @dev Converts an `address` into `address payable`. Note that this is\\r\\n     * simply a type cast: the actual underlying value is not changed.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function toPayable(address account) internal pure returns (address payable) {\\r\\n        return address(uint160(account));\\r\\n    }\\r\\n}\\r\\n\"},\"Context.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\ncontract Context {\\r\\n\\t// Empty internal constructor, to prevent people from mistakenly deploying\\r\\n\\t// an instance of this contract, which should be used via inheritance.\\r\\n\\tconstructor () internal { }\\r\\n\\t// solhint-disable-previous-line no-empty-blocks\\r\\n\\r\\n    /**\\r\\n     * @dev return msg.sender\\r\\n     * @return msg.sender\\r\\n     */\\r\\n\\tfunction _msgSender()\\r\\n        internal\\r\\n        view\\r\\n        returns (address payable)\\r\\n    {\\r\\n\\t\\treturn msg.sender;\\r\\n\\t}\\r\\n\\r\\n    /**\\r\\n     * @dev return msg.value\\r\\n     * @return msg.value\\r\\n     */\\r\\n\\tfunction _msgValue()\\r\\n        internal\\r\\n        view\\r\\n        returns (uint)\\r\\n    {\\r\\n\\t\\treturn msg.value;\\r\\n\\t}\\r\\n\\r\\n    /**\\r\\n     * @dev return msg.data\\r\\n     * @return msg.data\\r\\n     */\\r\\n    function _msgData() internal view returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n\\r\\n        /**\\r\\n     * @dev return tx.origin\\r\\n     * @return tx.origin\\r\\n     */\\r\\n\\tfunction _txOrigin()\\r\\n        internal\\r\\n        view\\r\\n        returns (address)\\r\\n    {\\r\\n\\t\\treturn tx.origin;\\r\\n\\t}\\r\\n}\"},\"Contract_Code.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\u0027./SafeMath.sol\\u0027;\\nimport \\u0027./String.sol\\u0027;\\nimport \\u0027./Address.sol\\u0027;\\nimport \\u0027./Context.sol\\u0027;\\nimport \\u0027./HumanChsek.sol\\u0027;\\nimport \\u0027./Whitelist.sol\\u0027;\\nimport \\u0027./DBUtilli.sol\\u0027;\\n\\n\\n/**\\n * @title Utillibrary\\n * @dev This integrates the basic functions.\\n */\\ncontract Utillibrary is Whitelist {\\n    //lib using list\\n\\tusing SafeMath for *;\\n\\n    //Loglist\\n    event TransferEvent(address indexed _from, address indexed _to, uint _value, uint time);\\n\\n    //base param setting\\n    // uint internal ethWei = 1 ether;\\n    uint internal ethWei = 10 finney;//Test 0.01ether\\n\\n    /**\\n     * @dev Transfer to designated user\\n     * @param userAddress user address\\n     * @param money transfer-out amount\\n     */\\n\\tfunction sendMoneyToUser(address payable userAddress, uint money)\\n        internal\\n    {\\n\\t\\tif (money \\u003e 0) {\\n\\t\\t\\tuserAddress.transfer(money);\\n\\t\\t}\\n\\t}\\n\\n    /**\\n     * @dev Check and correct transfer amount\\n     * @param sendMoney transfer-out amount\\n     * @return bool,amount\\n     */\\n\\tfunction isEnoughBalance(uint sendMoney)\\n        internal\\n        view\\n        returns (bool, uint)\\n    {\\n\\t\\tif (sendMoney \\u003e= address(this).balance) {\\n\\t\\t\\treturn (false, address(this).balance);\\n\\t\\t} else {\\n\\t\\t\\treturn (true, sendMoney);\\n\\t\\t}\\n\\t}\\n\\n    /**\\n     * @dev get UserLevel for the investment amount\\n     * @param value investment amount\\n     * @return UserLevel\\n     */\\n\\tfunction getLevel(uint value)\\n        public\\n        view\\n        returns (uint)\\n    {\\n\\t\\tif (value \\u003e= ethWei.mul(1) \\u0026\\u0026 value \\u003c= ethWei.mul(5)) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tif (value \\u003e= ethWei.mul(6) \\u0026\\u0026 value \\u003c= ethWei.mul(10)) {\\n\\t\\t\\treturn 2;\\n\\t\\t}\\n\\t\\tif (value \\u003e= ethWei.mul(11) \\u0026\\u0026 value \\u003c= ethWei.mul(15)) {\\n\\t\\t\\treturn 3;\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n\\n    /**\\n     * @dev get NodeLevel for the investment amount\\n     * @param value investment amount\\n     * @return NodeLevel\\n     */\\n\\tfunction getNodeLevel(uint value)\\n        public\\n        view\\n        returns (uint)\\n    {\\n\\t\\tif (value \\u003e= ethWei.mul(1) \\u0026\\u0026 value \\u003c= ethWei.mul(5)) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tif (value \\u003e= ethWei.mul(6) \\u0026\\u0026 value \\u003c= ethWei.mul(10)) {\\n\\t\\t\\treturn 2;\\n\\t\\t}\\n\\t\\tif (value \\u003e= ethWei.mul(11)) {\\n\\t\\t\\treturn 3;\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n\\n    /**\\n     * @dev get scale for the level\\n     * @param level level\\n     * @return scale\\n     */\\n\\tfunction getScaleByLevel(uint level)\\n        public\\n        pure\\n        returns (uint)\\n    {\\n\\t\\tif (level == 1) {\\n\\t\\t\\treturn 5;\\n\\t\\t}\\n\\t\\tif (level == 2) {\\n\\t\\t\\treturn 7;\\n\\t\\t}\\n\\t\\tif (level == 3) {\\n\\t\\t\\treturn 10;\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n\\n    /**\\n     * @dev get recommend scal for the level and times\\n     * @param level level\\n     * @param times The layer number of recommended\\n     * @return recommend scale\\n     */\\n\\tfunction getRecommendScaleByLevelAndTim(uint level, uint times)\\n        public\\n        pure\\n        returns (uint)\\n    {\\n\\t\\tif (level == 1 \\u0026\\u0026 times == 1) {\\n\\t\\t\\treturn 50;\\n\\t\\t}\\n\\t\\tif (level == 2 \\u0026\\u0026 times == 1) {\\n\\t\\t\\treturn 70;\\n\\t\\t}\\n\\t\\tif (level == 2 \\u0026\\u0026 times == 2) {\\n\\t\\t\\treturn 50;\\n\\t\\t}\\n\\t\\tif (level == 3) {\\n\\t\\t\\tif (times == 1) {\\n\\t\\t\\t\\treturn 100;\\n\\t\\t\\t}\\n\\t\\t\\tif (times == 2) {\\n\\t\\t\\t\\treturn 70;\\n\\t\\t\\t}\\n\\t\\t\\tif (times == 3) {\\n\\t\\t\\t\\treturn 50;\\n\\t\\t\\t}\\n\\t\\t\\tif (times \\u003e= 4 \\u0026\\u0026 times \\u003c= 10) {\\n\\t\\t\\t\\treturn 10;\\n\\t\\t\\t}\\n\\t\\t\\tif (times \\u003e= 11 \\u0026\\u0026 times \\u003c= 20) {\\n\\t\\t\\t\\treturn 5;\\n\\t\\t\\t}\\n\\t\\t\\tif (times \\u003e= 21) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n\\n    /**\\n     * @dev get burn scal for the level\\n     * @param level level\\n     * @return burn scale\\n     */\\n\\tfunction getBurnScaleByLevel(uint level)\\n        public\\n        pure\\n        returns (uint)\\n    {\\n\\t\\tif (level == 1) {\\n\\t\\t\\treturn 3;\\n\\t\\t}\\n\\t\\tif (level == 2) {\\n\\t\\t\\treturn 6;\\n\\t\\t}\\n\\t\\tif (level == 3) {\\n\\t\\t\\treturn 10;\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n\\n    /**\\n     * @dev Transfer to designated addr\\n     * Authorization Required\\n     * @param _addr transfer-out address\\n     * @param _val transfer-out amount\\n     */\\n    function sendMoneyToAddr(address _addr, uint _val)\\n        public\\n        payable\\n        onlyOwner\\n    {\\n        require(_addr != address(0), \\\"not the zero address\\\");\\n        address(uint160(_addr)).transfer(_val);\\n        emit TransferEvent(address(this), _addr, _val, now);\\n    }\\n}\\n\\n\\ncontract HYPlay is Context, HumanChsek, Whitelist, DBUtilli, Utillibrary {\\n    //lib using list\\n\\tusing SafeMath for *;\\n    using String for string;\\n    using Address for address;\\n\\n    //struct\\n\\tstruct User {\\n\\t\\tuint id;\\n\\t\\taddress userAddress;\\n        uint lineAmount;//bonus calculation mode line\\n        uint freezeAmount;//invest lock\\n\\t\\tuint freeAmount;//invest out unlock\\n        uint dayBonusAmount;//Daily bonus amount (static bonus)\\n        uint bonusAmount;//add up static bonus amonut (static bonus)\\n\\t\\tuint inviteAmonut;//add up invite bonus amonut (dynamic bonus)\\n\\t\\tuint level;//user level\\n\\t\\tuint nodeLevel;//user node Level\\n\\t\\tuint investTimes;//settlement bonus number\\n\\t\\tuint rewardIndex;//user current index of award\\n\\t\\tuint lastRwTime;//last settlement time\\n\\t}\\n\\tstruct AwardData {\\n        uint time;//settlement bonus time\\n        uint staticAmount;//static bonus of reward amount\\n\\t\\tuint oneInvAmount;//One layer of reward amount\\n\\t\\tuint twoInvAmount;//Two layer reward amount\\n\\t\\tuint threeInvAmount;//Three layer or more bonus amount\\n\\t}\\n\\n    //Loglist\\n    event InvestEvent(address indexed _addr, string _code, string _rCode, uint _value, uint time);\\n    event WithdrawEvent(address indexed _addr, uint _value, uint time);\\n\\n    //base param setting\\n\\taddress payable private devAddr = address(0);//The special account\\n\\taddress payable private foundationAddr = address(0);//Foundation address\\n\\n    //start Time setting\\n    uint startTime = 0;\\n\\tuint canSetStartTime = 1;\\n\\tuint period = 1 days;\\n\\n    //Bonus calculation mode (0 invested,!=0 line)\\n    uint lineStatus = 0;\\n\\n    //Round setting\\n\\tuint rid = 1;\\n\\tmapping(uint =\\u003e uint) roundInvestCount;//RoundID InvestCount Mapping\\n\\tmapping(uint =\\u003e uint) roundInvestMoney;//RoundID InvestMoney Mapping\\n\\tmapping(uint =\\u003e uint[]) lineArrayMapping;//RoundID UID[] Mapping\\n    //RoundID [address User Mapping] Mapping\\n\\tmapping(uint =\\u003e mapping(address =\\u003e User)) userRoundMapping;\\n    //RoundID [address [rewardIndex AwardData Mapping] Mapping] Mapping\\n\\tmapping(uint =\\u003e mapping(address =\\u003e mapping(uint =\\u003e AwardData))) userAwardDataMapping;\\n\\n    //limit setting\\n\\tuint bonuslimit = ethWei.mul(15);\\n\\tuint sendLimit = ethWei.mul(100);\\n\\tuint withdrawLimit = ethWei.mul(15);\\n\\n    /**\\n     * @dev the content of contract is Beginning\\n     */\\n\\tconstructor (address _dbAddr, address _devAddr, address _foundationAddr) public {\\n        db = IDB(_dbAddr);\\n        devAddr = address(_devAddr).toPayable();\\n        foundationAddr = address(_foundationAddr).toPayable();\\n\\t}\\n\\n    /**\\n     * @dev deposit\\n     */\\n\\tfunction() external payable {\\n\\t}\\n\\n    /**\\n     * @dev Set invest mode\\n     * @param line invest mode\\n     */\\n\\tfunction actUpdateLine(uint line)\\n        external\\n        onlyIfWhitelisted\\n    {\\n\\t\\tlineStatus = line;\\n\\t}\\n\\n    /**\\n     * @dev Set start time\\n     * @param time start time\\n     */\\n\\tfunction actSetStartTime(uint time)\\n        external\\n        onlyIfWhitelisted\\n    {\\n\\t\\trequire(canSetStartTime == 1, \\\"verydangerous, limited!\\\");\\n\\t\\trequire(time \\u003e now, \\\"no, verydangerous\\\");\\n\\t\\tstartTime = time;\\n\\t\\tcanSetStartTime = 0;\\n\\t}\\n\\n    /**\\n     * @dev Set End Round\\n     */\\n\\tfunction actEndRound()\\n        external\\n        onlyIfWhitelisted\\n    {\\n\\t\\trequire(address(this).balance \\u003c ethWei.mul(1), \\\"contract balance must be lower than 1 ether\\\");\\n\\t\\trid++;\\n\\t\\tstartTime = now.add(period).div(1 days).mul(1 days);\\n\\t\\tcanSetStartTime = 1;\\n\\t}\\n\\n    /**\\n     * @dev Set all limit\\n     * @param _bonuslimit bonus limit\\n     * @param _sendLimit send limit\\n     * @param _withdrawLimit withdraw limit\\n     */\\n\\tfunction actAllLimit(uint _bonuslimit, uint _sendLimit, uint _withdrawLimit)\\n        external\\n        onlyIfWhitelisted\\n    {\\n\\t\\trequire(_bonuslimit \\u003e= ethWei.mul(15) \\u0026\\u0026 _sendLimit \\u003e= ethWei.mul(100) \\u0026\\u0026 _withdrawLimit \\u003e= ethWei.mul(15), \\\"invalid amount\\\");\\n\\t\\tbonuslimit = _bonuslimit;\\n\\t\\tsendLimit = _sendLimit;\\n\\t\\twithdrawLimit = _withdrawLimit;\\n\\t}\\n\\n    /**\\n     * @dev Set user status\\n     * @param addr user address\\n     * @param status user status\\n     */\\n\\tfunction actUserStatus(address addr, uint status)\\n        external\\n        onlyIfWhitelisted\\n    {\\n\\t\\trequire(status == 0 || status == 1 || status == 2, \\\"bad parameter status\\\");\\n        _setUser(addr, status);\\n\\t}\\n\\n    /**\\n     * @dev Calculation of contract bonus\\n     * @param start start the entry\\n     * @param end end the entry\\n     * @param isUID parameter is UID\\n     */\\n\\tfunction calculationBonus(uint start, uint end, uint isUID)\\n        external\\n        isHuman()\\n        onlyIfWhitelisted\\n    {\\n\\t\\tfor (uint i = start; i \\u003c= end; i++) {\\n\\t\\t\\tuint userId = 0;\\n\\t\\t\\tif (isUID == 0) {\\n\\t\\t\\t\\tuserId = lineArrayMapping[rid][i];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tuserId = i;\\n\\t\\t\\t}\\n\\t\\t\\taddress userAddr = _getIndexMapping(userId);\\n\\t\\t\\tUser storage user = userRoundMapping[rid][userAddr];\\n\\t\\t\\tif (user.freezeAmount == 0 \\u0026\\u0026 user.lineAmount \\u003e= ethWei.mul(1) \\u0026\\u0026 user.lineAmount \\u003c= ethWei.mul(15)) {\\n\\t\\t\\t\\tuser.freezeAmount = user.lineAmount;\\n\\t\\t\\t\\tuser.level = getLevel(user.freezeAmount);\\n\\t\\t\\t\\tuser.lineAmount = 0;\\n\\t\\t\\t\\tsendFeeToDevAddr(user.freezeAmount);\\n\\t\\t\\t\\tcountBonus_All(user.userAddress);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n    /**\\n     * @dev settlement bonus\\n     * @param start start the entry\\n     * @param end end the entry\\n     */\\n\\tfunction settlement(uint start, uint end)\\n        external\\n        onlyIfWhitelisted\\n    {\\n\\t\\tfor (uint i = start; i \\u003c= end; i++) {\\n\\t\\t\\taddress userAddr = _getIndexMapping(i);\\n\\t\\t\\tUser storage user = userRoundMapping[rid][userAddr];\\n\\n            uint[2] memory user_data;\\n            (user_data, , ) = _getUserInfo(userAddr);\\n            uint user_status = user_data[1];\\n\\n\\t\\t\\tif (now.sub(user.lastRwTime) \\u003c= 12 hours) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tuser.lastRwTime = now;\\n\\n\\t\\t\\tif (user_status == 1) {\\n                user.rewardIndex = user.rewardIndex.add(1);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n            //static bonus\\n\\t\\t\\tuint bonusStatic = 0;\\n\\t\\t\\tif (user.id != 0 \\u0026\\u0026 user.freezeAmount \\u003e= ethWei.mul(1) \\u0026\\u0026 user.freezeAmount \\u003c= bonuslimit) {\\n\\t\\t\\t\\tif (user.investTimes \\u003c 5) {\\n\\t\\t\\t\\t\\tbonusStatic = bonusStatic.add(user.dayBonusAmount);\\n\\t\\t\\t\\t\\tuser.bonusAmount = user.bonusAmount.add(bonusStatic);\\n\\t\\t\\t\\t\\tuser.investTimes = user.investTimes.add(1);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tuser.freeAmount = user.freeAmount.add(user.freezeAmount);\\n\\t\\t\\t\\t\\tuser.freezeAmount = 0;\\n\\t\\t\\t\\t\\tuser.dayBonusAmount = 0;\\n\\t\\t\\t\\t\\tuser.level = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n            //dynamic bonus\\n\\t\\t\\tuint inviteSend = 0;\\n            if (user_status == 0) {\\n                inviteSend = getBonusAmount_Dynamic(userAddr, rid, 0, false);\\n            }\\n\\n            //sent bonus amonut\\n\\t\\t\\tif (bonusStatic.add(inviteSend) \\u003c= sendLimit) {\\n\\t\\t\\t\\tuser.inviteAmonut = user.inviteAmonut.add(inviteSend);\\n\\t\\t\\t\\tbool isEnough = false;\\n\\t\\t\\t\\tuint resultMoney = 0;\\n\\t\\t\\t\\t(isEnough, resultMoney) = isEnoughBalance(bonusStatic.add(inviteSend));\\n\\t\\t\\t\\tif (resultMoney \\u003e 0) {\\n\\t\\t\\t\\t\\tuint foundationMoney = resultMoney.div(10);\\n\\t\\t\\t\\t\\tsendMoneyToUser(foundationAddr, foundationMoney);\\n\\t\\t\\t\\t\\tresultMoney = resultMoney.sub(foundationMoney);\\n\\t\\t\\t\\t\\taddress payable sendAddr = address(uint160(userAddr));\\n\\t\\t\\t\\t\\tsendMoneyToUser(sendAddr, resultMoney);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n            AwardData storage awData = userAwardDataMapping[rid][userAddr][user.rewardIndex];\\n            //Record static bonus\\n            awData.staticAmount = bonusStatic;\\n            //Record settlement bonus time\\n            awData.time = now;\\n\\n            //user reward Index since the increase\\n            user.rewardIndex = user.rewardIndex.add(1);\\n\\t\\t}\\n\\t}\\n\\n    /**\\n     * @dev the invest withdraw of contract is Beginning\\n     */\\n    function withdraw()\\n        public\\n        isHuman()\\n    {\\n\\t\\trequire(isOpen(), \\\"Contract no open\\\");\\n\\t\\tUser storage user = userRoundMapping[rid][_msgSender()];\\n\\t\\trequire(user.id != 0, \\\"user not exist\\\");\\n\\t\\tuint sendMoney = user.freeAmount + user.lineAmount;\\n\\n\\t\\trequire(sendMoney \\u003e 0, \\\"Incorrect sendMoney\\\");\\n\\n\\t\\tbool isEnough = false;\\n\\t\\tuint resultMoney = 0;\\n\\n\\t\\t(isEnough, resultMoney) = isEnoughBalance(sendMoney);\\n\\n        require(resultMoney \\u003e 0, \\\"not Enough Balance\\\");\\n\\n\\t\\tif (resultMoney \\u003e 0 \\u0026\\u0026 resultMoney \\u003c= withdrawLimit) {\\n\\t\\t\\tuser.freeAmount = 0;\\n\\t\\t\\tuser.lineAmount = 0;\\n\\t\\t\\tuser.nodeLevel = getNodeLevel(user.freezeAmount);\\n            sendMoneyToUser(_msgSender(), resultMoney);\\n\\t\\t}\\n\\n        emit WithdrawEvent(_msgSender(), resultMoney, now);\\n\\t}\\n\\n    /**\\n     * @dev the invest of contract is Beginning\\n     * @param code user invite Code\\n     * @param rCode recommend code\\n     */\\n\\tfunction invest(string memory code, string memory rCode)\\n        public\\n        payable\\n        isHuman()\\n    {\\n\\t\\trequire(isOpen(), \\\"Contract no open\\\");\\n\\t\\trequire(_msgValue() \\u003e= ethWei.mul(1) \\u0026\\u0026 _msgValue() \\u003c= ethWei.mul(15), \\\"between 1 and 15\\\");\\n\\t\\trequire(_msgValue() == _msgValue().div(ethWei).mul(ethWei), \\\"invalid msg value\\\");\\n\\n        uint[2] memory user_data;\\n        (user_data, , ) = _getUserInfo(_msgSender());\\n        uint user_id = user_data[0];\\n\\n\\t\\tif (user_id == 0) {\\n\\t\\t\\t_registerUser(_msgSender(), code, rCode);\\n            (user_data, , ) = _getUserInfo(_msgSender());\\n            user_id = user_data[0];\\n\\t\\t}\\n\\n\\t\\tuint investAmout;\\n\\t\\tuint lineAmount;\\n\\t\\tif (isLine()) {\\n\\t\\t\\tlineAmount = _msgValue();\\n\\t\\t} else {\\n\\t\\t\\tinvestAmout = _msgValue();\\n\\t\\t}\\n\\t\\tUser storage user = userRoundMapping[rid][_msgSender()];\\n\\t\\tif (user.id != 0) {\\n\\t\\t\\trequire(user.freezeAmount.add(user.lineAmount) == 0, \\\"only once invest\\\");\\n\\t\\t} else {\\n\\t\\t\\tuser.id = user_id;\\n\\t\\t\\tuser.userAddress = _msgSender();\\n\\t\\t}\\n        user.freezeAmount = investAmout;\\n        user.lineAmount = lineAmount;\\n        user.level = getLevel(user.freezeAmount);\\n        user.nodeLevel = getNodeLevel(user.freezeAmount.add(user.freeAmount).add(user.lineAmount));\\n\\n\\t\\troundInvestCount[rid] = roundInvestCount[rid].add(1);\\n\\t\\troundInvestMoney[rid] = roundInvestMoney[rid].add(_msgValue());\\n\\t\\tif (!isLine()) {\\n\\t\\t\\tsendFeeToDevAddr(_msgValue());\\n\\t\\t\\tcountBonus_All(user.userAddress);\\n\\t\\t} else {\\n\\t\\t\\tlineArrayMapping[rid].push(user.id);\\n\\t\\t}\\n\\n        emit InvestEvent(_msgSender(), code, rCode, _msgValue(), now);\\n\\t}\\n\\n    /**\\n     * @dev Show contract state view\\n     * @return contract state view\\n     */\\n    function stateView()\\n        public\\n        view\\n        returns (uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint)\\n    {\\n\\t\\treturn (\\n            _getCurrentUserID(),\\n            rid,\\n            startTime,\\n            canSetStartTime,\\n            roundInvestCount[rid],\\n            roundInvestMoney[rid],\\n            bonuslimit,\\n            sendLimit,\\n            withdrawLimit,\\n            lineStatus,\\n            lineArrayMapping[rid].length\\n\\t\\t);\\n\\t}\\n\\n    /**\\n     * @dev determine if contract open\\n     * @return bool\\n     */\\n\\tfunction isOpen()\\n        public\\n        view\\n        returns (bool)\\n    {\\n\\t\\treturn startTime != 0 \\u0026\\u0026 now \\u003e startTime;\\n\\t}\\n\\n    /**\\n     * @dev Whether bonus is calculated when determining contract investment\\n     * @return bool\\n     */\\n\\tfunction isLine()\\n        private\\n        view\\n        returns (bool)\\n    {\\n\\t\\treturn lineStatus != 0;\\n\\t}\\n\\n    /**\\n     * @dev get the user id of the round ID or current round [lineArrayMapping] based on the index\\n     * @param index the index of [lineArrayMapping]\\n     * @param roundId round ID (Go to the current for empty)\\n     * @return user ID\\n     */\\n\\tfunction getLineUserId(uint index, uint roundId)\\n        public\\n        view\\n        returns (uint)\\n    {\\n\\t\\trequire(checkWhitelist(), \\\"Permission denied\\\");\\n\\t\\tif (roundId == 0) {\\n\\t\\t\\troundId = rid;\\n\\t\\t}\\n\\t\\treturn lineArrayMapping[rid][index];\\n\\t}\\n\\n    /**\\n     * @dev get the user info based on user ID and round ID\\n     * @param addr user address\\n     * @param roundId round ID (Go to the current for empty)\\n     * @param rewardIndex user current index of award\\n     * @param useRewardIndex use user current index of award\\n     * @return user info\\n     */\\n\\tfunction getUserByAddress(\\n        address addr,\\n        uint roundId,\\n        uint rewardIndex,\\n        bool useRewardIndex\\n    )\\n        public\\n        view\\n        returns (uint[17] memory info, string memory code, string memory rCode)\\n    {\\n\\t\\trequire(checkWhitelist() || _msgSender() == addr, \\\"Permission denied for view user\\u0027s privacy\\\");\\n\\n\\t\\tif (roundId == 0) {\\n\\t\\t\\troundId = rid;\\n\\t\\t}\\n\\n        uint[2] memory user_data;\\n        (user_data, code, rCode) = _getUserInfo(addr);\\n        uint user_id = user_data[0];\\n        uint user_status = user_data[1];\\n\\n\\t\\tUser memory user = userRoundMapping[roundId][addr];\\n\\n        uint historyDayBonusAmount = 0;\\n        uint settlementbonustime = 0;\\n        if (useRewardIndex)\\n        {\\n            AwardData memory awData = userAwardDataMapping[roundId][user.userAddress][rewardIndex];\\n            historyDayBonusAmount = awData.staticAmount;\\n            settlementbonustime = awData.time;\\n        }\\n\\n        uint grantAmount = 0;\\n\\t\\tif (user.id \\u003e 0 \\u0026\\u0026 user.freezeAmount \\u003e= ethWei.mul(1) \\u0026\\u0026 user.freezeAmount \\u003c= bonuslimit \\u0026\\u0026 user.investTimes \\u003c 5 \\u0026\\u0026 user_status != 1) {\\n            if (!useRewardIndex)\\n            {\\n                grantAmount = grantAmount.add(user.dayBonusAmount);\\n            }\\n\\t\\t}\\n\\n        grantAmount = grantAmount.add(getBonusAmount_Dynamic(addr, roundId, rewardIndex, useRewardIndex));\\n\\n\\t\\tinfo[0] = user_id;\\n\\t\\tinfo[1] = user.lineAmount;//bonus calculation mode line\\n        info[2] = user.freezeAmount;//invest lock\\n        info[3] = user.freeAmount;//invest out unlock\\n        info[4] = user.dayBonusAmount;//Daily bonus amount (static bonus)\\n        info[5] = user.bonusAmount;//add up static bonus amonut (static bonus)\\n        info[6] = grantAmount;//No settlement of invitation bonus amount (dynamic bonus)\\n\\t\\tinfo[7] = user.inviteAmonut;//add up invite bonus amonut (dynamic bonus)\\n        info[8] = user.level;//user level\\n        info[9] = user.nodeLevel;//user node Level\\n        info[10] = _getRCodeMappingLength(code);//user node number\\n        info[11] = user.investTimes;//settlement bonus number\\n\\t\\tinfo[12] = user.rewardIndex;//user current index of award\\n        info[13] = user.lastRwTime;//last settlement time\\n        info[14] = user_status;//user status\\n        info[15] = historyDayBonusAmount;//history daily bonus amount (static bonus) (reward Index is not zero)\\n        info[16] = settlementbonustime;//history daily settlement bonus time (reward Index is not zero)\\n\\n\\t\\treturn (info, code, rCode);\\n\\t}\\n\\n    /**\\n     * @dev Calculate the bonus (All)\\n     * @param addr user address\\n     */\\n\\tfunction countBonus_All(address addr)\\n        private\\n    {\\n\\t\\tUser storage user = userRoundMapping[rid][addr];\\n\\t\\tif (user.id == 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tuint staticScale = getScaleByLevel(user.level);\\n\\t\\tuser.dayBonusAmount = user.freezeAmount.mul(staticScale).div(1000);\\n\\t\\tuser.investTimes = 0;\\n\\n        uint[2] memory user_data;\\n        string memory user_rCode;\\n        (user_data, , user_rCode) = _getUserInfo(addr);\\n        uint user_status = user_data[1];\\n\\n\\t\\tif (user.freezeAmount \\u003e= ethWei.mul(1) \\u0026\\u0026 user.freezeAmount \\u003c= bonuslimit \\u0026\\u0026 user_status == 0) {\\n\\t\\t\\tcountBonus_Dynamic(user_rCode, user.freezeAmount, staticScale);\\n\\t\\t}\\n\\t}\\n\\n    /**\\n     * @dev Calculate the bonus (dynamic)\\n     * @param rCode user recommend code\\n     * @param money invest money\\n     * @param staticScale static scale\\n     */\\n\\tfunction countBonus_Dynamic(string memory rCode, uint money, uint staticScale)\\n        private\\n    {\\n\\t\\tstring memory tmpReferrerCode = rCode;\\n\\n\\t\\tfor (uint i = 1; i \\u003c= 25; i++) {\\n\\t\\t\\tif (tmpReferrerCode.compareStr(\\\"\\\")) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\taddress tmpUserAddr = _getCodeMapping(tmpReferrerCode);\\n\\t\\t\\tUser memory tmpUser = userRoundMapping[rid][tmpUserAddr];\\n\\n            string memory tmpUser_rCode;\\n            (, , tmpUser_rCode) = _getUserInfo(tmpUserAddr);\\n\\n\\t\\t\\tif (tmpUser.freezeAmount.add(tmpUser.freeAmount).add(tmpUser.lineAmount) == 0) {\\n\\t\\t\\t\\ttmpReferrerCode = tmpUser_rCode;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n            //use max Recommend Level Scale\\n            //The actual proportion is used for settlement\\n\\t\\t\\tuint recommendScale = getRecommendScaleByLevelAndTim(3, i);\\n\\t\\t\\tuint moneyResult = 0;\\n\\t\\t\\tif (money \\u003c= ethWei.mul(15)) {\\n\\t\\t\\t\\tmoneyResult = money;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmoneyResult = ethWei.mul(15);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (recommendScale != 0) {\\n\\t\\t\\t\\tuint tmpDynamicAmount = moneyResult.mul(staticScale).mul(recommendScale);\\n\\t\\t\\t\\ttmpDynamicAmount = tmpDynamicAmount.div(1000).div(100);\\n\\t\\t\\t\\trecordAwardData(tmpUserAddr, tmpDynamicAmount, tmpUser.rewardIndex, i);\\n\\t\\t\\t}\\n\\t\\t\\ttmpReferrerCode = tmpUser_rCode;\\n\\t\\t}\\n\\t}\\n\\n    /**\\n     * @dev Record bonus data\\n     * @param addr user address\\n     * @param awardAmount Calculated award amount\\n     * @param rewardIndex user current index of award\\n     * @param times The layer number of recommended\\n     */\\n\\tfunction recordAwardData(address addr, uint awardAmount, uint rewardIndex, uint times)\\n        private\\n    {\\n\\t\\tfor (uint i = 0; i \\u003c 5; i++) {\\n\\t\\t\\tAwardData storage awData = userAwardDataMapping[rid][addr][rewardIndex.add(i)];\\n\\t\\t\\tif (times == 1) {\\n\\t\\t\\t\\tawData.oneInvAmount = awData.oneInvAmount.add(awardAmount);\\n\\t\\t\\t}\\n\\t\\t\\tif (times == 2) {\\n\\t\\t\\t\\tawData.twoInvAmount = awData.twoInvAmount.add(awardAmount);\\n\\t\\t\\t}\\n\\t\\t\\tawData.threeInvAmount = awData.threeInvAmount.add(awardAmount);\\n\\t\\t}\\n\\t}\\n\\n    /**\\n     * @dev send fee to the develop addr\\n     * @param amount send amount (4%)\\n     */\\n\\tfunction sendFeeToDevAddr(uint amount)\\n        private\\n    {\\n        sendMoneyToUser(devAddr, amount.div(25));\\n\\t}\\n\\n    /**\\n     * @dev  get the bonus bmount based on user address and reward Index  (dynamic)\\n     * @param addr user address\\n     * @param roundId round ID\\n     * @param rewardIndex user current index of award\\n     * @param useRewardIndex use user current index of award\\n     * @return bonus amount\\n     */\\n\\tfunction getBonusAmount_Dynamic(\\n        address addr,\\n        uint roundId,\\n        uint rewardIndex,\\n        bool useRewardIndex\\n    )\\n        private\\n        view\\n        returns (uint)\\n    {\\n        uint resultAmount = 0;\\n\\t\\tUser memory user = userRoundMapping[roundId][addr];\\n\\n        if (!useRewardIndex) {\\n\\t\\t\\trewardIndex = user.rewardIndex;\\n\\t\\t}\\n\\n        uint[2] memory user_data;\\n        (user_data, , ) = _getUserInfo(addr);\\n        uint user_status = user_data[1];\\n\\n        uint lineAmount = user.freezeAmount.add(user.freeAmount).add(user.lineAmount);\\n\\t\\tif (user_status == 0 \\u0026\\u0026 lineAmount \\u003e= ethWei.mul(1) \\u0026\\u0026 lineAmount \\u003c= withdrawLimit) {\\n\\t\\t\\tuint inviteAmount = 0;\\n\\t\\t\\tAwardData memory awData = userAwardDataMapping[roundId][user.userAddress][rewardIndex];\\n            uint lineValue = lineAmount.div(ethWei);\\n            if (lineValue \\u003e= 15) {\\n                inviteAmount = inviteAmount.add(awData.threeInvAmount);\\n            } else {\\n                if (user.nodeLevel == 1 \\u0026\\u0026 lineAmount \\u003e= ethWei.mul(1) \\u0026\\u0026 awData.oneInvAmount \\u003e 0) {\\n                    //dev getRecommendScaleByLevelAndTim(3, 1)/getRecommendScaleByLevelAndTim(1, 1)=2   100/50=2\\n                    inviteAmount = inviteAmount.add(awData.oneInvAmount.div(15).mul(lineValue).div(2));\\n                }\\n                if (user.nodeLevel == 2 \\u0026\\u0026 lineAmount \\u003e= ethWei.mul(1) \\u0026\\u0026 (awData.oneInvAmount \\u003e 0 || awData.twoInvAmount \\u003e 0)) {\\n                    //mul getRecommendScaleByLevelAndTim(3, 1)  100 →  getRecommendScaleByLevelAndTim(2, 1)  70\\n                    inviteAmount = inviteAmount.add(awData.oneInvAmount.div(15).mul(lineValue).mul(7).div(10));\\n                    //mul getRecommendScaleByLevelAndTim(3, 2)  70 →  getRecommendScaleByLevelAndTim(2, 2)  50\\n                    inviteAmount = inviteAmount.add(awData.twoInvAmount.div(15).mul(lineValue).mul(5).div(7));\\n                }\\n                if (user.nodeLevel == 3 \\u0026\\u0026 lineAmount \\u003e= ethWei.mul(1) \\u0026\\u0026 awData.threeInvAmount \\u003e 0) {\\n                    inviteAmount = inviteAmount.add(awData.threeInvAmount.div(15).mul(lineValue));\\n                }\\n                if (user.nodeLevel \\u003c 3) {\\n                    //bonus burn\\n                    uint burnScale = getBurnScaleByLevel(user.nodeLevel);\\n                    inviteAmount = inviteAmount.mul(burnScale).div(10);\\n                }\\n            }\\n            resultAmount = resultAmount.add(inviteAmount);\\n\\t\\t}\\n\\n        return resultAmount;\\n\\t}\\n}\"},\"DBUtilli.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\nimport \\u0027./Context.sol\\u0027;\\r\\nimport \\u0027./Whitelist.sol\\u0027;\\r\\nimport \\u0027./IDB.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title DBUtilli\\r\\n * @dev This Provide database support services (db)\\r\\n */\\r\\ncontract DBUtilli is Context, Whitelist {\\r\\n\\r\\n    //include other contract\\r\\n    IDB internal db;\\r\\n\\r\\n    /**\\r\\n     * @dev Create store user information (db)\\r\\n     * @param addr user address\\r\\n     * @param code user invite Code\\r\\n     * @param rCode recommend code\\r\\n     */\\r\\n    function _registerUser(address addr, string memory code, string memory rCode)\\r\\n        internal\\r\\n    {\\r\\n        db.registerUser(addr, code, rCode);\\r\\n\\t}\\r\\n\\r\\n    /**\\r\\n     * @dev Set store user information\\r\\n     * @param addr user addr\\r\\n     * @param status user status\\r\\n     */\\r\\n    function _setUser(address addr, uint status)\\r\\n        internal\\r\\n    {\\r\\n\\t\\tdb.setUser(addr, status);\\r\\n\\t}\\r\\n\\r\\n    /**\\r\\n     * @dev determine if user invite code is use (db)\\r\\n     * @param code user invite Code\\r\\n     * @return bool\\r\\n     */\\r\\n    function _isUsedCode(string memory code)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool isUser)\\r\\n    {\\r\\n        isUser = db.isUsedCode(code);\\r\\n\\t\\treturn isUser;\\r\\n\\t}\\r\\n\\r\\n    /**\\r\\n     * @dev get the user address of the corresponding user invite code (db)\\r\\n     * Authorization Required\\r\\n     * @param code user invite Code\\r\\n     * @return address\\r\\n     */\\r\\n    function _getCodeMapping(string memory code)\\r\\n        internal\\r\\n        view\\r\\n        returns (address addr)\\r\\n    {\\r\\n        addr = db.getCodeMapping(code);\\r\\n        return  addr;\\r\\n\\t}\\r\\n\\r\\n    /**\\r\\n     * @dev get the user address of the corresponding user id (db)\\r\\n     * Authorization Required\\r\\n     * @param uid user id\\r\\n     * @return address\\r\\n     */\\r\\n    function _getIndexMapping(uint uid)\\r\\n        internal\\r\\n        view\\r\\n        returns (address addr)\\r\\n    {\\r\\n        addr = db.getIndexMapping(uid);\\r\\n\\t\\treturn addr;\\r\\n\\t}\\r\\n\\r\\n    /**\\r\\n     * @dev get the user address of the corresponding User info (db)\\r\\n     * Authorization Required or addr is owner\\r\\n     * @param addr user address\\r\\n     * @return info[id,status],code,rCode\\r\\n     */\\r\\n    function _getUserInfo(address addr)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint[2] memory info, string memory code, string memory rCode)\\r\\n    {\\r\\n        (info, code, rCode) = db.getUserInfo(addr);\\r\\n\\t\\treturn (info, code, rCode);\\r\\n\\t}\\r\\n\\r\\n    /**\\r\\n     * @dev get the current latest ID (db)\\r\\n     * Authorization Required\\r\\n     * @return current uid\\r\\n     */\\r\\n    function _getCurrentUserID()\\r\\n        internal\\r\\n        view\\r\\n        returns (uint uid)\\r\\n    {\\r\\n        uid = db.getCurrentUserID();\\r\\n\\t\\treturn uid;\\r\\n\\t}\\r\\n\\r\\n    /**\\r\\n     * @dev get the rCodeMapping array length of the corresponding recommend Code (db)\\r\\n     * Authorization Required\\r\\n     * @param rCode recommend Code\\r\\n     * @return rCodeMapping array length\\r\\n     */\\r\\n    function _getRCodeMappingLength(string memory rCode)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint length)\\r\\n    {\\r\\n        length = db.getRCodeMappingLength(rCode);\\r\\n\\t\\treturn length;\\r\\n\\t}\\r\\n\\r\\n    /**\\r\\n     * @dev get the user invite code of the recommend Code [rCodeMapping] based on the index (db)\\r\\n     * Authorization Required\\r\\n     * @param rCode recommend Code\\r\\n     * @param index the index of [rCodeMapping]\\r\\n     * @return user invite code\\r\\n     */\\r\\n    function _getRCodeMapping(string memory rCode, uint index)\\r\\n        internal\\r\\n        view\\r\\n        returns (string memory code)\\r\\n    {\\r\\n        code = db.getRCodeMapping(rCode, index);\\r\\n\\t\\treturn code;\\r\\n\\t}\\r\\n\\r\\n    /**\\r\\n     * @dev determine if user invite code is use (db)\\r\\n     * @param code user invite Code\\r\\n     * @return bool\\r\\n     */\\r\\n    function isUsedCode(string memory code)\\r\\n        public\\r\\n        view\\r\\n        returns (bool isUser)\\r\\n    {\\r\\n        isUser = _isUsedCode(code);\\r\\n\\t\\treturn isUser;\\r\\n\\t}\\r\\n\\r\\n    /**\\r\\n     * @dev get the user address of the corresponding user invite code (db)\\r\\n     * Authorization Required\\r\\n     * @param code user invite Code\\r\\n     * @return address\\r\\n     */\\r\\n    function getCodeMapping(string memory code)\\r\\n        public\\r\\n        view\\r\\n        returns (address addr)\\r\\n    {\\r\\n        require(checkWhitelist(), \\\"DBUtilli: Permission denied\\\");\\r\\n        addr = _getCodeMapping(code);\\r\\n\\t\\treturn addr;\\r\\n\\t}\\r\\n\\r\\n    /**\\r\\n     * @dev get the user address of the corresponding user id (db)\\r\\n     * Authorization Required\\r\\n     * @param uid user id\\r\\n     * @return address\\r\\n     */\\r\\n    function getIndexMapping(uint uid)\\r\\n        public\\r\\n        view\\r\\n        returns (address addr)\\r\\n    {\\r\\n        require(checkWhitelist(), \\\"DBUtilli: Permission denied\\\");\\r\\n\\t\\taddr = _getIndexMapping(uid);\\r\\n        return addr;\\r\\n\\t}\\r\\n\\r\\n    /**\\r\\n     * @dev get the user address of the corresponding User info (db)\\r\\n     * Authorization Required or addr is owner\\r\\n     * @param addr user address\\r\\n     * @return info[id,status],code,rCode\\r\\n     */\\r\\n    function getUserInfo(address addr)\\r\\n        public\\r\\n        view\\r\\n        returns (uint[2] memory info, string memory code, string memory rCode)\\r\\n    {\\r\\n        require(checkWhitelist() || _msgSender() == addr, \\\"DBUtilli: Permission denied for view user\\u0027s privacy\\\");\\r\\n        (info, code, rCode) = _getUserInfo(addr);\\r\\n\\t\\treturn (info, code, rCode);\\r\\n\\t}\\r\\n}\\r\\n\"},\"HumanChsek.sol\":{\"content\":\"pragma solidity ^0.5.11;\\r\\n\\r\\nimport \\u0027./Context.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title HumanChsek\\r\\n * @dev This Provide check address is contract\\r\\n */\\r\\ncontract HumanChsek is Context {\\r\\n\\r\\n    /**\\r\\n     * @dev modifier to scope access to a Contract (uses tx.origin and msg.sender)\\r\\n     */\\r\\n\\tmodifier isHuman() {\\r\\n\\t\\trequire(_msgSender() == _txOrigin(), \\\"HumanChsek: sorry, humans only\\\");\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\"},\"IDB.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @title DB interface\\r\\n * @dev This Provide database support services interface\\r\\n */\\r\\ncontract IDB {\\r\\n    function registerUser(address addr, string memory code, string memory rCode) public;\\r\\n    function setUser(address addr, uint status) public;\\r\\n    function isUsedCode(string memory code) public view returns (bool);\\r\\n    function getCodeMapping(string memory code) public view returns (address);\\r\\n    function getIndexMapping(uint uid) public view returns (address);\\r\\n    function getUserInfo(address addr) public view returns (uint[2] memory info, string memory code, string memory rCode);\\r\\n    function getCurrentUserID() public view returns (uint);\\r\\n    function getRCodeMappingLength(string memory rCode) public view returns (uint);\\r\\n    function getRCodeMapping(string memory rCode, uint index) public view returns (string memory);\\r\\n}\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\nimport \\u0027./Context.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnerTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n\\t */\\r\\n    constructor () internal {\\r\\n        _owner = _msgSender();\\r\\n        emit OwnerTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev modifier Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(), \\\"Ownable: it is not called by the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the caller is the current owner.\\r\\n     * @return bool\\r\\n     */\\r\\n    function isOwner()\\r\\n        internal\\r\\n        view\\r\\n        returns(bool)\\r\\n    {\\r\\n        return _msgSender() == _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     * @param newOwner The address to transfer ownership to.\\r\\n     */\\r\\n    function transferOwnership(address newOwner)\\r\\n        public\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(newOwner != address(0),\\u0027Ownable: new owner is the zero address\\u0027);\\r\\n        emit OwnerTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner()\\r\\n        public\\r\\n        view\\r\\n        returns(address)\\r\\n    {\\r\\n        return _owner;\\r\\n    }\\r\\n}\"},\"RBAC.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\nimport \\u0027./Context.sol\\u0027;\\r\\nimport \\u0027./Roles.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title RBAC (Role-Based Access Control)\\r\\n * @author Matt Condon (@Shrugs)\\r\\n * @dev Stores and provides setters and getters for roles and addresses.\\r\\n * Supports unlimited numbers of roles and addresses.\\r\\n * See //contracts/mocks/RBACMock.sol for an example of usage.\\r\\n * This RBAC method uses strings to key roles. It may be beneficial\\r\\n * for you to write your own implementation of this interface using Enums or similar.\\r\\n */\\r\\ncontract RBAC is Context {\\r\\n    using Roles for Roles.Role;\\r\\n\\r\\n    mapping (string =\\u003e Roles.Role) private roles;\\r\\n\\r\\n    event RoleAdded(address indexed operator, string role);\\r\\n    event RoleRemoved(address indexed operator, string role);\\r\\n\\r\\n    /**\\r\\n     * @dev modifier to scope access to a single role (uses msg.sender as addr)\\r\\n     * @param _role the name of the role\\r\\n     * // reverts\\r\\n     */\\r\\n    modifier onlyRole(string memory _role)\\r\\n    {\\r\\n        checkRole(_msgSender(), _role);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev add a role to an address\\r\\n     * @param _operator address\\r\\n     * @param _role the name of the role\\r\\n     */\\r\\n    function addRole(address _operator, string memory _role)\\r\\n        internal\\r\\n    {\\r\\n        roles[_role].add(_operator);\\r\\n        emit RoleAdded(_operator, _role);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev remove a role from an address\\r\\n     * @param _operator address\\r\\n     * @param _role the name of the role\\r\\n     */\\r\\n    function removeRole(address _operator, string memory _role)\\r\\n        internal\\r\\n    {\\r\\n        roles[_role].remove(_operator);\\r\\n        emit RoleRemoved(_operator, _role);\\r\\n    }\\r\\n\\r\\n        /**\\r\\n     * @dev reverts if addr does not have role\\r\\n     * @param _operator address\\r\\n     * @param _role the name of the role\\r\\n     * // reverts\\r\\n     */\\r\\n    function checkRole(address _operator, string memory _role)\\r\\n        internal\\r\\n        view\\r\\n    {\\r\\n        roles[_role].check(_operator);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev determine if addr has role\\r\\n     * @param _operator address\\r\\n     * @param _role the name of the role\\r\\n     * @return bool\\r\\n     */\\r\\n    function hasRole(address _operator, string memory _role)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return roles[_role].has(_operator);\\r\\n    }\\r\\n}\\r\\n\"},\"Roles.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @title Roles\\r\\n * @dev Library for managing addresses assigned to a Role.\\r\\n */\\r\\nlibrary Roles {\\r\\n    struct Role {\\r\\n        mapping (address =\\u003e bool) bearer;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev give an address access to this role\\r\\n     */\\r\\n    function add(Role storage _role, address _addr)\\r\\n        internal\\r\\n    {\\r\\n        require(!has(_role, _addr), \\\"Roles: addr already has role\\\");\\r\\n        _role.bearer[_addr] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev remove an address\\u0027 access to this role\\r\\n     */\\r\\n    function remove(Role storage _role, address _addr)\\r\\n        internal\\r\\n    {\\r\\n        require(has(_role, _addr), \\\"Roles: addr do not have role\\\");\\r\\n        _role.bearer[_addr] = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev check if an address has this role\\r\\n     * // reverts\\r\\n     */\\r\\n    function check(Role storage _role, address _addr)\\r\\n        internal\\r\\n        view\\r\\n    {\\r\\n        require(has(_role, _addr),\\u0027Roles: addr do not have role\\u0027);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev check if an address has this role\\r\\n     * @return bool\\r\\n     */\\r\\n    function has(Role storage _role, address _addr)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        require(_addr != address(0), \\\"Roles: not the zero address\\\");\\r\\n        return _role.bearer[_addr];\\r\\n    }\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"},\"String.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @title String\\r\\n * @dev This integrates the basic functions.\\r\\n */\\r\\nlibrary String {\\r\\n    /**\\r\\n     * @dev determine if strings are equal\\r\\n     * @param _str1 strings\\r\\n     * @param _str2 strings\\r\\n     * @return bool\\r\\n     */\\r\\n    function compareStr(string memory _str1, string memory _str2)\\r\\n        internal\\r\\n        pure\\r\\n        returns(bool)\\r\\n    {\\r\\n        if(keccak256(abi.encodePacked(_str1)) == keccak256(abi.encodePacked(_str2))) {\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n}\"},\"Whitelist.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\nimport \\u0027./Context.sol\\u0027;\\r\\nimport \\u0027./Ownable.sol\\u0027;\\r\\nimport \\u0027./Roles.sol\\u0027;\\r\\nimport \\u0027./RBAC.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title Whitelist\\r\\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\\r\\n * This simplifies the implementation of \\\"user permissions\\\".\\r\\n */\\r\\ncontract Whitelist is Context, Ownable, RBAC {\\r\\n    string private constant ROLE_WHITELISTED = \\\"whitelist\\\";\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if operator is not whitelisted.\\r\\n     */\\r\\n    modifier onlyIfWhitelisted() {\\r\\n        require(isWhitelist(_msgSender()), \\\"Whitelist: The operator is not whitelisted\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev check current operator is in whitelist\\r\\n     * @return bool\\r\\n     */\\r\\n    function checkWhitelist()\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return isWhitelist(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev add an address to the whitelist\\r\\n     * @param _operator address\\r\\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\\r\\n     */\\r\\n    function addAddressToWhitelist(address _operator)\\r\\n        public\\r\\n        onlyOwner\\r\\n    {\\r\\n        addRole(_operator, ROLE_WHITELISTED);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev add addresses to the whitelist\\r\\n     * @param _operators addresses\\r\\n     * @return true if at least one address was added to the whitelist,\\r\\n     * false if all addresses were already in the whitelist\\r\\n     */\\r\\n    function addAddressesToWhitelist(address[] memory _operators)\\r\\n        public\\r\\n        onlyOwner\\r\\n    {\\r\\n        for (uint256 i = 0; i \\u003c _operators.length; i++) {\\r\\n            addAddressToWhitelist(_operators[i]);\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * @dev remove an address from the whitelist\\r\\n     * @param _operator address\\r\\n     * @return true if the address was removed from the whitelist,\\r\\n     * false if the address wasn\\u0027t in the whitelist in the first place\\r\\n     */\\r\\n    function removeAddressFromWhitelist(address _operator)\\r\\n        public\\r\\n        onlyOwner\\r\\n    {\\r\\n        removeRole(_operator, ROLE_WHITELISTED);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev remove addresses from the whitelist\\r\\n     * @param _operators addresses\\r\\n     * @return true if at least one address was removed from the whitelist,\\r\\n     * false if all addresses weren\\u0027t in the whitelist in the first place\\r\\n     */\\r\\n    function removeAddressesFromWhitelist(address[] memory _operators)\\r\\n        public\\r\\n        onlyOwner\\r\\n    {\\r\\n        for (uint256 i = 0; i \\u003c _operators.length; i++) {\\r\\n            removeAddressFromWhitelist(_operators[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev determine if address is in whitelist\\r\\n     * @param _operator address\\r\\n     * @return bool\\r\\n     */\\r\\n    function isWhitelist(address _operator)\\r\\n        public\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return hasRole(_operator, ROLE_WHITELISTED) || isOwner();\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"getBurnScaleByLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"getNodeLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_operators\",\"type\":\"address[]\"}],\"name\":\"removeAddressesFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"times\",\"type\":\"uint256\"}],\"name\":\"getRecommendScaleByLevelAndTim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"actSetStartTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getLineUserId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stateView\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"actEndRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardIndex\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"useRewardIndex\",\"type\":\"bool\"}],\"name\":\"getUserByAddress\",\"outputs\":[{\"internalType\":\"uint256[17]\",\"name\":\"info\",\"type\":\"uint256[17]\"},{\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"rCode\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"}],\"name\":\"isUsedCode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isUser\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"info\",\"type\":\"uint256[2]\"},{\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"rCode\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"rCode\",\"type\":\"string\"}],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"getLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"getScaleByLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"actUserStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"settlement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"line\",\"type\":\"uint256\"}],\"name\":\"actUpdateLine\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_val\",\"type\":\"uint256\"}],\"name\":\"sendMoneyToAddr\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bonuslimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sendLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawLimit\",\"type\":\"uint256\"}],\"name\":\"actAllLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"}],\"name\":\"getIndexMapping\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"isUID\",\"type\":\"uint256\"}],\"name\":\"calculationBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_operators\",\"type\":\"address[]\"}],\"name\":\"addAddressesToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"}],\"name\":\"getCodeMapping\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dbAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_devAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_foundationAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_code\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_rCode\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"InvestEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"WithdrawEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"TransferEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerTransferred\",\"type\":\"event\"}]","ContractName":"HYPlay","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000858707162802468107d1840617854859629e5ab6000000000000000000000000835e86456f9876378461cbf80823a06651a33f70000000000000000000000000e3a45d119c7713c62541bfa0dc3cae3f72eeaaf0","Library":"","LicenseType":"None","SwarmSource":"bzzr://61fd97ff5c28eb79c56c9260d19a8b994ef862d3a03c87fb8ab257f94e62aa50"}]}