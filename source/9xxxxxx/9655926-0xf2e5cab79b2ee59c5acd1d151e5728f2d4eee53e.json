{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.1;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface ERC2477 {\r\n  \r\n  function tokenURIIntegrity(uint256 tokenId) external view returns(bytes memory digest, string memory hashAlgorithm);\r\n\r\n  \r\n  function tokenURISchemaIntegrity(uint256 tokenId) external view returns(bytes memory digest, string memory hashAlgorithm);\r\n}\r\n\r\ninterface Xcert {\r\n\r\n  \r\n  function create(\r\n    address _to,\r\n    uint256 _id,\r\n    bytes32 _imprint\r\n  )\r\n    external;\r\n\r\n  \r\n  function setUri(\r\n    string calldata _uriPrefix,\r\n    string calldata _uriPostfix\r\n  )\r\n    external;\r\n\r\n}\r\n\r\ninterface XcertBurnable {\r\n\r\n  \r\n  function destroy(\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n}\r\n\r\ninterface XcertMutable {\r\n\r\n  \r\n  function updateTokenURIIntegrityDigest(\r\n    uint256 _tokenId,\r\n    bytes32 _tokenURIIntegrityDigest\r\n  )\r\n    external;\r\n\r\n}\r\n\r\ninterface XcertPausable {\r\n\r\n  \r\n  function setPause(\r\n    bool _isPaused\r\n  )\r\n    external;\r\n\r\n}\r\n\r\ninterface XcertRevokable {\r\n\r\n  \r\n  function revoke(\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  \r\n  string constant OVERFLOW = \"008001\";\r\n  string constant SUBTRAHEND_GREATER_THEN_MINUEND = \"008002\";\r\n  string constant DIVISION_BY_ZERO = \"008003\";\r\n\r\n  \r\n  function mul(\r\n    uint256 _factor1,\r\n    uint256 _factor2\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 product)\r\n  {\r\n    \r\n    \r\n    \r\n    if (_factor1 == 0)\r\n    {\r\n      return 0;\r\n    }\r\n\r\n    product = _factor1 * _factor2;\r\n    require(product / _factor1 == _factor2, OVERFLOW);\r\n  }\r\n\r\n  \r\n  function div(\r\n    uint256 _dividend,\r\n    uint256 _divisor\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 quotient)\r\n  {\r\n    \r\n    require(_divisor > 0, DIVISION_BY_ZERO);\r\n    quotient = _dividend / _divisor;\r\n    \r\n  }\r\n\r\n  \r\n  function sub(\r\n    uint256 _minuend,\r\n    uint256 _subtrahend\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 difference)\r\n  {\r\n    require(_subtrahend <= _minuend, SUBTRAHEND_GREATER_THEN_MINUEND);\r\n    difference = _minuend - _subtrahend;\r\n  }\r\n\r\n  \r\n  function add(\r\n    uint256 _addend1,\r\n    uint256 _addend2\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 sum)\r\n  {\r\n    sum = _addend1 + _addend2;\r\n    require(sum >= _addend1, OVERFLOW);\r\n  }\r\n\r\n  \r\n  function mod(\r\n    uint256 _dividend,\r\n    uint256 _divisor\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 remainder)\r\n  {\r\n    require(_divisor != 0, DIVISION_BY_ZERO);\r\n    remainder = _dividend % _divisor;\r\n  }\r\n\r\n}\r\n\r\ncontract Abilitable {\r\n  using SafeMath for uint;\r\n\r\n  \r\n  string constant NOT_AUTHORIZED = \"017001\";\r\n  string constant INVALID_INPUT = \"017002\";\r\n\r\n  \r\n  uint8 constant SUPER_ABILITY = 1;\r\n\r\n  \r\n  uint8 constant ALLOW_SUPER_ABILITY = 2;\r\n\r\n  \r\n  uint8 constant EMPTY_SLOT_1 = 4;\r\n\r\n  \r\n  uint8 constant EMPTY_SLOT_2 = 8;\r\n\r\n  \r\n  uint8 constant ALL_DEFAULT_ABILITIES = 15;\r\n\r\n  \r\n  mapping(address => uint256) public addressToAbility;\r\n\r\n  \r\n  event SetAbilities(\r\n    address indexed _target,\r\n    uint256 indexed _abilities\r\n  );\r\n\r\n  \r\n  modifier hasAbilities(\r\n    uint256 _abilities\r\n  )\r\n  {\r\n    require(_abilities > 0, INVALID_INPUT);\r\n    require(\r\n      addressToAbility[msg.sender] & _abilities == _abilities,\r\n      NOT_AUTHORIZED\r\n    );\r\n    _;\r\n  }\r\n\r\n  \r\n  constructor()\r\n    public\r\n  {\r\n    addressToAbility[msg.sender] = ALL_DEFAULT_ABILITIES;\r\n  }\r\n\r\n  \r\n  function grantAbilities(\r\n    address _target,\r\n    uint256 _abilities\r\n  )\r\n    external\r\n    hasAbilities(SUPER_ABILITY)\r\n  {\r\n    addressToAbility[_target] |= _abilities;\r\n    emit SetAbilities(_target, addressToAbility[_target]);\r\n  }\r\n\r\n  \r\n  function revokeAbilities(\r\n    address _target,\r\n    uint256 _abilities\r\n  )\r\n    external\r\n    hasAbilities(SUPER_ABILITY)\r\n  {\r\n    addressToAbility[_target] &= ~_abilities;\r\n    emit SetAbilities(_target, addressToAbility[_target]);\r\n  }\r\n\r\n  \r\n  function setAbilities(\r\n    address _target,\r\n    uint256 _abilities\r\n  )\r\n    external\r\n    hasAbilities(SUPER_ABILITY)\r\n  {\r\n    addressToAbility[_target] = _abilities;\r\n    emit SetAbilities(_target, _abilities);\r\n  }\r\n\r\n  \r\n  function isAble(\r\n    address _target,\r\n    uint256 _abilities\r\n  )\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(_abilities > 0, INVALID_INPUT);\r\n    return (addressToAbility[_target] & _abilities) == _abilities;\r\n  }\r\n\r\n}\r\n\r\ninterface ERC721 {\r\n\r\n  \r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  \r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  \r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  \r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external;\r\n\r\n  \r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  \r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  \r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  \r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external;\r\n\r\n  \r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  \r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  \r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  \r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n}\r\n\r\ninterface ERC721Metadata {\r\n\r\n  \r\n  function name()\r\n    external\r\n    view\r\n    returns (string memory _name);\r\n\r\n  \r\n  function symbol()\r\n    external\r\n    view\r\n    returns (string memory _symbol);\r\n\r\n  \r\n  function tokenURI(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns (string memory);\r\n\r\n}\r\n\r\ninterface ERC721Enumerable {\r\n\r\n  \r\n  function totalSupply()\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  \r\n  function tokenByIndex(\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  \r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n}\r\n\r\ninterface ERC721TokenReceiver {\r\n\r\n  \r\n  function onERC721Received(\r\n    address _operator,\r\n    address _from,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n    returns(bytes4);\r\n\r\n}\r\n\r\ninterface ERC165 {\r\n\r\n  \r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n}\r\n\r\ncontract SupportsInterface is\r\n  ERC165\r\n{\r\n\r\n  \r\n  mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n  \r\n  constructor()\r\n    public\r\n  {\r\n    supportedInterfaces[0x01ffc9a7] = true; \r\n  }\r\n\r\n  \r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (bool)\r\n  {\r\n    return supportedInterfaces[_interfaceID];\r\n  }\r\n\r\n}\r\n\r\nlibrary AddressUtils {\r\n\r\n  \r\n  function isDeployedContract(\r\n    address _addr\r\n  )\r\n    internal\r\n    view\r\n    returns (bool addressCheck)\r\n  {\r\n    uint256 size;\r\n    assembly { size := extcodesize(_addr) } \r\n    addressCheck = size > 0;\r\n  }\r\n\r\n}\r\n\r\ncontract NFTokenMetadataEnumerable is\r\n  ERC721,\r\n  ERC721Metadata,\r\n  ERC721Enumerable,\r\n  SupportsInterface\r\n{\r\n  using SafeMath for uint256;\r\n  using AddressUtils for address;\r\n\r\n  \r\n  string constant ZERO_ADDRESS = \"006001\";\r\n  string constant NOT_VALID_NFT = \"006002\";\r\n  string constant NOT_OWNER_OR_OPERATOR = \"006003\";\r\n  string constant NOT_OWNER_APPROWED_OR_OPERATOR = \"006004\";\r\n  string constant NOT_ABLE_TO_RECEIVE_NFT = \"006005\";\r\n  string constant NFT_ALREADY_EXISTS = \"006006\";\r\n  string constant INVALID_INDEX = \"006007\";\r\n\r\n  \r\n  bytes4 constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  \r\n  string internal nftName;\r\n\r\n  \r\n  string internal nftSymbol;\r\n\r\n  \r\n  string public uriPrefix;\r\n\r\n  \r\n  string public uriPostfix;\r\n\r\n  \r\n  uint256[] internal tokens;\r\n\r\n  \r\n  mapping(uint256 => uint256) internal idToIndex;\r\n\r\n  \r\n  mapping(address => uint256[]) internal ownerToIds;\r\n\r\n  \r\n  mapping(uint256 => uint256) internal idToOwnerIndex;\r\n\r\n  \r\n  mapping (uint256 => address) internal idToOwner;\r\n\r\n  \r\n  mapping (uint256 => address) internal idToApproval;\r\n\r\n  \r\n  mapping (address => mapping (address => bool)) internal ownerToOperators;\r\n\r\n  \r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  \r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  \r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  \r\n  constructor()\r\n    public\r\n  {\r\n    supportedInterfaces[0x80ac58cd] = true; \r\n    supportedInterfaces[0x5b5e139f] = true; \r\n    supportedInterfaces[0x780e9d63] = true; \r\n  }\r\n\r\n  \r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n    override\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, _data);\r\n  }\r\n\r\n  \r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  \r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n  {\r\n    _transferFrom(_from, _to, _tokenId);\r\n  }\r\n\r\n  \r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n  {\r\n    \r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(\r\n      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\r\n      NOT_OWNER_OR_OPERATOR\r\n    );\r\n\r\n    idToApproval[_tokenId] = _approved;\r\n    emit Approval(tokenOwner, _approved, _tokenId);\r\n  }\r\n\r\n  \r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external\r\n    override\r\n  {\r\n    ownerToOperators[msg.sender][_operator] = _approved;\r\n    emit ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n  \r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_owner != address(0), ZERO_ADDRESS);\r\n    return ownerToIds[_owner].length;\r\n  }\r\n\r\n  \r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (address _owner)\r\n  {\r\n    _owner = idToOwner[_tokenId];\r\n    require(_owner != address(0), NOT_VALID_NFT);\r\n  }\r\n\r\n  \r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (address)\r\n  {\r\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\r\n    return idToApproval[_tokenId];\r\n  }\r\n\r\n  \r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (bool)\r\n  {\r\n    return ownerToOperators[_owner][_operator];\r\n  }\r\n\r\n  \r\n  function totalSupply()\r\n    external\r\n    override\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return tokens.length;\r\n  }\r\n\r\n  \r\n  function tokenByIndex(\r\n    uint256 _index\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_index < tokens.length, INVALID_INDEX);\r\n    return tokens[_index];\r\n  }\r\n\r\n  \r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_index < ownerToIds[_owner].length, INVALID_INDEX);\r\n    return ownerToIds[_owner][_index];\r\n  }\r\n\r\n  \r\n  function name()\r\n    external\r\n    override\r\n    view\r\n    returns (string memory _name)\r\n  {\r\n    _name = nftName;\r\n  }\r\n\r\n  \r\n  function symbol()\r\n    external\r\n    override\r\n    view\r\n    returns (string memory _symbol)\r\n  {\r\n    _symbol = nftSymbol;\r\n  }\r\n\r\n  \r\n  function tokenURI(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (string memory)\r\n  {\r\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\r\n    string memory uri = \"\";\r\n    if (bytes(uriPrefix).length > 0)\r\n    {\r\n      uri = string(abi.encodePacked(uriPrefix, _uint2str(_tokenId)));\r\n      if (bytes(uriPostfix).length > 0)\r\n      {\r\n        uri = string(abi.encodePacked(uri, uriPostfix));\r\n      }\r\n    }\r\n    return uri;\r\n  }\r\n\r\n  \r\n  function _setUri(\r\n    string memory _prefix,\r\n    string memory _postfix\r\n  )\r\n    internal\r\n  {\r\n    uriPrefix = _prefix;\r\n    uriPostfix = _postfix;\r\n  }\r\n\r\n  \r\n  function _create(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n\r\n    \r\n    idToOwner[_tokenId] = _to;\r\n\r\n    ownerToIds[_to].push(_tokenId);\r\n    idToOwnerIndex[_tokenId] = ownerToIds[_to].length - 1;\r\n\r\n    \r\n    tokens.push(_tokenId);\r\n    idToIndex[_tokenId] = tokens.length - 1;\r\n\r\n    emit Transfer(address(0), _to, _tokenId);\r\n  }\r\n\r\n  \r\n  function _destroy(\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    \r\n    address _owner = idToOwner[_tokenId];\r\n    require(_owner != address(0), NOT_VALID_NFT);\r\n\r\n    \r\n    if (idToApproval[_tokenId] != address(0))\r\n    {\r\n      delete idToApproval[_tokenId];\r\n    }\r\n\r\n    \r\n    assert(ownerToIds[_owner].length > 0);\r\n\r\n    uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\r\n    uint256 lastTokenIndex = ownerToIds[_owner].length - 1;\r\n    uint256 lastToken;\r\n    if (lastTokenIndex != tokenToRemoveIndex)\r\n    {\r\n      lastToken = ownerToIds[_owner][lastTokenIndex];\r\n      ownerToIds[_owner][tokenToRemoveIndex] = lastToken;\r\n      idToOwnerIndex[lastToken] = tokenToRemoveIndex;\r\n    }\r\n\r\n    delete idToOwner[_tokenId];\r\n    delete idToOwnerIndex[_tokenId];\r\n    ownerToIds[_owner].pop();\r\n\r\n    \r\n    assert(tokens.length > 0);\r\n\r\n    uint256 tokenIndex = idToIndex[_tokenId];\r\n    lastTokenIndex = tokens.length - 1;\r\n    lastToken = tokens[lastTokenIndex];\r\n\r\n    tokens[tokenIndex] = lastToken;\r\n\r\n    tokens.pop();\r\n    \r\n    idToIndex[lastToken] = tokenIndex;\r\n    idToIndex[_tokenId] = 0;\r\n\r\n    emit Transfer(_owner, address(0), _tokenId);\r\n  }\r\n\r\n  \r\n  function _transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    \r\n    require(_from != address(0), ZERO_ADDRESS);\r\n    require(idToOwner[_tokenId] == _from, NOT_VALID_NFT);\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n\r\n    \r\n    require(\r\n      _from == msg.sender\r\n      || idToApproval[_tokenId] == msg.sender\r\n      || ownerToOperators[_from][msg.sender],\r\n      NOT_OWNER_APPROWED_OR_OPERATOR\r\n    );\r\n\r\n    \r\n    if (idToApproval[_tokenId] != address(0))\r\n    {\r\n      delete idToApproval[_tokenId];\r\n    }\r\n\r\n    \r\n    assert(ownerToIds[_from].length > 0);\r\n\r\n    uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\r\n    uint256 lastTokenIndex = ownerToIds[_from].length - 1;\r\n\r\n    if (lastTokenIndex != tokenToRemoveIndex)\r\n    {\r\n      uint256 lastToken = ownerToIds[_from][lastTokenIndex];\r\n      ownerToIds[_from][tokenToRemoveIndex] = lastToken;\r\n      idToOwnerIndex[lastToken] = tokenToRemoveIndex;\r\n    }\r\n\r\n    ownerToIds[_from].pop();\r\n\r\n    \r\n    idToOwner[_tokenId] = _to;\r\n    ownerToIds[_to].push(_tokenId);\r\n    idToOwnerIndex[_tokenId] = ownerToIds[_to].length - 1;\r\n\r\n    emit Transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  \r\n  function _safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes memory _data\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    if (_to.isDeployedContract())\r\n    {\r\n      require(\r\n        ERC721TokenReceiver(_to)\r\n          .onERC721Received(msg.sender, _from, _tokenId, _data) == MAGIC_ON_ERC721_RECEIVED,\r\n        NOT_ABLE_TO_RECEIVE_NFT\r\n      );\r\n    }\r\n\r\n    _transferFrom(_from, _to, _tokenId);\r\n  }\r\n\r\n  \r\n  function _uint2str(\r\n    uint256 _i\r\n  )\r\n    internal\r\n    pure\r\n    returns (string memory str)\r\n  {\r\n    if (_i == 0)\r\n    {\r\n      return \"0\";\r\n    }\r\n    uint256 j = _i;\r\n    uint256 length;\r\n    while (j != 0)\r\n    {\r\n      length++;\r\n      j /= 10;\r\n    }\r\n    bytes memory bstr = new bytes(length);\r\n    uint256 k = length - 1;\r\n    j = _i;\r\n    while (j != 0)\r\n    {\r\n      bstr[k--] = byte(uint8(48 + j % 10));\r\n      j /= 10;\r\n    }\r\n    str = string(bstr);\r\n  }\r\n\r\n}\r\n\r\ninterface ERC20 {\r\n\r\n  \r\n  function name()\r\n    external\r\n    view\r\n    returns (string memory _name);\r\n\r\n  \r\n  function symbol()\r\n    external\r\n    view\r\n    returns (string memory _symbol);\r\n\r\n  \r\n  function decimals()\r\n    external\r\n    view\r\n    returns (uint8 _decimals);\r\n\r\n  \r\n  function totalSupply()\r\n    external\r\n    view\r\n    returns (uint256 _totalSupply);\r\n\r\n  \r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256 _balance);\r\n\r\n  \r\n  function transfer(\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    external\r\n    returns (bool _success);\r\n\r\n  \r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    external\r\n    returns (bool _success);\r\n\r\n  \r\n  function approve(\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    external\r\n    returns (bool _success);\r\n\r\n  \r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n  )\r\n    external\r\n    view\r\n    returns (uint256 _remaining);\r\n\r\n  \r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 _value\r\n  );\r\n\r\n  \r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _spender,\r\n    uint256 _value\r\n  );\r\n\r\n}\r\n\r\ncontract XcertToken is\r\n  ERC2477,\r\n  Xcert,\r\n  XcertBurnable,\r\n  XcertMutable,\r\n  XcertPausable,\r\n  XcertRevokable,\r\n  NFTokenMetadataEnumerable,\r\n  Abilitable\r\n{\r\n\r\n  \r\n  uint8 constant ABILITY_CREATE_ASSET = 16;\r\n  uint8 constant ABILITY_REVOKE_ASSET = 32;\r\n  uint8 constant ABILITY_TOGGLE_TRANSFERS = 64;\r\n  uint8 constant ABILITY_UPDATE_ASSET_URI_INTEGRITY_DIGEST = 128;\r\n  uint16 constant ABILITY_UPDATE_URI = 256;\r\n  \r\n  \r\n  \r\n  \r\n  \r\n\r\n  \r\n  bytes4 constant MUTABLE = 0x0d04c3b8;\r\n  bytes4 constant BURNABLE = 0x9d118770;\r\n  bytes4 constant PAUSABLE = 0xbedb86fb;\r\n  bytes4 constant REVOKABLE = 0x20c5429b;\r\n\r\n  \r\n  string constant HASH_ALGORITHM = 'sha256';\r\n\r\n  \r\n  string constant CAPABILITY_NOT_SUPPORTED = \"007001\";\r\n  string constant TRANSFERS_DISABLED = \"007002\";\r\n  string constant NOT_VALID_XCERT = \"007003\";\r\n  string constant NOT_XCERT_OWNER_OR_OPERATOR = \"007004\";\r\n  string constant INVALID_SIGNATURE = \"007005\";\r\n  string constant INVALID_SIGNATURE_KIND = \"007006\";\r\n  string constant CLAIM_PERFORMED = \"007007\";\r\n  string constant CLAIM_EXPIRED = \"007008\";\r\n  string constant CLAIM_CANCELED = \"007009\";\r\n  string constant NOT_OWNER = \"007010\";\r\n\r\n  \r\n  event IsPaused(bool isPaused);\r\n\r\n  \r\n  event TokenURIIntegrityDigestUpdate(\r\n    uint256 indexed _tokenId,\r\n    bytes32 _tokenURIIntegrityDigest\r\n  );\r\n\r\n  \r\n  enum SignatureKind\r\n  {\r\n    eth_sign,\r\n    trezor,\r\n    no_prefix\r\n  }\r\n\r\n  \r\n  struct SignatureData\r\n  {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n    SignatureKind kind;\r\n  }\r\n\r\n  \r\n  mapping(bytes32 => bool) public claimPerformed;\r\n\r\n  \r\n  mapping(bytes32 => bool) public claimCancelled;\r\n\r\n  \r\n  bytes32 internal schemaURIIntegrityDigest;\r\n\r\n  \r\n  mapping (uint256 => bytes32) internal idToIntegrityDigest;\r\n\r\n  \r\n  mapping (address => bool) internal addressToAuthorized;\r\n\r\n  \r\n  bool public isPaused;\r\n\r\n  \r\n  constructor()\r\n    public\r\n  {\r\n    supportedInterfaces[0x39541724] = true; \r\n  }\r\n\r\n  \r\n  function create(\r\n    address _to,\r\n    uint256 _id,\r\n    bytes32 _tokenURIIntegrityDigest\r\n  )\r\n    external\r\n    override\r\n    hasAbilities(ABILITY_CREATE_ASSET)\r\n  {\r\n    super._create(_to, _id);\r\n    idToIntegrityDigest[_id] = _tokenURIIntegrityDigest;\r\n  }\r\n\r\n  \r\n  function setUri(\r\n    string calldata _uriPrefix,\r\n    string calldata _uriPostfix\r\n  )\r\n    external\r\n    override\r\n    hasAbilities(ABILITY_UPDATE_URI)\r\n  {\r\n    super._setUri(_uriPrefix, _uriPostfix);\r\n  }\r\n\r\n  \r\n  function revoke(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    hasAbilities(ABILITY_REVOKE_ASSET)\r\n  {\r\n    require(supportedInterfaces[REVOKABLE], CAPABILITY_NOT_SUPPORTED);\r\n    super._destroy(_tokenId);\r\n    delete idToIntegrityDigest[_tokenId];\r\n  }\r\n\r\n  \r\n  function setPause(\r\n    bool _isPaused\r\n  )\r\n    external\r\n    override\r\n    hasAbilities(ABILITY_TOGGLE_TRANSFERS)\r\n  {\r\n    require(supportedInterfaces[PAUSABLE], CAPABILITY_NOT_SUPPORTED);\r\n    isPaused = _isPaused;\r\n    emit IsPaused(_isPaused);\r\n  }\r\n\r\n  \r\n  function updateTokenURIIntegrityDigest(\r\n    uint256 _tokenId,\r\n    bytes32 _tokenURIIntegrityDigest\r\n  )\r\n    external\r\n    override\r\n    hasAbilities(ABILITY_UPDATE_ASSET_URI_INTEGRITY_DIGEST)\r\n  {\r\n    require(supportedInterfaces[MUTABLE], CAPABILITY_NOT_SUPPORTED);\r\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_XCERT);\r\n    idToIntegrityDigest[_tokenId] = _tokenURIIntegrityDigest;\r\n    emit TokenURIIntegrityDigestUpdate(_tokenId, _tokenURIIntegrityDigest);\r\n  }\r\n\r\n  \r\n  function destroy(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n  {\r\n    require(supportedInterfaces[BURNABLE], CAPABILITY_NOT_SUPPORTED);\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    super._destroy(_tokenId);\r\n    require(\r\n      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\r\n      NOT_XCERT_OWNER_OR_OPERATOR\r\n    );\r\n    delete idToIntegrityDigest[_tokenId];\r\n  }\r\n\r\n  \r\n  function setApprovalForAllWithSignature(\r\n    address _owner,\r\n    address _operator,\r\n    bool _approved,\r\n    address _feeToken,\r\n    uint256 _feeValue,\r\n    address _feeRecipient,\r\n    uint256 _seed,\r\n    uint256 _expiration,\r\n    SignatureData calldata _signature\r\n  )\r\n    external\r\n  {\r\n    bytes32 claim = generateClaim(\r\n      _owner,\r\n      _operator,\r\n      _approved,\r\n      _feeToken,\r\n      _feeValue,\r\n      _feeRecipient,\r\n      _seed,\r\n      _expiration\r\n    );\r\n    require(!claimCancelled[claim], CLAIM_CANCELED);\r\n    require(\r\n      isValidSignature(\r\n        _owner,\r\n        claim,\r\n        _signature\r\n      ),\r\n      INVALID_SIGNATURE\r\n    );\r\n    require(!claimPerformed[claim], CLAIM_PERFORMED);\r\n    require(_expiration >= now, CLAIM_EXPIRED);\r\n    claimPerformed[claim] = true;\r\n    ownerToOperators[_owner][_operator] = _approved;\r\n    if (_feeRecipient == address(0)) {\r\n      _feeRecipient = msg.sender;\r\n    }\r\n    ERC20(_feeToken).transferFrom(_owner, _feeRecipient, _feeValue);\r\n    emit ApprovalForAll(_owner, _operator, _approved);\r\n  }\r\n\r\n  \r\n  function cancelSetApprovalForAllWithSignature(\r\n    address _owner,\r\n    address _operator,\r\n    bool _approved,\r\n    address _feeToken,\r\n    uint256 _feeValue,\r\n    address _feeRecipient,\r\n    uint256 _seed,\r\n    uint256 _expiration\r\n  )\r\n    external\r\n  {\r\n    require(msg.sender == _owner, NOT_OWNER);\r\n    bytes32 claim = generateClaim(\r\n      _owner,\r\n      _operator,\r\n      _approved,\r\n      _feeToken,\r\n      _feeValue,\r\n      _feeRecipient,\r\n      _seed,\r\n      _expiration\r\n    );\r\n    require(!claimPerformed[claim], CLAIM_PERFORMED);\r\n    claimCancelled[claim] = true;\r\n  }\r\n\r\n  \r\n  function generateClaim(\r\n    address _owner,\r\n    address _operator,\r\n    bool _approved,\r\n    address _feeToken,\r\n    uint256 _feeValue,\r\n    address _feeRecipient,\r\n    uint256 _seed,\r\n    uint256 _expiration\r\n  )\r\n    public\r\n    view\r\n    returns(bytes32)\r\n  {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        address(this),\r\n        _owner,\r\n        _operator,\r\n        _approved,\r\n        _feeToken,\r\n        _feeValue,\r\n        _feeRecipient,\r\n        _seed,\r\n        _expiration\r\n      )\r\n    );\r\n  }\r\n\r\n  \r\n  function isValidSignature(\r\n    address _signer,\r\n    bytes32 _claim,\r\n    SignatureData memory _signature\r\n  )\r\n    public\r\n    pure\r\n    returns (bool)\r\n  {\r\n    if (_signature.kind == SignatureKind.eth_sign)\r\n    {\r\n      return _signer == ecrecover(\r\n        keccak256(\r\n          abi.encodePacked(\r\n            \"\\x19Ethereum Signed Message:\\n32\",\r\n            _claim\r\n          )\r\n        ),\r\n        _signature.v,\r\n        _signature.r,\r\n        _signature.s\r\n      );\r\n    } else if (_signature.kind == SignatureKind.trezor)\r\n    {\r\n      return _signer == ecrecover(\r\n        keccak256(\r\n          abi.encodePacked(\r\n            \"\\x19Ethereum Signed Message:\\n\\x20\",\r\n            _claim\r\n          )\r\n        ),\r\n        _signature.v,\r\n        _signature.r,\r\n        _signature.s\r\n      );\r\n    } else if (_signature.kind == SignatureKind.no_prefix)\r\n    {\r\n      return _signer == ecrecover(\r\n        _claim,\r\n        _signature.v,\r\n        _signature.r,\r\n        _signature.s\r\n      );\r\n    }\r\n\r\n    revert(INVALID_SIGNATURE_KIND);\r\n  }\r\n\r\n  \r\n  function tokenURISchemaIntegrity(\r\n    uint256 tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns(bytes memory digest, string memory hashAlgorithm)\r\n  {\r\n    require(idToOwner[tokenId] != address(0), NOT_VALID_XCERT);\r\n    digest = abi.encodePacked(schemaURIIntegrityDigest);\r\n    hashAlgorithm = HASH_ALGORITHM;\r\n  }\r\n\r\n  \r\n  function tokenURIIntegrity(\r\n    uint256 tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns(bytes memory digest, string memory hashAlgorithm)\r\n  {\r\n    require(idToOwner[tokenId] != address(0), NOT_VALID_XCERT);\r\n    digest = abi.encodePacked(idToIntegrityDigest[tokenId]);\r\n    hashAlgorithm = HASH_ALGORITHM;\r\n  }\r\n\r\n  \r\n  function _transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    override\r\n  {\r\n    \r\n    require(!isPaused, TRANSFERS_DISABLED);\r\n    super._transferFrom(_from, _to, _tokenId);\r\n  }\r\n}\r\n\r\ncontract XcertCustom is XcertToken {\r\n\r\n  \r\n  uint8 constant ABILITY_NONE = 0;\r\n  uint16 constant ABILITY_ALL = 2047; \r\n\r\n  \r\n  constructor(\r\n    string memory _name,\r\n    string memory _symbol,\r\n    string memory _uriPrefix,\r\n    string memory _uriPostfix,\r\n    bytes32 _schemaURIIntegrityDigest,\r\n    bytes4[] memory _capabilities,\r\n    address[6] memory _addresses\r\n  )\r\n    public\r\n  {\r\n    nftName = _name;\r\n    nftSymbol = _symbol;\r\n    uriPrefix = _uriPrefix;\r\n    uriPostfix = _uriPostfix;\r\n    schemaURIIntegrityDigest = _schemaURIIntegrityDigest;\r\n    for(uint256 i = 0; i < _capabilities.length; i++)\r\n    {\r\n      supportedInterfaces[_capabilities[i]] = true;\r\n    }\r\n    addressToAbility[_addresses[1]] = ABILITY_CREATE_ASSET; \r\n    \r\n    addressToAbility[_addresses[2]] = ABILITY_UPDATE_ASSET_URI_INTEGRITY_DIGEST; \r\n    \r\n    addressToAbility[_addresses[3]] = SUPER_ABILITY; \r\n    \r\n    addressToAbility[msg.sender] = ABILITY_NONE;\r\n    addressToAbility[_addresses[0]] = ABILITY_ALL; \r\n    ownerToOperators[_addresses[0]][_addresses[4]] = true; \r\n    \r\n    ownerToOperators[_addresses[0]][_addresses[5]] = true; \r\n  }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_uriPrefix\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_uriPostfix\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"_schemaURIIntegrityDigest\",\"type\":\"bytes32\"},{\"internalType\":\"bytes4[]\",\"name\":\"_capabilities\",\"type\":\"bytes4[]\"},{\"internalType\":\"address[6]\",\"name\":\"_addresses\",\"type\":\"address[6]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"IsPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_abilities\",\"type\":\"uint256\"}],\"name\":\"SetAbilities\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_tokenURIIntegrityDigest\",\"type\":\"bytes32\"}],\"name\":\"TokenURIIntegrityDigestUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToAbility\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_feeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeValue\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiration\",\"type\":\"uint256\"}],\"name\":\"cancelSetApprovalForAllWithSignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"claimCancelled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"claimPerformed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_tokenURIIntegrityDigest\",\"type\":\"bytes32\"}],\"name\":\"create\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"destroy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_feeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeValue\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiration\",\"type\":\"uint256\"}],\"name\":\"generateClaim\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_abilities\",\"type\":\"uint256\"}],\"name\":\"grantAbilities\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_abilities\",\"type\":\"uint256\"}],\"name\":\"isAble\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_claim\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"enum XcertToken.SignatureKind\",\"name\":\"kind\",\"type\":\"uint8\"}],\"internalType\":\"struct XcertToken.SignatureData\",\"name\":\"_signature\",\"type\":\"tuple\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"revoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_abilities\",\"type\":\"uint256\"}],\"name\":\"revokeAbilities\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_abilities\",\"type\":\"uint256\"}],\"name\":\"setAbilities\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_feeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeValue\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiration\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"enum XcertToken.SignatureKind\",\"name\":\"kind\",\"type\":\"uint8\"}],\"internalType\":\"struct XcertToken.SignatureData\",\"name\":\"_signature\",\"type\":\"tuple\"}],\"name\":\"setApprovalForAllWithSignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isPaused\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uriPrefix\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_uriPostfix\",\"type\":\"string\"}],\"name\":\"setUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURIIntegrity\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"digest\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"hashAlgorithm\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURISchemaIntegrity\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"digest\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"hashAlgorithm\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_tokenURIIntegrityDigest\",\"type\":\"bytes32\"}],\"name\":\"updateTokenURIIntegrityDigest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uriPostfix\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uriPrefix\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"XcertCustom","CompilerVersion":"v0.6.1+commit.e6f7d5a4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000260cd3d7fce94669724f964061572f42ae0391996b0e348c7431251f9ab1bab0f4900000000000000000000000000000000000000000000000000000000000002a0000000000000000000000000f9196f9f176fd2ef9243e8960817d5fbe63d79aa0000000000000000000000006eefae076aa3a4f83cecde690672d5735f169ace0000000000000000000000002c3ba3407aa5650aba7101e20bd99bc5f9b0e4d00000000000000000000000006ad81cc888270ea2258adafe270100eebec124490000000000000000000000005522c775ae13a2763b0b1711633de3e1bf37848f000000000000000000000000744e60db927f62bd9853fbba61029f770c179e56000000000000000000000000000000000000000000000000000000000000000a44697274792047616d650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024447000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002668747470733a2f2f646972747967616d652e3078636572742e6f72672f6d657461646174612f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052e6a736f6e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010d04c3b800000000000000000000000000000000000000000000000000000000","Library":"","LicenseType":"MIT","SwarmSource":"ipfs://4574c5994c4e770a143ad25f63b9804d1c5a684f6a61f19a40daaca0540a2271"}]}