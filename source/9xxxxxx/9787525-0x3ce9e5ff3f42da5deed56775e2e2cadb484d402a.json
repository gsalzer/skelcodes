{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.3;\r\n\r\ncontract BrightID {\r\n    uint256 public id;\r\n\r\n    struct Context {\r\n        bool isActive;\r\n        mapping(address => bool) owners;\r\n        mapping(address => bool) nodes;\r\n        mapping(uint256 => address[]) accounts;\r\n        mapping(bytes32 => uint256) cIdToUid;\r\n        mapping(address => uint256) ethToUid;\r\n    }\r\n\r\n    mapping(bytes32 => Context) private contexts;\r\n\r\n    string private constant DUPLICATE_ETHEREUM_ADDRESS = \"Duplicate ethereum address\";\r\n    string private constant DUPLICATE_CONTEXT_ID = \"Duplicate context id\";\r\n    string private constant ONLY_CONTEXT_OWNER = \"Only context owner\";\r\n    string private constant UNAUTHORIZED_NODE = \"Unauthorized node\";\r\n    string private constant CONTEXT_NOT_FOUND = \"Context not found\";\r\n    string private constant NODE_NOT_FOUND = \"Node not found\";\r\n    string private constant ALREADY_EXISTS = \"Already exists\";\r\n    string private constant BAD_SIGNATURE = \"Bad signature\";\r\n    string private constant NO_CONTEXT_ID = \"No context id\";\r\n\r\n    /// Events\r\n    event ContextAdded(bytes32 indexed context, address indexed owner);\r\n    event ContextOwnerAdded(bytes32 indexed context, address owner);\r\n    event ContextOwnerRemoved(bytes32 indexed context, address owner);\r\n    event NodeAddedToContext(bytes32 indexed context, address nodeAddress);\r\n    event NodeRemovedFromContext(bytes32 indexed context, address nodeAddress);\r\n    event AddressLinked(bytes32 context, bytes32 contextId, address ethAddress);\r\n    event SponsorshipRequested(bytes32 indexed context, bytes32 indexed contextid);\r\n\r\n    constructor()\r\n        public\r\n    {\r\n        id = 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Check whether the context has been added to the smart contract using `addContext`.\r\n     * @param context The context.\r\n     * @return has the context been added?\r\n     */\r\n    function isContext(bytes32 context)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return contexts[context].isActive;\r\n    }\r\n\r\n    /**\r\n     * @notice Check whether `nodeAddress`'s signature is acceptable for the context.\r\n     * @param context The context.\r\n     * @param nodeAddress The node's address.\r\n     * @return can `nodeAddress` sign requests for this context?\r\n     */\r\n    function isNodeInContext(bytes32 context, address nodeAddress)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return contexts[context].nodes[nodeAddress];\r\n    }\r\n\r\n    /**\r\n     * @dev get uid.\r\n     * @param context The context.\r\n     * @param cIds an array of contextIds.\r\n     */\r\n    function getUid(bytes32 context, bytes32[] memory cIds)\r\n        internal\r\n        returns(uint256)\r\n    {\r\n        for(uint256 i=1; i < cIds.length-1; i++) {\r\n            uint256 uid = contexts[context].cIdToUid[cIds[i]];\r\n            if (uid != 0) {\r\n                return uid;\r\n            }\r\n        }\r\n        return ++id;\r\n    }\r\n\r\n    /**\r\n     * @notice Link `cIds[0]` to `msg.sender` under `context`.\r\n     * @param context The context.\r\n     * @param cIds an array of contextIds.\r\n     * @param v signature's v.\r\n     * @param r signature's r.\r\n     * @param s signature's s.\r\n     */\r\n    function register(\r\n        bytes32 context,\r\n        bytes32[] memory cIds,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s)\r\n        public\r\n    {\r\n        require(isContext(context), CONTEXT_NOT_FOUND);\r\n        require(0 < cIds.length, NO_CONTEXT_ID);\r\n        require(contexts[context].cIdToUid[cIds[0]] == 0, DUPLICATE_CONTEXT_ID);\r\n        require(contexts[context].ethToUid[msg.sender] == 0, DUPLICATE_ETHEREUM_ADDRESS);\r\n\r\n        bytes32 message = keccak256(abi.encodePacked(context, cIds));\r\n        address signerAddress = ecrecover(message, v, r, s);\r\n        require(signerAddress != address(0), BAD_SIGNATURE);\r\n        require(contexts[context].nodes[signerAddress], UNAUTHORIZED_NODE);\r\n\r\n        uint256 uid = getUid(context, cIds);\r\n\r\n        contexts[context].ethToUid[msg.sender] = uid;\r\n\r\n        for(uint256 i=0; i < cIds.length-1; i++) {\r\n            contexts[context].cIdToUid[cIds[i]] = uid;\r\n        }\r\n\r\n        // The last member of contexts[context].accounts[uid] is active address of the user\r\n        contexts[context].accounts[uid].push(msg.sender);\r\n\r\n        emit AddressLinked(context, cIds[0], msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Check that `ethAddress` is the mostly recently used address by a unique human in the context.\r\n     * Also return any addresses previously used by this unique human.\r\n     * @param ethAddress an Ethereum address.\r\n     * @param context the context.\r\n     * @return is `ethAddress` the most recently used address by a unique human in the `context`.\r\n     * @return addresses previously used by this unique human.\r\n     */\r\n    function isUniqueHuman(\r\n        address ethAddress,\r\n        bytes32 context)\r\n        public\r\n        view\r\n        returns(bool, address[] memory)\r\n    {\r\n        uint256 uid = contexts[context].ethToUid[ethAddress];\r\n        if (uid != 0) {\r\n            uint256 lastIndex = contexts[context].accounts[uid].length - 1;\r\n            if (contexts[context].accounts[uid][lastIndex] == ethAddress) {\r\n                return(true, contexts[context].accounts[uid]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Submit a request to sponsor `contextid` under `context`.\r\n     * @param context The context.\r\n     * @param contextid The contextid.\r\n     */\r\n    function sponsor(bytes32 context, bytes32 contextid)\r\n        public\r\n        onlyContextOwner(context)\r\n    {\r\n        emit SponsorshipRequested(context, contextid);\r\n    }\r\n\r\n    /**\r\n     * @notice Add a context.\r\n     * @param context The context.\r\n     */\r\n    function addContext(bytes32 context)\r\n        public\r\n    {\r\n        require(contexts[context].isActive != true, ALREADY_EXISTS);\r\n\r\n        contexts[context].isActive = true;\r\n        contexts[context].owners[msg.sender] = true;\r\n        emit ContextAdded(context, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Add a context owner.\r\n     * @param context The context.\r\n     * @param owner The address of the context owner to be added.\r\n     */\r\n    function addContextOwner(bytes32 context, address owner)\r\n        public\r\n        onlyContextOwner(context)\r\n    {\r\n        contexts[context].owners[owner] = true;\r\n        emit ContextOwnerAdded(context, owner);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove a context owner.\r\n     * @param context The context.\r\n     * @param owner The address of the context owner to be removed.\r\n     */\r\n    function removeContextOwner(bytes32 context, address owner)\r\n        public\r\n        onlyContextOwner(context)\r\n    {\r\n        contexts[context].owners[owner] = false;\r\n        emit ContextOwnerRemoved(context, owner);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Check that `owner` is a owner of `context`.\r\n     * @param context The context.\r\n     * @param owner The new context's owner.\r\n     */\r\n    function isContextOwner(bytes32 context, address owner)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return contexts[context].owners[owner];\r\n    }\r\n\r\n    /**\r\n     * @notice Add `nodeAddress` as a node to the context.\r\n     * @param context The context.\r\n     * @param nodeAddress The node's address.\r\n     */\r\n    function addNodeToContext(bytes32 context, address nodeAddress)\r\n        public\r\n        onlyContextOwner(context)\r\n    {\r\n        require(isContext(context), CONTEXT_NOT_FOUND);\r\n        require(contexts[context].nodes[nodeAddress] != true, ALREADY_EXISTS);\r\n\r\n        contexts[context].nodes[nodeAddress] = true;\r\n        emit NodeAddedToContext(context, nodeAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove `nodeAddress` from the context's nodes.\r\n     * @param context The context.\r\n     * @param nodeAddress The node's address.\r\n     */\r\n    function removeNodeFromContext(bytes32 context, address nodeAddress)\r\n        public\r\n        onlyContextOwner(context)\r\n    {\r\n        require(isContext(context), CONTEXT_NOT_FOUND);\r\n        require(contexts[context].nodes[nodeAddress] == true, NODE_NOT_FOUND);\r\n\r\n        contexts[context].nodes[nodeAddress] = false;\r\n        emit NodeRemovedFromContext(context, nodeAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner of the context.\r\n     * @param context The context.\r\n     */\r\n    modifier onlyContextOwner(bytes32 context) {\r\n        require(contexts[context].owners[msg.sender], ONLY_CONTEXT_OWNER);\r\n        _;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"contextId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ethAddress\",\"type\":\"address\"}],\"name\":\"AddressLinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ContextAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ContextOwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ContextOwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nodeAddress\",\"type\":\"address\"}],\"name\":\"NodeAddedToContext\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nodeAddress\",\"type\":\"address\"}],\"name\":\"NodeRemovedFromContext\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"contextid\",\"type\":\"bytes32\"}],\"name\":\"SponsorshipRequested\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"}],\"name\":\"addContext\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"addContextOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"nodeAddress\",\"type\":\"address\"}],\"name\":\"addNodeToContext\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"id\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"}],\"name\":\"isContext\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"isContextOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"nodeAddress\",\"type\":\"address\"}],\"name\":\"isNodeInContext\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ethAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"}],\"name\":\"isUniqueHuman\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"cIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"removeContextOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"nodeAddress\",\"type\":\"address\"}],\"name\":\"removeNodeFromContext\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"contextid\",\"type\":\"bytes32\"}],\"name\":\"sponsor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BrightID","CompilerVersion":"v0.6.4+commit.1dca32f3","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"ipfs://7b469c278ba38af586b4668da356fe38f019fcff1b12ab006d5b079b45cebd59"}]}