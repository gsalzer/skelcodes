{"status":"1","message":"OK","result":[{"SourceCode":"{\"Eth2DaiReserve.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./WithdrawableV5.sol\\\";\\nimport \\\"./UtilsV5.sol\\\";\\nimport \\\"./IOtc.sol\\\";\\n\\ncontract IWeth is IERC20 {\\n    function deposit() public payable;\\n    function withdraw(uint) public;\\n}\\n\\ncontract Eth2DaiReserve is Withdrawable, Utils {\\n\\n    // constants\\n    uint constant internal INVALID_ID = uint(-1);\\n    uint constant internal POW_2_32 = 2 ** 32;\\n    uint constant internal POW_2_96 = 2 ** 96;\\n    uint constant internal BPS = 10000; // 10^4\\n\\n    IOtc public otc;\\n    IWeth public wethToken;// = IWeth(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\\n    uint public maxTakes;\\n    uint public maxTraverse;\\n\\n    struct OfferData {\\n        uint payAmount;\\n        uint buyAmount;\\n        uint id;\\n    }\\n\\n    constructor(address _otc, address _weth, address _admin, uint _maxTakes, uint _maxTraverse) \\n        public Withdrawable(_admin)\\n    {\\n        require(_otc != address(0), \\\"constructor: otc\\u0027s address is missing\\\");\\n        require(_weth != address(0), \\\"constructor: weth\\u0027s address is missing\\\");\\n\\n        wethToken = IWeth(_weth);\\n        require(getDecimals(wethToken) == MAX_DECIMALS, \\\"constructor: wethToken\\u0027s decimals is not MAX_DECIMALS\\\");\\n\\n        otc = IOtc(_otc);\\n        admin = _admin;\\n        maxTakes = _maxTakes;\\n        maxTraverse = _maxTraverse;\\n    }\\n\\n    function() external payable {} // solhint-disable-line no-empty-blocks\\n\\n    /**\\n        Returns conversion rate of given pair and srcQty, use 1 as srcQty if srcQty = 0\\n        Using eth amount to compute offer limit configurations\\n        =\\u003e need to check spread is ok for token -\\u003e eth\\n        Last bit of the rate indicates whether to use internal inventory:\\n          0 - use eth2dai\\n          1 - use internal inventory\\n    */\\n    function getConversionRate(IERC20 src, IERC20 dest, uint srcQty, uint) public view returns(uint) {\\n        if (srcQty == 0) { return 0; }\\n        IERC20 token = src == ETH_TOKEN_ADDRESS ? dest : src;\\n\\n        OfferData memory bid;\\n        OfferData memory ask;\\n        (bid, ask) = getFirstBidAndAskOrders(token);\\n\\n        uint destQty;\\n        OfferData[] memory offers;\\n\\n        if (src == ETH_TOKEN_ADDRESS) {\\n            (destQty, offers) = findBestOffers(dest, wethToken, srcQty, bid, ask);\\n        } else {\\n            (destQty, offers) = findBestOffers(wethToken, src, srcQty, bid, ask);\\n        }\\n\\n        if (offers.length == 0 || destQty == 0) { return 0; } // no offer or destQty == 0, return 0 for rate\\n\\n        uint rate = calcRateFromQty(srcQty, destQty, MAX_DECIMALS, MAX_DECIMALS);\\n\\n        return rate;\\n    }\\n\\n    event ContractsSet(address otc);\\n\\n    function setContracts(address _otc) public onlyAdmin {\\n        require(_otc != address(0), \\\"setContracts: otc\\u0027s address is missing\\\");\\n\\n        otc = IOtc(_otc);\\n\\n        emit ContractsSet(_otc);\\n    }\\n\\n    event DataSet(uint maxTakes, uint maxTraverse);\\n\\n    function setMaxTakesAndTraverse(uint _maxTakes, uint _maxTraverse) public onlyAdmin {\\n        maxTakes = _maxTakes;\\n        maxTraverse = _maxTraverse;\\n    }\\n\\n    function findBestOffers(\\n        IERC20 dstToken,\\n        IERC20 srcToken,\\n        uint srcAmount,\\n        OfferData memory bid,\\n        OfferData memory ask\\n    )\\n        internal view\\n        returns(uint totalDestAmount, OfferData[] memory offers)\\n    {\\n        uint remainingSrcAmount = srcAmount;\\n        uint maxOrdersToTake = maxTakes;\\n        uint maxTraversedOrders = maxTraverse;\\n        uint numTakenOffer = 0;\\n        totalDestAmount = 0;\\n\\n        offers = new OfferData[](maxTraversedOrders);\\n\\n        // return earlier, we don\\u0027t want to take any orders\\n        if (maxTraversedOrders == 0 || maxOrdersToTake == 0) {\\n            return (totalDestAmount, offers);\\n        }\\n\\n        // otc\\u0027s terminology is of offer maker, so their sellGem is our (the taker\\u0027s) dest token.\\n        // if we don\\u0027t have best offers, get them.\\n        if ((srcToken == wethToken \\u0026\\u0026 bid.id == 0) || (dstToken == wethToken \\u0026\\u0026 ask.id == 0)) {\\n            offers[0].id = otc.getBestOffer(dstToken, srcToken);\\n            // assuming pay amount is taker pay amount. (in otc it is used differently)\\n            (offers[0].buyAmount, , offers[0].payAmount, ) = otc.getOffer(offers[0].id);\\n        } else {\\n            offers[0] = srcToken == wethToken ? bid : ask;\\n        }\\n\\n        uint thisOffer;\\n\\n        OfferData memory biggestSkippedOffer = OfferData(0, 0, 0);\\n\\n        for (; maxTraversedOrders \\u003e 0; --maxTraversedOrders) {\\n            thisOffer = numTakenOffer;\\n\\n            // in case both biggestSkippedOffer \\u0026 current offer have amount \\u003e= remainingSrcAmount\\n            // biggestSkippedOffer should have better rate than current offer\\n            if (biggestSkippedOffer.payAmount \\u003e= remainingSrcAmount) {\\n                offers[numTakenOffer].id = biggestSkippedOffer.id;\\n                offers[numTakenOffer].buyAmount = remainingSrcAmount * biggestSkippedOffer.buyAmount / biggestSkippedOffer.payAmount;\\n                offers[numTakenOffer].payAmount = remainingSrcAmount;\\n                totalDestAmount += offers[numTakenOffer].buyAmount;\\n                ++numTakenOffer;\\n                remainingSrcAmount = 0;\\n                break;\\n            } else if (offers[numTakenOffer].payAmount \\u003e= remainingSrcAmount) {\\n                offers[numTakenOffer].buyAmount = remainingSrcAmount * offers[numTakenOffer].buyAmount / offers[numTakenOffer].payAmount;\\n                offers[numTakenOffer].payAmount = remainingSrcAmount;\\n                totalDestAmount += offers[numTakenOffer].buyAmount;\\n                ++numTakenOffer;\\n                remainingSrcAmount = 0;\\n                break;\\n            } else if ((maxOrdersToTake - numTakenOffer) \\u003e 1) {\\n                totalDestAmount += offers[numTakenOffer].buyAmount;\\n                remainingSrcAmount -= offers[numTakenOffer].payAmount;\\n                ++numTakenOffer;\\n            } else if (offers[numTakenOffer].payAmount \\u003e biggestSkippedOffer.payAmount) {\\n                biggestSkippedOffer.payAmount = offers[numTakenOffer].payAmount;\\n                biggestSkippedOffer.buyAmount = offers[numTakenOffer].buyAmount;\\n                biggestSkippedOffer.id = offers[numTakenOffer].id;\\n            }\\n\\n            offers[numTakenOffer].id = otc.getWorseOffer(offers[thisOffer].id);\\n            (offers[numTakenOffer].buyAmount, , offers[numTakenOffer].payAmount, ) = otc.getOffer(offers[numTakenOffer].id);\\n        }\\n\\n        if (remainingSrcAmount \\u003e 0) totalDestAmount = 0;\\n        if (totalDestAmount == 0) offers = new OfferData[](0);\\n    }\\n\\n    // bid: buy WETH, ask: sell WETH (their base token is DAI)\\n    function getFirstBidAndAskOrders(IERC20 token)\\n        internal view\\n        returns(OfferData memory bid, OfferData memory ask)\\n    {\\n        // getting first bid offer (buy WETH)\\n        (bid.id, bid.payAmount, bid.buyAmount) = getFirstOffer(token, wethToken);\\n        // getting first ask offer (sell WETH)\\n        (ask.id, ask.payAmount, ask.buyAmount) = getFirstOffer(wethToken, token);\\n    }\\n\\n    function getFirstOffer(IERC20 offerSellGem, IERC20 offerBuyGem)\\n        internal view\\n        returns(uint offerId, uint offerPayAmount, uint offerBuyAmount)\\n    {\\n        offerId = otc.getBestOffer(offerSellGem, offerBuyGem);\\n        (offerBuyAmount, , offerPayAmount, ) = otc.getOffer(offerId);\\n    }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\n\\ninterface IERC20 {\\n    function transfer(address _to, uint _value) external returns (bool success);\\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\\n    function approve(address _spender, uint _value) external returns (bool success);\\n    function totalSupply() external view returns (uint supply);\\n    function balanceOf(address _owner) external view returns (uint balance);\\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\\n    function decimals() external view returns(uint digits);\\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\\n}\\n\"},\"IOtc.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ncontract IOtc {\\n    function getOffer(uint id) external view returns (uint, IERC20, uint, IERC20);\\n    function getBestOffer(IERC20 sellGem, IERC20 buyGem) external view returns(uint);\\n    function getWorseOffer(uint id) external view returns(uint);\\n    function take(bytes32 id, uint128 maxTakeAmount) external;\\n}\\n\"},\"PermissionGroupsV5.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\n\\ncontract PermissionGroups {\\n\\n    address public admin;\\n    address public pendingAdmin;\\n    mapping(address=\\u003ebool) internal operators;\\n    mapping(address=\\u003ebool) internal alerters;\\n    address[] internal operatorsGroup;\\n    address[] internal alertersGroup;\\n    uint constant internal MAX_GROUP_SIZE = 50;\\n\\n    constructor(address _admin) public {\\n        require(_admin != address(0), \\\"Admin 0\\\");\\n        admin = _admin;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin);\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(operators[msg.sender]);\\n        _;\\n    }\\n\\n    modifier onlyAlerter() {\\n        require(alerters[msg.sender]);\\n        _;\\n    }\\n\\n    function getOperators () external view returns(address[] memory) {\\n        return operatorsGroup;\\n    }\\n\\n    function getAlerters () external view returns(address[] memory) {\\n        return alertersGroup;\\n    }\\n\\n    event TransferAdminPending(address pendingAdmin);\\n\\n    /**\\n     * @dev Allows the current admin to set the pendingAdmin address.\\n     * @param newAdmin The address to transfer ownership to.\\n     */\\n    function transferAdmin(address newAdmin) public onlyAdmin {\\n        require(newAdmin != address(0));\\n        emit TransferAdminPending(pendingAdmin);\\n        pendingAdmin = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\\n     * @param newAdmin The address to transfer ownership to.\\n     */\\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\\n        require(newAdmin != address(0));\\n        emit TransferAdminPending(newAdmin);\\n        emit AdminClaimed(newAdmin, admin);\\n        admin = newAdmin;\\n    }\\n\\n    event AdminClaimed( address newAdmin, address previousAdmin);\\n\\n    /**\\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\\n     */\\n    function claimAdmin() public {\\n        require(pendingAdmin == msg.sender);\\n        emit AdminClaimed(pendingAdmin, admin);\\n        admin = pendingAdmin;\\n        pendingAdmin = address(0);\\n    }\\n\\n    event AlerterAdded (address newAlerter, bool isAdd);\\n\\n    function addAlerter(address newAlerter) public onlyAdmin {\\n        require(!alerters[newAlerter]); // prevent duplicates.\\n        require(alertersGroup.length \\u003c MAX_GROUP_SIZE);\\n\\n        emit AlerterAdded(newAlerter, true);\\n        alerters[newAlerter] = true;\\n        alertersGroup.push(newAlerter);\\n    }\\n\\n    function removeAlerter (address alerter) public onlyAdmin {\\n        require(alerters[alerter]);\\n        alerters[alerter] = false;\\n\\n        for (uint i = 0; i \\u003c alertersGroup.length; ++i) {\\n            if (alertersGroup[i] == alerter) {\\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\\n                alertersGroup.length--;\\n                emit AlerterAdded(alerter, false);\\n                break;\\n            }\\n        }\\n    }\\n\\n    event OperatorAdded(address newOperator, bool isAdd);\\n\\n    function addOperator(address newOperator) public onlyAdmin {\\n        require(!operators[newOperator]); // prevent duplicates.\\n        require(operatorsGroup.length \\u003c MAX_GROUP_SIZE);\\n\\n        emit OperatorAdded(newOperator, true);\\n        operators[newOperator] = true;\\n        operatorsGroup.push(newOperator);\\n    }\\n\\n    function removeOperator (address operator) public onlyAdmin {\\n        require(operators[operator]);\\n        operators[operator] = false;\\n\\n        for (uint i = 0; i \\u003c operatorsGroup.length; ++i) {\\n            if (operatorsGroup[i] == operator) {\\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\\n                operatorsGroup.length -= 1;\\n                emit OperatorAdded(operator, false);\\n                break;\\n            }\\n        }\\n    }\\n}\\n\"},\"UtilsV5.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\nimport \\\"./IERC20.sol\\\";\\n// import \\\"@nomiclabs/buidler/console.sol\\\";\\n\\n\\n/// @title Kyber utils and utils2 contracts\\ncontract Utils {\\n\\n    IERC20 constant internal ETH_TOKEN_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\n    uint  constant internal PRECISION = (10**18);\\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\\n    uint  constant internal MAX_RATE  = (PRECISION * 10**7); // up to 10M tokens per ETH\\n    uint  constant internal MAX_DECIMALS = 18;\\n    uint  constant internal ETH_DECIMALS = 18;\\n    uint  constant BPS = 10000; // Basic Price Steps. 1 step = 0.01%\\n\\n    mapping(address=\\u003euint) internal decimals;\\n\\n    /// @dev get the balance of a user.\\n    /// @param token The token type\\n    /// @return The balance\\n    function getBalance(IERC20 token, address user) internal view returns(uint) {\\n        if (token == ETH_TOKEN_ADDRESS)\\n            return user.balance;\\n        else\\n            return token.balanceOf(user);\\n    }\\n\\n    function setDecimals(IERC20 token) internal {\\n        if (token == ETH_TOKEN_ADDRESS)\\n            decimals[address(token)] = ETH_DECIMALS;\\n        else\\n            decimals[address(token)] = token.decimals();\\n    }\\n\\n    function getDecimals(IERC20 token) internal view returns(uint) {\\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\\n        uint tokenDecimals = decimals[address(token)];\\n        // moreover, very possible that old tokens have decimals 0\\n        // these tokens will just have higher gas fees.\\n        if (tokenDecimals == 0) return token.decimals();\\n\\n        return tokenDecimals;\\n    }\\n    \\n    function getUpdateDecimals(IERC20 token) internal returns(uint) {\\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\\n        uint tokenDecimals = decimals[address(token)];\\n        // moreover, very possible that old tokens have decimals 0\\n        // these tokens will just have higher gas fees.\\n        if (tokenDecimals == 0) {\\n            tokenDecimals = token.decimals();\\n            decimals[address(token)] = token.decimals();\\n        }\\n\\n        return tokenDecimals;\\n    }\\n\\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\\n        require(srcQty \\u003c= MAX_QTY, \\\"srcQty \\u003e MAX_QTY\\\");\\n        require(rate \\u003c= MAX_RATE, \\\"rate \\u003e MAX_RATE\\\");\\n\\n        if (dstDecimals \\u003e= srcDecimals) {\\n            require((dstDecimals - srcDecimals) \\u003c= MAX_DECIMALS, \\\"dst - src \\u003e MAX_DECIMALS\\\");\\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\\n        } else {\\n            require((srcDecimals - dstDecimals) \\u003c= MAX_DECIMALS, \\\"src - dst \\u003e MAX_DECIMALS\\\");\\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\\n        }\\n    }\\n\\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\\n        require(dstQty \\u003c= MAX_QTY, \\\"dstQty \\u003e MAX_QTY\\\");\\n        require(rate \\u003c= MAX_RATE, \\\"rate \\u003e MAX_RATE\\\");\\n\\n        //source quantity is rounded up. to avoid dest quantity being too low.\\n        uint numerator;\\n        uint denominator;\\n        if (srcDecimals \\u003e= dstDecimals) {\\n            require((srcDecimals - dstDecimals) \\u003c= MAX_DECIMALS, \\\"src - dst \\u003e MAX_DECIMALS\\\");\\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\\n            denominator = rate;\\n        } else {\\n            require((dstDecimals - srcDecimals) \\u003c= MAX_DECIMALS, \\\"dst - src \\u003e MAX_DECIMALS\\\");\\n            numerator = (PRECISION * dstQty);\\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\\n        }\\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\\n    }\\n\\n    function calcDestAmount(IERC20 src, IERC20 dest, uint srcAmount, uint rate) internal view returns(uint) {\\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\\n    }\\n\\n    function calcSrcAmount(IERC20 src, IERC20 dest, uint destAmount, uint rate) internal view returns(uint) {\\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\\n    }\\n\\n    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\\n        internal pure returns(uint)\\n    {\\n        require(srcAmount \\u003c= MAX_QTY, \\\"srcAmount \\u003e MAX_QTY\\\");\\n        require(destAmount \\u003c= MAX_QTY, \\\"destAmount \\u003e MAX_QTY\\\");\\n\\n        if (dstDecimals \\u003e= srcDecimals) {\\n            require((dstDecimals - srcDecimals) \\u003c= MAX_DECIMALS, \\\"dst - src \\u003e MAX_DECIMALS\\\");\\n            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\\n        } else {\\n            require((srcDecimals - dstDecimals) \\u003c= MAX_DECIMALS, \\\"src - dst \\u003e MAX_DECIMALS\\\");\\n            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\\n        }\\n    }\\n\\n    function minOf(uint x, uint y) internal pure returns(uint) {\\n        return x \\u003e y ? y : x;\\n    }\\n\\n    enum Module {\\n        LOGIC, // trade logic\\n        PROXY,\\n        NETWORK // internal network\\n    }\\n\\n    // function printGas(string memory str, uint refGas, Module module) internal view returns(uint currGas) {\\n    //     currGas = gasleft();\\n\\n    //     // update to your required module\\n    //     if (module != Module.NETWORK || refGas == 0) return currGas;\\n\\n    //     console.log(\\\"gas \\u0027%d\\u0027 in \\u0027%s\\u0027 diff: %d\\\", currGas, str, refGas - currGas);\\n    // }\\n}\\n\"},\"WithdrawableV5.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./PermissionGroupsV5.sol\\\";\\n\\n\\ncontract Withdrawable is PermissionGroups {\\n\\n    constructor(address _admin) public \\n        PermissionGroups(_admin) \\n        {}\\n        \\n    event TokenWithdraw(IERC20 token, uint amount, address sendTo);\\n\\n    /**\\n     * @dev Withdraw all IERC20 compatible tokens\\n     * @param token IERC20 The address of the token contract\\n     */\\n    function withdrawToken(IERC20 token, uint amount, address sendTo) external onlyAdmin {\\n        require(token.transfer(sendTo, amount));\\n        emit TokenWithdraw(token, amount, sendTo);\\n    }\\n\\n    event EtherWithdraw(uint amount, address sendTo);\\n\\n    /**\\n     * @dev Withdraw Ethers\\n     */\\n    function withdrawEther(uint amount, address payable sendTo) external onlyAdmin {\\n        sendTo.transfer(amount);\\n        emit EtherWithdraw(amount, sendTo);\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"alerter\",\"type\":\"address\"}],\"name\":\"removeAlerter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxTakes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxTraverse\",\"type\":\"uint256\"}],\"name\":\"setMaxTakesAndTraverse\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"otc\",\"outputs\":[{\"internalType\":\"contract IOtc\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAlerter\",\"type\":\"address\"}],\"name\":\"addAlerter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wethToken\",\"outputs\":[{\"internalType\":\"contract IWeth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_otc\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdminQuickly\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAlerters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcQty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getConversionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTraverse\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_otc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxTakes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxTraverse\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"otc\",\"type\":\"address\"}],\"name\":\"ContractsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxTakes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxTraverse\",\"type\":\"uint256\"}],\"name\":\"DataSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"TokenWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"EtherWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdminPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"AdminClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAlerter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"AlerterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"}]","ContractName":"Eth2DaiReserve","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000794e6e91555438afc3ccf1c5076a74f42133d08d000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000be2f0354d970265bfc36d383af77f72736b81b54000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000001f4","Library":"","LicenseType":"None","SwarmSource":"bzzr://0c1fed36a3a36258dec3bda0195bdc1c6747e8d395d00c712e0a8a9885780d1f"}]}