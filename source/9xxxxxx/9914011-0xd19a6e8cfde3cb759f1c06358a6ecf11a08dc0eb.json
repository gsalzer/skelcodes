{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *  @reviewers: [@clesaege, @unknownunknown1, @ferittuncer]\r\n *  @auditors: []\r\n *  @bounties: [<14 days 10 ETH max payout>]\r\n *  @deployments: []\r\n */\r\n\r\npragma solidity ^0.5.12;\r\n\r\n/**\r\n *  @title SortitionSumTreeFactory\r\n *  @author Enrique Piqueras - <epiquerass@gmail.com>\r\n *  @dev A factory of trees that keep track of staked values for sortition.\r\n */\r\nlibrary SortitionSumTreeFactory {\r\n    /* Structs */\r\n\r\n    struct SortitionSumTree {\r\n        uint K; // The maximum number of childs per node.\r\n        // We use this to keep track of vacant positions in the tree after removing a leaf. This is for keeping the tree as balanced as possible without spending gas on moving nodes around.\r\n        uint[] stack;\r\n        uint[] nodes;\r\n        // Two-way mapping of IDs to node indexes. Note that node index 0 is reserved for the root node, and means the ID does not have a node.\r\n        mapping(bytes32 => uint) IDsToNodeIndexes;\r\n        mapping(uint => bytes32) nodeIndexesToIDs;\r\n    }\r\n\r\n    /* Storage */\r\n\r\n    struct SortitionSumTrees {\r\n        mapping(bytes32 => SortitionSumTree) sortitionSumTrees;\r\n    }\r\n\r\n    /* Public */\r\n\r\n    /**\r\n     *  @dev Create a sortition sum tree at the specified key.\r\n     *  @param _key The key of the new tree.\r\n     *  @param _K The number of children each node in the tree should have.\r\n     */\r\n    function createTree(SortitionSumTrees storage self, bytes32 _key, uint _K) public {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n        require(tree.K == 0, \"Tree already exists.\");\r\n        require(_K > 1, \"K must be greater than one.\");\r\n        tree.K = _K;\r\n        tree.stack.length = 0;\r\n        tree.nodes.length = 0;\r\n        tree.nodes.push(0);\r\n    }\r\n\r\n    /**\r\n     *  @dev Set a value of a tree.\r\n     *  @param _key The key of the tree.\r\n     *  @param _value The new value.\r\n     *  @param _ID The ID of the value.\r\n     *  `O(log_k(n))` where\r\n     *  `k` is the maximum number of childs per node in the tree,\r\n     *   and `n` is the maximum number of nodes ever appended.\r\n     */\r\n    function set(SortitionSumTrees storage self, bytes32 _key, uint _value, bytes32 _ID) public {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n        uint treeIndex = tree.IDsToNodeIndexes[_ID];\r\n\r\n        if (treeIndex == 0) { // No existing node.\r\n            if (_value != 0) { // Non zero value.\r\n                // Append.\r\n                // Add node.\r\n                if (tree.stack.length == 0) { // No vacant spots.\r\n                    // Get the index and append the value.\r\n                    treeIndex = tree.nodes.length;\r\n                    tree.nodes.push(_value);\r\n\r\n                    // Potentially append a new node and make the parent a sum node.\r\n                    if (treeIndex != 1 && (treeIndex - 1) % tree.K == 0) { // Is first child.\r\n                        uint parentIndex = treeIndex / tree.K;\r\n                        bytes32 parentID = tree.nodeIndexesToIDs[parentIndex];\r\n                        uint newIndex = treeIndex + 1;\r\n                        tree.nodes.push(tree.nodes[parentIndex]);\r\n                        delete tree.nodeIndexesToIDs[parentIndex];\r\n                        tree.IDsToNodeIndexes[parentID] = newIndex;\r\n                        tree.nodeIndexesToIDs[newIndex] = parentID;\r\n                    }\r\n                } else { // Some vacant spot.\r\n                    // Pop the stack and append the value.\r\n                    treeIndex = tree.stack[tree.stack.length - 1];\r\n                    tree.stack.length--;\r\n                    tree.nodes[treeIndex] = _value;\r\n                }\r\n\r\n                // Add label.\r\n                tree.IDsToNodeIndexes[_ID] = treeIndex;\r\n                tree.nodeIndexesToIDs[treeIndex] = _ID;\r\n\r\n                updateParents(self, _key, treeIndex, true, _value);\r\n            }\r\n        } else { // Existing node.\r\n            if (_value == 0) { // Zero value.\r\n                // Remove.\r\n                // Remember value and set to 0.\r\n                uint value = tree.nodes[treeIndex];\r\n                tree.nodes[treeIndex] = 0;\r\n\r\n                // Push to stack.\r\n                tree.stack.push(treeIndex);\r\n\r\n                // Clear label.\r\n                delete tree.IDsToNodeIndexes[_ID];\r\n                delete tree.nodeIndexesToIDs[treeIndex];\r\n\r\n                updateParents(self, _key, treeIndex, false, value);\r\n            } else if (_value != tree.nodes[treeIndex]) { // New, non zero value.\r\n                // Set.\r\n                bool plusOrMinus = tree.nodes[treeIndex] <= _value;\r\n                uint plusOrMinusValue = plusOrMinus ? _value - tree.nodes[treeIndex] : tree.nodes[treeIndex] - _value;\r\n                tree.nodes[treeIndex] = _value;\r\n\r\n                updateParents(self, _key, treeIndex, plusOrMinus, plusOrMinusValue);\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Public Views */\r\n\r\n    /**\r\n     *  @dev Query the leaves of a tree. Note that if `startIndex == 0`, the tree is empty and the root node will be returned.\r\n     *  @param _key The key of the tree to get the leaves from.\r\n     *  @param _cursor The pagination cursor.\r\n     *  @param _count The number of items to return.\r\n     *  @return The index at which leaves start, the values of the returned leaves, and whether there are more for pagination.\r\n     *  `O(n)` where\r\n     *  `n` is the maximum number of nodes ever appended.\r\n     */\r\n    function queryLeafs(\r\n        SortitionSumTrees storage self,\r\n        bytes32 _key,\r\n        uint _cursor,\r\n        uint _count\r\n    ) public view returns(uint startIndex, uint[] memory values, bool hasMore) {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n\r\n        // Find the start index.\r\n        for (uint i = 0; i < tree.nodes.length; i++) {\r\n            if ((tree.K * i) + 1 >= tree.nodes.length) {\r\n                startIndex = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Get the values.\r\n        uint loopStartIndex = startIndex + _cursor;\r\n        values = new uint[](loopStartIndex + _count > tree.nodes.length ? tree.nodes.length - loopStartIndex : _count);\r\n        uint valuesIndex = 0;\r\n        for (uint j = loopStartIndex; j < tree.nodes.length; j++) {\r\n            if (valuesIndex < _count) {\r\n                values[valuesIndex] = tree.nodes[j];\r\n                valuesIndex++;\r\n            } else {\r\n                hasMore = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  @dev Draw an ID from a tree using a number. Note that this function reverts if the sum of all values in the tree is 0.\r\n     *  @param _key The key of the tree.\r\n     *  @param _drawnNumber The drawn number.\r\n     *  @return The drawn ID.\r\n     *  `O(k * log_k(n))` where\r\n     *  `k` is the maximum number of childs per node in the tree,\r\n     *   and `n` is the maximum number of nodes ever appended.\r\n     */\r\n    function draw(SortitionSumTrees storage self, bytes32 _key, uint _drawnNumber) public view returns(bytes32 ID) {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n        uint treeIndex = 0;\r\n        uint currentDrawnNumber = _drawnNumber % tree.nodes[0];\r\n\r\n        while ((tree.K * treeIndex) + 1 < tree.nodes.length)  // While it still has children.\r\n            for (uint i = 1; i <= tree.K; i++) { // Loop over children.\r\n                uint nodeIndex = (tree.K * treeIndex) + i;\r\n                uint nodeValue = tree.nodes[nodeIndex];\r\n\r\n                if (currentDrawnNumber >= nodeValue) currentDrawnNumber -= nodeValue; // Go to the next child.\r\n                else { // Pick this child.\r\n                    treeIndex = nodeIndex;\r\n                    break;\r\n                }\r\n            }\r\n        \r\n        ID = tree.nodeIndexesToIDs[treeIndex];\r\n    }\r\n\r\n    /** @dev Gets a specified ID's associated value.\r\n     *  @param _key The key of the tree.\r\n     *  @param _ID The ID of the value.\r\n     *  @return The associated value.\r\n     */\r\n    function stakeOf(SortitionSumTrees storage self, bytes32 _key, bytes32 _ID) public view returns(uint value) {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n        uint treeIndex = tree.IDsToNodeIndexes[_ID];\r\n\r\n        if (treeIndex == 0) value = 0;\r\n        else value = tree.nodes[treeIndex];\r\n    }\r\n\r\n    /* Private */\r\n\r\n    /**\r\n     *  @dev Update all the parents of a node.\r\n     *  @param _key The key of the tree to update.\r\n     *  @param _treeIndex The index of the node to start from.\r\n     *  @param _plusOrMinus Wether to add (true) or substract (false).\r\n     *  @param _value The value to add or substract.\r\n     *  `O(log_k(n))` where\r\n     *  `k` is the maximum number of childs per node in the tree,\r\n     *   and `n` is the maximum number of nodes ever appended.\r\n     */\r\n    function updateParents(SortitionSumTrees storage self, bytes32 _key, uint _treeIndex, bool _plusOrMinus, uint _value) private {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n\r\n        uint parentIndex = _treeIndex;\r\n        while (parentIndex != 0) {\r\n            parentIndex = (parentIndex - 1) / tree.K;\r\n            tree.nodes[parentIndex] = _plusOrMinus ? tree.nodes[parentIndex] + _value : tree.nodes[parentIndex] - _value;\r\n        }\r\n    }\r\n}","ABI":"[]","ContractName":"SortitionSumTreeFactory","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://f415f3c107d0341e674c2d6848166e743d59cefd706295e55ead61ce8ffeceb9"}]}