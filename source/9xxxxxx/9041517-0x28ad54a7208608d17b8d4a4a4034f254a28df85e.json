{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/reserves/orderBookReserve/permissionless/OrderListInterface.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\ninterface OrderListInterface {\r\n    function getOrderDetails(uint32 orderId) public view returns (address, uint128, uint128, uint32, uint32);\r\n    function add(address maker, uint32 orderId, uint128 srcAmount, uint128 dstAmount) public returns (bool);\r\n    function remove(uint32 orderId) public returns (bool);\r\n    function update(uint32 orderId, uint128 srcAmount, uint128 dstAmount) public returns (bool);\r\n    function getFirstOrder() public view returns(uint32 orderId, bool isEmpty);\r\n    function allocateIds(uint32 howMany) public returns(uint32);\r\n    function findPrevOrderId(uint128 srcAmount, uint128 dstAmount) public view returns(uint32);\r\n\r\n    function addAfterId(address maker, uint32 orderId, uint128 srcAmount, uint128 dstAmount, uint32 prevId) public\r\n        returns (bool);\r\n\r\n    function updateWithPositionHint(uint32 orderId, uint128 srcAmount, uint128 dstAmount, uint32 prevId) public\r\n        returns(bool, uint);\r\n}\r\n\r\n// File: contracts/reserves/orderBookReserve/permissionless/OrderIdManager.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\ncontract OrderIdManager {\r\n    struct OrderIdData {\r\n        uint32 firstOrderId;\r\n        uint takenBitmap;\r\n    }\r\n\r\n    uint constant public NUM_ORDERS = 32;\r\n\r\n    function fetchNewOrderId(OrderIdData storage freeOrders)\r\n        internal\r\n        returns(uint32)\r\n    {\r\n        uint orderBitmap = freeOrders.takenBitmap;\r\n        uint bitPointer = 1;\r\n\r\n        for (uint i = 0; i < NUM_ORDERS; ++i) {\r\n\r\n            if ((orderBitmap & bitPointer) == 0) {\r\n                freeOrders.takenBitmap = orderBitmap | bitPointer;\r\n                return(uint32(uint(freeOrders.firstOrderId) + i));\r\n            }\r\n\r\n            bitPointer *= 2;\r\n        }\r\n\r\n        revert();\r\n    }\r\n\r\n    /// @dev mark order as free to use.\r\n    function releaseOrderId(OrderIdData storage freeOrders, uint32 orderId)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        require(orderId >= freeOrders.firstOrderId);\r\n        require(orderId < (freeOrders.firstOrderId + NUM_ORDERS));\r\n\r\n        uint orderBitNum = uint(orderId) - uint(freeOrders.firstOrderId);\r\n        uint bitPointer = uint(1) << orderBitNum;\r\n\r\n        require(bitPointer & freeOrders.takenBitmap > 0);\r\n\r\n        freeOrders.takenBitmap &= ~bitPointer;\r\n        return true;\r\n    }\r\n\r\n    function allocateOrderIds(\r\n        OrderIdData storage makerOrders,\r\n        uint32 firstAllocatedId\r\n    )\r\n        internal\r\n        returns(bool)\r\n    {\r\n        if (makerOrders.firstOrderId > 0) {\r\n            return false;\r\n        }\r\n\r\n        makerOrders.firstOrderId = firstAllocatedId;\r\n        makerOrders.takenBitmap = 0;\r\n\r\n        return true;\r\n    }\r\n\r\n    function orderAllocationRequired(OrderIdData storage freeOrders) internal view returns (bool) {\r\n\r\n        if (freeOrders.firstOrderId == 0) return true;\r\n        return false;\r\n    }\r\n\r\n    function getNumActiveOrderIds(OrderIdData storage makerOrders) internal view returns (uint numActiveOrders) {\r\n        for (uint i = 0; i < NUM_ORDERS; ++i) {\r\n            if ((makerOrders.takenBitmap & (uint(1) << i)) > 0) numActiveOrders++;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/reserves/orderBookReserve/permissionless/OrderListFactoryInterface.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n\r\ninterface OrderListFactoryInterface {\r\n    function newOrdersContract(address admin) public returns(OrderListInterface);\r\n}\r\n\r\n// File: contracts/reserves/orderBookReserve/permissionless/OrderbookReserveInterface.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n\r\ninterface OrderbookReserveInterface {\r\n    function init() public returns(bool);\r\n    function kncRateBlocksTrade() public view returns(bool);\r\n}\r\n\r\n// File: contracts/ERC20Interface.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n// https://github.com/ethereum/EIPs/issues/20\r\ninterface ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address _owner) public view returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n    function decimals() public view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n// File: contracts/Utils.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n\r\n/// @title Kyber constants contract\r\ncontract Utils {\r\n\r\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n    uint  constant internal PRECISION = (10**18);\r\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\r\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\r\n    uint  constant internal MAX_DECIMALS = 18;\r\n    uint  constant internal ETH_DECIMALS = 18;\r\n    mapping(address=>uint) internal decimals;\r\n\r\n    function setDecimals(ERC20 token) internal {\r\n        if (token == ETH_TOKEN_ADDRESS) decimals[token] = ETH_DECIMALS;\r\n        else decimals[token] = token.decimals();\r\n    }\r\n\r\n    function getDecimals(ERC20 token) internal view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint tokenDecimals = decimals[token];\r\n        // technically, there might be token with decimals 0\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if(tokenDecimals == 0) return token.decimals();\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(srcQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(dstQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n        \r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint numerator;\r\n        uint denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n}\r\n\r\n// File: contracts/Utils2.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n\r\ncontract Utils2 is Utils {\r\n\r\n    /// @dev get the balance of a user.\r\n    /// @param token The token type\r\n    /// @return The balance\r\n    function getBalance(ERC20 token, address user) public view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS)\r\n            return user.balance;\r\n        else\r\n            return token.balanceOf(user);\r\n    }\r\n\r\n    function getDecimalsSafe(ERC20 token) internal returns(uint) {\r\n\r\n        if (decimals[token] == 0) {\r\n            setDecimals(token);\r\n        }\r\n\r\n        return decimals[token];\r\n    }\r\n\r\n    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal view returns(uint) {\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal view returns(uint) {\r\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\r\n        internal pure returns(uint)\r\n    {\r\n        require(srcAmount <= MAX_QTY);\r\n        require(destAmount <= MAX_QTY);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/KyberReserveInterface.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n/// @title Kyber Reserve contract\r\ninterface KyberReserveInterface {\r\n\r\n    function trade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 destToken,\r\n        address destAddress,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        public\r\n        payable\r\n        returns(bool);\r\n\r\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) public view returns(uint);\r\n}\r\n\r\n// File: contracts/reserves/orderBookReserve/permissionless/OrderbookReserve.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract FeeBurnerRateInterface {\r\n    uint public kncPerEthRatePrecision;\r\n}\r\n\r\n\r\ninterface MedianizerInterface {\r\n    function peek() public view returns (bytes32, bool);\r\n}\r\n\r\n\r\ncontract OrderbookReserve is OrderIdManager, Utils2, KyberReserveInterface, OrderbookReserveInterface {\r\n\r\n    uint public constant BURN_TO_STAKE_FACTOR = 5;      // stake per order must be xfactor expected burn amount.\r\n    uint public constant MAX_BURN_FEE_BPS = 100;        // 1%\r\n    uint public constant MIN_REMAINING_ORDER_RATIO = 2; // Ratio between min new order value and min order value.\r\n    uint public constant MAX_USD_PER_ETH = 100000;      // Above this value price is surely compromised.\r\n\r\n    uint32 constant public TAIL_ID = 1;         // tail Id in order list contract\r\n    uint32 constant public HEAD_ID = 2;         // head Id in order list contract\r\n\r\n    struct OrderLimits {\r\n        uint minNewOrderSizeUsd; // Basis for setting min new order size Eth\r\n        uint maxOrdersPerTrade;     // Limit number of iterated orders per trade / getRate loops.\r\n        uint minNewOrderSizeWei;    // Below this value can't create new order.\r\n        uint minOrderSizeWei;       // below this value order will be removed.\r\n    }\r\n\r\n    uint public kncPerEthBaseRatePrecision; // according to base rate all stakes are calculated.\r\n\r\n    struct ExternalContracts {\r\n        ERC20 kncToken;          // not constant. to enable testing while not on main net\r\n        ERC20 token;             // only supported token.\r\n        FeeBurnerRateInterface feeBurner;\r\n        address kyberNetwork;\r\n        MedianizerInterface medianizer; // price feed Eth - USD from maker DAO.\r\n        OrderListFactoryInterface orderListFactory;\r\n    }\r\n\r\n    //struct for getOrderData() return value. used only in memory.\r\n    struct OrderData {\r\n        address maker;\r\n        uint32 nextId;\r\n        bool isLastOrder;\r\n        uint128 srcAmount;\r\n        uint128 dstAmount;\r\n    }\r\n\r\n    OrderLimits public limits;\r\n    ExternalContracts public contracts;\r\n\r\n    // sorted lists of orders. one list for token to Eth, other for Eth to token.\r\n    // Each order is added in the correct position in the list to keep it sorted.\r\n    OrderListInterface public tokenToEthList;\r\n    OrderListInterface public ethToTokenList;\r\n\r\n    //funds data\r\n    mapping(address => mapping(address => uint)) public makerFunds; // deposited maker funds.\r\n    mapping(address => uint) public makerKnc;            // for knc staking.\r\n    mapping(address => uint) public makerTotalOrdersWei; // per maker how many Wei in orders, for stake calculation.\r\n\r\n    uint public makerBurnFeeBps;    // knc burn fee per order that is taken.\r\n\r\n    //each maker will have orders that will be reused.\r\n    mapping(address => OrderIdData) public makerOrdersTokenToEth;\r\n    mapping(address => OrderIdData) public makerOrdersEthToToken;\r\n\r\n    function OrderbookReserve(\r\n        ERC20 knc,\r\n        ERC20 reserveToken,\r\n        address burner,\r\n        address network,\r\n        MedianizerInterface medianizer,\r\n        OrderListFactoryInterface factory,\r\n        uint minNewOrderUsd,\r\n        uint maxOrdersPerTrade,\r\n        uint burnFeeBps\r\n    )\r\n        public\r\n    {\r\n\r\n        require(knc != address(0));\r\n        require(reserveToken != address(0));\r\n        require(burner != address(0));\r\n        require(network != address(0));\r\n        require(medianizer != address(0));\r\n        require(factory != address(0));\r\n        require(burnFeeBps != 0);\r\n        require(burnFeeBps <= MAX_BURN_FEE_BPS);\r\n        require(maxOrdersPerTrade != 0);\r\n        require(minNewOrderUsd > 0);\r\n\r\n        contracts.kyberNetwork = network;\r\n        contracts.feeBurner = FeeBurnerRateInterface(burner);\r\n        contracts.medianizer = medianizer;\r\n        contracts.orderListFactory = factory;\r\n        contracts.kncToken = knc;\r\n        contracts.token = reserveToken;\r\n\r\n        makerBurnFeeBps = burnFeeBps;\r\n        limits.minNewOrderSizeUsd = minNewOrderUsd;\r\n        limits.maxOrdersPerTrade = maxOrdersPerTrade;\r\n\r\n        require(setMinOrderSizeEth());\r\n    \r\n        require(contracts.kncToken.approve(contracts.feeBurner, (2**255)));\r\n\r\n        //can only support tokens with decimals() API\r\n        setDecimals(contracts.token);\r\n\r\n        kncPerEthBaseRatePrecision = contracts.feeBurner.kncPerEthRatePrecision();\r\n    }\r\n\r\n    ///@dev separate init function for this contract, if this init is in the C'tor. gas consumption too high.\r\n    function init() public returns(bool) {\r\n        if ((tokenToEthList != address(0)) && (ethToTokenList != address(0))) return true;\r\n        if ((tokenToEthList != address(0)) || (ethToTokenList != address(0))) revert();\r\n\r\n        tokenToEthList = contracts.orderListFactory.newOrdersContract(this);\r\n        ethToTokenList = contracts.orderListFactory.newOrdersContract(this);\r\n\r\n        return true;\r\n    }\r\n\r\n    function setKncPerEthBaseRate() public {\r\n        uint kncPerEthRatePrecision = contracts.feeBurner.kncPerEthRatePrecision();\r\n        if (kncPerEthRatePrecision < kncPerEthBaseRatePrecision) {\r\n            kncPerEthBaseRatePrecision = kncPerEthRatePrecision;\r\n        }\r\n    }\r\n\r\n    function getConversionRate(ERC20 src, ERC20 dst, uint srcQty, uint blockNumber) public view returns(uint) {\r\n        require((src == ETH_TOKEN_ADDRESS) || (dst == ETH_TOKEN_ADDRESS));\r\n        require((src == contracts.token) || (dst == contracts.token));\r\n        require(srcQty <= MAX_QTY);\r\n\r\n        if (kncRateBlocksTrade() || (srcQty == 0)) return 0;\r\n\r\n        blockNumber; // in this reserve no order expiry == no use for blockNumber. here to avoid compiler warning.\r\n\r\n        //user order ETH -> token is matched with maker order token -> ETH\r\n        OrderListInterface list = (src == ETH_TOKEN_ADDRESS) ? tokenToEthList : ethToTokenList;\r\n\r\n        uint32 orderId;\r\n        OrderData memory orderData;\r\n\r\n        uint128 userRemainingSrcQty = uint128(srcQty);\r\n        uint128 totalUserDstAmount = 0;\r\n        uint maxOrders = limits.maxOrdersPerTrade;\r\n\r\n        for (\r\n            (orderId, orderData.isLastOrder) = list.getFirstOrder();\r\n            ((userRemainingSrcQty > 0) && (!orderData.isLastOrder) && (maxOrders-- > 0));\r\n            orderId = orderData.nextId\r\n        ) {\r\n            orderData = getOrderData(list, orderId);\r\n            // maker dst quantity is the requested quantity he wants to receive. user src quantity is what user gives.\r\n            // so user src quantity is matched with maker dst quantity\r\n            if (orderData.dstAmount <= userRemainingSrcQty) {\r\n                totalUserDstAmount += orderData.srcAmount;\r\n                userRemainingSrcQty -= orderData.dstAmount;\r\n            } else {\r\n                totalUserDstAmount += uint128(uint(orderData.srcAmount) * uint(userRemainingSrcQty) /\r\n                    uint(orderData.dstAmount));\r\n                userRemainingSrcQty = 0;\r\n            }\r\n        }\r\n\r\n        if (userRemainingSrcQty != 0) return 0; //not enough tokens to exchange.\r\n\r\n        return calcRateFromQty(srcQty, totalUserDstAmount, getDecimals(src), getDecimals(dst));\r\n    }\r\n\r\n    event OrderbookReserveTrade(ERC20 srcToken, ERC20 dstToken, uint srcAmount, uint dstAmount);\r\n\r\n    function trade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 dstToken,\r\n        address dstAddress,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        public\r\n        payable\r\n        returns(bool)\r\n    {\r\n        require(msg.sender == contracts.kyberNetwork);\r\n        require((srcToken == ETH_TOKEN_ADDRESS) || (dstToken == ETH_TOKEN_ADDRESS));\r\n        require((srcToken == contracts.token) || (dstToken == contracts.token));\r\n        require(srcAmount <= MAX_QTY);\r\n\r\n        conversionRate;\r\n        validate;\r\n\r\n        if (srcToken == ETH_TOKEN_ADDRESS) {\r\n            require(msg.value == srcAmount);\r\n        } else {\r\n            require(msg.value == 0);\r\n            require(srcToken.transferFrom(msg.sender, this, srcAmount));\r\n        }\r\n\r\n        uint totalDstAmount = doTrade(\r\n                srcToken,\r\n                srcAmount,\r\n                dstToken\r\n            );\r\n\r\n        require(conversionRate <= calcRateFromQty(srcAmount, totalDstAmount, getDecimals(srcToken),\r\n            getDecimals(dstToken)));\r\n\r\n        //all orders were successfully taken. send to dstAddress\r\n        if (dstToken == ETH_TOKEN_ADDRESS) {\r\n            dstAddress.transfer(totalDstAmount);\r\n        } else {\r\n            require(dstToken.transfer(dstAddress, totalDstAmount));\r\n        }\r\n\r\n        OrderbookReserveTrade(srcToken, dstToken, srcAmount, totalDstAmount);\r\n        return true;\r\n    }\r\n\r\n    function doTrade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 dstToken\r\n    )\r\n        internal\r\n        returns(uint)\r\n    {\r\n        OrderListInterface list = (srcToken == ETH_TOKEN_ADDRESS) ? tokenToEthList : ethToTokenList;\r\n\r\n        uint32 orderId;\r\n        OrderData memory orderData;\r\n        uint128 userRemainingSrcQty = uint128(srcAmount);\r\n        uint128 totalUserDstAmount = 0;\r\n\r\n        for (\r\n            (orderId, orderData.isLastOrder) = list.getFirstOrder();\r\n            ((userRemainingSrcQty > 0) && (!orderData.isLastOrder));\r\n            orderId = orderData.nextId\r\n        ) {\r\n        // maker dst quantity is the requested quantity he wants to receive. user src quantity is what user gives.\r\n        // so user src quantity is matched with maker dst quantity\r\n            orderData = getOrderData(list, orderId);\r\n            if (orderData.dstAmount <= userRemainingSrcQty) {\r\n                totalUserDstAmount += orderData.srcAmount;\r\n                userRemainingSrcQty -= orderData.dstAmount;\r\n                require(takeFullOrder({\r\n                    maker: orderData.maker,\r\n                    orderId: orderId,\r\n                    userSrc: srcToken,\r\n                    userDst: dstToken,\r\n                    userSrcAmount: orderData.dstAmount,\r\n                    userDstAmount: orderData.srcAmount\r\n                }));\r\n            } else {\r\n                uint128 partialDstQty = uint128(uint(orderData.srcAmount) * uint(userRemainingSrcQty) /\r\n                    uint(orderData.dstAmount));\r\n                totalUserDstAmount += partialDstQty;\r\n                require(takePartialOrder({\r\n                    maker: orderData.maker,\r\n                    orderId: orderId,\r\n                    userSrc: srcToken,\r\n                    userDst: dstToken,\r\n                    userPartialSrcAmount: userRemainingSrcQty,\r\n                    userTakeDstAmount: partialDstQty,\r\n                    orderSrcAmount: orderData.srcAmount,\r\n                    orderDstAmount: orderData.dstAmount\r\n                }));\r\n                userRemainingSrcQty = 0;\r\n            }\r\n        }\r\n\r\n        require(userRemainingSrcQty == 0 && totalUserDstAmount > 0);\r\n\r\n        return totalUserDstAmount;\r\n    }\r\n\r\n    ///@param srcAmount is the token amount that will be payed. must be deposited before hand in the makers account.\r\n    ///@param dstAmount is the eth amount the maker expects to get for his tokens.\r\n    function submitTokenToEthOrder(uint128 srcAmount, uint128 dstAmount)\r\n        public\r\n        returns(bool)\r\n    {\r\n        return submitTokenToEthOrderWHint(srcAmount, dstAmount, 0);\r\n    }\r\n\r\n    function submitTokenToEthOrderWHint(uint128 srcAmount, uint128 dstAmount, uint32 hintPrevOrder)\r\n        public\r\n        returns(bool)\r\n    {\r\n        uint32 newId = fetchNewOrderId(makerOrdersTokenToEth[msg.sender]);\r\n        return addOrder(false, newId, srcAmount, dstAmount, hintPrevOrder);\r\n    }\r\n\r\n    ///@param srcAmount is the Ether amount that will be payed, must be deposited before hand.\r\n    ///@param dstAmount is the token amount the maker expects to get for his Ether.\r\n    function submitEthToTokenOrder(uint128 srcAmount, uint128 dstAmount)\r\n        public\r\n        returns(bool)\r\n    {\r\n        return submitEthToTokenOrderWHint(srcAmount, dstAmount, 0);\r\n    }\r\n\r\n    function submitEthToTokenOrderWHint(uint128 srcAmount, uint128 dstAmount, uint32 hintPrevOrder)\r\n        public\r\n        returns(bool)\r\n    {\r\n        uint32 newId = fetchNewOrderId(makerOrdersEthToToken[msg.sender]);\r\n        return addOrder(true, newId, srcAmount, dstAmount, hintPrevOrder);\r\n    }\r\n\r\n    ///@dev notice here a batch of orders represented in arrays. order x is represented by x cells of all arrays.\r\n    ///@dev all arrays expected to the same length.\r\n    ///@param isEthToToken per each order. is order x eth to token (= src is Eth) or vice versa.\r\n    ///@param srcAmount per each order. source amount for order x.\r\n    ///@param dstAmount per each order. destination amount for order x.\r\n    ///@param hintPrevOrder per each order what is the order it should be added after in ordered list. 0 for no hint.\r\n    ///@param isAfterPrevOrder per each order, set true if should be added in list right after previous added order.\r\n    function addOrderBatch(bool[] isEthToToken, uint128[] srcAmount, uint128[] dstAmount,\r\n        uint32[] hintPrevOrder, bool[] isAfterPrevOrder)\r\n        public\r\n        returns(bool)\r\n    {\r\n        require(isEthToToken.length == hintPrevOrder.length);\r\n        require(isEthToToken.length == dstAmount.length);\r\n        require(isEthToToken.length == srcAmount.length);\r\n        require(isEthToToken.length == isAfterPrevOrder.length);\r\n\r\n        address maker = msg.sender;\r\n        uint32 prevId;\r\n        uint32 newId = 0;\r\n\r\n        for (uint i = 0; i < isEthToToken.length; ++i) {\r\n            prevId = isAfterPrevOrder[i] ? newId : hintPrevOrder[i];\r\n            newId = fetchNewOrderId(isEthToToken[i] ? makerOrdersEthToToken[maker] : makerOrdersTokenToEth[maker]);\r\n            require(addOrder(isEthToToken[i], newId, srcAmount[i], dstAmount[i], prevId));\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function updateTokenToEthOrder(uint32 orderId, uint128 newSrcAmount, uint128 newDstAmount)\r\n        public\r\n        returns(bool)\r\n    {\r\n        require(updateTokenToEthOrderWHint(orderId, newSrcAmount, newDstAmount, 0));\r\n        return true;\r\n    }\r\n\r\n    function updateTokenToEthOrderWHint(\r\n        uint32 orderId,\r\n        uint128 newSrcAmount,\r\n        uint128 newDstAmount,\r\n        uint32 hintPrevOrder\r\n    )\r\n        public\r\n        returns(bool)\r\n    {\r\n        require(updateOrder(false, orderId, newSrcAmount, newDstAmount, hintPrevOrder));\r\n        return true;\r\n    }\r\n\r\n    function updateEthToTokenOrder(uint32 orderId, uint128 newSrcAmount, uint128 newDstAmount)\r\n        public\r\n        returns(bool)\r\n    {\r\n        return updateEthToTokenOrderWHint(orderId, newSrcAmount, newDstAmount, 0);\r\n    }\r\n\r\n    function updateEthToTokenOrderWHint(\r\n        uint32 orderId,\r\n        uint128 newSrcAmount,\r\n        uint128 newDstAmount,\r\n        uint32 hintPrevOrder\r\n    )\r\n        public\r\n        returns(bool)\r\n    {\r\n        require(updateOrder(true, orderId, newSrcAmount, newDstAmount, hintPrevOrder));\r\n        return true;\r\n    }\r\n\r\n    function updateOrderBatch(bool[] isEthToToken, uint32[] orderId, uint128[] newSrcAmount,\r\n        uint128[] newDstAmount, uint32[] hintPrevOrder)\r\n        public\r\n        returns(bool)\r\n    {\r\n        require(isEthToToken.length == orderId.length);\r\n        require(isEthToToken.length == newSrcAmount.length);\r\n        require(isEthToToken.length == newDstAmount.length);\r\n        require(isEthToToken.length == hintPrevOrder.length);\r\n\r\n        for (uint i = 0; i < isEthToToken.length; ++i) {\r\n            require(updateOrder(isEthToToken[i], orderId[i], newSrcAmount[i], newDstAmount[i],\r\n                hintPrevOrder[i]));\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    event TokenDeposited(address indexed maker, uint amount);\r\n\r\n    function depositToken(address maker, uint amount) public {\r\n        require(maker != address(0));\r\n        require(amount < MAX_QTY);\r\n\r\n        require(contracts.token.transferFrom(msg.sender, this, amount));\r\n\r\n        makerFunds[maker][contracts.token] += amount;\r\n        TokenDeposited(maker, amount);\r\n    }\r\n\r\n    event EtherDeposited(address indexed maker, uint amount);\r\n\r\n    function depositEther(address maker) public payable {\r\n        require(maker != address(0));\r\n\r\n        makerFunds[maker][ETH_TOKEN_ADDRESS] += msg.value;\r\n        EtherDeposited(maker, msg.value);\r\n    }\r\n\r\n    event KncFeeDeposited(address indexed maker, uint amount);\r\n\r\n    // knc will be staked per order. part of the amount will be used as fee.\r\n    function depositKncForFee(address maker, uint amount) public {\r\n        require(maker != address(0));\r\n        require(amount < MAX_QTY);\r\n\r\n        require(contracts.kncToken.transferFrom(msg.sender, this, amount));\r\n\r\n        makerKnc[maker] += amount;\r\n\r\n        KncFeeDeposited(maker, amount);\r\n\r\n        if (orderAllocationRequired(makerOrdersTokenToEth[maker])) {\r\n            require(allocateOrderIds(\r\n                makerOrdersTokenToEth[maker], /* makerOrders */\r\n                tokenToEthList.allocateIds(uint32(NUM_ORDERS)) /* firstAllocatedId */\r\n            ));\r\n        }\r\n\r\n        if (orderAllocationRequired(makerOrdersEthToToken[maker])) {\r\n            require(allocateOrderIds(\r\n                makerOrdersEthToToken[maker], /* makerOrders */\r\n                ethToTokenList.allocateIds(uint32(NUM_ORDERS)) /* firstAllocatedId */\r\n            ));\r\n        }\r\n    }\r\n\r\n    function withdrawToken(uint amount) public {\r\n\r\n        address maker = msg.sender;\r\n        uint makerFreeAmount = makerFunds[maker][contracts.token];\r\n\r\n        require(makerFreeAmount >= amount);\r\n\r\n        makerFunds[maker][contracts.token] -= amount;\r\n\r\n        require(contracts.token.transfer(maker, amount));\r\n    }\r\n\r\n    function withdrawEther(uint amount) public {\r\n\r\n        address maker = msg.sender;\r\n        uint makerFreeAmount = makerFunds[maker][ETH_TOKEN_ADDRESS];\r\n\r\n        require(makerFreeAmount >= amount);\r\n\r\n        makerFunds[maker][ETH_TOKEN_ADDRESS] -= amount;\r\n\r\n        maker.transfer(amount);\r\n    }\r\n\r\n    function withdrawKncFee(uint amount) public {\r\n\r\n        address maker = msg.sender;\r\n        \r\n        require(makerKnc[maker] >= amount);\r\n        require(makerUnlockedKnc(maker) >= amount);\r\n\r\n        makerKnc[maker] -= amount;\r\n\r\n        require(contracts.kncToken.transfer(maker, amount));\r\n    }\r\n\r\n    function cancelTokenToEthOrder(uint32 orderId) public returns(bool) {\r\n        require(cancelOrder(false, orderId));\r\n        return true;\r\n    }\r\n\r\n    function cancelEthToTokenOrder(uint32 orderId) public returns(bool) {\r\n        require(cancelOrder(true, orderId));\r\n        return true;\r\n    }\r\n\r\n    function setMinOrderSizeEth() public returns(bool) {\r\n        //get eth to $ from maker dao;\r\n        bytes32 usdPerEthInWei;\r\n        bool valid;\r\n        (usdPerEthInWei, valid) = contracts.medianizer.peek();\r\n        require(valid);\r\n\r\n        // ensuring that there is no underflow or overflow possible,\r\n        // even if the price is compromised\r\n        uint usdPerEth = uint(usdPerEthInWei) / (1 ether);\r\n        require(usdPerEth != 0);\r\n        require(usdPerEth < MAX_USD_PER_ETH);\r\n\r\n        // set Eth order limits according to price\r\n        uint minNewOrderSizeWei = limits.minNewOrderSizeUsd * PRECISION * (1 ether) / uint(usdPerEthInWei);\r\n\r\n        limits.minNewOrderSizeWei = minNewOrderSizeWei;\r\n        limits.minOrderSizeWei = limits.minNewOrderSizeWei / MIN_REMAINING_ORDER_RATIO;\r\n\r\n        return true;\r\n    }\r\n\r\n    ///@dev Each maker stakes per order KNC that is factor of the required burn amount.\r\n    ///@dev If Knc per Eth rate becomes lower by more then factor, stake will not be enough and trade will be blocked.\r\n    function kncRateBlocksTrade() public view returns (bool) {\r\n        return (contracts.feeBurner.kncPerEthRatePrecision() > kncPerEthBaseRatePrecision * BURN_TO_STAKE_FACTOR);\r\n    }\r\n\r\n    function getTokenToEthAddOrderHint(uint128 srcAmount, uint128 dstAmount) public view returns (uint32) {\r\n        require(dstAmount >= limits.minNewOrderSizeWei);\r\n        return tokenToEthList.findPrevOrderId(srcAmount, dstAmount);\r\n    }\r\n\r\n    function getEthToTokenAddOrderHint(uint128 srcAmount, uint128 dstAmount) public view returns (uint32) {\r\n        require(srcAmount >= limits.minNewOrderSizeWei);\r\n        return ethToTokenList.findPrevOrderId(srcAmount, dstAmount);\r\n    }\r\n\r\n    function getTokenToEthUpdateOrderHint(uint32 orderId, uint128 srcAmount, uint128 dstAmount)\r\n        public\r\n        view\r\n        returns (uint32)\r\n    {\r\n        require(dstAmount >= limits.minNewOrderSizeWei);\r\n        uint32 prevId = tokenToEthList.findPrevOrderId(srcAmount, dstAmount);\r\n        address add;\r\n        uint128 noUse;\r\n        uint32 next;\r\n\r\n        if (prevId == orderId) {\r\n            (add, noUse, noUse, prevId, next) = tokenToEthList.getOrderDetails(orderId);\r\n        }\r\n\r\n        return prevId;\r\n    }\r\n\r\n    function getEthToTokenUpdateOrderHint(uint32 orderId, uint128 srcAmount, uint128 dstAmount)\r\n        public\r\n        view\r\n        returns (uint32)\r\n    {\r\n        require(srcAmount >= limits.minNewOrderSizeWei);\r\n        uint32 prevId = ethToTokenList.findPrevOrderId(srcAmount, dstAmount);\r\n        address add;\r\n        uint128 noUse;\r\n        uint32 next;\r\n\r\n        if (prevId == orderId) {\r\n            (add, noUse, noUse, prevId, next) = ethToTokenList.getOrderDetails(orderId);\r\n        }\r\n\r\n        return prevId;\r\n    }\r\n\r\n    function getTokenToEthOrder(uint32 orderId)\r\n        public view\r\n        returns (\r\n            address _maker,\r\n            uint128 _srcAmount,\r\n            uint128 _dstAmount,\r\n            uint32 _prevId,\r\n            uint32 _nextId\r\n        )\r\n    {\r\n        return tokenToEthList.getOrderDetails(orderId);\r\n    }\r\n\r\n    function getEthToTokenOrder(uint32 orderId)\r\n        public view\r\n        returns (\r\n            address _maker,\r\n            uint128 _srcAmount,\r\n            uint128 _dstAmount,\r\n            uint32 _prevId,\r\n            uint32 _nextId\r\n        )\r\n    {\r\n        return ethToTokenList.getOrderDetails(orderId);\r\n    }\r\n\r\n    function makerRequiredKncStake(address maker) public view returns (uint) {\r\n        return(calcKncStake(makerTotalOrdersWei[maker]));\r\n    }\r\n\r\n    function makerUnlockedKnc(address maker) public view returns (uint) {\r\n        uint requiredKncStake = makerRequiredKncStake(maker);\r\n        if (requiredKncStake > makerKnc[maker]) return 0;\r\n        return (makerKnc[maker] - requiredKncStake);\r\n    }\r\n\r\n    function calcKncStake(uint weiAmount) public view returns(uint) {\r\n        return(calcBurnAmount(weiAmount) * BURN_TO_STAKE_FACTOR);\r\n    }\r\n\r\n    function calcBurnAmount(uint weiAmount) public view returns(uint) {\r\n        return(weiAmount * makerBurnFeeBps * kncPerEthBaseRatePrecision / (10000 * PRECISION));\r\n    }\r\n\r\n    function calcBurnAmountFromFeeBurner(uint weiAmount) public view returns(uint) {\r\n        return(weiAmount * makerBurnFeeBps * contracts.feeBurner.kncPerEthRatePrecision() / (10000 * PRECISION));\r\n    }\r\n\r\n    ///@dev This function is not fully optimized gas wise. Consider before calling on chain.\r\n    function getEthToTokenMakerOrderIds(address maker) public view returns(uint32[] orderList) {\r\n        OrderIdData storage makerOrders = makerOrdersEthToToken[maker];\r\n        orderList = new uint32[](getNumActiveOrderIds(makerOrders));\r\n        uint activeOrder = 0;\r\n\r\n        for (uint32 i = 0; i < NUM_ORDERS; ++i) {\r\n            if ((makerOrders.takenBitmap & (uint(1) << i) > 0)) orderList[activeOrder++] = makerOrders.firstOrderId + i;\r\n        }\r\n    }\r\n\r\n    ///@dev This function is not fully optimized gas wise. Consider before calling on chain.\r\n    function getTokenToEthMakerOrderIds(address maker) public view returns(uint32[] orderList) {\r\n        OrderIdData storage makerOrders = makerOrdersTokenToEth[maker];\r\n        orderList = new uint32[](getNumActiveOrderIds(makerOrders));\r\n        uint activeOrder = 0;\r\n\r\n        for (uint32 i = 0; i < NUM_ORDERS; ++i) {\r\n            if ((makerOrders.takenBitmap & (uint(1) << i) > 0)) orderList[activeOrder++] = makerOrders.firstOrderId + i;\r\n        }\r\n    }\r\n\r\n    ///@dev This function is not fully optimized gas wise. Consider before calling on chain.\r\n    function getEthToTokenOrderList() public view returns(uint32[] orderList) {\r\n        OrderListInterface list = ethToTokenList;\r\n        return getList(list);\r\n    }\r\n\r\n    ///@dev This function is not fully optimized gas wise. Consider before calling on chain.\r\n    function getTokenToEthOrderList() public view returns(uint32[] orderList) {\r\n        OrderListInterface list = tokenToEthList;\r\n        return getList(list);\r\n    }\r\n\r\n    event NewLimitOrder(\r\n        address indexed maker,\r\n        uint32 orderId,\r\n        bool isEthToToken,\r\n        uint128 srcAmount,\r\n        uint128 dstAmount,\r\n        bool addedWithHint\r\n    );\r\n\r\n    function addOrder(bool isEthToToken, uint32 newId, uint128 srcAmount, uint128 dstAmount, uint32 hintPrevOrder)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        require(srcAmount < MAX_QTY);\r\n        require(dstAmount < MAX_QTY);\r\n        address maker = msg.sender;\r\n\r\n        require(secureAddOrderFunds(maker, isEthToToken, srcAmount, dstAmount));\r\n        require(validateLegalRate(srcAmount, dstAmount, isEthToToken));\r\n\r\n        bool addedWithHint = false;\r\n        OrderListInterface list = isEthToToken ? ethToTokenList : tokenToEthList;\r\n\r\n        if (hintPrevOrder != 0) {\r\n            addedWithHint = list.addAfterId(maker, newId, srcAmount, dstAmount, hintPrevOrder);\r\n        }\r\n\r\n        if (!addedWithHint) {\r\n            require(list.add(maker, newId, srcAmount, dstAmount));\r\n        }\r\n\r\n        NewLimitOrder(maker, newId, isEthToToken, srcAmount, dstAmount, addedWithHint);\r\n\r\n        return true;\r\n    }\r\n\r\n    event OrderUpdated(\r\n        address indexed maker,\r\n        bool isEthToToken,\r\n        uint orderId,\r\n        uint128 srcAmount,\r\n        uint128 dstAmount,\r\n        bool updatedWithHint\r\n    );\r\n\r\n    function updateOrder(bool isEthToToken, uint32 orderId, uint128 newSrcAmount,\r\n        uint128 newDstAmount, uint32 hintPrevOrder)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        require(newSrcAmount < MAX_QTY);\r\n        require(newDstAmount < MAX_QTY);\r\n        address maker;\r\n        uint128 currDstAmount;\r\n        uint128 currSrcAmount;\r\n        uint32 noUse;\r\n        uint noUse2;\r\n\r\n        require(validateLegalRate(newSrcAmount, newDstAmount, isEthToToken));\r\n\r\n        OrderListInterface list = isEthToToken ? ethToTokenList : tokenToEthList;\r\n\r\n        (maker, currSrcAmount, currDstAmount, noUse, noUse) = list.getOrderDetails(orderId);\r\n        require(maker == msg.sender);\r\n\r\n        if (!secureUpdateOrderFunds(maker, isEthToToken, currSrcAmount, currDstAmount, newSrcAmount, newDstAmount)) {\r\n            return false;\r\n        }\r\n\r\n        bool updatedWithHint = false;\r\n\r\n        if (hintPrevOrder != 0) {\r\n            (updatedWithHint, noUse2) = list.updateWithPositionHint(orderId, newSrcAmount, newDstAmount, hintPrevOrder);\r\n        }\r\n\r\n        if (!updatedWithHint) {\r\n            require(list.update(orderId, newSrcAmount, newDstAmount));\r\n        }\r\n\r\n        OrderUpdated(maker, isEthToToken, orderId, newSrcAmount, newDstAmount, updatedWithHint);\r\n\r\n        return true;\r\n    }\r\n\r\n    event OrderCanceled(address indexed maker, bool isEthToToken, uint32 orderId, uint128 srcAmount, uint dstAmount);\r\n\r\n    function cancelOrder(bool isEthToToken, uint32 orderId) internal returns(bool) {\r\n\r\n        address maker = msg.sender;\r\n        OrderListInterface list = isEthToToken ? ethToTokenList : tokenToEthList;\r\n        OrderData memory orderData = getOrderData(list, orderId);\r\n\r\n        require(orderData.maker == maker);\r\n\r\n        uint weiAmount = isEthToToken ? orderData.srcAmount : orderData.dstAmount;\r\n        require(releaseOrderStakes(maker, weiAmount, 0));\r\n\r\n        require(removeOrder(list, maker, isEthToToken ? ETH_TOKEN_ADDRESS : contracts.token, orderId));\r\n\r\n        //funds go back to makers account\r\n        makerFunds[maker][isEthToToken ? ETH_TOKEN_ADDRESS : contracts.token] += orderData.srcAmount;\r\n\r\n        OrderCanceled(maker, isEthToToken, orderId, orderData.srcAmount, orderData.dstAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    ///@param maker is the maker of this order\r\n    ///@param isEthToToken which order type the maker is updating / adding\r\n    ///@param srcAmount is the orders src amount (token or ETH) could be negative if funds are released.\r\n    function bindOrderFunds(address maker, bool isEthToToken, int srcAmount)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        address fundsAddress = isEthToToken ? ETH_TOKEN_ADDRESS : contracts.token;\r\n\r\n        if (srcAmount < 0) {\r\n            makerFunds[maker][fundsAddress] += uint(-srcAmount);\r\n        } else {\r\n            require(makerFunds[maker][fundsAddress] >= uint(srcAmount));\r\n            makerFunds[maker][fundsAddress] -= uint(srcAmount);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    ///@param maker is the maker address\r\n    ///@param weiAmount is the wei amount inside order that should result in knc staking\r\n    function bindOrderStakes(address maker, int weiAmount) internal returns(bool) {\r\n\r\n        if (weiAmount < 0) {\r\n            uint decreaseWeiAmount = uint(-weiAmount);\r\n            if (decreaseWeiAmount > makerTotalOrdersWei[maker]) decreaseWeiAmount = makerTotalOrdersWei[maker];\r\n            makerTotalOrdersWei[maker] -= decreaseWeiAmount;\r\n            return true;\r\n        }\r\n\r\n        require(makerKnc[maker] >= calcKncStake(makerTotalOrdersWei[maker] + uint(weiAmount)));\r\n\r\n        makerTotalOrdersWei[maker] += uint(weiAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    ///@dev if totalWeiAmount is 0 we only release stakes.\r\n    ///@dev if totalWeiAmount == weiForBurn. all staked amount will be burned. so no knc returned to maker\r\n    ///@param maker is the maker address\r\n    ///@param totalWeiAmount is total wei amount that was released from order - including taken wei amount.\r\n    ///@param weiForBurn is the part in order wei amount that was taken and should result in burning.\r\n    function releaseOrderStakes(address maker, uint totalWeiAmount, uint weiForBurn) internal returns(bool) {\r\n\r\n        require(weiForBurn <= totalWeiAmount);\r\n\r\n        if (totalWeiAmount > makerTotalOrdersWei[maker]) {\r\n            makerTotalOrdersWei[maker] = 0;\r\n        } else {\r\n            makerTotalOrdersWei[maker] -= totalWeiAmount;\r\n        }\r\n\r\n        if (weiForBurn == 0) return true;\r\n\r\n        uint burnAmount = calcBurnAmountFromFeeBurner(weiForBurn);\r\n\r\n        require(makerKnc[maker] >= burnAmount);\r\n        makerKnc[maker] -= burnAmount;\r\n\r\n        return true;\r\n    }\r\n\r\n    ///@dev funds are valid only when required knc amount can be staked for this order.\r\n    function secureAddOrderFunds(address maker, bool isEthToToken, uint128 srcAmount, uint128 dstAmount)\r\n        internal returns(bool)\r\n    {\r\n        uint weiAmount = isEthToToken ? srcAmount : dstAmount;\r\n\r\n        require(weiAmount >= limits.minNewOrderSizeWei);\r\n        require(bindOrderFunds(maker, isEthToToken, int(srcAmount)));\r\n        require(bindOrderStakes(maker, int(weiAmount)));\r\n\r\n        return true;\r\n    }\r\n\r\n    ///@dev funds are valid only when required knc amount can be staked for this order.\r\n    function secureUpdateOrderFunds(address maker, bool isEthToToken, uint128 prevSrcAmount, uint128 prevDstAmount,\r\n        uint128 newSrcAmount, uint128 newDstAmount)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        uint weiAmount = isEthToToken ? newSrcAmount : newDstAmount;\r\n        int weiDiff = isEthToToken ? (int(newSrcAmount) - int(prevSrcAmount)) :\r\n            (int(newDstAmount) - int(prevDstAmount));\r\n\r\n        require(weiAmount >= limits.minNewOrderSizeWei);\r\n\r\n        require(bindOrderFunds(maker, isEthToToken, int(newSrcAmount) - int(prevSrcAmount)));\r\n\r\n        require(bindOrderStakes(maker, weiDiff));\r\n\r\n        return true;\r\n    }\r\n\r\n    event FullOrderTaken(address maker, uint32 orderId, bool isEthToToken);\r\n\r\n    function takeFullOrder(\r\n        address maker,\r\n        uint32 orderId,\r\n        ERC20 userSrc,\r\n        ERC20 userDst,\r\n        uint128 userSrcAmount,\r\n        uint128 userDstAmount\r\n    )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        OrderListInterface list = (userSrc == ETH_TOKEN_ADDRESS) ? tokenToEthList : ethToTokenList;\r\n\r\n        //userDst == maker source\r\n        require(removeOrder(list, maker, userDst, orderId));\r\n\r\n        FullOrderTaken(maker, orderId, userSrc == ETH_TOKEN_ADDRESS);\r\n\r\n        return takeOrder(maker, userSrc, userSrcAmount, userDstAmount, 0);\r\n    }\r\n\r\n    event PartialOrderTaken(address maker, uint32 orderId, bool isEthToToken, bool isRemoved);\r\n\r\n    function takePartialOrder(\r\n        address maker,\r\n        uint32 orderId,\r\n        ERC20 userSrc,\r\n        ERC20 userDst,\r\n        uint128 userPartialSrcAmount,\r\n        uint128 userTakeDstAmount,\r\n        uint128 orderSrcAmount,\r\n        uint128 orderDstAmount\r\n    )\r\n        internal\r\n        returns(bool)\r\n    {\r\n        require(userPartialSrcAmount < orderDstAmount);\r\n        require(userTakeDstAmount < orderSrcAmount);\r\n\r\n        //must reuse parameters, otherwise stack too deep error.\r\n        orderSrcAmount -= userTakeDstAmount;\r\n        orderDstAmount -= userPartialSrcAmount;\r\n\r\n        OrderListInterface list = (userSrc == ETH_TOKEN_ADDRESS) ? tokenToEthList : ethToTokenList;\r\n        uint weiValueNotReleasedFromOrder = (userSrc == ETH_TOKEN_ADDRESS) ? orderDstAmount : orderSrcAmount;\r\n        uint additionalReleasedWei = 0;\r\n\r\n        if (weiValueNotReleasedFromOrder < limits.minOrderSizeWei) {\r\n            // remaining order amount too small. remove order and add remaining funds to free funds\r\n            makerFunds[maker][userDst] += orderSrcAmount;\r\n            additionalReleasedWei = weiValueNotReleasedFromOrder;\r\n\r\n            //for remove order we give makerSrc == userDst\r\n            require(removeOrder(list, maker, userDst, orderId));\r\n        } else {\r\n            bool isSuccess;\r\n\r\n            // update order values, taken order is always first order\r\n            (isSuccess,) = list.updateWithPositionHint(orderId, orderSrcAmount, orderDstAmount, HEAD_ID);\r\n            require(isSuccess);\r\n        }\r\n\r\n        PartialOrderTaken(maker, orderId, userSrc == ETH_TOKEN_ADDRESS, additionalReleasedWei > 0);\r\n\r\n        //stakes are returned for unused wei value\r\n        return(takeOrder(maker, userSrc, userPartialSrcAmount, userTakeDstAmount, additionalReleasedWei));\r\n    }\r\n    \r\n    function takeOrder(\r\n        address maker,\r\n        ERC20 userSrc,\r\n        uint userSrcAmount,\r\n        uint userDstAmount,\r\n        uint additionalReleasedWei\r\n    )\r\n        internal\r\n        returns(bool)\r\n    {\r\n        uint weiAmount = userSrc == (ETH_TOKEN_ADDRESS) ? userSrcAmount : userDstAmount;\r\n\r\n        //token / eth already collected. just update maker balance\r\n        makerFunds[maker][userSrc] += userSrcAmount;\r\n\r\n        // send dst tokens in one batch. not here\r\n        //handle knc stakes and fee. releasedWeiValue was released and not traded.\r\n        return releaseOrderStakes(maker, (weiAmount + additionalReleasedWei), weiAmount);\r\n    }\r\n\r\n    function removeOrder(\r\n        OrderListInterface list,\r\n        address maker,\r\n        ERC20 makerSrc,\r\n        uint32 orderId\r\n    )\r\n        internal returns(bool)\r\n    {\r\n        require(list.remove(orderId));\r\n        OrderIdData storage orders = (makerSrc == ETH_TOKEN_ADDRESS) ?\r\n            makerOrdersEthToToken[maker] : makerOrdersTokenToEth[maker];\r\n        require(releaseOrderId(orders, orderId));\r\n\r\n        return true;\r\n    }\r\n\r\n    function getList(OrderListInterface list) internal view returns(uint32[] memory orderList) {\r\n        OrderData memory orderData;\r\n        uint32 orderId;\r\n        bool isEmpty;\r\n\r\n        (orderId, isEmpty) = list.getFirstOrder();\r\n        if (isEmpty) return(new uint32[](0));\r\n\r\n        uint numOrders = 0;\r\n\r\n        for (; !orderData.isLastOrder; orderId = orderData.nextId) {\r\n            orderData = getOrderData(list, orderId);\r\n            numOrders++;\r\n        }\r\n\r\n        orderList = new uint32[](numOrders);\r\n\r\n        (orderId, orderData.isLastOrder) = list.getFirstOrder();\r\n\r\n        for (uint i = 0; i < numOrders; i++) {\r\n            orderList[i] = orderId;\r\n            orderData = getOrderData(list, orderId);\r\n            orderId = orderData.nextId;\r\n        }\r\n    }\r\n\r\n    function getOrderData(OrderListInterface list, uint32 orderId) internal view returns (OrderData data) {\r\n        uint32 prevId;\r\n        (data.maker, data.srcAmount, data.dstAmount, prevId, data.nextId) = list.getOrderDetails(orderId);\r\n        data.isLastOrder = (data.nextId == TAIL_ID);\r\n    }\r\n\r\n    function validateLegalRate (uint srcAmount, uint dstAmount, bool isEthToToken)\r\n        internal view returns(bool)\r\n    {\r\n        uint rate;\r\n\r\n        /// notice, rate is calculated from taker perspective,\r\n        ///     for taker amounts are opposite. order srcAmount will be DstAmount for taker.\r\n        if (isEthToToken) {\r\n            rate = calcRateFromQty(dstAmount, srcAmount, getDecimals(contracts.token), ETH_DECIMALS);\r\n        } else {\r\n            rate = calcRateFromQty(dstAmount, srcAmount, ETH_DECIMALS, getDecimals(contracts.token));\r\n        }\r\n\r\n        if (rate > MAX_RATE) return false;\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"NUM_ORDERS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"srcAmount\",\"type\":\"uint128\"},{\"name\":\"dstAmount\",\"type\":\"uint128\"},{\"name\":\"hintPrevOrder\",\"type\":\"uint32\"}],\"name\":\"submitEthToTokenOrderWHint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"calcBurnAmountFromFeeBurner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint32\"},{\"name\":\"srcAmount\",\"type\":\"uint128\"},{\"name\":\"dstAmount\",\"type\":\"uint128\"}],\"name\":\"getEthToTokenUpdateOrderHint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"makerKnc\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"makerOrdersTokenToEth\",\"outputs\":[{\"name\":\"firstOrderId\",\"type\":\"uint32\"},{\"name\":\"takenBitmap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kncPerEthBaseRatePrecision\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"srcAmount\",\"type\":\"uint128\"},{\"name\":\"dstAmount\",\"type\":\"uint128\"}],\"name\":\"getTokenToEthAddOrderHint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BURN_TO_STAKE_FACTOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"isEthToToken\",\"type\":\"bool[]\"},{\"name\":\"srcAmount\",\"type\":\"uint128[]\"},{\"name\":\"dstAmount\",\"type\":\"uint128[]\"},{\"name\":\"hintPrevOrder\",\"type\":\"uint32[]\"},{\"name\":\"isAfterPrevOrder\",\"type\":\"bool[]\"}],\"name\":\"addOrderBatch\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"maker\",\"type\":\"address\"}],\"name\":\"depositEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_REMAINING_ORDER_RATIO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"makerOrdersEthToToken\",\"outputs\":[{\"name\":\"firstOrderId\",\"type\":\"uint32\"},{\"name\":\"takenBitmap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint32\"},{\"name\":\"newSrcAmount\",\"type\":\"uint128\"},{\"name\":\"newDstAmount\",\"type\":\"uint128\"},{\"name\":\"hintPrevOrder\",\"type\":\"uint32\"}],\"name\":\"updateEthToTokenOrderWHint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint32\"}],\"name\":\"cancelTokenToEthOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"maker\",\"type\":\"address\"}],\"name\":\"getEthToTokenMakerOrderIds\",\"outputs\":[{\"name\":\"orderList\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenToEthOrderList\",\"outputs\":[{\"name\":\"orderList\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"srcAmount\",\"type\":\"uint128\"},{\"name\":\"dstAmount\",\"type\":\"uint128\"}],\"name\":\"getEthToTokenAddOrderHint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_USD_PER_ETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenToEthList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contracts\",\"outputs\":[{\"name\":\"kncToken\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"feeBurner\",\"type\":\"address\"},{\"name\":\"kyberNetwork\",\"type\":\"address\"},{\"name\":\"medianizer\",\"type\":\"address\"},{\"name\":\"orderListFactory\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint32\"}],\"name\":\"getTokenToEthOrder\",\"outputs\":[{\"name\":\"_maker\",\"type\":\"address\"},{\"name\":\"_srcAmount\",\"type\":\"uint128\"},{\"name\":\"_dstAmount\",\"type\":\"uint128\"},{\"name\":\"_prevId\",\"type\":\"uint32\"},{\"name\":\"_nextId\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"srcToken\",\"type\":\"address\"},{\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"name\":\"dstToken\",\"type\":\"address\"},{\"name\":\"dstAddress\",\"type\":\"address\"},{\"name\":\"conversionRate\",\"type\":\"uint256\"},{\"name\":\"validate\",\"type\":\"bool\"}],\"name\":\"trade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"srcAmount\",\"type\":\"uint128\"},{\"name\":\"dstAmount\",\"type\":\"uint128\"}],\"name\":\"submitTokenToEthOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"srcAmount\",\"type\":\"uint128\"},{\"name\":\"dstAmount\",\"type\":\"uint128\"}],\"name\":\"submitEthToTokenOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_BURN_FEE_BPS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"dst\",\"type\":\"address\"},{\"name\":\"srcQty\",\"type\":\"uint256\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getConversionRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setKncPerEthBaseRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"calcKncStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint32\"},{\"name\":\"newSrcAmount\",\"type\":\"uint128\"},{\"name\":\"newDstAmount\",\"type\":\"uint128\"}],\"name\":\"updateEthToTokenOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"calcBurnAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limits\",\"outputs\":[{\"name\":\"minNewOrderSizeUsd\",\"type\":\"uint256\"},{\"name\":\"maxOrdersPerTrade\",\"type\":\"uint256\"},{\"name\":\"minNewOrderSizeWei\",\"type\":\"uint256\"},{\"name\":\"minOrderSizeWei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"maker\",\"type\":\"address\"}],\"name\":\"makerUnlockedKnc\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint32\"},{\"name\":\"srcAmount\",\"type\":\"uint128\"},{\"name\":\"dstAmount\",\"type\":\"uint128\"}],\"name\":\"getTokenToEthUpdateOrderHint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint32\"},{\"name\":\"newSrcAmount\",\"type\":\"uint128\"},{\"name\":\"newDstAmount\",\"type\":\"uint128\"},{\"name\":\"hintPrevOrder\",\"type\":\"uint32\"}],\"name\":\"updateTokenToEthOrderWHint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawKncFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint32\"},{\"name\":\"newSrcAmount\",\"type\":\"uint128\"},{\"name\":\"newDstAmount\",\"type\":\"uint128\"}],\"name\":\"updateTokenToEthOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"srcAmount\",\"type\":\"uint128\"},{\"name\":\"dstAmount\",\"type\":\"uint128\"},{\"name\":\"hintPrevOrder\",\"type\":\"uint32\"}],\"name\":\"submitTokenToEthOrderWHint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setMinOrderSizeEth\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"maker\",\"type\":\"address\"}],\"name\":\"getTokenToEthMakerOrderIds\",\"outputs\":[{\"name\":\"orderList\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"maker\",\"type\":\"address\"}],\"name\":\"makerRequiredKncStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint32\"}],\"name\":\"getEthToTokenOrder\",\"outputs\":[{\"name\":\"_maker\",\"type\":\"address\"},{\"name\":\"_srcAmount\",\"type\":\"uint128\"},{\"name\":\"_dstAmount\",\"type\":\"uint128\"},{\"name\":\"_prevId\",\"type\":\"uint32\"},{\"name\":\"_nextId\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HEAD_ID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"makerTotalOrdersWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositKncForFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"makerFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"makerBurnFeeBps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TAIL_ID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"init\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kncRateBlocksTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"isEthToToken\",\"type\":\"bool[]\"},{\"name\":\"orderId\",\"type\":\"uint32[]\"},{\"name\":\"newSrcAmount\",\"type\":\"uint128[]\"},{\"name\":\"newDstAmount\",\"type\":\"uint128[]\"},{\"name\":\"hintPrevOrder\",\"type\":\"uint32[]\"}],\"name\":\"updateOrderBatch\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEthToTokenOrderList\",\"outputs\":[{\"name\":\"orderList\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint32\"}],\"name\":\"cancelEthToTokenOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethToTokenList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"knc\",\"type\":\"address\"},{\"name\":\"reserveToken\",\"type\":\"address\"},{\"name\":\"burner\",\"type\":\"address\"},{\"name\":\"network\",\"type\":\"address\"},{\"name\":\"medianizer\",\"type\":\"address\"},{\"name\":\"factory\",\"type\":\"address\"},{\"name\":\"minNewOrderUsd\",\"type\":\"uint256\"},{\"name\":\"maxOrdersPerTrade\",\"type\":\"uint256\"},{\"name\":\"burnFeeBps\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"srcToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"dstToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dstAmount\",\"type\":\"uint256\"}],\"name\":\"OrderbookReserveTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EtherDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"KncFeeDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"orderId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"isEthToToken\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"srcAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"dstAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"addedWithHint\",\"type\":\"bool\"}],\"name\":\"NewLimitOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isEthToToken\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"srcAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"dstAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"updatedWithHint\",\"type\":\"bool\"}],\"name\":\"OrderUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isEthToToken\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"orderId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"srcAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"dstAmount\",\"type\":\"uint256\"}],\"name\":\"OrderCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"orderId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"isEthToToken\",\"type\":\"bool\"}],\"name\":\"FullOrderTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"orderId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"isEthToToken\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"isRemoved\",\"type\":\"bool\"}],\"name\":\"PartialOrderTaken\",\"type\":\"event\"}]","ContractName":"OrderbookReserve","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000dd974d5c2e2928dea5f71b9825b8b646686bd2000000000000000000000000000E8d6b471e332F140e7d9dbB99E5E3822F728DA60000000000000000000000008007aa43792A392b221DC091bdb2191E5fF626d100000000000000000000000065bF64Ff5f51272f729BDcD7AcFB00677ced86Cd000000000000000000000000729d19f657bd0614b4985cf1d82531c67569197b000000000000000000000000aba982e0190e27a32400a622fe016a44c4ffab6800000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000019","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://7eb541f3d1a2548f0c8d7e0ff28ca2edb63374d5242dead60640e16d719ac99d"}]}