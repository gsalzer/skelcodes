{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with buidler v1.2.0 https://buidler.dev\n\n// File contracts/interfaces/IBPool.sol\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is disstributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.6.2;\n\ninterface IBPool {\n    function isBound(address token) external view returns(bool);\n    function getBalance(address token) external view returns (uint);\n    function rebind(address token, uint balance, uint denorm) external;\n    function setSwapFee(uint swapFee) external;\n    function bind(address token, uint balance, uint denorm) external;\n    function unbind(address token) external;\n    function getDenormalizedWeight(address token) external view returns (uint);\n    function getTotalDenormalizedWeight() external view returns (uint);\n    function getCurrentTokens() external view returns(address[] memory);\n    function setController(address manager) external;\n\n    function calcPoolOutGivenSingleIn(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint poolSupply,\n        uint totalWeight,\n        uint tokenAmountIn,\n        uint swapFee\n    )\n        external pure\n        returns (uint poolAmountOut);\n\n    function calcSingleInGivenPoolOut(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint poolSupply,\n        uint totalWeight,\n        uint poolAmountOut,\n        uint swapFee\n    )\n        external pure\n        returns (uint tokenAmountIn);\n\n    function calcSingleOutGivenPoolIn(\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint poolSupply,\n        uint totalWeight,\n        uint poolAmountIn,\n        uint swapFee\n    )\n        external pure\n        returns (uint tokenAmountOut);\n\n    function calcPoolInGivenSingleOut(\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint poolSupply,\n        uint totalWeight,\n        uint tokenAmountOut,\n        uint swapFee\n    )\n        external pure\n        returns (uint poolAmountIn);\n}\n\n\n// File contracts/interfaces/IPSmartPool.sol\n\npragma solidity ^0.6.2;\n\n\n// Based on the liquidity bootstrapping pool by Balancer\ninterface IPSmartPool {\n    function joinPool(uint256 _amount) external;\n    function exitPool(uint256 _amount) external;\n}\n\n\n// File contracts/PCToken.sol\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.2;\n\n\n// Highly opinionated token implementation\n// Based on the balancer Implementation\n\ninterface IERC20 {\n    event Approval(address indexed _src, address indexed _dst, uint _amount);\n    event Transfer(address indexed _src, address indexed _dst, uint _amount);\n\n    function totalSupply() external view returns (uint);\n    function balanceOf(address _whom) external view returns (uint);\n    function allowance(address _src, address _dst) external view returns (uint);\n\n    function approve(address _dst, uint _amount) external returns (bool);\n    function transfer(address _dst, uint _amount) external returns (bool);\n    function transferFrom(\n        address _src, address _dst, uint _amount\n    ) external returns (bool);\n}\n\ncontract PCToken is IERC20 {\n    string public name     = \"Balancer Smart Pool\";\n    string public symbol   = \"BSP\";\n    uint8 public constant decimals = 18;\n\n    uint internal totalSupplyInternal;\n\n    mapping(address => uint)                   internal balance;\n    mapping(address => mapping(address=>uint)) internal allowanceInternal;\n\n    event Approval(address indexed _src, address indexed _dst, uint _amount);\n    event Transfer(address indexed _src, address indexed _dst, uint _amount);\n\n    uint public constant BONE              = 10**18;\n\n    uint public constant MAX_BOUND_TOKENS  = 8;\n\n    uint public constant MIN_WEIGHT        = BONE;\n    uint public constant MAX_WEIGHT        = BONE * 50;\n    uint public constant MAX_TOTAL_WEIGHT  = BONE * 50;\n    uint public constant MIN_BALANCE       = BONE / 10**6;\n    uint public constant MAX_BALANCE       = BONE * 10**12;\n\n    uint public constant MIN_POOL_SUPPLY   = BONE;\n\n    function badd(uint a, uint b)\n        internal pure\n        returns (uint)\n    {\n        uint c = a + b;\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\n        return c;\n    }\n\n    function bsub(uint a, uint b)\n        internal pure\n        returns (uint)\n    {\n        (uint c, bool flag) = bsubSign(a, b);\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\n        return c;\n    }\n\n    function bsubSign(uint a, uint b)\n        internal pure\n        returns (uint, bool)\n    {\n        if (a >= b) {\n            return (a - b, false);\n        } else {\n            return (b - a, true);\n        }\n    }\n\n    function bmul(uint a, uint b)\n        internal pure\n        returns (uint)\n    {\n        uint c0 = a * b;\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n        uint c1 = c0 + (BONE / 2);\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n        uint c2 = c1 / BONE;\n        return c2;\n    }\n\n    function bdiv(uint a, uint b)\n        internal pure\n        returns (uint)\n    {\n        require(b != 0, \"ERR_DIV_ZERO\");\n        uint c0 = a * BONE;\n        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\n        uint c1 = c0 + (b / 2);\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n        uint c2 = c1 / b;\n        return c2;\n    }\n\n    function _mint(uint _amount) internal {\n        balance[address(this)] = badd(balance[address(this)], _amount);\n        totalSupplyInternal = badd(totalSupplyInternal, _amount);\n        emit Transfer(address(0), address(this), _amount);\n    }\n\n    function _burn(uint _amount) internal {\n        require(balance[address(this)] >= _amount, \"ERR_INSUFFICIENT_BAL\");\n        balance[address(this)] = bsub(balance[address(this)], _amount);\n        totalSupplyInternal = bsub(totalSupplyInternal, _amount);\n        emit Transfer(address(this), address(0), _amount);\n    }\n\n    function _move(address _src, address _dst, uint _amount) internal {\n        require(balance[_src] >= _amount, \"ERR_INSUFFICIENT_BAL\");\n        balance[_src] = bsub(balance[_src], _amount);\n        balance[_dst] = badd(balance[_dst], _amount);\n        emit Transfer(_src, _dst, _amount);\n    }\n\n    function _push(address _to, uint _amount) internal {\n        _move(address(this), _to, _amount);\n    }\n\n    function _pull(address _from, uint _amount) internal {\n        _move(_from, address(this), _amount);\n    }\n\n    function allowance(address _src, address _dst) external view override returns (uint) {\n        return allowanceInternal[_src][_dst];\n    }\n\n    function balanceOf(address _whom) external view override returns (uint) {\n        return balance[_whom];\n    }\n\n    function totalSupply() public view override returns (uint) {\n        return totalSupplyInternal;\n    }\n\n    function approve(address _dst, uint _amount) external override returns (bool) {\n        allowanceInternal[msg.sender][_dst] = _amount;\n        emit Approval(msg.sender, _dst, _amount);\n        return true;\n    }\n\n    function increaseApproval(address _dst, uint _amount) external returns (bool) {\n        allowanceInternal[msg.sender][_dst] = badd(allowanceInternal[msg.sender][_dst], _amount);\n        emit Approval(msg.sender, _dst, allowanceInternal[msg.sender][_dst]);\n        return true;\n    }\n\n    function decreaseApproval(address _dst, uint _amount) external returns (bool) {\n        uint oldValue = allowanceInternal[msg.sender][_dst];\n        if (_amount > oldValue) {\n            allowanceInternal[msg.sender][_dst] = 0;\n        } else {\n            allowanceInternal[msg.sender][_dst] = bsub(oldValue, _amount);\n        }\n        emit Approval(msg.sender, _dst, allowanceInternal[msg.sender][_dst]);\n        return true;\n    }\n\n    function transfer(address _dst, uint _amount) external override returns (bool) {\n        _move(msg.sender, _dst, _amount);\n        return true;\n    }\n\n    function transferFrom(address _src, address _dst, uint _amount) external override returns (bool) {\n        require(msg.sender == _src || _amount <= allowanceInternal[_src][msg.sender], \"ERR_PCTOKEN_BAD_CALLER\");\n        _move(_src, _dst, _amount);\n        if (msg.sender != _src && allowanceInternal[_src][msg.sender] != uint256(-1)) {\n            allowanceInternal[_src][msg.sender] = bsub(allowanceInternal[_src][msg.sender], _amount);\n            emit Approval(msg.sender, _dst, allowanceInternal[_src][msg.sender]);\n        }\n        return true;\n    }\n}\n\n\n// File contracts/smart-pools/PBasicSmartPool.sol\n\npragma solidity ^0.6.2;\n\n\n\n\ncontract PBasicSmartPool is IPSmartPool, PCToken {\n    \n    IBPool public bPool;\n\n    modifier ready() {\n        require(address(bPool) != address(0), \"PBasicSmartPool.ready: not ready\");\n        _;\n    }   \n\n     event LOG_JOIN(\n        address indexed caller,\n        address indexed tokenIn,\n        uint256 tokenAmountIn\n    );\n\n    event LOG_EXIT(\n        address indexed caller,\n        address indexed tokenOut,\n        uint256 tokenAmountOut\n    );\n\n    constructor() public {\n        \n    }\n\n    // Seperated initializer for easier use with proxies\n    function init(address _bPool, string memory _name, string memory _symbol, uint256 _initialSupply) public {\n        require(address(bPool) == address(0), \"PBasicSmartPool.init: already initialised\");\n        bPool = IBPool(_bPool);\n        name = _name;\n        symbol = _symbol;\n        _mintPoolShare(_initialSupply);\n        _pushPoolShare(msg.sender, _initialSupply);\n    }\n\n    function joinPool(uint256 _amount) external override ready {\n        uint poolTotal = totalSupply();\n\n        uint ratio = bdiv(_amount, poolTotal);\n        require(ratio != 0);\n\n        address[] memory tokens = bPool.getCurrentTokens();\n\n        for (uint i = 0; i < tokens.length; i++) {\n            address t = tokens[i];\n            uint bal = bPool.getBalance(t);\n            uint tokenAmountIn = bmul(ratio, bal);\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\n        }\n        _mintPoolShare(_amount);\n        _pushPoolShare(msg.sender, _amount);\n    }\n\n    function exitPool(uint256 _amount) external override ready {\n\n        uint poolTotal = totalSupply();\n        uint ratio = bdiv(_amount, poolTotal);\n        require(ratio != 0);\n\n        _pullPoolShare(msg.sender, _amount);\n        _burnPoolShare(_amount);\n\n        address[] memory tokens = bPool.getCurrentTokens();\n\n        for (uint i = 0; i < tokens.length; i++) {\n            address t = tokens[i];\n            uint bal = bPool.getBalance(t);\n            uint tAo = bmul(ratio, bal);\n            emit LOG_EXIT(msg.sender, t, tAo);  \n            _pushUnderlying(t, msg.sender, tAo);\n        }\n    }\n\n    // Pull tokens from address and rebind BPool\n    function _pullUnderlying(address _token, address _from, uint _amount)\n        internal\n    {\n        // Gets current Balance of token i, Bi, and weight of token i, Wi, from BPool.\n        uint tokenBalance = bPool.getBalance(_token);\n        uint tokenWeight = bPool.getDenormalizedWeight(_token);\n\n        bool xfer = IERC20(_token).transferFrom(_from, address(this), _amount);\n        IERC20(_token).approve(address(bPool), _amount);\n        require(xfer, \"ERR_ERC20_FALSE\");\n        bPool.rebind(_token, badd(tokenBalance, _amount), tokenWeight);\n    }\n\n    // Rebind BPool and push tokens to address\n    function _pushUnderlying(address _token, address _to, uint _amount)\n        internal\n    {\n        // Gets current Balance of token i, Bi, and weight of token i, Wi, from BPool.\n        uint tokenBalance = bPool.getBalance(_token);\n        uint tokenWeight = bPool.getDenormalizedWeight(_token);\n        bPool.rebind(_token, bsub(tokenBalance, _amount), tokenWeight);\n\n        bool xfer = IERC20(_token).transfer(_to, _amount);\n        require(xfer, \"ERR_ERC20_FALSE\");\n    }\n    function _pullPoolShare(address _from, uint _amount)\n        internal\n    {\n        _pull(_from, _amount);\n    }\n\n    function _burnPoolShare(uint _amount)\n        internal\n    {\n        _burn(_amount);\n    }\n\n    function _mintPoolShare(uint _amount)\n        internal\n    {\n        _mint(_amount);\n    }\n\n    function _pushPoolShare(address _to, uint _amount)\n        internal\n    {\n        _push(_to, _amount);\n    }\n\n}\n\n\n// File contracts/interfaces/IBFactory.sol\n\npragma solidity ^0.6.2;\n\ninterface IBFactory {\n    function newBPool() external returns (address);\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_EXIT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"name\":\"LOG_JOIN\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TOTAL_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_POOL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dst\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bPool\",\"outputs\":[{\"internalType\":\"contract IBPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_whom\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"exitPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bPool\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_initialSupply\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"joinPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PBasicSmartPool","CompilerVersion":"v0.6.2+commit.bacdbe57","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":""}]}