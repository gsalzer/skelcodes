{"status":"1","message":"OK","result":[{"SourceCode":"/*\n* Synthetix - Synthetix.sol\n*\n* https://github.com/Synthetixio/synthetix\n* https://synthetix.io\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2019 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\t\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n    \n/* ===============================================\n* Flattened with Solidifier by Coinage\n* \n* https://solidifier.coina.ge\n* ===============================================\n*/\n\n\npragma solidity ^0.4.24;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\n\n/*\n\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       SafeDecimalMath.sol\nversion:    2.0\nauthor:     Kevin Brown\n            Gavin Conway\ndate:       2018-10-18\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nA library providing safe mathematical operations for division and\nmultiplication with the capability to round or truncate the results\nto the nearest increment. Operations can return a standard precision\nor high precision decimal. High precision decimals are useful for\nexample when attempting to calculate percentages or fractions\naccurately.\n\n-----------------------------------------------------------------\n*/\n\n\n/**\n * @title Safely manipulate unsigned fixed-point decimals at a given precision level.\n * @dev Functions accepting uints in this contract and derived contracts\n * are taken to be such fixed point decimals of a specified precision (either standard\n * or high).\n */\nlibrary SafeDecimalMath {\n\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10 ** uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10 ** uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10 ** uint(highPrecisionDecimals - decimals);\n\n    /** \n     * @return Provides an interface to UNIT.\n     */\n    function unit()\n        external\n        pure\n        returns (uint)\n    {\n        return UNIT;\n    }\n\n    /** \n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit()\n        external\n        pure \n        returns (uint)\n    {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     * \n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y)\n        internal\n        pure\n        returns (uint)\n    {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(uint x, uint y, uint precisionUnit)\n        private\n        pure\n        returns (uint)\n    {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y)\n        internal\n        pure\n        returns (uint)\n    {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y)\n        internal\n        pure\n        returns (uint)\n    {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     * \n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y)\n        internal\n        pure\n        returns (uint)\n    {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(uint x, uint y, uint precisionUnit)\n        private\n        pure\n        returns (uint)\n    {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y)\n        internal\n        pure\n        returns (uint)\n    {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y)\n        internal\n        pure\n        returns (uint)\n    {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i)\n        internal\n        pure\n        returns (uint)\n    {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i)\n        internal\n        pure\n        returns (uint)\n    {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       Owned.sol\nversion:    1.1\nauthor:     Anton Jurisevic\n            Dominic Romanowski\n\ndate:       2018-2-26\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nAn Owned contract, to be inherited by other contracts.\nRequires its owner to be explicitly set in the constructor.\nProvides an onlyOwner access modifier.\n\nTo change owner, the current owner must nominate the next owner,\nwho then has to accept the nomination. The nomination can be\ncancelled before it is accepted by the new owner by having the\nprevious owner change the nomination (setting it to 0).\n\n-----------------------------------------------------------------\n*/\n\n\n/**\n * @title A contract with an owner.\n * @notice Contract ownership can be transferred by first nominating the new owner,\n * who must then accept the ownership, which prevents accidental incorrect ownership transfers.\n */\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    /**\n     * @dev Owned Constructor\n     */\n    constructor(address _owner)\n        public\n    {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    /**\n     * @notice Nominate a new owner of this contract.\n     * @dev Only the current owner may nominate a new owner.\n     */\n    function nominateNewOwner(address _owner)\n        external\n        onlyOwner\n    {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    /**\n     * @notice Accept the nomination to be owner.\n     */\n    function acceptOwnership()\n        external\n    {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner\n    {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       SelfDestructible.sol\nversion:    1.2\nauthor:     Anton Jurisevic\n\ndate:       2018-05-29\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nThis contract allows an inheriting contract to be destroyed after\nits owner indicates an intention and then waits for a period\nwithout changing their mind. All ether contained in the contract\nis forwarded to a nominated beneficiary upon destruction.\n\n-----------------------------------------------------------------\n*/\n\n\n/**\n * @title A contract that can be destroyed by its owner after a delay elapses.\n */\ncontract SelfDestructible is Owned {\n    \n    uint public initiationTime;\n    bool public selfDestructInitiated;\n    address public selfDestructBeneficiary;\n    uint public constant SELFDESTRUCT_DELAY = 4 weeks;\n\n    /**\n     * @dev Constructor\n     * @param _owner The account which controls this contract.\n     */\n    constructor(address _owner)\n        Owned(_owner)\n        public\n    {\n        require(_owner != address(0), \"Owner must not be zero\");\n        selfDestructBeneficiary = _owner;\n        emit SelfDestructBeneficiaryUpdated(_owner);\n    }\n\n    /**\n     * @notice Set the beneficiary address of this contract.\n     * @dev Only the contract owner may call this. The provided beneficiary must be non-null.\n     * @param _beneficiary The address to pay any eth contained in this contract to upon self-destruction.\n     */\n    function setSelfDestructBeneficiary(address _beneficiary)\n        external\n        onlyOwner\n    {\n        require(_beneficiary != address(0), \"Beneficiary must not be zero\");\n        selfDestructBeneficiary = _beneficiary;\n        emit SelfDestructBeneficiaryUpdated(_beneficiary);\n    }\n\n    /**\n     * @notice Begin the self-destruction counter of this contract.\n     * Once the delay has elapsed, the contract may be self-destructed.\n     * @dev Only the contract owner may call this.\n     */\n    function initiateSelfDestruct()\n        external\n        onlyOwner\n    {\n        initiationTime = now;\n        selfDestructInitiated = true;\n        emit SelfDestructInitiated(SELFDESTRUCT_DELAY);\n    }\n\n    /**\n     * @notice Terminate and reset the self-destruction timer.\n     * @dev Only the contract owner may call this.\n     */\n    function terminateSelfDestruct()\n        external\n        onlyOwner\n    {\n        initiationTime = 0;\n        selfDestructInitiated = false;\n        emit SelfDestructTerminated();\n    }\n\n    /**\n     * @notice If the self-destruction delay has elapsed, destroy this contract and\n     * remit any ether it owns to the beneficiary address.\n     * @dev Only the contract owner may call this.\n     */\n    function selfDestruct()\n        external\n        onlyOwner\n    {\n        require(selfDestructInitiated, \"Self Destruct not yet initiated\");\n        require(initiationTime + SELFDESTRUCT_DELAY < now, \"Self destruct delay not met\");\n        address beneficiary = selfDestructBeneficiary;\n        emit SelfDestructed(beneficiary);\n        selfdestruct(beneficiary);\n    }\n\n    event SelfDestructTerminated();\n    event SelfDestructed(address beneficiary);\n    event SelfDestructInitiated(uint selfDestructDelay);\n    event SelfDestructBeneficiaryUpdated(address newBeneficiary);\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       State.sol\nversion:    1.1\nauthor:     Dominic Romanowski\n            Anton Jurisevic\n\ndate:       2018-05-15\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nThis contract is used side by side with external state token\ncontracts, such as Synthetix and Synth.\nIt provides an easy way to upgrade contract logic while\nmaintaining all user balances and allowances. This is designed\nto make the changeover as easy as possible, since mappings\nare not so cheap or straightforward to migrate.\n\nThe first deployed contract would create this state contract,\nusing it as its store of balances.\nWhen a new contract is deployed, it links to the existing\nstate contract, whose owner would then change its associated\ncontract to the new one.\n\n-----------------------------------------------------------------\n*/\n\n\ncontract State is Owned {\n    // the address of the contract that can modify variables\n    // this can only be changed by the owner of this contract\n    address public associatedContract;\n\n\n    constructor(address _owner, address _associatedContract)\n        Owned(_owner)\n        public\n    {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    /* ========== SETTERS ========== */\n\n    // Change the associated contract to a new address\n    function setAssociatedContract(address _associatedContract)\n        external\n        onlyOwner\n    {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyAssociatedContract\n    {\n        require(msg.sender == associatedContract, \"Only the associated contract can perform this action\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AssociatedContractUpdated(address associatedContract);\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       TokenState.sol\nversion:    1.1\nauthor:     Dominic Romanowski\n            Anton Jurisevic\n\ndate:       2018-05-15\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nA contract that holds the state of an ERC20 compliant token.\n\nThis contract is used side by side with external state token\ncontracts, such as Synthetix and Synth.\nIt provides an easy way to upgrade contract logic while\nmaintaining all user balances and allowances. This is designed\nto make the changeover as easy as possible, since mappings\nare not so cheap or straightforward to migrate.\n\nThe first deployed contract would create this state contract,\nusing it as its store of balances.\nWhen a new contract is deployed, it links to the existing\nstate contract, whose owner would then change its associated\ncontract to the new one.\n\n-----------------------------------------------------------------\n*/\n\n\n/**\n * @title ERC20 Token State\n * @notice Stores balance information of an ERC20 token contract.\n */\ncontract TokenState is State {\n\n    /* ERC20 fields. */\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    /**\n     * @dev Constructor\n     * @param _owner The address which controls this contract.\n     * @param _associatedContract The ERC20 contract whose state this composes.\n     */\n    constructor(address _owner, address _associatedContract)\n        State(_owner, _associatedContract)\n        public\n    {}\n\n    /* ========== SETTERS ========== */\n\n    /**\n     * @notice Set ERC20 allowance.\n     * @dev Only the associated contract may call this.\n     * @param tokenOwner The authorising party.\n     * @param spender The authorised party.\n     * @param value The total value the authorised party may spend on the\n     * authorising party's behalf.\n     */\n    function setAllowance(address tokenOwner, address spender, uint value)\n        external\n        onlyAssociatedContract\n    {\n        allowance[tokenOwner][spender] = value;\n    }\n\n    /**\n     * @notice Set the balance in a given account\n     * @dev Only the associated contract may call this.\n     * @param account The account whose value to set.\n     * @param value The new balance of the given account.\n     */\n    function setBalanceOf(address account, uint value)\n        external\n        onlyAssociatedContract\n    {\n        balanceOf[account] = value;\n    }\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       Proxy.sol\nversion:    1.3\nauthor:     Anton Jurisevic\n\ndate:       2018-05-29\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nA proxy contract that, if it does not recognise the function\nbeing called on it, passes all value and call data to an\nunderlying target contract.\n\nThis proxy has the capacity to toggle between DELEGATECALL\nand CALL style proxy functionality.\n\nThe former executes in the proxy's context, and so will preserve \nmsg.sender and store data at the proxy address. The latter will not.\nTherefore, any contract the proxy wraps in the CALL style must\nimplement the Proxyable interface, in order that it can pass msg.sender\ninto the underlying contract as the state parameter, messageSender.\n\n-----------------------------------------------------------------\n*/\n\n\ncontract Proxy is Owned {\n\n    Proxyable public target;\n    bool public useDELEGATECALL;\n\n    constructor(address _owner)\n        Owned(_owner)\n        public\n    {}\n\n    function setTarget(Proxyable _target)\n        external\n        onlyOwner\n    {\n        target = _target;\n        emit TargetUpdated(_target);\n    }\n\n    function setUseDELEGATECALL(bool value) \n        external\n        onlyOwner\n    {\n        useDELEGATECALL = value;\n    }\n\n    function _emit(bytes callData, uint numTopics, bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes32 topic4)\n        external\n        onlyTarget\n    {\n        uint size = callData.length;\n        bytes memory _callData = callData;\n\n        assembly {\n            /* The first 32 bytes of callData contain its length (as specified by the abi). \n             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\n             * in length. It is also leftpadded to be a multiple of 32 bytes.\n             * This means moving call_data across 32 bytes guarantees we correctly access\n             * the data itself. */\n            switch numTopics\n            case 0 {\n                log0(add(_callData, 32), size)\n            } \n            case 1 {\n                log1(add(_callData, 32), size, topic1)\n            }\n            case 2 {\n                log2(add(_callData, 32), size, topic1, topic2)\n            }\n            case 3 {\n                log3(add(_callData, 32), size, topic1, topic2, topic3)\n            }\n            case 4 {\n                log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\n            }\n        }\n    }\n\n    function()\n        external\n        payable\n    {\n        if (useDELEGATECALL) {\n            assembly {\n                /* Copy call data into free memory region. */\n                let free_ptr := mload(0x40)\n                calldatacopy(free_ptr, 0, calldatasize)\n\n                /* Forward all gas and call data to the target contract. */\n                let result := delegatecall(gas, sload(target_slot), free_ptr, calldatasize, 0, 0)\n                returndatacopy(free_ptr, 0, returndatasize)\n\n                /* Revert if the call failed, otherwise return the result. */\n                if iszero(result) { revert(free_ptr, returndatasize) }\n                return(free_ptr, returndatasize)\n            }\n        } else {\n            /* Here we are as above, but must send the messageSender explicitly \n             * since we are using CALL rather than DELEGATECALL. */\n            target.setMessageSender(msg.sender);\n            assembly {\n                let free_ptr := mload(0x40)\n                calldatacopy(free_ptr, 0, calldatasize)\n\n                /* We must explicitly forward ether to the underlying contract as well. */\n                let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\n                returndatacopy(free_ptr, 0, returndatasize)\n\n                if iszero(result) { revert(free_ptr, returndatasize) }\n                return(free_ptr, returndatasize)\n            }\n        }\n    }\n\n    modifier onlyTarget {\n        require(Proxyable(msg.sender) == target, \"Must be proxy target\");\n        _;\n    }\n\n    event TargetUpdated(Proxyable newTarget);\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       Proxyable.sol\nversion:    1.1\nauthor:     Anton Jurisevic\n\ndate:       2018-05-15\n\nchecked:    Mike Spain\napproved:   Samuel Brooks\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nA proxyable contract that works hand in hand with the Proxy contract\nto allow for anyone to interact with the underlying contract both\ndirectly and through the proxy.\n\n-----------------------------------------------------------------\n*/\n\n\n// This contract should be treated like an abstract contract\ncontract Proxyable is Owned {\n    /* The proxy this contract exists behind. */\n    Proxy public proxy;\n    Proxy public integrationProxy;\n\n    /* The caller of the proxy, passed through to this contract.\n     * Note that every function using this member must apply the onlyProxy or\n     * optionalProxy modifiers, otherwise their invocations can use stale values. */\n    address public messageSender;\n\n    constructor(address _proxy, address _owner)\n        Owned(_owner)\n        public\n    {\n        proxy = Proxy(_proxy);\n        emit ProxyUpdated(_proxy);\n    }\n\n    function setProxy(address _proxy)\n        external\n        onlyOwner\n    {\n        proxy = Proxy(_proxy);\n        emit ProxyUpdated(_proxy);\n    }\n\n    function setIntegrationProxy(address _integrationProxy)\n        external\n        onlyOwner\n    {\n        integrationProxy = Proxy(_integrationProxy);\n    }\n\n    function setMessageSender(address sender)\n        external\n        onlyProxy\n    {\n        messageSender = sender;\n    }\n\n    modifier onlyProxy {\n        require(Proxy(msg.sender) == proxy || Proxy(msg.sender) == integrationProxy, \"Only the proxy can call\");\n        _;\n    }\n\n    modifier optionalProxy\n    {\n        if (Proxy(msg.sender) != proxy && Proxy(msg.sender) != integrationProxy && messageSender != msg.sender) {\n            messageSender = msg.sender;\n        }\n        _;\n    }\n\n    modifier optionalProxy_onlyOwner\n    {\n        if (Proxy(msg.sender) != proxy && Proxy(msg.sender) != integrationProxy && messageSender != msg.sender) {\n            messageSender = msg.sender;\n        }\n        require(messageSender == owner, \"Owner only function\");\n        _;\n    }\n\n    event ProxyUpdated(address proxyAddress);\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       ExternStateToken.sol\nversion:    1.3\nauthor:     Anton Jurisevic\n            Dominic Romanowski\n            Kevin Brown\n\ndate:       2018-05-29\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nA partial ERC20 token contract, designed to operate with a proxy.\nTo produce a complete ERC20 token, transfer and transferFrom\ntokens must be implemented, using the provided _byProxy internal\nfunctions.\nThis contract utilises an external state for upgradeability.\n\n-----------------------------------------------------------------\n*/\n\n\n/**\n * @title ERC20 Token contract, with detached state and designed to operate behind a proxy.\n */\ncontract ExternStateToken is SelfDestructible, Proxyable {\n\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /* ========== STATE VARIABLES ========== */\n\n    /* Stores balances and allowances. */\n    TokenState public tokenState;\n\n    /* Other ERC20 fields. */\n    string public name;\n    string public symbol;\n    uint public totalSupply;\n    uint8 public decimals;\n\n    /**\n     * @dev Constructor.\n     * @param _proxy The proxy associated with this contract.\n     * @param _name Token's ERC20 name.\n     * @param _symbol Token's ERC20 symbol.\n     * @param _totalSupply The total supply of the token.\n     * @param _tokenState The TokenState contract address.\n     * @param _owner The owner of this contract.\n     */\n    constructor(address _proxy, TokenState _tokenState,\n                string _name, string _symbol, uint _totalSupply,\n                uint8 _decimals, address _owner)\n        SelfDestructible(_owner)\n        Proxyable(_proxy, _owner)\n        public\n    {\n        tokenState = _tokenState;\n\n        name = _name;\n        symbol = _symbol;\n        totalSupply = _totalSupply;\n        decimals = _decimals;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Returns the ERC20 allowance of one party to spend on behalf of another.\n     * @param owner The party authorising spending of their funds.\n     * @param spender The party spending tokenOwner's funds.\n     */\n    function allowance(address owner, address spender)\n        public\n        view\n        returns (uint)\n    {\n        return tokenState.allowance(owner, spender);\n    }\n\n    /**\n     * @notice Returns the ERC20 token balance of a given account.\n     */\n    function balanceOf(address account)\n        public\n        view\n        returns (uint)\n    {\n        return tokenState.balanceOf(account);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice Set the address of the TokenState contract.\n     * @dev This can be used to \"pause\" transfer functionality, by pointing the tokenState at 0x000..\n     * as balances would be unreachable.\n     */\n    function setTokenState(TokenState _tokenState)\n        external\n        optionalProxy_onlyOwner\n    {\n        tokenState = _tokenState;\n        emitTokenStateUpdated(_tokenState);\n    }\n\n    function _internalTransfer(address from, address to, uint value)\n        internal\n        returns (bool)\n    {\n        /* Disallow transfers to irretrievable-addresses. */\n        require(to != address(0) && to != address(this) && to != address(proxy), \"Cannot transfer to this address\");\n\n        // Insufficient balance will be handled by the safe subtraction.\n        tokenState.setBalanceOf(from, tokenState.balanceOf(from).sub(value));\n        tokenState.setBalanceOf(to, tokenState.balanceOf(to).add(value));\n\n        // Emit a standard ERC20 transfer event\n        emitTransfer(from, to, value);\n        \n        return true;\n    }\n\n    /**\n     * @dev Perform an ERC20 token transfer. Designed to be called by transfer functions possessing\n     * the onlyProxy or optionalProxy modifiers.\n     */\n    function _transfer_byProxy(address from, address to, uint value)\n        internal\n        returns (bool)\n    {\n        return _internalTransfer(from, to, value);\n    }\n\n    /**\n     * @dev Perform an ERC20 token transferFrom. Designed to be called by transferFrom functions\n     * possessing the optionalProxy or optionalProxy modifiers.\n     */\n    function _transferFrom_byProxy(address sender, address from, address to, uint value)\n        internal\n        returns (bool)\n    {\n        /* Insufficient allowance will be handled by the safe subtraction. */\n        tokenState.setAllowance(from, sender, tokenState.allowance(from, sender).sub(value));\n        return _internalTransfer(from, to, value);\n    }\n\n    /**\n     * @notice Approves spender to transfer on the message sender's behalf.\n     */\n    function approve(address spender, uint value)\n        public\n        optionalProxy\n        returns (bool)\n    {\n        address sender = messageSender;\n\n        tokenState.setAllowance(sender, spender, value);\n        emitApproval(sender, spender, value);\n        return true;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    bytes32 constant TRANSFER_SIG = keccak256(\"Transfer(address,address,uint256)\");\n    function emitTransfer(address from, address to, uint value) internal {\n        proxy._emit(abi.encode(value), 3, TRANSFER_SIG, bytes32(from), bytes32(to), 0);\n    }\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    bytes32 constant APPROVAL_SIG = keccak256(\"Approval(address,address,uint256)\");\n    function emitApproval(address owner, address spender, uint value) internal {\n        proxy._emit(abi.encode(value), 3, APPROVAL_SIG, bytes32(owner), bytes32(spender), 0);\n    }\n\n    event TokenStateUpdated(address newTokenState);\n    bytes32 constant TOKENSTATEUPDATED_SIG = keccak256(\"TokenStateUpdated(address)\");\n    function emitTokenStateUpdated(address newTokenState) internal {\n        proxy._emit(abi.encode(newTokenState), 1, TOKENSTATEUPDATED_SIG, 0, 0, 0);\n    }\n}\n\n\nlibrary Math {\n\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n    * @dev Uses \"exponentiation by squaring\" algorithm where cost is 0(logN)\n    * vs 0(N) for naive repeated multiplication. \n    * Calculates x^n with x as fixed-point and n as regular unsigned int.\n    * Calculates to 18 digits of precision with SafeDecimalMath.unit()\n    */\n    function powDecimal(uint x, uint n)\n        internal\n        pure\n        returns (uint)\n    {\n        // https://mpark.github.io/programming/2014/08/18/exponentiation-by-squaring/\n\n        uint result = SafeDecimalMath.unit();\n        while (n > 0) {\n            if (n % 2 != 0) {\n                result = result.multiplyDecimal(x);\n            }\n            x = x.multiplyDecimal(x);\n            n /= 2;\n        }\n        return result;\n    }\n}\n    \n\n/**\n * @title SynthetixState interface contract\n * @notice Abstract contract to hold public getters\n */\ncontract ISynthetixState {\n    // A struct for handing values associated with an individual user's debt position\n    struct IssuanceData {\n        // Percentage of the total debt owned at the time\n        // of issuance. This number is modified by the global debt\n        // delta array. You can figure out a user's exit price and\n        // collateralisation ratio using a combination of their initial\n        // debt and the slice of global debt delta which applies to them.\n        uint initialDebtOwnership;\n        // This lets us know when (in relative terms) the user entered\n        // the debt pool so we can calculate their exit price and\n        // collateralistion ratio\n        uint debtEntryIndex;\n    }\n\n    uint[] public debtLedger;\n    uint public issuanceRatio;\n    mapping(address => IssuanceData) public issuanceData;\n\n    function debtLedgerLength() external view returns (uint);\n    function hasIssued(address account) external view returns (bool);\n    function incrementTotalIssuerCount() external;\n    function decrementTotalIssuerCount() external;\n    function setCurrentIssuanceData(address account, uint initialDebtOwnership) external;\n    function lastDebtLedgerEntry() external view returns (uint);\n    function appendDebtLedgerValue(uint value) external;\n    function clearIssuanceData(address account) external;\n}\n\n\ninterface ISynth {\n    function burn(address account, uint amount) external;\n    function issue(address account, uint amount) external;\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\n\n/**\n * @title SynthetixEscrow interface\n */\ninterface ISynthetixEscrow {\n    function balanceOf(address account) public view returns (uint);\n    function appendVestingEntry(address account, uint quantity) public;\n}\n\n\n/**\n * @title FeePool Interface\n * @notice Abstract contract to hold public getters\n */\ncontract IFeePool {\n    address public FEE_ADDRESS;\n    uint public exchangeFeeRate;\n    function amountReceivedFromExchange(uint value) external view returns (uint);\n    function amountReceivedFromTransfer(uint value) external view returns (uint);\n    function recordFeePaid(uint xdrAmount) external;\n    function appendAccountIssuanceRecord(address account, uint lockedAmount, uint debtEntryIndex) external;\n    function setRewardsToDistribute(uint amount) external;\n}\n\n\n/**\n * @title ExchangeRates interface\n */\ninterface IExchangeRates {\n    function effectiveValue(bytes32 sourceCurrencyKey, uint sourceAmount, bytes32 destinationCurrencyKey) external view returns (uint);\n\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\n    function ratesForCurrencies(bytes32[] currencyKeys) external view returns (uint[] memory);\n\n    function rateIsStale(bytes32 currencyKey) external view returns (bool);\n    function anyRateIsStale(bytes32[] currencyKeys) external view returns (bool);\n}\n\n\n/*\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nSynthetix-backed stablecoin contract.\n\nThis contract issues synths, which are tokens that mirror various\nflavours of fiat currency.\n\nSynths are issuable by Synthetix Network Token (SNX) holders who\nhave to lock up some value of their SNX to issue S * Cmax synths.\nWhere Cmax issome value less than 1.\n\nA configurable fee is charged on synth exchanges and deposited\ninto the fee pool, which Synthetix holders may withdraw from once\nper fee period.\n\n-----------------------------------------------------------------\n*/\n\n\ncontract Synth is ExternStateToken {\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Address of the FeePoolProxy\n    address public feePoolProxy;\n    // Address of the SynthetixProxy\n    address public synthetixProxy;\n\n    // Currency key which identifies this Synth to the Synthetix system\n    bytes32 public currencyKey;\n\n    uint8 constant DECIMALS = 18;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address _proxy, TokenState _tokenState, address _synthetixProxy, address _feePoolProxy,\n        string _tokenName, string _tokenSymbol, address _owner, bytes32 _currencyKey, uint _totalSupply\n    )\n        ExternStateToken(_proxy, _tokenState, _tokenName, _tokenSymbol, _totalSupply, DECIMALS, _owner)\n        public\n    {\n        require(_proxy != address(0), \"_proxy cannot be 0\");\n        require(_synthetixProxy != address(0), \"_synthetixProxy cannot be 0\");\n        require(_feePoolProxy != address(0), \"_feePoolProxy cannot be 0\");\n        require(_owner != 0, \"_owner cannot be 0\");\n        require(ISynthetix(_synthetixProxy).synths(_currencyKey) == Synth(0), \"Currency key is already in use\");\n\n        feePoolProxy = _feePoolProxy;\n        synthetixProxy = _synthetixProxy;\n        currencyKey = _currencyKey;\n    }\n\n    /* ========== SETTERS ========== */\n\n    /**\n     * @notice Set the SynthetixProxy should it ever change.\n     * The Synth requires Synthetix address as it has the authority\n     * to mint and burn synths\n     * */\n    function setSynthetixProxy(ISynthetix _synthetixProxy)\n        external\n        optionalProxy_onlyOwner\n    {\n        synthetixProxy = _synthetixProxy;\n        emitSynthetixUpdated(_synthetixProxy);\n    }\n\n    /**\n     * @notice Set the FeePoolProxy should it ever change.\n     * The Synth requires FeePool address as it has the authority\n     * to mint and burn for FeePool.claimFees()\n     * */\n    function setFeePoolProxy(address _feePoolProxy)\n        external\n        optionalProxy_onlyOwner\n    {\n        feePoolProxy = _feePoolProxy;\n        emitFeePoolUpdated(_feePoolProxy);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice ERC20 transfer function\n     * forward call on to _internalTransfer */\n    function transfer(address to, uint value)\n        public\n        optionalProxy\n        returns (bool)\n    {        \n        return super._internalTransfer(messageSender, to, value);\n    }\n\n    /**\n     * @notice ERC20 transferFrom function\n     */\n    function transferFrom(address from, address to, uint value)\n        public\n        optionalProxy\n        returns (bool)\n    {        \n        // Skip allowance update in case of infinite allowance\n        if (tokenState.allowance(from, messageSender) != uint(-1)) {\n            // Reduce the allowance by the amount we're transferring.\n            // The safeSub call will handle an insufficient allowance.\n            tokenState.setAllowance(from, messageSender, tokenState.allowance(from, messageSender).sub(value));\n        }\n        \n        return super._internalTransfer(from, to, value);\n    }\n\n    // Allow synthetix to issue a certain number of synths from an account.\n    function issue(address account, uint amount)\n        external\n        onlySynthetixOrFeePool\n    {\n        tokenState.setBalanceOf(account, tokenState.balanceOf(account).add(amount));\n        totalSupply = totalSupply.add(amount);\n        emitTransfer(address(0), account, amount);\n        emitIssued(account, amount);\n    }\n\n    // Allow synthetix or another synth contract to burn a certain number of synths from an account.\n    function burn(address account, uint amount)\n        external\n        onlySynthetixOrFeePool\n    {\n        tokenState.setBalanceOf(account, tokenState.balanceOf(account).sub(amount));\n        totalSupply = totalSupply.sub(amount);\n        emitTransfer(account, address(0), amount);\n        emitBurned(account, amount);\n    }\n\n    // Allow owner to set the total supply on import.\n    function setTotalSupply(uint amount)\n        external\n        optionalProxy_onlyOwner\n    {\n        totalSupply = amount;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlySynthetixOrFeePool() {\n        bool isSynthetix = msg.sender == address(Proxy(synthetixProxy).target());\n        bool isFeePool = msg.sender == address(Proxy(feePoolProxy).target());\n\n        require(isSynthetix || isFeePool, \"Only Synthetix, FeePool allowed\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event SynthetixUpdated(address newSynthetix);\n    bytes32 constant SYNTHETIXUPDATED_SIG = keccak256(\"SynthetixUpdated(address)\");\n    function emitSynthetixUpdated(address newSynthetix) internal {\n        proxy._emit(abi.encode(newSynthetix), 1, SYNTHETIXUPDATED_SIG, 0, 0, 0);\n    }\n\n    event FeePoolUpdated(address newFeePool);\n    bytes32 constant FEEPOOLUPDATED_SIG = keccak256(\"FeePoolUpdated(address)\");\n    function emitFeePoolUpdated(address newFeePool) internal {\n        proxy._emit(abi.encode(newFeePool), 1, FEEPOOLUPDATED_SIG, 0, 0, 0);\n    }\n\n    event Issued(address indexed account, uint value);\n    bytes32 constant ISSUED_SIG = keccak256(\"Issued(address,uint256)\");\n    function emitIssued(address account, uint value) internal {\n        proxy._emit(abi.encode(value), 2, ISSUED_SIG, bytes32(account), 0, 0);\n    }\n\n    event Burned(address indexed account, uint value);\n    bytes32 constant BURNED_SIG = keccak256(\"Burned(address,uint256)\");\n    function emitBurned(address account, uint value) internal {\n        proxy._emit(abi.encode(value), 2, BURNED_SIG, bytes32(account), 0, 0);\n    }\n}\n\n\n/**\n * @title Synthetix interface contract\n * @notice Abstract contract to hold public getters\n * @dev pseudo interface, actually declared as contract to hold the public getters \n */\n\n\ncontract ISynthetix {\n\n    // ========== PUBLIC STATE VARIABLES ==========\n\n    IFeePool public feePool;\n    ISynthetixEscrow public escrow;\n    ISynthetixEscrow public rewardEscrow;\n    ISynthetixState public synthetixState;\n    IExchangeRates public exchangeRates;\n\n    uint public totalSupply;\n        \n    mapping(bytes32 => Synth) public synths;\n\n    // ========== PUBLIC FUNCTIONS ==========\n\n    function balanceOf(address account) public view returns (uint);\n    function transfer(address to, uint value) public returns (bool);\n    function effectiveValue(bytes32 sourceCurrencyKey, uint sourceAmount, bytes32 destinationCurrencyKey) public view returns (uint);\n\n    function synthInitiatedExchange(\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress) external returns (bool);\n    function exchange(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey) external returns (bool);\n    function collateralisationRatio(address issuer) public view returns (uint);\n    function totalIssuedSynths(bytes32 currencyKey)\n        public\n        view\n        returns (uint);\n    function getSynth(bytes32 currencyKey) public view returns (ISynth);\n    function debtBalanceOf(address issuer, bytes32 currencyKey) public view returns (uint);\n}\n\n\n/*\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nThe SNX supply schedule contract determines the amount of SNX tokens\nmintable over the course of 195 weeks.\n\nExponential Decay Inflation Schedule\n\nSynthetix.mint() function is used to mint the inflationary supply.\n\nThe mechanics for Inflation Smoothing and Terminal Inflation \nhave been defined in these sips\nhttps://sips.synthetix.io/sips/sip-23\nhttps://sips.synthetix.io/sips/sip-24\n\nThe previous SNX Inflation Supply Schedule is at \nhttps://etherscan.io/address/0xA3de830b5208851539De8e4FF158D635E8f36FCb#code\n\n-----------------------------------------------------------------\n*/\n\n\n/**\n * @title SupplySchedule contract\n */\ncontract SupplySchedule is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n    using Math for uint;\n\n    // Time of the last inflation supply mint event\n    uint public lastMintEvent;\n\n    // Counter for number of weeks since the start of supply inflation\n    uint public weekCounter;\n\n    // The number of SNX rewarded to the caller of Synthetix.mint()\n    uint public minterReward = 200 * SafeDecimalMath.unit();\n\n    // The initial weekly inflationary supply is 75m / 52 until the start of the decay rate. \n    // 75e6 * SafeDecimalMath.unit() / 52\n    uint public constant INITIAL_WEEKLY_SUPPLY = 1442307692307692307692307;    \n\n    // Address of the SynthetixProxy for the onlySynthetix modifier\n    address public synthetixProxy;\n\n    // Max SNX rewards for minter\n    uint public constant MAX_MINTER_REWARD = 200 * SafeDecimalMath.unit();\n\n    // How long each inflation period is before mint can be called\n    uint public constant MINT_PERIOD_DURATION = 1 weeks;\n\n    uint public constant INFLATION_START_DATE = 1551830400; // 2019-03-06T00:00:00+00:00\n    uint public constant MINT_BUFFER = 1 days;\n    uint8 public constant SUPPLY_DECAY_START = 40; // Week 40\n    uint8 public constant SUPPLY_DECAY_END = 234; //  Supply Decay ends on Week 234 (inclusive of Week 234 for a total of 195 weeks of inflation decay)\n    \n    // Weekly percentage decay of inflationary supply from the first 40 weeks of the 75% inflation rate\n    uint public constant DECAY_RATE = 12500000000000000; // 1.25% weekly\n\n    // Percentage growth of terminal supply per annum\n    uint public constant TERMINAL_SUPPLY_RATE_ANNUAL = 25000000000000000; // 2.5% pa\n    \n    constructor(\n        address _owner,\n        uint _lastMintEvent,\n        uint _currentWeek)\n        Owned(_owner)\n        public\n    {\n        lastMintEvent = _lastMintEvent;\n        weekCounter = _currentWeek;\n    }\n\n    // ========== VIEWS ==========     \n    \n    /**    \n    * @return The amount of SNX mintable for the inflationary supply\n    */\n    function mintableSupply()\n        external\n        view\n        returns (uint)\n    {\n        uint totalAmount;\n\n        if (!isMintable()) {\n            return totalAmount;\n        }\n        \n        uint remainingWeeksToMint = weeksSinceLastIssuance();\n          \n        uint currentWeek = weekCounter;\n        \n        // Calculate total mintable supply from exponential decay function\n        // The decay function stops after week 234\n        while (remainingWeeksToMint > 0) {\n            currentWeek++;            \n            \n            // If current week is before supply decay we add initial supply to mintableSupply\n            if (currentWeek < SUPPLY_DECAY_START) {\n                totalAmount = totalAmount.add(INITIAL_WEEKLY_SUPPLY);\n                remainingWeeksToMint--;\n            }\n            // if current week before supply decay ends we add the new supply for the week \n            else if (currentWeek <= SUPPLY_DECAY_END) {\n                \n                // diff between current week and (supply decay start week - 1)  \n                uint decayCount = currentWeek.sub(SUPPLY_DECAY_START -1);\n                \n                totalAmount = totalAmount.add(tokenDecaySupplyForWeek(decayCount));\n                remainingWeeksToMint--;\n            } \n            // Terminal supply is calculated on the total supply of Synthetix including any new supply\n            // We can compound the remaining week's supply at the fixed terminal rate  \n            else {\n                uint totalSupply = ISynthetix(synthetixProxy).totalSupply();\n                uint currentTotalSupply = totalSupply.add(totalAmount);\n\n                totalAmount = totalAmount.add(terminalInflationSupply(currentTotalSupply, remainingWeeksToMint));\n                remainingWeeksToMint = 0;\n            }\n        }\n        \n        return totalAmount;\n    }\n\n    /**\n    * @return A unit amount of decaying inflationary supply from the INITIAL_WEEKLY_SUPPLY\n    * @dev New token supply reduces by the decay rate each week calculated as supply = INITIAL_WEEKLY_SUPPLY * () \n    */\n    function tokenDecaySupplyForWeek(uint counter)\n        public \n        pure\n        returns (uint)\n    {   \n        // Apply exponential decay function to number of weeks since\n        // start of inflation smoothing to calculate diminishing supply for the week.\n        uint effectiveDecay = (SafeDecimalMath.unit().sub(DECAY_RATE)).powDecimal(counter);\n        uint supplyForWeek = INITIAL_WEEKLY_SUPPLY.multiplyDecimal(effectiveDecay);\n\n        return supplyForWeek;\n    }    \n    \n    /**\n    * @return A unit amount of terminal inflation supply\n    * @dev Weekly compound rate based on number of weeks     \n    */\n    function terminalInflationSupply(uint totalSupply, uint numOfWeeks)\n        public\n        pure\n        returns (uint)\n    {   \n        // rate = (1 + weekly rate) ^ num of weeks\n        uint effectiveCompoundRate = SafeDecimalMath.unit().add(TERMINAL_SUPPLY_RATE_ANNUAL.div(52)).powDecimal(numOfWeeks);\n\n        // return Supply * (effectiveRate - 1) for extra supply to issue based on number of weeks\n        return totalSupply.multiplyDecimal(effectiveCompoundRate.sub(SafeDecimalMath.unit()));\n    }\n\n    /**    \n    * @dev Take timeDiff in seconds (Dividend) and MINT_PERIOD_DURATION as (Divisor)\n    * @return Calculate the numberOfWeeks since last mint rounded down to 1 week\n    */\n    function weeksSinceLastIssuance()\n        public\n        view\n        returns (uint)\n    {\n        // Get weeks since lastMintEvent\n        // If lastMintEvent not set or 0, then start from inflation start date.\n        uint timeDiff = lastMintEvent > 0 ? now.sub(lastMintEvent) : now.sub(INFLATION_START_DATE);\n        return timeDiff.div(MINT_PERIOD_DURATION);\n    }\n\n    /**\n     * @return boolean whether the MINT_PERIOD_DURATION (7 days)\n     * has passed since the lastMintEvent.\n     * */\n    function isMintable()\n        public\n        view\n        returns (bool)\n    {\n        if (now - lastMintEvent > MINT_PERIOD_DURATION)\n        {\n            return true;\n        }\n        return false;\n    }\n\n    // ========== MUTATIVE FUNCTIONS ==========\n\n    /**\n     * @notice Record the mint event from Synthetix by incrementing the inflation \n     * week counter for the number of weeks minted (probabaly always 1)\n     * and store the time of the event.\n     * @param supplyMinted the amount of SNX the total supply was inflated by.\n     * */\n    function recordMintEvent(uint supplyMinted)\n        external\n        onlySynthetix\n        returns (bool)\n    {\n        uint numberOfWeeksIssued = weeksSinceLastIssuance();\n\n        // add number of weeks minted to weekCounter\n        weekCounter = weekCounter.add(numberOfWeeksIssued);\n\n        // Update mint event to latest week issued (start date + number of weeks issued * seconds in week)\n        // 1 day time buffer is added so inflation is minted after feePeriod closes \n        lastMintEvent = INFLATION_START_DATE.add(weekCounter.mul(MINT_PERIOD_DURATION)).add(MINT_BUFFER);\n\n        emit SupplyMinted(supplyMinted, numberOfWeeksIssued, lastMintEvent, now);\n        return true;\n    }\n\n    /**\n     * @notice Sets the reward amount of SNX for the caller of the public \n     * function Synthetix.mint(). \n     * This incentivises anyone to mint the inflationary supply and the mintr \n     * Reward will be deducted from the inflationary supply and sent to the caller.\n     * @param amount the amount of SNX to reward the minter.\n     * */\n    function setMinterReward(uint amount)\n        external\n        onlyOwner\n    {\n        require(amount <= MAX_MINTER_REWARD, \"Reward cannot exceed max minter reward\");\n        minterReward = amount;\n        emit MinterRewardUpdated(minterReward);\n    }\n\n    // ========== SETTERS ========== */\n\n    /**\n     * @notice Set the SynthetixProxy should it ever change.\n     * SupplySchedule requires Synthetix address as it has the authority\n     * to record mint event.\n     * */\n    function setSynthetixProxy(ISynthetix _synthetixProxy)\n        external\n        onlyOwner\n    {\n        require(_synthetixProxy != address(0), \"Address cannot be 0\");\n        synthetixProxy = _synthetixProxy;\n        emit SynthetixProxyUpdated(synthetixProxy);\n    }\n\n    // ========== MODIFIERS ==========\n\n    /**\n     * @notice Only the Synthetix contract is authorised to call this function\n     * */\n    modifier onlySynthetix() {\n        require(msg.sender == address(Proxy(synthetixProxy).target()), \"Only the synthetix contract can perform this action\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n    /**\n     * @notice Emitted when the inflationary supply is minted\n     * */\n    event SupplyMinted(uint supplyMinted, uint numberOfWeeksIssued, uint lastMintEvent, uint timestamp);\n\n    /**\n     * @notice Emitted when the SNX minter reward amount is updated\n     * */\n    event MinterRewardUpdated(uint newRewardAmount);\n\n    /**\n     * @notice Emitted when setSynthetixProxy is called changing the Synthetix Proxy address\n     * */\n    event SynthetixProxyUpdated(address newAddress);\n}\n\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n  function latestTimestamp() external view returns (uint256);\n  function latestRound() external view returns (uint256);\n  function getAnswer(uint256 roundId) external view returns (int256);\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n  event NewRound(uint256 indexed roundId, address indexed startedBy);\n}\n\n\n// AggregatorInterface from Chainlink represents a decentralized pricing network for a single currency keys\n\n\n/**\n * @title The repository for exchange rates\n */\n\ncontract ExchangeRates is SelfDestructible {\n\n\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    struct RateAndUpdatedTime {\n        uint216 rate;\n        uint40 time;\n    }\n\n    // Exchange rates and update times stored by currency code, e.g. 'SNX', or 'sUSD'\n    mapping(bytes32 => RateAndUpdatedTime) private _rates;\n\n    // The address of the oracle which pushes rate updates to this contract\n    address public oracle;\n\n    // Decentralized oracle networks that feed into pricing aggregators\n    mapping(bytes32 => AggregatorInterface) public aggregators;\n\n    // List of configure aggregator keys for convenient iteration\n    bytes32[] public aggregatorKeys;\n\n    // Do not allow the oracle to submit times any further forward into the future than this constant.\n    uint constant ORACLE_FUTURE_LIMIT = 10 minutes;\n\n    // How long will the contract assume the rate of any asset is correct\n    uint public rateStalePeriod = 3 hours;\n\n\n    // Each participating currency in the XDR basket is represented as a currency key with\n    // equal weighting.\n    // There are 5 participating currencies, so we'll declare that clearly.\n    bytes32[5] public xdrParticipants;\n\n    // A conveience mapping for checking if a rate is a XDR participant\n    mapping(bytes32 => bool) public isXDRParticipant;\n\n    // For inverted prices, keep a mapping of their entry, limits and frozen status\n    struct InversePricing {\n        uint entryPoint;\n        uint upperLimit;\n        uint lowerLimit;\n        bool frozen;\n    }\n    mapping(bytes32 => InversePricing) public inversePricing;\n    bytes32[] public invertedKeys;\n\n    //\n    // ========== CONSTRUCTOR ==========\n\n    /**\n     * @dev Constructor\n     * @param _owner The owner of this contract.\n     * @param _oracle The address which is able to update rate information.\n     * @param _currencyKeys The initial currency keys to store (in order).\n     * @param _newRates The initial currency amounts for each currency (in order).\n     */\n    constructor(\n        // SelfDestructible (Ownable)\n        address _owner,\n\n        // Oracle values - Allows for rate updates\n        address _oracle,\n        bytes32[] _currencyKeys,\n        uint[] _newRates\n    )\n        /* Owned is initialised in SelfDestructible */\n        SelfDestructible(_owner)\n        public\n    {\n        require(_currencyKeys.length == _newRates.length, \"Currency key length and rate length must match.\");\n\n        oracle = _oracle;\n\n        // The sUSD rate is always 1 and is never stale.\n        _setRate(\"sUSD\", SafeDecimalMath.unit(), now);\n\n        // These are the currencies that make up the XDR basket.\n        // These are hard coded because:\n        //  - This way users can depend on the calculation and know it won't change for this deployment of the contract.\n        //  - Adding new currencies would likely introduce some kind of weighting factor, which\n        //    isn't worth preemptively adding when all of the currencies in the current basket are weighted at 1.\n        //  - The expectation is if this logic needs to be updated, we'll simply deploy a new version of this contract\n        //    then point the system at the new version.\n        xdrParticipants = [\n            bytes32(\"sUSD\"),\n            bytes32(\"sAUD\"),\n            bytes32(\"sCHF\"),\n            bytes32(\"sEUR\"),\n            bytes32(\"sGBP\")\n        ];\n\n        // Mapping the XDR participants is cheaper than looping the xdrParticipants array to check if they exist\n        isXDRParticipant[bytes32(\"sUSD\")] = true;\n        isXDRParticipant[bytes32(\"sAUD\")] = true;\n        isXDRParticipant[bytes32(\"sCHF\")] = true;\n        isXDRParticipant[bytes32(\"sEUR\")] = true;\n        isXDRParticipant[bytes32(\"sGBP\")] = true;\n\n        internalUpdateRates(_currencyKeys, _newRates, now);\n    }\n\n    function getRateAndUpdatedTime(bytes32 code) internal view returns (RateAndUpdatedTime) {\n        if (code == \"XDR\") {\n            // The XDR rate is the sum of the underlying XDR participant rates, and the latest\n            // timestamp from those rates\n            uint total = 0;\n            uint lastUpdated = 0;\n            for (uint i = 0; i < xdrParticipants.length; i++) {\n                RateAndUpdatedTime memory xdrEntry = getRateAndUpdatedTime(xdrParticipants[i]);\n                total = total.add(xdrEntry.rate);\n                if (xdrEntry.time > lastUpdated) {\n                    lastUpdated = xdrEntry.time;\n                }\n            }\n            return RateAndUpdatedTime({\n                rate: uint216(total),\n                time: uint40(lastUpdated)\n            });\n        } else if (aggregators[code] != address(0)) {\n            return RateAndUpdatedTime({\n                rate: uint216(aggregators[code].latestAnswer() * 1e10),\n                time: uint40(aggregators[code].latestTimestamp())\n            });\n        } else {\n            return _rates[code];\n        }\n    }\n    /**\n     * @notice Retrieves the exchange rate (sUSD per unit) for a given currency key\n     */\n    function rates(bytes32 code) public view returns(uint256) {\n        return getRateAndUpdatedTime(code).rate;\n    }\n\n    /**\n     * @notice Retrieves the timestamp the given rate was last updated.\n     */\n    function lastRateUpdateTimes(bytes32 code) public view returns(uint256) {\n        return getRateAndUpdatedTime(code).time;\n    }\n\n    /**\n     * @notice Retrieve the last update time for a list of currencies\n     */\n    function lastRateUpdateTimesForCurrencies(bytes32[] currencyKeys)\n        public\n        view\n        returns (uint[])\n    {\n        uint[] memory lastUpdateTimes = new uint[](currencyKeys.length);\n\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            lastUpdateTimes[i] = lastRateUpdateTimes(currencyKeys[i]);\n        }\n\n        return lastUpdateTimes;\n    }\n\n    function _setRate(bytes32 code, uint256 rate, uint256 time) internal {\n        _rates[code] = RateAndUpdatedTime({\n            rate: uint216(rate),\n            time: uint40(time)\n        });\n    }\n\n    /* ========== SETTERS ========== */\n\n    /**\n     * @notice Set the rates stored in this contract\n     * @param currencyKeys The currency keys you wish to update the rates for (in order)\n     * @param newRates The rates for each currency (in order)\n     * @param timeSent The timestamp of when the update was sent, specified in seconds since epoch (e.g. the same as the now keyword in solidity).contract\n     *                 This is useful because transactions can take a while to confirm, so this way we know how old the oracle's datapoint was exactly even\n     *                 if it takes a long time for the transaction to confirm.\n     */\n    function updateRates(bytes32[] currencyKeys, uint[] newRates, uint timeSent)\n        external\n        onlyOracle\n        returns(bool)\n    {\n        return internalUpdateRates(currencyKeys, newRates, timeSent);\n    }\n\n    /**\n     * @notice Internal function which sets the rates stored in this contract\n     * @param currencyKeys The currency keys you wish to update the rates for (in order)\n     * @param newRates The rates for each currency (in order)\n     * @param timeSent The timestamp of when the update was sent, specified in seconds since epoch (e.g. the same as the now keyword in solidity).contract\n     *                 This is useful because transactions can take a while to confirm, so this way we know how old the oracle's datapoint was exactly even\n     *                 if it takes a long time for the transaction to confirm.\n     */\n    function internalUpdateRates(bytes32[] currencyKeys, uint[] newRates, uint timeSent)\n        internal\n        returns(bool)\n    {\n        require(currencyKeys.length == newRates.length, \"Currency key array length must match rates array length.\");\n        require(timeSent < (now + ORACLE_FUTURE_LIMIT), \"Time is too far into the future\");\n\n        // Loop through each key and perform update.\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            bytes32 currencyKey = currencyKeys[i];\n\n            // Should not set any rate to zero ever, as no asset will ever be\n            // truely worthless and still valid. In this scenario, we should\n            // delete the rate and remove it from the system.\n            require(newRates[i] != 0, \"Zero is not a valid rate, please call deleteRate instead.\");\n            require(currencyKey != \"sUSD\", \"Rate of sUSD cannot be updated, it's always UNIT.\");\n\n            // We should only update the rate if it's at least the same age as the last rate we've got.\n            if (timeSent < lastRateUpdateTimes(currencyKey)) {\n                continue;\n            }\n\n            newRates[i] = rateOrInverted(currencyKey, newRates[i]);\n\n            // Ok, go ahead with the update.\n            _setRate(currencyKey, newRates[i], timeSent);\n        }\n\n        emit RatesUpdated(currencyKeys, newRates);\n\n        return true;\n    }\n\n    /**\n     * @notice Internal function to get the inverted rate, if any, and mark an inverted\n     *  key as frozen if either limits are reached.\n     *\n     * Inverted rates are ones that take a regular rate, perform a simple calculation (double entryPrice and\n     * subtract the rate) on them and if the result of the calculation is over or under predefined limits, it freezes the\n     * rate at that limit, preventing any future rate updates.\n     *\n     * For example, if we have an inverted rate iBTC with the following parameters set:\n     * - entryPrice of 200\n     * - upperLimit of 300\n     * - lower of 100\n     *\n     * if this function is invoked with params iETH and 184 (or rather 184e18),\n     * then the rate would be: 200 * 2 - 184 = 216. 100 < 216 < 200, so the rate would be 216,\n     * and remain unfrozen.\n     *\n     * If this function is then invoked with params iETH and 301 (or rather 301e18),\n     * then the rate would be: 200 * 2 - 301 = 99. 99 < 100, so the rate would be 100 and the\n     * rate would become frozen, no longer accepting future price updates until the synth is unfrozen\n     * by the owner function: setInversePricing().\n     *\n     * @param currencyKey The price key to lookup\n     * @param rate The rate for the given price key\n     */\n    function rateOrInverted(bytes32 currencyKey, uint rate) internal returns (uint) {\n        // if an inverse mapping exists, adjust the price accordingly\n        InversePricing storage inverse = inversePricing[currencyKey];\n        if (inverse.entryPoint <= 0) {\n            return rate;\n        }\n\n        // set the rate to the current rate initially (if it's frozen, this is what will be returned)\n        uint newInverseRate = rates(currencyKey);\n\n        // get the new inverted rate if not frozen\n        if (!inverse.frozen) {\n            uint doubleEntryPoint = inverse.entryPoint.mul(2);\n            if (doubleEntryPoint <= rate) {\n                // avoid negative numbers for unsigned ints, so set this to 0\n                // which by the requirement that lowerLimit be > 0 will\n                // cause this to freeze the price to the lowerLimit\n                newInverseRate = 0;\n            } else {\n                newInverseRate = doubleEntryPoint.sub(rate);\n            }\n\n            // now if new rate hits our limits, set it to the limit and freeze\n            if (newInverseRate >= inverse.upperLimit) {\n                newInverseRate = inverse.upperLimit;\n            } else if (newInverseRate <= inverse.lowerLimit) {\n                newInverseRate = inverse.lowerLimit;\n            }\n\n            if (newInverseRate == inverse.upperLimit || newInverseRate == inverse.lowerLimit) {\n                inverse.frozen = true;\n                emit InversePriceFrozen(currencyKey);\n            }\n        }\n\n        return newInverseRate;\n    }\n\n    /**\n     * @notice Delete a rate stored in the contract\n     * @param currencyKey The currency key you wish to delete the rate for\n     */\n    function deleteRate(bytes32 currencyKey)\n        external\n        onlyOracle\n    {\n        require(rates(currencyKey) > 0, \"Rate is zero\");\n\n        delete _rates[currencyKey];\n\n        emit RateDeleted(currencyKey);\n    }\n\n    /**\n     * @notice Set the Oracle that pushes the rate information to this contract\n     * @param _oracle The new oracle address\n     */\n    function setOracle(address _oracle)\n        external\n        onlyOwner\n    {\n        oracle = _oracle;\n        emit OracleUpdated(oracle);\n    }\n\n    /**\n     * @notice Set the stale period on the updated rate variables\n     * @param _time The new rateStalePeriod\n     */\n    function setRateStalePeriod(uint _time)\n        external\n        onlyOwner\n    {\n        rateStalePeriod = _time;\n        emit RateStalePeriodUpdated(rateStalePeriod);\n    }\n\n    /**\n     * @notice Set an inverse price up for the currency key.\n     *\n     * An inverse price is one which has an entryPoint, an uppper and a lower limit. Each update, the\n     * rate is calculated as double the entryPrice minus the current rate. If this calculation is\n     * above or below the upper or lower limits respectively, then the rate is frozen, and no more\n     * rate updates will be accepted.\n     *\n     * @param currencyKey The currency to update\n     * @param entryPoint The entry price point of the inverted price\n     * @param upperLimit The upper limit, at or above which the price will be frozen\n     * @param lowerLimit The lower limit, at or below which the price will be frozen\n     * @param freeze Whether or not to freeze this rate immediately. Note: no frozen event will be configured\n     * @param freezeAtUpperLimit When the freeze flag is true, this flag indicates whether the rate\n     * to freeze at is the upperLimit or lowerLimit..\n     */\n    function setInversePricing(bytes32 currencyKey, uint entryPoint, uint upperLimit, uint lowerLimit, bool freeze, bool freezeAtUpperLimit)\n        external onlyOwner\n    {\n        require(entryPoint > 0, \"entryPoint must be above 0\");\n        require(lowerLimit > 0, \"lowerLimit must be above 0\");\n        require(upperLimit > entryPoint, \"upperLimit must be above the entryPoint\");\n        require(upperLimit < entryPoint.mul(2), \"upperLimit must be less than double entryPoint\");\n        require(lowerLimit < entryPoint, \"lowerLimit must be below the entryPoint\");\n\n        if (inversePricing[currencyKey].entryPoint <= 0) {\n            // then we are adding a new inverse pricing, so add this\n            invertedKeys.push(currencyKey);\n        }\n        inversePricing[currencyKey].entryPoint = entryPoint;\n        inversePricing[currencyKey].upperLimit = upperLimit;\n        inversePricing[currencyKey].lowerLimit = lowerLimit;\n        inversePricing[currencyKey].frozen = freeze;\n\n        emit InversePriceConfigured(currencyKey, entryPoint, upperLimit, lowerLimit);\n\n        // When indicating to freeze, we need to know the rate to freeze it at - either upper or lower\n        // this is useful in situations where ExchangeRates is updated and there are existing inverted\n        // rates already frozen in the current contract that need persisting across the upgrade\n        if (freeze) {\n            emit InversePriceFrozen(currencyKey);\n\n            _setRate(currencyKey, freezeAtUpperLimit ? upperLimit : lowerLimit, now);\n        }\n    }\n\n    /**\n     * @notice Remove an inverse price for the currency key\n     * @param currencyKey The currency to remove inverse pricing for\n     */\n    function removeInversePricing(bytes32 currencyKey) external onlyOwner\n    {\n        require(inversePricing[currencyKey].entryPoint > 0, \"No inverted price exists\");\n\n        inversePricing[currencyKey].entryPoint = 0;\n        inversePricing[currencyKey].upperLimit = 0;\n        inversePricing[currencyKey].lowerLimit = 0;\n        inversePricing[currencyKey].frozen = false;\n\n        // now remove inverted key from array\n        bool wasRemoved = removeFromArray(currencyKey, invertedKeys);\n\n        if (wasRemoved) {\n            emit InversePriceConfigured(currencyKey, 0, 0, 0);\n        }\n    }\n\n    /**\n     * @notice Add a pricing aggregator for the given key. Note: existing aggregators may be overridden.\n     * @param currencyKey The currency key to add an aggregator for\n     */\n    function addAggregator(bytes32 currencyKey, address aggregatorAddress) external onlyOwner {\n        AggregatorInterface aggregator = AggregatorInterface(aggregatorAddress);\n        require(aggregator.latestTimestamp() >= 0, \"Given Aggregator is invalid\");\n        if (aggregators[currencyKey] == address(0)) {\n            aggregatorKeys.push(currencyKey);\n        }\n        aggregators[currencyKey] = aggregator;\n        emit AggregatorAdded(currencyKey, aggregator);\n    }\n\n    /**\n     * @notice Remove a single value from an array by iterating through until it is found.\n     * @param entry The entry to find\n     * @param array The array to mutate\n     * @return bool Whether or not the entry was found and removed\n     */\n    function removeFromArray(bytes32 entry, bytes32[] storage array) internal returns (bool) {\n        for (uint i = 0; i < array.length; i++) {\n            if (array[i] == entry) {\n                delete array[i];\n\n                // Copy the last key into the place of the one we just deleted\n                // If there's only one key, this is array[0] = array[0].\n                // If we're deleting the last one, it's also a NOOP in the same way.\n                array[i] = array[array.length - 1];\n\n                // Decrease the size of the array by one.\n                array.length--;\n\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * @notice Remove a pricing aggregator for the given key\n     * @param currencyKey THe currency key to remove an aggregator for\n     */\n    function removeAggregator(bytes32 currencyKey) external onlyOwner {\n        address aggregator = aggregators[currencyKey];\n        require(aggregator != address(0), \"No aggregator exists for key\");\n        delete aggregators[currencyKey];\n\n        bool wasRemoved = removeFromArray(currencyKey, aggregatorKeys);\n\n        if (wasRemoved) {\n            emit AggregatorRemoved(currencyKey, aggregator);\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice A function that lets you easily convert an amount in a source currency to an amount in the destination currency\n     * @param sourceCurrencyKey The currency the amount is specified in\n     * @param sourceAmount The source amount, specified in UNIT base\n     * @param destinationCurrencyKey The destination currency\n     */\n    function effectiveValue(bytes32 sourceCurrencyKey, uint sourceAmount, bytes32 destinationCurrencyKey)\n        public\n        view\n        rateNotStale(sourceCurrencyKey)\n        rateNotStale(destinationCurrencyKey)\n        returns (uint)\n    {\n        // If there's no change in the currency, then just return the amount they gave us\n        if (sourceCurrencyKey == destinationCurrencyKey) return sourceAmount;\n\n        // Calculate the effective value by going from source -> USD -> destination\n        return sourceAmount.multiplyDecimalRound(rateForCurrency(sourceCurrencyKey))\n            .divideDecimalRound(rateForCurrency(destinationCurrencyKey));\n    }\n\n    /**\n     * @notice Retrieve the rate for a specific currency\n     */\n    function rateForCurrency(bytes32 currencyKey)\n        public\n        view\n        returns (uint)\n    {\n        return rates(currencyKey);\n    }\n\n    /**\n     * @notice Retrieve the rates for a list of currencies\n     */\n    function ratesForCurrencies(bytes32[] currencyKeys)\n        public\n        view\n        returns (uint[])\n    {\n        uint[] memory _localRates = new uint[](currencyKeys.length);\n\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            _localRates[i] = rates(currencyKeys[i]);\n        }\n\n        return _localRates;\n    }\n\n    /**\n     * @notice Retrieve the rates and isAnyStale for a list of currencies\n     */\n    function ratesAndStaleForCurrencies(bytes32[] currencyKeys)\n        public\n        view\n        returns (uint[], bool)\n    {\n        uint[] memory _localRates = new uint[](currencyKeys.length);\n\n        bool anyRateStale = false;\n        uint period = rateStalePeriod;\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            RateAndUpdatedTime memory rateAndUpdateTime = getRateAndUpdatedTime(currencyKeys[i]);\n            _localRates[i] = uint256(rateAndUpdateTime.rate);\n            if (!anyRateStale) {\n                anyRateStale = (currencyKeys[i] != \"sUSD\" && uint256(rateAndUpdateTime.time).add(period) < now);\n            }\n        }\n\n        return (_localRates, anyRateStale);\n    }\n\n    /**\n     * @notice Check if a specific currency's rate hasn't been updated for longer than the stale period.\n     */\n    function rateIsStale(bytes32 currencyKey)\n        public\n        view\n        returns (bool)\n    {\n        // sUSD is a special case and is never stale.\n        if (currencyKey == \"sUSD\") return false;\n\n        return lastRateUpdateTimes(currencyKey).add(rateStalePeriod) < now;\n    }\n\n    /**\n     * @notice Check if any rate is frozen (cannot be exchanged into)\n     */\n    function rateIsFrozen(bytes32 currencyKey)\n        external\n        view\n        returns (bool)\n    {\n        return inversePricing[currencyKey].frozen;\n    }\n\n\n    /**\n     * @notice Check if any of the currency rates passed in haven't been updated for longer than the stale period.\n     */\n    function anyRateIsStale(bytes32[] currencyKeys)\n        external\n        view\n        returns (bool)\n    {\n        // Loop through each key and check whether the data point is stale.\n        uint256 i = 0;\n\n        while (i < currencyKeys.length) {\n            // sUSD is a special case and is never false\n            if (currencyKeys[i] != \"sUSD\" && lastRateUpdateTimes(currencyKeys[i]).add(rateStalePeriod) < now) {\n                return true;\n            }\n            i += 1;\n        }\n\n        return false;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier rateNotStale(bytes32 currencyKey) {\n        require(!rateIsStale(currencyKey), \"Rate stale or nonexistant currency\");\n        _;\n    }\n\n    modifier onlyOracle\n    {\n        require(msg.sender == oracle, \"Only the oracle can perform this action\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event OracleUpdated(address newOracle);\n    event RateStalePeriodUpdated(uint rateStalePeriod);\n    event RatesUpdated(bytes32[] currencyKeys, uint[] newRates);\n    event RateDeleted(bytes32 currencyKey);\n    event InversePriceConfigured(bytes32 currencyKey, uint entryPoint, uint upperLimit, uint lowerLimit);\n    event InversePriceFrozen(bytes32 currencyKey);\n    event AggregatorAdded(bytes32 currencyKey, address aggregator);\n    event AggregatorRemoved(bytes32 currencyKey, address aggregator);\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       LimitedSetup.sol\nversion:    1.1\nauthor:     Anton Jurisevic\n\ndate:       2018-05-15\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nA contract with a limited setup period. Any function modified\nwith the setup modifier will cease to work after the\nconclusion of the configurable-length post-construction setup period.\n\n-----------------------------------------------------------------\n*/\n\n\n/**\n * @title Any function decorated with the modifier this contract provides\n * deactivates after a specified setup period.\n */\ncontract LimitedSetup {\n\n    uint setupExpiryTime;\n\n    /**\n     * @dev LimitedSetup Constructor.\n     * @param setupDuration The time the setup period will last for.\n     */\n    constructor(uint setupDuration)\n        public\n    {\n        setupExpiryTime = now + setupDuration;\n    }\n\n    modifier onlyDuringSetup\n    {\n        require(now < setupExpiryTime, \"Can only perform this action during setup\");\n        _;\n    }\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       SynthetixState.sol\nversion:    1.0\nauthor:     Kevin Brown\ndate:       2018-10-19\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nA contract that holds issuance state and preferred currency of\nusers in the Synthetix system.\n\nThis contract is used side by side with the Synthetix contract\nto make it easier to upgrade the contract logic while maintaining\nissuance state.\n\nThe Synthetix contract is also quite large and on the edge of\nbeing beyond the contract size limit without moving this information\nout to another contract.\n\nThe first deployed contract would create this state contract,\nusing it as its store of issuance data.\n\nWhen a new contract is deployed, it links to the existing\nstate contract, whose owner would then change its associated\ncontract to the new one.\n\n-----------------------------------------------------------------\n*/\n\n\n/**\n * @title Synthetix State\n * @notice Stores issuance information and preferred currency information of the Synthetix contract.\n */\ncontract SynthetixState is State, LimitedSetup {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    // A struct for handing values associated with an individual user's debt position\n    struct IssuanceData {\n        // Percentage of the total debt owned at the time\n        // of issuance. This number is modified by the global debt\n        // delta array. You can figure out a user's exit price and\n        // collateralisation ratio using a combination of their initial\n        // debt and the slice of global debt delta which applies to them.\n        uint initialDebtOwnership;\n        // This lets us know when (in relative terms) the user entered\n        // the debt pool so we can calculate their exit price and\n        // collateralistion ratio\n        uint debtEntryIndex;\n    }\n\n    // Issued synth balances for individual fee entitlements and exit price calculations\n    mapping(address => IssuanceData) public issuanceData;\n\n    // The total count of people that have outstanding issued synths in any flavour\n    uint public totalIssuerCount;\n\n    // Global debt pool tracking\n    uint[] public debtLedger;\n\n    // Import state\n    uint public importedXDRAmount;\n\n    // A quantity of synths greater than this ratio\n    // may not be issued against a given value of SNX.\n    uint public issuanceRatio = SafeDecimalMath.unit() / 5;\n    // No more synths may be issued than the value of SNX backing them.\n    uint constant MAX_ISSUANCE_RATIO = SafeDecimalMath.unit();\n\n    // Users can specify their preferred currency, in which case all synths they receive\n    // will automatically exchange to that preferred currency upon receipt in their wallet\n    mapping(address => bytes4) public preferredCurrency;\n\n    /**\n     * @dev Constructor\n     * @param _owner The address which controls this contract.\n     * @param _associatedContract The ERC20 contract whose state this composes.\n     */\n    constructor(address _owner, address _associatedContract)\n        State(_owner, _associatedContract)\n        LimitedSetup(1 weeks)\n        public\n    {}\n\n    /* ========== SETTERS ========== */\n\n    /**\n     * @notice Set issuance data for an address\n     * @dev Only the associated contract may call this.\n     * @param account The address to set the data for.\n     * @param initialDebtOwnership The initial debt ownership for this address.\n     */\n    function setCurrentIssuanceData(address account, uint initialDebtOwnership)\n        external\n        onlyAssociatedContract\n    {\n        issuanceData[account].initialDebtOwnership = initialDebtOwnership;\n        issuanceData[account].debtEntryIndex = debtLedger.length;\n    }\n\n    /**\n     * @notice Clear issuance data for an address\n     * @dev Only the associated contract may call this.\n     * @param account The address to clear the data for.\n     */\n    function clearIssuanceData(address account)\n        external\n        onlyAssociatedContract\n    {\n        delete issuanceData[account];\n    }\n\n    /**\n     * @notice Increment the total issuer count\n     * @dev Only the associated contract may call this.\n     */\n    function incrementTotalIssuerCount()\n        external\n        onlyAssociatedContract\n    {\n        totalIssuerCount = totalIssuerCount.add(1);\n    }\n\n    /**\n     * @notice Decrement the total issuer count\n     * @dev Only the associated contract may call this.\n     */\n    function decrementTotalIssuerCount()\n        external\n        onlyAssociatedContract\n    {\n        totalIssuerCount = totalIssuerCount.sub(1);\n    }\n\n    /**\n     * @notice Append a value to the debt ledger\n     * @dev Only the associated contract may call this.\n     * @param value The new value to be added to the debt ledger.\n     */\n    function appendDebtLedgerValue(uint value)\n        external\n        onlyAssociatedContract\n    {\n        debtLedger.push(value);\n    }\n\n    /**\n     * @notice Set preferred currency for a user\n     * @dev Only the associated contract may call this.\n     * @param account The account to set the preferred currency for\n     * @param currencyKey The new preferred currency\n     */\n    function setPreferredCurrency(address account, bytes4 currencyKey)\n        external\n        onlyAssociatedContract\n    {\n        preferredCurrency[account] = currencyKey;\n    }\n\n    /**\n     * @notice Set the issuanceRatio for issuance calculations.\n     * @dev Only callable by the contract owner.\n     */\n    function setIssuanceRatio(uint _issuanceRatio)\n        external\n        onlyOwner\n    {\n        require(_issuanceRatio <= MAX_ISSUANCE_RATIO, \"New issuance ratio cannot exceed MAX_ISSUANCE_RATIO\");\n        issuanceRatio = _issuanceRatio;\n        emit IssuanceRatioUpdated(_issuanceRatio);\n    }\n\n    /**\n     * @notice Import issuer data from the old Synthetix contract before multicurrency\n     * @dev Only callable by the contract owner, and only for 1 week after deployment.\n     */\n    function importIssuerData(address[] accounts, uint[] sUSDAmounts)\n        external\n        onlyOwner\n        onlyDuringSetup\n    {\n        require(accounts.length == sUSDAmounts.length, \"Length mismatch\");\n\n        for (uint8 i = 0; i < accounts.length; i++) {\n            _addToDebtRegister(accounts[i], sUSDAmounts[i]);\n        }\n    }\n\n    /**\n     * @notice Import issuer data from the old Synthetix contract before multicurrency\n     * @dev Only used from importIssuerData above, meant to be disposable\n     */\n    function _addToDebtRegister(address account, uint amount)\n        internal\n    {\n        // This code is duplicated from Synthetix so that we can call it directly here\n        // during setup only.\n        Synthetix synthetix = Synthetix(associatedContract);\n\n        // What is the value of the requested debt in XDRs?\n        uint xdrValue = synthetix.effectiveValue(\"sUSD\", amount, \"XDR\");\n\n        // What is the value that we've previously imported?\n        uint totalDebtIssued = importedXDRAmount;\n\n        // What will the new total be including the new value?\n        uint newTotalDebtIssued = xdrValue.add(totalDebtIssued);\n\n        // Save that for the next import.\n        importedXDRAmount = newTotalDebtIssued;\n\n        // What is their percentage (as a high precision int) of the total debt?\n        uint debtPercentage = xdrValue.divideDecimalRoundPrecise(newTotalDebtIssued);\n\n        // And what effect does this percentage have on the global debt holding of other issuers?\n        // The delta specifically needs to not take into account any existing debt as it's already\n        // accounted for in the delta from when they issued previously.\n        // The delta is a high precision integer.\n        uint delta = SafeDecimalMath.preciseUnit().sub(debtPercentage);\n\n        uint existingDebt = synthetix.debtBalanceOf(account, \"XDR\");\n\n        // And what does their debt ownership look like including this previous stake?\n        if (existingDebt > 0) {\n            debtPercentage = xdrValue.add(existingDebt).divideDecimalRoundPrecise(newTotalDebtIssued);\n        }\n\n        // Are they a new issuer? If so, record them.\n        if (issuanceData[account].initialDebtOwnership == 0) {\n            totalIssuerCount = totalIssuerCount.add(1);\n        }\n\n        // Save the debt entry parameters\n        issuanceData[account].initialDebtOwnership = debtPercentage;\n        issuanceData[account].debtEntryIndex = debtLedger.length;\n\n        // And if we're the first, push 1 as there was no effect to any other holders, otherwise push\n        // the change for the rest of the debt holders. The debt ledger holds high precision integers.\n        if (debtLedger.length > 0) {\n            debtLedger.push(\n                debtLedger[debtLedger.length - 1].multiplyDecimalRoundPrecise(delta)\n            );\n        } else {\n            debtLedger.push(SafeDecimalMath.preciseUnit());\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the debt ledger array\n     */\n    function debtLedgerLength()\n        external\n        view\n        returns (uint)\n    {\n        return debtLedger.length;\n    }\n\n    /**\n     * @notice Retrieve the most recent entry from the debt ledger\n     */\n    function lastDebtLedgerEntry()\n        external\n        view\n        returns (uint)\n    {\n        return debtLedger[debtLedger.length - 1];\n    }\n\n    /**\n     * @notice Query whether an account has issued and has an outstanding debt balance\n     * @param account The address to query for\n     */\n    function hasIssued(address account)\n        external\n        view\n        returns (bool)\n    {\n        return issuanceData[account].initialDebtOwnership > 0;\n    }\n\n    event IssuanceRatioUpdated(uint newRatio);\n}\n\n\n/**\n * @title RewardsDistribution interface\n */\ninterface IRewardsDistribution {\n    function distributeRewards(uint amount) external;\n}\n\n\n/**\n * @title Synthetix ERC20 contract.\n * @notice The Synthetix contracts not only facilitates transfers, exchanges, and tracks balances,\n * but it also computes the quantity of fees each synthetix holder is entitled to.\n */\ncontract Synthetix is ExternStateToken {\n\n    // ========== STATE VARIABLES ==========\n\n    // Available Synths which can be used with the system\n    Synth[] public availableSynths;\n    mapping(bytes32 => Synth) public synths;\n    mapping(address => bytes32) public synthsByAddress;\n\n    IFeePool public feePool;\n    ISynthetixEscrow public escrow;\n    ISynthetixEscrow public rewardEscrow;\n    ExchangeRates public exchangeRates;\n    SynthetixState public synthetixState;\n    SupplySchedule public supplySchedule;\n    IRewardsDistribution public rewardsDistribution;\n\n    bool private protectionCircuit = false;\n\n    string constant TOKEN_NAME = \"Synthetix Network Token\";\n    string constant TOKEN_SYMBOL = \"SNX\";\n    uint8 constant DECIMALS = 18;\n    bool public exchangeEnabled = true;\n    uint public gasPriceLimit;\n\n    address public gasLimitOracle;\n    // ========== CONSTRUCTOR ==========\n\n    /**\n     * @dev Constructor\n     * @param _proxy The main token address of the Proxy contract. This will be ProxyERC20.sol\n     * @param _tokenState Address of the external immutable contract containing token balances.\n     * @param _synthetixState External immutable contract containing the SNX minters debt ledger.\n     * @param _owner The owner of this contract.\n     * @param _exchangeRates External immutable contract where the price oracle pushes prices onchain too.\n     * @param _feePool External upgradable contract handling SNX Fees and Rewards claiming\n     * @param _supplySchedule External immutable contract with the SNX inflationary supply schedule\n     * @param _rewardEscrow External immutable contract for SNX Rewards Escrow\n     * @param _escrow External immutable contract for SNX Token Sale Escrow\n     * @param _rewardsDistribution External immutable contract managing the Rewards Distribution of the SNX inflationary supply\n     * @param _totalSupply On upgrading set to reestablish the current total supply (This should be in SynthetixState if ever updated)\n     */\n    constructor(address _proxy, TokenState _tokenState, SynthetixState _synthetixState,\n        address _owner, ExchangeRates _exchangeRates, IFeePool _feePool, SupplySchedule _supplySchedule,\n        ISynthetixEscrow _rewardEscrow, ISynthetixEscrow _escrow, IRewardsDistribution _rewardsDistribution, uint _totalSupply\n    )\n        ExternStateToken(_proxy, _tokenState, TOKEN_NAME, TOKEN_SYMBOL, _totalSupply, DECIMALS, _owner)\n        public\n    {\n        synthetixState = _synthetixState;\n        exchangeRates = _exchangeRates;\n        feePool = _feePool;\n        supplySchedule = _supplySchedule;\n        rewardEscrow = _rewardEscrow;\n        escrow = _escrow;\n        rewardsDistribution = _rewardsDistribution;\n    }\n    // ========== SETTERS ========== */\n\n    function setFeePool(IFeePool _feePool)\n        external\n        optionalProxy_onlyOwner\n    {\n        feePool = _feePool;\n    }\n\n    function setExchangeRates(ExchangeRates _exchangeRates)\n        external\n        optionalProxy_onlyOwner\n    {\n        exchangeRates = _exchangeRates;\n    }\n\n    function setProtectionCircuit(bool _protectionCircuitIsActivated)\n        external\n        onlyOracle\n    {\n        protectionCircuit = _protectionCircuitIsActivated;\n    }\n\n    function setExchangeEnabled(bool _exchangeEnabled)\n        external\n        optionalProxy_onlyOwner\n    {\n        exchangeEnabled = _exchangeEnabled;\n    }\n\n    function setGasLimitOracle(address _gasLimitOracle)\n        external\n        optionalProxy_onlyOwner\n    {\n        gasLimitOracle = _gasLimitOracle;\n    }\n\n    function setGasPriceLimit(uint _gasPriceLimit)\n        external\n    {\n        require(msg.sender == gasLimitOracle, \"Only gas limit oracle allowed\");\n        require(_gasPriceLimit > 0, \"Needs to be greater than 0\");\n        gasPriceLimit = _gasPriceLimit;\n    }\n\n    /**\n     * @notice Add an associated Synth contract to the Synthetix system\n     * @dev Only the contract owner may call this.\n     */\n    function addSynth(Synth synth)\n        external\n        optionalProxy_onlyOwner\n    {\n        bytes32 currencyKey = synth.currencyKey();\n\n        require(synths[currencyKey] == Synth(0), \"Synth already exists\");\n        require(synthsByAddress[synth] == bytes32(0), \"Synth address already exists\");\n\n        availableSynths.push(synth);\n        synths[currencyKey] = synth;\n        synthsByAddress[synth] = currencyKey;\n    }\n\n    /**\n     * @notice Remove an associated Synth contract from the Synthetix system\n     * @dev Only the contract owner may call this.\n     */\n    function removeSynth(bytes32 currencyKey)\n        external\n        optionalProxy_onlyOwner\n    {\n        require(synths[currencyKey] != address(0), \"Synth does not exist\");\n        require(synths[currencyKey].totalSupply() == 0, \"Synth supply exists\");\n        require(currencyKey != \"XDR\" && currencyKey != \"sUSD\", \"Cannot remove synth\");        \n\n        // Save the address we're removing for emitting the event at the end.\n        address synthToRemove = synths[currencyKey];\n\n        // Remove the synth from the availableSynths array.\n        for (uint i = 0; i < availableSynths.length; i++) {\n            if (availableSynths[i] == synthToRemove) {\n                delete availableSynths[i];\n\n                // Copy the last synth into the place of the one we just deleted\n                // If there's only one synth, this is synths[0] = synths[0].\n                // If we're deleting the last one, it's also a NOOP in the same way.\n                availableSynths[i] = availableSynths[availableSynths.length - 1];\n\n                // Decrease the size of the array by one.\n                availableSynths.length--;\n\n                break;\n            }\n        }\n\n        // And remove it from the synths mapping\n        delete synthsByAddress[synths[currencyKey]];\n        delete synths[currencyKey];\n\n        // Note: No event here as Synthetix contract exceeds max contract size\n        // with these events, and it's unlikely people will need to\n        // track these events specifically.\n    }\n\n    // ========== VIEWS ==========\n\n    /**\n     * @notice A function that lets you easily convert an amount in a source currency to an amount in the destination currency\n     * @param sourceCurrencyKey The currency the amount is specified in\n     * @param sourceAmount The source amount, specified in UNIT base\n     * @param destinationCurrencyKey The destination currency\n     */\n    function effectiveValue(bytes32 sourceCurrencyKey, uint sourceAmount, bytes32 destinationCurrencyKey)\n        public\n        view\n        returns (uint)\n    {\n        return exchangeRates.effectiveValue(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);\n    }\n\n    /**\n     * @notice Total amount of synths issued by the system, priced in currencyKey\n     * @param currencyKey The currency to value the synths in\n     */\n    function totalIssuedSynths(bytes32 currencyKey)\n        public\n        view\n        returns (uint)\n    {\n        uint total = 0;\n        uint currencyRate = exchangeRates.rateForCurrency(currencyKey);\n\n        (uint[] memory rates, bool anyRateStale) = exchangeRates.ratesAndStaleForCurrencies(availableCurrencyKeys());\n        require(!anyRateStale, \"Rates are stale\");\n\n        for (uint i = 0; i < availableSynths.length; i++) {\n            // What's the total issued value of that synth in the destination currency?\n            // Note: We're not using our effectiveValue function because we don't want to go get the\n            //       rate for the destination currency and check if it's stale repeatedly on every\n            //       iteration of the loop\n            uint synthValue = availableSynths[i].totalSupply()\n                .multiplyDecimalRound(rates[i]);\n            total = total.add(synthValue);\n        }\n\n        return total.divideDecimalRound(currencyRate);\n    }\n\n    /**\n     * @notice Returns the currencyKeys of availableSynths for rate checking\n     */\n    function availableCurrencyKeys()\n        public\n        view\n        returns (bytes32[])\n    {\n        bytes32[] memory currencyKeys = new bytes32[](availableSynths.length);\n\n        for (uint i = 0; i < availableSynths.length; i++) {\n            currencyKeys[i] = synthsByAddress[availableSynths[i]];\n        }\n\n        return currencyKeys;\n    }\n\n    /**\n     * @notice Returns the count of available synths in the system, which you can use to iterate availableSynths\n     */\n    function availableSynthCount()\n        public\n        view\n        returns (uint)\n    {\n        return availableSynths.length;\n    }\n\n    /**\n     * @notice Determine the effective fee rate for the exchange, taking into considering swing trading\n     */\n    function feeRateForExchange(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey)\n        public\n        view\n        returns (uint)\n    {\n        // Get the base exchange fee rate\n        uint exchangeFeeRate = feePool.exchangeFeeRate();\n\n        uint multiplier = 1;\n\n        // Is this a swing trade? I.e. long to short or vice versa, excluding when going into or out of sUSD.\n        // Note: this assumes shorts begin with 'i' and longs with 's'.\n        if (\n            (sourceCurrencyKey[0] == 0x73 && sourceCurrencyKey != \"sUSD\" && destinationCurrencyKey[0] == 0x69) ||\n            (sourceCurrencyKey[0] == 0x69 && destinationCurrencyKey != \"sUSD\" && destinationCurrencyKey[0] == 0x73)\n        ) {\n            // If so then double the exchange fee multipler\n            multiplier = 2;\n        }\n\n        return exchangeFeeRate.mul(multiplier);\n    }\n    // ========== MUTATIVE FUNCTIONS ==========\n    \n    /**\n     * @notice ERC20 transfer function.\n     */\n    function transfer(address to, uint value)\n        public\n        optionalProxy\n        returns (bool)\n    {\n        // Ensure they're not trying to exceed their staked SNX amount\n        require(value <= transferableSynthetix(messageSender), \"Cannot transfer staked or escrowed SNX\");\n\n        // Perform the transfer: if there is a problem an exception will be thrown in this call.\n        _transfer_byProxy(messageSender, to, value);\n\n        return true;\n    }\n\n     /**\n     * @notice ERC20 transferFrom function.\n     */\n    function transferFrom(address from, address to, uint value)\n        public\n        optionalProxy\n        returns (bool)\n    {\n        // Ensure they're not trying to exceed their locked amount\n        require(value <= transferableSynthetix(from), \"Cannot transfer staked or escrowed SNX\");\n\n        // Perform the transfer: if there is a problem,\n        // an exception will be thrown in this call.\n        return _transferFrom_byProxy(messageSender, from, to, value);         \n    }\n\n    /**\n     * @notice Function that allows you to exchange synths you hold in one flavour for another.\n     * @param sourceCurrencyKey The source currency you wish to exchange from\n     * @param sourceAmount The amount, specified in UNIT of source currency you wish to exchange\n     * @param destinationCurrencyKey The destination currency you wish to obtain.\n     * @return Boolean that indicates whether the transfer succeeded or failed.\n     */\n    function exchange(bytes32 sourceCurrencyKey, uint sourceAmount, bytes32 destinationCurrencyKey)\n        external\n        optionalProxy\n        // Note: We don't need to insist on non-stale rates because effectiveValue will do it for us.\n        returns (bool)\n    {\n        require(sourceCurrencyKey != destinationCurrencyKey, \"Can't be same synth\");\n        require(sourceAmount > 0, \"Zero amount\");\n\n        // verify gas price limit\n        validateGasPrice(tx.gasprice);\n\n        //  If the oracle has set protectionCircuit to true then burn the synths\n        if (protectionCircuit) {\n            synths[sourceCurrencyKey].burn(messageSender, sourceAmount);\n            return true;\n        } else {\n            // Pass it along, defaulting to the sender as the recipient.\n            return _internalExchange(\n                messageSender,\n                sourceCurrencyKey,\n                sourceAmount,\n                destinationCurrencyKey,\n                messageSender,\n                true // Charge fee on the exchange\n            );\n        }\n    }\n\n    /*\n        @dev validate that the given gas price is less than or equal to the gas price limit\n        @param _gasPrice tested gas price\n    */\n    function validateGasPrice(uint _givenGasPrice)\n        public\n        view\n    {\n        require(_givenGasPrice <= gasPriceLimit, \"Gas price above limit\");\n    }\n\n    /**\n     * @notice Function that allows synth contract to delegate exchanging of a synth that is not the same sourceCurrency\n     * @dev Only the synth contract can call this function\n     * @param from The address to exchange / burn synth from\n     * @param sourceCurrencyKey The source currency you wish to exchange from\n     * @param sourceAmount The amount, specified in UNIT of source currency you wish to exchange\n     * @param destinationCurrencyKey The destination currency you wish to obtain.\n     * @param destinationAddress Where the result should go.\n     * @return Boolean that indicates whether the transfer succeeded or failed.\n     */\n    function synthInitiatedExchange(\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress\n    )\n        external\n        optionalProxy\n        returns (bool)\n    {\n        require(synthsByAddress[messageSender] != bytes32(0), \"Only synth allowed\");\n        require(sourceCurrencyKey != destinationCurrencyKey, \"Can't be same synth\");\n        require(sourceAmount > 0, \"Zero amount\");\n\n        // Pass it along\n        return _internalExchange(\n            from,\n            sourceCurrencyKey,\n            sourceAmount,\n            destinationCurrencyKey,\n            destinationAddress,\n            false\n        );\n    }\n\n    /**\n     * @notice Function that allows synth contract to delegate sending fee to the fee Pool.\n     * @dev fee pool contract address is not allowed to call function\n     * @param from The address to move synth from\n     * @param sourceCurrencyKey source currency from.\n     * @param sourceAmount The amount, specified in UNIT of source currency.\n     * @param destinationCurrencyKey The destination currency to obtain.\n     * @param destinationAddress Where the result should go.\n     * @param chargeFee Boolean to charge a fee for exchange.\n     * @return Boolean that indicates whether the transfer succeeded or failed.\n     */\n    function _internalExchange(\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress,\n        bool chargeFee\n    )\n        internal\n        returns (bool)\n    {\n        require(exchangeEnabled, \"Exchanging is disabled\");\n\n        // Note: We don't need to check their balance as the burn() below will do a safe subtraction which requires\n        // the subtraction to not overflow, which would happen if their balance is not sufficient.\n\n        // Burn the source amount\n        synths[sourceCurrencyKey].burn(from, sourceAmount);\n\n        // How much should they get in the destination currency?\n        uint destinationAmount = effectiveValue(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);\n\n        // What's the fee on that currency that we should deduct?\n        uint amountReceived = destinationAmount;\n        uint fee = 0;\n\n        if (chargeFee) {\n            // Get the exchange fee rate\n            uint exchangeFeeRate = feeRateForExchange(sourceCurrencyKey, destinationCurrencyKey);\n\n            amountReceived = destinationAmount.multiplyDecimal(SafeDecimalMath.unit().sub(exchangeFeeRate));\n\n            fee = destinationAmount.sub(amountReceived);\n        }\n\n        // Issue their new synths\n        synths[destinationCurrencyKey].issue(destinationAddress, amountReceived);\n\n        // Remit the fee in XDRs\n        if (fee > 0) {\n            uint xdrFeeAmount = effectiveValue(destinationCurrencyKey, fee, \"XDR\");\n            synths[\"XDR\"].issue(feePool.FEE_ADDRESS(), xdrFeeAmount);\n            // Tell the fee pool about this.\n            feePool.recordFeePaid(xdrFeeAmount);\n        }\n\n        // Nothing changes as far as issuance data goes because the total value in the system hasn't changed.        \n\n        //Let the DApps know there was a Synth exchange\n        emitSynthExchange(from, sourceCurrencyKey, sourceAmount, destinationCurrencyKey, amountReceived, destinationAddress);\n\n        return true;\n    }\n\n    /**\n     * @notice Function that registers new synth as they are issued. Calculate delta to append to synthetixState.\n     * @dev Only internal calls from synthetix address.\n     * @param currencyKey The currency to register synths in, for example sUSD or sAUD\n     * @param amount The amount of synths to register with a base of UNIT\n     */\n    function _addToDebtRegister(bytes32 currencyKey, uint amount)\n        internal\n    {\n        // What is the value of the requested debt in XDRs?\n        uint xdrValue = effectiveValue(currencyKey, amount, \"XDR\");\n\n        // What is the value of all issued synths of the system (priced in XDRs)?\n        uint totalDebtIssued = totalIssuedSynths(\"XDR\");\n\n        // What will the new total be including the new value?\n        uint newTotalDebtIssued = xdrValue.add(totalDebtIssued);\n\n        // What is their percentage (as a high precision int) of the total debt?\n        uint debtPercentage = xdrValue.divideDecimalRoundPrecise(newTotalDebtIssued);\n\n        // And what effect does this percentage change have on the global debt holding of other issuers?\n        // The delta specifically needs to not take into account any existing debt as it's already\n        // accounted for in the delta from when they issued previously.\n        // The delta is a high precision integer.\n        uint delta = SafeDecimalMath.preciseUnit().sub(debtPercentage);\n\n        // How much existing debt do they have?\n        uint existingDebt = debtBalanceOf(messageSender, \"XDR\");\n\n        // And what does their debt ownership look like including this previous stake?\n        if (existingDebt > 0) {\n            debtPercentage = xdrValue.add(existingDebt).divideDecimalRoundPrecise(newTotalDebtIssued);\n        }\n\n        // Are they a new issuer? If so, record them.\n        if (existingDebt == 0) {\n            synthetixState.incrementTotalIssuerCount();\n        }\n\n        // Save the debt entry parameters\n        synthetixState.setCurrentIssuanceData(messageSender, debtPercentage);\n\n        // And if we're the first, push 1 as there was no effect to any other holders, otherwise push\n        // the change for the rest of the debt holders. The debt ledger holds high precision integers.\n        if (synthetixState.debtLedgerLength() > 0) {\n            synthetixState.appendDebtLedgerValue(\n                synthetixState.lastDebtLedgerEntry().multiplyDecimalRoundPrecise(delta)\n            );\n        } else {\n            synthetixState.appendDebtLedgerValue(SafeDecimalMath.preciseUnit());\n        }\n    }\n\n    /**\n     * @notice Issue synths against the sender's SNX.\n     * @dev Issuance is only allowed if the synthetix price isn't stale. Amount should be larger than 0.\n     * @param amount The amount of synths you wish to issue with a base of UNIT\n     */\n    function issueSynths(uint amount)\n        public\n        optionalProxy\n        // No need to check if price is stale, as it is checked in issuableSynths.\n    {\n        bytes32 currencyKey = \"sUSD\";\n\n        require(amount <= remainingIssuableSynths(messageSender, currencyKey), \"Amount too large\");\n\n        // Keep track of the debt they're about to create\n        _addToDebtRegister(currencyKey, amount);\n\n        // Create their synths\n        synths[currencyKey].issue(messageSender, amount);\n\n        // Store their locked SNX amount to determine their fee % for the period\n        _appendAccountIssuanceRecord();\n    }\n\n    /**\n     * @notice Issue the maximum amount of Synths possible against the sender's SNX.\n     * @dev Issuance is only allowed if the synthetix price isn't stale.\n     */\n    function issueMaxSynths()\n        external\n        optionalProxy\n    {\n        bytes32 currencyKey = \"sUSD\";\n\n        // Figure out the maximum we can issue in that currency\n        uint maxIssuable = remainingIssuableSynths(messageSender, currencyKey);\n\n        // Keep track of the debt they're about to create\n        _addToDebtRegister(currencyKey, maxIssuable);\n\n        // Create their synths\n        synths[currencyKey].issue(messageSender, maxIssuable);\n\n        // Store their locked SNX amount to determine their fee % for the period\n        _appendAccountIssuanceRecord();\n    }\n\n    /**\n     * @notice Burn synths to clear issued synths/free SNX.\n     * @param amount The amount (in UNIT base) you wish to burn\n     * @dev The amount to burn is debased to XDR's\n     */\n    function burnSynths(uint amount)\n        external\n        optionalProxy\n        // No need to check for stale rates as effectiveValue checks rates\n    {\n        bytes32 currencyKey = \"sUSD\";\n\n        // How much debt do they have?\n        uint debtToRemove = effectiveValue(currencyKey, amount, \"XDR\");\n        uint existingDebt = debtBalanceOf(messageSender, \"XDR\");\n\n        uint debtInCurrencyKey = debtBalanceOf(messageSender, currencyKey);\n\n        require(existingDebt > 0, \"No debt to forgive\");\n\n        // If they're trying to burn more debt than they actually owe, rather than fail the transaction, let's just\n        // clear their debt and leave them be.\n        uint amountToRemove = existingDebt < debtToRemove ? existingDebt : debtToRemove;\n\n        // Remove their debt from the ledger\n        _removeFromDebtRegister(amountToRemove, existingDebt);\n\n        uint amountToBurn = debtInCurrencyKey < amount ? debtInCurrencyKey : amount;\n\n        // synth.burn does a safe subtraction on balance (so it will revert if there are not enough synths).\n        synths[currencyKey].burn(messageSender, amountToBurn);\n\n        // Store their debtRatio against a feeperiod to determine their fee/rewards % for the period\n        _appendAccountIssuanceRecord();\n    }\n\n    /**\n     * @notice Store in the FeePool the users current debt value in the system in XDRs.\n     * @dev debtBalanceOf(messageSender, \"XDR\") to be used with totalIssuedSynths(\"XDR\") to get\n     *  users % of the system within a feePeriod.\n     */\n    function _appendAccountIssuanceRecord()\n        internal\n    {\n        uint initialDebtOwnership;\n        uint debtEntryIndex;\n        (initialDebtOwnership, debtEntryIndex) = synthetixState.issuanceData(messageSender);\n\n        feePool.appendAccountIssuanceRecord(\n            messageSender,\n            initialDebtOwnership,\n            debtEntryIndex\n        );\n    }\n\n    /**\n     * @notice Remove a debt position from the register\n     * @param amount The amount (in UNIT base) being presented in XDRs\n     * @param existingDebt The existing debt (in UNIT base) of address presented in XDRs\n     */\n    function _removeFromDebtRegister(uint amount, uint existingDebt)\n        internal\n    {\n        uint debtToRemove = amount;\n\n        // What is the value of all issued synths of the system (priced in XDRs)?\n        uint totalDebtIssued = totalIssuedSynths(\"XDR\");\n\n        // What will the new total after taking out the withdrawn amount\n        uint newTotalDebtIssued = totalDebtIssued.sub(debtToRemove);\n\n        uint delta = 0;\n\n        // What will the debt delta be if there is any debt left?\n        // Set delta to 0 if no more debt left in system after user\n        if (newTotalDebtIssued > 0) {\n\n            // What is the percentage of the withdrawn debt (as a high precision int) of the total debt after?\n            uint debtPercentage = debtToRemove.divideDecimalRoundPrecise(newTotalDebtIssued);\n\n            // And what effect does this percentage change have on the global debt holding of other issuers?\n            // The delta specifically needs to not take into account any existing debt as it's already\n            // accounted for in the delta from when they issued previously.\n            delta = SafeDecimalMath.preciseUnit().add(debtPercentage);\n        }\n\n        // Are they exiting the system, or are they just decreasing their debt position?\n        if (debtToRemove == existingDebt) {\n            synthetixState.setCurrentIssuanceData(messageSender, 0);\n            synthetixState.decrementTotalIssuerCount();\n        } else {\n            // What percentage of the debt will they be left with?\n            uint newDebt = existingDebt.sub(debtToRemove);\n            uint newDebtPercentage = newDebt.divideDecimalRoundPrecise(newTotalDebtIssued);\n\n            // Store the debt percentage and debt ledger as high precision integers\n            synthetixState.setCurrentIssuanceData(messageSender, newDebtPercentage);\n        }\n\n        // Update our cumulative ledger. This is also a high precision integer.\n        synthetixState.appendDebtLedgerValue(\n            synthetixState.lastDebtLedgerEntry().multiplyDecimalRoundPrecise(delta)\n        );\n    }\n\n    // ========== Issuance/Burning ==========\n\n    /**\n     * @notice The maximum synths an issuer can issue against their total synthetix quantity, priced in XDRs.\n     * This ignores any already issued synths, and is purely giving you the maximimum amount the user can issue.\n     */\n    function maxIssuableSynths(address issuer, bytes32 currencyKey)\n        public\n        view\n        // We don't need to check stale rates here as effectiveValue will do it for us.\n        returns (uint)\n    {\n        // What is the value of their SNX balance in the destination currency?\n        uint destinationValue = effectiveValue(\"SNX\", collateral(issuer), currencyKey);\n\n        // They're allowed to issue up to issuanceRatio of that value\n        return destinationValue.multiplyDecimal(synthetixState.issuanceRatio());\n    }\n\n    /**\n     * @notice The current collateralisation ratio for a user. Collateralisation ratio varies over time\n     * as the value of the underlying Synthetix asset changes,\n     * e.g. based on an issuance ratio of 20%. if a user issues their maximum available\n     * synths when they hold $10 worth of Synthetix, they will have issued $2 worth of synths. If the value\n     * of Synthetix changes, the ratio returned by this function will adjust accordingly. Users are\n     * incentivised to maintain a collateralisation ratio as close to the issuance ratio as possible by\n     * altering the amount of fees they're able to claim from the system.\n     */\n    function collateralisationRatio(address issuer)\n        public\n        view\n        returns (uint)\n    {\n        uint totalOwnedSynthetix = collateral(issuer);\n        if (totalOwnedSynthetix == 0) return 0;\n\n        uint debtBalance = debtBalanceOf(issuer, \"SNX\");\n        return debtBalance.divideDecimalRound(totalOwnedSynthetix);\n    }\n\n    /**\n     * @notice If a user issues synths backed by SNX in their wallet, the SNX become locked. This function\n     * will tell you how many synths a user has to give back to the system in order to unlock their original\n     * debt position. This is priced in whichever synth is passed in as a currency key, e.g. you can price\n     * the debt in sUSD, XDR, or any other synth you wish.\n     */\n    function debtBalanceOf(address issuer, bytes32 currencyKey)\n        public\n        view\n        // Don't need to check for stale rates here because totalIssuedSynths will do it for us\n        returns (uint)\n    {\n        // What was their initial debt ownership?\n        uint initialDebtOwnership;\n        uint debtEntryIndex;\n        (initialDebtOwnership, debtEntryIndex) = synthetixState.issuanceData(issuer);\n\n        // If it's zero, they haven't issued, and they have no debt.\n        if (initialDebtOwnership == 0) return 0;\n\n        // Figure out the global debt percentage delta from when they entered the system.\n        // This is a high precision integer of 27 (1e27) decimals.\n        uint currentDebtOwnership = synthetixState.lastDebtLedgerEntry()\n            .divideDecimalRoundPrecise(synthetixState.debtLedger(debtEntryIndex))\n            .multiplyDecimalRoundPrecise(initialDebtOwnership);\n\n        // What's the total value of the system in their requested currency?\n        uint totalSystemValue = totalIssuedSynths(currencyKey);\n\n        // Their debt balance is their portion of the total system value.\n        uint highPrecisionBalance = totalSystemValue.decimalToPreciseDecimal()\n            .multiplyDecimalRoundPrecise(currentDebtOwnership);\n\n        // Convert back into 18 decimals (1e18)\n        return highPrecisionBalance.preciseDecimalToDecimal();\n    }\n\n    /**\n     * @notice The remaining synths an issuer can issue against their total synthetix balance.\n     * @param issuer The account that intends to issue\n     * @param currencyKey The currency to price issuable value in\n     */\n    function remainingIssuableSynths(address issuer, bytes32 currencyKey)\n        public\n        view\n        // Don't need to check for synth existing or stale rates because maxIssuableSynths will do it for us.\n        returns (uint)\n    {\n        uint alreadyIssued = debtBalanceOf(issuer, currencyKey);\n        uint max = maxIssuableSynths(issuer, currencyKey);\n\n        if (alreadyIssued >= max) {\n            return 0;\n        } else {\n            return max.sub(alreadyIssued);\n        }\n    }\n\n    /**\n     * @notice The total SNX owned by this account, both escrowed and unescrowed,\n     * against which synths can be issued.\n     * This includes those already being used as collateral (locked), and those\n     * available for further issuance (unlocked).\n     */\n    function collateral(address account)\n        public\n        view\n        returns (uint)\n    {\n        uint balance = tokenState.balanceOf(account);\n\n        if (escrow != address(0)) {\n            balance = balance.add(escrow.balanceOf(account));\n        }\n\n        if (rewardEscrow != address(0)) {\n            balance = balance.add(rewardEscrow.balanceOf(account));\n        }\n\n        return balance;\n    }\n\n    /**\n     * @notice The number of SNX that are free to be transferred for an account.\n     * @dev Escrowed SNX are not transferable, so they are not included\n     * in this calculation.\n     * @notice SNX rate not stale is checked within debtBalanceOf\n     */\n    function transferableSynthetix(address account)\n        public\n        view\n        rateNotStale(\"SNX\") // SNX is not a synth so is not checked in totalIssuedSynths\n        returns (uint)\n    {\n        // How many SNX do they have, excluding escrow?\n        // Note: We're excluding escrow here because we're interested in their transferable amount\n        // and escrowed SNX are not transferable.\n        uint balance = tokenState.balanceOf(account);\n\n        // How many of those will be locked by the amount they've issued?\n        // Assuming issuance ratio is 20%, then issuing 20 SNX of value would require\n        // 100 SNX to be locked in their wallet to maintain their collateralisation ratio\n        // The locked synthetix value can exceed their balance.\n        uint lockedSynthetixValue = debtBalanceOf(account, \"SNX\").divideDecimalRound(synthetixState.issuanceRatio());\n\n        // If we exceed the balance, no SNX are transferable, otherwise the difference is.\n        if (lockedSynthetixValue >= balance) {\n            return 0;\n        } else {\n            return balance.sub(lockedSynthetixValue);\n        }\n    }\n\n    /**\n     * @notice Mints the inflationary SNX supply. The inflation shedule is\n     * defined in the SupplySchedule contract.\n     * The mint() function is publicly callable by anyone. The caller will\n     receive a minter reward as specified in supplySchedule.minterReward().\n     */\n    function mint()\n        external\n        returns (bool)\n    {\n        require(rewardsDistribution != address(0), \"RewardsDistribution not set\");\n\n        uint supplyToMint = supplySchedule.mintableSupply();\n        require(supplyToMint > 0, \"No supply is mintable\");\n\n        // record minting event before mutation to token supply\n        supplySchedule.recordMintEvent(supplyToMint);\n\n        // Set minted SNX balance to RewardEscrow's balance\n        // Minus the minterReward and set balance of minter to add reward\n        uint minterReward = supplySchedule.minterReward();\n        // Get the remainder\n        uint amountToDistribute = supplyToMint.sub(minterReward);\n\n        // Set the token balance to the RewardsDistribution contract\n        tokenState.setBalanceOf(rewardsDistribution, tokenState.balanceOf(rewardsDistribution).add(amountToDistribute));\n        emitTransfer(this, rewardsDistribution, amountToDistribute);\n\n        // Kick off the distribution of rewards\n        rewardsDistribution.distributeRewards(amountToDistribute);\n\n        // Assign the minters reward.\n        tokenState.setBalanceOf(msg.sender, tokenState.balanceOf(msg.sender).add(minterReward));\n        emitTransfer(this, msg.sender, minterReward);\n\n        totalSupply = totalSupply.add(supplyToMint);\n\n        return true;\n    }\n\n    // ========== MODIFIERS ==========\n\n    modifier rateNotStale(bytes32 currencyKey) {\n        require(!exchangeRates.rateIsStale(currencyKey), \"Rate stale or not a synth\");\n        _;\n    }\n\n    modifier onlyOracle\n    {\n        require(msg.sender == exchangeRates.oracle(), \"Only oracle allowed\");\n        _;\n    }\n\n    // ========== EVENTS ==========\n    /* solium-disable */\n    event SynthExchange(address indexed account, bytes32 fromCurrencyKey, uint256 fromAmount, bytes32 toCurrencyKey,  uint256 toAmount, address toAddress);\n    bytes32 constant SYNTHEXCHANGE_SIG = keccak256(\"SynthExchange(address,bytes32,uint256,bytes32,uint256,address)\");\n    function emitSynthExchange(address account, bytes32 fromCurrencyKey, uint256 fromAmount, bytes32 toCurrencyKey, uint256 toAmount, address toAddress) internal {\n        proxy._emit(abi.encode(fromCurrencyKey, fromAmount, toCurrencyKey, toAmount, toAddress), 2, SYNTHEXCHANGE_SIG, bytes32(account), 0, 0);\n    }\n    /* solium-enable */\n}\n\n\n    ","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gasPriceLimit\",\"type\":\"uint256\"}],\"name\":\"setGasPriceLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"removeSynth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_integrationProxy\",\"type\":\"address\"}],\"name\":\"setIntegrationProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"synthsByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initiationTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feePool\",\"type\":\"address\"}],\"name\":\"setFeePool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"name\":\"destinationCurrencyKey\",\"type\":\"bytes32\"}],\"name\":\"feeRateForExchange\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gasLimitOracle\",\"type\":\"address\"}],\"name\":\"setGasLimitOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"setSelfDestructBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnSynths\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"synths\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"terminateSelfDestruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardsDistribution\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRates\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeRates\",\"type\":\"address\"}],\"name\":\"setExchangeRates\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"name\":\"destinationCurrencyKey\",\"type\":\"bytes32\"}],\"name\":\"effectiveValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"transferableSynthetix\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_givenGasPrice\",\"type\":\"uint256\"}],\"name\":\"validateGasPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableCurrencyKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"issuer\",\"type\":\"address\"},{\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"remainingIssuableSynths\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"availableSynths\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"totalIssuedSynths\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"synth\",\"type\":\"address\"}],\"name\":\"addSynth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"issueSynths\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeEnabled\",\"type\":\"bool\"}],\"name\":\"setExchangeEnabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasPriceLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"setProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"selfDestruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"integrationProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenState\",\"type\":\"address\"}],\"name\":\"setTokenState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"issuer\",\"type\":\"address\"}],\"name\":\"collateralisationRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardEscrow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SELFDESTRUCT_DELAY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"collateral\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"issuer\",\"type\":\"address\"},{\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"maxIssuableSynths\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"name\":\"destinationCurrencyKey\",\"type\":\"bytes32\"},{\"name\":\"destinationAddress\",\"type\":\"address\"}],\"name\":\"synthInitiatedExchange\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feePool\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"issueMaxSynths\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"selfDestructInitiated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"setMessageSender\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initiateSelfDestruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supplySchedule\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"selfDestructBeneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_protectionCircuitIsActivated\",\"type\":\"bool\"}],\"name\":\"setProtectionCircuit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"issuer\",\"type\":\"address\"},{\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"debtBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"messageSender\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthetixState\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableSynthCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escrow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenState\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"name\":\"destinationCurrencyKey\",\"type\":\"bytes32\"}],\"name\":\"exchange\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasLimitOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_proxy\",\"type\":\"address\"},{\"name\":\"_tokenState\",\"type\":\"address\"},{\"name\":\"_synthetixState\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_exchangeRates\",\"type\":\"address\"},{\"name\":\"_feePool\",\"type\":\"address\"},{\"name\":\"_supplySchedule\",\"type\":\"address\"},{\"name\":\"_rewardEscrow\",\"type\":\"address\"},{\"name\":\"_escrow\",\"type\":\"address\"},{\"name\":\"_rewardsDistribution\",\"type\":\"address\"},{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fromCurrencyKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"fromAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"toCurrencyKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"toAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"SynthExchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newTokenState\",\"type\":\"address\"}],\"name\":\"TokenStateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proxyAddress\",\"type\":\"address\"}],\"name\":\"ProxyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SelfDestructTerminated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"SelfDestructed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"selfDestructDelay\",\"type\":\"uint256\"}],\"name\":\"SelfDestructInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newBeneficiary\",\"type\":\"address\"}],\"name\":\"SelfDestructBeneficiaryUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"}]","ContractName":"Synthetix","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c011a72400e58ecd99ee497cf89e3775d4bd732f0000000000000000000000005b1b5fea1b99d83ad479df0c222f0492385381dd0000000000000000000000004b9ca5607f1ff8019c1c6a3c2f0cc8de622d5b82000000000000000000000000b64ff7a4a33acdf48d97dab0d764afd0f6176882000000000000000000000000e95ef4e7a04d2fb05cb625c62ca58da10112c605000000000000000000000000a8cb0b163cefb21f22c72f6a7d243184bd688a5a000000000000000000000000a05e45396703babaa9c276b5e5a9b6e2c175b521000000000000000000000000b671f2210b1f6621a2607ea63e6b2dc3e2464d1f000000000000000000000000971e78e0c92392a4e39099835cf7e6ab535b2227000000000000000000000000ffa72fd80d8a84032d855bfb67036baf45949009000000000000000000000000000000000000000000826cd3c893bc38462c9d73","Library":"SafeDecimalMath:84d626b2bb4d0f064067e4bf80fce7055d8f3e7b","LicenseType":"","SwarmSource":"bzzr://7e5de7b2c8454afb4fecf2a46fa9ccc0e392fe2b302da0369358c02ba4f12d11"}]}