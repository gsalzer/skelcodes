{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.26;\n\n\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract DSMath {\n    \n    \n\n    function add(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        assert((z = x + y) >= x);\n    }\n\n    function sub(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        assert((z = x - y) <= x);\n    }\n\n    function mul(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        assert((z = x * y) >= x);\n    }\n    \n    function div(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        require(y > 0);\n        z = x / y;\n    }\n    \n    function min(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n    function max(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    \n\n\n    function hadd(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        assert((z = x + y) >= x);\n    }\n\n    function hsub(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        assert((z = x - y) <= x);\n    }\n\n    function hmul(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        assert((z = x * y) >= x);\n    }\n\n    function hdiv(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        assert(y > 0);\n        z = x / y;\n    }\n\n    function hmin(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        return x <= y ? x : y;\n    }\n    function hmax(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        return x >= y ? x : y;\n    }\n\n\n    \n\n    function imin(int256 x, int256 y) pure internal returns (int256 z) {\n        return x <= y ? x : y;\n    }\n    function imax(int256 x, int256 y) pure internal returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    \n\n    uint128 constant WAD = 10 ** 18;\n\n    function wadd(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function wsub(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function wmul(uint128 x, uint128 y) view internal returns (uint128 z) {\n        z = cast((uint256(x) * y + WAD / 2) / WAD);\n    }\n\n    function wdiv(uint128 x, uint128 y) view internal returns (uint128 z) {\n        z = cast((uint256(x) * WAD + y / 2) / y);\n    }\n\n    function wmin(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hmin(x, y);\n    }\n    function wmax(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hmax(x, y);\n    }\n\n    \n\n    uint128 constant RAY = 10 ** 27;\n\n    function radd(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function rsub(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function rmul(uint128 x, uint128 y) view internal returns (uint128 z) {\n        z = cast((uint256(x) * y + RAY / 2) / RAY);\n    }\n\n    function rdiv(uint128 x, uint128 y) view internal returns (uint128 z) {\n        z = cast((uint256(x) * RAY + y / 2) / y);\n    }\n\n    function rpow(uint128 x, uint64 n) view internal returns (uint128 z) {\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n\n    function rmin(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hmin(x, y);\n    }\n    function rmax(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hmax(x, y);\n    }\n\n    function cast(uint256 x) pure internal returns (uint128 z) {\n        assert((z = uint128(x)) == x);\n    }\n\n}\n\ninterface MedianizerInterface {\n    function oracles(uint256) public view returns (address);\n    function peek() public view returns (bytes32, bool);\n    function read() public returns (bytes32);\n    function poke() public;\n    function poke(bytes32) public;\n    function fund (uint256 amount, ERC20 token) public;\n}\n\ncontract Oracle is DSMath {\n    uint32  constant public DELAY = 900; \n    uint128 constant public prem = 1100000000000000000; \n    uint128 constant public turn = 1010000000000000000; \n\n    MedianizerInterface med; \n\n    uint32 public expiry;\n    uint32 public timeout;\n    uint128 assetPrice;\n    uint128 public paymentTokenPrice;\n    uint256 rewardAmount;\n\n    mapping(bytes32 => AsyncRequest) asyncRequests;\n\n    \n    struct AsyncRequest {\n        address rewardee;\n        uint128 payment;\n        uint128 disbursement;\n        ERC20 token;\n        bool assetPriceSet;\n        bool paymentTokenPriceSet;\n    }\n\n    event SetAssetPrice(bytes32 queryId, uint128 assetPrice_, uint32 expiry_);\n\n    event SetPaymentTokenPrice(bytes32 queryId, uint128 paymentTokenPrice_);\n\n    event Reward(bytes32 queryId);\n\n    \n    function peek() public view returns (bytes32,bool) {\n        return (bytes32(uint(assetPrice)), now < expiry);\n    }\n\n    \n    function read() public view returns (bytes32) {\n        assert(now < expiry);\n        return bytes32(uint(assetPrice));\n    }\n\n    \n    function setAssetPrice(bytes32 queryId, uint128 assetPrice_, uint32 expiry_) internal {\n        asyncRequests[queryId].disbursement = 0;\n        if (assetPrice_ >= wmul(assetPrice, turn) || assetPrice_ <= wdiv(assetPrice, turn)) {\n            asyncRequests[queryId].disbursement = asyncRequests[queryId].payment;\n        }\n        assetPrice = assetPrice_;\n        expiry = expiry_;\n        med.poke();\n        asyncRequests[queryId].assetPriceSet = true;\n        if (asyncRequests[queryId].paymentTokenPriceSet) {reward(queryId);}\n\n        emit SetAssetPrice(queryId, assetPrice_, expiry_);\n    }\n\n    \n    function setPaymentTokenPrice(bytes32 queryId, uint128 paymentTokenPrice_) internal {\n        paymentTokenPrice = paymentTokenPrice_;\n        asyncRequests[queryId].paymentTokenPriceSet = true;\n        if (asyncRequests[queryId].assetPriceSet) {reward(queryId);}\n\n        emit SetPaymentTokenPrice(queryId, paymentTokenPrice_);\n    }\n\n    \n    function reward(bytes32 queryId) internal {\n        rewardAmount = wmul(wmul(paymentTokenPrice, asyncRequests[queryId].disbursement), prem);\n        if (asyncRequests[queryId].token.balanceOf(address(this)) >= rewardAmount && asyncRequests[queryId].disbursement > 0) {\n            require(asyncRequests[queryId].token.transfer(asyncRequests[queryId].rewardee, rewardAmount), \"Oracle.reward: token transfer failed\");\n        }\n        delete(asyncRequests[queryId]);\n\n        emit Reward(queryId);\n    }\n\n    \n    function setMaxReward(uint256 maxReward_) public;\n\n    \n    function setGasLimit(uint256 gasLimit_) public;\n}\n\ncontract Medianizer is DSMath {\n    bool    hasPrice;\n    bytes32 assetPrice;\n    uint256 public minOraclesRequired = 5;\n    bool on;\n    address deployer;\n\n    uint256 constant public MIN_ORACLIZE_GAS_LIMIT = 200000;\n    uint256 constant public MAX_ORACLIZE_GAS_LIMIT = 1000000;\n\n    Oracle[] public oracles;\n\n    event Fund(uint256 amount_, ERC20 token_);\n\n    event Poke(bytes32 assetPrice, bool hasPrice);\n\n    \n    constructor() public {\n    \tdeployer = msg.sender;\n    }\n\n    \n    \n    \n    \n    \n    \n\n    \n    function setOracles(address[10] addrs) public {\n        require(!on, \"Funds.setOracles: Oracles already set\");\n        require(msg.sender == deployer, \"Funds.setOracles: msg.sender isn't deployer\");\n        oracles.push(Oracle(addrs[0]));\n        oracles.push(Oracle(addrs[1]));\n        oracles.push(Oracle(addrs[2]));\n        oracles.push(Oracle(addrs[3]));\n        oracles.push(Oracle(addrs[4]));\n        oracles.push(Oracle(addrs[5]));\n        oracles.push(Oracle(addrs[6]));\n        oracles.push(Oracle(addrs[7]));\n        oracles.push(Oracle(addrs[8]));\n        oracles.push(Oracle(addrs[9]));\n    \ton = true;\n    }\n    \n\n    \n    \n    \n    \n    \n    \n\n    \n    function setMaxReward(uint256 maxReward_) public {\n        require(on, \"Funds.setMaxReward: Oracles not set\");\n        require(msg.sender == deployer, \"Funds.setMaxReward: msg.sender isn't deployer\");\n        oracles[0].setMaxReward(maxReward_);\n        oracles[1].setMaxReward(maxReward_);\n        oracles[2].setMaxReward(maxReward_);\n        oracles[3].setMaxReward(maxReward_);\n        oracles[4].setMaxReward(maxReward_);\n        oracles[5].setMaxReward(maxReward_);\n        oracles[6].setMaxReward(maxReward_);\n        oracles[7].setMaxReward(maxReward_);\n        oracles[8].setMaxReward(maxReward_);\n        oracles[9].setMaxReward(maxReward_);\n    }\n    \n\n    \n    \n    \n    \n    \n    \n\n    \n    function setGasLimit(uint256 gasLimit_) public {\n        require(on, \"Funds.setGasLimit: Oracles not set\");\n        require(msg.sender == deployer, \"Funds.setGasLimit: msg.sender isn't deployer\");\n        require(gasLimit_ >= MIN_ORACLIZE_GAS_LIMIT, \"Funds.setGasLimit: gasLimit_ cannot be less than min oraclize gas limit\");\n        require(gasLimit_ <= MAX_ORACLIZE_GAS_LIMIT, \"Funds.setGasLimit: gasLimit_ cannot be greater than max oraclize gas limit\");\n        oracles[0].setGasLimit(gasLimit_);\n        oracles[1].setGasLimit(gasLimit_);\n        oracles[2].setGasLimit(gasLimit_);\n        oracles[3].setGasLimit(gasLimit_);\n        oracles[4].setGasLimit(gasLimit_);\n        oracles[5].setGasLimit(gasLimit_);\n        oracles[6].setGasLimit(gasLimit_);\n        oracles[7].setGasLimit(gasLimit_);\n        oracles[8].setGasLimit(gasLimit_);\n        oracles[9].setGasLimit(gasLimit_);\n    }\n    \n\n    \n    function peek() public view returns (bytes32, bool) {\n        return (assetPrice,hasPrice);\n    }\n\n    \n    function read() public returns (bytes32) {\n        (assetPrice, hasPrice) = peek();\n        assert(hasPrice);\n        return assetPrice;\n    }\n\n    \n    function fund(uint256 amount_, ERC20 token_) public {\n        require(amount_ < 2**128-1, \"Medianizer.fund: amount is greater than max uint128\"); \n        for (uint256 i = 0; i < oracles.length; i++) {\n            require(\n                token_.transferFrom(msg.sender, address(oracles[i]), uint256(hdiv(uint128(amount_), uint128(oracles.length)))),\n                \"Medianizer.fund: failed to transfer tokens to oracles\"\n            );\n        }\n\n        emit Fund(amount_, token_);\n    }\n\n    \n    function poke() public {\n        poke(0);\n    }\n\n    \n    function poke(bytes32) public {\n        (assetPrice, hasPrice) = compute();\n\n        emit Poke(assetPrice, hasPrice);\n    }\n\n    \n    function compute() public view returns (bytes32, bool) {\n        bytes32 wut;\n        bool wuz;\n        bytes32[] memory wuts = new bytes32[](oracles.length);\n        uint256 ctr = 0;\n        for (uint256 i = 0; i < oracles.length; i++) {\n            if (address(oracles[i]) != 0) {\n                (wut, wuz) = oracles[i].peek();\n                if (wuz) {\n                    if (ctr == 0 || wut >= wuts[ctr - 1]) {\n                        wuts[ctr] = wut;\n                    } else {\n                        uint256 j = 0;\n                        while (wut >= wuts[j]) {\n                            j++;\n                        }\n                        for (uint256 k = ctr; k > j; k--) {\n                            wuts[k] = wuts[k - 1];\n                        }\n                        wuts[j] = wut;\n                    }\n                    ctr++;\n                }\n            }\n        }\n\n        if (ctr < minOraclesRequired) return (assetPrice, false);\n\n        bytes32 value;\n        if (ctr % 2 == 0) {\n            uint128 val1 = uint128(wuts[(ctr / 2) - 1]);\n            uint128 val2 = uint128(wuts[ctr / 2]);\n            value = bytes32((val1 + val2) / 2);\n        } else {\n            value = wuts[(ctr - 1) / 2];\n        }\n\n        return (value, true);\n    }\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"poke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"poke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"compute\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"maxReward_\",\"type\":\"uint256\"}],\"name\":\"setMaxReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"read\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"peek\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"oracles\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_ORACLIZE_GAS_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_ORACLIZE_GAS_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minOraclesRequired\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gasLimit_\",\"type\":\"uint256\"}],\"name\":\"setGasLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount_\",\"type\":\"uint256\"},{\"name\":\"token_\",\"type\":\"address\"}],\"name\":\"fund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[10]\"}],\"name\":\"setOracles\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount_\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token_\",\"type\":\"address\"}],\"name\":\"Fund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"assetPrice\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"hasPrice\",\"type\":\"bool\"}],\"name\":\"Poke\",\"type\":\"event\"}]","ContractName":"Medianizer","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":""}]}