{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\ncontract MinterRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event MinterAdded(address indexed account);\r\n    event MinterRemoved(address indexed account);\r\n\r\n    Roles.Role private _minters;\r\n\r\n    constructor () internal {\r\n        _addMinter(msg.sender);\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n        require(isMinter(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isMinter(address account) public view returns (bool) {\r\n        return _minters.has(account);\r\n    }\r\n\r\n    function addMinter(address account) public onlyMinter {\r\n        _addMinter(account);\r\n    }\r\n\r\n    function renounceMinter() public {\r\n        _removeMinter(msg.sender);\r\n    }\r\n\r\n    function _addMinter(address account) internal {\r\n        _minters.add(account);\r\n        emit MinterAdded(account);\r\n    }\r\n\r\n    function _removeMinter(address account) internal {\r\n        _minters.remove(account);\r\n        emit MinterRemoved(account);\r\n    }\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n/**\r\n * @title ERC1400 security token standard\r\n * @dev ERC1400 logic\r\n */\r\ninterface IERC1400  {\r\n\r\n    // Document Management\r\n    function getDocument(bytes32 name) external view returns (string memory, bytes32); // 1/9\r\n    function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external; // 2/9\r\n    event Document(bytes32 indexed name, string uri, bytes32 documentHash);\r\n\r\n    // Controller Operation\r\n    function isControllable() external view returns (bool); // 3/9\r\n\r\n    // Token Issuance\r\n    function isIssuable() external view returns (bool); // 4/9\r\n    function issueByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data) external; // 5/9\r\n    event IssuedByPartition(bytes32 indexed partition, address indexed operator, address indexed to, uint256 value, bytes data, bytes operatorData);\r\n\r\n    // Token Redemption\r\n    function redeemByPartition(bytes32 partition, uint256 value, bytes calldata data) external; // 6/9\r\n    function operatorRedeemByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data, bytes calldata operatorData) external; // 7/9\r\n    event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes data, bytes operatorData);\r\n\r\n    // // Transfer Validity\r\n    function canTransferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data) external view returns (byte, bytes32, bytes32); // 8/9\r\n    function canOperatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external view returns (byte, bytes32, bytes32); // 9/9\r\n\r\n}\r\n\r\n/**\r\n * Reason codes - ERC1066\r\n *\r\n * To improve the token holder experience, canTransfer MUST return a reason byte code\r\n * on success or failure based on the EIP-1066 application-specific status codes specified below.\r\n * An implementation can also return arbitrary data as a bytes32 to provide additional\r\n * information not captured by the reason code.\r\n *\r\n * Code\tReason\r\n * 0xA0\tTransfer Verified - Unrestricted\r\n * 0xA1\tTransfer Verified - On-Chain approval for restricted token\r\n * 0xA2\tTransfer Verified - Off-Chain approval for restricted token\r\n * 0xA3\tTransfer Blocked - Sender lockup period not ended\r\n * 0xA4\tTransfer Blocked - Sender balance insufficient\r\n * 0xA5\tTransfer Blocked - Sender not eligible\r\n * 0xA6\tTransfer Blocked - Receiver not eligible\r\n * 0xA7\tTransfer Blocked - Identity restriction\r\n * 0xA8\tTransfer Blocked - Token restriction\r\n * 0xA9\tTransfer Blocked - Token granularity\r\n */\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n/**\r\n * @title IERC1400Partition partially fungible token standard\r\n * @dev ERC1400Partition interface\r\n */\r\ninterface IERC1400Partition {\r\n\r\n    // Token Information\r\n    function balanceOfByPartition(bytes32 partition, address tokenHolder) external view returns (uint256); // 1/10\r\n    function partitionsOf(address tokenHolder) external view returns (bytes32[] memory); // 2/10\r\n\r\n    // Token Transfers\r\n    function transferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data) external returns (bytes32); // 3/10\r\n    function operatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external returns (bytes32); // 4/10\r\n\r\n    // Default Partition Management\r\n    function getDefaultPartitions() external view returns (bytes32[] memory); // 5/10\r\n    function setDefaultPartitions(bytes32[] calldata partitions) external; // 6/10\r\n\r\n    // Operators\r\n    function controllersByPartition(bytes32 partition) external view returns (address[] memory); // 7/10\r\n    function authorizeOperatorByPartition(bytes32 partition, address operator) external; // 8/10\r\n    function revokeOperatorByPartition(bytes32 partition, address operator) external; // 9/10\r\n    function isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) external view returns (bool); // 10/10\r\n\r\n    // Transfer Events\r\n    event TransferByPartition(\r\n        bytes32 indexed fromPartition,\r\n        address operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value,\r\n        bytes data,\r\n        bytes operatorData\r\n    );\r\n\r\n    event ChangedPartition(\r\n        bytes32 indexed fromPartition,\r\n        bytes32 indexed toPartition,\r\n        uint256 value\r\n    );\r\n\r\n    // Operator Events\r\n    event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n    event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n\r\n    // Allowance\r\n    event ApprovalByPartition(bytes32 indexed partition, address indexed owner, address indexed spender, uint256 value);\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract ERC1820Registry {\r\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\r\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address);\r\n    function setManager(address _addr, address _newManager) external;\r\n    function getManager(address _addr) public view returns (address);\r\n}\r\n\r\n\r\n/// Base client to interact with the registry.\r\ncontract ERC1820Client {\r\n    ERC1820Registry constant ERC1820REGISTRY = ERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\r\n    function setInterfaceImplementation(string memory _interfaceLabel, address _implementation) internal {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        ERC1820REGISTRY.setInterfaceImplementer(address(this), interfaceHash, _implementation);\r\n    }\r\n\r\n    function interfaceAddr(address addr, string memory _interfaceLabel) internal view returns(address) {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        return ERC1820REGISTRY.getInterfaceImplementer(addr, interfaceHash);\r\n    }\r\n\r\n    function delegateManagement(address _newManager) internal {\r\n        ERC1820REGISTRY.setManager(address(this), _newManager);\r\n    }\r\n}\r\n\r\ncontract ERC1820Implementer {\r\n  bytes32 constant ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));\r\n\r\n  mapping(bytes32 => bool) internal _interfaceHashes;\r\n\r\n  function canImplementInterfaceForAddress(bytes32 interfaceHash, address /*addr*/) // Comments to avoid compilation warnings for unused variables.\r\n    external\r\n    view\r\n    returns(bytes32)\r\n  {\r\n    if(_interfaceHashes[interfaceHash]) {\r\n      return ERC1820_ACCEPT_MAGIC;\r\n    } else {\r\n      return \"\";\r\n    }\r\n  }\r\n\r\n  function _setInterface(string memory interfaceLabel) internal {\r\n    _interfaceHashes[keccak256(abi.encodePacked(interfaceLabel))] = true;\r\n  }\r\n\r\n}\r\n\r\n// CertificateController comment...\r\ncontract CertificateController {\r\n\r\n  // If set to 'true', the certificate control is activated\r\n  bool _certificateControllerActivated;\r\n\r\n  // Address used by off-chain controller service to sign certificate\r\n  mapping(address => bool) internal _certificateSigners;\r\n\r\n  // A nonce used to ensure a certificate can be used only once\r\n  mapping(address => uint256) internal _checkCount;\r\n\r\n  event Checked(address sender);\r\n\r\n  constructor(address _certificateSigner, bool activated) public {\r\n    _setCertificateSigner(_certificateSigner, true);\r\n    _certificateControllerActivated = activated;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to protect methods with certificate control\r\n   */\r\n  modifier isValidCertificate(bytes memory data) {\r\n\r\n    if(_certificateControllerActivated) {\r\n      require(_certificateSigners[msg.sender] || _checkCertificate(data, 0, 0x00000000), \"A3\"); // Transfer Blocked - Sender lockup period not ended\r\n\r\n      _checkCount[msg.sender] += 1; // Increment sender check count\r\n\r\n      emit Checked(msg.sender);\r\n    }\r\n\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to protect methods with certificate control\r\n   */\r\n  /* modifier isValidPayableCertificate(bytes memory data) {\r\n\r\n    require(_certificateSigners[msg.sender] || _checkCertificate(data, msg.value, 0x00000000), \"A3\"); // Transfer Blocked - Sender lockup period not ended\r\n\r\n    _checkCount[msg.sender] += 1; // Increment sender check count\r\n\r\n    emit Checked(msg.sender);\r\n    _;\r\n  } */\r\n\r\n\r\n  /**\r\n   * @dev Get number of transations already sent to this contract by the sender\r\n   * @param sender Address whom to check the counter of.\r\n   * @return uint256 Number of transaction already sent to this contract.\r\n   */\r\n  function checkCount(address sender) external view returns (uint256) {\r\n    return _checkCount[sender];\r\n  }\r\n\r\n  /**\r\n   * @dev Get certificate signer authorization for an operator.\r\n   * @param operator Address whom to check the certificate signer authorization for.\r\n   * @return bool 'true' if operator is authorized as certificate signer, 'false' if not.\r\n   */\r\n  function certificateSigners(address operator) external view returns (bool) {\r\n    return _certificateSigners[operator];\r\n  }\r\n\r\n  /**\r\n   * @dev Set signer authorization for operator.\r\n   * @param operator Address to add/remove as a certificate signer.\r\n   * @param authorized 'true' if operator shall be accepted as certificate signer, 'false' if not.\r\n   */\r\n  function _setCertificateSigner(address operator, bool authorized) internal {\r\n    require(operator != address(0)); // Action Blocked - Not a valid address\r\n    _certificateSigners[operator] = authorized;\r\n  }\r\n\r\n  /**\r\n   * @dev Get activation status of certificate controller.\r\n   */\r\n  function certificateControllerActivated() external view returns (bool) {\r\n    return _certificateControllerActivated;\r\n  }\r\n\r\n  /**\r\n   * @dev Activate/disactivate certificate controller.\r\n   * @param activated 'true', if the certificate control shall be activated, 'false' if not.\r\n   */\r\n  function _setCertificateControllerActivated(bool activated) internal {\r\n    _certificateControllerActivated = activated;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if a certificate is correct\r\n   * @param data Certificate to control\r\n   */\r\n  function _checkCertificate(\r\n    bytes memory data,\r\n    uint256 amount,\r\n    bytes4 functionID\r\n  )\r\n    internal\r\n    view\r\n    returns(bool)\r\n  {\r\n    uint256 counter = _checkCount[msg.sender];\r\n\r\n    uint256 e;\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    // Certificate should be 97 bytes long\r\n    if (data.length != 97) {\r\n      return false;\r\n    }\r\n\r\n    // Extract certificate information and expiration time from payload\r\n    assembly {\r\n      // Retrieve expirationTime & ECDSA elements from certificate which is a 97 long bytes\r\n      // Certificate encoding format is: <expirationTime (32 bytes)>@<r (32 bytes)>@<s (32 bytes)>@<v (1 byte)>\r\n      e := mload(add(data, 0x20))\r\n      r := mload(add(data, 0x40))\r\n      s := mload(add(data, 0x60))\r\n      v := byte(0, mload(add(data, 0x80)))\r\n    }\r\n\r\n    // Certificate should not be expired\r\n    if (e < now) {\r\n      return false;\r\n    }\r\n\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // Perform ecrecover to ensure message information corresponds to certificate\r\n    if (v == 27 || v == 28) {\r\n      // Extract payload and remove data argument\r\n      bytes memory payload;\r\n\r\n      assembly {\r\n        let payloadsize := sub(calldatasize, 160)\r\n        payload := mload(0x40) // allocate new memory\r\n        mstore(0x40, add(payload, and(add(add(payloadsize, 0x20), 0x1f), not(0x1f)))) // boolean trick for padding to 0x40\r\n        mstore(payload, payloadsize) // set length\r\n        calldatacopy(add(add(payload, 0x20), 4), 4, sub(payloadsize, 4))\r\n      }\r\n\r\n      if(functionID == 0x00000000) {\r\n        assembly {\r\n          calldatacopy(add(payload, 0x20), 0, 4)\r\n        }\r\n      } else {\r\n        for (uint i = 0; i < 4; i++) { // replace 4 bytes corresponding to function selector\r\n          payload[i] = functionID[i];\r\n        }\r\n      }\r\n\r\n      // Pack and hash\r\n      bytes memory pack = abi.encodePacked(\r\n        msg.sender,\r\n        this,\r\n        amount,\r\n        payload,\r\n        e,\r\n        counter\r\n      );\r\n      bytes32 hash = keccak256(pack);\r\n\r\n      // Check if certificate match expected transactions parameters\r\n      if (_certificateSigners[ecrecover(hash, v, r, s)]) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n/**\r\n * @title IERC1400Raw token standard\r\n * @dev ERC1400Raw interface\r\n */\r\ninterface IERC1400Raw {\r\n\r\n  function name() external view returns (string memory); // 1/13\r\n  function symbol() external view returns (string memory); // 2/13\r\n  function totalSupply() external view returns (uint256); // 3/13\r\n  function balanceOf(address owner) external view returns (uint256); // 4/13\r\n  function granularity() external view returns (uint256); // 5/13\r\n\r\n  function controllers() external view returns (address[] memory); // 6/13\r\n  function authorizeOperator(address operator) external; // 7/13\r\n  function revokeOperator(address operator) external; // 8/13\r\n  function isOperator(address operator, address tokenHolder) external view returns (bool); // 9/13\r\n\r\n  function transferWithData(address to, uint256 value, bytes calldata data) external; // 10/13\r\n  function transferFromWithData(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external; // 11/13\r\n\r\n  function redeem(uint256 value, bytes calldata data) external; // 12/13\r\n  function redeemFrom(address from, uint256 value, bytes calldata data, bytes calldata operatorData) external; // 13/13\r\n\r\n  event TransferWithData(\r\n    address indexed operator,\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value,\r\n    bytes data,\r\n    bytes operatorData\r\n  );\r\n  event Issued(address indexed operator, address indexed to, uint256 value, bytes data, bytes operatorData);\r\n  event Redeemed(address indexed operator, address indexed from, uint256 value, bytes data, bytes operatorData);\r\n  event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n  event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n/**\r\n * @title IERC1400TokensSender\r\n * @dev ERC1400TokensSender interface\r\n */\r\ninterface IERC1400TokensSender {\r\n\r\n  function canTransfer(\r\n    bytes4 functionSig,\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) external view returns(bool);\r\n\r\n  function tokensToTransfer(\r\n    bytes4 functionSig,\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) external;\r\n\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n/**\r\n * @title IERC1400TokensValidator\r\n * @dev ERC1400TokensValidator interface\r\n */\r\ninterface IERC1400TokensValidator {\r\n\r\n  function canValidate(\r\n    bytes4 functionSig,\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) external view returns(bool);\r\n\r\n  function tokensToValidate(\r\n    bytes4 functionSig,\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) external;\r\n\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n/**\r\n * @title IERC1400TokensRecipient\r\n * @dev ERC1400TokensRecipient interface\r\n */\r\ninterface IERC1400TokensRecipient {\r\n\r\n  function canReceive(\r\n    bytes4 functionSig,\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) external view returns(bool);\r\n\r\n  function tokensReceived(\r\n    bytes4 functionSig,\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) external;\r\n\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC1400Raw\r\n * @dev ERC1400Raw logic\r\n */\r\ncontract ERC1400Raw is IERC1400Raw, Ownable, ERC1820Client, ERC1820Implementer, CertificateController {\r\n  using SafeMath for uint256;\r\n\r\n  string constant internal ERC1400_TOKENS_SENDER = \"ERC1400TokensSender\";\r\n  string constant internal ERC1400_TOKENS_VALIDATOR = \"ERC1400TokensValidator\";\r\n  string constant internal ERC1400_TOKENS_RECIPIENT = \"ERC1400TokensRecipient\";\r\n\r\n  string internal _name;\r\n  string internal _symbol;\r\n  uint256 internal _granularity;\r\n  uint256 internal _totalSupply;\r\n\r\n  bool internal _migrated;\r\n\r\n  // Indicate whether the token can still be controlled by operators or not anymore.\r\n  bool internal _isControllable;\r\n\r\n  // Mapping from tokenHolder to balance.\r\n  mapping(address => uint256) internal _balances;\r\n\r\n  /******************** Mappings related to operator **************************/\r\n  // Mapping from (operator, tokenHolder) to authorized status. [TOKEN-HOLDER-SPECIFIC]\r\n  mapping(address => mapping(address => bool)) internal _authorizedOperator;\r\n\r\n  // Array of controllers. [GLOBAL - NOT TOKEN-HOLDER-SPECIFIC]\r\n  address[] internal _controllers;\r\n\r\n  // Mapping from operator to controller status. [GLOBAL - NOT TOKEN-HOLDER-SPECIFIC]\r\n  mapping(address => bool) internal _isController;\r\n  /****************************************************************************/\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not migrated.\r\n   */\r\n  modifier whenNotMigrated() {\r\n      require(!_migrated, \"A8\");\r\n      _;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw CONSTRUCTOR]\r\n   * @dev Initialize ERC1400Raw and CertificateController parameters + register\r\n   * the contract implementation in ERC1820Registry.\r\n   * @param name Name of the token.\r\n   * @param symbol Symbol of the token.\r\n   * @param granularity Granularity of the token.\r\n   * @param controllers Array of initial controllers.\r\n   * @param certificateSigner Address of the off-chain service which signs the\r\n   * conditional ownership certificates required for token transfers, issuance,\r\n   * redemption (Cf. CertificateController.sol).\r\n   * @param certificateActivated If set to 'true', the certificate controller\r\n   * is activated at contract creation.\r\n   */\r\n  constructor(\r\n    string memory name,\r\n    string memory symbol,\r\n    uint256 granularity,\r\n    address[] memory controllers,\r\n    address certificateSigner,\r\n    bool certificateActivated\r\n  )\r\n    public\r\n    CertificateController(certificateSigner, certificateActivated)\r\n  {\r\n    _name = name;\r\n    _symbol = symbol;\r\n    _totalSupply = 0;\r\n    require(granularity >= 1); // Constructor Blocked - Token granularity can not be lower than 1\r\n    _granularity = granularity;\r\n\r\n    _setControllers(controllers);\r\n  }\r\n\r\n  /********************** ERC1400Raw EXTERNAL FUNCTIONS ***************************/\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (1/13)]\r\n   * @dev Get the name of the token, e.g., \"MyToken\".\r\n   * @return Name of the token.\r\n   */\r\n  function name() external view returns(string memory) {\r\n    return _name;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (2/13)]\r\n   * @dev Get the symbol of the token, e.g., \"MYT\".\r\n   * @return Symbol of the token.\r\n   */\r\n  function symbol() external view returns(string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (3/13)]\r\n   * @dev Get the total number of issued tokens.\r\n   * @return Total supply of tokens currently in circulation.\r\n   */\r\n  function totalSupply() external view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (4/13)]\r\n   * @dev Get the balance of the account with address 'tokenHolder'.\r\n   * @param tokenHolder Address for which the balance is returned.\r\n   * @return Amount of token held by 'tokenHolder' in the token contract.\r\n   */\r\n  function balanceOf(address tokenHolder) external view returns (uint256) {\r\n    return _balances[tokenHolder];\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (5/13)]\r\n   * @dev Get the smallest part of the token that’s not divisible.\r\n   * @return The smallest non-divisible part of the token.\r\n   */\r\n  function granularity() external view returns(uint256) {\r\n    return _granularity;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (6/13)]\r\n   * @dev Get the list of controllers as defined by the token contract.\r\n   * @return List of addresses of all the controllers.\r\n   */\r\n  function controllers() external view returns (address[] memory) {\r\n    return _controllers;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (7/13)]\r\n   * @dev Set a third party operator address as an operator of 'msg.sender' to transfer\r\n   * and redeem tokens on its behalf.\r\n   * @param operator Address to set as an operator for 'msg.sender'.\r\n   */\r\n  function authorizeOperator(address operator) external {\r\n    require(operator != msg.sender);\r\n    _authorizedOperator[operator][msg.sender] = true;\r\n    emit AuthorizedOperator(operator, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (8/13)]\r\n   * @dev Remove the right of the operator address to be an operator for 'msg.sender'\r\n   * and to transfer and redeem tokens on its behalf.\r\n   * @param operator Address to rescind as an operator for 'msg.sender'.\r\n   */\r\n  function revokeOperator(address operator) external {\r\n    require(operator != msg.sender);\r\n    _authorizedOperator[operator][msg.sender] = false;\r\n    emit RevokedOperator(operator, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (9/13)]\r\n   * @dev Indicate whether the operator address is an operator of the tokenHolder address.\r\n   * @param operator Address which may be an operator of tokenHolder.\r\n   * @param tokenHolder Address of a token holder which may have the operator address as an operator.\r\n   * @return 'true' if operator is an operator of 'tokenHolder' and 'false' otherwise.\r\n   */\r\n  function isOperator(address operator, address tokenHolder) external view returns (bool) {\r\n    return _isOperator(operator, tokenHolder);\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (10/13)]\r\n   * @dev Transfer the amount of tokens from the address 'msg.sender' to the address 'to'.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, by the token holder. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function transferWithData(address to, uint256 value, bytes calldata data)\r\n    external\r\n    isValidCertificate(data)\r\n  {\r\n    _callPreTransferHooks(\"\", msg.sender, msg.sender, to, value, data, \"\");\r\n\r\n    _transferWithData(msg.sender, msg.sender, to, value, data, \"\");\r\n\r\n    _callPostTransferHooks(\"\", msg.sender, msg.sender, to, value, data, \"\");\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (11/13)]\r\n   * @dev Transfer the amount of tokens on behalf of the address 'from' to the address 'to'.\r\n   * @param from Token holder (or 'address(0)' to set from to 'msg.sender').\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, and intended for the token holder ('from').\r\n   * @param operatorData Information attached to the transfer by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function transferFromWithData(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData)\r\n    external\r\n    isValidCertificate(operatorData)\r\n  {\r\n    require(_isOperator(msg.sender, from), \"A7\"); // Transfer Blocked - Identity restriction\r\n\r\n    _callPreTransferHooks(\"\", msg.sender, from, to, value, data, operatorData);\r\n\r\n    _transferWithData(msg.sender, from, to, value, data, operatorData);\r\n\r\n    _callPostTransferHooks(\"\", msg.sender, from, to, value, data, operatorData);\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (12/13)]\r\n   * @dev Redeem the amount of tokens from the address 'msg.sender'.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption, by the token holder. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function redeem(uint256 value, bytes calldata data)\r\n    external\r\n    isValidCertificate(data)\r\n  {\r\n    _callPreTransferHooks(\"\", msg.sender, msg.sender, address(0), value, data, \"\");\r\n\r\n    _redeem(msg.sender, msg.sender, value, data, \"\");\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (13/13)]\r\n   * @dev Redeem the amount of tokens on behalf of the address from.\r\n   * @param from Token holder whose tokens will be redeemed (or address(0) to set from to msg.sender).\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption, by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function redeemFrom(address from, uint256 value, bytes calldata data, bytes calldata operatorData)\r\n    external\r\n    isValidCertificate(operatorData)\r\n  {\r\n    require(_isOperator(msg.sender, from), \"A7\"); // Transfer Blocked - Identity restriction\r\n\r\n    _callPreTransferHooks(\"\", msg.sender, from, address(0), value, data, operatorData);\r\n\r\n    _redeem(msg.sender, from, value, data, operatorData);\r\n  }\r\n\r\n  /********************** ERC1400Raw INTERNAL FUNCTIONS ***************************/\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Check if 'value' is multiple of the granularity.\r\n   * @param value The quantity that want's to be checked.\r\n   * @return 'true' if 'value' is a multiple of the granularity.\r\n   */\r\n  function _isMultiple(uint256 value) internal view returns(bool) {\r\n    return(value.div(_granularity).mul(_granularity) == value);\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Indicate whether the operator address is an operator of the tokenHolder address.\r\n   * @param operator Address which may be an operator of 'tokenHolder'.\r\n   * @param tokenHolder Address of a token holder which may have the 'operator' address as an operator.\r\n   * @return 'true' if 'operator' is an operator of 'tokenHolder' and 'false' otherwise.\r\n   */\r\n  function _isOperator(address operator, address tokenHolder) internal view returns (bool) {\r\n    return (operator == tokenHolder\r\n      || _authorizedOperator[operator][tokenHolder]\r\n      || (_isControllable && _isController[operator])\r\n    );\r\n  }\r\n\r\n   /**\r\n    * [INTERNAL]\r\n    * @dev Perform the transfer of tokens.\r\n    * @param operator The address performing the transfer.\r\n    * @param from Token holder.\r\n    * @param to Token recipient.\r\n    * @param value Number of tokens to transfer.\r\n    * @param data Information attached to the transfer.\r\n    * @param operatorData Information attached to the transfer by the operator (if any)..\r\n    */\r\n  function _transferWithData(\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n    whenNotMigrated\r\n  {\r\n    require(_isMultiple(value), \"A9\"); // Transfer Blocked - Token granularity\r\n    require(to != address(0), \"A6\"); // Transfer Blocked - Receiver not eligible\r\n    require(_balances[from] >= value, \"A4\"); // Transfer Blocked - Sender balance insufficient\r\n  \r\n    _balances[from] = _balances[from].sub(value);\r\n    _balances[to] = _balances[to].add(value);\r\n\r\n    emit TransferWithData(operator, from, to, value, data, operatorData);\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Perform the token redemption.\r\n   * @param operator The address performing the redemption.\r\n   * @param from Token holder whose tokens will be redeemed.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption, by the operator (if any).\r\n   */\r\n  function _redeem(address operator, address from, uint256 value, bytes memory data, bytes memory operatorData)\r\n    internal\r\n    whenNotMigrated\r\n  {\r\n    require(_isMultiple(value), \"A9\"); // Transfer Blocked - Token granularity\r\n    require(from != address(0), \"A5\"); // Transfer Blocked - Sender not eligible\r\n    require(_balances[from] >= value, \"A4\"); // Transfer Blocked - Sender balance insufficient\r\n\r\n    _balances[from] = _balances[from].sub(value);\r\n    _totalSupply = _totalSupply.sub(value);\r\n\r\n    emit Redeemed(operator, from, value, data, operatorData);\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Check for 'ERC1400TokensSender' hook on the sender + check for 'ERC1400TokensValidator' on the token\r\n   * contract address and call them.\r\n   * @param partition Name of the partition (bytes32 to be left empty for ERC1400Raw transfer).\r\n   * @param operator Address which triggered the balance decrease (through transfer or redemption).\r\n   * @param from Token holder.\r\n   * @param to Token recipient for a transfer and 0x for a redemption.\r\n   * @param value Number of tokens the token holder balance is decreased by.\r\n   * @param data Extra information.\r\n   * @param operatorData Extra information, attached by the operator (if any).\r\n   */\r\n  function _callPreTransferHooks(\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n  {\r\n    address senderImplementation;\r\n    senderImplementation = interfaceAddr(from, ERC1400_TOKENS_SENDER);\r\n    if (senderImplementation != address(0)) {\r\n      IERC1400TokensSender(senderImplementation).tokensToTransfer(msg.sig, partition, operator, from, to, value, data, operatorData);\r\n    }\r\n\r\n    address validatorImplementation;\r\n    validatorImplementation = interfaceAddr(address(this), ERC1400_TOKENS_VALIDATOR);\r\n    if (validatorImplementation != address(0)) {\r\n      IERC1400TokensValidator(validatorImplementation).tokensToValidate(msg.sig, partition, operator, from, to, value, data, operatorData);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Check for 'ERC1400TokensRecipient' hook on the recipient and call it.\r\n   * @param partition Name of the partition (bytes32 to be left empty for ERC1400Raw transfer).\r\n   * @param operator Address which triggered the balance increase (through transfer or issuance).\r\n   * @param from Token holder for a transfer and 0x for an issuance.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens the recipient balance is increased by.\r\n   * @param data Extra information, intended for the token holder ('from').\r\n   * @param operatorData Extra information attached by the operator (if any).\r\n   */\r\n  function _callPostTransferHooks(\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n  {\r\n    address recipientImplementation;\r\n    recipientImplementation = interfaceAddr(to, ERC1400_TOKENS_RECIPIENT);\r\n\r\n    if (recipientImplementation != address(0)) {\r\n      IERC1400TokensRecipient(recipientImplementation).tokensReceived(msg.sig, partition, operator, from, to, value, data, operatorData);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Perform the issuance of tokens.\r\n   * @param operator Address which triggered the issuance.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens issued.\r\n   * @param data Information attached to the issuance, and intended for the recipient (to).\r\n   * @param operatorData Information attached to the issuance by the operator (if any).\r\n   */\r\n  function _issue(address operator, address to, uint256 value, bytes memory data, bytes memory operatorData)\r\n    internal\r\n    whenNotMigrated  \r\n  {\r\n    require(_isMultiple(value), \"A9\"); // Transfer Blocked - Token granularity\r\n    require(to != address(0), \"A6\"); // Transfer Blocked - Receiver not eligible\r\n\r\n    _totalSupply = _totalSupply.add(value);\r\n    _balances[to] = _balances[to].add(value);\r\n\r\n    emit Issued(operator, to, value, data, operatorData);\r\n  }\r\n\r\n  /********************** ERC1400Raw OPTIONAL FUNCTIONS ***************************/\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400Raw STANDARD]\r\n   * @dev Set validator contract address.\r\n   * The validator contract needs to verify \"ERC1400TokensValidator\" interface.\r\n   * Once setup, the validator will be called everytime a transfer is executed.\r\n   * @param validatorAddress Address of the validator contract.\r\n   * @param interfaceLabel Interface label of hook contract.\r\n   */\r\n  function _setHookContract(address validatorAddress, string memory interfaceLabel) internal {\r\n    ERC1820Client.setInterfaceImplementation(interfaceLabel, validatorAddress);\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400Raw STANDARD]\r\n   * @dev Set list of token controllers.\r\n   * @param operators Controller addresses.\r\n   */\r\n  function _setControllers(address[] memory operators) internal {\r\n    for (uint i = 0; i<_controllers.length; i++){\r\n      _isController[_controllers[i]] = false;\r\n    }\r\n    for (uint j = 0; j<operators.length; j++){\r\n      _isController[operators[j]] = true;\r\n    }\r\n    _controllers = operators;\r\n  }\r\n\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC1400Partition\r\n * @dev ERC1400Partition logic\r\n */\r\ncontract ERC1400Partition is IERC1400Partition, ERC1400Raw {\r\n\r\n  /******************** Mappings to find partition ******************************/\r\n  // List of partitions.\r\n  bytes32[] internal _totalPartitions;\r\n\r\n  // Mapping from partition to their index.\r\n  mapping (bytes32 => uint256) internal _indexOfTotalPartitions;\r\n\r\n  // Mapping from partition to global balance of corresponding partition.\r\n  mapping (bytes32 => uint256) internal _totalSupplyByPartition;\r\n\r\n  // Mapping from tokenHolder to their partitions.\r\n  mapping (address => bytes32[]) internal _partitionsOf;\r\n\r\n  // Mapping from (tokenHolder, partition) to their index.\r\n  mapping (address => mapping (bytes32 => uint256)) internal _indexOfPartitionsOf;\r\n\r\n  // Mapping from (tokenHolder, partition) to balance of corresponding partition.\r\n  mapping (address => mapping (bytes32 => uint256)) internal _balanceOfByPartition;\r\n\r\n  // List of token default partitions (for ERC20 compatibility).\r\n  bytes32[] internal _defaultPartitions;\r\n  /****************************************************************************/\r\n\r\n  /**************** Mappings to find partition operators ************************/\r\n  // Mapping from (partition, tokenHolder, spender) to allowed value. [TOKEN-HOLDER-SPECIFIC]\r\n  mapping(bytes32 => mapping (address => mapping (address => uint256))) internal _allowedByPartition;\r\n\r\n  // Mapping from (tokenHolder, partition, operator) to 'approved for partition' status. [TOKEN-HOLDER-SPECIFIC]\r\n  mapping (address => mapping (bytes32 => mapping (address => bool))) internal _authorizedOperatorByPartition;\r\n\r\n  // Mapping from partition to controllers for the partition. [NOT TOKEN-HOLDER-SPECIFIC]\r\n  mapping (bytes32 => address[]) internal _controllersByPartition;\r\n\r\n  // Mapping from (partition, operator) to PartitionController status. [NOT TOKEN-HOLDER-SPECIFIC]\r\n  mapping (bytes32 => mapping (address => bool)) internal _isControllerByPartition;\r\n  /****************************************************************************/\r\n\r\n  /**\r\n   * [ERC1400Partition CONSTRUCTOR]\r\n   * @dev Initialize ERC1400Partition parameters + register\r\n   * the contract implementation in ERC1820Registry.\r\n   * @param name Name of the token.\r\n   * @param symbol Symbol of the token.\r\n   * @param granularity Granularity of the token.\r\n   * @param controllers Array of initial controllers.\r\n   * @param certificateSigner Address of the off-chain service which signs the\r\n   * conditional ownership certificates required for token transfers, issuance,\r\n   * redemption (Cf. CertificateController.sol).\r\n   * @param certificateActivated If set to 'true', the certificate controller\r\n   * is activated at contract creation.\r\n   * @param defaultPartitions Partitions chosen by default, when partition is\r\n   * not specified, like the case ERC20 tranfers.\r\n   */\r\n  constructor(\r\n    string memory name,\r\n    string memory symbol,\r\n    uint256 granularity,\r\n    address[] memory controllers,\r\n    address certificateSigner,\r\n    bool certificateActivated,\r\n    bytes32[] memory defaultPartitions\r\n  )\r\n    public\r\n    ERC1400Raw(name, symbol, granularity, controllers, certificateSigner, certificateActivated)\r\n  {\r\n    _defaultPartitions = defaultPartitions;\r\n  }\r\n\r\n  /********************** ERC1400Partition EXTERNAL FUNCTIONS **************************/\r\n\r\n  /**\r\n   * [ERC1400Partition INTERFACE (1/10)]\r\n   * @dev Get balance of a tokenholder for a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param tokenHolder Address for which the balance is returned.\r\n   * @return Amount of token of partition 'partition' held by 'tokenHolder' in the token contract.\r\n   */\r\n  function balanceOfByPartition(bytes32 partition, address tokenHolder) external view returns (uint256) {\r\n    return _balanceOfByPartition[tokenHolder][partition];\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Partition INTERFACE (2/10)]\r\n   * @dev Get partitions index of a tokenholder.\r\n   * @param tokenHolder Address for which the partitions index are returned.\r\n   * @return Array of partitions index of 'tokenHolder'.\r\n   */\r\n  function partitionsOf(address tokenHolder) external view returns (bytes32[] memory) {\r\n    return _partitionsOf[tokenHolder];\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Partition INTERFACE (3/10)]\r\n   * @dev Transfer tokens from a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, by the token holder. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   * @return Destination partition.\r\n   */\r\n  function transferByPartition(\r\n    bytes32 partition,\r\n    address to,\r\n    uint256 value,\r\n    bytes calldata data\r\n  )\r\n    external\r\n    isValidCertificate(data)\r\n    returns (bytes32)\r\n  {\r\n    return _transferByPartition(partition, msg.sender, msg.sender, to, value, data, \"\");\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Partition INTERFACE (4/10)]\r\n   * @dev Transfer tokens from a specific partition through an operator.\r\n   * @param partition Name of the partition.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer, by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   * @return Destination partition.\r\n   */\r\n  function operatorTransferByPartition(\r\n    bytes32 partition,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  )\r\n    external\r\n    isValidCertificate(operatorData)\r\n    returns (bytes32)\r\n  {\r\n    require(_isOperatorForPartition(partition, msg.sender, from)\r\n      || (value <= _allowedByPartition[partition][from][msg.sender]), \"A7\"); // Transfer Blocked - Identity restriction\r\n\r\n    if(_allowedByPartition[partition][from][msg.sender] >= value) {\r\n      _allowedByPartition[partition][from][msg.sender] = _allowedByPartition[partition][from][msg.sender].sub(value);\r\n    } else {\r\n      _allowedByPartition[partition][from][msg.sender] = 0;\r\n    }\r\n\r\n    return _transferByPartition(partition, msg.sender, from, to, value, data, operatorData);\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Partition INTERFACE (5/10)]\r\n   * @dev Get default partitions to transfer from.\r\n   * Function used for ERC1400Raw and ERC20 backwards compatibility.\r\n   * For example, a security token may return the bytes32(\"unrestricted\").\r\n   * @return Array of default partitions.\r\n   */\r\n  function getDefaultPartitions() external view returns (bytes32[] memory) {\r\n    return _defaultPartitions;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Partition INTERFACE (6/10)]\r\n   * @dev Set default partitions to transfer from.\r\n   * Function used for ERC1400Raw and ERC20 backwards compatibility.\r\n   * @param partitions partitions to use by default when not specified.\r\n   */\r\n  function setDefaultPartitions(bytes32[] calldata partitions) external onlyOwner {\r\n    _defaultPartitions = partitions;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Partition INTERFACE (7/10)]\r\n   * @dev Get controllers for a given partition.\r\n   * Function used for ERC1400Raw and ERC20 backwards compatibility.\r\n   * @param partition Name of the partition.\r\n   * @return Array of controllers for partition.\r\n   */\r\n  function controllersByPartition(bytes32 partition) external view returns (address[] memory) {\r\n    return _controllersByPartition[partition];\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Partition INTERFACE (8/10)]\r\n   * @dev Set 'operator' as an operator for 'msg.sender' for a given partition.\r\n   * @param partition Name of the partition.\r\n   * @param operator Address to set as an operator for 'msg.sender'.\r\n   */\r\n  function authorizeOperatorByPartition(bytes32 partition, address operator) external {\r\n    _authorizedOperatorByPartition[msg.sender][partition][operator] = true;\r\n    emit AuthorizedOperatorByPartition(partition, operator, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Partition INTERFACE (9/10)]\r\n   * @dev Remove the right of the operator address to be an operator on a given\r\n   * partition for 'msg.sender' and to transfer and redeem tokens on its behalf.\r\n   * @param partition Name of the partition.\r\n   * @param operator Address to rescind as an operator on given partition for 'msg.sender'.\r\n   */\r\n  function revokeOperatorByPartition(bytes32 partition, address operator) external {\r\n    _authorizedOperatorByPartition[msg.sender][partition][operator] = false;\r\n    emit RevokedOperatorByPartition(partition, operator, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Partition INTERFACE (10/10)]\r\n   * @dev Indicate whether the operator address is an operator of the tokenHolder\r\n   * address for the given partition.\r\n   * @param partition Name of the partition.\r\n   * @param operator Address which may be an operator of tokenHolder for the given partition.\r\n   * @param tokenHolder Address of a token holder which may have the operator address as an operator for the given partition.\r\n   * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition 'partition' and 'false' otherwise.\r\n   */\r\n  function isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) external view returns (bool) {\r\n    return _isOperatorForPartition(partition, operator, tokenHolder);\r\n  }\r\n\r\n  /********************** ERC1400Partition INTERNAL FUNCTIONS **************************/\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Indicate whether the operator address is an operator of the tokenHolder\r\n   * address for the given partition.\r\n   * @param partition Name of the partition.\r\n   * @param operator Address which may be an operator of tokenHolder for the given partition.\r\n   * @param tokenHolder Address of a token holder which may have the operator address as an operator for the given partition.\r\n   * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition 'partition' and 'false' otherwise.\r\n   */\r\n   function _isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) internal view returns (bool) {\r\n     return (_isOperator(operator, tokenHolder)\r\n       || _authorizedOperatorByPartition[tokenHolder][partition][operator]\r\n       || (_isControllable && _isControllerByPartition[partition][operator])\r\n     );\r\n   }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Transfer tokens from a specific partition.\r\n   * @param fromPartition Partition of the tokens to transfer.\r\n   * @param operator The address performing the transfer.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer, by the operator (if any).\r\n   * @return Destination partition.\r\n   */\r\n  function _transferByPartition(\r\n    bytes32 fromPartition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n    returns (bytes32)\r\n  {\r\n    require(_balanceOfByPartition[from][fromPartition] >= value, \"A4\"); // Transfer Blocked - Sender balance insufficient\r\n\r\n    bytes32 toPartition = fromPartition;\r\n\r\n    if(operatorData.length != 0 && data.length >= 64) {\r\n      toPartition = _getDestinationPartition(fromPartition, data);\r\n    }\r\n\r\n    _callPreTransferHooks(fromPartition, operator, from, to, value, data, operatorData);\r\n\r\n    _removeTokenFromPartition(from, fromPartition, value);\r\n    _transferWithData(operator, from, to, value, data, operatorData);\r\n    _addTokenToPartition(to, toPartition, value);\r\n\r\n    _callPostTransferHooks(toPartition, operator, from, to, value, data, operatorData);\r\n\r\n    emit TransferByPartition(fromPartition, operator, from, to, value, data, operatorData);\r\n\r\n    if(toPartition != fromPartition) {\r\n      emit ChangedPartition(fromPartition, toPartition, value);\r\n    }\r\n\r\n    return toPartition;\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Remove a token from a specific partition.\r\n   * @param from Token holder.\r\n   * @param partition Name of the partition.\r\n   * @param value Number of tokens to transfer.\r\n   */\r\n  function _removeTokenFromPartition(address from, bytes32 partition, uint256 value) internal {\r\n    _balanceOfByPartition[from][partition] = _balanceOfByPartition[from][partition].sub(value);\r\n    _totalSupplyByPartition[partition] = _totalSupplyByPartition[partition].sub(value);\r\n\r\n    // If the total supply is zero, finds and deletes the partition.\r\n    if(_totalSupplyByPartition[partition] == 0) {\r\n      uint256 index1 = _indexOfTotalPartitions[partition];\r\n      require(index1 > 0, \"A8\"); // Transfer Blocked - Token restriction\r\n\r\n      // move the last item into the index being vacated\r\n      bytes32 lastValue = _totalPartitions[_totalPartitions.length - 1];\r\n      _totalPartitions[index1 - 1] = lastValue; // adjust for 1-based indexing\r\n      _indexOfTotalPartitions[lastValue] = index1;\r\n\r\n      _totalPartitions.length -= 1;\r\n      _indexOfTotalPartitions[partition] = 0;\r\n    }\r\n\r\n    // If the balance of the TokenHolder's partition is zero, finds and deletes the partition.\r\n    if(_balanceOfByPartition[from][partition] == 0) {\r\n      uint256 index2 = _indexOfPartitionsOf[from][partition];\r\n      require(index2 > 0, \"A8\"); // Transfer Blocked - Token restriction\r\n\r\n      // move the last item into the index being vacated\r\n      bytes32 lastValue = _partitionsOf[from][_partitionsOf[from].length - 1];\r\n      _partitionsOf[from][index2 - 1] = lastValue;  // adjust for 1-based indexing\r\n      _indexOfPartitionsOf[from][lastValue] = index2;\r\n\r\n      _partitionsOf[from].length -= 1;\r\n      _indexOfPartitionsOf[from][partition] = 0;\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Add a token to a specific partition.\r\n   * @param to Token recipient.\r\n   * @param partition Name of the partition.\r\n   * @param value Number of tokens to transfer.\r\n   */\r\n  function _addTokenToPartition(address to, bytes32 partition, uint256 value) internal {\r\n    if(value != 0) {\r\n      if (_indexOfPartitionsOf[to][partition] == 0) {\r\n        _partitionsOf[to].push(partition);\r\n        _indexOfPartitionsOf[to][partition] = _partitionsOf[to].length;\r\n      }\r\n      _balanceOfByPartition[to][partition] = _balanceOfByPartition[to][partition].add(value);\r\n\r\n      if (_indexOfTotalPartitions[partition] == 0) {\r\n        _totalPartitions.push(partition);\r\n        _indexOfTotalPartitions[partition] = _totalPartitions.length;\r\n      }\r\n      _totalSupplyByPartition[partition] = _totalSupplyByPartition[partition].add(value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Retrieve the destination partition from the 'data' field.\r\n   * By convention, a partition change is requested ONLY when 'data' starts\r\n   * with the flag: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\r\n   * When the flag is detected, the destination tranche is extracted from the\r\n   * 32 bytes following the flag.\r\n   * @param fromPartition Partition of the tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @return Destination partition.\r\n   */\r\n  function _getDestinationPartition(bytes32 fromPartition, bytes memory data) internal pure returns(bytes32 toPartition) {\r\n    bytes32 changePartitionFlag = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    bytes32 flag;\r\n    assembly {\r\n      flag := mload(add(data, 32))\r\n    }\r\n    if(flag == changePartitionFlag) {\r\n      assembly {\r\n        toPartition := mload(add(data, 64))\r\n      }\r\n    } else {\r\n      toPartition = fromPartition;\r\n    }\r\n  }\r\n\r\n  /********************* ERC1400Partition OPTIONAL FUNCTIONS ***************************/\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400Partition STANDARD]\r\n   * @dev Get list of existing partitions.\r\n   * @return Array of all exisiting partitions.\r\n   */\r\n  function totalPartitions() external view returns (bytes32[] memory) {\r\n    return _totalPartitions;\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400Partition STANDARD][SHALL BE CALLED ONLY FROM ERC1400]\r\n   * @dev Set list of token partition controllers.\r\n   * @param partition Name of the partition.\r\n   * @param operators Controller addresses.\r\n   */\r\n   function _setPartitionControllers(bytes32 partition, address[] memory operators) internal {\r\n     for (uint i = 0; i<_controllersByPartition[partition].length; i++){\r\n       _isControllerByPartition[partition][_controllersByPartition[partition][i]] = false;\r\n     }\r\n     for (uint j = 0; j<operators.length; j++){\r\n       _isControllerByPartition[partition][operators[j]] = true;\r\n     }\r\n     _controllersByPartition[partition] = operators;\r\n   }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400Partition STANDARD]\r\n   * @dev Check the value of tokens that an owner allowed to a spender.\r\n   * @param partition Name of the partition.\r\n   * @param owner address The address which owns the funds.\r\n   * @param spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the value of tokens still available for the spender.\r\n   */\r\n  function allowanceByPartition(bytes32 partition, address owner, address spender) external view returns (uint256) {\r\n    return _allowedByPartition[partition][owner][spender];\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400Partition STANDARD]\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of 'msg.sender'.\r\n   * @param partition Name of the partition.\r\n   * @param spender The address which will spend the funds.\r\n   * @param value The amount of tokens to be spent.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function approveByPartition(bytes32 partition, address spender, uint256 value) external returns (bool) {\r\n    require(spender != address(0), \"A5\"); // Transfer Blocked - Sender not eligible\r\n    _allowedByPartition[partition][msg.sender][spender] = value;\r\n    emit ApprovalByPartition(partition, msg.sender, spender, value);\r\n    return true;\r\n  }\r\n\r\n  /************** ERC1400Raw BACKWARDS RETROCOMPATIBILITY *************************/\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400Partition STANDARD][OVERRIDES ERC1400Raw METHOD]\r\n   * @dev Transfer the value of tokens from the address 'msg.sender' to the address 'to'.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, by the token holder. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function transferWithData(address to, uint256 value, bytes calldata data)\r\n    external\r\n    isValidCertificate(data)\r\n  {\r\n    _transferByDefaultPartitions(msg.sender, msg.sender, to, value, data, \"\");\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400Partition STANDARD][OVERRIDES ERC1400Raw METHOD]\r\n   * @dev Transfer the value of tokens on behalf of the address from to the address to.\r\n   * @param from Token holder (or 'address(0)'' to set from to 'msg.sender').\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, and intended for the token holder ('from'). [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function transferFromWithData(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData)\r\n    external\r\n    isValidCertificate(operatorData)\r\n  {\r\n    require(_isOperator(msg.sender, from), \"A7\"); // Transfer Blocked - Identity restriction\r\n\r\n    _transferByDefaultPartitions(msg.sender, from, to, value, data, operatorData);\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400Partition STANDARD][OVERRIDES ERC1400Raw METHOD]\r\n   * @dev Empty function to erase ERC1400Raw redeem() function since it doesn't handle partitions.\r\n   */\r\n  function redeem(uint256 /*value*/, bytes calldata /*data*/) external { // Comments to avoid compilation warnings for unused variables.\r\n    revert(\"A8\"); // Transfer Blocked - Token restriction\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400Partition STANDARD][OVERRIDES ERC1400Raw METHOD]\r\n   * @dev Empty function to erase ERC1400Raw redeemFrom() function since it doesn't handle partitions.\r\n   */\r\n  function redeemFrom(address /*from*/, uint256 /*value*/, bytes calldata /*data*/, bytes calldata /*operatorData*/) external { // Comments to avoid compilation warnings for unused variables.\r\n    revert(\"A8\"); // Transfer Blocked - Token restriction\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400Partition STANDARD]\r\n   * @dev Transfer tokens from default partitions.\r\n   * @param operator The address performing the transfer.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, and intended for the token holder ('from') [CAN CONTAIN THE DESTINATION PARTITION].\r\n   * @param operatorData Information attached to the transfer by the operator (if any).\r\n   */\r\n  function _transferByDefaultPartitions(\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n  {\r\n    require(_defaultPartitions.length != 0, \"A8\"); // Transfer Blocked - Token restriction\r\n\r\n    uint256 _remainingValue = value;\r\n    uint256 _localBalance;\r\n\r\n    for (uint i = 0; i < _defaultPartitions.length; i++) {\r\n      _localBalance = _balanceOfByPartition[from][_defaultPartitions[i]];\r\n      if(_remainingValue <= _localBalance) {\r\n        _transferByPartition(_defaultPartitions[i], operator, from, to, _remainingValue, data, operatorData);\r\n        _remainingValue = 0;\r\n        break;\r\n      } else if (_localBalance != 0) {\r\n        _transferByPartition(_defaultPartitions[i], operator, from, to, _localBalance, data, operatorData);\r\n        _remainingValue = _remainingValue - _localBalance;\r\n      }\r\n    }\r\n\r\n    require(_remainingValue == 0, \"A8\"); // Transfer Blocked - Token restriction\r\n  }\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n/**\r\n * @title IERC1400TokensChecker\r\n * @dev IERC1400TokensChecker interface\r\n */\r\ninterface IERC1400TokensChecker {\r\n\r\n  // function canTransfer(\r\n  //   bytes4 functionSig,\r\n  //   address operator,\r\n  //   address from,\r\n  //   address to,\r\n  //   uint256 value,\r\n  //   bytes calldata data,\r\n  //   bytes calldata operatorData\r\n  // ) external view returns (byte, bytes32);\r\n\r\n  function canTransferByPartition(\r\n    bytes4 functionSig,\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n    ) external view returns (byte, bytes32, bytes32);\r\n\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC1400\r\n * @dev ERC1400 logic\r\n */\r\ncontract ERC1400 is IERC1400, ERC1400Partition, MinterRole {\r\n  \r\n  string constant internal ERC1400_INTERFACE_NAME = \"ERC1400Token\";\r\n  string constant internal ERC1400_TOKENS_CHECKER = \"ERC1400TokensChecker\";\r\n\r\n  struct Doc {\r\n    string docURI;\r\n    bytes32 docHash;\r\n  }\r\n\r\n  // Mapping for token URIs.\r\n  mapping(bytes32 => Doc) internal _documents;\r\n\r\n  // Indicate whether the token can still be issued by the issuer or not anymore.\r\n  bool internal _isIssuable;\r\n\r\n  /**\r\n   * @dev Modifier to verify if token is issuable.\r\n   */\r\n  modifier issuableToken() {\r\n    require(_isIssuable, \"A8\"); // Transfer Blocked - Token restriction\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 CONSTRUCTOR]\r\n   * @dev Initialize ERC1400 + register\r\n   * the contract implementation in ERC1820Registry.\r\n   * @param name Name of the token.\r\n   * @param symbol Symbol of the token.\r\n   * @param granularity Granularity of the token.\r\n   * @param controllers Array of initial controllers.\r\n   * @param certificateSigner Address of the off-chain service which signs the\r\n   * conditional ownership certificates required for token transfers, issuance,\r\n   * redemption (Cf. CertificateController.sol).\r\n   * @param certificateActivated If set to 'true', the certificate controller\r\n   * is activated at contract creation.\r\n   * @param defaultPartitions Partitions chosen by default, when partition is\r\n   * not specified, like the case ERC20 tranfers.\r\n   */\r\n  constructor(\r\n    string memory name,\r\n    string memory symbol,\r\n    uint256 granularity,\r\n    address[] memory controllers,\r\n    address certificateSigner,\r\n    bool certificateActivated,\r\n    bytes32[] memory defaultPartitions\r\n  )\r\n    public\r\n    ERC1400Partition(name, symbol, granularity, controllers, certificateSigner, certificateActivated, defaultPartitions)\r\n  {\r\n    ERC1820Client.setInterfaceImplementation(ERC1400_INTERFACE_NAME, address(this));\r\n    _isControllable = true;\r\n    _isIssuable = true;\r\n\r\n    ERC1820Implementer._setInterface(ERC1400_INTERFACE_NAME); // For migration\r\n  }\r\n\r\n  /********************** ERC1400 EXTERNAL FUNCTIONS **************************/\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (1/9)]\r\n   * @dev Access a document associated with the token.\r\n   * @param name Short name (represented as a bytes32) associated to the document.\r\n   * @return Requested document + document hash.\r\n   */\r\n  function getDocument(bytes32 name) external view returns (string memory, bytes32) {\r\n    require(bytes(_documents[name].docURI).length != 0); // Action Blocked - Empty document\r\n    return (\r\n      _documents[name].docURI,\r\n      _documents[name].docHash\r\n    );\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (2/9)]\r\n   * @dev Associate a document with the token.\r\n   * @param name Short name (represented as a bytes32) associated to the document.\r\n   * @param uri Document content.\r\n   * @param documentHash Hash of the document [optional parameter].\r\n   */\r\n  function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external {\r\n    require(_isController[msg.sender]);\r\n    _documents[name] = Doc({\r\n      docURI: uri,\r\n      docHash: documentHash\r\n    });\r\n    emit Document(name, uri, documentHash);\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (3/9)]\r\n   * @dev Know if the token can be controlled by operators.\r\n   * If a token returns 'false' for 'isControllable()'' then it MUST always return 'false' in the future.\r\n   * @return bool 'true' if the token can still be controlled by operators, 'false' if it can't anymore.\r\n   */\r\n  function isControllable() external view returns (bool) {\r\n    return _isControllable;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (4/9)]\r\n   * @dev Know if new tokens can be issued in the future.\r\n   * @return bool 'true' if tokens can still be issued by the issuer, 'false' if they can't anymore.\r\n   */\r\n  function isIssuable() external view returns (bool) {\r\n    return _isIssuable;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (5/9)]\r\n   * @dev Issue tokens from a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param tokenHolder Address for which we want to issue tokens.\r\n   * @param value Number of tokens issued.\r\n   * @param data Information attached to the issuance, by the issuer. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function issueByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data)\r\n    external\r\n    onlyMinter\r\n    issuableToken\r\n    isValidCertificate(data)\r\n  {\r\n    _issueByPartition(partition, msg.sender, tokenHolder, value, data, \"\");\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (6/9)]\r\n   * @dev Redeem tokens of a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param value Number of tokens redeemed.\r\n   * @param data Information attached to the redemption, by the redeemer. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function redeemByPartition(bytes32 partition, uint256 value, bytes calldata data)\r\n    external\r\n    isValidCertificate(data)\r\n  {\r\n    _redeemByPartition(partition, msg.sender, msg.sender, value, data, \"\");\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (7/9)]\r\n   * @dev Redeem tokens of a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param tokenHolder Address for which we want to redeem tokens.\r\n   * @param value Number of tokens redeemed.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption, by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function operatorRedeemByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data, bytes calldata operatorData)\r\n    external\r\n    isValidCertificate(operatorData)\r\n  {\r\n    require(_isOperatorForPartition(partition, msg.sender, tokenHolder), \"A7\"); // Transfer Blocked - Identity restriction\r\n\r\n    _redeemByPartition(partition, msg.sender, tokenHolder, value, data, operatorData);\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (8/9)]\r\n   * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\r\n   * @param partition Name of the partition.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, by the token holder. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\r\n   * @return Additional bytes32 parameter that can be used to define\r\n   * application specific reason codes with additional details (for example the\r\n   * transfer restriction rule responsible for making the transfer operation invalid).\r\n   * @return Destination partition.\r\n   */\r\n  function canTransferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data)\r\n    external\r\n    view\r\n    returns (byte, bytes32, bytes32)\r\n  {\r\n    bytes4 functionSig = this.transferByPartition.selector; // 0xf3d490db: 4 first bytes of keccak256(transferByPartition(bytes32,address,uint256,bytes))\r\n    if(!_checkCertificate(data, 0, functionSig)) {\r\n      return(hex\"A3\", \"\", partition); // Transfer Blocked - Sender lockup period not ended\r\n    } else {\r\n      return _canTransfer(functionSig, partition, msg.sender, msg.sender, to, value, data, \"\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (9/9)]\r\n   * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\r\n   * @param partition Name of the partition.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer, by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\r\n   * @return Additional bytes32 parameter that can be used to define\r\n   * application specific reason codes with additional details (for example the\r\n   * transfer restriction rule responsible for making the transfer operation invalid).\r\n   * @return Destination partition.\r\n   */\r\n  function canOperatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData)\r\n    external\r\n    view\r\n    returns (byte, bytes32, bytes32)\r\n  {\r\n    bytes4 functionSig = this.operatorTransferByPartition.selector; // 0x8c0dee9c: 4 first bytes of keccak256(operatorTransferByPartition(bytes32,address,address,uint256,bytes,bytes))\r\n    if(!_checkCertificate(operatorData, 0, functionSig)) {\r\n      return(hex\"A3\", \"\", partition); // Transfer Blocked - Sender lockup period not ended\r\n    } else {\r\n      return _canTransfer(functionSig, partition, msg.sender, from, to, value, data, operatorData);\r\n    }\r\n  }\r\n\r\n  /********************** ERC1400 INTERNAL FUNCTIONS **************************/\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\r\n   * @param functionSig ID of the function that needs to be called.\r\n   * @param partition Name of the partition.\r\n   * @param operator The address performing the transfer.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer, by the operator (if any).\r\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\r\n   * @return Additional bytes32 parameter that can be used to define\r\n   * application specific reason codes with additional details (for example the\r\n   * transfer restriction rule responsible for making the transfer operation invalid).\r\n   * @return Destination partition.\r\n   */\r\n   function _canTransfer(bytes4 functionSig, bytes32 partition, address operator, address from, address to, uint256 value, bytes memory data, bytes memory operatorData)\r\n     internal\r\n     view\r\n     returns (byte, bytes32, bytes32)\r\n   {\r\n     address checksImplementation = interfaceAddr(address(this), ERC1400_TOKENS_CHECKER);\r\n\r\n     if((checksImplementation != address(0))) {\r\n       return IERC1400TokensChecker(checksImplementation).canTransferByPartition(functionSig, partition, operator, from, to, value, data, operatorData);\r\n     }\r\n     else {\r\n       return(hex\"00\", \"\", partition);\r\n     }\r\n   }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Issue tokens from a specific partition.\r\n   * @param toPartition Name of the partition.\r\n   * @param operator The address performing the issuance.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to issue.\r\n   * @param data Information attached to the issuance.\r\n   * @param operatorData Information attached to the issuance, by the operator (if any).\r\n   */\r\n  function _issueByPartition(\r\n    bytes32 toPartition,\r\n    address operator,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n  {\r\n    _issue(operator, to, value, data, operatorData);\r\n    _addTokenToPartition(to, toPartition, value);\r\n\r\n    _callPostTransferHooks(toPartition, operator, address(0), to, value, data, operatorData);\r\n\r\n    emit IssuedByPartition(toPartition, operator, to, value, data, operatorData);\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Redeem tokens of a specific partition.\r\n   * @param fromPartition Name of the partition.\r\n   * @param operator The address performing the redemption.\r\n   * @param from Token holder whose tokens will be redeemed.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption, by the operator (if any).\r\n   */\r\n  function _redeemByPartition(\r\n    bytes32 fromPartition,\r\n    address operator,\r\n    address from,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n  {\r\n    require(_balanceOfByPartition[from][fromPartition] >= value, \"A4\"); // Transfer Blocked - Sender balance insufficient\r\n\r\n    _callPreTransferHooks(fromPartition, operator, from, address(0), value, data, operatorData);\r\n\r\n    _removeTokenFromPartition(from, fromPartition, value);\r\n    _redeem(operator, from, value, data, operatorData);\r\n\r\n    emit RedeemedByPartition(fromPartition, operator, from, value, data, operatorData);\r\n  }\r\n\r\n  /********************** ERC1400 OPTIONAL FUNCTIONS **************************/\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Definitely renounce the possibility to control tokens on behalf of tokenHolders.\r\n   * Once set to false, '_isControllable' can never be set to 'true' again.\r\n   */\r\n  function renounceControl() external onlyOwner {\r\n    _isControllable = false;\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Definitely renounce the possibility to issue new tokens.\r\n   * Once set to false, '_isIssuable' can never be set to 'true' again.\r\n   */\r\n  function renounceIssuance() external onlyOwner {\r\n    _isIssuable = false;\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Set list of token controllers.\r\n   * @param operators Controller addresses.\r\n   */\r\n  function setControllers(address[] calldata operators) external onlyOwner {\r\n    _setControllers(operators);\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Set list of token partition controllers.\r\n   * @param partition Name of the partition.\r\n   * @param operators Controller addresses.\r\n   */\r\n   function setPartitionControllers(bytes32 partition, address[] calldata operators) external onlyOwner {\r\n     _setPartitionControllers(partition, operators);\r\n   }\r\n\r\n   /**\r\n   * @dev Add a certificate signer for the token.\r\n   * @param operator Address to set as a certificate signer.\r\n   * @param authorized 'true' if operator shall be accepted as certificate signer, 'false' if not.\r\n   */\r\n  function setCertificateSigner(address operator, bool authorized) external onlyOwner {\r\n    _setCertificateSigner(operator, authorized);\r\n  }\r\n\r\n  /**\r\n   * @dev Activate/disactivate certificate controller.\r\n   * @param activated 'true', if the certificate control shall be activated, 'false' if not.\r\n   */\r\n  function setCertificateControllerActivated(bool activated) external onlyOwner {\r\n   _setCertificateControllerActivated(activated);\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Set validator contract address.\r\n   * The validator contract needs to verify \"ERC1400TokensValidator\" interface.\r\n   * Once setup, the validator will be called everytime a transfer is executed.\r\n   * @param validatorAddress Address of the validator contract.\r\n   * @param interfaceLabel Interface label of hook contract.\r\n   */\r\n  function setHookContract(address validatorAddress, string calldata interfaceLabel) external onlyOwner {\r\n    ERC1400Raw._setHookContract(validatorAddress, interfaceLabel);\r\n  }\r\n\r\n  /************************** REQUIRED FOR MIGRATION FEATURE *******************************/\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Migrate contract.\r\n   *\r\n   * ===> CAUTION: DEFINITIVE ACTION\r\n   * \r\n   * This function shall be called once a new version of the smart contract has been created.\r\n   * Once this function is called:\r\n   *  - The address of the new smart contract is set in ERC1820 registry\r\n   *  - If the choice is definitive, the current smart contract is turned off and can never be used again\r\n   *\r\n   * @param newContractAddress Address of the new version of the smart contract.\r\n   * @param definitive If set to 'true' the contract is turned off definitely.\r\n   */\r\n  function migrate(address newContractAddress, bool definitive) external onlyOwner {\r\n    _migrate(newContractAddress, definitive);\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Migrate contract.\r\n   *\r\n   * ===> CAUTION: DEFINITIVE ACTION\r\n   * \r\n   * This function shall be called once a new version of the smart contract has been created.\r\n   * Once this function is called:\r\n   *  - The address of the new smart contract is set in ERC1820 registry\r\n   *  - If the choice is definitive, the current smart contract is turned off and can never be used again\r\n   *\r\n   * @param newContractAddress Address of the new version of the smart contract.\r\n   * @param definitive If set to 'true' the contract is turned off definitely.\r\n   */\r\n  function _migrate(address newContractAddress, bool definitive) internal {\r\n    ERC1820Client.setInterfaceImplementation(ERC1400_INTERFACE_NAME, newContractAddress);\r\n    if(definitive) {\r\n      _migrated = true;\r\n    }\r\n  }\r\n\r\n  /************* ERC1400Partition/ERC1400Raw BACKWARDS RETROCOMPATIBILITY ******************/\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD][OVERRIDES ERC1400Partition METHOD]\r\n   * @dev Redeem the value of tokens from the address 'msg.sender'.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption, by the token holder. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function redeem(uint256 value, bytes calldata data)\r\n    external\r\n    isValidCertificate(data)\r\n  {\r\n    _redeemByDefaultPartitions(msg.sender, msg.sender, value, data, \"\");\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD][OVERRIDES ERC1400Partition METHOD]\r\n   * @dev Redeem the value of tokens on behalf of the address 'from'.\r\n   * @param from Token holder whose tokens will be redeemed (or 'address(0)' to set from to 'msg.sender').\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption, by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function redeemFrom(address from, uint256 value, bytes calldata data, bytes calldata operatorData)\r\n    external\r\n    isValidCertificate(operatorData)\r\n  {\r\n    require(_isOperator(msg.sender, from), \"A7\"); // Transfer Blocked - Identity restriction\r\n\r\n    _redeemByDefaultPartitions(msg.sender, from, value, data, operatorData);\r\n  }\r\n\r\n  /**\r\n  * [NOT MANDATORY FOR ERC1400Partition STANDARD]\r\n   * @dev Redeem tokens from a default partitions.\r\n   * @param operator The address performing the redeem.\r\n   * @param from Token holder.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption, by the operator (if any).\r\n   */\r\n  function _redeemByDefaultPartitions(\r\n    address operator,\r\n    address from,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n  {\r\n    require(_defaultPartitions.length != 0, \"A8\"); // Transfer Blocked - Token restriction\r\n\r\n    uint256 _remainingValue = value;\r\n    uint256 _localBalance;\r\n\r\n    for (uint i = 0; i < _defaultPartitions.length; i++) {\r\n      _localBalance = _balanceOfByPartition[from][_defaultPartitions[i]];\r\n      if(_remainingValue <= _localBalance) {\r\n        _redeemByPartition(_defaultPartitions[i], operator, from, _remainingValue, data, operatorData);\r\n        _remainingValue = 0;\r\n        break;\r\n      } else {\r\n        _redeemByPartition(_defaultPartitions[i], operator, from, _localBalance, data, operatorData);\r\n        _remainingValue = _remainingValue - _localBalance;\r\n      }\r\n    }\r\n\r\n    require(_remainingValue == 0, \"A8\"); // Transfer Blocked - Token restriction\r\n  }\r\n\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC1400ERC20\r\n * @dev ERC1400 with ERC20 retrocompatibility\r\n */\r\ncontract ERC1400ERC20 is IERC20, ERC1400 {\r\n\r\n  string constant internal ERC20_INTERFACE_NAME = \"ERC20Token\";\r\n\r\n  // Mapping from (tokenHolder, spender) to allowed value.\r\n  mapping (address => mapping (address => uint256)) internal _allowed;\r\n\r\n  /**\r\n   * [ERC1400ERC20 CONSTRUCTOR]\r\n   * @dev Initialize ERC71400ERC20 and CertificateController parameters + register\r\n   * the contract implementation in ERC1820Registry.\r\n   * @param name Name of the token.\r\n   * @param symbol Symbol of the token.\r\n   * @param granularity Granularity of the token.\r\n   * @param controllers Array of initial controllers.\r\n   * @param certificateSigner Address of the off-chain service which signs the\r\n   * conditional ownership certificates required for token transfers, issuance,\r\n   * redemption (Cf. CertificateController.sol).\r\n   * @param certificateActivated If set to 'true', the certificate controller\r\n   * is activated at contract creation.\r\n   * @param defaultPartitions Partitions chosen by default, when partition is\r\n   * not specified, like the case ERC20 tranfers.\r\n   */\r\n  constructor(\r\n    string memory name,\r\n    string memory symbol,\r\n    uint256 granularity,\r\n    address[] memory controllers,\r\n    address certificateSigner,\r\n    bool certificateActivated,\r\n    bytes32[] memory defaultPartitions\r\n  )\r\n    public\r\n    ERC1400(name, symbol, granularity, controllers, certificateSigner, certificateActivated, defaultPartitions)\r\n  {\r\n    ERC1820Client.setInterfaceImplementation(ERC20_INTERFACE_NAME, address(this));\r\n\r\n    ERC1820Implementer._setInterface(ERC20_INTERFACE_NAME); // For migration\r\n  }\r\n\r\n  /**\r\n   * [OVERRIDES ERC1400 METHOD]\r\n   * @dev Perform the transfer of tokens.\r\n   * @param operator The address performing the transfer.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer.\r\n   * @param operatorData Information attached to the transfer by the operator (if any).\r\n   */\r\n  function _transferWithData(\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n  {\r\n    ERC1400Raw._transferWithData(operator, from, to, value, data, operatorData);\r\n\r\n    emit Transfer(from, to, value);\r\n  }\r\n\r\n  /**\r\n   * [OVERRIDES ERC1400 METHOD]\r\n   * @dev Perform the token redemption.\r\n   * @param operator The address performing the redemption.\r\n   * @param from Token holder whose tokens will be redeemed.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption by the operator (if any).\r\n   */\r\n  function _redeem(address operator, address from, uint256 value, bytes memory data, bytes memory operatorData) internal {\r\n    ERC1400Raw._redeem(operator, from, value, data, operatorData);\r\n\r\n    emit Transfer(from, address(0), value);  //  ERC20 backwards compatibility\r\n  }\r\n\r\n  /**\r\n   * [OVERRIDES ERC1400 METHOD]\r\n   * @dev Perform the issuance of tokens.\r\n   * @param operator Address which triggered the issuance.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens issued.\r\n   * @param data Information attached to the issuance.\r\n   * @param operatorData Information attached to the issuance by the operator (if any).\r\n   */\r\n  function _issue(address operator, address to, uint256 value, bytes memory data, bytes memory operatorData) internal {\r\n    ERC1400Raw._issue(operator, to, value, data, operatorData);\r\n\r\n    emit Transfer(address(0), to, value); // ERC20 backwards compatibility\r\n  }\r\n\r\n  /**\r\n   * [OVERRIDES ERC1400 METHOD]\r\n   * @dev Get the number of decimals of the token.\r\n   * @return The number of decimals of the token. For Backwards compatibility, decimals are forced to 18 in ERC1400Raw.\r\n   */\r\n  function decimals() external pure returns(uint8) {\r\n    return uint8(18);\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Check the value of tokens that an owner allowed to a spender.\r\n   * @param owner address The address which owns the funds.\r\n   * @param spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the value of tokens still available for the spender.\r\n   */\r\n  function allowance(address owner, address spender) external view returns (uint256) {\r\n    return _allowed[owner][spender];\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of 'msg.sender'.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param spender The address which will spend the funds.\r\n   * @param value The amount of tokens to be spent.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function approve(address spender, uint256 value) external returns (bool) {\r\n    require(spender != address(0), \"A5\"); // Transfer Blocked - Sender not eligible\r\n    _allowed[msg.sender][spender] = value;\r\n    emit Approval(msg.sender, spender, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Transfer token for a specified address.\r\n   * @param to The address to transfer to.\r\n   * @param value The value to be transferred.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function transfer(address to, uint256 value) external returns (bool) {\r\n    _transferByDefaultPartitions(msg.sender, msg.sender, to, value, \"\", \"\");\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Transfer tokens from one address to another.\r\n   * @param from The address which you want to transfer tokens from.\r\n   * @param to The address which you want to transfer to.\r\n   * @param value The amount of tokens to be transferred.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool) {\r\n    require( _isOperator(msg.sender, from)\r\n      || (value <= _allowed[from][msg.sender]), \"A7\"); // Transfer Blocked - Identity restriction\r\n\r\n    if(_allowed[from][msg.sender] >= value) {\r\n      _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n    } else {\r\n      _allowed[from][msg.sender] = 0;\r\n    }\r\n\r\n    _transferByDefaultPartitions(msg.sender, from, to, value, \"\", \"\");\r\n    return true;\r\n  }\r\n\r\n  /************************** REQUIRED FOR MIGRATION FEATURE *******************************/\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD][OVERRIDES ERC1400 METHOD]\r\n   * @dev Migrate contract.\r\n   *\r\n   * ===> CAUTION: DEFINITIVE ACTION\r\n   * \r\n   * This function shall be called once a new version of the smart contract has been created.\r\n   * Once this function is called:\r\n   *  - The address of the new smart contract is set in ERC1820 registry\r\n   *  - If the choice is definitive, the current smart contract is turned off and can never be used again\r\n   *\r\n   * @param newContractAddress Address of the new version of the smart contract.\r\n   * @param definitive If set to 'true' the contract is turned off definitely.\r\n   */\r\n  function migrate(address newContractAddress, bool definitive) external onlyOwner {\r\n    ERC1820Client.setInterfaceImplementation(ERC20_INTERFACE_NAME, newContractAddress);\r\n    ERC1400._migrate(newContractAddress, definitive);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"uri\",\"type\":\"string\"},{\"name\":\"documentHash\",\"type\":\"bytes32\"}],\"name\":\"setDocument\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"authorizeOperatorByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"tokenHolder\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorRedeemByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approveByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"revokeOperatorByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"setPartitionControllers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowanceByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"activated\",\"type\":\"bool\"}],\"name\":\"setCertificateControllerActivated\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"interfaceHash\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"canImplementInterfaceForAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferWithData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isIssuable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOfByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isControllable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"granularity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"redeemByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"tokenHolder\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"issueByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"validatorAddress\",\"type\":\"address\"},{\"name\":\"interfaceLabel\",\"type\":\"string\"}],\"name\":\"setHookContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"checkCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPartitions\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"canOperatorTransferByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceIssuance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperatorForPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"certificateSigners\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"partitionsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"authorized\",\"type\":\"bool\"}],\"name\":\"setCertificateSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controllers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"}],\"name\":\"controllersByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"transferFromWithData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorTransferByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"canTransferByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newContractAddress\",\"type\":\"address\"},{\"name\":\"definitive\",\"type\":\"bool\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"authorizeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"getDocument\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDefaultPartitions\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceControl\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"certificateControllerActivated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"setControllers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partitions\",\"type\":\"bytes32[]\"}],\"name\":\"setDefaultPartitions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"redeemFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"granularity\",\"type\":\"uint256\"},{\"name\":\"controllers\",\"type\":\"address[]\"},{\"name\":\"certificateSigner\",\"type\":\"address\"},{\"name\":\"certificateActivated\",\"type\":\"bool\"},{\"name\":\"defaultPartitions\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Checked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"TransferWithData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Issued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fromPartition\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"TransferByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fromPartition\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"toPartition\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ChangedPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperatorByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperatorByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ApprovalByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"uri\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"documentHash\",\"type\":\"bytes32\"}],\"name\":\"Document\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"IssuedByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"RedeemedByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ERC1400ERC20","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000160000000000000000000000000e31c41f0f70c5ff39f73b4b94bccd767b3071630000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000e446169737931343030546f6b656e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000544414953590000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000e07e225466af79561b99efd85fb87f7afe863f5e0000000000000000000000000000000000000000000000000000000000000000","Library":"","LicenseType":"Apache-2.0","SwarmSource":"bzzr://36f91ec7fa8998a111fb2b916977697f46bbeb92c5ae484b55af1aa26bbca4cf"}]}