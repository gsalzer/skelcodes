{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\ncontract IERC20Token {\r\n    function balanceOf(address _owner) public view returns (uint);\r\n    function allowance(address _owner, address _spender) public view returns (uint);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function totalSupply() public view returns (uint);\r\n}\r\n\r\ncontract IDSWrappedToken is IERC20Token {\r\n    function mint(address _account, uint _value) public;\r\n    function burn(address _account, uint _value) public;\r\n    function wrap(address _dst, uint _amount) public returns (uint);\r\n    function unwrap(address _dst, uint _amount) public returns (uint);\r\n    function changeByMultiple(uint _amount) public view returns (uint);\r\n    function reverseByMultiple(uint _xAmount) public view returns (uint);\r\n    function getSrcERC20() public view returns (address);\r\n}\r\n\r\ncontract IDFStore {\r\n\r\n    function getSectionMinted(uint _position) public view returns (uint);\r\n    function addSectionMinted(uint _amount) public;\r\n    function addSectionMinted(uint _position, uint _amount) public;\r\n    function setSectionMinted(uint _amount) public;\r\n    function setSectionMinted(uint _position, uint _amount) public;\r\n\r\n    function getSectionBurned(uint _position) public view returns (uint);\r\n    function addSectionBurned(uint _amount) public;\r\n    function addSectionBurned(uint _position, uint _amount) public;\r\n    function setSectionBurned(uint _amount) public;\r\n    function setSectionBurned(uint _position, uint _amount) public;\r\n\r\n    function getSectionToken(uint _position) public view returns (address[] memory);\r\n    function getSectionWeight(uint _position) public view returns (uint[] memory);\r\n    function getSectionData(uint _position) public view returns (uint, uint, uint, address[] memory, uint[] memory);\r\n    function getBackupSectionData(uint _position) public view returns (uint, address[] memory, uint[] memory);\r\n    function getBackupSectionIndex(uint _position) public view returns (uint);\r\n    function setBackupSectionIndex(uint _position, uint _backupIdx) public;\r\n\r\n    function setSection(address[] memory _wrappedTokens, uint[] memory _weight) public;\r\n    function setBackupSection(uint _position, address[] memory _tokens, uint[] memory _weight) public;\r\n    function burnSectionMoveon() public;\r\n\r\n    function getMintingToken(address _token) public view returns (bool);\r\n    function setMintingToken(address _token, bool _flag) public;\r\n    function getMintedToken(address _token) public view returns (bool);\r\n    function setMintedToken(address _token, bool _flag) public;\r\n    function getBackupToken(address _token) public view returns (address);\r\n    function setBackupToken(address _token, address _backupToken) public;\r\n    function getMintedTokenList() public view returns (address[] memory);\r\n\r\n    function getMintPosition() public view returns (uint);\r\n    function getBurnPosition() public view returns (uint);\r\n\r\n    function getTotalMinted() public view returns (uint);\r\n    function addTotalMinted(uint _amount) public;\r\n    function setTotalMinted(uint _amount) public;\r\n    function getTotalBurned() public view returns (uint);\r\n    function addTotalBurned(uint _amount) public;\r\n    function setTotalBurned(uint _amount) public;\r\n    function getMinBurnAmount() public view returns (uint);\r\n    function setMinBurnAmount(uint _amount) public;\r\n\r\n    function getTokenBalance(address _tokenID) public view returns (uint);\r\n    function setTokenBalance(address _tokenID, uint _amount) public;\r\n    function getResUSDXBalance(address _tokenID) public view returns (uint);\r\n    function setResUSDXBalance(address _tokenID, uint _amount) public;\r\n    function getDepositorBalance(address _depositor, address _tokenID) public view returns (uint);\r\n    function setDepositorBalance(address _depositor, address _tokenID, uint _amount) public;\r\n\r\n    function getFeeRate(uint ct) public view returns (uint);\r\n    function setFeeRate(uint ct, uint rate) public;\r\n    function getTypeToken(uint tt) public view returns (address);\r\n    function setTypeToken(uint tt, address _tokenID) public;\r\n    function getTokenMedian(address _tokenID) public view returns (address);\r\n    function setTokenMedian(address _tokenID, address _median) public;\r\n\r\n    function setTotalCol(uint _amount) public;\r\n    function getTotalCol() public view returns (uint);\r\n\r\n    function setWrappedToken(address _srcToken, address _wrappedToken) public;\r\n    function getWrappedToken(address _srcToken) public view returns (address);\r\n}\r\n\r\ncontract IMedianizer {\r\n    function read() public view returns (bytes32);\r\n}\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function div(uint x, uint y) internal pure returns (uint z) {\r\n        require(y > 0, \"ds-math-div-overflow\");\r\n        z = x / y;\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n    /**\r\n     * @dev x to the power of y power(base, exponent)\r\n     */\r\n    function pow(uint256 base, uint256 exponent) public pure returns (uint256) {\r\n        if (exponent == 0) {\r\n            return 1;\r\n        }\r\n        else if (exponent == 1) {\r\n            return base;\r\n        }\r\n        else if (base == 0 && exponent != 0) {\r\n            return 0;\r\n        }\r\n        else {\r\n            uint256 z = base;\r\n            for (uint256 i = 1; i < exponent; i++)\r\n                z = mul(z, base);\r\n            return z;\r\n        }\r\n    }\r\n}\r\n\r\ncontract DFProtocolView is DSMath {\r\n    IDFStore public dfStore;\r\n    address public dfCol;\r\n\r\n    constructor (address _dfStore, address _dfCol)\r\n        public\r\n    {\r\n        dfStore = IDFStore(_dfStore);\r\n        dfCol = _dfCol;\r\n    }\r\n\r\n    function getUSDXForDeposit(address _srcToken, uint _srcAmount) public view returns (uint) {\r\n        address _depositor = msg.sender;\r\n        address _tokenID = dfStore.getWrappedToken(_srcToken);\r\n        require(dfStore.getMintingToken(_tokenID), \"CalcDepositorMintTotal: asset not allow.\");\r\n\r\n        uint _amount = IDSWrappedToken(_tokenID).changeByMultiple(_srcAmount);\r\n        uint _depositorMintTotal;\r\n        uint _step = uint(-1);\r\n        address[] memory _tokens;\r\n        uint[] memory _mintCW;\r\n        (, , , _tokens, _mintCW) = dfStore.getSectionData(dfStore.getMintPosition());\r\n\r\n        uint[] memory _tokenBalance = new uint[](_tokens.length);\r\n        uint[] memory _depositorBalance = new uint[](_tokens.length);\r\n        uint[] memory _resUSDXBalance = new uint[](_tokens.length);\r\n\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            _tokenBalance[i] = dfStore.getTokenBalance(_tokens[i]);\r\n            _resUSDXBalance[i] = dfStore.getResUSDXBalance(_tokens[i]);\r\n            _depositorBalance[i] = dfStore.getDepositorBalance(_depositor, _tokens[i]);\r\n            if (_tokenID == _tokens[i]){\r\n                _tokenBalance[i] = add(_tokenBalance[i], _amount);\r\n                _depositorBalance[i] = add(_depositorBalance[i], _amount);\r\n            }\r\n            _step = min(div(_tokenBalance[i], _mintCW[i]), _step);\r\n        }\r\n\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            _depositorMintTotal = add(_depositorMintTotal,\r\n                                    min(_depositorBalance[i], add(_resUSDXBalance[i], mul(_step, _mintCW[i])))\r\n                                    );\r\n        }\r\n\r\n        return _depositorMintTotal;\r\n    }\r\n\r\n    function getUserMaxToClaim() public view returns (uint) {\r\n        address _depositor = msg.sender;\r\n        uint _resUSDXBalance;\r\n        uint _depositorBalance;\r\n        uint _depositorClaimAmount;\r\n        uint _claimAmount;\r\n        address[] memory _tokens = dfStore.getMintedTokenList();\r\n\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            _resUSDXBalance = dfStore.getResUSDXBalance(_tokens[i]);\r\n            _depositorBalance = dfStore.getDepositorBalance(_depositor, _tokens[i]);\r\n\r\n            _depositorClaimAmount = min(_resUSDXBalance, _depositorBalance);\r\n            _claimAmount = add(_claimAmount, _depositorClaimAmount);\r\n        }\r\n\r\n        return _claimAmount;\r\n    }\r\n\r\n    function getColMaxClaim() public view returns (address[] memory, uint[] memory) {\r\n        address[] memory _tokens = dfStore.getMintedTokenList();\r\n        uint[] memory _balance = new uint[](_tokens.length);\r\n        address[] memory _srcTokens = new address[](_tokens.length);\r\n\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            _balance[i] = dfStore.getResUSDXBalance(_tokens[i]);\r\n            _srcTokens[i] = IDSWrappedToken(_tokens[i]).getSrcERC20();\r\n        }\r\n\r\n        return (_srcTokens, _balance);\r\n    }\r\n\r\n    function getMintingSection() public view returns(address[] memory, uint[] memory) {\r\n        uint position = dfStore.getMintPosition();\r\n        uint[] memory _weight = dfStore.getSectionWeight(position);\r\n        address[] memory _tokens = dfStore.getSectionToken(position);\r\n        address[] memory _srcTokens = new address[](_tokens.length);\r\n\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            _srcTokens[i] = IDSWrappedToken(_tokens[i]).getSrcERC20();\r\n        }\r\n\r\n        return (_srcTokens, _weight);\r\n    }\r\n\r\n    function getBurningSection() public view returns(address[] memory, uint[] memory) {\r\n        uint position = dfStore.getBurnPosition();\r\n        uint[] memory _weight = dfStore.getSectionWeight(position);\r\n        address[] memory _tokens = dfStore.getSectionToken(position);\r\n\r\n        address[] memory _srcTokens = new address[](_tokens.length);\r\n\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            _srcTokens[i] = IDSWrappedToken(_tokens[i]).getSrcERC20();\r\n        }\r\n\r\n        return (_srcTokens, _weight);\r\n    }\r\n\r\n    function getUserWithdrawBalance() public view returns(address[] memory, uint[] memory) {\r\n        address _depositor = msg.sender;\r\n        address[] memory _tokens = dfStore.getMintedTokenList();\r\n        uint[] memory _withdrawBalances = new uint[](_tokens.length);\r\n\r\n        address[] memory _srcTokens = new address[](_tokens.length);\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            _srcTokens[i] = IDSWrappedToken(_tokens[i]).getSrcERC20();\r\n            _withdrawBalances[i] = IDSWrappedToken(_tokens[i]).reverseByMultiple(calcWithdrawAmount(_depositor, _tokens[i]));\r\n        }\r\n\r\n        return (_srcTokens, _withdrawBalances);\r\n    }\r\n\r\n    function getPrice(uint _tokenIdx) public view returns (uint) {\r\n        address _token = dfStore.getTypeToken(_tokenIdx);\r\n        require(_token != address(0), \"_UnifiedCommission: fee token not correct.\");\r\n        bytes32 price = IMedianizer(dfStore.getTokenMedian(_token)).read();\r\n        return uint(price);\r\n    }\r\n\r\n    function getFeeRate(uint _processIdx) public view returns (uint) {\r\n        return dfStore.getFeeRate(_processIdx);\r\n    }\r\n\r\n    function getDestroyThreshold() public view returns (uint) {\r\n        return dfStore.getMinBurnAmount();\r\n    }\r\n\r\n    function calcWithdrawAmount(address _depositor, address _tokenID) internal view returns (uint) {\r\n        uint _depositorBalance = dfStore.getDepositorBalance(_depositor, _tokenID);\r\n        uint _tokenBalance = dfStore.getTokenBalance(_tokenID);\r\n        uint _withdrawAmount = min(_tokenBalance, _depositorBalance);\r\n\r\n        return _withdrawAmount;\r\n    }\r\n\r\n    function getColStatus() public view returns (address[] memory, uint[] memory) {\r\n\t\taddress[] memory _tokens = dfStore.getMintedTokenList();\r\n\t\tuint[] memory _srcBalance = new uint[](_tokens.length);\r\n\t\taddress[] memory _srcTokens = new address[](_tokens.length);\r\n\t\tuint _xAmount;\r\n\r\n\t\tfor (uint i = 0; i < _tokens.length; i++) {\r\n\t\t\t_xAmount = IDSWrappedToken(_tokens[i]).balanceOf(dfCol);\r\n\t\t\t_srcBalance[i] = IDSWrappedToken(_tokens[i]).reverseByMultiple(_xAmount);\r\n\t\t\t_srcTokens[i] = IDSWrappedToken(_tokens[i]).getSrcERC20();\r\n\t\t}\r\n\r\n\t\treturn (_srcTokens, _srcBalance);\r\n    }\r\n\r\n    function getPoolStatus() public view returns (address[] memory, uint[] memory) {\r\n\t\taddress[] memory _tokens = dfStore.getMintedTokenList();\r\n\t\tuint[] memory _srcBalance = new uint[](_tokens.length);\r\n\t\taddress[] memory _srcTokens = new address[](_tokens.length);\r\n        uint _xAmount;\r\n\r\n\t\tfor (uint i = 0; i < _tokens.length; i++) {\r\n            _xAmount = dfStore.getTokenBalance(_tokens[i]);\r\n\t\t\t_srcBalance[i] = IDSWrappedToken(_tokens[i]).reverseByMultiple(_xAmount);\r\n\t\t\t_srcTokens[i] = IDSWrappedToken(_tokens[i]).getSrcERC20();\r\n\t\t}\r\n\r\n\t\treturn (_srcTokens, _srcBalance);\r\n    }\r\n\r\n    function calcMaxMinting() public view returns(uint) {\r\n        address[] memory _tokens;\r\n        uint[] memory _mintCW;\r\n        (, , , _tokens, _mintCW) = dfStore.getSectionData(dfStore.getMintPosition());\r\n\r\n        uint _sumMintCW;\r\n        uint _step = uint(-1);\r\n        address _depositor = msg.sender;\r\n        address _srcToken;\r\n        uint _balance;\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            _sumMintCW = add(_sumMintCW, _mintCW[i]);\r\n            _srcToken = IDSWrappedToken(_tokens[i]).getSrcERC20();\r\n            _balance = IDSWrappedToken(_srcToken).balanceOf(_depositor);\r\n            _step = min(div(IDSWrappedToken(_tokens[i]).changeByMultiple(_balance), _mintCW[i]), _step);\r\n        }\r\n\r\n        return mul(_step, _sumMintCW);\r\n    }\r\n\r\n    function getCollateralList() public view returns (address[] memory) {\r\n\t\taddress[] memory _tokens = dfStore.getMintedTokenList();\r\n\t\taddress[] memory _srcTokens = new address[](_tokens.length);\r\n\r\n\t\tfor (uint i = 0; i < _tokens.length; i++)\r\n\t\t\t_srcTokens[i] = IDSWrappedToken(_tokens[i]).getSrcERC20();\r\n\r\n\t\treturn _srcTokens;\r\n    }\r\n\r\n    function getCollateralBalance(address _srcToken) public view returns (uint) {\r\n\t\taddress _tokenID = dfStore.getWrappedToken(_srcToken);\r\n        return IDSWrappedToken(_tokenID).reverseByMultiple(IDSWrappedToken(_tokenID).balanceOf(dfCol));\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_srcToken\",\"type\":\"address\"},{\"name\":\"_srcAmount\",\"type\":\"uint256\"}],\"name\":\"getUSDXForDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDestroyThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calcMaxMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_srcToken\",\"type\":\"address\"}],\"name\":\"getCollateralBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUserMaxToClaim\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"base\",\"type\":\"uint256\"},{\"name\":\"exponent\",\"type\":\"uint256\"}],\"name\":\"pow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMintingSection\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dfStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dfCol\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getColMaxClaim\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPoolStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBurningSection\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCollateralList\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUserWithdrawBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_processIdx\",\"type\":\"uint256\"}],\"name\":\"getFeeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenIdx\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getColStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_dfStore\",\"type\":\"address\"},{\"name\":\"_dfCol\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"DFProtocolView","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d30d06b276867cfa2266542791242ff37c91ba8d000000000000000000000000617bed8699f71fe830a50469bd474bc8481f5235","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://febc92d50840e08b9d33cea85ada0b80aa1f4e8f35ebbba8e7c989f0a481dab9"}]}