{"status":"1","message":"OK","result":[{"SourceCode":"{\"VERCO.sol\":{\"content\":\"pragma solidity ^0.5.16;\\n\\nimport \\\"./VERCO_ERC20_SmartContract.sol\\\";\\n\\ncontract VERCO is ERC25BasicContract {\\n    using SafeMath for uint256;\\n\\nconstructor () public{\\n\\ttotalSupply = 3000000000000000000000000; \\n\\tname = \\\"Vector Robotics\\\";\\n\\t\\tdecimals = 18;\\n\\t\\tsymbol = \\\"VERCO\\\";\\n\\t\\tversion = \\\"1.0\\\";\\n\\t   balances[msg.sender] = totalSupply; \\n\\t}\\n}\\n\"},\"VERCO_ERC20_SmartContract.sol\":{\"content\":\"pragma solidity ^0.5.16;\\n/**\\n* Version: 0.1.0\\n*  * Equity agreement standard used for Ethereum smart contracts\\n blockchain for the apportionment of the capital project.\\n* The current standard version of the Agreement is 0.1.0, which includes the main \\n* information about the project application, creation of equity, confirming the validity of equity,\\n* capital transfer, capital transfer accounting and other functions.\\n*  Payment of dividends. \\n*  Decentralized management of the company through voting. \\n*  Acceptance of a member to the Board of Directors. \\n* * Exclusion of a participant from the Board of Directors.\\n*/\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = a + b;\\n        require(c \\u003e= a);\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        require(b \\u003c= a);\\n        c = a - b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = a * b;\\n        require(a == 0 || c / a == b);\\n    }\\n    \\n    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        require(b \\u003e 0);\\n        c = a / b;\\n    }\\n}\\n\\n\\ncontract ERC20Basic{\\n\\n    function balanceOf(address tokenOwner) public view returns (uint256 amount);\\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\\n    function transfer(address recipient, uint256 amount) public returns (bool);\\n    function approve(address spender, uint256 amount) public returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool);\\n    event Transfer(address indexed _from, address indexed to, uint256 tokens);\\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\\n\\n}\\n\\ncontract ERC20 is ERC20Basic{\\n    using SafeMath for uint256;\\n    \\n    // Tokens total supply\\n    uint256 public totalSupply;\\n\\t\\n\\t// Company\\u0027s name\\n\\tstring public name;\\n\\t\\n\\t// Number of decimals\\n\\tuint8 public decimals;\\n\\t\\n\\t// Token symbol\\n\\tstring public symbol;\\n\\t\\n\\t// treasury address\\n\\taddress treasuryAddress;\\n\\t\\n\\t// Token version\\n\\tstring public version;\\n\\t\\n\\t//Token buyer\\n\\taddress payable saleAgent;\\n\\t\\n\\t// Project owner address\\n\\taddress project_owner;\\n\\t\\n\\t// Token owner address\\n\\taddress payable token_owner;\\n\\t\\n\\t// Balances global values\\n\\tmapping (address =\\u003e uint256) balances;\\n\\t\\n\\t// Balances with address global values\\n\\tmapping (address =\\u003e mapping (address =\\u003e uint)) allowed;\\n\\t\\n\\t// Holder struct\\n\\t struct Holder {\\n        uint256 payment_id;\\n        uint256 dateCangeBalance;\\n    }\\n        \\n    // Holder global values\\n    mapping(address =\\u003e Holder) holders;\\n    \\n\\t//Fix for short address attack against ERC20\\n\\tmodifier onlyPayloadSize(uint size) {\\n\\t\\tassert(msg.data.length == size + 4);\\n\\t\\t_;\\n\\t}\\n\\t\\n\\t// Owner modifier\\n\\t modifier onlyOwner {\\n        require(msg.sender == project_owner, \\\"ACCESS DENIED\\\");\\n        _;\\n    }\\n\\n    /** @dev Shows balances `_token_owner`.\\n     * @return amount of tokens owned by `_token_owner`.\\n     */\\n\\n\\tfunction balanceOf(address _token_owner) public view returns (uint256 amount) {\\n\\t\\treturn balances[_token_owner];\\n    }\\n\\n    /**\\n     * @dev Moves `tokens` tokens from the caller\\u0027s account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n\\n    function transfer(address recipient, uint256 amount) public returns (bool) {\\n        _transfer(recipient, amount);\\n        return true;\\n    }\\n    \\n     /**\\n     * @dev Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n     \\n\\tfunction _transfer(address recipient, uint256 amount) internal  onlyPayloadSize(2*32) {\\n\\t    require(recipient != address(0));\\n\\t    require(balances[msg.sender] \\u003e= amount \\u0026\\u0026 amount \\u003e 0);\\n\\t    balances[msg.sender] = balances[msg.sender].sub(amount);\\n\\t    balances[recipient] = balances[recipient].add(amount);\\n\\t    holders[recipient].dateCangeBalance = block.timestamp;\\n\\t    emit Transfer(msg.sender, recipient, amount);        \\n    }\\n\\n    /**\\n     * @dev Moves `tokens` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    \\n     \\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\\n        _transferFrom(sender, recipient, amount);\\n            return true;\\n    }\\n\\n     /**\\n     * @dev Emits an {Transfer} event indicating the updated allowance. \\n     * \\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `sender`\\u0027s tokens of at least\\n     * `amount`.\\n     */\\n\\n    function _transferFrom (address sender, address recipient, uint256 amount) internal {\\n        require(recipient != address(0) || sender != address (0), \\\"APPROVE TO THE ZERO ADDRESS\\\");\\n\\t    require(balances[sender] \\u003e= amount \\u0026\\u0026 allowed[sender][msg.sender] \\u003e= amount \\u0026\\u0026 amount \\u003e 0);\\n            balances[recipient] = balances[recipient].add(amount);\\n            balances[sender] = balances[sender].sub(amount);\\n            allowed[sender][msg.sender] = allowed[sender][msg.sender].sub(amount);\\n            holders[recipient].dateCangeBalance = block.timestamp;\\n            emit Transfer(sender, recipient, amount);\\n    }\\n\\n     /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value.\\n     *\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) public returns (bool) {\\n        _approve(spender, amount);\\n        return true;\\n    }\\n    /** @dev Sets `tokens` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     *  boolean value indicating whether the operation succeeded.\\n     * Emits an {Approval} event.\\n     */\\n\\n\\tfunction  _approve(address spender, uint256 amount) internal {\\n        require(spender != address(0), \\\"APPROVE TO THE ZERO ADDRESS\\\");\\n\\t\\tallowed[msg.sender][spender] = amount;\\n\\t\\temit Approval(msg.sender, spender, amount);\\n\\t}\\n\\n    /**@dev allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     * @return remaining number of tokens that `spender` will be\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n\\n\\tfunction allowance(address _token_owner, address spender) public view returns (uint256 remaining) {\\n\\t\\treturn allowed[_token_owner][spender];\\n\\t}\\n\\t\\n}\\n\\ncontract ERC25Interface is ERC20 {\\n    \\n     function acceptOwnership() external;\\n     function getOwnersList() public view returns (address[] memory Owners_List);\\n     function getNumOfOwners() public view returns (uint256);\\n     function projectOwner() external view returns (address);\\n     function checkOwner (address address_owner) public view returns (bool);\\n     function newOwnerInvite(address _to) public;\\n     function createVote() public returns (uint256);\\n     function currentVoting () public view returns (uint256 _votes_num, uint256 _quorum, uint256 _start_vote, uint256 _end_vote);\\n     function vote(uint256 _vote_status_value) public;\\n     function getVotingDataBase (uint256 _voting_num) public;\\n     function getVoteResult() public returns (uint256[] memory);\\n     function previousVoteResult() public view returns (uint256 vote_ID, uint256 Result, uint256 Quorum, uint256 Start, uint256 End);\\n     function reward (address token_holder) public view returns (uint256 Reward);\\n     function dividendPaymentsTime (uint256 _start) public returns (uint256 Start_reward, uint256 End_reward);\\n     function treasuryRest () public view returns (uint256);\\n     function withdrawDividend() external;\\n     function depositEther() external payable;\\n}\\n\\n\\ncontract ERC25BasicContract is ERC25Interface {\\n    using SafeMath for uint256;\\n    \\n    //Board Of Directors composition\\n    uint256 internal Fas_number;\\n    \\n    // Board of Directors acception Id\\n    uint256 internal acception_Id; \\n\\n    // Difference time for new member acception\\n    uint256 internal difference_time;\\n    \\n    // Temporary address for new member\\n    address internal temporary_address;\\n\\n    // Vote Number\\n    uint256 internal votes_num;\\n    \\n    // Board Of Directors addresses list \\n    address[] internal FASList;\\n    \\n    //Number of voters Dissagree\\n    uint256 internal voteResult_Dissagree;\\n    \\n     //Number of voters Dissagree\\n    uint256 internal voteResult_Agree;\\n    \\n    // Agree vote\\n     uint256 agree;\\n    \\n    // Dissagree vote\\n    uint256 disagree;\\n    \\n    // Quorum who voted\\n    uint256 internal quorum;\\n    \\n    // vote Result\\n    uint256 internal voteResult;\\n    \\n    // Vote start time\\n    uint256 internal vote_start;\\n    \\n    // Voting period\\n    uint256 internal voting_period;\\n   \\n    // Result of last voting \\n    uint256[] internal lastVoteResult;\\n    \\n    // Voting data base\\n    uint256 internal VotingResult;\\n    \\n    // Vote end time\\n    uint256 internal voteEndTime;\\n    \\n    // Array to get voting data by votes_num\\n    uint256[] internal voteData;\\n    \\n    // Ids of owners struct\\n    struct OwnerId {\\n       \\n       // Owners Ids\\n        address ID;\\n        \\n        // Voted time\\n        uint256 voted_time;\\n     }\\n     \\n    // Owners Ids global values\\n    mapping(address =\\u003e OwnerId) internal owners;\\n    \\n    // Voing data base struct \\n    struct VotingDataBase {\\n        \\n        // Number of participants in the voting\\n        uint256 quorum_summ;\\n        \\n        // Voting result\\n        uint256 voting_result;\\n        \\n        // Voting start time\\n        uint256 voting_starts;\\n        \\n        // Voting end time\\n        uint256 voting_ends;\\n    }\\n    \\n    // Voting global values\\n    mapping (uint256 =\\u003e VotingDataBase) internal voteNum;\\n \\n \\t// Start of dividend payments\\n\\tuint256 public dividend_start;\\n\\t\\n\\t// end of dividend payments\\n\\tuint256 public dividend_end;\\n    \\n    // Amount of ether to pay dividents\\n    uint256 public treasuryBalance;\\n    \\n    // Time when token holder has received dividends\\n    uint256 internal LastWithdrawTime;\\n    \\n    // ID of dividend payments\\n    uint256 internal dividend_payment_Id;\\n\\n \\n    constructor () public{\\n       project_owner = msg.sender;\\n       FASList.push(project_owner);\\n       votes_num = 0;\\n       voting_period = 86400; \\n       owners[project_owner].ID = project_owner;\\n       Fas_number = 1;\\n       dividend_payment_Id = 0;\\n    }\\n    \\n    /** @dev Shows project_owner address\\n     * @return project owner address\\n    */\\n    \\n    function projectOwner() external view returns (address) { \\n        return project_owner;\\n    }\\n    \\n    /**@dev New member accepts the invitation of the Board of Directors.\\n    * param Owner_Id used to confirm your consent to the invitation\\n    * to the Board of Directors of the company valid for 24 hours.\\n    * if the Owner_Id is not used during the day, the invitation is canceled\\n    * \\u0027Owner_Id\\u0027 is deleted.\\n    * only a new member of the company\\u0027s Board of Directors has access to the function call\\n    */\\n   \\n    function acceptOwnership() external {\\n        require(this.checkOwner(msg.sender) == true, \\\"ACCESS DENIED\\\");\\n        require(msg.sender != project_owner, \\\"ACCESS DENIED\\\");\\n        uint256 time_accept = block.timestamp;\\n        difference_time = time_accept - acception_Id;\\n        if (difference_time \\u003c 86400){    \\n            FASList.push(msg.sender);\\n            Fas_number++;\\n            }\\n        else{\\n            delete owners[msg.sender];\\n        }\\n    }\\n    \\n    /**@dev Checking the owner in the list of owners\\n     * @return true or false\\n    */\\n    \\n    function checkOwner (address address_owner) public view returns (bool) {\\n        if(owners[address_owner].ID == address_owner || address_owner == temporary_address)\\n            return true;\\n        else {\\n            return false;\\n        }\\n    }\\n    \\n    /**@dev Removes a member from the company\\u0027s Board of Directors.\\n    * param address_owner this is the address of the Board member being \\n    * removed. Only the project owner has access to call the function. \\n    * The \\u0027project_owner\\u0027 cannot be deleted. \\n    */\\n    \\n    function delOwner (address address_owner) public {\\n        require(msg.sender == project_owner, \\\"ACCESS DENIED\\\");\\n        require (address_owner != project_owner, \\\"IT IS IMPOSSIBLE TO REMOVE PROJECT OWNER\\\");\\n        delete owners[address_owner];\\n        uint256 new_FASListLength = FASList.length;\\n        new_FASListLength--;\\n        uint256 index_array_del;\\n        address [] memory _FASList = new address[](new_FASListLength);\\n            for (uint256 j = 0; j\\u003c Fas_number; j++){\\n                if (FASList[j] == address_owner){\\n                    index_array_del = j;\\n                }\\n            }\\n            for (uint256 i = 0; i\\u003c new_FASListLength; i++){\\n                if (i \\u003c index_array_del){\\n                    _FASList[i] = FASList[i];\\n                }\\n                else\\n                {\\n                    _FASList[i] = FASList[i+1]; \\n                }\\n            }\\n        Fas_number--;\\n        FASList = _FASList;\\n    }\\n    \\n    /**@dev Shows addresses of company\\u0027s Owners\\n     * @return Owners_List a listing of addresses of the company\\u0027s Board of Directors\\n     */\\n    \\n    function getOwnersList() public view returns (address[] memory Owners_List){\\n        address[] memory _FASList = new address[](FASList.length);\\n        _FASList = FASList;\\n        return _FASList;\\n    }\\n\\n    /**@dev Shows number of Owners\\n     * @return number of members of the company\\u0027s Board of Directors\\n     */\\n\\n    function getNumOfOwners() public view returns (uint256 number){\\n        return Fas_number;\\n    }\\n \\n    /**Invitation of a new member of the company\\u0027s Board of Directors.\\n     * Only the project owner has access to the function call.\\n     * param _to address of the invited member of the company\\u0027s Board of Directors\\n     * A new member of the company\\u0027s Board of Directors receives \\u0027Owner_Id\\u0027.\\n     * Conditions in White Paper \\n    */\\n   \\n    function newOwnerInvite(address _new_owner) public {\\n        require(_new_owner != address(0));\\n        require(msg.sender == project_owner, \\\"ACCESS DENIED\\\");\\n        require(balances[_new_owner]\\u003e0, \\\"ZERO BALANCE\\\");\\n        require(owners[_new_owner].ID != _new_owner, \\\"ALREADY EXIST\\\");\\n        owners[_new_owner].ID = _new_owner;\\n        acception_Id = block.timestamp;\\n        temporary_address = _new_owner;\\n    }\\n\\n    /** @dev Function to start the voting process. Call access only project_owner. \\n     * Clears the previous result of the vote. Sets a time stamp for the \\n     * start of voting.\\n     * @return votes_num\\n     */\\n\\n   function createVote() public returns (uint256){\\n        require (msg.sender == project_owner, \\\"ACCESS DENIED\\\");\\n        uint256 current_time = block.timestamp;\\n        require(current_time \\u003e voteEndTime, \\\"CURRENT VOTING IS\\u0027N OVER YET\\\");\\n        votes_num = votes_num.add(1);\\n        vote_start = current_time;\\n        voteEndTime = vote_start.add(voting_period);\\n        voteResult_Agree = 0;\\n        voteResult_Dissagree = 0;\\n        quorum = 0;\\n        voteNum[votes_num].voting_starts = vote_start;\\n        voteNum[votes_num].voting_ends = voteEndTime;\\n        return votes_num;\\n    }\\n\\n    /**\\n    * vote for a given votes_num\\n    * param _vote_status_value uint256 the vote of status, 1 Agree, 0 Disagree\\n    * Only a member of the company\\u0027s Board of Directors has the right to vote.\\n    * You can only vote once during the voting period.\\n    * Votes are counted in proportion to the number of tokens.\\n    * If you did not participate in the voting your vote will be abstained.\\n    */\\n    \\n    function vote(uint256 _vote_status_value) public{\\n        require(_vote_status_value \\u003e= 0, \\\"INPUT: 1 = AGREE, 0 = DISAGREE\\\");\\n        require(_vote_status_value \\u003c= 1, \\\"INPUT: 1 = AGREE, 0 = DISAGREE\\\");\\n        uint256 voting_time = block.timestamp;\\n        require(owners[msg.sender].ID == msg.sender, \\\"ACCESS DENIED\\\");\\n        uint256 lastVotingOwnerCheck = voting_time.sub(owners[msg.sender].voted_time);\\n        require(voting_time \\u003c voteEndTime, \\\"THE VOTE IS ALREADY OVER\\\");\\n        require(voting_period \\u003c lastVotingOwnerCheck, \\\"YOU HAVE ALREADY VOTED\\\");\\n\\n        if(_vote_status_value == 0)\\n        {\\n            disagree = balances[msg.sender];\\n            voteResult_Dissagree = voteResult_Dissagree.add(disagree); \\n            owners[msg.sender].voted_time = voting_time;\\n        }\\n        if (_vote_status_value == 1)\\n        {\\n            agree = balances[msg.sender];\\n            voteResult_Agree = voteResult_Agree.add(agree); \\n            owners[msg.sender].voted_time = voting_time;\\n        }\\n\\n        quorum = voteResult_Agree.add(voteResult_Dissagree);\\n        voteNum[votes_num].quorum_summ = quorum;\\n    }\\n\\t/**\\n     * @dev Sows current voting process.\\n     * @return _votes_num\\n    */\\n    function currentVoting () public view returns (uint256 _votes_num, uint256 _quorum, uint256 _start_vote, uint256 _end_vote){\\n        return (votes_num, quorum, vote_start, voteEndTime);\\n    }\\n\\n    /**\\n    * @dev Called only after the end of the voting time.\\n    * @return the voting restult: vote_num, voteResult, quorum_summ, vote_start, vote_end\\n    */\\n   function getVoteResult() public returns (uint256 [] memory){\\n       uint256 current_time = block.timestamp;\\n       require (current_time \\u003e voteEndTime, \\\"THE VOTE ISN\\u0027T OVER YET\\\");\\n            if(voteResult_Agree \\u003e= voteResult_Dissagree)\\n            {\\n                voteResult = 1;\\n            }\\n\\n            if(voteResult_Agree \\u003c voteResult_Dissagree)\\n            {\\n                voteResult = 0;\\n            }\\n\\n        lastVoteResult = [votes_num, voteResult, quorum, vote_start, voteEndTime];\\n        voteNum[votes_num].voting_result = voteResult;\\n            return lastVoteResult;\\n   }\\n    \\n      /**\\n     * @dev Shows previous voting data\\n    * @return Ballot of all completed votes by \\u0027_voting_num\\u0027\\n    * output format \\u0027voting_result\\u0027, \\u0027quorum\\u0027, \\u0027voting_starts\\u0027, \\u0027voting_ends\\u0027.\\n    */\\n    \\n    function previousVoteResult() public view returns (uint256 vote_ID, uint256 Result, uint256 Quorum, uint256 Start, uint256 End){ \\n        vote_ID = lastVoteResult[0];\\n        Result = lastVoteResult[1];\\n        Quorum = lastVoteResult[2];\\n        Start = lastVoteResult[3];\\n        End = lastVoteResult[4];\\n        return (vote_ID, Result, Quorum, Start, End);\\n     }\\n\\n    /**\\n    * @dev Create array for previous voting data\\n    * @return Ballot of all completed votes by \\u0027_voting_num\\u0027\\n    * output format \\u0027voting_result\\u0027, \\u0027quorum\\u0027, \\u0027voting_starts\\u0027, \\u0027voting_ends\\u0027.\\n    */\\n\\n    function getVotingDataBase (uint256 _voting_num) public { \\n        voteData = [0, 0, 0, 0, 0];\\n        uint256 result = voteNum[_voting_num].voting_result;\\n        uint256 quorum_vote = voteNum[_voting_num].quorum_summ;\\n        uint256 start_vote = voteNum[_voting_num].voting_starts;\\n        uint256 end_vote = voteNum[_voting_num].voting_ends;\\n        voteData = [_voting_num, result, quorum_vote, start_vote, end_vote];\\n     }\\n     \\n     /**\\n    * @dev Shows result of previous voting data\\n    * @return Ballot of all completed votes by \\u0027_voting_num\\u0027\\n    * output format \\u0027vote_ID\\u0027, \\u0027Result\\u0027, \\u0027Quorum\\u0027, \\u0027Start\\u0027, \\u0027End\\u0027.\\n    */\\n    \\n    function showVotingDataBase () public view returns (uint256 vote_ID, uint256 Result, uint256 Quorum, uint256 Start, uint256 End){\\n        vote_ID = voteData[0];\\n        Result = voteData[1];\\n        Quorum = voteData[2];\\n        Start = voteData[3];\\n        End = voteData[4];\\n        return (vote_ID, Result, Quorum, Start, End);\\n    } \\n     \\n   \\t/**\\n\\t * @dev Set time of dividend Payments.\\n\\t * @return Start reward, End reward. The period for receiving \\n\\t * the reward is 30 days. Approved Fund of the Treasury for the payment of dividends. \\n\\t*/\\n\\tfunction dividendPaymentsTime (uint256 _start) public onlyOwner returns (uint256 Start_reward, uint256 End_reward)  {\\n\\t    uint256 check_time = block.timestamp;\\n\\t    require(check_time \\u003e dividend_end, \\\"CURRENT DIVIDEND PAYMENT IS\\u0027T OVER YET\\\"); \\n\\t    treasuryBalance = address(this).balance;\\n\\t    require(treasuryBalance \\u003e 0, \\\"BALANCE IS EMPTY\\\");\\n\\t    dividend_payment_Id = dividend_payment_Id.add(1);\\n\\t    require (check_time \\u003c _start, \\\"INCORRECT TIME, LESS CURRENT TIME\\\");\\n\\t    require (check_time \\u003c _start.add(2629743), \\\"ONE MONTH BEFORE THE START OF PAYMENTS\\\"); \\n\\t    dividend_start = _start;\\n        dividend_end = dividend_start.add(2629743);\\n        return (dividend_start, dividend_end);\\n\\t}  \\n\\t\\n    /**@dev Shows rest of treasuryBalance of ether on contract address\\n    * @return address(this).balance\\n    */\\n    function treasuryRest () public view returns (uint256){\\n        return address(this).balance; \\n }\\n    \\n    /*@dev call _token_owner address \\n\\t* @return Reward _dividend. The function can only be called \\n\\t* during the dividend payment period. \\n\\t* During the rest of the time, the function returns an error if \\n\\t* the Fund has a zero balance for paying dividends.\\n\\t* The minimum amount of tokens for receiving dividends is 30 tokens. \\n\\t* This allows you to get 0.001% of the treasury Fund.\\n\\t*/\\n\\tfunction reward (address token_holder) public view returns (uint256 Reward) {\\n        require(msg.sender != address(0));\\n        uint256 current_time = block.timestamp;\\n\\t    uint256 rest_treasury = treasuryRest();\\n        require(rest_treasury \\u003e 0, \\\"BALANCE IS EMPTY\\\");\\n        require(balances[token_holder] != 0, \\\"ZERO BALANCE\\\");\\n        require(holders[token_holder].payment_id \\u003c dividend_payment_Id, \\\"DIVIDENDS RECEIVED ALREADY\\\");\\n        require(holders[token_holder].dateCangeBalance \\u003c dividend_start, \\\"IT\\u0027S TO EARLY FOR RECEIVING DIVIDENDS\\\");\\n        require(current_time \\u003e dividend_start, \\\"TO EARLY\\\");\\n        require(current_time \\u003c dividend_end, \\\"TO LATE\\\");\\n        uint256 percentage_count = balances[token_holder];\\n        uint256 _percentage = percentage_count.mul(1000000).div(totalSupply);\\n        uint256 _dividend = treasuryBalance.mul(_percentage).div(1000000);\\n        return _dividend;\\n  }\\n\\t\\n\\t /** \\n    * Distribution of dividends.\\n    * IMPORTANT:\\n    * The time stamp of receipt of dividends in struct \\u0027Holder\\u0027 to \\u0027holders\\u0027 to \\n    * exclude multiple receipt of dividends, valid for 30 days.\\n    * Change balance of token owner it is not allowed during dividend payments \\n    * period for receiveng  dividends. Before changing token balance holder have\\n    * to receive dividends, else the execution of function will revert.\\n    * Dividends are received once during payment period. \\n    * Dividends are debited from the contract address by token owners PERSONALLY. \\n    * The contract balance is replenished with  ether depending on the results of the company\\u0027s work.\\n    */\\n    \\n    function withdrawDividend() external {\\n        uint256 dividend = this.reward(msg.sender);\\n        address pay_dividends = address(this);\\n        address payable token_holder = address (msg.sender);\\n        holders[msg.sender].payment_id = dividend_payment_Id;\\n            if (pay_dividends.balance \\u003e= dividend)\\n            token_holder.transfer(dividend);\\n  }  \\n    /**@dev accept Ether for dividend payments \\n     * onlly project_owner can deposit Ether on the contract balance\\n    */\\n    function depositEther() external payable{\\n        require(msg.sender == this.projectOwner(), \\\"ACCESS DENIED\\\");\\n        require(msg.sender.balance \\u003e msg.value);\\n     }  \\n         \\n    /* accept Ether\\n    *\\n    */\\n    function() external payable{\\n        this.depositEther();\\n        msg.sender.transfer(msg.value);\\n    }\\n    \\n}\"}}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_owner\",\"type\":\"address\"}],\"name\":\"checkOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createVote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentVoting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_votes_num\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_quorum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_start_vote\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end_vote\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_owner\",\"type\":\"address\"}],\"name\":\"delOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"}],\"name\":\"dividendPaymentsTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Start_reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"End_reward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividend_end\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividend_start\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumOfOwners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwnersList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"Owners_List\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getVoteResult\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_voting_num\",\"type\":\"uint256\"}],\"name\":\"getVotingDataBase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new_owner\",\"type\":\"address\"}],\"name\":\"newOwnerInvite\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"previousVoteResult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vote_ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Result\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Quorum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"End\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"projectOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_holder\",\"type\":\"address\"}],\"name\":\"reward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Reward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"showVotingDataBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vote_ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Result\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Quorum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"End\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasuryBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasuryRest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vote_status_value\",\"type\":\"uint256\"}],\"name\":\"vote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDividend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"VERCO","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://1367a4362465872382c74033396aa40c6e3cfaac6bfeb125386cba337b9b84f7"}]}