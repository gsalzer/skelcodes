{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.10 <0.6.0;\npragma experimental ABIEncoderV2;\n\n\ncontract Proxiable {\n    \n\n    function updateCodeAddress(address newAddress) internal {\n        require(\n            bytes32(\n                    0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7\n                ) ==\n                Proxiable(newAddress).proxiableUUID(),\n            \"Not compatible\"\n        );\n        assembly {\n            \n            sstore(\n                0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7,\n                newAddress\n            )\n        }\n    }\n    function proxiableUUID() public pure returns (bytes32) {\n        return\n            0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7;\n    }\n}\n\ncontract RTokenStructs {\n    \n    struct GlobalStats {\n        \n        uint256 totalSupply;\n        \n        uint256 totalSavingsAmount;\n    }\n\n\n    \n    struct AccountStatsView {\n        \n        uint256 hatID;\n        \n        uint256 rAmount;\n        \n        uint256 rInterest;\n        \n        uint256 lDebt;\n        \n        uint256 sInternalAmount;\n        \n        uint256 rInterestPayable;\n        \n        uint256 cumulativeInterest;\n    }\n\n    \n    struct AccountStatsStored {\n        \n        uint256 cumulativeInterest;\n    }\n\n    \n    struct HatStatsView {\n        \n        uint256 useCount;\n        \n        uint256 totalLoans;\n        \n        uint256 totalSavings;\n    }\n\n    \n    struct HatStatsStored {\n        \n        uint256 useCount;\n        \n        uint256 totalLoans;\n        \n        uint256 totalInternalSavings;\n    }\n\n    \n    struct Hat {\n        address[] recipients;\n        uint32[] proportions;\n    }\n\n    \n    struct Account {\n        uint256 hatID;\n        uint256 rAmount;\n        uint256 rInterest;\n        mapping(address => uint256) lRecipients;\n        uint256 lDebt;\n        uint256 sInternalAmount;\n    }\n}\n\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n\n    \n    function balanceOf(address account) external view returns (uint256);\n\n    \n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IAllocationStrategy {\n\n    \n    function underlying() external view returns (address);\n\n    \n    function exchangeRateStored() external view returns (uint256);\n\n    \n    function accrueInterest() external returns (bool);\n\n    \n    function investUnderlying(uint256 investAmount) external returns (uint256);\n\n    \n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    \n    function redeemAll() external returns (uint256 savingsAmount, uint256 underlyingAmount);\n\n}\n\ncontract RTokenStorage is RTokenStructs, IERC20 {\n    \n    address public _owner;\n    bool public initialized;\n    \n    uint256 public _guardCounter;\n    \n    string public name;\n    \n    string public symbol;\n    \n    uint256 public decimals;\n    \n    uint256 public totalSupply;\n    \n    IAllocationStrategy public ias;\n    \n    IERC20 public token;\n    \n    \n    uint256 public savingAssetOrignalAmount;\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    uint256 public savingAssetConversionRate;\n    \n    mapping(address => mapping(address => uint256)) public transferAllowances;\n    \n    Hat[] internal hats;\n    \n    mapping(address => Account) public accounts;\n    \n    mapping(address => AccountStatsStored) public accountStats;\n    \n    mapping(uint256 => HatStatsStored) public hatStats;\n}\n\ncontract Ownable is RTokenStorage {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    \n    constructor() internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    \n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    \n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    \n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    \n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    \n    function _transferOwnership(address newOwner) internal {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract LibraryLock is RTokenStorage {\n    \n    \n\n    modifier delegatedOnly() {\n        require(\n            initialized == true,\n            \"The library is locked. No direct 'call' is allowed.\"\n        );\n        _;\n    }\n    function initialize() internal {\n        initialized = true;\n    }\n}\n\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        \n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        \n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ncontract ReentrancyGuard is RTokenStorage {\n    \n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(\n            localCounter == _guardCounter,\n            \"ReentrancyGuard: reentrant call\"\n        );\n    }\n}\n\ncontract IRToken is RTokenStructs, IERC20 {\n    \n    \n    \n    \n    function mint(uint256 mintAmount) external returns (bool);\n\n    \n    function mintWithSelectedHat(uint256 mintAmount, uint256 hatID)\n        external\n        returns (bool);\n\n    \n    function mintWithNewHat(\n        uint256 mintAmount,\n        address[] calldata recipients,\n        uint32[] calldata proportions\n    ) external returns (bool);\n\n    \n    function transferAll(address dst) external returns (bool);\n\n    \n    function transferAllFrom(address src, address dst) external returns (bool);\n\n    \n    function redeem(uint256 redeemTokens) external returns (bool);\n\n    \n    function redeemAll() external returns (bool);\n\n    \n    function redeemAndTransfer(address redeemTo, uint256 redeemTokens)\n        external\n        returns (bool);\n\n    \n    function redeemAndTransferAll(address redeemTo) external returns (bool);\n\n    \n    function createHat(\n        address[] calldata recipients,\n        uint32[] calldata proportions,\n        bool doChangeHat\n    ) external returns (uint256 hatID);\n\n    \n    function changeHat(uint256 hatID) external returns (bool);\n\n    \n    function payInterest(address owner) external returns (bool);\n\n    \n    \n    \n    \n    function getMaximumHatID() external view returns (uint256 hatID);\n\n    \n    function getHatByAddress(address owner)\n        external\n        view\n        returns (\n            uint256 hatID,\n            address[] memory recipients,\n            uint32[] memory proportions\n        );\n\n    \n    function getHatByID(uint256 hatID)\n        external\n        view\n        returns (address[] memory recipients, uint32[] memory proportions);\n\n    \n    function receivedSavingsOf(address owner)\n        external\n        view\n        returns (uint256 amount);\n\n    \n    function receivedLoanOf(address owner)\n        external\n        view\n        returns (uint256 amount);\n\n    \n    function interestPayableOf(address owner)\n        external\n        view\n        returns (uint256 amount);\n\n    \n    \n    \n    \n    function getCurrentSavingStrategy() external view returns (address);\n\n    \n    function getSavingAssetBalance()\n        external\n        view\n        returns (uint256 rAmount, uint256 sOriginalAmount);\n\n    \n    function getGlobalStats() external view returns (GlobalStats memory);\n\n    \n    function getAccountStats(address owner)\n        external\n        view\n        returns (AccountStatsView memory);\n\n    \n    function getHatStats(uint256 hatID)\n        external\n        view\n        returns (HatStatsView memory);\n\n    \n    \n    \n    \n    event LoansTransferred(\n        address indexed owner,\n        address indexed recipient,\n        uint256 indexed hatId,\n        bool isDistribution,\n        uint256 redeemableAmount,\n        uint256 internalSavingsAmount);\n\n    \n    event InterestPaid(address indexed recipient, uint256 amount);\n\n    \n    event HatCreated(uint256 indexed hatID);\n\n    \n    event HatChanged(address indexed account, uint256 indexed oldHatID, uint256 indexed newHatID);\n}\n\ninterface IRTokenAdmin {\n\n    \n    function owner() external view returns (address);\n\n    \n    function transferOwnership(address newOwner) external;\n\n    \n    function getCurrentAllocationStrategy()\n        external view returns (address allocationStrategy);\n\n    \n    function changeAllocationStrategy(address allocationStrategy)\n        external;\n\n    \n    function changeHatFor(address contractAddress, uint256 hatID)\n        external;\n\n    \n    function updateCode(address newCode) external;\n\n    \n    event CodeUpdated(address newCode);\n\n    \n    event AllocationStrategyChanged(address strategy, uint256 conversionRate);\n}\n\ncontract RToken is\n    RTokenStorage,\n    IRToken,\n    IRTokenAdmin,\n    Ownable,\n    Proxiable,\n    LibraryLock,\n    ReentrancyGuard {\n    using SafeMath for uint256;\n\n\n    uint256 public constant ALLOCATION_STRATEGY_EXCHANGE_RATE_SCALE = 1e18;\n    uint256 public constant INITIAL_SAVING_ASSET_CONVERSION_RATE = 1e18;\n    uint256 public constant MAX_UINT256 = uint256(int256(-1));\n    uint256 public constant SELF_HAT_ID = MAX_UINT256;\n    uint32 public constant PROPORTION_BASE = 0xFFFFFFFF;\n    uint256 public constant MAX_NUM_HAT_RECIPIENTS = 50;\n\n    \n    function initialize(\n        IAllocationStrategy allocationStrategy,\n        string memory name_,\n        string memory symbol_,\n        uint256 decimals_) public {\n        require(!initialized, \"The library has already been initialized.\");\n        LibraryLock.initialize();\n        _owner = msg.sender;\n        _guardCounter = 1;\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n        savingAssetConversionRate = INITIAL_SAVING_ASSET_CONVERSION_RATE;\n        ias = allocationStrategy;\n        token = IERC20(ias.underlying());\n\n        \n        hats.push(Hat(new address[](0), new uint32[](0)));\n\n        \n        hatStats[0].useCount = MAX_UINT256;\n\n        emit AllocationStrategyChanged(address(ias), savingAssetConversionRate);\n    }\n\n    \n    \n    \n\n    \n    function balanceOf(address owner) external view returns (uint256) {\n        return accounts[owner].rAmount;\n    }\n\n    \n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256)\n    {\n        return transferAllowances[owner][spender];\n    }\n\n    \n    function approve(address spender, uint256 amount) external returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    \n    function transfer(address dst, uint256 amount)\n        external\n        nonReentrant\n        returns (bool)\n    {\n        address src = msg.sender;\n        payInterestInternal(src);\n        transferInternal(src, src, dst, amount);\n        payInterestInternal(dst);\n        return true;\n    }\n\n    \n    function transferAll(address dst) external nonReentrant returns (bool) {\n        address src = msg.sender;\n        payInterestInternal(src);\n        transferInternal(src, src, dst, accounts[src].rAmount);\n        payInterestInternal(dst);\n        return true;\n    }\n\n    \n    function transferAllFrom(address src, address dst)\n        external\n        nonReentrant\n        returns (bool)\n    {\n        payInterestInternal(src);\n        transferInternal(msg.sender, src, dst, accounts[src].rAmount);\n        payInterestInternal(dst);\n        return true;\n    }\n\n    \n    function transferFrom(address src, address dst, uint256 amount)\n        external\n        nonReentrant\n        returns (bool)\n    {\n        payInterestInternal(src);\n        transferInternal(msg.sender, src, dst, amount);\n        payInterestInternal(dst);\n        return true;\n    }\n\n    \n    \n    \n\n    \n    function mint(uint256 mintAmount) external nonReentrant returns (bool) {\n        mintInternal(mintAmount);\n        payInterestInternal(msg.sender);\n        return true;\n    }\n\n    \n    function mintWithSelectedHat(uint256 mintAmount, uint256 hatID)\n        external\n        nonReentrant\n        returns (bool)\n    {\n        changeHatInternal(msg.sender, hatID);\n        mintInternal(mintAmount);\n        payInterestInternal(msg.sender);\n        return true;\n    }\n\n    \n    function mintWithNewHat(\n        uint256 mintAmount,\n        address[] calldata recipients,\n        uint32[] calldata proportions\n    ) external nonReentrant returns (bool) {\n        uint256 hatID = createHatInternal(recipients, proportions);\n        changeHatInternal(msg.sender, hatID);\n        mintInternal(mintAmount);\n        payInterestInternal(msg.sender);\n        return true;\n    }\n\n    \n    function redeem(uint256 redeemTokens) external nonReentrant returns (bool) {\n        address src = msg.sender;\n        payInterestInternal(src);\n        redeemInternal(src, redeemTokens);\n        return true;\n    }\n\n    \n    function redeemAll() external nonReentrant returns (bool) {\n        address src = msg.sender;\n        payInterestInternal(src);\n        redeemInternal(src, accounts[src].rAmount);\n        return true;\n    }\n\n    \n    function redeemAndTransfer(address redeemTo, uint256 redeemTokens)\n        external\n        nonReentrant\n        returns (bool)\n    {\n        address src = msg.sender;\n        payInterestInternal(src);\n        redeemInternal(redeemTo, redeemTokens);\n        return true;\n    }\n\n    \n    function redeemAndTransferAll(address redeemTo)\n        external\n        nonReentrant\n        returns (bool)\n    {\n        address src = msg.sender;\n        payInterestInternal(src);\n        redeemInternal(redeemTo, accounts[src].rAmount);\n        return true;\n    }\n\n    \n    function createHat(\n        address[] calldata recipients,\n        uint32[] calldata proportions,\n        bool doChangeHat\n    ) external nonReentrant returns (uint256 hatID) {\n        hatID = createHatInternal(recipients, proportions);\n        if (doChangeHat) {\n            changeHatInternal(msg.sender, hatID);\n        }\n    }\n\n    \n    function changeHat(uint256 hatID) external nonReentrant returns (bool) {\n        changeHatInternal(msg.sender, hatID);\n        payInterestInternal(msg.sender);\n        return true;\n    }\n\n    \n    function getMaximumHatID() external view returns (uint256 hatID) {\n        return hats.length - 1;\n    }\n\n    \n    function getHatByAddress(address owner)\n        external\n        view\n        returns (\n            uint256 hatID,\n            address[] memory recipients,\n            uint32[] memory proportions\n        )\n    {\n        hatID = accounts[owner].hatID;\n        (recipients, proportions) = _getHatByID(hatID);\n    }\n\n    \n    function getHatByID(uint256 hatID)\n        external\n        view\n        returns (address[] memory recipients, uint32[] memory proportions) {\n        (recipients, proportions) = _getHatByID(hatID);\n    }\n\n    function _getHatByID(uint256 hatID)\n        private\n        view\n        returns (address[] memory recipients, uint32[] memory proportions) {\n        if (hatID != 0 && hatID != SELF_HAT_ID) {\n            Hat memory hat = hats[hatID];\n            recipients = hat.recipients;\n            proportions = hat.proportions;\n        } else {\n            recipients = new address[](0);\n            proportions = new uint32[](0);\n        }\n    }\n\n    \n    function receivedSavingsOf(address owner)\n        external\n        view\n        returns (uint256 amount)\n    {\n        Account storage account = accounts[owner];\n        uint256 rGross = sInternalToR(account.sInternalAmount);\n        return rGross;\n    }\n\n    \n    function receivedLoanOf(address owner)\n        external\n        view\n        returns (uint256 amount)\n    {\n        Account storage account = accounts[owner];\n        return account.lDebt;\n    }\n\n    \n    function interestPayableOf(address owner)\n        external\n        view\n        returns (uint256 amount)\n    {\n        Account storage account = accounts[owner];\n        return getInterestPayableOf(account);\n    }\n\n    \n    function payInterest(address owner) external nonReentrant returns (bool) {\n        payInterestInternal(owner);\n        return true;\n    }\n\n    \n    function getGlobalStats() external view returns (GlobalStats memory) {\n        uint256 totalSavingsAmount;\n        totalSavingsAmount += sOriginalToR(savingAssetOrignalAmount);\n        return\n            GlobalStats({\n                totalSupply: totalSupply,\n                totalSavingsAmount: totalSavingsAmount\n            });\n    }\n\n    \n    function getAccountStats(address owner)\n        external\n        view\n        returns (AccountStatsView memory stats)\n    {\n        Account storage account = accounts[owner];\n        stats.hatID = account.hatID;\n        stats.rAmount = account.rAmount;\n        stats.rInterest = account.rInterest;\n        stats.lDebt = account.lDebt;\n        stats.sInternalAmount = account.sInternalAmount;\n\n        stats.rInterestPayable = getInterestPayableOf(account);\n\n        AccountStatsStored storage statsStored = accountStats[owner];\n        stats.cumulativeInterest = statsStored.cumulativeInterest;\n\n        return stats;\n    }\n\n    \n    function getHatStats(uint256 hatID)\n        external\n        view\n        returns (HatStatsView memory stats) {\n        HatStatsStored storage statsStored = hatStats[hatID];\n        stats.useCount = statsStored.useCount;\n        stats.totalLoans = statsStored.totalLoans;\n\n        stats.totalSavings = sInternalToR(statsStored.totalInternalSavings);\n        return stats;\n    }\n\n    \n    function getCurrentSavingStrategy() external view returns (address) {\n        return address(ias);\n    }\n\n    \n    function getSavingAssetBalance()\n        external\n        view\n        returns (uint256 rAmount, uint256 sOriginalAmount)\n    {\n        sOriginalAmount = savingAssetOrignalAmount;\n        rAmount = sOriginalToR(sOriginalAmount);\n    }\n\n    \n    function changeAllocationStrategy(address allocationStrategy_)\n        external\n        nonReentrant\n        onlyOwner\n    {\n        IAllocationStrategy allocationStrategy = IAllocationStrategy(allocationStrategy_);\n        require(\n            allocationStrategy.underlying() == address(token),\n            \"New strategy should have the same underlying asset\"\n        );\n        IAllocationStrategy oldIas = ias;\n        ias = allocationStrategy;\n        \n        (uint256 sOriginalBurned, ) = oldIas.redeemAll();\n        uint256 totalAmount = token.balanceOf(address(this));\n        \n        require(token.approve(address(ias), totalAmount), \"token approve failed\");\n        uint256 sOriginalCreated = ias.investUnderlying(totalAmount);\n\n        \n        \n        \n        \n        \n        \n        \n        if (address(ias) != address(oldIas)) {\n            Ownable(address(oldIas)).transferOwnership(address(owner()));\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        uint256 savingAssetConversionRateOld = savingAssetConversionRate;\n        savingAssetConversionRate = sOriginalBurned\n            .mul(savingAssetConversionRateOld)\n            .div(sOriginalCreated);\n\n        emit AllocationStrategyChanged(allocationStrategy_, savingAssetConversionRate);\n    }\n\n    \n    function getCurrentAllocationStrategy()\n        external view returns (address allocationStrategy) {\n        return address(ias);\n    }\n\n    \n    function changeHatFor(address contractAddress, uint256 hatID) external onlyOwner {\n        require(_isContract(contractAddress), \"Admin can only change hat for contract address\");\n        changeHatInternal(contractAddress, hatID);\n    }\n\n    \n    function updateCode(address newCode) external onlyOwner delegatedOnly {\n        updateCodeAddress(newCode);\n        emit CodeUpdated(newCode);\n    }\n\n    \n    function transferInternal(\n        address spender,\n        address src,\n        address dst,\n        uint256 tokens\n    ) internal {\n        require(src != dst, \"src should not equal dst\");\n\n        require(\n            accounts[src].rAmount >= tokens,\n            \"Not enough balance to transfer\"\n        );\n\n        \n        uint256 startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = MAX_UINT256;\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n        require(\n            startingAllowance >= tokens,\n            \"Not enough allowance for transfer\"\n        );\n\n        \n        uint256 allowanceNew = startingAllowance.sub(tokens);\n        uint256 srcTokensNew = accounts[src].rAmount.sub(tokens);\n        uint256 dstTokensNew = accounts[dst].rAmount.add(tokens);\n\n        \n        \n        \n\n        \n        bool sameHat = accounts[src].hatID == accounts[dst].hatID;\n\n        \n        if ((accounts[src].hatID != 0 &&\n            accounts[dst].hatID == 0 &&\n            accounts[src].hatID != SELF_HAT_ID)) {\n            changeHatInternal(dst, accounts[src].hatID);\n        }\n\n        accounts[src].rAmount = srcTokensNew;\n        accounts[dst].rAmount = dstTokensNew;\n\n        \n        if (startingAllowance != MAX_UINT256) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        \n        if (!sameHat) {\n            uint256 sInternalAmountCollected = estimateAndRecollectLoans(\n                src,\n                tokens\n            );\n            distributeLoans(dst, tokens, sInternalAmountCollected);\n        } else {\n            \n            sameHatTransfer(src, dst, accounts[src].hatID, tokens);\n        }\n\n        \n        \n        \n        \n        \n        if (accounts[src].rInterest > accounts[src].rAmount) {\n            accounts[src].rInterest = accounts[src].rAmount;\n        }\n\n        \n        emit Transfer(src, dst, tokens);\n    }\n\n    \n    function mintInternal(uint256 mintAmount) internal {\n        require(\n            token.allowance(msg.sender, address(this)) >= mintAmount,\n            \"Not enough allowance\"\n        );\n\n        Account storage account = accounts[msg.sender];\n\n        \n        require(token.transferFrom(msg.sender, address(this), mintAmount), \"token transfer failed\");\n        require(token.approve(address(ias), mintAmount), \"token approve failed\");\n        uint256 sOriginalCreated = ias.investUnderlying(mintAmount);\n\n        \n        totalSupply = totalSupply.add(mintAmount);\n        account.rAmount = account.rAmount.add(mintAmount);\n\n        \n        savingAssetOrignalAmount = savingAssetOrignalAmount.add(sOriginalCreated);\n\n        \n        uint256 sInternalCreated = sOriginalToSInternal(sOriginalCreated);\n        distributeLoans(msg.sender, mintAmount, sInternalCreated);\n\n        emit Transfer(address(0), msg.sender, mintAmount);\n    }\n\n    \n    function redeemInternal(address redeemTo, uint256 redeemAmount) internal {\n        Account storage account = accounts[msg.sender];\n        require(redeemAmount > 0, \"Redeem amount cannot be zero\");\n        require(\n            redeemAmount <= account.rAmount,\n            \"Not enough balance to redeem\"\n        );\n\n        uint256 sOriginalBurned = redeemAndRecollectLoans(\n            msg.sender,\n            redeemAmount\n        );\n\n        \n        account.rAmount = account.rAmount.sub(redeemAmount);\n        if (account.rInterest > account.rAmount) {\n            account.rInterest = account.rAmount;\n        }\n        totalSupply = totalSupply.sub(redeemAmount);\n\n        \n        if (savingAssetOrignalAmount > sOriginalBurned) {\n            savingAssetOrignalAmount -= sOriginalBurned;\n        } else {\n            savingAssetOrignalAmount = 0;\n        }\n\n        \n        require(token.transfer(redeemTo, redeemAmount), \"token transfer failed\");\n\n        emit Transfer(msg.sender, address(0), redeemAmount);\n    }\n\n    \n    function createHatInternal(\n        address[] memory recipients,\n        uint32[] memory proportions\n    ) internal returns (uint256 hatID) {\n        uint256 i;\n\n        require(recipients.length > 0, \"Invalid hat: at least one recipient\");\n        require(recipients.length <= MAX_NUM_HAT_RECIPIENTS, \"Invalild hat: maximum number of recipients reached\");\n        require(\n            recipients.length == proportions.length,\n            \"Invalid hat: length not matching\"\n        );\n\n        \n        \n        \n        uint256 totalProportions = 0;\n        for (i = 0; i < recipients.length; ++i) {\n            require(\n                proportions[i] > 0,\n                \"Invalid hat: proportion should be larger than 0\"\n            );\n            require(recipients[i] != address(0), \"Invalid hat: recipient should not be 0x0\");\n            \n            totalProportions += uint256(proportions[i]);\n        }\n        for (i = 0; i < proportions.length; ++i) {\n            proportions[i] = uint32(\n                \n                (uint256(proportions[i]) * uint256(PROPORTION_BASE)) /\n                    totalProportions\n            );\n        }\n\n        hatID = hats.push(Hat(recipients, proportions)) - 1;\n        emit HatCreated(hatID);\n    }\n\n    \n    function changeHatInternal(address owner, uint256 hatID) internal {\n        require(hatID == SELF_HAT_ID || hatID < hats.length, \"Invalid hat ID\");\n        Account storage account = accounts[owner];\n        uint256 oldHatID = account.hatID;\n        HatStatsStored storage oldHatStats = hatStats[oldHatID];\n        HatStatsStored storage newHatStats = hatStats[hatID];\n        if (account.rAmount > 0) {\n            uint256 sInternalAmountCollected = estimateAndRecollectLoans(\n                owner,\n                account.rAmount\n            );\n            account.hatID = hatID;\n            distributeLoans(owner, account.rAmount, sInternalAmountCollected);\n        } else {\n            account.hatID = hatID;\n        }\n        oldHatStats.useCount -= 1;\n        newHatStats.useCount += 1;\n        emit HatChanged(owner, oldHatID, hatID);\n    }\n\n    \n    function getInterestPayableOf(Account storage account)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 rGross = sInternalToR(account.sInternalAmount);\n        if (rGross > (account.lDebt.add(account.rInterest))) {\n            \n            return rGross - account.lDebt - account.rInterest;\n        } else {\n            \n            return 0;\n        }\n    }\n\n    \n    function distributeLoans(\n        address owner,\n        uint256 rAmount,\n        uint256 sInternalAmount\n    ) internal {\n        Account storage account = accounts[owner];\n        Hat storage hat = hats[account.hatID == SELF_HAT_ID\n            ? 0\n            : account.hatID];\n        uint256 i;\n        if (hat.recipients.length > 0) {\n            uint256 rLeft = rAmount;\n            uint256 sInternalLeft = sInternalAmount;\n            for (i = 0; i < hat.proportions.length; ++i) {\n                address recipientAddress = hat.recipients[i];\n                Account storage recipientAccount = accounts[recipientAddress];\n                bool isLastRecipient = i == (hat.proportions.length - 1);\n\n                \n                uint256 lDebtRecipient = isLastRecipient\n                    ? rLeft\n                    : (rAmount.mul(hat.proportions[i])) / PROPORTION_BASE;\n                \n                account.lRecipients[recipientAddress] = account.lRecipients[recipientAddress]\n                    .add(lDebtRecipient);\n                recipientAccount.lDebt = recipientAccount.lDebt\n                    .add(lDebtRecipient);\n                \n                rLeft = gentleSub(rLeft, lDebtRecipient);\n\n                \n                uint256 sInternalAmountRecipient = isLastRecipient\n                    ? sInternalLeft\n                    : (sInternalAmount.mul(hat.proportions[i])) / PROPORTION_BASE;\n                recipientAccount.sInternalAmount = recipientAccount.sInternalAmount\n                    .add(sInternalAmountRecipient);\n                \n                sInternalLeft = gentleSub(sInternalLeft, sInternalAmountRecipient);\n\n                _updateLoanStats(owner, recipientAddress, account.hatID, true, lDebtRecipient, sInternalAmountRecipient);\n            }\n        } else {\n            \n            account.lDebt = account.lDebt.add(rAmount);\n            account.sInternalAmount = account.sInternalAmount\n                .add(sInternalAmount);\n\n            _updateLoanStats(owner, owner, account.hatID, true, rAmount, sInternalAmount);\n        }\n    }\n\n    \n    function estimateAndRecollectLoans(address owner, uint256 rAmount)\n        internal\n        returns (uint256 sInternalAmount)\n    {\n        \n        require(ias.accrueInterest(), \"accrueInterest failed\");\n        sInternalAmount = rToSInternal(rAmount);\n        recollectLoans(owner, rAmount, sInternalAmount);\n    }\n\n    \n    function redeemAndRecollectLoans(address owner, uint256 rAmount)\n        internal\n        returns (uint256 sOriginalBurned)\n    {\n        sOriginalBurned = ias.redeemUnderlying(rAmount);\n        uint256 sInternalBurned = sOriginalToSInternal(sOriginalBurned);\n        recollectLoans(owner, rAmount, sInternalBurned);\n    }\n\n    \n    function recollectLoans(\n        address owner,\n        uint256 rAmount,\n        uint256 sInternalAmount\n    ) internal {\n        Account storage account = accounts[owner];\n        Hat storage hat = hats[account.hatID == SELF_HAT_ID\n            ? 0\n            : account.hatID];\n        if (hat.recipients.length > 0) {\n            uint256 rLeft = rAmount;\n            uint256 sInternalLeft = sInternalAmount;\n            uint256 i;\n            for (i = 0; i < hat.proportions.length; ++i) {\n                address recipientAddress = hat.recipients[i];\n                Account storage recipientAccount = accounts[recipientAddress];\n                bool isLastRecipient = i == (hat.proportions.length - 1);\n\n                \n                uint256 lDebtRecipient = isLastRecipient\n                    ? rLeft\n                    : (rAmount.mul(hat.proportions[i])) / PROPORTION_BASE;\n                recipientAccount.lDebt = gentleSub(\n                    recipientAccount.lDebt,\n                    lDebtRecipient);\n                account.lRecipients[recipientAddress] = gentleSub(\n                    account.lRecipients[recipientAddress],\n                    lDebtRecipient);\n                \n                rLeft = gentleSub(rLeft, lDebtRecipient);\n\n                \n                uint256 sInternalAmountRecipient = isLastRecipient\n                    ? sInternalLeft\n                    : (sInternalAmount.mul(hat.proportions[i])) / PROPORTION_BASE;\n                recipientAccount.sInternalAmount = gentleSub(\n                    recipientAccount.sInternalAmount,\n                    sInternalAmountRecipient);\n                \n                sInternalLeft = gentleSub(sInternalLeft, sInternalAmountRecipient);\n\n                _updateLoanStats(owner, recipientAddress, account.hatID, false, lDebtRecipient, sInternalAmountRecipient);\n            }\n        } else {\n            \n            account.lDebt = gentleSub(account.lDebt, rAmount);\n            account.sInternalAmount = gentleSub(account.sInternalAmount, sInternalAmount);\n\n            _updateLoanStats(owner, owner, account.hatID, false, rAmount, sInternalAmount);\n        }\n    }\n\n    \n    function sameHatTransfer(\n        address src,\n        address dst,\n        uint256 hatID,\n        uint256 rAmount) internal {\n        \n        require(ias.accrueInterest(), \"accrueInterest failed\");\n\n        Account storage srcAccount = accounts[src];\n        Account storage dstAccount = accounts[dst];\n\n        uint256 sInternalAmount = rToSInternal(rAmount);\n\n        srcAccount.lDebt = gentleSub(srcAccount.lDebt, rAmount);\n        srcAccount.sInternalAmount = gentleSub(srcAccount.sInternalAmount, sInternalAmount);\n        _updateLoanStats(src, src, hatID, false, rAmount, sInternalAmount);\n\n        dstAccount.lDebt = dstAccount.lDebt.add(rAmount);\n        dstAccount.sInternalAmount = dstAccount.sInternalAmount.add(sInternalAmount);\n        _updateLoanStats(dst, dst, hatID, true, rAmount, sInternalAmount);\n    }\n\n    \n    function payInterestInternal(address owner) internal {\n        Account storage account = accounts[owner];\n        AccountStatsStored storage stats = accountStats[owner];\n\n        require(ias.accrueInterest(), \"accrueInterest failed\");\n        uint256 interestAmount = getInterestPayableOf(account);\n\n        if (interestAmount > 0) {\n            stats.cumulativeInterest = stats\n                .cumulativeInterest\n                .add(interestAmount);\n            account.rInterest = account.rInterest.add(interestAmount);\n            account.rAmount = account.rAmount.add(interestAmount);\n            totalSupply = totalSupply.add(interestAmount);\n            emit InterestPaid(owner, interestAmount);\n            emit Transfer(address(0), owner, interestAmount);\n        }\n    }\n\n    function _updateLoanStats(\n        address owner,\n        address recipient,\n        uint256 hatID,\n        bool isDistribution,\n        uint256 redeemableAmount,\n        uint256 sInternalAmount) private {\n        HatStatsStored storage hatStats = hatStats[hatID];\n\n        emit LoansTransferred(owner, recipient, hatID,\n            isDistribution,\n            redeemableAmount,\n            sInternalAmount);\n\n        if (isDistribution) {\n            hatStats.totalLoans = hatStats.totalLoans.add(redeemableAmount);\n            hatStats.totalInternalSavings = hatStats.totalInternalSavings\n                .add(sInternalAmount);\n        } else {\n            hatStats.totalLoans = gentleSub(hatStats.totalLoans, redeemableAmount);\n            hatStats.totalInternalSavings = gentleSub(\n                hatStats.totalInternalSavings,\n                sInternalAmount);\n        }\n    }\n\n    function _isContract(address addr) private view returns (bool) {\n      uint size;\n      assembly { size := extcodesize(addr) }\n      return size > 0;\n    }\n\n    \n    function gentleSub(uint256 a, uint256 b) private pure returns (uint256) {\n        if (a < b) return 0;\n        else return a - b;\n    }\n\n    \n    function sInternalToR(uint256 sInternalAmount)\n        private view\n        returns (uint256 rAmount) {\n        \n        \n        \n        \n        \n        \n        \n        return sInternalAmount\n            .mul(ias.exchangeRateStored())\n            .div(savingAssetConversionRate);\n    }\n\n    \n    function rToSInternal(uint256 rAmount)\n        private view\n        returns (uint256 sInternalAmount) {\n        return rAmount\n            .mul(savingAssetConversionRate)\n            .div(ias.exchangeRateStored());\n    }\n\n    \n    function sOriginalToR(uint sOriginalAmount)\n        private view\n        returns (uint256 sInternalAmount) {\n        return sOriginalAmount\n            .mul(ias.exchangeRateStored())\n            .div(ALLOCATION_STRATEGY_EXCHANGE_RATE_SCALE);\n    }\n\n    \n    function sOriginalToSInternal(uint sOriginalAmount)\n        private view\n        returns (uint256 sInternalAmount) {\n        \n        return sOriginalAmount\n            .mul(savingAssetConversionRate)\n            .div(ALLOCATION_STRATEGY_EXCHANGE_RATE_SCALE);\n    }\n}\n\ncontract rDAI is RToken {\n\n    function initialize (\n        IAllocationStrategy allocationStrategy) external {\n        RToken.initialize(allocationStrategy,\n            \"Redeemable DAI\",\n            \"rDAI\",\n            18);\n    }\n\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"conversionRate\",\"type\":\"uint256\"}],\"name\":\"AllocationStrategyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newCode\",\"type\":\"address\"}],\"name\":\"CodeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldHatID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newHatID\",\"type\":\"uint256\"}],\"name\":\"HatChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"HatCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InterestPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"hatId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isDistribution\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemableAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"internalSavingsAmount\",\"type\":\"uint256\"}],\"name\":\"LoansTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"ALLOCATION_STRATEGY_EXCHANGE_RATE_SCALE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_SAVING_ASSET_CONVERSION_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_NUM_HAT_RECIPIENTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_UINT256\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROPORTION_BASE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SELF_HAT_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_guardCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cumulativeInterest\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sInternalAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"allocationStrategy_\",\"type\":\"address\"}],\"name\":\"changeAllocationStrategy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"changeHat\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"changeHatFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"proportions\",\"type\":\"uint32[]\"},{\"internalType\":\"bool\",\"name\":\"doChangeHat\",\"type\":\"bool\"}],\"name\":\"createHat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getAccountStats\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sInternalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rInterestPayable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cumulativeInterest\",\"type\":\"uint256\"}],\"internalType\":\"struct RTokenStructs.AccountStatsView\",\"name\":\"stats\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentAllocationStrategy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"allocationStrategy\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentSavingStrategy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGlobalStats\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSavingsAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct RTokenStructs.GlobalStats\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getHatByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"proportions\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"getHatByID\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"proportions\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"getHatStats\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"useCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLoans\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSavings\",\"type\":\"uint256\"}],\"internalType\":\"struct RTokenStructs.HatStatsView\",\"name\":\"stats\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMaximumHatID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSavingAssetBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sOriginalAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hatStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"useCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLoans\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInternalSavings\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ias\",\"outputs\":[{\"internalType\":\"contract IAllocationStrategy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IAllocationStrategy\",\"name\":\"allocationStrategy\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals_\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IAllocationStrategy\",\"name\":\"allocationStrategy\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"interestPayableOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"proportions\",\"type\":\"uint32[]\"}],\"name\":\"mintWithNewHat\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"mintWithSelectedHat\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"payInterest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"receivedLoanOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"receivedSavingsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"redeemAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"redeemTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"redeemAndTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"redeemTo\",\"type\":\"address\"}],\"name\":\"redeemAndTransferAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"savingAssetConversionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"savingAssetOrignalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"transferAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"transferAllFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"transferAllowances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCode\",\"type\":\"address\"}],\"name\":\"updateCode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"rDAI","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://f283024c9e16d45c5cfcba13e0ef7e0ef250b5afbdc65bcdd55ebbd1f45c1ff8"}]}