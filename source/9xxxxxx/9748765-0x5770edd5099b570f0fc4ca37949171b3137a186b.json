{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11; // optimization runs: 200, evm version: petersburg\r\n\r\n\r\ninterface DharmaTransferFacilitatorInterface {\r\n  event RoleModified(Role indexed role, address account);\r\n  event RolePaused(Role indexed role);\r\n  event RoleUnpaused(Role indexed role);\r\n\r\n  enum Role {\r\n    TRANSFERRER,\r\n    PAUSER\r\n  }\r\n\r\n  struct RoleStatus {\r\n    address account;\r\n    bool paused;\r\n  }\r\n\r\n  function enactDDaiTransfer(\r\n    address senderSmartWallet,\r\n    address recipientInitialSigningKey, // the receiver's key ring\r\n    address recipientSmartWallet,\r\n    uint256 value,\r\n    uint256 expiration,\r\n    bytes32 salt,\r\n    bytes calldata signatures\r\n  ) external;\r\n\r\n  function deploySenderWalletAndEnactDDaiTransfer(\r\n    address senderInitialSigningKey, // the sender's key ring\r\n    address senderSmartWallet,\r\n    address recipientInitialSigningKey, // the receiver's key ring\r\n    address recipientSmartWallet,\r\n    uint256 value,\r\n    uint256 expiration,\r\n    bytes32 salt,\r\n    bytes calldata signatures\r\n  ) external;\r\n\r\n  function deploySenderKeyRingAndEnactDDaiTransfer(\r\n    address senderInitialKeyRingSigningKey, // initial key on sender's key ring\r\n    address senderKeyRing, // the sender's key ring\r\n    address senderSmartWallet,\r\n    address recipientInitialSigningKey, // the receiver's key ring\r\n    address recipientSmartWallet,\r\n    uint256 value,\r\n    uint256 expiration,\r\n    bytes32 salt,\r\n    bytes calldata signatures\r\n  ) external;\r\n  \r\n  function deploySenderKeyRingAndWalletAndEnactDDaiTransfer(\r\n    address senderInitialKeyRingSigningKey, // initial key on sender's key ring\r\n    address senderKeyRing, // the sender's key ring\r\n    address senderSmartWallet,\r\n    address recipientInitialSigningKey, // the receiver's key ring\r\n    address recipientSmartWallet,\r\n    uint256 value,\r\n    uint256 expiration,\r\n    bytes32 salt,\r\n    bytes calldata signatures\r\n  ) external;\r\n\r\n  function withdraw(\r\n    ERC20Interface token, address recipient, uint256 amount\r\n  ) external returns (bool success);\r\n\r\n  function callGeneric(\r\n    address payable target, uint256 amount, bytes calldata data\r\n  ) external returns (bool ok, bytes memory returnData);\r\n  \r\n  function setLimit(uint256 daiAmount) external;\r\n\r\n  function setRole(Role role, address account) external;\r\n\r\n  function removeRole(Role role) external;\r\n\r\n  function pause(Role role) external;\r\n\r\n  function unpause(Role role) external;\r\n\r\n  function isPaused(Role role) external view returns (bool paused);\r\n\r\n  function isRole(Role role) external view returns (bool hasRole);\r\n\r\n  function getTransferrer() external view returns (address transferrer);\r\n\r\n  function getPauser() external view returns (address pauser);\r\n  \r\n  function getLimit() external view returns (\r\n    uint256 daiAmount, uint256 dDaiAmount\r\n  );\r\n\r\n  function isDharmaSmartWallet(\r\n    address smartWallet, address initialUserSigningKey\r\n  ) external pure returns (bool dharmaSmartWallet);\r\n}\r\n\r\n\r\ninterface ERC20Interface {\r\n  function balanceOf(address) external view returns (uint256);\r\n  function approve(address, uint256) external returns (bool);\r\n  function transfer(address, uint256) external returns (bool);\r\n}\r\n\r\n\r\ninterface DTokenInterface {\r\n  function transferFrom(\r\n    address sender, address recipient, uint256 amount\r\n  ) external returns (bool success);\r\n  function modifyAllowanceViaMetaTransaction(\r\n    address owner,\r\n    address spender,\r\n    uint256 value,\r\n    bool increase,\r\n    uint256 expiration,\r\n    bytes32 salt,\r\n    bytes calldata signatures\r\n  ) external returns (bool success);\r\n  function approve(address, uint256) external returns (bool);\r\n\r\n  function exchangeRateCurrent() external view returns (uint256);\r\n  function getMetaTransactionMessageHash(\r\n    bytes4 functionSelector,\r\n    bytes calldata arguments,\r\n    uint256 expiration,\r\n    bytes32 salt\r\n  ) external view returns (bytes32 digest, bool valid);\r\n  function allowance(address, address) external view returns (uint256);\r\n}\r\n\r\n\r\ninterface DharmaSmartWalletFactoryV1Interface {\r\n  function newSmartWallet(\r\n    address userSigningKey\r\n  ) external returns (address wallet);\r\n  \r\n  function getNextSmartWallet(\r\n    address userSigningKey\r\n  ) external view returns (address wallet);\r\n}\r\n\r\n\r\ninterface DharmaKeyRingFactoryV2Interface {\r\n  function newKeyRing(\r\n    address userSigningKey, address targetKeyRing\r\n  ) external returns (address keyRing);\r\n\r\n  function getNextKeyRing(\r\n    address userSigningKey\r\n  ) external view returns (address targetKeyRing);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) return 0;\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0, \"SafeMath: division by zero\");\r\n    return a / b;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n *\r\n * In order to transfer ownership, a recipient must be specified, at which point\r\n * the specified recipient can call `acceptOwnership` and take ownership.\r\n */\r\ncontract TwoStepOwnable {\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  address private _owner;\r\n\r\n  address private _newPotentialOwner;\r\n\r\n  /**\r\n   * @dev Initialize contract by setting transaction submitter as initial owner.\r\n   */\r\n  constructor() internal {\r\n    _owner = tx.origin;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows a new account (`newOwner`) to accept ownership.\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) external onlyOwner {\r\n    require(\r\n      newOwner != address(0),\r\n      \"TwoStepOwnable: new potential owner is the zero address.\"\r\n    );\r\n\r\n    _newPotentialOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Cancel a transfer of ownership to a new account.\r\n   * Can only be called by the current owner.\r\n   */\r\n  function cancelOwnershipTransfer() external onlyOwner {\r\n    delete _newPotentialOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to the caller.\r\n   * Can only be called by a new potential owner set by the current owner.\r\n   */\r\n  function acceptOwnership() external {\r\n    require(\r\n      msg.sender == _newPotentialOwner,\r\n      \"TwoStepOwnable: current owner must set caller as new potential owner.\"\r\n    );\r\n\r\n    delete _newPotentialOwner;\r\n\r\n    emit OwnershipTransferred(_owner, msg.sender);\r\n\r\n    _owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() external view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the caller is the current owner.\r\n   */\r\n  function isOwner() public view returns (bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner(), \"TwoStepOwnable: caller is not the owner.\");\r\n    _;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title DharmaTransferFacilitatorV2\r\n * @author 0age\r\n * @notice This contract is owned by Dharma and used to facilitate peer-to-peer\r\n * payments on the platform. It designates a collection of \"roles\" - these\r\n * are dedicated accounts that can be modified by the owner, and that can\r\n * trigger specific functionality on the contract. These roles are:\r\n *  - transferrer (0): initiates token transfers between smart wallets by\r\n      designating a recipient and transferring on behalf of the sender \r\n *  - pauser (1): pauses any role (only the owner is then able to unpause it)\r\n *\r\n * When making transfers, the transferrer must adhere to two constraints:\r\n *  - it must provide \"proof\" that the recipient is a smart wallet by including\r\n *    the initial user signing key used to derive the smart wallet address\r\n *  - it must not attempt to transfer more Dai, or more than the Dai-equivalent\r\n *    value of Dharma Dai, than the current \"limit\" set by the owner.\r\n *\r\n * Smart wallet \"proofs\" can be validated via `isSmartWallet`.\r\n */\r\ncontract DharmaTransferFacilitatorV2 is\r\n  DharmaTransferFacilitatorInterface, TwoStepOwnable {\r\n  using SafeMath for uint256;\r\n\r\n  // Maintain a role status mapping with assigned accounts and paused states.\r\n  mapping(uint256 => RoleStatus) private _roles;\r\n  \r\n  // Maintain a maximum allowable transfer size (in Dai) for the transferrer.\r\n  uint256 private _limit;\r\n\r\n  // This contract interacts with Dai and Dharma Dai.\r\n  ERC20Interface internal constant _DAI = ERC20Interface(\r\n    0x6B175474E89094C44Da98b954EedeAC495271d0F // mainnet\r\n  );\r\n\r\n  DTokenInterface internal constant _DDAI = DTokenInterface(\r\n    0x00000000001876eB1444c986fD502e618c587430\r\n  );\r\n\r\n  // The \"Create2 Header\" is used to compute smart wallet deployment addresses.\r\n  bytes21 internal constant _CREATE2_HEADER = bytes21(\r\n    0xfffc00c80b0000007f73004edb00094cad80626d8d // control character + factory\r\n  );\r\n  \r\n  // The \"Wallet creation code\" header & footer are also used to derive wallets.\r\n  bytes internal constant _WALLET_CREATION_CODE_HEADER = hex\"60806040526040516104423803806104428339818101604052602081101561002657600080fd5b810190808051604051939291908464010000000082111561004657600080fd5b90830190602082018581111561005b57600080fd5b825164010000000081118282018810171561007557600080fd5b82525081516020918201929091019080838360005b838110156100a257818101518382015260200161008a565b50505050905090810190601f1680156100cf5780820380516001836020036101000a031916815260200191505b5060405250505060006100e661019e60201b60201c565b6001600160a01b0316826040518082805190602001908083835b6020831061011f5780518252601f199092019160209182019101610100565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855af49150503d806000811461017f576040519150601f19603f3d011682016040523d82523d6000602084013e610184565b606091505b5050905080610197573d6000803e3d6000fd5b50506102be565b60405160009081906060906e26750c571ce882b17016557279adaa9083818181855afa9150503d80600081146101f0576040519150601f19603f3d011682016040523d82523d6000602084013e6101f5565b606091505b509150915081819061029f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360005b8381101561026457818101518382015260200161024c565b50505050905090810190601f1680156102915780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b508080602001905160208110156102b557600080fd5b50519392505050565b610175806102cd6000396000f3fe608060405261001461000f610016565b61011c565b005b60405160009081906060906e26750c571ce882b17016557279adaa9083818181855afa9150503d8060008114610068576040519150601f19603f3d011682016040523d82523d6000602084013e61006d565b606091505b50915091508181906100fd5760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b838110156100c25781810151838201526020016100aa565b50505050905090810190601f1680156100ef5780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b5080806020019051602081101561011357600080fd5b50519392505050565b3660008037600080366000845af43d6000803e80801561013b573d6000f35b3d6000fdfea265627a7a7231582020202020202055706772616465426561636f6e50726f7879563120202020202064736f6c634300050b003200000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000024c4d66de8000000000000000000000000\";\r\n  bytes28 internal constant _WALLET_CREATION_CODE_FOOTER = bytes28(\r\n    0x00000000000000000000000000000000000000000000000000000000\r\n  );\r\n\r\n  DharmaSmartWalletFactoryV1Interface internal constant _WALLET_FACTORY = (\r\n    DharmaSmartWalletFactoryV1Interface(\r\n      0xfc00C80b0000007F73004edB00094caD80626d8D\r\n    )\r\n  );\r\n  \r\n  DharmaKeyRingFactoryV2Interface internal constant _KEYRING_FACTORY = (\r\n    DharmaKeyRingFactoryV2Interface(\r\n      0x2484000059004afB720000dc738434fA6200F49D\r\n    )\r\n  );\r\n\r\n  // Use the smart wallet instance runtime code hash to verify expected targets.\r\n  bytes32 internal constant _SMART_WALLET_INSTANCE_RUNTIME_HASH = bytes32(\r\n    0xe25d4f154acb2394ee6c18d64fb5635959ba063d57f83091ec9cf34be16224d7\r\n  );\r\n\r\n  // The keyring instance runtime code hash is used to verify expected targets.\r\n  bytes32 internal constant _KEY_RING_INSTANCE_RUNTIME_HASH = bytes32(\r\n    0xb15b24278e79e856d35b262e76ff7d3a759b17e625ff72adde4116805af59648\r\n  );\r\n\r\n  /**\r\n   * @notice In the constructor, set the initial owner to the transaction\r\n   * submitter and cap the size of transfers to 300 dai worth of dDai.\r\n   */\r\n  constructor() public {    \r\n    // Set the initial limit to 300 Dai.\r\n    _limit = 300 * 1e18;\r\n  }\r\n\r\n  /**\r\n   * @notice Prove that `recipientSmartWallet` is a Dharma smart wallet address\r\n   * using `recipientInitialSigningKey`, attempt to modify the allowance of this\r\n   * contract for the sender using the meta-transaction via `senderSmartWallet`,\r\n   * `value`, `expiration`, `salt`, and `signatures`, then transfer `value` dDai\r\n   * from the sender to the recipient, reverting on failure. Only the owner or\r\n   * the transferrer role may call this function.\r\n   * @param senderSmartWallet address The wallet of the sender.\r\n   * @param recipientInitialSigningKey address The input to recipient's wallet.\r\n   * @param recipientSmartWallet address The wallet of the recipient.\r\n   * @param value uint256 The amount of dDai to approve and transfer.\r\n   * @param expiration uint256 The timestamp where the meta-transaction expires.\r\n   * @param salt bytes32 The salt associated with the meta-transaction.\r\n   * @param signatures bytes The signature or signatures associated with the\r\n   * meta-transaction.\r\n   */\r\n  function enactDDaiTransfer(\r\n    address senderSmartWallet,\r\n    address recipientInitialSigningKey, // the receiver's key ring\r\n    address recipientSmartWallet,\r\n    uint256 value,\r\n    uint256 expiration,\r\n    bytes32 salt,\r\n    bytes calldata signatures\r\n  ) external onlyOwnerOr(Role.TRANSFERRER) {\r\n    // Ensure that the receiver has a Dharma Smart Wallet (deployed or not).\r\n    require(\r\n      _isSmartWallet(recipientSmartWallet, recipientInitialSigningKey),\r\n      \"Could not resolve receiver's smart wallet using provided signing key.\"\r\n    );\r\n\r\n    // Attempt to modify the allowance.\r\n    _tryApprovalViaMetaTransaction(\r\n      senderSmartWallet, value, expiration, salt, signatures\r\n    );\r\n\r\n    // Make the transfer from the sender's smart wallet to the receiver's.\r\n    bool ok = _DDAI.transferFrom(senderSmartWallet, recipientSmartWallet, value);\r\n    require(ok, \"Dharma Dai transfer failed.\");\r\n  }\r\n  \r\n  /**\r\n   * @notice Prove that `recipientSmartWallet` is a Dharma smart wallet address\r\n   * using `recipientInitialSigningKey`, deploy sender's smart wallet (unless it\r\n   * is already deployed) using `senderInitialSigningKey`, attempt to modify the\r\n   * allowance of this contract for the sender using the meta-transaction via\r\n   * `senderSmartWallet`, `value`, `expiration`, `salt`, and `signatures`, then\r\n   * transfer `value` dDai from the sender to the recipient, reverting on\r\n   * failure. Only the owner or the transferrer role may call this function.\r\n   * @param senderInitialSigningKey address The sender's key ring, used as the\r\n   * input to the smart wallet deployment.\r\n   * @param senderSmartWallet address The wallet of the sender.\r\n   * @param recipientInitialSigningKey address The input to recipient's wallet.\r\n   * @param recipientSmartWallet address The wallet of the recipient.\r\n   * @param value uint256 The amount of dDai to approve and transfer.\r\n   * @param expiration uint256 The timestamp where the meta-transaction expires.\r\n   * @param salt bytes32 The salt associated with the meta-transaction.\r\n   * @param signatures bytes The signature or signatures associated with the\r\n   * meta-transaction.\r\n   */\r\n  function deploySenderWalletAndEnactDDaiTransfer(\r\n    address senderInitialSigningKey, // the sender's key ring\r\n    address senderSmartWallet,\r\n    address recipientInitialSigningKey, // the receiver's key ring\r\n    address recipientSmartWallet,\r\n    uint256 value,\r\n    uint256 expiration,\r\n    bytes32 salt,\r\n    bytes calldata signatures\r\n  ) external onlyOwnerOr(Role.TRANSFERRER) {\r\n    // Ensure the recipient is valid and that dDai amount is under the limit.\r\n    _enforceRecipientAndValue(\r\n      recipientSmartWallet, recipientInitialSigningKey, value\r\n    );\r\n\r\n    // Deploy the sender's smart wallet if necessary.\r\n    _deployNewSmartWalletIfNeeded(senderInitialSigningKey, senderSmartWallet);\r\n\r\n    // Attempt to modify the allowance.\r\n    _tryApprovalViaMetaTransaction(\r\n      senderSmartWallet, value, expiration, salt, signatures\r\n    );\r\n\r\n    // Make the transfer from the sender's smart wallet to the receiver's.\r\n    bool ok = _DDAI.transferFrom(senderSmartWallet, recipientSmartWallet, value);\r\n    require(ok, \"Dharma Dai transfer failed.\");\r\n  }\r\n\r\n  /**\r\n   * @notice Prove that `recipientSmartWallet` is a Dharma smart wallet address\r\n   * using `recipientInitialSigningKey`, deploy sender's key ring (unless it is\r\n   * already deployed) using `senderInitialKeyRingSigningKey`, attempt to modify\r\n   * the allowance of this contract for the sender using the meta-transaction\r\n   * via `senderSmartWallet`, `value`, `expiration`, `salt`, and `signatures`,\r\n   * then transfer `value` dDai from the sender to the recipient, reverting on\r\n   * failure. Only the owner or the transferrer role may call this function.\r\n   * @param senderInitialKeyRingSigningKey address The input to the key ring.\r\n   * @param senderKeyRing address The sender's keyring; the smart wallet input.\r\n   * @param senderSmartWallet address The wallet of the sender.\r\n   * @param recipientInitialSigningKey address The input to recipient's wallet.\r\n   * @param recipientSmartWallet address The wallet of the recipient.\r\n   * @param value uint256 The amount of dDai to approve and transfer.\r\n   * @param expiration uint256 The timestamp where the meta-transaction expires.\r\n   * @param salt bytes32 The salt associated with the meta-transaction.\r\n   * @param signatures bytes The signature or signatures associated with the\r\n   * meta-transaction.\r\n   */\r\n  function deploySenderKeyRingAndEnactDDaiTransfer(\r\n    address senderInitialKeyRingSigningKey, // initial key on sender's key ring\r\n    address senderKeyRing, // the sender's key ring\r\n    address senderSmartWallet,\r\n    address recipientInitialSigningKey, // the receiver's key ring\r\n    address recipientSmartWallet,\r\n    uint256 value,\r\n    uint256 expiration,\r\n    bytes32 salt,\r\n    bytes calldata signatures\r\n  ) external onlyOwnerOr(Role.TRANSFERRER) {\r\n    // Ensure the recipient is valid and that dDai amount is under the limit.\r\n    _enforceRecipientAndValue(\r\n      recipientSmartWallet, recipientInitialSigningKey, value\r\n    );\r\n\r\n    // Deploy the sender's key ring if necessary.\r\n    _deployNewKeyRingIfNeeded(senderInitialKeyRingSigningKey, senderKeyRing);\r\n\r\n    // Attempt to modify the allowance.\r\n    _tryApprovalViaMetaTransaction(\r\n      senderSmartWallet, value, expiration, salt, signatures\r\n    );\r\n\r\n    // Make the transfer from the sender's smart wallet to the receiver's.\r\n    bool ok = _DDAI.transferFrom(senderSmartWallet, recipientSmartWallet, value);\r\n    require(ok, \"Dharma Dai transfer failed.\");\r\n  }\r\n\r\n  /**\r\n   * @notice Prove that `recipientSmartWallet` is a Dharma smart wallet address\r\n   * using `recipientInitialSigningKey`, deploy sender's key ring (unless it is\r\n   * already deployed) using `senderInitialKeyRingSigningKey`, deploy sender's\r\n   * smart wallet (unless it is already deployed) using `senderKeyRing`, attempt\r\n   * to modify the allowance of this contract for the sender using the\r\n   * meta-transaction via `senderSmartWallet`, `value`, `expiration`, `salt`,\r\n   * and `signatures`, then transfer `value` dDai from the sender to the\r\n   * recipient, reverting on failure. Only the owner or the transferrer role may\r\n   * call this function.\r\n   * @param senderInitialKeyRingSigningKey address The input to the key ring.\r\n   * @param senderKeyRing address The sender's keyring; the smart wallet input.\r\n   * @param senderSmartWallet address The wallet of the sender.\r\n   * @param recipientInitialSigningKey address The input to recipient's wallet.\r\n   * @param recipientSmartWallet address The wallet of the recipient.\r\n   * @param value uint256 The amount of dDai to approve and transfer.\r\n   * @param expiration uint256 The timestamp where the meta-transaction expires.\r\n   * @param salt bytes32 The salt associated with the meta-transaction.\r\n   * @param signatures bytes The signature or signatures associated with the\r\n   * meta-transaction.\r\n   */\r\n  function deploySenderKeyRingAndWalletAndEnactDDaiTransfer(\r\n    address senderInitialKeyRingSigningKey, // initial key on sender's key ring\r\n    address senderKeyRing, // the sender's key ring\r\n    address senderSmartWallet,\r\n    address recipientInitialSigningKey, // the receiver's key ring\r\n    address recipientSmartWallet,\r\n    uint256 value,\r\n    uint256 expiration,\r\n    bytes32 salt,\r\n    bytes calldata signatures\r\n  ) external onlyOwnerOr(Role.TRANSFERRER) {\r\n    // Ensure the recipient is valid and that dDai amount is under the limit.\r\n    _enforceRecipientAndValue(\r\n      recipientSmartWallet, recipientInitialSigningKey, value\r\n    );\r\n\r\n    // Deploy the sender's key ring if necessary.\r\n    _deployNewKeyRingIfNeeded(senderInitialKeyRingSigningKey, senderKeyRing);\r\n\r\n    // Deploy the sender's smart wallet if necessary.\r\n    _deployNewSmartWalletIfNeeded(senderKeyRing, senderSmartWallet);\r\n\r\n    // Attempt to modify the allowance.\r\n    _tryApprovalViaMetaTransaction(\r\n      senderSmartWallet, value, expiration, salt, signatures\r\n    );\r\n\r\n    // Make the transfer from the sender's smart wallet to the receiver's.\r\n    bool ok = _DDAI.transferFrom(senderSmartWallet, recipientSmartWallet, value);\r\n    require(ok, \"Dharma Dai transfer failed.\");\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer `amount` of ERC20 token `token` to `recipient`. Only the\r\n   * owner may call this function.\r\n   * @param token ERC20Interface The ERC20 token to transfer.\r\n   * @param recipient address The account to transfer the tokens to.\r\n   * @param amount uint256 The amount of tokens to transfer.\r\n   * @return A boolean to indicate if the transfer was successful - note that\r\n   * unsuccessful ERC20 transfers will usually revert.\r\n   */\r\n  function withdraw(\r\n    ERC20Interface token, address recipient, uint256 amount\r\n  ) external onlyOwner returns (bool success) {\r\n    // Transfer the token to the specified recipient.\r\n    success = token.transfer(recipient, amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Call account `target`, supplying value `amount` and data `data`.\r\n   * Only the owner may call this function.\r\n   * @param target address The account to call.\r\n   * @param amount uint256 The amount of ether to include as an endowment.\r\n   * @param data bytes The data to include along with the call.\r\n   * @return A boolean to indicate if the call was successful, as well as the\r\n   * returned data or revert reason.\r\n   */\r\n  function callGeneric(\r\n    address payable target, uint256 amount, bytes calldata data\r\n  ) external onlyOwner returns (bool ok, bytes memory returnData) {\r\n    // Call the specified target and supply the specified data.\r\n    (ok, returnData) = target.call.value(amount)(data);\r\n  }\r\n\r\n  /**\r\n   * @notice Set `daiAmount` as the new limit on the size of finalized deposits.\r\n   * Only the owner may call this function.\r\n   * @param daiAmount uint256 The new limit on the size of finalized deposits.\r\n   */\r\n  function setLimit(uint256 daiAmount) external onlyOwner {\r\n    // Set the new limit.\r\n    _limit = daiAmount;\r\n  }\r\n\r\n  /**\r\n   * @notice Pause a currently unpaused role and emit a `RolePaused` event. Only\r\n   * the owner or the designated pauser may call this function. Also, bear in\r\n   * mind that only the owner may unpause a role once paused.\r\n   * @param role The role to pause. Permitted roles are transferrer (0) and\r\n   * pauser (1).\r\n   */\r\n  function pause(Role role) external onlyOwnerOr(Role.PAUSER) {\r\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\r\n    require(!storedRoleStatus.paused, \"Role in question is already paused.\");\r\n    storedRoleStatus.paused = true;\r\n    emit RolePaused(role);\r\n  }\r\n\r\n  /**\r\n   * @notice Unpause a currently paused role and emit a `RoleUnpaused` event.\r\n   * Only the owner may call this function.\r\n   * @param role The role to pause. Permitted roles are transferrer (0) and\r\n   * pauser (1).\r\n   */\r\n  function unpause(Role role) external onlyOwner {\r\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\r\n    require(storedRoleStatus.paused, \"Role in question is already unpaused.\");\r\n    storedRoleStatus.paused = false;\r\n    emit RoleUnpaused(role);\r\n  }\r\n\r\n  /**\r\n   * @notice Set a new account on a given role and emit a `RoleModified` event\r\n   * if the role holder has changed. Only the owner may call this function.\r\n   * @param role The role that the account will be set for. Permitted roles are\r\n   * transferrer (0) and pauser (1).\r\n   * @param account The account to set as the designated role bearer.\r\n   */\r\n  function setRole(Role role, address account) external onlyOwner {\r\n    require(account != address(0), \"Must supply an account.\");\r\n    _setRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @notice Remove any current role bearer for a given role and emit a\r\n   * `RoleModified` event if a role holder was previously set. Only the owner\r\n   * may call this function.\r\n   * @param role The role that the account will be removed from. Permitted roles\r\n   * are transferrer (0) and pauser (1).\r\n   */\r\n  function removeRole(Role role) external onlyOwner {\r\n    _setRole(role, address(0));\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check whether or not the functionality\r\n   * associated with a given role is currently paused or not. The owner or the\r\n   * pauser may pause any given role (including the pauser itself), but only the\r\n   * owner may unpause functionality. Additionally, the owner may call paused\r\n   * functions directly.\r\n   * @param role The role to check the pause status on. Permitted roles are\r\n   * transferrer (0) and pauser (1).\r\n   * @return A boolean to indicate if the functionality associated with the role\r\n   * in question is currently paused.\r\n   */\r\n  function isPaused(Role role) external view returns (bool paused) {\r\n    paused = _isPaused(role);\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check whether the caller is the current\r\n   * role holder.\r\n   * @param role The role to check for. Permitted roles are transferrer (0) and\r\n   * pauser (1).\r\n   * @return A boolean indicating if the caller has the specified role.\r\n   */\r\n  function isRole(Role role) external view returns (bool hasRole) {\r\n    hasRole = _isRole(role);\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check the account currently holding the\r\n   * transferrer role. The transferrer can process transfers using unordered\r\n   * approval meta-transactions and in doing so specify the recipient, but it\r\n   * must prove that the recipient is a Dharma Smart Wallet and adhere to the\r\n   * current limit.\r\n   * @return The address of the current transferrer, or the null address if none\r\n   * is set.\r\n   */\r\n  function getTransferrer() external view returns (address transferrer) {\r\n    transferrer = _roles[uint256(Role.TRANSFERRER)].account;\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check the account currently holding the\r\n   * pauser role. The pauser can pause any role from taking its standard action,\r\n   * though the owner will still be able to call the associated function in the\r\n   * interim and is the only entity able to unpause the given role once paused.\r\n   * @return The address of the current pauser, or the null address if none is\r\n   * set.\r\n   */\r\n  function getPauser() external view returns (address pauser) {\r\n    pauser = _roles[uint256(Role.PAUSER)].account;\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check the current limit on transfer\r\n   * amount enforced for the transferrer, expressed in Dai and in Dharma Dai.\r\n   * @return The Dai and Dharma Dai limit on transfer amount.\r\n   */  \r\n  function getLimit() external view returns (\r\n    uint256 daiAmount, uint256 dDaiAmount\r\n  ) {\r\n    daiAmount = _limit;\r\n    dDaiAmount = (daiAmount.mul(1e18)).div(_DDAI.exchangeRateCurrent());   \r\n  }\r\n\r\n  /**\r\n   * @notice External pure function to check whether a \"proof\" that a given\r\n   * smart wallet is actually a Dharma Smart Wallet, based on the initial user\r\n   * signing key, is valid or not. This proof only works when the Dharma Smart\r\n   * Wallet in question is derived using V1 of the Dharma Smart Wallet Factory.\r\n   * @param smartWallet address The smart wallet to check.\r\n   * @param initialUserSigningKey address The initial user signing key supplied\r\n   * when deriving the smart wallet address - this could be an EOA or a Dharma\r\n   * key ring address.\r\n   * @return A boolean indicating if the specified smart wallet account is\r\n   * indeed a smart wallet based on the specified initial user signing key.\r\n   */\r\n  function isDharmaSmartWallet(\r\n    address smartWallet, address initialUserSigningKey\r\n  ) external pure returns (bool dharmaSmartWallet) {\r\n    dharmaSmartWallet = _isSmartWallet(smartWallet, initialUserSigningKey);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to set a new account on a given role and emit a\r\n   * `RoleModified` event if the role holder has changed.\r\n   * @param role The role that the account will be set for. Permitted roles are\r\n   * transferrer (0) and pauser (1).\r\n   * @param account The account to set as the designated role bearer.\r\n   */\r\n  function _setRole(Role role, address account) internal {\r\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\r\n\r\n    if (account != storedRoleStatus.account) {\r\n      storedRoleStatus.account = account;\r\n      emit RoleModified(role, account);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to set an approval, or to continue if a given\r\n   * metatransaction has been used for an approval before but allowance is still\r\n   * set (for instance, by a griefer that has lifted it from calldata while the\r\n   * transaction is still in the mempool and used it to frontrun the call). If\r\n   * one of these steps fails, revert.\r\n   * @param senderSmartWallet address The wallet of the sender.\r\n   * @param value uint256 The amount of dDai to approve.\r\n   * @param expiration uint256 The timestamp where the meta-transaction expires.\r\n   * @param salt bytes32 The salt associated with the meta-transaction.\r\n   * @param signatures bytes The signature or signatures associated with the\r\n   * meta-transaction.\r\n   */  function _tryApprovalViaMetaTransaction(\r\n    address senderSmartWallet,\r\n    uint256 value,\r\n    uint256 expiration,\r\n    bytes32 salt,\r\n    bytes memory signatures\r\n  ) internal {\r\n    // Attempt to modify the allowance.\r\n    (bool ok, bytes memory returnData) = address(_DDAI).call(\r\n      abi.encodeWithSelector(\r\n        _DDAI.modifyAllowanceViaMetaTransaction.selector,\r\n        senderSmartWallet,\r\n        address(this),\r\n        value,\r\n        true, // increase\r\n        expiration,\r\n        salt,\r\n        signatures\r\n      )\r\n    );\r\n\r\n    // Protect against griefing via frontrunning by handling specific reverts.\r\n    if (!ok) {\r\n      // Determine whether the meta-transaction in question has been used yet.\r\n      (, bool valid) = _DDAI.getMetaTransactionMessageHash(\r\n        _DDAI.modifyAllowanceViaMetaTransaction.selector,\r\n        abi.encode(senderSmartWallet, address(this), value, true),\r\n        expiration,\r\n        salt\r\n      );\r\n\r\n      // Revert with the original message if it has not been used.\r\n      if (valid) {\r\n        assembly { revert(add(32, returnData), mload(returnData)) }\r\n      }\r\n\r\n      // If it has been used, determine if there is still sufficient allowance.\r\n      uint256 allowance = _DDAI.allowance(senderSmartWallet, address(this));\r\n\r\n      // Revert with the original message if allowance is insufficient.\r\n      if (allowance < value) {\r\n        assembly { revert(add(32, returnData), mload(returnData)) }\r\n      }\r\n    }\r\n  }\r\n \r\n  /**\r\n   * @notice Internal function to deploy a key ring if needed. If expected key\r\n   * ring address does not match the next key ring address, revert.\r\n   */  \r\n  function _deployNewKeyRingIfNeeded(\r\n    address initialSigningKey, address expectedKeyRing\r\n  ) internal returns (address keyRing) {\r\n    // Only deploy if a smart wallet doesn't already exist at expected address.\r\n    bytes32 hash;\r\n    assembly { hash := extcodehash(expectedKeyRing) }\r\n    if (hash != _KEY_RING_INSTANCE_RUNTIME_HASH) {\r\n      require(\r\n        _KEYRING_FACTORY.getNextKeyRing(initialSigningKey) == expectedKeyRing,\r\n        \"Key ring to be deployed does not match expected key ring.\"\r\n      );\r\n      keyRing = _KEYRING_FACTORY.newKeyRing(initialSigningKey, expectedKeyRing);\r\n    } else {\r\n      // Note: the key ring at the expected address may have been modified so that\r\n      // the supplied user signing key is no longer a valid key - therefore, treat\r\n      // this helper as a way to protect against race conditions, not as a primary\r\n      // mechanism for interacting with key ring contracts.\r\n      keyRing = expectedKeyRing;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to deploy a smart wallet if needed. If expected\r\n   * smart wallet address does not match the next smart wallet address, revert.\r\n   */  \r\n  function _deployNewSmartWalletIfNeeded(\r\n    address userSigningKey, // the key ring\r\n    address expectedSmartWallet\r\n  ) internal returns (address smartWallet) {\r\n    // Only deploy if a smart wallet doesn't already exist at expected address.\r\n    bytes32 hash;\r\n    assembly { hash := extcodehash(expectedSmartWallet) }\r\n    if (hash != _SMART_WALLET_INSTANCE_RUNTIME_HASH) {\r\n      require(\r\n        _WALLET_FACTORY.getNextSmartWallet(userSigningKey) == expectedSmartWallet,\r\n        \"Smart wallet to be deployed does not match expected smart wallet.\"\r\n      );\r\n      smartWallet = _WALLET_FACTORY.newSmartWallet(userSigningKey);\r\n    } else {\r\n      // Note: the smart wallet at the expected address may have been modified\r\n      // so that the supplied user signing key is no longer a valid key.\r\n      // Therefore, treat this helper as a way to protect against race\r\n      // conditions, not as a primary mechanism for interacting with smart\r\n      // wallet contracts.\r\n      smartWallet = expectedSmartWallet;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal view function to ensure that a recipient is a valid target\r\n   * for the transferrer to select and that the value being transferred does not\r\n   * exceed the current limit.\r\n   */\r\n  function _enforceRecipientAndValue(\r\n    address recipient, address recipientInitialSigningKey, uint256 dDaiAmount\r\n  ) internal view {\r\n    // Ensure that the recipient is indeed a smart wallet.\r\n    require(\r\n      _isSmartWallet(recipient, recipientInitialSigningKey),\r\n      \"Could not resolve smart wallet using provided signing key.\"\r\n    );\r\n    \r\n    // Get the current dDai exchange rate.\r\n    uint256 exchangeRate = _DDAI.exchangeRateCurrent();\r\n\r\n    // Ensure that an exchange rate was actually returned.\r\n    require(exchangeRate != 0, \"Could not retrieve dDai exchange rate.\");\r\n    \r\n    // Get the equivalent Dai amount of the transfer.\r\n    uint256 daiEquivalent = (dDaiAmount.mul(exchangeRate)) / 1e18;\r\n    \r\n    // Ensure that the amount to transfer is lower than the limit.\r\n    require(daiEquivalent < _limit, \"Transfer size exceeds the limit.\");\r\n  }\r\n\r\n  /**\r\n   * @notice Internal view function to check whether the caller is the current\r\n   * role holder.\r\n   * @param role The role to check for. Permitted roles are transferrer (0) and\r\n   * pauser (1).\r\n   * @return A boolean indicating if the caller has the specified role.\r\n   */\r\n  function _isRole(Role role) internal view returns (bool hasRole) {\r\n    hasRole = msg.sender == _roles[uint256(role)].account;\r\n  }\r\n\r\n  /**\r\n   * @notice Internal view function to check whether the given role is paused or\r\n   * not.\r\n   * @param role The role to check for. Permitted roles are transferrer (0) and\r\n   * pauser (1).\r\n   * @return A boolean indicating if the specified role is paused or not.\r\n   */\r\n  function _isPaused(Role role) internal view returns (bool paused) {\r\n    paused = _roles[uint256(role)].paused;\r\n  }\r\n\r\n  /**\r\n   * @notice Internal view function to enforce that the given initial user\r\n   * signing key resolves to the given smart wallet when deployed through the\r\n   * Dharma Smart Wallet Factory V1.\r\n   * @param smartWallet address The smart wallet.\r\n   * @param initialUserSigningKey address The initial user signing key.\r\n   */\r\n  function _isSmartWallet(\r\n    address smartWallet, address initialUserSigningKey\r\n  ) internal pure returns (bool) {\r\n    // Derive the keccak256 hash of the smart wallet initialization code.\r\n    bytes32 initCodeHash = keccak256(\r\n      abi.encodePacked(\r\n        _WALLET_CREATION_CODE_HEADER,\r\n        initialUserSigningKey,\r\n        _WALLET_CREATION_CODE_FOOTER\r\n      )\r\n    );\r\n\r\n    // Attempt to derive a smart wallet address that matches the one provided.\r\n    address target;\r\n    for (uint256 nonce = 0; nonce < 10; nonce++) {\r\n      target = address(          // derive the target deployment address.\r\n        uint160(                 // downcast to match the address type.\r\n          uint256(               // cast to uint to truncate upper digits.\r\n            keccak256(           // compute CREATE2 hash using all inputs.\r\n              abi.encodePacked(  // pack all inputs to the hash together.\r\n                _CREATE2_HEADER, // pass in control character + factory address.\r\n                nonce,           // pass in current nonce as the salt.\r\n                initCodeHash     // pass in hash of contract creation code.\r\n              )\r\n            )\r\n          )\r\n        )\r\n      );\r\n\r\n      // Exit early if the provided smart wallet matches derived target address.\r\n      if (target == smartWallet) {\r\n        return true;\r\n      }\r\n\r\n      // Otherwise, increment the nonce and derive a new salt.\r\n      nonce++;\r\n    }\r\n\r\n    // Explicity recognize no target was found matching provided smart wallet.\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @notice Modifier that throws if called by any account other than the owner\r\n   * or the supplied role, or if the caller is not the owner and the role in\r\n   * question is paused.\r\n   * @param role The role to require unless the caller is the owner. Permitted\r\n   * roles are transferrer (0) and pauser (1).\r\n   */\r\n  modifier onlyOwnerOr(Role role) {\r\n    if (!isOwner()) {\r\n      require(_isRole(role), \"Caller does not have a required role.\");\r\n      require(!_isPaused(role), \"Role in question is currently paused.\");\r\n    }\r\n    _;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"daiAmount\",\"type\":\"uint256\"}],\"name\":\"setLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTransferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"transferrer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum DharmaTransferFacilitatorInterface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"senderInitialSigningKey\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderSmartWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipientInitialSigningKey\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipientSmartWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"deploySenderWalletAndEnactDDaiTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialUserSigningKey\",\"type\":\"address\"}],\"name\":\"isDharmaSmartWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"dharmaSmartWallet\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"senderInitialKeyRingSigningKey\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderKeyRing\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderSmartWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipientInitialSigningKey\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipientSmartWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"deploySenderKeyRingAndWalletAndEnactDDaiTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPauser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pauser\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"senderSmartWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipientInitialSigningKey\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipientSmartWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"enactDDaiTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"callGeneric\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"daiAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dDaiAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"enum DharmaTransferFacilitatorInterface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"isRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasRole\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"enum DharmaTransferFacilitatorInterface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"senderInitialKeyRingSigningKey\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderKeyRing\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderSmartWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipientInitialSigningKey\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipientSmartWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"deploySenderKeyRingAndEnactDDaiTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20Interface\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum DharmaTransferFacilitatorInterface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"removeRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum DharmaTransferFacilitatorInterface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum DharmaTransferFacilitatorInterface.Role\",\"name\":\"role\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum DharmaTransferFacilitatorInterface.Role\",\"name\":\"role\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RoleModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum DharmaTransferFacilitatorInterface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"RolePaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum DharmaTransferFacilitatorInterface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"RoleUnpaused\",\"type\":\"event\"}]","ContractName":"DharmaTransferFacilitatorV2","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://79de05b353fac97d9b72a6df218e64fd3b64969050f606536d282bd40a932e40"}]}