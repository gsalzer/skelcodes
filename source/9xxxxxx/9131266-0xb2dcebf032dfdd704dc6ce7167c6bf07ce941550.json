{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11; // optimization disabled, evm version: petersburg\r\n\r\n\r\n/**\r\n * @title DharmaAccountRecoveryOperatorMultisigStaging\r\n * @author 0age (derived from Christian Lundkvist's Simple Multisig)\r\n * @notice This contract is a multisig that will initiate timelocks for account\r\n * recovery on the Dharma Smart Wallet, based on Christian Lundkvist's Simple\r\n * Multisig (found at https://github.com/christianlundkvist/simple-multisig).\r\n * The Account Recovery Manager is hard-coded as the only allowable call\r\n * destination, and any changes in ownership or signature threshold will require\r\n * deploying a new multisig and setting it as the new operator on the account\r\n * recovery manager.\r\n */\r\ncontract DharmaAccountRecoveryOperatorMultisigStaging {\r\n  // Maintain a mapping of used hashes to prevent replays.\r\n  mapping(bytes32 => bool) private _usedHashes;\r\n\r\n  // Maintain a mapping and a convenience array of owners.\r\n  mapping(address => bool) private _isOwner;\r\n  address[] private _owners;\r\n\r\n  // The Account Recovery Manager is the only account the multisig can call.\r\n  address private constant _DESTINATION = address(\r\n    0x2a7E7718b755F9868E6B64DD18C6886707DD9c10\r\n  );\r\n\r\n  // The threshold is an exact number of valid signatures that must be supplied.\r\n  uint256 private constant _THRESHOLD = 2;\r\n\r\n  // Note: Owners must be strictly increasing in order to prevent duplicates.\r\n  constructor(address[] memory owners) public {\r\n    require(owners.length <= 10, \"Cannot have more than 10 owners.\");\r\n    require(_THRESHOLD <= owners.length, \"Threshold cannot exceed total owners.\");\r\n\r\n    address lastAddress = address(0);\r\n    for (uint256 i = 0; i < owners.length; i++) {\r\n      require(\r\n        owners[i] > lastAddress, \"Owner addresses must be strictly increasing.\"\r\n      );\r\n      _isOwner[owners[i]] = true;\r\n      lastAddress = owners[i];\r\n    }\r\n    _owners = owners;\r\n  }\r\n\r\n  function getHash(\r\n    bytes calldata data,\r\n    address executor,\r\n    uint256 gasLimit,\r\n    bytes32 salt\r\n  ) external view returns (bytes32 hash, bool usable) {\r\n    (hash, usable) = _getHash(data, executor, gasLimit, salt);\r\n  }\r\n\r\n  function getOwners() external view returns (address[] memory owners) {\r\n    owners = _owners;\r\n  }\r\n\r\n  function isOwner(address account) external view returns (bool owner) {\r\n    owner = _isOwner[account];\r\n  }\r\n\r\n  function getThreshold() external pure returns (uint256 threshold) {\r\n    threshold = _THRESHOLD;\r\n  }\r\n\r\n  function getDestination() external pure returns (address destination) {\r\n    destination = _DESTINATION;\r\n  }\r\n\r\n  // Note: addresses recovered from signatures must be strictly increasing.\r\n  function execute(\r\n    bytes calldata data,\r\n    address executor,\r\n    uint256 gasLimit,\r\n    bytes32 salt,\r\n    bytes calldata signatures\r\n  ) external returns (bool success, bytes memory returnData) {\r\n    require(\r\n      executor == msg.sender || executor == address(0),\r\n      \"Must call from the executor account if one is specified.\"\r\n    );\r\n\r\n    // Derive the message hash and ensure that it has not been used before.\r\n    (bytes32 rawHash, bool usable) = _getHash(data, executor, gasLimit, salt);\r\n    require(usable, \"Hash in question has already been used previously.\");\r\n\r\n    // wrap the derived message hash as an eth signed messsage hash.\r\n    bytes32 hash = _toEthSignedMessageHash(rawHash);\r\n\r\n    // Recover each signer from provided signatures and ensure threshold is met.\r\n    address[] memory signers = _recoverGroup(hash, signatures);\r\n\r\n    require(signers.length == _THRESHOLD, \"Total signers must equal threshold.\");\r\n\r\n    // Verify that each signatory is an owner and is strictly increasing.\r\n    address lastAddress = address(0); // cannot have address(0) as an owner\r\n    for (uint256 i = 0; i < signers.length; i++) {\r\n      require(\r\n        _isOwner[signers[i]], \"Signature does not correspond to an owner.\"\r\n      );\r\n      require(\r\n        signers[i] > lastAddress, \"Signer addresses must be strictly increasing.\"\r\n      );\r\n      lastAddress = signers[i];\r\n    }\r\n\r\n    // Add the hash to the mapping of used hashes and execute the transaction.\r\n    _usedHashes[rawHash] = true;\r\n    (success, returnData) = _DESTINATION.call.gas(gasLimit)(data);\r\n  }\r\n\r\n  function _getHash(\r\n    bytes memory data,\r\n    address executor,\r\n    uint256 gasLimit,\r\n    bytes32 salt\r\n  ) internal view returns (bytes32 hash, bool usable) {\r\n    // Note: this is the data used to create a personal signed message hash.\r\n    hash = keccak256(\r\n      abi.encodePacked(address(this), salt, executor, gasLimit, data)\r\n    );\r\n\r\n    usable = !_usedHashes[hash];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns each address that signed a hashed message (`hash`) from a\r\n   * collection of `signatures`.\r\n   *\r\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n   * this function rejects them by requiring the `s` value to be in the lower\r\n   * half order, and the `v` value to be either 27 or 28.\r\n   *\r\n   * NOTE: This call _does not revert_ if a signature is invalid, or if the\r\n   * signer is otherwise unable to be retrieved. In those scenarios, the zero\r\n   * address is returned for that signature.\r\n   *\r\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n   * verification to be secure: it is possible to craft signatures that recover\r\n   * to arbitrary addresses for non-hashed data.\r\n   */\r\n  function _recoverGroup(\r\n    bytes32 hash,\r\n    bytes memory signatures\r\n  ) internal pure returns (address[] memory signers) {\r\n    // Ensure that the signatures length is a multiple of 65.\r\n    if (signatures.length % 65 != 0) {\r\n      return new address[](0);\r\n    }\r\n\r\n    // Create an appropriately-sized array of addresses for each signer.\r\n    signers = new address[](signatures.length / 65);\r\n\r\n    // Get each signature location and divide into r, s and v variables.\r\n    bytes32 signatureLocation;\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    for (uint256 i = 0; i < signers.length; i++) {\r\n      assembly {\r\n        signatureLocation := add(signatures, mul(i, 65))\r\n        r := mload(add(signatureLocation, 32))\r\n        s := mload(add(signatureLocation, 64))\r\n        v := byte(0, mload(add(signatureLocation, 96)))\r\n      }\r\n\r\n      // EIP-2 still allows signature malleability for ecrecover(). Remove\r\n      // this possibility and make the signature unique.\r\n      if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n        continue;\r\n      }\r\n\r\n      if (v != 27 && v != 28) {\r\n        continue;\r\n      }\r\n\r\n      // If signature is valid & not malleable, add signer address.\r\n      signers[i] = ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n  function _toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getDestination\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"owner\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"getHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"usable\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"DharmaAccountRecoveryOperatorMultisigStaging","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000050000000000000000000000001ad3d7dceff0e0219e577aeda10b6f93564f9d3f00000000000000000000000047a601efa64ab429c28309a57246969543d7aec500000000000000000000000056111524abfe0ef01162ab7ef731cb99a4b49d750000000000000000000000007e4a8391c728fed9069b2962699ab416628b19fa000000000000000000000000806d1d723d1b7a51ed1d5329fe948c454153f11d","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://4620d447c49bb7efcb9b51db3e77c7e62951f9dcab2db790d16c565508bb9061"}]}