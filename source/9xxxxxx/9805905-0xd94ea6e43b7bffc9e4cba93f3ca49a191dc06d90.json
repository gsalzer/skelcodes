{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\ncontract UtilGLSC {\r\n\r\n    uint ethWei = 1 ether;\r\n\r\n    function getLevel(uint value, uint _type) public view returns (uint) {\r\n        if (value >= 1 * ethWei && value <= 5 * ethWei) return 1;\r\n        if (value >= 6 * ethWei && value <= 10 * ethWei) return 2;\r\n        if (_type == 1 && value >= 11 * ethWei) return 3;\r\n        else if (_type == 2 && value >= 11 * ethWei && value <= 15 * ethWei) return 3;\r\n        return 0;\r\n    }\r\n\r\n    function getScByLevel(uint level) public pure returns (uint) {\r\n        if (level == 1) return 5;\r\n        if (level == 2) return 7;\r\n        if (level == 3) return 10;\r\n        return 0;\r\n    }\r\n\r\n    function getFireScByLevel(uint level) public pure returns (uint) {\r\n        if (level == 1) return 3;\r\n        if (level == 2) return 6;\r\n        if (level == 3) return 10;\r\n        return 0;\r\n    }\r\n\r\n    function getRecommendScaleByLevelAndTim(uint level, uint times) public pure returns (uint){\r\n        if (level == 1 && times == 1) return 50;\r\n        if (level == 2 && times == 1) return 70;\r\n        if (level == 2 && times == 2) return 30;\r\n        if (level == 3) {\r\n            if (times == 1) return 100;\r\n            if (times == 2) return 50;\r\n            if (times == 3) return 30;\r\n            if (times >= 4 && times <= 10) return 5;\r\n            //            > 10 ä»£  1%\r\n            if (times >= 11) return 1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function compareStr(string memory _str, string memory str) public pure returns (bool) {\r\n        if (keccak256(abi.encodePacked(_str)) == keccak256(abi.encodePacked(str))) return true;\r\n        return false;\r\n    }\r\n}\r\n\r\ncontract Context {\r\n\r\n    constructor() internal {}\r\n    function _msgSender() internal view returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n\r\n    address private _owner;\r\n\r\n    constructor () internal {\r\n        _owner = _msgSender();\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\nlibrary Roles {\r\n\r\n    struct Role {\r\n        mapping(address => bool) bearer;\r\n    }\r\n\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\ncontract WhitelistAdminRole is Context, Ownable {\r\n\r\n    using Roles for Roles.Role;\r\n\r\n    Roles.Role private _whitelistAdmins;\r\n\r\n    constructor () internal {\r\n    }\r\n\r\n    modifier onlyWhitelistAdmin() {\r\n        require(isWhitelistAdmin(_msgSender()) || isOwner(), \"WhitelistAdminRole: caller does not have the WhitelistAdmin role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelistAdmin(address account) public view returns (bool) {\r\n        return _whitelistAdmins.has(account) || isOwner();\r\n    }\r\n\r\n    function addWhitelistAdmin(address account) public onlyOwner {\r\n        _whitelistAdmins.add(account);\r\n    }\r\n\r\n    function removeWhitelistAdmin(address account) public onlyOwner {\r\n        _whitelistAdmins.remove(account);\r\n    }\r\n}\r\n\r\ncontract GLSC is UtilGLSC, WhitelistAdminRole {\r\n\r\n    using SafeMath for *;\r\n    uint ethWei = 1 ether;\r\n\r\n    address payable private devAddr = address(0x1D8c188E2eC17A4723216b26531fBF59713556eC);\r\n    address payable private comfortAddr = address(0x3840679CbBA3E940C0b9CC4A9801B6ae9A90E592);\r\n\r\n    uint public currBalance = 0 ether;\r\n    uint curr = 0 ether;\r\n    uint _time = now;\r\n\r\n    struct User {\r\n        uint id;\r\n        address userAddress;\r\n        uint freeAmount;\r\n        uint freezeAmount;\r\n        uint lineAmount;\r\n        uint inviteAmonut;\r\n        uint dayBonusAmount;\r\n        uint bonusAmount;\r\n        uint level;\r\n        uint lineLevel;\r\n        uint resTime;\r\n        uint investTimes;\r\n        string inviteCode;\r\n        string beCode;\r\n        uint rewardIndex;\r\n        uint lastRwTime;\r\n        uint bigCycle;\r\n    }\r\n\r\n    struct UserGlobal {\r\n        uint id;\r\n        address userAddress;\r\n        string inviteCode;\r\n        string beCode;\r\n        uint status;\r\n    }\r\n\r\n    struct AwardData {\r\n        uint oneInvAmount;\r\n        uint twoInvAmount;\r\n        uint threeInvAmount;\r\n    }\r\n\r\n    uint startTime;\r\n    uint lineStatus = 0;\r\n    uint bigCycle = 10;\r\n    mapping(uint => uint) rInvestCount;\r\n    mapping(uint => uint) rInvestMoney;\r\n    uint period = 1 days;\r\n    uint uid = 0;\r\n    uint rid = 1;\r\n    mapping(uint => uint[]) lineArrayMapping;\r\n    mapping(uint => mapping(address => User)) userRoundMapping;\r\n    mapping(address => UserGlobal) userMapping;\r\n    mapping(string => address) addressMapping;\r\n    mapping(uint => address) indexMapping;\r\n    mapping(uint => mapping(address => mapping(uint => AwardData))) userAwardDataMapping;\r\n    uint bonuslimit = 15 ether;\r\n    uint sendLimit = 100 ether;\r\n    uint withdrawLimit = 15 ether;\r\n    uint canImport = 1;\r\n    uint canSetStartTime = 1;\r\n\r\n    modifier isHuman() {\r\n        address addr = msg.sender;\r\n        uint codeLength;\r\n        assembly {codeLength := extcodesize(addr)}\r\n        require(codeLength == 0, \"sorry humans only\");\r\n        require(tx.origin == msg.sender, \"sorry, humans only\");\r\n        _;\r\n    }\r\n\r\n    constructor () public {\r\n    }\r\n\r\n    function() external payable {\r\n    }\r\n\r\n    function verydangerous(uint time) external onlyOwner {\r\n        require(canSetStartTime == 1, \"verydangerous, limited!\");\r\n        require(time > now, \"no, verydangerous\");\r\n        startTime = time;\r\n        canSetStartTime = 0;\r\n    }\r\n\r\n    function donnotimitate() public view returns (bool) {\r\n        return startTime != 0 && now > startTime;\r\n    }\r\n\r\n    function updateLine(uint line) external onlyWhitelistAdmin {\r\n        lineStatus = line;\r\n    }\r\n\r\n    function updateCycle(uint cycle) external onlyOwner {\r\n        bigCycle = cycle;\r\n    }\r\n\r\n    function isLine() private view returns (bool) {\r\n        return lineStatus != 0;\r\n    }\r\n\r\n    function stopImport() external onlyOwner {\r\n        canImport = 0;\r\n    }\r\n\r\n    function actUserStatus(address addr, uint status) external onlyWhitelistAdmin {\r\n        require(status == 0 || status == 1 || status == 2, \"bad parameter status\");\r\n        UserGlobal storage userGlobal = userMapping[addr];\r\n        userGlobal.status = status;\r\n    }\r\n\r\n    function repeatPldge() public {\r\n\r\n        require(donnotimitate(), \"no donnotimitate\");\r\n        User storage user = userRoundMapping[rid][msg.sender];\r\n        require(user.investTimes >= 7, \"investTimes must more than 7\");\r\n        user.bigCycle += 1;\r\n        require(user.id != 0, \"user not exist\");\r\n        uint sendMoney = user.freeAmount + user.lineAmount;\r\n\r\n        uint resultMoney = sendMoney;\r\n\r\n        user.freeAmount = 0;\r\n        user.lineAmount = 0;\r\n        user.lineLevel = getLevel(user.freezeAmount, 1);\r\n\r\n        require(resultMoney >= 1 * ethWei && resultMoney <= 15 * ethWei, \"between 1 and 15\");\r\n        //        require(resultMoney == resultMoney.div(ethWei).mul(ethWei), \"invalid msg value\");\r\n\r\n        uint investAmout;\r\n        uint lineAmount;\r\n        if (isLine()) lineAmount = resultMoney;\r\n        else investAmout = resultMoney;\r\n        require(user.freezeAmount.add(user.lineAmount) == 0, \"only once invest\");\r\n        user.freezeAmount = investAmout;\r\n        user.lineAmount = lineAmount;\r\n        user.level = getLevel(user.freezeAmount, 2);\r\n        user.lineLevel = getLevel(user.freezeAmount.add(user.freeAmount).add(user.lineAmount), 1);\r\n\r\n        rInvestCount[rid] = rInvestCount[rid].add(1);\r\n        rInvestMoney[rid] = rInvestMoney[rid].add(resultMoney);\r\n        if (!isLine()) {\r\n            sendFeetoAdmin(resultMoney);\r\n            countBonus(user.userAddress);\r\n        } else lineArrayMapping[rid].push(user.id);\r\n\r\n    }\r\n\r\n    function adWithDraw(uint amount) external onlyOwner {\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    function exit(string memory inviteCode, string memory beCode) public isHuman() payable {\r\n        require(donnotimitate(), \"no, donnotimitate\");\r\n        require(msg.value >= 1 * ethWei && msg.value <= 15 * ethWei, \"between 1 and 15\");\r\n        require(msg.value == msg.value.div(ethWei).mul(ethWei), \"invalid msg value\");\r\n\r\n        UserGlobal storage userGlobal = userMapping[msg.sender];\r\n        if (userGlobal.id == 0) {\r\n            require(!compareStr(inviteCode, \"\") && bytes(inviteCode).length == 6, \"invalid invite code\");\r\n            address beCodeAddr = addressMapping[beCode];\r\n            require(isUsed(beCode), \"beCode not exist\");\r\n            require(beCodeAddr != msg.sender, \"beCodeAddr can't be self\");\r\n            require(!isUsed(inviteCode), \"invite code is used\");\r\n            registerUser(msg.sender, inviteCode, beCode);\r\n        }\r\n        uint investAmout;\r\n        uint lineAmount;\r\n        if (isLine()) lineAmount = msg.value;\r\n        else investAmout = msg.value;\r\n        User storage user = userRoundMapping[rid][msg.sender];\r\n        if (user.id != 0) {\r\n            require(user.freezeAmount.add(user.lineAmount) == 0, \"only once invest\");\r\n            user.freezeAmount = investAmout;\r\n            user.lineAmount = lineAmount;\r\n            user.level = getLevel(user.freezeAmount, 2);\r\n            user.lineLevel = getLevel(user.freezeAmount.add(user.freeAmount).add(user.lineAmount), 1);\r\n        } else {\r\n            user.id = userGlobal.id;\r\n            user.userAddress = msg.sender;\r\n            user.freezeAmount = investAmout;\r\n            user.level = getLevel(investAmout, 2);\r\n            user.lineAmount = lineAmount;\r\n            user.lineLevel = getLevel(user.freezeAmount.add(user.freeAmount).add(user.lineAmount), 1);\r\n            user.inviteCode = userGlobal.inviteCode;\r\n            user.beCode = userGlobal.beCode;\r\n        }\r\n\r\n        rInvestCount[rid] = rInvestCount[rid].add(1);\r\n        rInvestMoney[rid] = rInvestMoney[rid].add(msg.value);\r\n        if (!isLine()) {\r\n            sendFeetoAdmin(msg.value);\r\n            countBonus(user.userAddress);\r\n        } else lineArrayMapping[rid].push(user.id);\r\n    }\r\n\r\n    function importGlobal(address addr, string calldata inviteCode, string calldata beCode) external onlyWhitelistAdmin {\r\n        require(canImport == 1, \"import stopped\");\r\n        UserGlobal storage user = userMapping[addr];\r\n        require(user.id == 0, \"user already exists\");\r\n        require(!compareStr(inviteCode, \"\"), \"empty invite code\");\r\n        if (uid != 0) require(!compareStr(beCode, \"\"), \"empty beCode\");\r\n        address beCodeAddr = addressMapping[beCode];\r\n        require(beCodeAddr != addr, \"beCodeAddr can't be self\");\r\n        require(!isUsed(inviteCode), \"invite code is used\");\r\n\r\n        registerUser(addr, inviteCode, beCode);\r\n    }\r\n\r\n    function countBonus(address userAddr) private {\r\n        User storage user = userRoundMapping[rid][userAddr];\r\n        if (user.id == 0) return;\r\n        uint scale = getScByLevel(user.level);\r\n        user.dayBonusAmount = user.freezeAmount.mul(scale).div(1000);\r\n        user.investTimes = 0;\r\n        UserGlobal memory userGlobal = userMapping[userAddr];\r\n        if (user.freezeAmount >= 1 ether && user.freezeAmount <= bonuslimit && userGlobal.status == 0) getaway(user.beCode, user.freezeAmount, scale);\r\n\r\n    }\r\n\r\n    function getaway(string memory beCode, uint money, uint shareSc) private {\r\n        string memory tmpReferrer = beCode;\r\n\r\n        for (uint i = 1; i <= 25; i++) {\r\n            if (compareStr(tmpReferrer, \"\")) break;\r\n            address tmpUserAddr = addressMapping[tmpReferrer];\r\n            UserGlobal storage userGlobal = userMapping[tmpUserAddr];\r\n            User storage calUser = userRoundMapping[rid][tmpUserAddr];\r\n\r\n            if (calUser.freezeAmount.add(calUser.freeAmount).add(calUser.lineAmount) == 0) {\r\n                tmpReferrer = userGlobal.beCode;\r\n                continue;\r\n            }\r\n\r\n            uint recommendSc = getRecommendScaleByLevelAndTim(3, i);\r\n            uint moneyResult = 0;\r\n            if (money <= 15 ether) moneyResult = money;\r\n            else moneyResult = 15 ether;\r\n\r\n            if (recommendSc != 0) {\r\n                uint tmpDynamicAmount = moneyResult.mul(shareSc).mul(recommendSc);\r\n                tmpDynamicAmount = tmpDynamicAmount.div(1000).div(100);\r\n                earneth(userGlobal.userAddress, tmpDynamicAmount, calUser.rewardIndex, i);\r\n            }\r\n            tmpReferrer = userGlobal.beCode;\r\n        }\r\n    }\r\n\r\n    function earneth(address userAddr, uint dayInvAmount, uint rewardIndex, uint times) private {\r\n        for (uint i = 0; i < 7; i++) {\r\n            AwardData storage awData = userAwardDataMapping[rid][userAddr][rewardIndex.add(i)];\r\n            if (times == 1) awData.oneInvAmount += dayInvAmount;\r\n            if (times == 2) awData.twoInvAmount += dayInvAmount;\r\n            awData.threeInvAmount += dayInvAmount;\r\n        }\r\n    }\r\n\r\n    function happy() public isHuman() {\r\n        require(donnotimitate(), \"no donnotimitate\");\r\n        User storage user = userRoundMapping[rid][msg.sender];\r\n        require(user.id != 0, \"user not exist\");\r\n        require(user.bigCycle >= bigCycle, \"user big cycle less than\");\r\n        uint sendMoney = user.freeAmount + user.lineAmount;\r\n        bool isEnough = false;\r\n        uint resultMoney = 0;\r\n\r\n        (isEnough, resultMoney) = isEnoughBalance(sendMoney);\r\n\r\n        if (resultMoney > 0 && resultMoney <= withdrawLimit) {\r\n            sendMoneyToUser(msg.sender, resultMoney);\r\n            user.freeAmount = 0;\r\n            user.lineAmount = 0;\r\n            user.bigCycle = 0;\r\n            user.lineLevel = getLevel(user.freezeAmount, 1);\r\n        }\r\n    }\r\n\r\n    function christmas(uint start, uint end) external onlyWhitelistAdmin {\r\n\r\n        if (_time - now > 12 hours) {\r\n            if (address(this).balance > curr) currBalance = address(this).balance.sub(curr);\r\n            else currBalance = 0 ether;\r\n            curr = address(this).balance;\r\n        }\r\n        for (uint i = start; i <= end; i++) {\r\n            address userAddr = indexMapping[i];\r\n            User storage user = userRoundMapping[rid][userAddr];\r\n            UserGlobal memory userGlobal = userMapping[userAddr];\r\n            if (now.sub(user.lastRwTime) <= 12 hours) {\r\n                continue;\r\n            }\r\n            uint bonusSend = 0;\r\n            if (user.level > 2) {\r\n                uint inviteSendQ = 0;\r\n                if (user.bigCycle >= 10 && user.bigCycle < 20) inviteSendQ = currBalance.div(100);\r\n                else if (user.bigCycle >= 20 && user.bigCycle < 30) inviteSendQ = currBalance.div(50);\r\n                else if (user.bigCycle >= 30) inviteSendQ = currBalance.div(100).mul(3);\r\n\r\n                bool isEnough = false;\r\n                uint resultMoneyQ = 0;\r\n                (isEnough, resultMoneyQ) = isEnoughBalance(bonusSend.add(inviteSendQ));\r\n                if (resultMoneyQ > 0) {\r\n                    address payable sendAddr = address(uint160(userAddr));\r\n                    sendMoneyToUser(sendAddr, resultMoneyQ);\r\n                }\r\n            }\r\n            user.lastRwTime = now;\r\n            if (userGlobal.status == 1) {\r\n                user.rewardIndex = user.rewardIndex.add(1);\r\n                continue;\r\n            }\r\n\r\n            if (user.id != 0 && user.freezeAmount >= 1 ether && user.freezeAmount <= bonuslimit) {\r\n                if (user.investTimes < 7) {\r\n                    bonusSend += user.dayBonusAmount;\r\n                    user.bonusAmount = user.bonusAmount.add(bonusSend);\r\n                    user.investTimes = user.investTimes.add(1);\r\n                } else {\r\n                    user.freeAmount = user.freeAmount.add(user.freezeAmount);\r\n                    user.freezeAmount = 0;\r\n                    user.dayBonusAmount = 0;\r\n                    user.level = 0;\r\n                }\r\n            }\r\n            uint lineAmount = user.freezeAmount.add(user.freeAmount).add(user.lineAmount);\r\n            if (lineAmount < 1 ether || lineAmount > withdrawLimit) {\r\n                user.rewardIndex = user.rewardIndex.add(1);\r\n                continue;\r\n            }\r\n            uint inviteSend = 0;\r\n            if (userGlobal.status == 0) {\r\n                AwardData memory awData = userAwardDataMapping[rid][userAddr][user.rewardIndex];\r\n                user.rewardIndex = user.rewardIndex.add(1);\r\n                uint lineValue = lineAmount.div(ethWei);\r\n                if (lineValue >= 15) {\r\n                    inviteSend += awData.threeInvAmount;\r\n                } else {\r\n                    if (user.lineLevel == 1 && lineAmount >= 1 ether && awData.oneInvAmount > 0) inviteSend += awData.oneInvAmount.div(15).mul(lineValue).div(2);\r\n\r\n                    if (user.lineLevel == 2 && lineAmount >= 6 ether && (awData.oneInvAmount > 0 || awData.twoInvAmount > 0)) {\r\n                        inviteSend += awData.oneInvAmount.div(15).mul(lineValue).mul(7).div(10);\r\n                        inviteSend += awData.twoInvAmount.div(15).mul(lineValue).mul(5).div(7);\r\n                    }\r\n                    if (user.lineLevel == 3 && lineAmount >= 11 ether && awData.threeInvAmount > 0) inviteSend += awData.threeInvAmount.div(15).mul(lineValue);\r\n\r\n                    if (user.lineLevel < 3) {\r\n                        uint fireSc = getFireScByLevel(user.lineLevel);\r\n                        inviteSend = inviteSend.mul(fireSc).div(10);\r\n                    }\r\n                }\r\n            } else if (userGlobal.status == 2) user.rewardIndex = user.rewardIndex.add(1);\r\n\r\n            if (bonusSend.add(inviteSend) <= sendLimit) {\r\n                user.inviteAmonut = user.inviteAmonut.add(inviteSend);\r\n                bool isEnough = false;\r\n                uint resultMoney = 0;\r\n                (isEnough, resultMoney) = isEnoughBalance(bonusSend.add(inviteSend));\r\n                if (resultMoney > 0) {\r\n                    uint confortMoney = resultMoney.div(10);\r\n                    sendMoneyToUser(comfortAddr, confortMoney);\r\n                    resultMoney = resultMoney.sub(confortMoney);\r\n                    address payable sendAddr = address(uint160(userAddr));\r\n                    sendMoneyToUser(sendAddr, resultMoney);\r\n                }\r\n            }\r\n\r\n        }\r\n        _time = now;\r\n    }\r\n\r\n    function isEnoughBalance(uint sendMoney) private view returns (bool, uint){\r\n        if (sendMoney >= address(this).balance) return (false, address(this).balance);\r\n        else return (true, sendMoney);\r\n    }\r\n\r\n    function sendFeetoAdmin(uint amount) private {\r\n        devAddr.transfer(amount.div(20));\r\n    }\r\n\r\n    function sendMoneyToUser(address payable userAddress, uint money) private {\r\n        if (money > 0) userAddress.transfer(money);\r\n    }\r\n\r\n    function isUsed(string memory code) public view returns (bool) {\r\n        address addr = addressMapping[code];\r\n        return uint(addr) != 0;\r\n    }\r\n\r\n    function getUserAddressByCode(string memory code) public view returns (address) {\r\n        require(isWhitelistAdmin(msg.sender), \"Permission denied\");\r\n        return addressMapping[code];\r\n    }\r\n\r\n    function registerUser(address addr, string memory inviteCode, string memory beCode) private {\r\n        UserGlobal storage userGlobal = userMapping[addr];\r\n        uid++;\r\n        userGlobal.id = uid;\r\n        userGlobal.userAddress = addr;\r\n        userGlobal.inviteCode = inviteCode;\r\n        userGlobal.beCode = beCode;\r\n        addressMapping[inviteCode] = addr;\r\n        indexMapping[uid] = addr;\r\n    }\r\n\r\n    function endRound() external onlyOwner {\r\n        require(address(this).balance < 1 ether, \"contract balance must be lower than 1 ether\");\r\n        rid++;\r\n        startTime = now.add(period).div(1 days).mul(1 days);\r\n        canSetStartTime = 1;\r\n    }\r\n\r\n    function donnottouch() public view returns (uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint) {\r\n        return (\r\n        rid,\r\n        uid,\r\n        startTime,\r\n        rInvestCount[rid],\r\n        rInvestMoney[rid],\r\n        bonuslimit,\r\n        sendLimit,\r\n        withdrawLimit,\r\n        canImport,\r\n        lineStatus,\r\n        lineArrayMapping[rid].length,\r\n        canSetStartTime\r\n        );\r\n    }\r\n\r\n    function getUserByAddress(address addr, uint roundId) public view returns (uint[15] memory info, string memory inviteCode, string memory beCode) {\r\n        require(isWhitelistAdmin(msg.sender) || msg.sender == addr, \"Permission denied for view user's privacy\");\r\n        if (roundId == 0) roundId = rid;\r\n        UserGlobal memory userGlobal = userMapping[addr];\r\n        User memory user = userRoundMapping[roundId][addr];\r\n        info[0] = userGlobal.id;\r\n        info[1] = user.lineAmount;\r\n        info[2] = user.freeAmount;\r\n        info[3] = user.freezeAmount;\r\n        info[4] = user.inviteAmonut;\r\n        info[5] = user.bonusAmount;\r\n        info[6] = user.lineLevel;\r\n        info[7] = user.dayBonusAmount;\r\n        info[8] = user.rewardIndex;\r\n        info[9] = user.investTimes;\r\n        info[10] = user.level;\r\n        uint grantAmount = 0;\r\n        if (user.id > 0 && user.freezeAmount >= 1 ether && user.freezeAmount <= bonuslimit && user.investTimes < 7 && userGlobal.status != 1) grantAmount += user.dayBonusAmount;\r\n        if (userGlobal.status == 0) {\r\n            uint inviteSend = 0;\r\n            AwardData memory awData = userAwardDataMapping[rid][user.userAddress][user.rewardIndex];\r\n            uint lineAmount = user.freezeAmount.add(user.freeAmount).add(user.lineAmount);\r\n            if (lineAmount >= 1 ether) {\r\n                uint lineValue = lineAmount.div(ethWei);\r\n                if (lineValue >= 15) inviteSend += awData.threeInvAmount;\r\n                else {\r\n                    if (user.lineLevel == 1 && lineAmount >= 1 ether && awData.oneInvAmount > 0) inviteSend += awData.oneInvAmount.div(15).mul(lineValue).div(2);\r\n                    if (user.lineLevel == 2 && lineAmount >= 1 ether && (awData.oneInvAmount > 0 || awData.twoInvAmount > 0)) {\r\n                        inviteSend += awData.oneInvAmount.div(15).mul(lineValue).mul(7).div(10);\r\n                        inviteSend += awData.twoInvAmount.div(15).mul(lineValue).mul(5).div(7);\r\n                    }\r\n                    if (user.lineLevel == 3 && lineAmount >= 1 ether && awData.threeInvAmount > 0) inviteSend += awData.threeInvAmount.div(15).mul(lineValue);\r\n                    if (user.lineLevel < 3) {\r\n                        uint fireSc = getFireScByLevel(user.lineLevel);\r\n                        inviteSend = inviteSend.mul(fireSc).div(10);\r\n                    }\r\n                }\r\n                grantAmount += inviteSend;\r\n            }\r\n        }\r\n        info[11] = grantAmount;\r\n        info[12] = user.lastRwTime;\r\n        info[13] = userGlobal.status;\r\n        info[14] = user.bigCycle;\r\n        return (info, userGlobal.inviteCode, userGlobal.beCode);\r\n    }\r\n\r\n    function getUserAddressById(uint id) public view returns (address) {\r\n        require(isWhitelistAdmin(msg.sender), \"Permission denied\");\r\n        return indexMapping[id];\r\n    }\r\n\r\n    function getLineUserId(uint index, uint rouId) public view returns (uint) {\r\n        require(isWhitelistAdmin(msg.sender), \"Permission denied\");\r\n        if (rouId == 0) rouId = rid;\r\n        return lineArrayMapping[rid][index];\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"mul overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"div zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"lower sub bigger\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"overflow\");\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"mod zero\");\r\n        return a % b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? b : a;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"actUserStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"adWithDraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"christmas\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_str\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"compareStr\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"donnotimitate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"donnottouch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"inviteCode\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"beCode\",\"type\":\"string\"}],\"name\":\"exit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"getFireScByLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"getLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rouId\",\"type\":\"uint256\"}],\"name\":\"getLineUserId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"times\",\"type\":\"uint256\"}],\"name\":\"getRecommendScaleByLevelAndTim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"getScByLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"}],\"name\":\"getUserAddressByCode\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getUserAddressById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getUserByAddress\",\"outputs\":[{\"internalType\":\"uint256[15]\",\"name\":\"info\",\"type\":\"uint256[15]\"},{\"internalType\":\"string\",\"name\":\"inviteCode\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"beCode\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"happy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"inviteCode\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"beCode\",\"type\":\"string\"}],\"name\":\"importGlobal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"}],\"name\":\"isUsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelistAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"repeatPldge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopImport\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"}],\"name\":\"updateCycle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"line\",\"type\":\"uint256\"}],\"name\":\"updateLine\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"verydangerous\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GLSC","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://1b04e436f7973257b6d6873e0d68b3140e200a97b6628689798809969eb0521b"}]}