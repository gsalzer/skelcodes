{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20.sol\":{\"content\":\"pragma solidity ^0.6.1;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see `ERC20Detailed`.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a `Transfer` event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through `transferFrom`. This is\\n   * zero by default.\\n   *\\n   * This value changes when `approve` or `transferFrom` are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * \\u003e Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an `Approval` event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a `Transfer` event.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to `approve`. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"PaymentContract.sol\":{\"content\":\"pragma solidity ^0.6.1;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * Contract that will forward any incoming Ether to the recipient\\r\\n */\\r\\ncontract PaymentContract {\\r\\n\\r\\n  // Address to which any funds sent to this contract will be forwarded to\\r\\n  address payable private _recipient;\\r\\n\\r\\n  event ForwarderDeposited(address from, uint256 value, bytes data);\\r\\n  event TokensFlushed(address receiveAddress, uint256 value, address tokenContractAddress);\\r\\n\\r\\n  /**\\r\\n   * Create the contract, and sets the destination address to that of the creator\\r\\n   */\\r\\n  constructor(address payable recipient) public payable {\\r\\n    _recipient = recipient;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Modifier that will execute internal code block only if the sender is the recipient address\\r\\n   */\\r\\n  modifier onlyReceipent {\\r\\n    require(msg.sender == _recipient, \\\"Sender is not the recipient address\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  receive() external payable {\\r\\n    // throws on failure\\r\\n    _recipient.transfer(msg.value);\\r\\n\\r\\n    // Fire off the deposited event if we can forward it\\r\\n    emit ForwarderDeposited(msg.sender, msg.value, msg.data);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Default function; Gets called when Ether is deposited, and forwards it to the recipient address\\r\\n   */\\r\\n  // fallback() external payable {\\r\\n  //   // throws on failure\\r\\n  //   _recipient.transfer(msg.value);\\r\\n\\r\\n  //   // Fire off the deposited event if we can forward it\\r\\n  //   emit ForwarderDeposited(msg.sender, msg.value, msg.data);\\r\\n  // }\\r\\n\\r\\n  function changeReceipent(address payable newReceipent) public onlyReceipent {\\r\\n      _recipient = newReceipent;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Execute a token transfer of the full balance from the forwarder token to the recipient address\\r\\n   * @param tokenContractAddress the address of the erc20 token contract\\r\\n   */\\r\\n  function flushTokens(address tokenContractAddress) public {\\r\\n    IERC20 instance = IERC20(tokenContractAddress);\\r\\n    uint256 balance = instance.balanceOf(address(this));\\r\\n\\r\\n    require(balance \\u003e 0, \\\"Token balance is zero\\\");\\r\\n\\r\\n    require(instance.transfer(_recipient, balance), \\\"Transfer token failed\\\");\\r\\n\\r\\n    // fire of an event just for the record!\\r\\n    emit TokensFlushed(_recipient, balance, tokenContractAddress);\\r\\n  }\\r\\n}\\r\\n\\r\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ForwarderDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiveAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"}],\"name\":\"TokensFlushed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newReceipent\",\"type\":\"address\"}],\"name\":\"changeReceipent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"}],\"name\":\"flushTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"PaymentContract","CompilerVersion":"v0.6.1+commit.e6f7d5a4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000055843a14f0bb20aac64b0f8858780d4cd5dcb2dd","Library":"","LicenseType":"None","SwarmSource":"ipfs://29d98eb8347a6363d222a56da530a5378d6bedcbc7367748f564ea823e3dcea7"}]}