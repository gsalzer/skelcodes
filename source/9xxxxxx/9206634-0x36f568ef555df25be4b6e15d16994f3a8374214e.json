{"status":"1","message":"OK","result":[{"SourceCode":"/**\nAuthor: Loopring Foundation (Loopring Project Ltd)\n*/\n\npragma solidity ^0.5.11;\n\n\ncontract Proxy {\n  \n  function implementation() public view returns (address);\n\n  \n  function () payable external {\n    address _impl = implementation();\n    require(_impl != address(0));\n\n    assembly {\n      let ptr := mload(0x40)\n      calldatacopy(ptr, 0, calldatasize)\n      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n      let size := returndatasize\n      returndatacopy(ptr, 0, size)\n\n      switch result\n      case 0 { revert(ptr, size) }\n      default { return(ptr, size) }\n    }\n  }\n}\n\ncontract SimpleProxy is Proxy\n{\n    bytes32 private constant implementationPosition = keccak256(\n        \"org.loopring.protocol.simple.proxy\"\n    );\n\n    constructor(address _implementation)\n        public\n    {\n        bytes32 position = implementationPosition;\n        assembly {sstore(position, _implementation) }\n    }\n\n    function implementation()\n        public\n        view\n        returns (address impl)\n    {\n        bytes32 position = implementationPosition;\n        assembly { impl := sload(position) }\n    }\n}\n\nlibrary ERC20SafeTransfer {\n    function safeTransferAndVerify(\n        address token,\n        address to,\n        uint    value\n        )\n        internal\n    {\n        safeTransferWithGasLimitAndVerify(\n            token,\n            to,\n            value,\n            gasleft()\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint    value\n        )\n        internal\n        returns (bool)\n    {\n        return safeTransferWithGasLimit(\n            token,\n            to,\n            value,\n            gasleft()\n        );\n    }\n\n    function safeTransferWithGasLimitAndVerify(\n        address token,\n        address to,\n        uint    value,\n        uint    gasLimit\n        )\n        internal\n    {\n        require(\n            safeTransferWithGasLimit(token, to, value, gasLimit),\n            \"TRANSFER_FAILURE\"\n        );\n    }\n\n    function safeTransferWithGasLimit(\n        address token,\n        address to,\n        uint    value,\n        uint    gasLimit\n        )\n        internal\n        returns (bool)\n    {\n        \n        \n        \n\n        \n        bytes memory callData = abi.encodeWithSelector(\n            bytes4(0xa9059cbb),\n            to,\n            value\n        );\n        (bool success, ) = token.call.gas(gasLimit)(callData);\n        return checkReturnValue(success);\n    }\n\n    function safeTransferFromAndVerify(\n        address token,\n        address from,\n        address to,\n        uint    value\n        )\n        internal\n    {\n        safeTransferFromWithGasLimitAndVerify(\n            token,\n            from,\n            to,\n            value,\n            gasleft()\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint    value\n        )\n        internal\n        returns (bool)\n    {\n        return safeTransferFromWithGasLimit(\n            token,\n            from,\n            to,\n            value,\n            gasleft()\n        );\n    }\n\n    function safeTransferFromWithGasLimitAndVerify(\n        address token,\n        address from,\n        address to,\n        uint    value,\n        uint    gasLimit\n        )\n        internal\n    {\n        bool result = safeTransferFromWithGasLimit(\n            token,\n            from,\n            to,\n            value,\n            gasLimit\n        );\n        require(result, \"TRANSFER_FAILURE\");\n    }\n\n    function safeTransferFromWithGasLimit(\n        address token,\n        address from,\n        address to,\n        uint    value,\n        uint    gasLimit\n        )\n        internal\n        returns (bool)\n    {\n        \n        \n        \n\n        \n        bytes memory callData = abi.encodeWithSelector(\n            bytes4(0x23b872dd),\n            from,\n            to,\n            value\n        );\n        (bool success, ) = token.call.gas(gasLimit)(callData);\n        return checkReturnValue(success);\n    }\n\n    function checkReturnValue(\n        bool success\n        )\n        internal\n        pure\n        returns (bool)\n    {\n        \n        \n        \n        if (success) {\n            assembly {\n                switch returndatasize()\n                \n                case 0 {\n                    success := 1\n                }\n                \n                case 32 {\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)\n                }\n                \n                default {\n                    success := 0\n                }\n            }\n        }\n        return success;\n    }\n}\n\nlibrary Cloneable {\n    function clone(address a)\n        external\n        returns (address)\n    {\n\n    \n        address retval;\n        assembly{\n            mstore(0x0, or (0x5880730000000000000000000000000000000000000000803b80938091923cF3 ,mul(a,0x1000000000000000000)))\n            retval := create(0,0, 32)\n        }\n        return retval;\n    }\n}\n\ncontract Ownable {\n    address public owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    \n    \n    constructor()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    \n    modifier onlyOwner()\n    {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n        _;\n    }\n\n    \n    \n    \n    function transferOwnership(\n        address newOwner\n        )\n        public\n        onlyOwner\n    {\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function renounceOwnership()\n        public\n        onlyOwner\n    {\n        emit OwnershipTransferred(owner, address(0));\n        owner = address(0);\n    }\n}\n\ncontract Claimable is Ownable\n{\n    address public pendingOwner;\n\n    \n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner, \"UNAUTHORIZED\");\n        _;\n    }\n\n    \n    \n    function transferOwnership(\n        address newOwner\n        )\n        public\n        onlyOwner\n    {\n        require(newOwner != address(0) && newOwner != owner, \"INVALID_ADDRESS\");\n        pendingOwner = newOwner;\n    }\n\n    \n    function claimOwnership()\n        public\n        onlyPendingOwner\n    {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n}\n\ncontract ReentrancyGuard {\n    \n    uint private _guardValue;\n\n    \n    modifier nonReentrant()\n    {\n        \n        require(_guardValue == 0, \"REENTRANCY\");\n\n        \n        _guardValue = 1;\n\n        \n        _;\n\n        \n        _guardValue = 0;\n    }\n}\n\ncontract IExchange is Claimable, ReentrancyGuard\n{\n    string constant public version = \"\"; \n\n    event Cloned (address indexed clone);\n\n    \n    \n    function clone()\n        external\n        nonReentrant\n        returns (address cloneAddress)\n    {\n        address origin = address(this);\n        cloneAddress = Cloneable.clone(origin);\n\n        assert(cloneAddress != origin);\n        assert(cloneAddress != address(0));\n\n        emit Cloned(cloneAddress);\n    }\n}\n\ncontract ILoopring is Claimable, ReentrancyGuard\n{\n    string  constant public version = \"\"; \n\n    uint    public exchangeCreationCostLRC;\n    address public universalRegistry;\n    address public lrcAddress;\n\n    event ExchangeInitialized(\n        uint    indexed exchangeId,\n        address indexed exchangeAddress,\n        address indexed owner,\n        address         operator,\n        bool            onchainDataAvailability\n    );\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function initializeExchange(\n        address exchangeAddress,\n        uint    exchangeId,\n        address owner,\n        address payable operator,\n        bool    onchainDataAvailability\n        )\n        external;\n}\n\ncontract ILoopringV3 is ILoopring\n{\n    \n\n    event ExchangeStakeDeposited(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event ExchangeStakeWithdrawn(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event ExchangeStakeBurned(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event ProtocolFeeStakeDeposited(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event ProtocolFeeStakeWithdrawn(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event SettingsUpdated(\n        uint            time\n    );\n\n    \n    struct Exchange\n    {\n        address exchangeAddress;\n        uint    exchangeStake;\n        uint    protocolFeeStake;\n    }\n\n    mapping (uint => Exchange) internal exchanges;\n\n    string  constant public version = \"3.1\";\n\n    address public wethAddress;\n    uint    public totalStake;\n    address public blockVerifierAddress;\n    address public downtimeCostCalculator;\n    uint    public maxWithdrawalFee;\n    uint    public withdrawalFineLRC;\n    uint    public tokenRegistrationFeeLRCBase;\n    uint    public tokenRegistrationFeeLRCDelta;\n    uint    public minExchangeStakeWithDataAvailability;\n    uint    public minExchangeStakeWithoutDataAvailability;\n    uint    public revertFineLRC;\n    uint8   public minProtocolTakerFeeBips;\n    uint8   public maxProtocolTakerFeeBips;\n    uint8   public minProtocolMakerFeeBips;\n    uint8   public maxProtocolMakerFeeBips;\n    uint    public targetProtocolTakerFeeStake;\n    uint    public targetProtocolMakerFeeStake;\n\n    address payable public protocolFeeVault;\n\n    \n    \n    \n    \n    \n    \n    function updateSettings(\n        address payable _protocolFeeVault,   \n        address _blockVerifierAddress,       \n        address _downtimeCostCalculator,     \n        uint    _exchangeCreationCostLRC,\n        uint    _maxWithdrawalFee,\n        uint    _tokenRegistrationFeeLRCBase,\n        uint    _tokenRegistrationFeeLRCDelta,\n        uint    _minExchangeStakeWithDataAvailability,\n        uint    _minExchangeStakeWithoutDataAvailability,\n        uint    _revertFineLRC,\n        uint    _withdrawalFineLRC\n        )\n        external;\n\n    \n    \n    \n    \n    \n    function updateProtocolFeeSettings(\n        uint8 _minProtocolTakerFeeBips,\n        uint8 _maxProtocolTakerFeeBips,\n        uint8 _minProtocolMakerFeeBips,\n        uint8 _maxProtocolMakerFeeBips,\n        uint  _targetProtocolTakerFeeStake,\n        uint  _targetProtocolMakerFeeStake\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function canExchangeCommitBlocks(\n        uint exchangeId,\n        bool onchainDataAvailability\n        )\n        external\n        view\n        returns (bool);\n\n    \n    \n    \n    function getExchangeStake(\n        uint exchangeId\n        )\n        public\n        view\n        returns (uint stakedLRC);\n\n    \n    \n    \n    \n    \n    function burnExchangeStake(\n        uint exchangeId,\n        uint amount\n        )\n        external\n        returns (uint burnedLRC);\n\n    \n    \n    \n    \n    function depositExchangeStake(\n        uint exchangeId,\n        uint amountLRC\n        )\n        external\n        returns (uint stakedLRC);\n\n    \n    \n    \n    \n    \n    \n    function withdrawExchangeStake(\n        uint    exchangeId,\n        address recipient,\n        uint    requestedAmount\n        )\n        external\n        returns (uint amount);\n\n    \n    \n    \n    \n    function depositProtocolFeeStake(\n        uint exchangeId,\n        uint amountLRC\n        )\n        external\n        returns (uint stakedLRC);\n\n    \n    \n    \n    \n    \n    function withdrawProtocolFeeStake(\n        uint    exchangeId,\n        address recipient,\n        uint    amount\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    function getProtocolFeeValues(\n        uint exchangeId,\n        bool onchainDataAvailability\n        )\n        external\n        view\n        returns (\n            uint8 takerFeeBips,\n            uint8 makerFeeBips\n        );\n\n    \n    \n    \n    function getProtocolFeeStake(\n        uint exchangeId\n        )\n        external\n        view\n        returns (uint protocolFeeStake);\n}\n\ncontract IUniversalRegistry is Claimable, ReentrancyGuard\n{\n    enum ForgeMode {\n        AUTO_UPGRADABLE,\n        MANUAL_UPGRADABLE,\n        PROXIED,\n        NATIVE\n    }\n\n    \n\n    event ProtocolRegistered (\n        address indexed protocol,\n        address indexed implementationManager,\n        string          version\n    );\n\n    event ProtocolEnabled (\n        address indexed protocol\n    );\n\n    event ProtocolDisabled (\n        address indexed protocol\n    );\n\n    event DefaultProtocolChanged (\n        address indexed oldDefault,\n        address indexed newDefault\n    );\n\n    event ExchangeForged (\n        address indexed protocol,\n        address indexed implementation,\n        address indexed exchangeAddress,\n        address         owner,\n        ForgeMode       forgeMode,\n        bool            onchainDataAvailability,\n        uint            exchangeId,\n        uint            amountLRCBurned\n    );\n\n    \n\n    address   public lrcAddress;\n    address[] public exchanges;\n    address[] public protocols;\n\n    \n    mapping (string => address) public versionMap;\n\n    \n\n    \n    \n    \n    \n    function registerProtocol(\n        address protocol,\n        address implementation\n        )\n        external\n        returns (address implManager);\n\n    \n    \n    function setDefaultProtocol(\n        address protocol\n        )\n        external;\n\n    \n    \n    function enableProtocol(\n        address protocol\n        )\n        external;\n\n    \n    \n    function disableProtocol(\n        address protocol\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function forgeExchange(\n        ForgeMode forgeMode,\n        bool      onchainDataAvailability,\n        address   protocol,\n        address   implementation\n        )\n        external\n        returns (\n            address exchangeAddress,\n            uint    exchangeId\n        );\n\n    \n    \n    \n    \n    \n    function defaultProtocol()\n        public\n        view\n        returns (\n            address protocol,\n            address versionmanager,\n            address defaultImpl,\n            string  memory protocolVersion,\n            string  memory defaultImplVersion\n        );\n\n    \n    \n    \n    function isProtocolRegistered(\n        address protocol\n        )\n        public\n        view\n        returns (bool registered);\n\n    \n    \n    \n    function isProtocolEnabled(\n        address protocol\n        )\n        public\n        view\n        returns (bool enabled);\n\n    \n    \n    function isExchangeRegistered(\n        address exchange\n        )\n        public\n        view\n        returns (bool registered);\n\n    \n    \n    \n    \n    function isProtocolAndImplementationEnabled(\n        address protocol,\n        address implementation\n        )\n        public\n        view\n        returns (bool enabled);\n\n    \n    \n    \n    \n    \n    function getExchangeProtocol(\n        address exchangeAddress\n        )\n        public\n        view\n        returns (\n            address protocol,\n            address manager\n        );\n}\n\ncontract IImplementationManager is Claimable, ReentrancyGuard\n{\n    \n\n    event DefaultChanged (\n        address indexed oldDefault,\n        address indexed newDefault\n    );\n\n    event Registered (\n        address indexed implementation,\n        string          version\n    );\n\n    event Enabled (\n        address indexed implementation\n    );\n\n    event Disabled (\n        address indexed implementation\n    );\n\n    \n\n    address   public protocol;\n    address   public defaultImpl;\n    address[] public implementations;\n\n    \n    mapping (string => address) public versionMap;\n\n    \n\n    \n    \n    function register(\n        address implementation\n        )\n        external;\n\n    \n    \n    function setDefault(\n        address implementation\n        )\n        external;\n\n    \n    \n    function enable(\n        address implementation\n        )\n        external;\n\n    \n    \n    function disable(\n        address implementation\n        )\n        external;\n\n    \n    \n    \n    function version()\n        public\n        view\n        returns (\n            string  memory protocolVersion,\n            string  memory defaultImplVersion\n        );\n\n    \n    \n    function latest()\n        public\n        view\n        returns (address implementation);\n\n    \n    \n    function isRegistered(\n        address implementation\n        )\n        public\n        view\n        returns (bool registered);\n\n    \n    \n    function isEnabled(\n        address implementation\n        )\n        public\n        view\n        returns (bool enabled);\n}\n\ncontract IExchangeProxy is Proxy\n{\n    bytes32 private constant registryPosition = keccak256(\n        \"org.loopring.protocol.v3.registry\"\n    );\n\n    constructor(address _registry)\n        public\n    {\n        setRegistry(_registry);\n    }\n\n    \n    function registry()\n        public\n        view\n        returns (address registryAddress)\n    {\n        bytes32 position = registryPosition;\n        assembly { registryAddress := sload(position) }\n    }\n\n    \n    function protocol()\n        public\n        view\n        returns (address protocolAddress)\n    {\n        IUniversalRegistry r = IUniversalRegistry(registry());\n        (protocolAddress, ) = r.getExchangeProtocol(address(this));\n    }\n\n    function setRegistry(address _registry)\n        private\n    {\n        require(_registry != address(0), \"ZERO_ADDRESS\");\n        bytes32 position = registryPosition;\n        assembly { sstore(position, _registry) }\n    }\n}\n\ncontract AutoUpgradabilityProxy is IExchangeProxy\n{\n    constructor(address _registry) public IExchangeProxy(_registry) {}\n\n    function implementation()\n        public\n        view\n        returns (address)\n    {\n        IUniversalRegistry r = IUniversalRegistry(registry());\n        (, address managerAddr) = r.getExchangeProtocol(address(this));\n        return IImplementationManager(managerAddr).defaultImpl();\n    }\n}\n\ncontract ManualUpgradabilityProxy is IExchangeProxy\n{\n    event Upgraded(address indexed implementation);\n\n    bytes32 private constant implementationPosition = keccak256(\n        \"org.loopring.protocol.v3.implementation\"\n    );\n\n    modifier onlyUnderlyingOwner()\n    {\n        address underlyingOwner = Ownable(address(this)).owner();\n        require(underlyingOwner != address(0), \"NO_OWNER\");\n        require(underlyingOwner == msg.sender, \"UNAUTHORIZED\");\n        _;\n    }\n\n    constructor(\n        address _registry,\n        address _implementation\n        )\n        public\n        IExchangeProxy(_registry)\n    {\n        setImplementation(_implementation);\n    }\n\n    function implementation()\n        public\n        view\n        returns (address impl)\n    {\n        bytes32 position = implementationPosition;\n        assembly { impl := sload(position) }\n    }\n\n    function upgradeTo(\n        address newImplementation\n        )\n        external\n        onlyUnderlyingOwner\n    {\n        require(implementation() != newImplementation, \"SAME_IMPLEMENTATION\");\n\n        IUniversalRegistry r = IUniversalRegistry(registry());\n        require(\n            r.isProtocolAndImplementationEnabled(protocol(), newImplementation),\n            \"INVALID_PROTOCOL_OR_IMPLEMENTATION\"\n        );\n\n        setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    function setImplementation(\n        address newImplementation\n        )\n        private\n    {\n        bytes32 position = implementationPosition;\n        assembly {sstore(position, newImplementation) }\n    }\n}\n\ncontract ImplementationManager is IImplementationManager\n{\n    struct Status\n    {\n        bool registered;\n        bool enabled;\n    }\n\n    \n    mapping (address => Status) private statusMap;\n\n    constructor(\n        address _owner,\n        address _protocol,\n        address _implementation\n        )\n        public\n    {\n        require(_owner != address(0), \"ZERO_ADDRESS\");\n        require(_protocol != address(0), \"ZERO_PROTOCOL\");\n\n        owner = _owner;\n        protocol = _protocol;\n        defaultImpl = _implementation;\n\n        registerInternal(_implementation);\n    }\n\n    \n\n    function register(\n        address implementation\n        )\n        external\n        nonReentrant\n        onlyOwner\n    {\n        registerInternal(implementation);\n    }\n\n    function setDefault(\n        address implementation\n        )\n        external\n        nonReentrant\n        onlyOwner\n    {\n        require(implementation != defaultImpl, \"SAME_IMPLEMENTATION\");\n        require(isEnabled(implementation), \"INVALID_IMPLEMENTATION\");\n\n        address oldDefault = defaultImpl;\n        defaultImpl = implementation;\n\n        emit DefaultChanged(\n            oldDefault,\n            implementation\n        );\n    }\n\n    function enable(\n        address implementation\n        )\n        external\n        nonReentrant\n        onlyOwner\n    {\n        Status storage status = statusMap[implementation];\n        require(status.registered && !status.enabled, \"INVALID_IMPLEMENTATION\");\n\n        status.enabled = true;\n        emit Enabled(implementation);\n    }\n\n    function disable(\n        address implementation\n        )\n        external\n        nonReentrant\n        onlyOwner\n    {\n        require(implementation != defaultImpl, \"FORBIDDEN\");\n        require(isEnabled(implementation), \"INVALID_IMPLEMENTATION\");\n\n        statusMap[implementation].enabled = false;\n        emit Disabled(implementation);\n    }\n\n    function version()\n        public\n        view\n        returns (\n            string  memory protocolVersion,\n            string  memory defaultImplVersion\n        )\n    {\n        protocolVersion = ILoopring(protocol).version();\n        defaultImplVersion = IExchange(defaultImpl).version();\n    }\n\n    function latest()\n        public\n        view\n        returns (address)\n    {\n        return implementations[implementations.length - 1];\n    }\n\n    function isRegistered(\n        address implementation\n        )\n        public\n        view\n        returns (bool)\n    {\n        return statusMap[implementation].registered;\n    }\n\n    function isEnabled(\n        address implementation\n        )\n        public\n        view\n        returns (bool)\n    {\n        return statusMap[implementation].enabled;\n    }\n\n    function registerInternal(\n        address implementation\n        )\n        internal\n    {\n        require(implementation != address(0), \"INVALID_IMPLEMENTATION\");\n\n        string memory _version = IExchange(implementation).version();\n        require(bytes(_version).length >= 3, \"INVALID_VERSION\");\n        require(versionMap[_version] == address(0), \"VERSION_USED\");\n        require(!statusMap[implementation].registered, \"ALREADY_REGISTERED\");\n\n        implementations.push(implementation);\n        statusMap[implementation] = Status(true, true);\n        versionMap[_version] = implementation;\n\n        emit Registered(implementation, _version);\n    }\n}\n\ncontract UniversalRegistry is IUniversalRegistry {\n\n    using ERC20SafeTransfer for address;\n\n    struct Protocol\n    {\n        address protocol;\n        bool    registered;\n        bool    enabled;\n        address manager;\n        string  version;\n    }\n\n    \n    mapping (address => address) private exchangeMap;\n     \n    mapping (address => Protocol) private protocolMap;\n\n    address private defaultProtocolAddress;\n\n    \n    constructor(\n        address _lrcAddress\n        )\n        Claimable()\n        public\n    {\n        require(_lrcAddress != address(0), \"ZERO_ADDRESS\");\n        lrcAddress = _lrcAddress;\n    }\n\n    function registerProtocol(\n        address protocol,\n        address implementation\n        )\n        external\n        nonReentrant\n        onlyOwner\n        returns (address manager)\n    {\n        require(!protocolMap[protocol].registered, \"PROTOCOL_REGISTERED\");\n\n        ILoopring loopring = ILoopring(protocol);\n        require(loopring.universalRegistry() == address(this), \"REGISTRY_MISMATCH\");\n        require(loopring.owner() == owner, \"OWNER_MISMATCH\");\n        require(loopring.lrcAddress() == lrcAddress, \"LRC_ADDRESS_MISMATCH\");\n\n        IImplementationManager m = new ImplementationManager(owner, protocol, implementation);\n        manager = address(m);\n\n        string memory version = loopring.version();\n        require(versionMap[version] == address(0), \"VERSION_REGISTERED\");\n        require(!protocolMap[protocol].registered, \"PROTOCOL_REGISTERED\");\n\n        protocols.push(protocol);\n        versionMap[version] = protocol;\n        protocolMap[protocol] = Protocol(protocol, true, true, manager, version);\n\n        if (defaultProtocolAddress == address(0)) {\n            defaultProtocolAddress = protocol;\n        }\n\n        emit ProtocolRegistered(protocol, manager, version);\n    }\n\n    function setDefaultProtocol(\n        address protocol\n        )\n        external\n        nonReentrant\n        onlyOwner\n    {\n        require(protocol != defaultProtocolAddress, \"SAME_PROTOCOL\");\n        require(protocolMap[protocol].registered, \"NOT_REGISTERED\");\n        require(protocolMap[protocol].enabled, \"PROTOCOL_DISABLED\");\n        address oldDefault = defaultProtocolAddress;\n        defaultProtocolAddress = protocol;\n        emit DefaultProtocolChanged(oldDefault, defaultProtocolAddress);\n    }\n\n    function enableProtocol(\n        address protocol\n        )\n        external\n        nonReentrant\n        onlyOwner\n    {\n        require(protocolMap[protocol].registered, \"NOT_REGISTERED\");\n        require(!protocolMap[protocol].enabled, \"ALREADY_ENABLED\");\n\n        protocolMap[protocol].enabled = true;\n        emit ProtocolEnabled(protocol);\n    }\n\n    function disableProtocol(\n        address protocol\n        )\n        external\n        nonReentrant\n        onlyOwner\n    {\n        require(protocolMap[protocol].enabled, \"ALREADY_DISABLED\");\n\n        protocolMap[protocol].enabled = false;\n        emit ProtocolDisabled(protocol);\n    }\n\n    function forgeExchange(\n        ForgeMode forgeMode,\n        bool      onchainDataAvailability,\n        address   protocol,\n        address   implementation\n        )\n        external\n        nonReentrant\n        returns (\n            address exchangeAddress,\n            uint    exchangeId\n        )\n    {\n        (address _protocol, address _implementation) = getProtocolAndImplementationToUse(\n            protocol,\n            implementation\n        );\n\n        ILoopringV3 loopring = ILoopringV3(_protocol);\n        uint exchangeCreationCostLRC = loopring.exchangeCreationCostLRC();\n        address feeVault = loopring.protocolFeeVault();\n\n        if (exchangeCreationCostLRC > 0) {\n            lrcAddress.safeTransferFromAndVerify(\n                msg.sender,\n                feeVault,\n                exchangeCreationCostLRC\n            );\n        }\n\n        exchangeAddress = forgeInternal(forgeMode, _implementation);\n        assert(exchangeMap[exchangeAddress] == address(0));\n\n        exchangeMap[exchangeAddress] = _protocol;\n        exchanges.push(exchangeAddress);\n        exchangeId = exchanges.length;\n\n        loopring.initializeExchange(\n            exchangeAddress,\n            exchangeId,\n            msg.sender,  \n            msg.sender,  \n            onchainDataAvailability\n        );\n\n        emit ExchangeForged(\n            _protocol,\n            _implementation,\n            exchangeAddress,\n            msg.sender,\n            forgeMode,\n            onchainDataAvailability,\n            exchangeId,\n            exchangeCreationCostLRC\n        );\n    }\n\n    function defaultProtocol()\n        public\n        view\n        returns (\n            address protocol,\n            address manager,\n            address defaultImpl,\n            string  memory protocolVersion,\n            string  memory defaultImplVersion\n        )\n    {\n        protocol = defaultProtocolAddress;\n        Protocol storage p = protocolMap[protocol];\n        manager = p.manager;\n\n        IImplementationManager m = IImplementationManager(manager);\n        defaultImpl = m.defaultImpl();\n        (protocolVersion, defaultImplVersion) = m.version();\n    }\n\n    function isProtocolRegistered(\n        address protocol\n        )\n        public\n        view\n        returns (bool)\n    {\n        return protocolMap[protocol].registered;\n    }\n\n    function isProtocolEnabled(\n        address protocol\n        )\n        public\n        view\n        returns (bool)\n    {\n        return protocolMap[protocol].enabled;\n    }\n\n    function isExchangeRegistered(\n        address exchange\n        )\n        public\n        view\n        returns (bool)\n    {\n        return exchangeMap[exchange] != address(0);\n    }\n\n    function isProtocolAndImplementationEnabled(\n        address protocol,\n        address implementation\n        )\n        public\n        view\n        returns (bool enabled)\n    {\n        if (!isProtocolEnabled(protocol)) {\n            return false;\n        }\n\n        address managerAddr = protocolMap[protocol].manager;\n        IImplementationManager m = IImplementationManager(managerAddr);\n        return m.isEnabled(implementation);\n    }\n\n    function getExchangeProtocol(\n        address exchangeAddress\n        )\n        public\n        view\n        returns (\n            address protocol,\n            address manager\n        )\n    {\n        require(exchangeAddress != address(0), \"ZERO_ADDRESS\");\n        protocol = exchangeMap[exchangeAddress];\n        require(protocol != address(0), \"INVALID_EXCHANGE\");\n        manager = protocolMap[protocol].manager;\n    }\n\n    \n\n    function getProtocolAndImplementationToUse(\n        address protocol,\n        address implementation\n        )\n        private\n        view\n        returns (\n            address protocolToUse,\n            address implementationToUse\n        )\n    {\n        protocolToUse = protocol;\n        if (protocolToUse == address(0)) {\n            protocolToUse = defaultProtocolAddress;\n        } else {\n            require(isProtocolEnabled(protocolToUse), \"INVALID_PROTOCOL\");\n        }\n\n        implementationToUse = implementation;\n        IImplementationManager m = IImplementationManager(protocolMap[protocolToUse].manager);\n        if (implementationToUse == address(0)) {\n            implementationToUse = m.defaultImpl();\n        } else {\n            require(m.isEnabled(implementationToUse), \"INVALID_IMPLEMENTATION\");\n        }\n    }\n\n    function forgeInternal(\n        ForgeMode forgeMode,\n        address   implementation\n        )\n        private\n        returns (address)\n    {\n        if (forgeMode == ForgeMode.AUTO_UPGRADABLE) {\n            return address(new AutoUpgradabilityProxy(address(this)));\n        } else if (forgeMode == ForgeMode.MANUAL_UPGRADABLE) {\n            return address(new ManualUpgradabilityProxy(address(this), implementation));\n        } else if (forgeMode == ForgeMode.PROXIED) {\n            return address(new SimpleProxy(implementation));\n        } else if (forgeMode == ForgeMode.NATIVE) {\n            return IExchange(implementation).clone();\n        } else {\n            revert(\"INVALID_FORGE_MODE\");\n        }\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"exchanges\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"registerProtocol\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"name\":\"isExchangeRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lrcAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"}],\"name\":\"isProtocolEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"}],\"name\":\"setDefaultProtocol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultProtocol\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"defaultImpl\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"protocolVersion\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"defaultImplVersion\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"}],\"name\":\"getExchangeProtocol\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"}],\"name\":\"enableProtocol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"protocols\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum IUniversalRegistry.ForgeMode\",\"name\":\"forgeMode\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"onchainDataAvailability\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"forgeExchange\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"exchangeId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"}],\"name\":\"disableProtocol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"isProtocolAndImplementationEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"}],\"name\":\"isProtocolRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"versionMap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lrcAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementationManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"}],\"name\":\"ProtocolRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"}],\"name\":\"ProtocolEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"}],\"name\":\"ProtocolDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldDefault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDefault\",\"type\":\"address\"}],\"name\":\"DefaultProtocolChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum IUniversalRegistry.ForgeMode\",\"name\":\"forgeMode\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"onchainDataAvailability\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exchangeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountLRCBurned\",\"type\":\"uint256\"}],\"name\":\"ExchangeForged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"UniversalRegistry","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000bbbbca6a901c926f240b89eacb641d8aec7aeafd","Library":"","LicenseType":"","SwarmSource":"bzzr://8a1d02545563558e366d24e2968a5515dde5f30b97bffd41f20ff8bd02187ac2"}]}