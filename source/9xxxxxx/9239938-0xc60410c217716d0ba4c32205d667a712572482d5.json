{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ncontract ProtocolInterface {\r\n\r\n    function deposit(address _user, uint _amount) public;\r\n    function withdraw(address _user, uint _amount) public;\r\n}\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint supply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract ITokenInterface is ERC20 {\r\n\r\n    function assetBalanceOf(address _owner) public view returns(uint256);\r\n    function mint(address receiver, uint256 depositAmount) external returns(uint256 mintAmount);\r\n    function burn(address receiver, uint256 burnAmount) external returns(uint256 loanAmountPaid);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function tokenPrice() public view returns (uint256 price);\r\n}\r\n\r\ncontract ConstantAddressesMainnet {\r\n    address public constant MAKER_DAI_ADDRESS = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\r\n    address public constant IDAI_ADDRESS = 0x14094949152EDDBFcd073717200DA82fEd8dC960;\r\n    address public constant SOLO_MARGIN_ADDRESS = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\r\n    address public constant CDAI_ADDRESS = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC;\r\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    address public constant MKR_ADDRESS = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;\r\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address public constant VOX_ADDRESS = 0x9B0F70Df76165442ca6092939132bBAEA77f2d7A;\r\n    address public constant PETH_ADDRESS = 0xf53AD2c6851052A81B42133467480961B2321C09;\r\n    address public constant TUB_ADDRESS = 0x448a5065aeBB8E423F0896E6c5D525C040f59af3;\r\n    address payable public constant WALLET_ID = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;\r\n    address public constant LOGGER_ADDRESS = 0xeCf88e1ceC2D2894A0295DB3D86Fe7CE4991E6dF;\r\n    address public constant OTC_ADDRESS = 0x39755357759cE0d7f32dC8dC45414CCa409AE24e;\r\n    address public constant DISCOUNT_ADDRESS = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\r\n\r\n    address public constant KYBER_WRAPPER = 0x8F337bD3b7F2b05d9A8dC8Ac518584e833424893;\r\n    address public constant UNISWAP_WRAPPER = 0x1e30124FDE14533231216D95F7798cD0061e5cf8;\r\n    address public constant ETH2DAI_WRAPPER = 0xd7BBB1777E13b6F535Dec414f575b858ed300baF;\r\n    address public constant OASIS_WRAPPER = 0x9aBE2715D2d99246269b8E17e9D1b620E9bf6558;\r\n\r\n    address public constant KYBER_INTERFACE = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;\r\n    address public constant UNISWAP_FACTORY = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;\r\n    address public constant FACTORY_ADDRESS = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;\r\n    address public constant PIP_INTERFACE_ADDRESS = 0x729D19f657BD0614b4985Cf1D82531c67569197B;\r\n\r\n    address public constant PROXY_REGISTRY_INTERFACE_ADDRESS = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;\r\n    address public constant GAS_TOKEN_INTERFACE_ADDRESS = 0x0000000000b3F879cb30FE243b4Dfee438691c04;\r\n\r\n    address public constant SAVINGS_LOGGER_ADDRESS = 0x89b3635BD2bAD145C6f92E82C9e83f06D5654984;\r\n\r\n    address public constant SAVER_EXCHANGE_ADDRESS = 0x865B41584A22F8345Fca4B71c42a1E7aBcD67eCB;\r\n\r\n    // Kovan addresses, not used on mainnet\r\n    address public constant COMPOUND_DAI_ADDRESS = 0x25a01a05C188DaCBCf1D61Af55D4a5B4021F7eeD;\r\n    address public constant STUPID_EXCHANGE = 0x863E41FE88288ebf3fcd91d8Dbb679fb83fdfE17;\r\n\r\n    // new MCD contracts\r\n    address public constant MANAGER_ADDRESS = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\r\n    address public constant VAT_ADDRESS = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;\r\n    address public constant SPOTTER_ADDRESS = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;\r\n    address public constant PROXY_ACTIONS = 0x82ecD135Dce65Fbc6DbdD0e4237E0AF93FFD5038;\r\n\r\n    address public constant JUG_ADDRESS = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;\r\n    address public constant DAI_JOIN_ADDRESS = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\r\n    address public constant ETH_JOIN_ADDRESS = 0x2F0b23f53734252Bda2277357e97e1517d6B042A;\r\n    address public constant MIGRATION_ACTIONS_PROXY = 0xe4B22D484958E582098A98229A24e8A43801b674;\r\n\r\n    address public constant SAI_ADDRESS = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\r\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n\r\n    address payable public constant SCD_MCD_MIGRATION = 0xc73e0383F3Aff3215E6f04B0331D58CeCf0Ab849;\r\n\r\n    // Our contracts\r\n    address public constant SUBSCRIPTION_ADDRESS = 0x83152CAA0d344a2Fd428769529e2d490A88f4393;\r\n    address public constant MONITOR_ADDRESS = 0x3F4339816EDEF8D3d3970DB2993e2e0Ec6010760;\r\n\r\n    address public constant NEW_CDAI_ADDRESS = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\r\n    address public constant NEW_IDAI_ADDRESS = 0x493C57C4763932315A328269E1ADaD09653B9081;\r\n\r\n}\r\n\r\ncontract ConstantAddressesKovan {\r\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    address public constant WETH_ADDRESS = 0xd0A1E359811322d97991E03f863a0C30C2cF029C;\r\n    address public constant MAKER_DAI_ADDRESS = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;\r\n    address public constant MKR_ADDRESS = 0xAaF64BFCC32d0F15873a02163e7E500671a4ffcD;\r\n    address public constant VOX_ADDRESS = 0xBb4339c0aB5B1d9f14Bd6e3426444A1e9d86A1d9;\r\n    address public constant PETH_ADDRESS = 0xf4d791139cE033Ad35DB2B2201435fAd668B1b64;\r\n    address public constant TUB_ADDRESS = 0xa71937147b55Deb8a530C7229C442Fd3F31b7db2;\r\n    address public constant LOGGER_ADDRESS = 0x32d0e18f988F952Eb3524aCE762042381a2c39E5;\r\n    address payable public  constant WALLET_ID = 0x54b44C6B18fc0b4A1010B21d524c338D1f8065F6;\r\n    address public constant OTC_ADDRESS = 0x4A6bC4e803c62081ffEbCc8d227B5a87a58f1F8F;\r\n    address public constant COMPOUND_DAI_ADDRESS = 0x25a01a05C188DaCBCf1D61Af55D4a5B4021F7eeD;\r\n    address public constant SOLO_MARGIN_ADDRESS = 0x4EC3570cADaAEE08Ae384779B0f3A45EF85289DE;\r\n    address public constant IDAI_ADDRESS = 0xA1e58F3B1927743393b25f261471E1f2D3D9f0F6;\r\n    address public constant CDAI_ADDRESS = 0xb6b09fBffBa6A5C4631e5F7B2e3Ee183aC259c0d;\r\n    address public constant STUPID_EXCHANGE = 0x863E41FE88288ebf3fcd91d8Dbb679fb83fdfE17;\r\n    address public constant DISCOUNT_ADDRESS = 0x1297c1105FEDf45E0CF6C102934f32C4EB780929;\r\n    address public constant SAI_SAVER_PROXY = 0xADB7c74bCe932fC6C27ddA3Ac2344707d2fBb0E6;\r\n\r\n    address public constant KYBER_WRAPPER = 0x68c56FF0E7BBD30AF9Ad68225479449869fC1bA0;\r\n    address public constant UNISWAP_WRAPPER = 0x2A4ee140F05f1Ba9A07A020b07CCFB76CecE4b43;\r\n    address public constant ETH2DAI_WRAPPER = 0x823cde416973a19f98Bb9C96d97F4FE6C9A7238B;\r\n    address public constant OASIS_WRAPPER = 0x0257Ba4876863143bbeDB7847beC583e4deb6fE6;\r\n\r\n    address public constant SAVER_EXCHANGE_ADDRESS = 0xACA7d11e3f482418C324aAC8e90AaD0431f692A6;\r\n\r\n\r\n    address public constant FACTORY_ADDRESS = 0xc72E74E474682680a414b506699bBcA44ab9a930;\r\n    //\r\n    address public constant PIP_INTERFACE_ADDRESS = 0xA944bd4b25C9F186A846fd5668941AA3d3B8425F;\r\n    address public constant PROXY_REGISTRY_INTERFACE_ADDRESS = 0x64A436ae831C1672AE81F674CAb8B6775df3475C;\r\n    address public constant GAS_TOKEN_INTERFACE_ADDRESS = 0x0000000000170CcC93903185bE5A2094C870Df62;\r\n    address public constant KYBER_INTERFACE = 0x692f391bCc85cefCe8C237C01e1f636BbD70EA4D;\r\n\r\n    address public constant SAVINGS_LOGGER_ADDRESS = 0x2aa889D809B29c608dA99767837D189dAe12a874;\r\n\r\n    // Rinkeby, when no Kovan\r\n    address public constant UNISWAP_FACTORY = 0xf5D915570BC477f9B8D6C0E980aA81757A3AaC36;\r\n\r\n    // new MCD contracts\r\n    address public constant MANAGER_ADDRESS = 0x1476483dD8C35F25e568113C5f70249D3976ba21;\r\n    address public constant VAT_ADDRESS = 0xbA987bDB501d131f766fEe8180Da5d81b34b69d9;\r\n    address public constant SPOTTER_ADDRESS = 0x3a042de6413eDB15F2784f2f97cC68C7E9750b2D;\r\n\r\n    address public constant JUG_ADDRESS = 0xcbB7718c9F39d05aEEDE1c472ca8Bf804b2f1EaD;\r\n    address public constant DAI_JOIN_ADDRESS = 0x5AA71a3ae1C0bd6ac27A1f28e1415fFFB6F15B8c;\r\n    address public constant ETH_JOIN_ADDRESS = 0x775787933e92b709f2a3C70aa87999696e74A9F8;\r\n    address public constant MIGRATION_ACTIONS_PROXY = 0x433870076aBd08865f0e038dcC4Ac6450e313Bd8;\r\n    address public constant PROXY_ACTIONS = 0xd1D24637b9109B7f61459176EdcfF9Be56283a7B;\r\n\r\n    address public constant SAI_ADDRESS = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;\r\n    address public constant DAI_ADDRESS = 0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa;\r\n\r\n    address payable public constant SCD_MCD_MIGRATION = 0x411B2Faa662C8e3E5cF8f01dFdae0aeE482ca7b0;\r\n\r\n    // Our contracts\r\n    address public constant SUBSCRIPTION_ADDRESS = 0xFC41f79776061a396635aD0b9dF7a640A05063C1;\r\n    address public constant MONITOR_ADDRESS = 0xfC1Fc0502e90B7A3766f93344E1eDb906F8A75DD;\r\n}\r\n\r\ncontract ConstantAddresses is ConstantAddressesMainnet {\r\n}\r\n\r\n/*\r\n\r\n    Copyright 2019 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\n\r\n\r\n/**\r\n * @title Actions\r\n * @author dYdX\r\n *\r\n * Library that defines and parses valid Actions\r\n */\r\nlibrary Actions {\r\n\r\n    // ============ Constants ============\r\n\r\n    bytes32 constant FILE = \"Actions\";\r\n\r\n    // ============ Enums ============\r\n\r\n    enum ActionType {\r\n        Deposit,   // supply tokens\r\n        Withdraw,  // borrow tokens\r\n        Transfer,  // transfer balance between accounts\r\n        Buy,       // buy an amount of some token (externally)\r\n        Sell,      // sell an amount of some token (externally)\r\n        Trade,     // trade tokens against another account\r\n        Liquidate, // liquidate an undercollateralized or expiring account\r\n        Vaporize,  // use excess tokens to zero-out a completely negative account\r\n        Call       // send arbitrary data to an address\r\n    }\r\n\r\n    enum AccountLayout {\r\n        OnePrimary,\r\n        TwoPrimary,\r\n        PrimaryAndSecondary\r\n    }\r\n\r\n    enum MarketLayout {\r\n        ZeroMarkets,\r\n        OneMarket,\r\n        TwoMarkets\r\n    }\r\n\r\n    // ============ Structs ============\r\n\r\n    /*\r\n     * Arguments that are passed to Solo in an ordered list as part of a single operation.\r\n     * Each ActionArgs has an actionType which specifies which action struct that this data will be\r\n     * parsed into before being processed.\r\n     */\r\n    struct ActionArgs {\r\n        ActionType actionType;\r\n        uint256 accountId;\r\n        Types.AssetAmount amount;\r\n        uint256 primaryMarketId;\r\n        uint256 secondaryMarketId;\r\n        address otherAddress;\r\n        uint256 otherAccountId;\r\n        bytes data;\r\n    }\r\n\r\n    // ============ Action Types ============\r\n\r\n    /*\r\n     * Moves tokens from an address to Solo. Can either repay a borrow or provide additional supply.\r\n     */\r\n    struct DepositArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info account;\r\n        uint256 market;\r\n        address from;\r\n    }\r\n\r\n    /*\r\n     * Moves tokens from Solo to another address. Can either borrow tokens or reduce the amount\r\n     * previously supplied.\r\n     */\r\n    struct WithdrawArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info account;\r\n        uint256 market;\r\n        address to;\r\n    }\r\n\r\n    /*\r\n     * Transfers balance between two accounts. The msg.sender must be an operator for both accounts.\r\n     * The amount field applies to accountOne.\r\n     * This action does not require any token movement since the trade is done internally to Solo.\r\n     */\r\n    struct TransferArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info accountOne;\r\n        Account.Info accountTwo;\r\n        uint256 market;\r\n    }\r\n\r\n    /*\r\n     * Acquires a certain amount of tokens by spending other tokens. Sends takerMarket tokens to the\r\n     * specified exchangeWrapper contract and expects makerMarket tokens in return. The amount field\r\n     * applies to the makerMarket.\r\n     */\r\n    struct BuyArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info account;\r\n        uint256 makerMarket;\r\n        uint256 takerMarket;\r\n        address exchangeWrapper;\r\n        bytes orderData;\r\n    }\r\n\r\n    /*\r\n     * Spends a certain amount of tokens to acquire other tokens. Sends takerMarket tokens to the\r\n     * specified exchangeWrapper and expects makerMarket tokens in return. The amount field applies\r\n     * to the takerMarket.\r\n     */\r\n    struct SellArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info account;\r\n        uint256 takerMarket;\r\n        uint256 makerMarket;\r\n        address exchangeWrapper;\r\n        bytes orderData;\r\n    }\r\n\r\n    /*\r\n     * Trades balances between two accounts using any external contract that implements the\r\n     * AutoTrader interface. The AutoTrader contract must be an operator for the makerAccount (for\r\n     * which it is trading on-behalf-of). The amount field applies to the makerAccount and the\r\n     * inputMarket. This proposed change to the makerAccount is passed to the AutoTrader which will\r\n     * quote a change for the makerAccount in the outputMarket (or will disallow the trade).\r\n     * This action does not require any token movement since the trade is done internally to Solo.\r\n     */\r\n    struct TradeArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info takerAccount;\r\n        Account.Info makerAccount;\r\n        uint256 inputMarket;\r\n        uint256 outputMarket;\r\n        address autoTrader;\r\n        bytes tradeData;\r\n    }\r\n\r\n    /*\r\n     * Each account must maintain a certain margin-ratio (specified globally). If the account falls\r\n     * below this margin-ratio, it can be liquidated by any other account. This allows anyone else\r\n     * (arbitrageurs) to repay any borrowed asset (owedMarket) of the liquidating account in\r\n     * exchange for any collateral asset (heldMarket) of the liquidAccount. The ratio is determined\r\n     * by the price ratio (given by the oracles) plus a spread (specified globally). Liquidating an\r\n     * account also sets a flag on the account that the account is being liquidated. This allows\r\n     * anyone to continue liquidating the account until there are no more borrows being taken by the\r\n     * liquidating account. Liquidators do not have to liquidate the entire account all at once but\r\n     * can liquidate as much as they choose. The liquidating flag allows liquidators to continue\r\n     * liquidating the account even if it becomes collateralized through partial liquidation or\r\n     * price movement.\r\n     */\r\n    struct LiquidateArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info solidAccount;\r\n        Account.Info liquidAccount;\r\n        uint256 owedMarket;\r\n        uint256 heldMarket;\r\n    }\r\n\r\n    /*\r\n     * Similar to liquidate, but vaporAccounts are accounts that have only negative balances\r\n     * remaining. The arbitrageur pays back the negative asset (owedMarket) of the vaporAccount in\r\n     * exchange for a collateral asset (heldMarket) at a favorable spread. However, since the\r\n     * liquidAccount has no collateral assets, the collateral must come from Solo's excess tokens.\r\n     */\r\n    struct VaporizeArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info solidAccount;\r\n        Account.Info vaporAccount;\r\n        uint256 owedMarket;\r\n        uint256 heldMarket;\r\n    }\r\n\r\n    /*\r\n     * Passes arbitrary bytes of data to an external contract that implements the Callee interface.\r\n     * Does not change any asset amounts. This function may be useful for setting certain variables\r\n     * on layer-two contracts for certain accounts without having to make a separate Ethereum\r\n     * transaction for doing so. Also, the second-layer contracts can ensure that the call is coming\r\n     * from an operator of the particular account.\r\n     */\r\n    struct CallArgs {\r\n        Account.Info account;\r\n        address callee;\r\n        bytes data;\r\n    }\r\n\r\n    // ============ Helper Functions ============\r\n\r\n    function getMarketLayout(\r\n        ActionType actionType\r\n    )\r\n        internal\r\n        pure\r\n        returns (MarketLayout)\r\n    {\r\n        if (\r\n            actionType == Actions.ActionType.Deposit\r\n            || actionType == Actions.ActionType.Withdraw\r\n            || actionType == Actions.ActionType.Transfer\r\n        ) {\r\n            return MarketLayout.OneMarket;\r\n        }\r\n        else if (actionType == Actions.ActionType.Call) {\r\n            return MarketLayout.ZeroMarkets;\r\n        }\r\n        return MarketLayout.TwoMarkets;\r\n    }\r\n\r\n    function getAccountLayout(\r\n        ActionType actionType\r\n    )\r\n        internal\r\n        pure\r\n        returns (AccountLayout)\r\n    {\r\n        if (\r\n            actionType == Actions.ActionType.Transfer\r\n            || actionType == Actions.ActionType.Trade\r\n        ) {\r\n            return AccountLayout.TwoPrimary;\r\n        } else if (\r\n            actionType == Actions.ActionType.Liquidate\r\n            || actionType == Actions.ActionType.Vaporize\r\n        ) {\r\n            return AccountLayout.PrimaryAndSecondary;\r\n        }\r\n        return AccountLayout.OnePrimary;\r\n    }\r\n\r\n    // ============ Parsing Functions ============\r\n\r\n    function parseDepositArgs(\r\n        Account.Info[] memory accounts,\r\n        ActionArgs memory args\r\n    )\r\n        internal\r\n        pure\r\n        returns (DepositArgs memory)\r\n    {\r\n        assert(args.actionType == ActionType.Deposit);\r\n        return DepositArgs({\r\n            amount: args.amount,\r\n            account: accounts[args.accountId],\r\n            market: args.primaryMarketId,\r\n            from: args.otherAddress\r\n        });\r\n    }\r\n\r\n    function parseWithdrawArgs(\r\n        Account.Info[] memory accounts,\r\n        ActionArgs memory args\r\n    )\r\n        internal\r\n        pure\r\n        returns (WithdrawArgs memory)\r\n    {\r\n        assert(args.actionType == ActionType.Withdraw);\r\n        return WithdrawArgs({\r\n            amount: args.amount,\r\n            account: accounts[args.accountId],\r\n            market: args.primaryMarketId,\r\n            to: args.otherAddress\r\n        });\r\n    }\r\n\r\n    function parseTransferArgs(\r\n        Account.Info[] memory accounts,\r\n        ActionArgs memory args\r\n    )\r\n        internal\r\n        pure\r\n        returns (TransferArgs memory)\r\n    {\r\n        assert(args.actionType == ActionType.Transfer);\r\n        return TransferArgs({\r\n            amount: args.amount,\r\n            accountOne: accounts[args.accountId],\r\n            accountTwo: accounts[args.otherAccountId],\r\n            market: args.primaryMarketId\r\n        });\r\n    }\r\n\r\n    function parseBuyArgs(\r\n        Account.Info[] memory accounts,\r\n        ActionArgs memory args\r\n    )\r\n        internal\r\n        pure\r\n        returns (BuyArgs memory)\r\n    {\r\n        assert(args.actionType == ActionType.Buy);\r\n        return BuyArgs({\r\n            amount: args.amount,\r\n            account: accounts[args.accountId],\r\n            makerMarket: args.primaryMarketId,\r\n            takerMarket: args.secondaryMarketId,\r\n            exchangeWrapper: args.otherAddress,\r\n            orderData: args.data\r\n        });\r\n    }\r\n\r\n    function parseSellArgs(\r\n        Account.Info[] memory accounts,\r\n        ActionArgs memory args\r\n    )\r\n        internal\r\n        pure\r\n        returns (SellArgs memory)\r\n    {\r\n        assert(args.actionType == ActionType.Sell);\r\n        return SellArgs({\r\n            amount: args.amount,\r\n            account: accounts[args.accountId],\r\n            takerMarket: args.primaryMarketId,\r\n            makerMarket: args.secondaryMarketId,\r\n            exchangeWrapper: args.otherAddress,\r\n            orderData: args.data\r\n        });\r\n    }\r\n\r\n    function parseTradeArgs(\r\n        Account.Info[] memory accounts,\r\n        ActionArgs memory args\r\n    )\r\n        internal\r\n        pure\r\n        returns (TradeArgs memory)\r\n    {\r\n        assert(args.actionType == ActionType.Trade);\r\n        return TradeArgs({\r\n            amount: args.amount,\r\n            takerAccount: accounts[args.accountId],\r\n            makerAccount: accounts[args.otherAccountId],\r\n            inputMarket: args.primaryMarketId,\r\n            outputMarket: args.secondaryMarketId,\r\n            autoTrader: args.otherAddress,\r\n            tradeData: args.data\r\n        });\r\n    }\r\n\r\n    function parseLiquidateArgs(\r\n        Account.Info[] memory accounts,\r\n        ActionArgs memory args\r\n    )\r\n        internal\r\n        pure\r\n        returns (LiquidateArgs memory)\r\n    {\r\n        assert(args.actionType == ActionType.Liquidate);\r\n        return LiquidateArgs({\r\n            amount: args.amount,\r\n            solidAccount: accounts[args.accountId],\r\n            liquidAccount: accounts[args.otherAccountId],\r\n            owedMarket: args.primaryMarketId,\r\n            heldMarket: args.secondaryMarketId\r\n        });\r\n    }\r\n\r\n    function parseVaporizeArgs(\r\n        Account.Info[] memory accounts,\r\n        ActionArgs memory args\r\n    )\r\n        internal\r\n        pure\r\n        returns (VaporizeArgs memory)\r\n    {\r\n        assert(args.actionType == ActionType.Vaporize);\r\n        return VaporizeArgs({\r\n            amount: args.amount,\r\n            solidAccount: accounts[args.accountId],\r\n            vaporAccount: accounts[args.otherAccountId],\r\n            owedMarket: args.primaryMarketId,\r\n            heldMarket: args.secondaryMarketId\r\n        });\r\n    }\r\n\r\n    function parseCallArgs(\r\n        Account.Info[] memory accounts,\r\n        ActionArgs memory args\r\n    )\r\n        internal\r\n        pure\r\n        returns (CallArgs memory)\r\n    {\r\n        assert(args.actionType == ActionType.Call);\r\n        return CallArgs({\r\n            account: accounts[args.accountId],\r\n            callee: args.otherAddress,\r\n            data: args.data\r\n        });\r\n    }\r\n}\r\n\r\n/*\r\n\r\n    Copyright 2019 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Account\r\n * @author dYdX\r\n *\r\n * Library of structs and functions that represent an account\r\n */\r\nlibrary Account {\r\n    // ============ Enums ============\r\n\r\n    /*\r\n     * Most-recently-cached account status.\r\n     *\r\n     * Normal: Can only be liquidated if the account values are violating the global margin-ratio.\r\n     * Liquid: Can be liquidated no matter the account values.\r\n     *         Can be vaporized if there are no more positive account values.\r\n     * Vapor:  Has only negative (or zeroed) account values. Can be vaporized.\r\n     *\r\n     */\r\n    enum Status {\r\n        Normal,\r\n        Liquid,\r\n        Vapor\r\n    }\r\n\r\n    // ============ Structs ============\r\n\r\n    // Represents the unique key that specifies an account\r\n    struct Info {\r\n        address owner;  // The address that owns the account\r\n        uint256 number; // A nonce that allows a single address to control many accounts\r\n    }\r\n\r\n    // The complete storage for any account\r\n    struct Storage {\r\n        mapping (uint256 => Types.Par) balances; // Mapping from marketId to principal\r\n        Status status;\r\n    }\r\n\r\n    // ============ Library Functions ============\r\n\r\n    function equals(\r\n        Info memory a,\r\n        Info memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.owner == b.owner && a.number == b.number;\r\n    }\r\n}\r\n\r\n/*\r\n\r\n    Copyright 2019 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\n/*\r\n\r\n    Copyright 2019 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\n/*\r\n\r\n    Copyright 2019 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title Require\r\n * @author dYdX\r\n *\r\n * Stringifies parameters to pretty-print revert messages. Costs more gas than regular require()\r\n */\r\nlibrary Require {\r\n\r\n    // ============ Constants ============\r\n\r\n    uint256 constant ASCII_ZERO = 48; // '0'\r\n    uint256 constant ASCII_RELATIVE_ZERO = 87; // 'a' - 10\r\n    uint256 constant ASCII_LOWER_EX = 120; // 'x'\r\n    bytes2 constant COLON = 0x3a20; // ': '\r\n    bytes2 constant COMMA = 0x2c20; // ', '\r\n    bytes2 constant LPAREN = 0x203c; // ' <'\r\n    byte constant RPAREN = 0x3e; // '>'\r\n    uint256 constant FOUR_BIT_MASK = 0xf;\r\n\r\n    // ============ Library Functions ============\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason)\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        uint256 payloadA\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        uint256 payloadA,\r\n        uint256 payloadB\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA,\r\n        uint256 payloadB\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA,\r\n        uint256 payloadB,\r\n        uint256 payloadC\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        COMMA,\r\n                        stringify(payloadC),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        bytes32 payloadA\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        bytes32 payloadA,\r\n        uint256 payloadB,\r\n        uint256 payloadC\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        COMMA,\r\n                        stringify(payloadC),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    // ============ Private Functions ============\r\n\r\n    function stringifyTruncated(\r\n        bytes32 input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        // put the input bytes into the result\r\n        bytes memory result = abi.encodePacked(input);\r\n\r\n        // determine the length of the input by finding the location of the last non-zero byte\r\n        for (uint256 i = 32; i > 0; ) {\r\n            // reverse-for-loops with unsigned integer\r\n            /* solium-disable-next-line security/no-modify-for-iter-var */\r\n            i--;\r\n\r\n            // find the last non-zero byte in order to determine the length\r\n            if (result[i] != 0) {\r\n                uint256 length = i + 1;\r\n\r\n                /* solium-disable-next-line security/no-inline-assembly */\r\n                assembly {\r\n                    mstore(result, length) // r.length = length;\r\n                }\r\n\r\n                return result;\r\n            }\r\n        }\r\n\r\n        // all bytes are zero\r\n        return new bytes(0);\r\n    }\r\n\r\n    function stringify(\r\n        uint256 input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        if (input == 0) {\r\n            return \"0\";\r\n        }\r\n\r\n        // get the final string length\r\n        uint256 j = input;\r\n        uint256 length;\r\n        while (j != 0) {\r\n            length++;\r\n            j /= 10;\r\n        }\r\n\r\n        // allocate the string\r\n        bytes memory bstr = new bytes(length);\r\n\r\n        // populate the string starting with the least-significant character\r\n        j = input;\r\n        for (uint256 i = length; i > 0; ) {\r\n            // reverse-for-loops with unsigned integer\r\n            /* solium-disable-next-line security/no-modify-for-iter-var */\r\n            i--;\r\n\r\n            // take last decimal digit\r\n            bstr[i] = byte(uint8(ASCII_ZERO + (j % 10)));\r\n\r\n            // remove the last decimal digit\r\n            j /= 10;\r\n        }\r\n\r\n        return bstr;\r\n    }\r\n\r\n    function stringify(\r\n        address input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        uint256 z = uint256(input);\r\n\r\n        // addresses are \"0x\" followed by 20 bytes of data which take up 2 characters each\r\n        bytes memory result = new bytes(42);\r\n\r\n        // populate the result with \"0x\"\r\n        result[0] = byte(uint8(ASCII_ZERO));\r\n        result[1] = byte(uint8(ASCII_LOWER_EX));\r\n\r\n        // for each byte (starting from the lowest byte), populate the result with two characters\r\n        for (uint256 i = 0; i < 20; i++) {\r\n            // each byte takes two characters\r\n            uint256 shift = i * 2;\r\n\r\n            // populate the least-significant character\r\n            result[41 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n\r\n            // populate the most-significant character\r\n            result[40 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function stringify(\r\n        bytes32 input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        uint256 z = uint256(input);\r\n\r\n        // bytes32 are \"0x\" followed by 32 bytes of data which take up 2 characters each\r\n        bytes memory result = new bytes(66);\r\n\r\n        // populate the result with \"0x\"\r\n        result[0] = byte(uint8(ASCII_ZERO));\r\n        result[1] = byte(uint8(ASCII_LOWER_EX));\r\n\r\n        // for each byte (starting from the lowest byte), populate the result with two characters\r\n        for (uint256 i = 0; i < 32; i++) {\r\n            // each byte takes two characters\r\n            uint256 shift = i * 2;\r\n\r\n            // populate the least-significant character\r\n            result[65 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n\r\n            // populate the most-significant character\r\n            result[64 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function char(\r\n        uint256 input\r\n    )\r\n        private\r\n        pure\r\n        returns (byte)\r\n    {\r\n        // return ASCII digit (0-9)\r\n        if (input < 10) {\r\n            return byte(uint8(input + ASCII_ZERO));\r\n        }\r\n\r\n        // return ASCII letter (a-f)\r\n        return byte(uint8(input + ASCII_RELATIVE_ZERO));\r\n    }\r\n}\r\n\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title Math\r\n * @author dYdX\r\n *\r\n * Library for non-standard Math functions\r\n */\r\nlibrary Math {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Constants ============\r\n\r\n    bytes32 constant FILE = \"Math\";\r\n\r\n    // ============ Library Functions ============\r\n\r\n    /*\r\n     * Return target * (numerator / denominator).\r\n     */\r\n    function getPartial(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return target.mul(numerator).div(denominator);\r\n    }\r\n\r\n    /*\r\n     * Return target * (numerator / denominator), but rounded up.\r\n     */\r\n    function getPartialRoundUp(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (target == 0 || numerator == 0) {\r\n            // SafeMath will check for zero denominator\r\n            return SafeMath.div(0, denominator);\r\n        }\r\n        return target.mul(numerator).sub(1).div(denominator).add(1);\r\n    }\r\n\r\n    function to128(\r\n        uint256 number\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint128)\r\n    {\r\n        uint128 result = uint128(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \"Unsafe cast to uint128\"\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function to96(\r\n        uint256 number\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint96)\r\n    {\r\n        uint96 result = uint96(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \"Unsafe cast to uint96\"\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function to32(\r\n        uint256 number\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint32)\r\n    {\r\n        uint32 result = uint32(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \"Unsafe cast to uint32\"\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function min(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a > b ? a : b;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Types\r\n * @author dYdX\r\n *\r\n * Library for interacting with the basic structs used in Solo\r\n */\r\nlibrary Types {\r\n    using Math for uint256;\r\n\r\n    // ============ AssetAmount ============\r\n\r\n    enum AssetDenomination {\r\n        Wei, // the amount is denominated in wei\r\n        Par  // the amount is denominated in par\r\n    }\r\n\r\n    enum AssetReference {\r\n        Delta, // the amount is given as a delta from the current value\r\n        Target // the amount is given as an exact number to end up at\r\n    }\r\n\r\n    struct AssetAmount {\r\n        bool sign; // true if positive\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n\r\n    // ============ Par (Principal Amount) ============\r\n\r\n    // Total borrow and supply values for a market\r\n    struct TotalPar {\r\n        uint128 borrow;\r\n        uint128 supply;\r\n    }\r\n\r\n    // Individual principal amount for an account\r\n    struct Par {\r\n        bool sign; // true if positive\r\n        uint128 value;\r\n    }\r\n\r\n    function zeroPar()\r\n        internal\r\n        pure\r\n        returns (Par memory)\r\n    {\r\n        return Par({\r\n            sign: false,\r\n            value: 0\r\n        });\r\n    }\r\n\r\n    function sub(\r\n        Par memory a,\r\n        Par memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Par memory)\r\n    {\r\n        return add(a, negative(b));\r\n    }\r\n\r\n    function add(\r\n        Par memory a,\r\n        Par memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Par memory)\r\n    {\r\n        Par memory result;\r\n        if (a.sign == b.sign) {\r\n            result.sign = a.sign;\r\n            result.value = SafeMath.add(a.value, b.value).to128();\r\n        } else {\r\n            if (a.value >= b.value) {\r\n                result.sign = a.sign;\r\n                result.value = SafeMath.sub(a.value, b.value).to128();\r\n            } else {\r\n                result.sign = b.sign;\r\n                result.value = SafeMath.sub(b.value, a.value).to128();\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function equals(\r\n        Par memory a,\r\n        Par memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (a.value == b.value) {\r\n            if (a.value == 0) {\r\n                return true;\r\n            }\r\n            return a.sign == b.sign;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function negative(\r\n        Par memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (Par memory)\r\n    {\r\n        return Par({\r\n            sign: !a.sign,\r\n            value: a.value\r\n        });\r\n    }\r\n\r\n    function isNegative(\r\n        Par memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return !a.sign && a.value > 0;\r\n    }\r\n\r\n    function isPositive(\r\n        Par memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.sign && a.value > 0;\r\n    }\r\n\r\n    function isZero(\r\n        Par memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.value == 0;\r\n    }\r\n\r\n    // ============ Wei (Token Amount) ============\r\n\r\n    // Individual token amount for an account\r\n    struct Wei {\r\n        bool sign; // true if positive\r\n        uint256 value;\r\n    }\r\n\r\n    function zeroWei()\r\n        internal\r\n        pure\r\n        returns (Wei memory)\r\n    {\r\n        return Wei({\r\n            sign: false,\r\n            value: 0\r\n        });\r\n    }\r\n\r\n    function sub(\r\n        Wei memory a,\r\n        Wei memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Wei memory)\r\n    {\r\n        return add(a, negative(b));\r\n    }\r\n\r\n    function add(\r\n        Wei memory a,\r\n        Wei memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Wei memory)\r\n    {\r\n        Wei memory result;\r\n        if (a.sign == b.sign) {\r\n            result.sign = a.sign;\r\n            result.value = SafeMath.add(a.value, b.value);\r\n        } else {\r\n            if (a.value >= b.value) {\r\n                result.sign = a.sign;\r\n                result.value = SafeMath.sub(a.value, b.value);\r\n            } else {\r\n                result.sign = b.sign;\r\n                result.value = SafeMath.sub(b.value, a.value);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function equals(\r\n        Wei memory a,\r\n        Wei memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (a.value == b.value) {\r\n            if (a.value == 0) {\r\n                return true;\r\n            }\r\n            return a.sign == b.sign;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function negative(\r\n        Wei memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (Wei memory)\r\n    {\r\n        return Wei({\r\n            sign: !a.sign,\r\n            value: a.value\r\n        });\r\n    }\r\n\r\n    function isNegative(\r\n        Wei memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return !a.sign && a.value > 0;\r\n    }\r\n\r\n    function isPositive(\r\n        Wei memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.sign && a.value > 0;\r\n    }\r\n\r\n    function isZero(\r\n        Wei memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.value == 0;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ISoloMargin {\r\n    struct OperatorArg {\r\n        address operator;\r\n        bool trusted;\r\n    }\r\n\r\n    function operate(\r\n        Account.Info[] memory accounts,\r\n        Actions.ActionArgs[] memory actions\r\n    ) public;\r\n\r\n    function getAccountBalances(\r\n        Account.Info memory account\r\n    ) public view returns (\r\n        address[] memory,\r\n        Types.Par[] memory,\r\n        Types.Wei[] memory\r\n    );\r\n\r\n    function setOperators(\r\n        OperatorArg[] memory args\r\n    ) public;\r\n}\r\n\r\ncontract SavingsLogger {\r\n\r\n        event Deposit(address indexed sender, uint8 protocol, uint amount);\r\n        event Withdraw(address indexed sender, uint8 protocol, uint amount);\r\n        event Swap(address indexed sender, uint8 fromProtocol, uint8 toProtocol, uint amount);\r\n\r\n        function logDeposit(address _sender, uint8 _protocol, uint _amount) external {\r\n            emit Deposit(_sender, _protocol, _amount);\r\n        }\r\n\r\n        function logWithdraw(address _sender, uint8 _protocol, uint _amount) external {\r\n            emit Withdraw(_sender, _protocol, _amount);\r\n        }\r\n\r\n        function logSwap(address _sender, uint8 _protocolFrom, uint8 _protocolTo, uint _amount) external {\r\n            emit Swap(_sender, _protocolFrom, _protocolTo, _amount);\r\n        }\r\n}\r\n\r\ncontract Gem {\r\n    function dec() public returns (uint);\r\n    function gem() public returns (Gem);\r\n    function join(address, uint) public payable;\r\n    function exit(address, uint) public;\r\n\r\n    function approve(address, uint) public;\r\n    function transfer(address, uint) public returns (bool);\r\n    function transferFrom(address, address, uint) public returns (bool);\r\n    function deposit() public payable;\r\n    function withdraw(uint) public;\r\n    function allowance(address, address) public returns (uint);\r\n}\r\n\r\ncontract Join {\r\n    bytes32 public ilk;\r\n\r\n    function dec() public returns (uint);\r\n    function gem() public returns (Gem);\r\n    function join(address, uint) public payable;\r\n    function exit(address, uint) public;\r\n}\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function div(uint x, uint y) internal pure returns (uint z) {\r\n        return x / y;\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract VatLike {\r\n    function can(address, address) public view returns (uint);\r\n    function ilks(bytes32) public view returns (uint, uint, uint, uint, uint);\r\n    function dai(address) public view returns (uint);\r\n    function urns(bytes32, address) public view returns (uint, uint);\r\n    function frob(bytes32, address, address, address, int, int) public;\r\n    function hope(address) public;\r\n    function move(address, address, uint) public;\r\n}\r\n\r\ncontract PotLike {\r\n    function pie(address) public view returns (uint);\r\n    function drip() public returns (uint);\r\n    function join(uint) public;\r\n    function exit(uint) public;\r\n}\r\n\r\ncontract GemLike {\r\n    function approve(address, uint) public;\r\n    function transfer(address, uint) public;\r\n    function transferFrom(address, address, uint) public;\r\n    function deposit() public payable;\r\n    function withdraw(uint) public;\r\n}\r\n\r\ncontract DaiJoinLike {\r\n    function vat() public returns (VatLike);\r\n    function dai() public returns (GemLike);\r\n    function join(address, uint) public payable;\r\n    function exit(address, uint) public;\r\n}\r\n\r\ncontract DSRSavingsProtocol is DSMath {\r\n\r\n    // Kovan\r\n    // address public constant DAI_JOIN_ADDRESS = 0x5AA71a3ae1C0bd6ac27A1f28e1415fFFB6F15B8c;\r\n    // address public constant POT_ADDRESS = 0xEA190DBDC7adF265260ec4dA6e9675Fd4f5A78bb;\r\n\r\n    // Mainnet\r\n    address public constant DAI_JOIN_ADDRESS = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\r\n    address public constant POT_ADDRESS = 0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7;\r\n\r\n    function dsrDeposit(uint _amount) internal {\r\n        VatLike vat = DaiJoinLike(DAI_JOIN_ADDRESS).vat();\r\n\r\n        uint chi = PotLike(POT_ADDRESS).drip();\r\n\r\n        daiJoin_join(DAI_JOIN_ADDRESS, address(this), _amount);\r\n\r\n        if (vat.can(address(this), address(POT_ADDRESS)) == 0) {\r\n            vat.hope(POT_ADDRESS);\r\n        }\r\n\r\n        PotLike(POT_ADDRESS).join(mul(_amount, RAY) / chi);\r\n    }\r\n\r\n    function dsrWithdraw(uint _amount) internal {\r\n        VatLike vat = DaiJoinLike(DAI_JOIN_ADDRESS).vat();\r\n\r\n        uint chi = PotLike(POT_ADDRESS).drip();\r\n        uint pie = mul(_amount, RAY) / chi;\r\n\r\n        PotLike(POT_ADDRESS).exit(pie);\r\n        uint balance = DaiJoinLike(DAI_JOIN_ADDRESS).vat().dai(address(this));\r\n\r\n        if (vat.can(address(this), address(DAI_JOIN_ADDRESS)) == 0) {\r\n            vat.hope(DAI_JOIN_ADDRESS);\r\n        }\r\n\r\n        if (_amount == uint(-1)) {\r\n            DaiJoinLike(DAI_JOIN_ADDRESS).exit(msg.sender, mul(chi, pie) / RAY);\r\n        } else {\r\n            DaiJoinLike(DAI_JOIN_ADDRESS).exit(\r\n                msg.sender,\r\n                balance >= mul(_amount, RAY) ? _amount : balance / RAY\r\n            );\r\n        }\r\n    }\r\n\r\n    function daiJoin_join(address apt, address urn, uint wad) internal {\r\n        DaiJoinLike(apt).dai().transferFrom(msg.sender, address(this), wad);\r\n\r\n        DaiJoinLike(apt).dai().approve(apt, wad);\r\n\r\n        DaiJoinLike(apt).join(urn, wad);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract SavingsProxy is ConstantAddresses, DSRSavingsProtocol {\r\n\r\n    address constant public SAVINGS_COMPOUND_ADDRESS = 0x72c5a18D651DA5568EFfE731a98484dE62C9F347;\r\n    address constant public SAVINGS_DYDX_ADDRESS = 0x03b1565e070df392e48e7a8e01798C4B00E534A5;\r\n    address constant public SAVINGS_FULCRUM_ADDRESS = 0xe9ea575d2d8Ca26b0E026a2146994592e0Ee1Dd9;\r\n\r\n    enum SavingsProtocol { Compound, Dydx, Fulcrum, Dsr }\r\n\r\n    function deposit(SavingsProtocol _protocol, uint _amount) public {\r\n        if (_protocol == SavingsProtocol.Dsr) {\r\n            dsrDeposit(_amount);\r\n        } else {\r\n            _deposit(_protocol, _amount);\r\n        }\r\n\r\n        SavingsLogger(SAVINGS_LOGGER_ADDRESS).logDeposit(msg.sender, uint8(_protocol), _amount);\r\n    }\r\n\r\n    function withdraw(SavingsProtocol _protocol, uint _amount) public {\r\n        if (_protocol == SavingsProtocol.Dsr) {\r\n            dsrWithdraw(_amount);\r\n        } else {\r\n            _withdraw(_protocol, _amount);\r\n        }\r\n\r\n        SavingsLogger(SAVINGS_LOGGER_ADDRESS).logWithdraw(msg.sender, uint8(_protocol), _amount);\r\n    }\r\n\r\n    function swap(SavingsProtocol _from, SavingsProtocol _to, uint _amount) public {\r\n        if (_from == SavingsProtocol.Dsr) {\r\n            dsrWithdraw(_amount);\r\n        } else {\r\n            _withdraw(_from, _amount);\r\n        }\r\n\r\n        if (_to == SavingsProtocol.Dsr) {\r\n            dsrDeposit(_amount);\r\n        } else {\r\n            _deposit(_to, _amount);\r\n        }\r\n\r\n        SavingsLogger(SAVINGS_LOGGER_ADDRESS).logSwap(msg.sender, uint8(_from), uint8(_to), _amount);\r\n    }\r\n\r\n\r\n    function withdrawDai() public {\r\n        ERC20(DAI_ADDRESS).transfer(msg.sender, ERC20(DAI_ADDRESS).balanceOf(address(this)));\r\n    }\r\n\r\n    function getAddress(SavingsProtocol _protocol) public pure returns(address) {\r\n        if (_protocol == SavingsProtocol.Compound) {\r\n            return SAVINGS_COMPOUND_ADDRESS;\r\n        }\r\n\r\n        if (_protocol == SavingsProtocol.Dydx) {\r\n            return SAVINGS_DYDX_ADDRESS;\r\n        }\r\n\r\n        if (_protocol == SavingsProtocol.Fulcrum) {\r\n            return SAVINGS_FULCRUM_ADDRESS;\r\n        }\r\n    }\r\n\r\n    function _deposit(SavingsProtocol _protocol, uint _amount) internal {\r\n        approveDeposit(_protocol, _amount);\r\n\r\n        ProtocolInterface(getAddress(_protocol)).deposit(address(this), _amount);\r\n\r\n        endAction(_protocol);\r\n    }\r\n\r\n    function _withdraw(SavingsProtocol _protocol, uint _amount) public {\r\n        approveWithdraw(_protocol, _amount);\r\n\r\n        ProtocolInterface(getAddress(_protocol)).withdraw(address(this), _amount);\r\n\r\n        endAction(_protocol);\r\n\r\n        withdrawDai();\r\n    }\r\n\r\n    function endAction(SavingsProtocol _protocol) internal {\r\n        if (_protocol == SavingsProtocol.Dydx) {\r\n            setDydxOperator(false);\r\n        }\r\n    }\r\n\r\n    function approveDeposit(SavingsProtocol _protocol, uint _amount) internal {\r\n        ERC20(DAI_ADDRESS).transferFrom(msg.sender, address(this), _amount);\r\n\r\n        if (_protocol == SavingsProtocol.Compound || _protocol == SavingsProtocol.Fulcrum) {\r\n            ERC20(DAI_ADDRESS).approve(getAddress(_protocol), uint(-1));\r\n        }\r\n\r\n        if (_protocol == SavingsProtocol.Dydx) {\r\n            ERC20(DAI_ADDRESS).approve(SOLO_MARGIN_ADDRESS, uint(-1));\r\n            setDydxOperator(true);\r\n        }\r\n    }\r\n\r\n    function approveWithdraw(SavingsProtocol _protocol, uint _amount) internal {\r\n        if (_protocol == SavingsProtocol.Compound) {\r\n            ERC20(NEW_CDAI_ADDRESS).approve(getAddress(_protocol), uint(-1));\r\n        }\r\n\r\n        if (_protocol == SavingsProtocol.Dydx) {\r\n            setDydxOperator(true);\r\n        }\r\n\r\n        if (_protocol == SavingsProtocol.Fulcrum) {\r\n            ERC20(NEW_IDAI_ADDRESS).approve(getAddress(_protocol), uint(-1));\r\n        }\r\n    }\r\n\r\n    function setDydxOperator(bool _trusted) internal {\r\n        ISoloMargin.OperatorArg[] memory operatorArgs = new ISoloMargin.OperatorArg[](1);\r\n        operatorArgs[0] = ISoloMargin.OperatorArg({\r\n            operator: getAddress(SavingsProtocol.Dydx),\r\n            trusted: _trusted\r\n        });\r\n\r\n        ISoloMargin(SOLO_MARGIN_ADDRESS).setOperators(operatorArgs);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"WETH_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CDAI_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SAVINGS_LOGGER_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SAI_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"uint8\"},{\"name\":\"_to\",\"type\":\"uint8\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SAVINGS_DYDX_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PIP_INTERFACE_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KYBER_ETH_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OTC_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAI_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"IDAI_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GAS_TOKEN_INTERFACE_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VOX_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MANAGER_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_protocol\",\"type\":\"uint8\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SAVINGS_FULCRUM_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MONITOR_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH2DAI_WRAPPER\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STUPID_EXCHANGE\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"POT_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIGRATION_ACTIONS_PROXY\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SPOTTER_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROXY_REGISTRY_INTERFACE_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROXY_ACTIONS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MKR_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FACTORY_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LOGGER_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SAVER_EXCHANGE_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAKER_DAI_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DISCOUNT_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_protocol\",\"type\":\"uint8\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"_withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"JUG_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NEW_CDAI_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KYBER_WRAPPER\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SUBSCRIPTION_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_protocol\",\"type\":\"uint8\"}],\"name\":\"getAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NEW_IDAI_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMPOUND_DAI_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UNISWAP_FACTORY\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OASIS_WRAPPER\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PETH_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KYBER_INTERFACE\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VAT_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAI_JOIN_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WALLET_ID\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SOLO_MARGIN_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UNISWAP_WRAPPER\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TUB_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_JOIN_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_protocol\",\"type\":\"uint8\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SCD_MCD_MIGRATION\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SAVINGS_COMPOUND_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SavingsProxy","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://6de013a2ac75ddffc5a9b3c8c0705f575594f19fc20ecf168d3bdc5fb1067524"}]}