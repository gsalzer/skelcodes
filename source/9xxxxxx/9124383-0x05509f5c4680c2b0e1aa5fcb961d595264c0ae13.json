{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.13;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract XBullionTokenConfig {\r\n    using Math64x64 for int128;\r\n\r\n    string internal constant TOKEN_SYMBOL = \"GOLD\";\r\n    string internal constant TOKEN_NAME = \"xbullion token\";\r\n    uint8 internal constant TOKEN_DECIMALS = 8;\r\n\r\n    uint256 private constant DECIMALS_FACTOR = 10**uint256(TOKEN_DECIMALS);\r\n    uint256 internal constant TOKEN_INITIALSUPPLY = 0;\r\n\r\n    uint256 internal constant TOKEN_MINTCAPACITY = 100 * DECIMALS_FACTOR;\r\n    uint internal constant TOKEN_MINTPERIOD = 24 hours;\r\n\r\n    function initialFeeTiers()\r\n        internal\r\n        pure\r\n        returns (ERC20WithFees.FeeTier[] memory feeTiers)\r\n    {\r\n        feeTiers = new ERC20WithFees.FeeTier[](2);\r\n        feeTiers[0] = ERC20WithFees.FeeTier({\r\n            threshold: 0,\r\n            fee: feeFromBPs(60)\r\n        });\r\n        feeTiers[1] = ERC20WithFees.FeeTier({\r\n            threshold: 20000 * DECIMALS_FACTOR,\r\n            fee: feeFromBPs(30)\r\n        });\r\n    }\r\n\r\n    function initialTxFee()\r\n        internal\r\n        pure\r\n        returns (int128)\r\n    {\r\n        return txFeeFromBPs(12);\r\n    }\r\n\r\n    function makeAddressSingleton(address _addr)\r\n        internal\r\n        pure\r\n        returns (address[] memory addrs)\r\n    {\r\n        addrs = new address[](1);\r\n        addrs[0] = _addr;\r\n    }\r\n\r\n    function feeFromBPs(uint _bps)\r\n        internal\r\n        pure\r\n        returns (int128)\r\n    {\r\n        return Math64x64.fromUInt(_bps)\r\n            .div(Math64x64.fromUInt(10000))\r\n            .div(Math64x64.fromUInt(365))\r\n            .div(Math64x64.fromUInt(86400));\r\n    }\r\n\r\n    function txFeeFromBPs(uint _bps)\r\n        internal\r\n        pure\r\n        returns (int128)\r\n    {\r\n        return Math64x64.fromUInt(_bps)\r\n            .div(Math64x64.fromUInt(10000));\r\n    }\r\n}\r\n\r\ncontract ERC20Interface {\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n    event Burn(address indexed from, uint256 amount);\r\n    event Mint(address indexed to, uint256 amount);\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n    function approve(address _spender, uint256 _amount) public returns (bool success);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _amount) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success);\r\n\r\n    function decimals() public view returns (uint8);\r\n    function name() public view returns (string memory);\r\n    function symbol() public view returns (string memory);\r\n    function totalSupply() public view returns (uint256);\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary AddressSet\r\n{\r\n    struct addrset\r\n    {\r\n        mapping(address => uint) index;\r\n        address[] elements;\r\n    }\r\n\r\n    function insert(addrset storage self, address e)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        if (self.index[e] > 0) {\r\n            return false;\r\n        } else {\r\n            self.index[e] = self.elements.push(e);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function remove(addrset storage self, address e)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        uint index = self.index[e];\r\n        if (index == 0) {\r\n            return false;\r\n        } else {\r\n            address e0 = self.elements[self.elements.length - 1];\r\n            self.elements[index - 1] = e0;\r\n            self.elements.pop();\r\n            self.index[e0] = index;\r\n            delete self.index[e];\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function has(addrset storage self, address e)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return self.index[e] > 0;\r\n    }\r\n}\r\n\r\n/**\r\n * Smart contract library of mathematical functions operating with signed\r\n * 64.64-bit fixed point numbers.\r\n */\r\nlibrary Math64x64 {\r\n  /**\r\n   * Minimum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\r\n\r\n  /**\r\n   * Maximum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /**\r\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromInt (int256 x) internal pure returns (int128) {\r\n    require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\r\n    return int128 (x << 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\r\n   * rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64-bit integer number\r\n   */\r\n  function toInt (int128 x) internal pure returns (int64) {\r\n    return int64 (x >> 64);\r\n  }\r\n\r\n  /**\r\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromUInt (uint256 x) internal pure returns (int128) {\r\n    require (x <= 0x7FFFFFFFFFFFFFFF);\r\n    return int128 (x << 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\r\n   * number rounding down.  Revert on underflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return unsigned 64-bit integer number\r\n   */\r\n  function toUInt (int128 x) internal pure returns (uint64) {\r\n    require (x >= 0);\r\n    return uint64 (x >> 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\r\n   * number rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 128.128-bin fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function from128x128 (int256 x) internal pure returns (int128) {\r\n    int256 result = x >> 64;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\r\n   * number.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 128.128 fixed point number\r\n   */\r\n  function to128x128 (int128 x) internal pure returns (int256) {\r\n    return int256 (x) << 64;\r\n  }\r\n\r\n  /**\r\n   * Calculate x + y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function add (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) + y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x - y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sub (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) - y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function mul (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) * y >> 64;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\r\n   * number and y is signed 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 256-bit integer number\r\n   */\r\n  function muli (int128 x, int256 y) internal pure returns (int256) {\r\n    if (x == MIN_64x64) {\r\n      require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\r\n        y <= 0x1000000000000000000000000000000000000000000000000);\r\n      return -y << 63;\r\n    } else {\r\n      bool negativeResult = false;\r\n      if (x < 0) {\r\n        x = -x;\r\n        negativeResult = true;\r\n      }\r\n      if (y < 0) {\r\n        y = -y; // We rely on overflow behavior here\r\n        negativeResult = !negativeResult;\r\n      }\r\n      uint256 absoluteResult = mulu (x, uint256 (y));\r\n      if (negativeResult) {\r\n        require (absoluteResult <=\r\n          0x8000000000000000000000000000000000000000000000000000000000000000);\r\n        return -int256 (absoluteResult); // We rely on overflow behavior here\r\n      } else {\r\n        require (absoluteResult <=\r\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n        return int256 (absoluteResult);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 256-bit integer number\r\n   */\r\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\r\n    if (y == 0) return 0;\r\n\r\n    require (x >= 0);\r\n\r\n    uint256 lo = (uint256 (x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\r\n    uint256 hi = uint256 (x) * (y >> 128);\r\n\r\n    require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    hi <<= 64;\r\n\r\n    require (hi <=\r\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\r\n    return hi + lo;\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function div (int128 x, int128 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n    int256 result = (int256 (x) << 64) / y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divi (int256 x, int256 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n\r\n    bool negativeResult = false;\r\n    if (x < 0) {\r\n      x = -x; // We rely on overflow behavior here\r\n      negativeResult = true;\r\n    }\r\n    if (y < 0) {\r\n      y = -y; // We rely on overflow behavior here\r\n      negativeResult = !negativeResult;\r\n    }\r\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\r\n    if (negativeResult) {\r\n      require (absoluteResult <= 0x80000000000000000000000000000000);\r\n      return -int128 (absoluteResult); // We rely on overflow behavior here\r\n    } else {\r\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return int128 (absoluteResult); // We rely on overflow behavior here\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n    uint128 result = divuu (x, y);\r\n    require (result <= uint128 (MAX_64x64));\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate -x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function neg (int128 x) internal pure returns (int128) {\r\n    require (x != MIN_64x64);\r\n    return -x;\r\n  }\r\n\r\n  /**\r\n   * Calculate |x|.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function abs (int128 x) internal pure returns (int128) {\r\n    require (x != MIN_64x64);\r\n    return x < 0 ? -x : x;\r\n  }\r\n\r\n  /**\r\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function inv (int128 x) internal pure returns (int128) {\r\n    require (x != 0);\r\n    int256 result = int256 (0x100000000000000000000000000000000) / x;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function avg (int128 x, int128 y) internal pure returns (int128) {\r\n    return int128 ((int256 (x) + int256 (y)) >> 1);\r\n  }\r\n\r\n  /**\r\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\r\n   * Revert on overflow or in case x * y is negative.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 m = int256 (x) * int256 (y);\r\n    require (m >= 0);\r\n    require (m <\r\n        0x4000000000000000000000000000000000000000000000000000000000000000);\r\n    return int128 (sqrtu (uint256 (m), uint256 (x) + uint256 (y) >> 1));\r\n  }\r\n\r\n  /**\r\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\r\n    uint256 absoluteResult;\r\n    bool negativeResult = false;\r\n    if (x >= 0) {\r\n      absoluteResult = powu (uint256 (x) << 63, y);\r\n    } else {\r\n      // We rely on overflow behavior here\r\n      absoluteResult = powu (uint256 (uint128 (-x)) << 63, y);\r\n      negativeResult = y & 1 > 0;\r\n    }\r\n\r\n    absoluteResult >>= 63;\r\n\r\n    if (negativeResult) {\r\n      require (absoluteResult <= 0x80000000000000000000000000000000);\r\n      return -int128 (absoluteResult); // We rely on overflow behavior here\r\n    } else {\r\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return int128 (absoluteResult); // We rely on overflow behavior here\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sqrt (int128 x) internal pure returns (int128) {\r\n    require (x >= 0);\r\n    return int128 (sqrtu (uint256 (x) << 64, 0x10000000000000000));\r\n  }\r\n\r\n  /**\r\n   * Calculate binary logarithm of x.  Revert if x <= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function log_2 (int128 x) internal pure returns (int128) {\r\n    require (x > 0);\r\n\r\n    int256 msb = 0;\r\n    int256 xc = x;\r\n    if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\r\n    if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n    if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n    if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n    if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n    if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n    if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n    int256 result = msb - 64 << 64;\r\n    uint256 ux = uint256 (x) << 127 - msb;\r\n    for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\r\n      ux *= ux;\r\n      uint256 b = ux >> 255;\r\n      ux >>= 127 + b;\r\n      result += bit * int256 (b);\r\n    }\r\n\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate natural logarithm of x.  Revert if x <= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function ln (int128 x) internal pure returns (int128) {\r\n    require (x > 0);\r\n\r\n    return int128 (\r\n        uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128);\r\n  }\r\n\r\n  /**\r\n   * Calculate binary exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp_2 (int128 x) internal pure returns (int128) {\r\n    require (x < 0x400000000000000000); // Overflow\r\n\r\n    if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n    uint256 result = 0x80000000000000000000000000000000;\r\n\r\n    if (x & 0x8000000000000000 > 0)\r\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\r\n    if (x & 0x4000000000000000 > 0)\r\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\r\n    if (x & 0x2000000000000000 > 0)\r\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\r\n    if (x & 0x1000000000000000 > 0)\r\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\r\n    if (x & 0x800000000000000 > 0)\r\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\r\n    if (x & 0x400000000000000 > 0)\r\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\r\n    if (x & 0x200000000000000 > 0)\r\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\r\n    if (x & 0x100000000000000 > 0)\r\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\r\n    if (x & 0x80000000000000 > 0)\r\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\r\n    if (x & 0x40000000000000 > 0)\r\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\r\n    if (x & 0x20000000000000 > 0)\r\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\r\n    if (x & 0x10000000000000 > 0)\r\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\r\n    if (x & 0x8000000000000 > 0)\r\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\r\n    if (x & 0x4000000000000 > 0)\r\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\r\n    if (x & 0x2000000000000 > 0)\r\n      result = result * 0x1000162E525EE054754457D5995292026 >> 128;\r\n    if (x & 0x1000000000000 > 0)\r\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\r\n    if (x & 0x800000000000 > 0)\r\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\r\n    if (x & 0x400000000000 > 0)\r\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\r\n    if (x & 0x200000000000 > 0)\r\n      result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\r\n    if (x & 0x100000000000 > 0)\r\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\r\n    if (x & 0x80000000000 > 0)\r\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\r\n    if (x & 0x40000000000 > 0)\r\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\r\n    if (x & 0x20000000000 > 0)\r\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\r\n    if (x & 0x10000000000 > 0)\r\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\r\n    if (x & 0x8000000000 > 0)\r\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\r\n    if (x & 0x4000000000 > 0)\r\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\r\n    if (x & 0x2000000000 > 0)\r\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\r\n    if (x & 0x1000000000 > 0)\r\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\r\n    if (x & 0x800000000 > 0)\r\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\r\n    if (x & 0x400000000 > 0)\r\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\r\n    if (x & 0x200000000 > 0)\r\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\r\n    if (x & 0x100000000 > 0)\r\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\r\n    if (x & 0x80000000 > 0)\r\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\r\n    if (x & 0x40000000 > 0)\r\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\r\n    if (x & 0x20000000 > 0)\r\n      result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\r\n    if (x & 0x10000000 > 0)\r\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\r\n    if (x & 0x8000000 > 0)\r\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\r\n    if (x & 0x4000000 > 0)\r\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\r\n    if (x & 0x2000000 > 0)\r\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\r\n    if (x & 0x1000000 > 0)\r\n      result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\r\n    if (x & 0x800000 > 0)\r\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\r\n    if (x & 0x400000 > 0)\r\n      result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\r\n    if (x & 0x200000 > 0)\r\n      result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\r\n    if (x & 0x100000 > 0)\r\n      result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\r\n    if (x & 0x80000 > 0)\r\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\r\n    if (x & 0x40000 > 0)\r\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\r\n    if (x & 0x20000 > 0)\r\n      result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\r\n    if (x & 0x10000 > 0)\r\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\r\n    if (x & 0x8000 > 0)\r\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\r\n    if (x & 0x4000 > 0)\r\n      result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\r\n    if (x & 0x2000 > 0)\r\n      result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\r\n    if (x & 0x1000 > 0)\r\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\r\n    if (x & 0x800 > 0)\r\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\r\n    if (x & 0x400 > 0)\r\n      result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\r\n    if (x & 0x200 > 0)\r\n      result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\r\n    if (x & 0x100 > 0)\r\n      result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\r\n    if (x & 0x80 > 0)\r\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\r\n    if (x & 0x40 > 0)\r\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\r\n    if (x & 0x20 > 0)\r\n      result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\r\n    if (x & 0x10 > 0)\r\n      result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\r\n    if (x & 0x8 > 0)\r\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\r\n    if (x & 0x4 > 0)\r\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\r\n    if (x & 0x2 > 0)\r\n      result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\r\n    if (x & 0x1 > 0)\r\n      result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\r\n\r\n    result >>= 63 - (x >> 64);\r\n    require (result <= uint256 (MAX_64x64));\r\n\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate natural exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp (int128 x) internal pure returns (int128) {\r\n    require (x < 0x400000000000000000); // Overflow\r\n\r\n    if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n    return exp_2 (\r\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 64.64-bit fixed point number\r\n   */\r\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\r\n    require (y != 0);\r\n\r\n    uint256 result;\r\n\r\n    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n      result = (x << 64) / y;\r\n    else {\r\n      uint256 a = 192;\r\n      uint256 b = 255;\r\n      while (a < b) {\r\n        uint256 m = a + b >> 1;\r\n        uint256 t = x >> m;\r\n        if (t == 0) b = m - 1;\r\n        else if (t > 1) a = m + 1;\r\n        else {\r\n          a = m;\r\n          break;\r\n        }\r\n      }\r\n\r\n      result = (x << 255 - a) / ((y - 1 >> a - 191) + 1);\r\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n      uint256 hi = result * (y >> 128);\r\n      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n      uint256 xh = x >> 192;\r\n      uint256 xl = x << 64;\r\n\r\n      if (xl < lo) xh -= 1;\r\n      xl -= lo; // We rely on overflow behavior here\r\n      lo = hi << 128;\r\n      if (xl < lo) xh -= 1;\r\n      xl -= lo; // We rely on overflow behavior here\r\n\r\n      assert (xh == hi >> 128);\r\n\r\n      result += xl / y;\r\n    }\r\n\r\n    require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    return uint128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x^y assuming 0^0 is 1, where x is unsigned 129.127 fixed point\r\n   * number and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 129.127-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return unsigned 129.127-bit fixed point number\r\n   */\r\n  function powu (uint256 x, uint256 y) private pure returns (uint256) {\r\n    if (y == 0) return 0x80000000000000000000000000000000;\r\n    else if (x == 0) return 0;\r\n    else {\r\n      uint256 a = 0;\r\n      uint256 b = 255;\r\n      while (a < b) {\r\n        uint256 m = a + b >> 1;\r\n        uint256 t = x >> m;\r\n        if (t == 0) b = m - 1;\r\n        else if (t > 1) a = m + 1;\r\n        else {\r\n          a = m;\r\n          break;\r\n        }\r\n      }\r\n\r\n      int256 xe = int256 (a) - 127;\r\n      if (xe > 0) x >>= xe;\r\n      else x <<= -xe;\r\n\r\n      uint256 result = 0x80000000000000000000000000000000;\r\n      int256 re = 0;\r\n\r\n      while (y > 0) {\r\n        if (y & 1 > 0) {\r\n          result = result * x;\r\n          y -= 1;\r\n          re += xe;\r\n          if (result >=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\r\n            result >>= 128;\r\n            re += 1;\r\n          } else result >>= 127;\r\n          if (re < -127) return 0; // Underflow\r\n          require (re < 128); // Overflow\r\n        } else {\r\n          x = x * x;\r\n          y >>= 1;\r\n          xe <<= 1;\r\n          if (x >=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\r\n            x >>= 128;\r\n            xe += 1;\r\n          } else x >>= 127;\r\n          if (xe < -127) return 0; // Underflow\r\n          require (xe < 128); // Overflow\r\n        }\r\n      }\r\n\r\n      if (re > 0) result <<= re;\r\n      else if (re < 0) result >>= -re;\r\n\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\r\n   * number.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return unsigned 128-bit integer number\r\n   */\r\n  function sqrtu (uint256 x, uint256 r) private pure returns (uint128) {\r\n    if (x == 0) return 0;\r\n    else {\r\n      require (r > 0);\r\n      while (true) {\r\n        uint256 rr = x / r;\r\n        if (r == rr || r + 1 == rr) return uint128 (r);\r\n        else if (r == rr + 1) return uint128 (rr);\r\n        r = r + rr + 1 >> 1;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\ncontract BurnerRole {\r\n    using AddressSet for AddressSet.addrset;\r\n\r\n    AddressSet.addrset private burners;\r\n\r\n    event BurnerAddition(address indexed addr);\r\n    event BurnerRemoval(address indexed addr);\r\n\r\n    modifier ifBurner(address _addr) {\r\n        require(isBurner(_addr),\r\n            \"BurnerRole: specified account does not have the Burner role\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyBurner() {\r\n        require(isBurner(msg.sender),\r\n            \"BurnerRole: caller does not have the Burner role\");\r\n        _;\r\n    }\r\n\r\n    function getBurners()\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return burners.elements;\r\n    }\r\n\r\n    function isBurner(address _addr)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return burners.has(_addr);\r\n    }\r\n\r\n    function numBurners()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return burners.elements.length;\r\n    }\r\n\r\n    function _addBurner(address _addr)\r\n        internal\r\n    {\r\n        require(burners.insert(_addr),\r\n            \"BurnerRole: duplicate bearer\");\r\n        emit BurnerAddition(_addr);\r\n    }\r\n\r\n    function _removeBurner(address _addr)\r\n        internal\r\n    {\r\n        require(burners.remove(_addr),\r\n            \"BurnerRole: not a bearer\");\r\n        emit BurnerRemoval(_addr);\r\n    }\r\n}\r\n\r\ncontract ManagerRole {\r\n    using AddressSet for AddressSet.addrset;\r\n\r\n    AddressSet.addrset private managers;\r\n\r\n    event ManagerAddition(address indexed addr);\r\n    event ManagerRemoval(address indexed addr);\r\n\r\n    modifier ifManager(address _addr) {\r\n        require(isManager(_addr),\r\n            \"ManagerRole: specified account does not have the Manager role\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyManager() {\r\n        require(isManager(msg.sender),\r\n            \"ManagerRole: caller does not have the Manager role\");\r\n        _;\r\n    }\r\n\r\n    function getManagers()\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return managers.elements;\r\n    }\r\n\r\n    function isManager(address _addr)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return managers.has(_addr);\r\n    }\r\n\r\n    function numManagers()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return managers.elements.length;\r\n    }\r\n\r\n    function _addManager(address _addr)\r\n        internal\r\n    {\r\n        require(managers.insert(_addr),\r\n            \"ManagerRole: duplicate bearer\");\r\n        emit ManagerAddition(_addr);\r\n    }\r\n\r\n    function _removeManager(address _addr)\r\n        internal\r\n    {\r\n        require(managers.remove(_addr),\r\n            \"ManagerRole: not a bearer\");\r\n        emit ManagerRemoval(_addr);\r\n    }\r\n}\r\n\r\ncontract MinterRole {\r\n    using AddressSet for AddressSet.addrset;\r\n\r\n    AddressSet.addrset private minters;\r\n\r\n    event MinterAddition(address indexed addr);\r\n    event MinterRemoval(address indexed addr);\r\n\r\n    modifier ifMinter(address _addr) {\r\n        require(isMinter(_addr),\r\n            \"MinterRole: specified account does not have the Minter role\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n        require(isMinter(msg.sender),\r\n            \"MinterRole: caller does not have the Minter role\");\r\n        _;\r\n    }\r\n\r\n    function getMinters()\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return minters.elements;\r\n    }\r\n\r\n    function isMinter(address _addr)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return minters.has(_addr);\r\n    }\r\n\r\n    function numMinters()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return minters.elements.length;\r\n    }\r\n\r\n    function _addMinter(address _addr)\r\n        internal\r\n    {\r\n        require(minters.insert(_addr),\r\n            \"MinterRole: duplicate bearer\");\r\n        emit MinterAddition(_addr);\r\n    }\r\n\r\n    function _removeMinter(address _addr)\r\n        internal\r\n    {\r\n        require(minters.remove(_addr),\r\n            \"MinterRole: not a bearer\");\r\n        emit MinterRemoval(_addr);\r\n    }\r\n}\r\n\r\ncontract OwnerRole {\r\n    using AddressSet for AddressSet.addrset;\r\n\r\n    AddressSet.addrset private owners;\r\n\r\n    event OwnerAddition(address indexed addr);\r\n    event OwnerRemoval(address indexed addr);\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender),\r\n            \"OwnerRole: caller does not have the Owner role\");\r\n        _;\r\n    }\r\n\r\n    function getOwners()\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return owners.elements;\r\n    }\r\n\r\n    function isOwner(address _addr)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return owners.has(_addr);\r\n    }\r\n\r\n    function numOwners()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return owners.elements.length;\r\n    }\r\n\r\n    function _addOwner(address _addr)\r\n        internal\r\n    {\r\n        require(owners.insert(_addr),\r\n            \"OwnerRole: duplicate bearer\");\r\n        emit OwnerAddition(_addr);\r\n    }\r\n\r\n    function _removeOwner(address _addr)\r\n        internal\r\n    {\r\n        require(owners.remove(_addr),\r\n            \"OwnerRole: not a bearer\");\r\n        emit OwnerRemoval(_addr);\r\n    }\r\n}\r\n\r\ncontract MultiOwned is OwnerRole {\r\n    uint constant public MAX_OWNER_COUNT = 50;\r\n\r\n    struct Transaction {\r\n        bytes data;\r\n        bool executed;\r\n    }\r\n\r\n    mapping(bytes32 => Transaction) public transactions;\r\n    mapping(bytes32 => mapping(address => bool)) internal confirmations;\r\n    uint public required;\r\n\r\n    event Confirmation(address indexed sender, bytes32 indexed transactionId);\r\n    event Revocation(address indexed sender, bytes32 indexed transactionId);\r\n    event Submission(bytes32 indexed transactionId);\r\n    event Execution(bytes32 indexed transactionId);\r\n    event ExecutionFailure(bytes32 indexed transactionId);\r\n    event Requirement(uint required);\r\n\r\n    modifier confirmed(bytes32 _transactionId, address _owner) {\r\n        require(confirmations[_transactionId][_owner]);\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmed(bytes32 _transactionId, address _owner) {\r\n        require(!confirmations[_transactionId][_owner]);\r\n        _;\r\n    }\r\n\r\n    modifier notExecuted(bytes32 _transactionId) {\r\n        require(!transactions[_transactionId].executed);\r\n        _;\r\n    }\r\n\r\n    modifier onlySelf() {\r\n        require(msg.sender == address(this));\r\n        _;\r\n    }\r\n\r\n    modifier transactionExists(bytes32 _transactionId) {\r\n        require(transactions[_transactionId].data.length != 0);\r\n        _;\r\n    }\r\n\r\n    modifier validRequirement(uint _ownerCount, uint _required) {\r\n        require(0 < _ownerCount\r\n            && 0 < _required\r\n            && _required <= _ownerCount\r\n            && _ownerCount <= MAX_OWNER_COUNT);\r\n        _;\r\n    }\r\n\r\n    constructor(address[] memory _owners, uint _required)\r\n        public\r\n        validRequirement(_owners.length, _required)\r\n    {\r\n        for (uint i = 0; i < _owners.length; ++i) {\r\n            _addOwner(_owners[i]);\r\n        }\r\n        required = _required;\r\n    }\r\n\r\n    function addOwner(address _owner)\r\n        public\r\n        onlySelf\r\n        validRequirement(numOwners() + 1, required)\r\n    {\r\n        _addOwner(_owner);\r\n    }\r\n\r\n    function addTransaction(bytes memory _data, uint _nonce)\r\n        internal\r\n        returns (bytes32 transactionId)\r\n    {\r\n        if (_nonce == 0) _nonce = block.number;\r\n        transactionId = makeTransactionId(_data, _nonce);\r\n        if (transactions[transactionId].data.length == 0) {\r\n            transactions[transactionId] = Transaction({\r\n                data: _data,\r\n                executed: false\r\n            });\r\n            emit Submission(transactionId);\r\n        }\r\n    }\r\n\r\n    function confirmTransaction(bytes32 _transactionId)\r\n        public\r\n        onlyOwner\r\n        transactionExists(_transactionId)\r\n        notConfirmed(_transactionId, msg.sender)\r\n    {\r\n        confirmations[_transactionId][msg.sender] = true;\r\n        emit Confirmation(msg.sender, _transactionId);\r\n        executeTransaction(_transactionId);\r\n    }\r\n\r\n    function executeTransaction(bytes32 _transactionId)\r\n        public\r\n        onlyOwner\r\n        confirmed(_transactionId, msg.sender)\r\n        notExecuted(_transactionId)\r\n    {\r\n        if (isConfirmed(_transactionId)) {\r\n            Transaction storage txn = transactions[_transactionId];\r\n            txn.executed = true;\r\n            (bool success,) = address(this).call(txn.data);\r\n            if (success) {\r\n                emit Execution(_transactionId);\r\n            } else {\r\n                emit ExecutionFailure(_transactionId);\r\n                txn.executed = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function removeOwner(address _owner)\r\n        public\r\n        onlySelf\r\n    {\r\n        _removeOwner(_owner);\r\n        if (required > numOwners()) {\r\n            setRequirement(numOwners());\r\n        }\r\n    }\r\n\r\n    function renounceOwner()\r\n        public\r\n        validRequirement(numOwners() - 1, required)\r\n    {\r\n        _removeOwner(msg.sender);\r\n    }\r\n\r\n    function replaceOwner(address _owner, address _newOwner)\r\n        public\r\n        onlySelf\r\n    {\r\n        _addOwner(_owner);\r\n        _removeOwner(_newOwner);\r\n    }\r\n\r\n    function revokeConfirmation(bytes32 _transactionId)\r\n        public\r\n        onlyOwner\r\n        confirmed(_transactionId, msg.sender)\r\n        notExecuted(_transactionId)\r\n    {\r\n        confirmations[_transactionId][msg.sender] = false;\r\n        emit Revocation(msg.sender, _transactionId);\r\n    }\r\n\r\n    function setRequirement(uint _required)\r\n        public\r\n        onlySelf\r\n        validRequirement(numOwners(), _required)\r\n    {\r\n        required = _required;\r\n        emit Requirement(_required);\r\n    }\r\n\r\n    function submitTransaction(bytes memory _data, uint _nonce)\r\n        public\r\n        returns (bytes32 transactionId)\r\n    {\r\n        transactionId = addTransaction(_data, _nonce);\r\n        confirmTransaction(transactionId);\r\n    }\r\n\r\n    function getConfirmationCount(bytes32 _transactionId)\r\n        public\r\n        view\r\n        returns (uint count)\r\n    {\r\n        address[] memory owners = getOwners();\r\n        for (uint i = 0; i < numOwners(); ++i) {\r\n            if (confirmations[_transactionId][owners[i]]) ++count;\r\n        }\r\n    }\r\n\r\n    function getConfirmations(bytes32 _transactionId)\r\n        public\r\n        view\r\n        returns (address[] memory _confirmations)\r\n    {\r\n        address[] memory confirmationsTmp = new address[](numOwners());\r\n        uint count = 0;\r\n        uint i;\r\n        address[] memory owners = getOwners();\r\n        for (i = 0; i < numOwners(); ++i) {\r\n            if (confirmations[_transactionId][owners[i]]) {\r\n                confirmationsTmp[count] = owners[i];\r\n                ++count;\r\n            }\r\n        }\r\n        _confirmations = new address[](count);\r\n        for (i = 0; i < count; ++i) {\r\n            _confirmations[i] = confirmationsTmp[i];\r\n        }\r\n    }\r\n\r\n    function isConfirmed(bytes32 _transactionId)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        address[] memory owners = getOwners();\r\n        uint count = 0;\r\n        for (uint i = 0; i < numOwners(); ++i) {\r\n            if (confirmations[_transactionId][owners[i]]) ++count;\r\n            if (count == required) return true;\r\n        }\r\n    }\r\n\r\n    function makeTransactionId(bytes memory _data, uint _nonce)\r\n        public\r\n        pure\r\n        returns (bytes32 transactionId)\r\n    {\r\n        transactionId = keccak256(abi.encode(_data, _nonce));\r\n    }\r\n}\r\n\r\ncontract ERC20 is ERC20Interface {\r\n    using SafeMath for uint256;\r\n\r\n    string  internal tokenName;\r\n    string  internal tokenSymbol;\r\n    uint8   internal tokenDecimals;\r\n    uint256 internal tokenTotalSupply;\r\n\r\n    mapping(address => uint256) internal balances;\r\n    mapping(address => mapping(address => uint256)) internal allowed;\r\n\r\n    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply)\r\n        internal\r\n    {\r\n        tokenName = _name;\r\n        tokenSymbol = _symbol;\r\n        tokenDecimals = _decimals;\r\n        _mint(msg.sender, _totalSupply);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _amount)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        _approve(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint256 _delta)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        _approve(msg.sender, _spender, allowed[msg.sender][_spender].sub(_delta));\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint256 _delta)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        _approve(msg.sender, _spender, allowed[msg.sender][_spender].add(_delta));\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _amount)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        _transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _amount)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        _transfer(_from, _to, _amount);\r\n        _approve(_from, msg.sender, allowed[_from][msg.sender].sub(_amount));\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender)\r\n        public\r\n        view\r\n        returns (uint256 remaining)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function balanceOf(address _owner)\r\n        public\r\n        view\r\n        returns (uint256 balance)\r\n    {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function decimals()\r\n        public\r\n        view\r\n        returns (uint8)\r\n    {\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function name()\r\n        public\r\n        view\r\n        returns (string memory)\r\n    {\r\n        return tokenName;\r\n    }\r\n\r\n    function symbol()\r\n        public\r\n        view\r\n        returns (string memory)\r\n    {\r\n        return tokenSymbol;\r\n    }\r\n\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return tokenTotalSupply;\r\n    }\r\n\r\n    function _approve(address _owner, address _spender, uint256 _amount)\r\n        internal\r\n    {\r\n        allowed[_owner][_spender] = _amount;\r\n        emit Approval(_owner, _spender, _amount);\r\n    }\r\n\r\n    function _burn(address _from, uint256 _amount)\r\n        internal\r\n    {\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        tokenTotalSupply = tokenTotalSupply.sub(_amount);\r\n\r\n        emit Transfer(_from, address(0), _amount);\r\n        emit Burn(_from, _amount);\r\n    }\r\n\r\n    function _mint(address _to, uint256 _amount)\r\n        internal\r\n    {\r\n        require(_to != address(0), \"ERC20: mint to the zero address\");\r\n        require(_to != address(this), \"ERC20: mint to token contract\");\r\n\r\n        tokenTotalSupply = tokenTotalSupply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n\r\n        emit Transfer(address(0), _to, _amount);\r\n        emit Mint(_to, _amount);\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint256 _amount)\r\n        internal\r\n    {\r\n        require(_to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(_to != address(this), \"ERC20: transfer to token contract\");\r\n\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Transfer(_from, _to, _amount);\r\n    }\r\n}\r\n\r\ncontract ERC20WithFees is MultiOwned, ERC20 {\r\n    using Math64x64 for int128;\r\n    using SafeMath for uint256;\r\n    using AddressSet for AddressSet.addrset;\r\n\r\n    struct FeeTier {\r\n        uint256 threshold;\r\n        int128 fee; // fraction per second; positive 64.64 fixed point number\r\n    }\r\n\r\n    AddressSet.addrset internal holders;\r\n    mapping(address => uint) internal lastCollected; // epoch timestamp of last management fee collection per holder\r\n    FeeTier[] internal feeTiers; // Management fees per tier; tier thresholds increase monotonically; assumed non-empty with first threshold value equal to zero.\r\n    int128 txFee; // Transfer fee ratio; positive 64.64 fixed point number\r\n\r\n    event ManagementFeeCollected(address indexed addr, uint256 amount);\r\n    event TransferFeeCollected(address indexed addr, uint256 amount);\r\n\r\n    constructor(FeeTier[] memory _feeTiers, int128 _txFee)\r\n        public\r\n    {\r\n        _setFeeTiers(_feeTiers);\r\n        _setTxFee(_txFee);\r\n    }\r\n\r\n    function collectAll()\r\n        public\r\n        returns (uint256 count, uint256 amount)\r\n    {\r\n        for (; count < holders.elements.length; ++count) {\r\n            amount += _collectFee(holders.elements[count]);\r\n        }\r\n    }\r\n\r\n    function collectAll(uint256 _offset, uint256 _limit)\r\n        public\r\n        returns (uint256 count, uint256 amount)\r\n    {\r\n        for (; count < _limit && count.add(_offset) < holders.elements.length; ++count) {\r\n            amount += _collectFee(holders.elements[count.add(_offset)]);\r\n        }\r\n    }\r\n\r\n    function setFeeTiers(FeeTier[] memory _feeTiers)\r\n        public\r\n        onlySelf\r\n    {\r\n        _setFeeTiers(_feeTiers);\r\n    }\r\n\r\n    function setTxFee(int128 _txFee)\r\n        public\r\n        onlySelf\r\n    {\r\n        _setTxFee(_txFee);\r\n    }\r\n\r\n    function transferAll(address _to)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        _transferAll(msg.sender, _to);\r\n        return true;\r\n    }\r\n\r\n    function transferAllFrom(address _from, address _to)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        uint256 amount = _transferAll(_from, _to);\r\n        _approve(_from, msg.sender, allowed[_from][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    function holderCount()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return holders.elements.length;\r\n    }\r\n\r\n    function balanceOf(address _owner)\r\n        public\r\n        view\r\n        returns (uint256 balance)\r\n    {\r\n        return balances[_owner].sub(_computeFee(_owner));\r\n    }\r\n\r\n    function _collectFee(address _from)\r\n        internal\r\n        returns (uint256 feeAmount)\r\n    {\r\n        if (balances[_from] != 0) {\r\n            feeAmount = _computeFee(_from);\r\n            if (feeAmount != 0) {\r\n                balances[_from] = balances[_from].sub(feeAmount);\r\n                tokenTotalSupply = tokenTotalSupply.sub(feeAmount);\r\n                emit Transfer(_from, address(0), feeAmount);\r\n                emit ManagementFeeCollected(_from, feeAmount);\r\n            }\r\n        }\r\n        lastCollected[_from] = now;\r\n    }\r\n\r\n    function _collectTxFee(address _from, uint256 _amount)\r\n        internal\r\n        returns (uint256 txFeeAmount)\r\n    {\r\n        txFeeAmount = _computeTxFee(_amount);\r\n        if (txFeeAmount != 0) {\r\n            balances[_from] = balances[_from].sub(txFeeAmount);\r\n            tokenTotalSupply = tokenTotalSupply.sub(txFeeAmount);\r\n            emit Transfer(_from, address(0), txFeeAmount);\r\n            emit TransferFeeCollected(_from, txFeeAmount);\r\n        }\r\n    }\r\n\r\n    function _setFeeTiers(FeeTier[] memory _feeTiers)\r\n        internal\r\n    {\r\n        require(_feeTiers.length > 0,\r\n            \"ERC20WithFees: empty fee schedule\");\r\n        require(_feeTiers[0].threshold == 0,\r\n            \"ERC20WithFees: nonzero threshold for bottom tier\");\r\n        require(Math64x64.fromUInt(0) <= _feeTiers[0].fee\r\n            && _feeTiers[0].fee <= Math64x64.fromUInt(1),\r\n            \"ERC20WithFees: invalid fee value\");\r\n        for (uint i = 1; i < _feeTiers.length; ++i) {\r\n            require(_feeTiers[i].threshold > _feeTiers[i-1].threshold,\r\n                \"ERC20WithFees: nonmonotonic threshold value\");\r\n            require(_feeTiers[i].fee < _feeTiers[i-1].fee,\r\n                \"ERC20WithFees: nonmonotonic fee value\");\r\n            require(Math64x64.fromUInt(0) <= _feeTiers[i].fee,\r\n                \"ERC20WithFees: invalid fee value\");\r\n        }\r\n\r\n        delete feeTiers; // re-initializes to empty dynamic storage array\r\n        for (uint i = 0; i < _feeTiers.length; ++i) {\r\n            feeTiers.push(_feeTiers[i]);\r\n        }\r\n    }\r\n\r\n    function _setTxFee(int128 _txFee)\r\n        internal\r\n    {\r\n        require(Math64x64.fromUInt(0) <= _txFee\r\n            && _txFee <= Math64x64.fromUInt(1),\r\n            \"ERC20WithFees: invalid transfer fee value\");\r\n        txFee = _txFee;\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint256 _amount)\r\n        internal\r\n    {\r\n        require(_to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(_to != address(this), \"ERC20: transfer to token contract\");\r\n\r\n        // Collect accrued management fees from sender and recipient\r\n        _collectFee(_from);\r\n        _collectFee(_to);\r\n\r\n        // Execute transfer\r\n        super._transfer(_from, _to, _amount);\r\n\r\n        // Collect transfer fee\r\n        _collectTxFee(_to, _amount);\r\n\r\n        // Update set of holders\r\n        if (balances[_from] == 0) holders.remove(_from);\r\n        if (balances[_to] > 0) holders.insert(_to);\r\n    }\r\n\r\n    function _transferAll(address _from, address _to)\r\n        internal\r\n        returns (uint256 amount)\r\n    {\r\n        require(_to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(_to != address(this), \"ERC20: transfer to token contract\");\r\n\r\n        // Collect accrued management fees from sender and recipient\r\n        _collectFee(_from);\r\n        _collectFee(_to);\r\n\r\n        // Execute transfer\r\n        amount = balances[_from];\r\n        super._transfer(_from, _to, amount);\r\n\r\n        // Collect transfer fee\r\n        _collectTxFee(_to, amount);\r\n\r\n        // Update set of holders\r\n        holders.remove(_from);\r\n        if (balances[_to] > 0) holders.insert(_to);\r\n    }\r\n\r\n    function _computeFee(address _addr)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint tier = 0;\r\n        while (tier+1 < feeTiers.length && feeTiers[tier+1].threshold <= balances[_addr]) {\r\n            ++tier;\r\n        }\r\n        uint duration = now - lastCollected[_addr];\r\n        return Math64x64.fromUInt(1).sub(Math64x64.exp(Math64x64.fromInt(-1).mul(Math64x64.fromUInt(duration)).mul(feeTiers[tier].fee))).mulu(balances[_addr]);\r\n    }\r\n\r\n    function _computeTxFee(uint256 _amount)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        return txFee.mulu(_amount);\r\n    }\r\n}\r\n\r\ncontract ERC20Burnable is ERC20WithFees, BurnerRole, ManagerRole {\r\n    function addBurner(address _addr)\r\n        public\r\n        onlyManager\r\n    {\r\n        _addBurner(_addr);\r\n    }\r\n\r\n    function addManager(address _addr)\r\n        public\r\n        onlySelf\r\n    {\r\n        _addManager(_addr);\r\n    }\r\n\r\n    function burn(uint256 _amount)\r\n        public\r\n        onlyBurner\r\n        returns (bool success)\r\n    {\r\n        _burn(msg.sender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function burnFrom(address _from, uint256 _amount)\r\n        public\r\n        ifBurner(_from)\r\n        returns (bool success)\r\n    {\r\n        _burn(_from, _amount);\r\n        _approve(_from, msg.sender, allowed[_from][msg.sender].sub(_amount));\r\n        return true;\r\n    }\r\n\r\n    function burnAll()\r\n        public\r\n        onlyBurner\r\n        returns (bool success)\r\n    {\r\n        _burnAll(msg.sender);\r\n        return true;\r\n    }\r\n\r\n    function burnAllFrom(address _from)\r\n        public\r\n        ifBurner(_from)\r\n        returns (bool success)\r\n    {\r\n        uint256 amount = _burnAll(_from);\r\n        _approve(_from, msg.sender, allowed[_from][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    function removeBurner(address _addr)\r\n        public\r\n        onlyManager\r\n    {\r\n        _removeBurner(_addr);\r\n    }\r\n\r\n    function removeManager(address _addr)\r\n        public\r\n        onlySelf\r\n    {\r\n        _removeManager(_addr);\r\n    }\r\n\r\n    function renounceManager()\r\n        public\r\n    {\r\n        _removeManager(msg.sender);\r\n    }\r\n\r\n    function _burn(address _from, uint256 _amount)\r\n        internal\r\n    {\r\n        _collectFee(_from);\r\n\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        if (balances[_from] == 0) holders.remove(_from);\r\n        tokenTotalSupply = tokenTotalSupply.sub(_amount);\r\n\r\n        emit Transfer(_from, address(0), _amount);\r\n        emit Burn(_from, _amount);\r\n    }\r\n\r\n    function _burnAll(address _from)\r\n        internal\r\n        returns (uint256 amount)\r\n    {\r\n        _collectFee(_from);\r\n\r\n        amount = balances[_from];\r\n        balances[_from] = 0;\r\n        holders.remove(_from);\r\n        tokenTotalSupply = tokenTotalSupply.sub(amount);\r\n\r\n        emit Transfer(_from, address(0), amount);\r\n        emit Burn(_from, amount);\r\n    }\r\n}\r\n\r\ncontract ERC20Mintable is XBullionTokenConfig, ERC20WithFees, MinterRole {\r\n    uint256 public mintCapacity;\r\n    uint256 public amountMinted;\r\n    uint public mintPeriod;\r\n    uint public mintPeriodStart;\r\n\r\n    event MintCapacity(uint256 amount);\r\n    event MintPeriod(uint duration);\r\n\r\n    constructor(uint256 _mintCapacity, uint _mintPeriod)\r\n        public\r\n    {\r\n        _setMintCapacity(_mintCapacity);\r\n        _setMintPeriod(_mintPeriod);\r\n    }\r\n\r\n    function addMinter(address _addr)\r\n        public\r\n        onlySelf\r\n    {\r\n        _addMinter(_addr);\r\n    }\r\n\r\n    function mint(address _to, uint256 _amount)\r\n        public\r\n    {\r\n        if (msg.sender != address(this)) {\r\n            require(isMinter(msg.sender), \"MinterRole: caller does not have the Minter role\");\r\n            require(isUnderMintLimit(_amount), \"ERC20: exceeds minting capacity\");\r\n        }\r\n        _mint(_to, _amount);\r\n    }\r\n\r\n    function removeMinter(address _addr)\r\n        public\r\n        onlySelf\r\n    {\r\n        _removeMinter(_addr);\r\n    }\r\n\r\n    function renounceMinter()\r\n        public\r\n        returns (bool)\r\n    {\r\n        _removeMinter(msg.sender);\r\n        return true;\r\n    }\r\n\r\n    function setMintCapacity(uint256 _amount)\r\n        public\r\n        onlySelf\r\n    {\r\n        _setMintCapacity(_amount);\r\n    }\r\n\r\n    function setMintPeriod(uint _duration)\r\n        public\r\n        onlySelf\r\n    {\r\n        _setMintPeriod(_duration);\r\n    }\r\n\r\n    function _mint(address _to, uint256 _amount)\r\n        internal\r\n    {\r\n        require(_to != address(0), \"ERC20: mint to the zero address\");\r\n        require(_to != address(this), \"ERC20: mint to token contract\");\r\n\r\n        _collectFee(_to);\r\n        if (now > mintPeriodStart + mintPeriod) {\r\n            amountMinted = 0;\r\n            mintPeriodStart = now;\r\n        }\r\n        amountMinted = amountMinted.add(_amount);\r\n        tokenTotalSupply = tokenTotalSupply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        if (balances[_to] > 0) holders.insert(_to);\r\n\r\n        emit Transfer(address(0), _to, _amount);\r\n        emit Mint(_to, _amount);\r\n    }\r\n\r\n    function _setMintCapacity(uint256 _amount)\r\n        internal\r\n    {\r\n        mintCapacity = _amount;\r\n        emit MintCapacity(_amount);\r\n    }\r\n\r\n    function _setMintPeriod(uint _duration)\r\n        internal\r\n    {\r\n        require(_duration < (1 << 64),\r\n                \"ERC20: mint period must be less than 2^64 seconds\");\r\n        mintPeriod = _duration;\r\n        emit MintPeriod(_duration);\r\n    }\r\n\r\n    function isUnderMintLimit(uint256 _amount)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint256 effAmountMinted = (now > mintPeriodStart + mintPeriod) ? 0 : amountMinted;\r\n        if (effAmountMinted + _amount > mintCapacity\r\n            || effAmountMinted + _amount < amountMinted) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function remainingMintCapacity()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (now > mintPeriodStart + mintPeriod)\r\n            return mintCapacity;\r\n        if (mintCapacity < amountMinted)\r\n            return 0;\r\n        return mintCapacity - amountMinted;\r\n    }\r\n}\r\n\r\ncontract XBullionToken is XBullionTokenConfig, ERC20Burnable, ERC20Mintable {\r\n    constructor()\r\n        MultiOwned(\r\n            makeAddressSingleton(msg.sender),\r\n            1)\r\n        ERC20(\r\n            TOKEN_NAME,\r\n            TOKEN_SYMBOL,\r\n            TOKEN_DECIMALS,\r\n            TOKEN_INITIALSUPPLY)\r\n        ERC20WithFees(\r\n            initialFeeTiers(),\r\n            initialTxFee())\r\n        ERC20Mintable(\r\n            TOKEN_MINTCAPACITY,\r\n            TOKEN_MINTPERIOD)\r\n        public\r\n    {}\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"BurnerAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"BurnerRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"Execution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"ExecutionFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ManagementFeeCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ManagerAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ManagerRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MintCapacity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"MintPeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"MinterAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"MinterRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"OwnerAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"OwnerRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"Requirement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"Revocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"Submission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferFeeCollected\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_OWNER_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addBurner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burnAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"burnAllFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"collectAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collectAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transactionId\",\"type\":\"bytes32\"}],\"name\":\"confirmTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_delta\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transactionId\",\"type\":\"bytes32\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBurners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transactionId\",\"type\":\"bytes32\"}],\"name\":\"getConfirmationCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transactionId\",\"type\":\"bytes32\"}],\"name\":\"getConfirmations\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_confirmations\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getManagers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMinters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"holderCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_delta\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isBurner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transactionId\",\"type\":\"bytes32\"}],\"name\":\"isConfirmed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"makeTransactionId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintCapacity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintPeriodStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numBurners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numManagers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numMinters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numOwners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingMintCapacity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removeBurner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removeMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"replaceOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"required\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transactionId\",\"type\":\"bytes32\"}],\"name\":\"revokeConfirmation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"internalType\":\"int128\",\"name\":\"fee\",\"type\":\"int128\"}],\"internalType\":\"struct ERC20WithFees.FeeTier[]\",\"name\":\"_feeTiers\",\"type\":\"tuple[]\"}],\"name\":\"setFeeTiers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setMintCapacity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"setMintPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_required\",\"type\":\"uint256\"}],\"name\":\"setRequirement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"int128\",\"name\":\"_txFee\",\"type\":\"int128\"}],\"name\":\"setTxFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"submitTransaction\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"transactions\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferAllFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"XBullionToken","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"","Library":"","LicenseType":"Unlicense","SwarmSource":"bzzr://78159ba27dc3e29bb5484af453ee7c4d7ca53bb878dddf3da493005d4aa08126"}]}