{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.26;\n\n\ncontract DSMath {\n    \n    /*\n    standard uint256 functions\n     */\n\n    function add(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        assert((z = x + y) >= x);\n    }\n\n    function sub(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        assert((z = x - y) <= x);\n    }\n\n    function mul(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        assert((z = x * y) >= x);\n    }\n    \n    function div(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        require(y > 0);\n        z = x / y;\n    }\n    \n    function min(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n    function max(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    /*\n    uint128 functions (h is for half)\n     */\n\n\n    function hadd(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        assert((z = x + y) >= x);\n    }\n\n    function hsub(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        assert((z = x - y) <= x);\n    }\n\n    function hmul(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        assert((z = x * y) >= x);\n    }\n\n    function hdiv(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        assert(y > 0);\n        z = x / y;\n    }\n\n    function hmin(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        return x <= y ? x : y;\n    }\n    function hmax(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        return x >= y ? x : y;\n    }\n\n\n    /*\n    int256 functions\n     */\n\n    function imin(int256 x, int256 y) pure internal returns (int256 z) {\n        return x <= y ? x : y;\n    }\n    function imax(int256 x, int256 y) pure internal returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    /*\n    WAD math\n     */\n\n    uint128 constant WAD = 10 ** 18;\n\n    function wadd(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function wsub(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function wmul(uint128 x, uint128 y) view internal returns (uint128 z) {\n        z = cast((uint256(x) * y + WAD / 2) / WAD);\n    }\n\n    function wdiv(uint128 x, uint128 y) view internal returns (uint128 z) {\n        z = cast((uint256(x) * WAD + y / 2) / y);\n    }\n\n    function wmin(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hmin(x, y);\n    }\n    function wmax(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hmax(x, y);\n    }\n\n    /*\n    RAY math\n     */\n\n    uint128 constant RAY = 10 ** 27;\n\n    function radd(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function rsub(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function rmul(uint128 x, uint128 y) view internal returns (uint128 z) {\n        z = cast((uint256(x) * y + RAY / 2) / RAY);\n    }\n\n    function rdiv(uint128 x, uint128 y) view internal returns (uint128 z) {\n        z = cast((uint256(x) * RAY + y / 2) / y);\n    }\n\n    function rpow(uint128 x, uint64 n) view internal returns (uint128 z) {\n        // This famous algorithm is called \"exponentiation by squaring\"\n        // and calculates x^n with x as fixed-point and n as regular unsigned.\n        //\n        // It's O(log n), instead of O(n) for naive repeated multiplication.\n        //\n        // These facts are why it works:\n        //\n        //  If n is even, then x^n = (x^2)^(n/2).\n        //  If n is odd,  then x^n = x * x^(n-1),\n        //   and applying the equation for even x gives\n        //    x^n = x * (x^2)^((n-1) / 2).\n        //\n        //  Also, EVM division is flooring and\n        //    floor[(n-1) / 2] = floor[n / 2].\n\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n\n    function rmin(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hmin(x, y);\n    }\n    function rmax(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hmax(x, y);\n    }\n\n    function cast(uint256 x) pure internal returns (uint128 z) {\n        assert((z = uint128(x)) == x);\n    }\n\n}\n\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract WETH is ERC20 {\n    function deposit() public payable;\n    function withdraw(uint wad) public;\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n}\n\ninterface UniswapExchangeInterface {\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\n}\n\ninterface OracleInterface {\n  function bill() external view returns (uint256);\n  function update(uint128 payment_, address token_) external;\n  function peek() external view returns (bytes32,bool);\n  function read() external view returns (bytes32);\n  function expiry() external view returns (uint32);\n  function timeout() external view returns (uint32);\n}\n\ninterface MedianizerInterface {\n    function oracles(uint256) public view returns (address);\n    function peek() public view returns (bytes32, bool);\n    function read() public returns (bytes32);\n    function poke() public;\n    function poke(bytes32) public;\n    function fund (uint256 amount, ERC20 token) public;\n}\n\ncontract FundOracles is DSMath {\n  ERC20 link;\n  WETH weth;\n  UniswapExchangeInterface uniswapExchange;\n\n  MedianizerInterface med;\n\n  /**\n    * @notice Construct a new Fund Oracles contract\n    * @param med_ The address of the Medianizer\n    * @param link_ The LINK token address\n    * @param weth_ The WETH token address\n    * @param uniswapExchange_ The address of the LINK to ETH Uniswap Exchange\n    */\n  constructor(MedianizerInterface med_, ERC20 link_, WETH weth_, UniswapExchangeInterface uniswapExchange_) public {\n    med = med_;\n    link = link_;\n    weth = weth_;\n    uniswapExchange = uniswapExchange_;\n  }\n\n  /**\n    * @notice Determines the last oracle token payment\n    * @param oracle_ Index of oracle\n    * @return Last payment to oracle in token (LINK for Chainlink, WETH for Oraclize)\n    */\n  function billWithEth(uint256 oracle_) public view returns (uint256) {\n      return OracleInterface(med.oracles(oracle_)).bill();\n  }\n\n  /**\n    * @notice Determines the payment amount in ETH\n    * @param oracle_ Index of oracle\n    * @param payment_ Payment amount in tokens (LINK or WETH)\n    * @return Amount of ETH to pay in updateWithEth to update Oracle\n    */\n  function paymentWithEth(uint256 oracle_, uint128 payment_) public view returns(uint256) {\n      if (oracle_ < 5) {\n          return uniswapExchange.getEthToTokenOutputPrice(payment_);\n      } else {\n          return uint(payment_);\n      }\n  }\n\n  /**\n    * @notice Update the Oracle using ETH\n    * @param oracle_ Index of oracle\n    * @param payment_ Payment amount in tokens (LINK or WETH)\n    * @param token_ Address of token to receive as a reward for updating Oracle\n    */\n  function updateWithEth(uint256 oracle_, uint128 payment_, address token_) public payable {\n    address oracleAddress = med.oracles(oracle_);\n    OracleInterface oracle = OracleInterface(oracleAddress);\n    if (oracle_ < 5) {\n      // ChainLink Oracle\n      uint256 ethPayment = uniswapExchange.getEthToTokenOutputPrice(payment_);\n      require(msg.value >= ethPayment, \"Insufficient ETH for LINK conversion for payment\");\n      link.approve(address(uniswapExchange), uint(payment_));\n      uniswapExchange.ethToTokenSwapOutput.value(ethPayment)(uint(payment_), now + 300);\n      link.approve(oracleAddress, uint(payment_));\n      oracle.update(payment_, token_);\n      msg.sender.transfer(msg.value - ethPayment);\n    } else {\n      // Oraclize Oracle\n      weth.deposit.value(msg.value)();\n      weth.approve(oracleAddress, uint(payment_));\n      oracle.update(payment_, token_);\n    }\n  }\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"oracle_\",\"type\":\"uint256\"},{\"name\":\"payment_\",\"type\":\"uint128\"},{\"name\":\"token_\",\"type\":\"address\"}],\"name\":\"updateWithEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"oracle_\",\"type\":\"uint256\"}],\"name\":\"billWithEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"oracle_\",\"type\":\"uint256\"},{\"name\":\"payment_\",\"type\":\"uint128\"}],\"name\":\"paymentWithEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"med_\",\"type\":\"address\"},{\"name\":\"link_\",\"type\":\"address\"},{\"name\":\"weth_\",\"type\":\"address\"},{\"name\":\"uniswapExchange_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"FundOracles","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000bc32048d9be3a3c3b626c44d296cefaaa400c797000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000f173214c720f58e03e194085b1db28b50acdeead","Library":"","LicenseType":"","SwarmSource":""}]}