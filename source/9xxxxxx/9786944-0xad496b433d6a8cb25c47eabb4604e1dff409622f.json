{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/upgrades/contracts/Initializable.sol\r\n\r\npragma solidity >=0.4.24 <0.7.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context is Initializable {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Initializable, Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function initialize(address sender) public initializer {\r\n        _owner = sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: hardlydifficult-ethereum-contracts/contracts/proxies/Clone2Factory.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n// From https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.sol\r\n// Updated to support Solidity 5, switch to `create2` and revert on fail\r\nlibrary Clone2Factory\r\n{\r\n  /**\r\n   * @notice Uses create2 to deploy a clone to a pre-determined address.\r\n   * @param target the address of the template contract, containing the logic for this contract.\r\n   * @param salt a salt used to determine the contract address before the transaction is mined,\r\n   * may be random or sequential.\r\n   * @return proxyAddress the address of the newly deployed contract.\r\n   * @dev Using `bytes12` for the salt saves 6 gas over using `uint96` (requires another shift).\r\n   * Will revert on fail.\r\n   */\r\n  function _createClone2(\r\n    address target,\r\n    bytes12 salt\r\n  ) internal\r\n    returns (address proxyAddress)\r\n  {\r\n    // solium-disable-next-line\r\n    assembly\r\n    {\r\n      let pointer := mload(0x40)\r\n\r\n      // Create the bytecode for deployment based on the Minimal Proxy Standard (EIP-1167)\r\n      // bytecode: 0x0\r\n      mstore(pointer, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n      mstore(add(pointer, 0x14), shl(96, target))\r\n      mstore(add(pointer, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n\r\n      // `create2` consumes all available gas if called with a salt that's already been consumed\r\n      // we check if the address is available first so that doesn't happen\r\n      // Costs ~958 gas\r\n\r\n      // Calculate the hash\r\n      let contractCodeHash := keccak256(pointer, 0x37)\r\n\r\n      // salt: 0x100\r\n      // The salt to use with the create2 call is `msg.sender+salt`\r\n      // this prevents at attacker from front-running another user's deployment\r\n      mstore(add(pointer, 0x100), shl(96, caller))\r\n      mstore(add(pointer, 0x114), salt)\r\n\r\n      // addressSeed: 0x40\r\n      // 0xff\r\n      mstore(add(pointer, 0x40), 0xff00000000000000000000000000000000000000000000000000000000000000)\r\n      // this\r\n      mstore(add(pointer, 0x41), shl(96, address))\r\n      // salt\r\n      mstore(add(pointer, 0x55), mload(add(pointer, 0x100)))\r\n      // hash\r\n      mstore(add(pointer, 0x75), contractCodeHash)\r\n\r\n      proxyAddress := keccak256(add(pointer, 0x40), 0x55)\r\n\r\n      switch extcodesize(proxyAddress)\r\n      case 0 {\r\n        // Deploy the contract, returning the address or 0 on fail\r\n        proxyAddress := create2(0, pointer, 0x37, mload(add(pointer, 0x100)))\r\n      }\r\n      default {\r\n        proxyAddress := 0\r\n      }\r\n    }\r\n\r\n    // Revert if the deployment fails (possible if salt was already used)\r\n    require(proxyAddress != address(0), 'PROXY_DEPLOY_FAILED');\r\n  }\r\n}\r\n\r\n// File: hardlydifficult-ethereum-contracts/contracts/interfaces/IUniswapExchange.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n// Source: https://github.com/Uniswap/contracts-vyper/blob/master/contracts/uniswap_exchange.vy\r\n// The fallback function is payable and calls `ethToTokenInput`\r\ninterface IUniswapExchange\r\n{\r\n  // Events\r\n  event AddLiquidity(address indexed provider, uint indexed eth_amount, uint indexed token_amount);\r\n  event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n  event EthPurchase(address indexed buyer, uint indexed tokens_sold, uint eth_bought);\r\n  event RemoveLiquidity(address indexed provider, uint indexed eth_amount, uint indexed token_amount);\r\n  event TokenPurchase(address indexed buyer, uint indexed eth_sold, uint indexed tokens_bought);\r\n  event Transfer(address indexed _from, address indexed _to, uint _value);\r\n\r\n  // Read-only\r\n  function allowance(address _owner, address _spender) external view returns(uint);\r\n  function balanceOf(address _owner) external view returns(uint);\r\n  function decimals() external view returns(uint);\r\n  function factoryAddress() external view returns(address);\r\n  function getEthToTokenInputPrice(uint eth_sold) external view returns(uint);\r\n  function getEthToTokenOutputPrice(uint tokens_bought) external view returns(uint);\r\n  function getTokenToEthInputPrice(uint tokens_sold) external view returns(uint);\r\n  function getTokenToEthOutputPrice(uint eth_bought) external view returns(uint);\r\n  function name() external view returns (bytes32);\r\n  function symbol() external view returns (bytes32);\r\n  function tokenAddress() external view returns(address);\r\n  function totalSupply() external view returns(uint);\r\n\r\n  // Transactions\r\n  function setup(\r\n    address token_addr\r\n  ) external;\r\n  function addLiquidity(\r\n    uint min_liquidity, uint max_tokens, uint deadline\r\n  ) external payable returns (uint);\r\n  function removeLiquidity(\r\n    uint amount, uint min_eth, uint min_tokens, uint deadline\r\n  ) external returns (uint, uint);\r\n  function ethToTokenSwapInput(\r\n    uint min_tokens, uint deadline\r\n  ) external payable returns (uint);\r\n  function ethToTokenTransferInput(\r\n    uint min_tokens, uint deadline, address recipient\r\n  ) external payable returns(uint);\r\n  function ethToTokenSwapOutput(\r\n    uint tokens_bought, uint deadline\r\n  ) external payable returns(uint);\r\n  function ethToTokenTransferOutput(\r\n    uint tokens_bought, uint deadline, address recipient\r\n  ) external payable returns(uint);\r\n  function tokenToEthSwapInput(\r\n    uint tokens_sold, uint min_eth, uint deadline\r\n  ) external returns(uint);\r\n  function tokenToEthTransferInput(\r\n    uint tokens_sold, uint min_eth, uint deadline, address recipient\r\n  ) external returns(uint);\r\n  function tokenToEthSwapOutput(\r\n    uint eth_bought, uint max_tokens, uint deadline\r\n  ) external returns(uint);\r\n  function tokenToEthTransferOutput(\r\n    uint eth_bought, uint max_tokens, uint deadline, address recipient\r\n  ) external returns(uint);\r\n  function tokenToTokenSwapInput(\r\n    uint tokens_sold, uint min_tokens_bought, uint min_eth_bought, uint deadline, address token_addr\r\n  ) external returns(uint);\r\n  function tokenToTokenTransferInput(\r\n    uint tokens_sold, uint min_tokens_bought, uint min_eth_bought, uint deadline, address recipient, address token_addr\r\n  ) external returns(uint);\r\n  function tokenToTokenSwapOutput(\r\n    uint tokens_bought, uint max_tokens_sold, uint max_eth_sold, uint deadline, address token_addr\r\n  ) external returns(uint);\r\n  function tokenToTokenTransferOutput(\r\n    uint tokens_bought, uint max_tokens_sold, uint max_eth_sold, uint deadline, address recipient, address token_addr\r\n  ) external returns(uint);\r\n  function tokenToExchangeSwapInput(\r\n    uint tokens_sold, uint min_tokens_bought, uint min_eth_bought, uint deadline, address exchange_addr\r\n  ) external returns(uint);\r\n  function tokenToExchangeTransferInput(\r\n    uint tokens_sold, uint min_tokens_bought, uint min_eth_bought, uint deadline, address recipient, address exchange_addr\r\n  ) external returns(uint);\r\n  function tokenToExchangeSwapOutput(\r\n    uint tokens_bought, uint max_tokens_sold, uint max_eth_sold, uint deadline, address exchange_addr\r\n  ) external returns(uint);\r\n  function tokenToExchangeTransferOutput(\r\n    uint tokens_bought, uint max_tokens_sold, uint max_eth_sold, uint deadline, address recipient, address exchange_addr\r\n  ) external returns(uint);\r\n  function transfer(\r\n    address _to, uint _value\r\n  ) external returns(bool);\r\n  function transferFrom(\r\n    address _from, address _to, uint _value\r\n  ) external returns(bool);\r\n  function approve(\r\n    address _spender, uint _value\r\n  ) external returns(bool);\r\n}\r\n\r\n// File: contracts/interfaces/IPublicLock.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n/**\r\n* @title The PublicLock Interface\r\n* @author Nick Furfaro (unlock-protocol.com)\r\n */\r\n\r\n\r\ncontract IPublicLock\r\n{\r\n\r\n// See indentationissue description here:\r\n// https://github.com/duaraghav8/Ethlint/issues/268\r\n// solium-disable indentation\r\n\r\n  /// Functions\r\n\r\n  function initialize(\r\n    address _lockCreator,\r\n    uint _expirationDuration,\r\n    address _tokenAddress,\r\n    uint _keyPrice,\r\n    uint _maxNumberOfKeys,\r\n    string calldata _lockName\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Allow the contract to accept tips in ETH sent directly to the contract.\r\n   * @dev This is okay to use even if the lock is priced in ERC-20 tokens\r\n   */\r\n  function() external payable;\r\n\r\n  /**\r\n   * @dev Never used directly\r\n   */\r\n  function initialize() external;\r\n\r\n  /**\r\n  * @notice The version number of the current implementation on this network.\r\n  * @return The current version number.\r\n  */\r\n  function publicLockVersion() public pure returns (uint);\r\n\r\n  /**\r\n  * @notice Gets the current balance of the account provided.\r\n  * @param _tokenAddress The token type to retrieve the balance of.\r\n  * @param _account The account to get the balance of.\r\n  * @return The number of tokens of the given type for the given address, possibly 0.\r\n  */\r\n  function getBalance(\r\n    address _tokenAddress,\r\n    address _account\r\n  ) external view\r\n    returns (uint);\r\n\r\n  /**\r\n  * @notice Used to disable lock before migrating keys and/or destroying contract.\r\n  * @dev Throws if called by other than a lock manager.\r\n  * @dev Throws if lock contract has already been disabled.\r\n  */\r\n  function disableLock() external;\r\n\r\n  /**\r\n   * @dev Called by a lock manager or beneficiary to withdraw all funds from the lock and send them to the `beneficiary`.\r\n   * @dev Throws if called by other than a lock manager or beneficiary\r\n   * @param _tokenAddress specifies the token address to withdraw or 0 for ETH. This is usually\r\n   * the same as `tokenAddress` in MixinFunds.\r\n   * @param _amount specifies the max amount to withdraw, which may be reduced when\r\n   * considering the available balance. Set to 0 or MAX_UINT to withdraw everything.\r\n   *  -- however be wary of draining funds as it breaks the `cancelAndRefund` and `expireAndRefundFor`\r\n   * use cases.\r\n   */\r\n  function withdraw(\r\n    address _tokenAddress,\r\n    uint _amount\r\n  ) external;\r\n\r\n  /**\r\n   * A function which lets a Lock manager of the lock to change the price for future purchases.\r\n   * @dev Throws if called by other than a Lock manager\r\n   * @dev Throws if lock has been disabled\r\n   * @dev Throws if _tokenAddress is not a valid token\r\n   * @param _keyPrice The new price to set for keys\r\n   * @param _tokenAddress The address of the erc20 token to use for pricing the keys,\r\n   * or 0 to use ETH\r\n   */\r\n  function updateKeyPricing( uint _keyPrice, address _tokenAddress ) external;\r\n\r\n  /**\r\n   * A function which lets a Lock manager update the beneficiary account,\r\n   * which receives funds on withdrawal.\r\n   * @dev Throws if called by other than a Lock manager or beneficiary\r\n   * @dev Throws if _beneficiary is address(0)\r\n   * @param _beneficiary The new address to set as the beneficiary\r\n   */\r\n  function updateBeneficiary( address _beneficiary ) external;\r\n\r\n    /**\r\n   * Checks if the user has a non-expired key.\r\n   * @param _user The address of the key owner\r\n   */\r\n  function getHasValidKey(\r\n    address _user\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @notice Find the tokenId for a given user\r\n   * @return The tokenId of the NFT, else returns 0\r\n   * @param _account The address of the key owner\r\n  */\r\n  function getTokenIdFor(\r\n    address _account\r\n  ) external view returns (uint);\r\n\r\n  /**\r\n  * A function which returns a subset of the keys for this Lock as an array\r\n  * @param _page the page of key owners requested when faceted by page size\r\n  * @param _pageSize the number of Key Owners requested per page\r\n  * @dev Throws if there are no key owners yet\r\n  */\r\n  function getOwnersByPage(\r\n    uint _page,\r\n    uint _pageSize\r\n  ) external view returns (address[] memory);\r\n\r\n  /**\r\n   * Checks if the given address owns the given tokenId.\r\n   * @param _tokenId The tokenId of the key to check\r\n   * @param _keyOwner The potential key owners address\r\n   */\r\n  function isKeyOwner(\r\n    uint _tokenId,\r\n    address _keyOwner\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n  * @dev Returns the key's ExpirationTimestamp field for a given owner.\r\n  * @param _keyOwner address of the user for whom we search the key\r\n  * @dev Returns 0 if the owner has never owned a key for this lock\r\n  */\r\n  function keyExpirationTimestampFor(\r\n    address _keyOwner\r\n  ) external view returns (uint timestamp);\r\n\r\n  /**\r\n   * Public function which returns the total number of unique owners (both expired\r\n   * and valid).  This may be larger than totalSupply.\r\n   */\r\n  function numberOfOwners() external view returns (uint);\r\n\r\n  /**\r\n   * Allows a Lock manager to assign a descriptive name for this Lock.\r\n   * @param _lockName The new name for the lock\r\n   * @dev Throws if called by other than a Lock manager\r\n   */\r\n  function updateLockName(\r\n    string calldata _lockName\r\n  ) external;\r\n\r\n  /**\r\n   * Allows a Lock manager to assign a Symbol for this Lock.\r\n   * @param _lockSymbol The new Symbol for the lock\r\n   * @dev Throws if called by other than a Lock manager\r\n   */\r\n  function updateLockSymbol(\r\n    string calldata _lockSymbol\r\n  ) external;\r\n\r\n  /**\r\n    * @dev Gets the token symbol\r\n    * @return string representing the token symbol\r\n    */\r\n  function symbol()\r\n    external view\r\n    returns(string memory);\r\n\r\n    /**\r\n   * Allows a Lock manager to update the baseTokenURI for this Lock.\r\n   * @dev Throws if called by other than a Lock manager\r\n   * @param _baseTokenURI String representing the base of the URI for this lock.\r\n   */\r\n  function setBaseTokenURI(\r\n    string calldata _baseTokenURI\r\n  ) external;\r\n\r\n  /**  @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n   * @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n   *  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n   *  Metadata JSON Schema\".\r\n   * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n   * @param _tokenId The tokenID we're inquiring about\r\n   * @return String representing the URI for the requested token\r\n   */\r\n  function tokenURI(\r\n    uint256 _tokenId\r\n  ) external view returns(string memory);\r\n\r\n  /**\r\n   * @notice Allows a Lock manager to add or remove an event hook\r\n   */\r\n  function setEventHooks(\r\n    address _onKeyPurchaseHook,\r\n    address _onKeyCancelHook\r\n  ) external;\r\n\r\n  /**\r\n   * Allows a Lock manager to give a collection of users a key with no charge.\r\n   * Each key may be assigned a different expiration date.\r\n   * @dev Throws if called by other than a Lock manager\r\n   * @param _recipients An array of receiving addresses\r\n   * @param _expirationTimestamps An array of expiration Timestamps for the keys being granted\r\n   */\r\n  function grantKeys(\r\n    address[] calldata _recipients,\r\n    uint[] calldata _expirationTimestamps,\r\n    address[] calldata _keyManagers\r\n  ) external;\r\n\r\n  /**\r\n  * @dev Purchase function\r\n  * @param _value the number of tokens to pay for this purchase >= the current keyPrice - any applicable discount\r\n  * (_value is ignored when using ETH)\r\n  * @param _recipient address of the recipient of the purchased key\r\n  * @param _referrer address of the user making the referral\r\n  * @param _data arbitrary data populated by the front-end which initiated the sale\r\n  * @dev Throws if lock is disabled. Throws if lock is sold-out. Throws if _recipient == address(0).\r\n  * @dev Setting _value to keyPrice exactly doubles as a security feature. That way if a Lock manager increases the\r\n  * price while my transaction is pending I can't be charged more than I expected (only applicable to ERC-20 when more\r\n  * than keyPrice is approved for spending).\r\n  */\r\n  function purchase(\r\n    uint256 _value,\r\n    address _recipient,\r\n    address _referrer,\r\n    bytes calldata _data\r\n  ) external payable;\r\n\r\n  /**\r\n   * @notice returns the minimum price paid for a purchase with these params.\r\n   * @dev this considers any discount from Unlock or the OnKeyPurchase hook.\r\n   */\r\n  function purchasePriceFor(\r\n    address _recipient,\r\n    address _referrer,\r\n    bytes calldata _data\r\n  ) external view\r\n    returns (uint);\r\n\r\n  /**\r\n   * Allow a Lock manager to change the transfer fee.\r\n   * @dev Throws if called by other than a Lock manager\r\n   * @param _transferFeeBasisPoints The new transfer fee in basis-points(bps).\r\n   * Ex: 200 bps = 2%\r\n   */\r\n  function updateTransferFee(\r\n    uint _transferFeeBasisPoints\r\n  ) external;\r\n\r\n  /**\r\n   * Determines how much of a fee a key owner would need to pay in order to\r\n   * transfer the key to another account.  This is pro-rated so the fee goes down\r\n   * overtime.\r\n   * @dev Throws if _keyOwner does not have a valid key\r\n   * @param _keyOwner The owner of the key check the transfer fee for.\r\n   * @param _time The amount of time to calculate the fee for.\r\n   * @return The transfer fee in seconds.\r\n   */\r\n  function getTransferFee(\r\n    address _keyOwner,\r\n    uint _time\r\n  ) external view returns (uint);\r\n\r\n  /**\r\n   * @dev Invoked by a Lock manager to expire the user's key and perform a refund and cancellation of the key\r\n   * @param _keyOwner The key owner to whom we wish to send a refund to\r\n   * @param amount The amount to refund the key-owner\r\n   * @dev Throws if called by other than a Lock manager\r\n   * @dev Throws if _keyOwner does not have a valid key\r\n   */\r\n  function expireAndRefundFor(\r\n    address _keyOwner,\r\n    uint amount\r\n  ) external;\r\n\r\n   /**\r\n   * @dev allows the key manager to expire a given tokenId\r\n   * and send a refund to the keyOwner based on the amount of time remaining.\r\n   * @param _tokenId The id of the key to cancel.\r\n   */\r\n  function cancelAndRefund(uint _tokenId) external;\r\n\r\n  /**\r\n   * @dev Cancels a key managed by a different user and sends the funds to the keyOwner.\r\n   * @param _keyManager the key managed by this user will be canceled\r\n   * @param _v _r _s getCancelAndRefundApprovalHash signed by the _keyManager\r\n   * @param _tokenId The key to cancel\r\n   */\r\n  function cancelAndRefundFor(\r\n    address _keyManager,\r\n    uint8 _v,\r\n    bytes32 _r,\r\n    bytes32 _s,\r\n    uint _tokenId\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Sets the minimum nonce for a valid off-chain approval message from the\r\n   * senders account.\r\n   * @dev This can be used to invalidate a previously signed message.\r\n   */\r\n  function invalidateOffchainApproval(\r\n    uint _nextAvailableNonce\r\n  ) external;\r\n\r\n  /**\r\n   * Allow a Lock manager to change the refund penalty.\r\n   * @dev Throws if called by other than a Lock manager\r\n   * @param _freeTrialLength The new duration of free trials for this lock\r\n   * @param _refundPenaltyBasisPoints The new refund penaly in basis-points(bps)\r\n   */\r\n  function updateRefundPenalty(\r\n    uint _freeTrialLength,\r\n    uint _refundPenaltyBasisPoints\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Determines how much of a refund a key owner would receive if they issued\r\n   * @param _keyOwner The key owner to get the refund value for.\r\n   * a cancelAndRefund block.timestamp.\r\n   * Note that due to the time required to mine a tx, the actual refund amount will be lower\r\n   * than what the user reads from this call.\r\n   */\r\n  function getCancelAndRefundValueFor(\r\n    address _keyOwner\r\n  ) external view returns (uint refund);\r\n\r\n  function keyManagerToNonce(address ) external view returns (uint256 );\r\n\r\n  /**\r\n   * @notice returns the hash to sign in order to allow another user to cancel on your behalf.\r\n   * @dev this can be computed in JS instead of read from the contract.\r\n   * @param _keyManager The key manager's address (also the message signer)\r\n   * @param _txSender The address cancelling cancel on behalf of the keyOwner\r\n   * @return approvalHash The hash to sign\r\n   */\r\n  function getCancelAndRefundApprovalHash(\r\n    address _keyManager,\r\n    address _txSender\r\n  ) external view returns (bytes32 approvalHash);\r\n\r\n  function addKeyGranter(address account) external;\r\n\r\n  function addLockManager(address account) external;\r\n\r\n  function isKeyGranter(address account) external view returns (bool);\r\n\r\n  function isLockManager(address account) external view returns (bool);\r\n\r\n  function onKeyPurchaseHook() external view returns(address);\r\n\r\n  function onKeyCancelHook() external view returns(address);\r\n\r\n  function revokeKeyGranter(address _granter) external;\r\n\r\n  function renounceLockManager() external;\r\n\r\n  ///===================================================================\r\n  /// Auto-generated getter functions from public state variables\r\n\r\n  function beneficiary() external view returns (address );\r\n\r\n  function expirationDuration() external view returns (uint256 );\r\n\r\n  function freeTrialLength() external view returns (uint256 );\r\n\r\n  function isAlive() external view returns (bool );\r\n\r\n  function keyPrice() external view returns (uint256 );\r\n\r\n  function maxNumberOfKeys() external view returns (uint256 );\r\n\r\n  function owners(uint256 ) external view returns (address );\r\n\r\n  function refundPenaltyBasisPoints() external view returns (uint256 );\r\n\r\n  function tokenAddress() external view returns (address );\r\n\r\n  function transferFeeBasisPoints() external view returns (uint256 );\r\n\r\n  function unlockProtocol() external view returns (address );\r\n\r\n  function keyManagerOf(uint) external view returns (address );\r\n\r\n  ///===================================================================\r\n\r\n  /**\r\n  * @notice Allows the key owner to safely share their key (parent key) by\r\n  * transferring a portion of the remaining time to a new key (child key).\r\n  * @dev Throws if key is not valid.\r\n  * @dev Throws if `_to` is the zero address\r\n  * @param _to The recipient of the shared key\r\n  * @param _tokenId the key to share\r\n  * @param _timeShared The amount of time shared\r\n  * checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n  * `onERC721Received` on `_to` and throws if the return value is not\r\n  * `bytes4(keccak256('onERC721Received(address,address,uint,bytes)'))`.\r\n  * @dev Emit Transfer event\r\n  */\r\n  function shareKey(\r\n    address _to,\r\n    uint _tokenId,\r\n    uint _timeShared\r\n  ) external;\r\n\r\n  /**\r\n  * @notice Update transfer and cancel rights for a given key\r\n  * @param _tokenId The id of the key to assign rights for\r\n  * @param _keyManager The address to assign the rights to for the given key\r\n  */\r\n  function setKeyManagerOf(\r\n    uint _tokenId,\r\n    address _keyManager\r\n  ) external;\r\n\r\n  /// @notice A descriptive name for a collection of NFTs in this contract\r\n  function name() external view returns (string memory _name);\r\n  ///===================================================================\r\n\r\n  /// From ERC165.sol\r\n  function supportsInterface(bytes4 interfaceId) external view returns (bool );\r\n  ///===================================================================\r\n\r\n  /// From ERC-721\r\n  /**\r\n     * @dev Returns the number of NFTs in `owner`'s account.\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the NFT specified by `tokenId`.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address _owner);\r\n\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     *\r\n     *\r\n     * Requirements:\r\n     * - `from`, `to` cannot be zero.\r\n     * - `tokenId` must be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this\r\n     * NFT by either {approve} or {setApprovalForAll}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Requirements:\r\n     * - If the caller is not `from`, it must be approved to move this NFT by\r\n     * either {approve} or {setApprovalForAll}.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function approve(address to, uint256 tokenId) public;\r\n\r\n    /**\r\n    * @notice Get the approved address for a single NFT\r\n    * @dev Throws if `_tokenId` is not a valid NFT.\r\n    * @param _tokenId The NFT to find the approved address for\r\n    * @return The approved address for this NFT, or the zero address if there is none\r\n    */\r\n    function getApproved(uint256 _tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address _owner, address operator) public view returns (bool);\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n\r\n    function totalSupply() public view returns (uint256);\r\n    function tokenOfOwnerByIndex(address _owner, uint256 index) public view returns (uint256 tokenId);\r\n\r\n    function tokenByIndex(uint256 index) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/interfaces/IUnlock.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n/**\r\n * @title The Unlock Interface\r\n * @author Nick Furfaro (unlock-protocol.com)\r\n**/\r\n\r\ninterface IUnlock\r\n{\r\n  // Use initialize instead of a constructor to support proxies(for upgradeability via zos).\r\n  function initialize(address _unlockOwner) external;\r\n\r\n  /**\r\n  * @dev Create lock\r\n  * This deploys a lock for a creator. It also keeps track of the deployed lock.\r\n  * @param _tokenAddress set to the ERC20 token address, or 0 for ETH.\r\n  * @param _salt an identifier for the Lock, which is unique for the user.\r\n  * This may be implemented as a sequence ID or with RNG. It's used with `create2`\r\n  * to know the lock's address before the transaction is mined.\r\n  */\r\n  function createLock(\r\n    uint _expirationDuration,\r\n    address _tokenAddress,\r\n    uint _keyPrice,\r\n    uint _maxNumberOfKeys,\r\n    string calldata _lockName,\r\n    bytes12 _salt\r\n  ) external;\r\n\r\n    /**\r\n   * This function keeps track of the added GDP, as well as grants of discount tokens\r\n   * to the referrer, if applicable.\r\n   * The number of discount tokens granted is based on the value of the referal,\r\n   * the current growth rate and the lock's discount token distribution rate\r\n   * This function is invoked by a previously deployed lock only.\r\n   */\r\n  function recordKeyPurchase(\r\n    uint _value,\r\n    address _referrer // solhint-disable-line no-unused-vars\r\n  )\r\n    external;\r\n\r\n    /**\r\n   * This function will keep track of consumed discounts by a given user.\r\n   * It will also grant discount tokens to the creator who is granting the discount based on the\r\n   * amount of discount and compensation rate.\r\n   * This function is invoked by a previously deployed lock only.\r\n   */\r\n  function recordConsumedDiscount(\r\n    uint _discount,\r\n    uint _tokens // solhint-disable-line no-unused-vars\r\n  )\r\n    external;\r\n\r\n    /**\r\n   * This function returns the discount available for a user, when purchasing a\r\n   * a key from a lock.\r\n   * This does not modify the state. It returns both the discount and the number of tokens\r\n   * consumed to grant that discount.\r\n   */\r\n  function computeAvailableDiscountFor(\r\n    address _purchaser, // solhint-disable-line no-unused-vars\r\n    uint _keyPrice // solhint-disable-line no-unused-vars\r\n  )\r\n    external\r\n    view\r\n    returns(uint discount, uint tokens);\r\n\r\n  // Function to read the globalTokenURI field.\r\n  function globalBaseTokenURI()\r\n    external\r\n    view\r\n    returns(string memory);\r\n\r\n  /**\r\n   * @dev Redundant with globalBaseTokenURI() for backwards compatibility with v3 & v4 locks.\r\n   */\r\n  function getGlobalBaseTokenURI()\r\n    external\r\n    view\r\n    returns (string memory);\r\n\r\n  // Function to read the globalTokenSymbol field.\r\n  function globalTokenSymbol()\r\n    external\r\n    view\r\n    returns(string memory);\r\n\r\n  /**\r\n   * @dev Redundant with globalTokenSymbol() for backwards compatibility with v3 & v4 locks.\r\n   */\r\n  function getGlobalTokenSymbol()\r\n    external\r\n    view\r\n    returns (string memory);\r\n\r\n  /** Function for the owner to update configuration variables.\r\n   *  Should throw if called by other than owner.\r\n   */\r\n  function configUnlock(\r\n    string calldata _symbol,\r\n    string calldata _URI\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @notice Upgrade the PublicLock template used for future calls to `createLock`.\r\n   * @dev This will initialize the template and revokeOwnership.\r\n   */\r\n  function setLockTemplate(\r\n    address payable _publicLockAddress\r\n  ) external;\r\n\r\n  // Allows the owner to change the value tracking variables as needed.\r\n  function resetTrackedValue(\r\n    uint _grossNetworkProduct,\r\n    uint _totalDiscountGranted\r\n  ) external;\r\n\r\n  function grossNetworkProduct() external view returns(uint);\r\n\r\n  function totalDiscountGranted() external view returns(uint);\r\n\r\n  function locks(address) external view returns(bool deployed, uint totalSales, uint yieldedDiscountTokens);\r\n\r\n  // The address of the public lock template, used when `createLock` is called\r\n  function publicLockAddress() external view returns(address);\r\n\r\n  // Map token address to exchange contract address if the token is supported\r\n  // Used for GDP calculations\r\n  function uniswapExchanges(address) external view returns(address);\r\n\r\n  // The version number of the current Unlock implementation on this network\r\n  function unlockVersion() external pure returns(uint16);\r\n\r\n  // allows the owner to set the exchange address to use for value conversions\r\n  // setting the _exchangeAddress to address(0) removes support for the token\r\n  function setExchange(\r\n    address _tokenAddress,\r\n    address _exchangeAddress\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Returns true if the caller is the current owner.\r\n   */\r\n  function isOwner() external view returns(bool);\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() external view returns(address);\r\n\r\n  /**\r\n   * @dev Leaves the contract without owner. It will not be possible to call\r\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n   *\r\n   * NOTE: Renouncing ownership will leave the contract without an owner,\r\n   * thereby removing any functionality that is only available to the owner.\r\n   */\r\n  function renounceOwnership() external;\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// File: contracts/Unlock.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n/**\r\n * @title The Unlock contract\r\n * @author Julien Genestoux (unlock-protocol.com)\r\n * This smart contract has 3 main roles:\r\n *  1. Distribute discounts to discount token holders\r\n *  2. Grant dicount tokens to users making referrals and/or publishers granting discounts.\r\n *  3. Create & deploy Public Lock contracts.\r\n * In order to achieve these 3 elements, it keeps track of several things such as\r\n *  a. Deployed locks addresses and balances of discount tokens granted by each lock.\r\n *  b. The total network product (sum of all key sales, net of discounts)\r\n *  c. Total of discounts granted\r\n *  d. Balances of discount tokens, including 'frozen' tokens (which have been used to claim\r\n * discounts and cannot be used/transferred for a given period)\r\n *  e. Growth rate of Network Product\r\n *  f. Growth rate of Discount tokens supply\r\n * The smart contract has an owner who only can perform the following\r\n *  - Upgrades\r\n *  - Change in golden rules (20% of GDP available in discounts, and supply growth rate is at most\r\n * 50% of GNP growth rate)\r\n * NOTE: This smart contract is partially implemented for now until enough Locks are deployed and\r\n * in the wild.\r\n * The partial implementation includes the following features:\r\n *  a. Keeping track of deployed locks\r\n *  b. Keeping track of GNP\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @dev Must list the direct base contracts in the order from “most base-like” to “most derived”.\r\n/// https://solidity.readthedocs.io/en/latest/contracts.html#multiple-inheritance-and-linearization\r\ncontract Unlock is\r\n  IUnlock,\r\n  Initializable,\r\n  Ownable\r\n{\r\n  using Address for address;\r\n  using Clone2Factory for address;\r\n\r\n  /**\r\n   * The struct for a lock\r\n   * We use deployed to keep track of deployments.\r\n   * This is required because both totalSales and yieldedDiscountTokens are 0 when initialized,\r\n   * which would be the same values when the lock is not set.\r\n   */\r\n  struct LockBalances\r\n  {\r\n    bool deployed;\r\n    uint totalSales; // This is in wei\r\n    uint yieldedDiscountTokens;\r\n  }\r\n\r\n  modifier onlyFromDeployedLock() {\r\n    require(locks[msg.sender].deployed, 'ONLY_LOCKS');\r\n    _;\r\n  }\r\n\r\n  uint public grossNetworkProduct;\r\n\r\n  uint public totalDiscountGranted;\r\n\r\n  // We keep track of deployed locks to ensure that callers are all deployed locks.\r\n  mapping (address => LockBalances) public locks;\r\n\r\n  // global base token URI\r\n  // Used by locks where the owner has not set a custom base URI.\r\n  string public globalBaseTokenURI;\r\n\r\n  // global base token symbol\r\n  // Used by locks where the owner has not set a custom symbol\r\n  string public globalTokenSymbol;\r\n\r\n  // The address of the public lock template, used when `createLock` is called\r\n  address public publicLockAddress;\r\n\r\n  // Map token address to exchange contract address if the token is supported\r\n  // Used for GDP calculations\r\n  mapping (address => IUniswapExchange) public uniswapExchanges;\r\n\r\n  // Events\r\n  event NewLock(\r\n    address indexed lockOwner,\r\n    address indexed newLockAddress\r\n  );\r\n\r\n  event ConfigUnlock(\r\n    string globalTokenSymbol,\r\n    string globalTokenURI\r\n  );\r\n\r\n  event SetLockTemplate(\r\n    address publicLockAddress\r\n  );\r\n\r\n  event ResetTrackedValue(\r\n    uint grossNetworkProduct,\r\n    uint totalDiscountGranted\r\n  );\r\n\r\n  // Use initialize instead of a constructor to support proxies (for upgradeability via zos).\r\n  function initialize(\r\n    address _unlockOwner\r\n  )\r\n    public\r\n    initializer()\r\n  {\r\n    // We must manually initialize Ownable.sol\r\n    Ownable.initialize(_unlockOwner);\r\n  }\r\n\r\n  /**\r\n  * @dev Create lock\r\n  * This deploys a lock for a creator. It also keeps track of the deployed lock.\r\n  * @param _tokenAddress set to the ERC20 token address, or 0 for ETH.\r\n  * @param _salt an identifier for the Lock, which is unique for the user.\r\n  * This may be implemented as a sequence ID or with RNG. It's used with `create2`\r\n  * to know the lock's address before the transaction is mined.\r\n  */\r\n  function createLock(\r\n    uint _expirationDuration,\r\n    address _tokenAddress,\r\n    uint _keyPrice,\r\n    uint _maxNumberOfKeys,\r\n    string memory _lockName,\r\n    bytes12 _salt\r\n  ) public\r\n  {\r\n    require(publicLockAddress != address(0), 'MISSING_LOCK_TEMPLATE');\r\n\r\n    // create lock\r\n    address payable newLock = address(uint160(publicLockAddress._createClone2(_salt)));\r\n    IPublicLock(newLock).initialize(\r\n      msg.sender,\r\n      _expirationDuration,\r\n      _tokenAddress,\r\n      _keyPrice,\r\n      _maxNumberOfKeys,\r\n      _lockName\r\n    );\r\n\r\n    // Assign the new Lock\r\n    locks[newLock] = LockBalances({\r\n      deployed: true, totalSales: 0, yieldedDiscountTokens: 0\r\n    });\r\n\r\n    // trigger event\r\n    emit NewLock(msg.sender, newLock);\r\n  }\r\n\r\n  /**\r\n   * This function returns the discount available for a user, when purchasing a\r\n   * a key from a lock.\r\n   * This does not modify the state. It returns both the discount and the number of tokens\r\n   * consumed to grant that discount.\r\n   * TODO: actually implement this.\r\n   */\r\n  function computeAvailableDiscountFor(\r\n    address /* _purchaser */,\r\n    uint /* _keyPrice */\r\n  )\r\n    public\r\n    view\r\n    returns (uint discount, uint tokens)\r\n  {\r\n    // TODO: implement me\r\n    return (0, 0);\r\n  }\r\n\r\n  /**\r\n   * This function keeps track of the added GDP, as well as grants of discount tokens\r\n   * to the referrer, if applicable.\r\n   * The number of discount tokens granted is based on the value of the referal,\r\n   * the current growth rate and the lock's discount token distribution rate\r\n   * This function is invoked by a previously deployed lock only.\r\n   * TODO: actually implement\r\n   */\r\n  function recordKeyPurchase(\r\n    uint _value,\r\n    address /* _referrer */\r\n  )\r\n    public\r\n    onlyFromDeployedLock()\r\n  {\r\n    if(_value > 0) {\r\n      uint valueInETH;\r\n      address tokenAddress = IPublicLock(msg.sender).tokenAddress();\r\n      if(tokenAddress != address(0)) {\r\n        // If priced in an ERC-20 token, find the supported uniswap exchange\r\n        IUniswapExchange exchange = uniswapExchanges[tokenAddress];\r\n        if(address(exchange) != address(0)) {\r\n          valueInETH = exchange.getTokenToEthInputPrice(_value);\r\n        } else {\r\n          // If the token type is not supported, assume 0 value\r\n          valueInETH = 0;\r\n        }\r\n      }\r\n      else {\r\n        // If priced in ETH (or value is 0), no conversion is required\r\n        valueInETH = _value;\r\n      }\r\n\r\n      grossNetworkProduct += valueInETH;\r\n      locks[msg.sender].totalSales += valueInETH;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This function will keep track of consumed discounts by a given user.\r\n   * It will also grant discount tokens to the creator who is granting the discount based on the\r\n   * amount of discount and compensation rate.\r\n   * This function is invoked by a previously deployed lock only.\r\n   */\r\n  function recordConsumedDiscount(\r\n    uint _discount,\r\n    uint /* _tokens */\r\n  )\r\n    public\r\n    onlyFromDeployedLock()\r\n  {\r\n    // TODO: implement me\r\n    totalDiscountGranted += _discount;\r\n    return;\r\n  }\r\n\r\n  // The version number of the current Unlock implementation on this network\r\n  function unlockVersion(\r\n  ) external pure\r\n    returns (uint16)\r\n  {\r\n    return 7;\r\n  }\r\n\r\n  // function for the owner to update configuration variables\r\n  function configUnlock(\r\n    string calldata _symbol,\r\n    string calldata _URI\r\n  ) external\r\n    onlyOwner\r\n  {\r\n    // ensure that this is an address to which a contract has been deployed.\r\n    globalTokenSymbol = _symbol;\r\n    globalBaseTokenURI = _URI;\r\n\r\n    emit ConfigUnlock(_symbol, _URI);\r\n  }\r\n\r\n  /**\r\n   * @notice Upgrade the PublicLock template used for future calls to `createLock`.\r\n   * @dev This will initialize the template and revokeOwnership.\r\n   */\r\n  function setLockTemplate(\r\n    address payable _publicLockAddress\r\n  ) external\r\n    onlyOwner\r\n  {\r\n    // First claim the template so that no-one else could\r\n    // this will revert if the template was already initialized.\r\n    IPublicLock(_publicLockAddress).initialize(\r\n      address(this), 0, address(0), 0, 0, ''\r\n    );\r\n    IPublicLock(_publicLockAddress).renounceLockManager();\r\n\r\n    publicLockAddress = _publicLockAddress;\r\n\r\n    emit SetLockTemplate(_publicLockAddress);\r\n  }\r\n\r\n  // allows the owner to set the exchange address to use for value conversions\r\n  // setting the _exchangeAddress to address(0) removes support for the token\r\n  function setExchange(\r\n    address _tokenAddress,\r\n    address _exchangeAddress\r\n  ) external\r\n    onlyOwner\r\n  {\r\n    uniswapExchanges[_tokenAddress] = IUniswapExchange(_exchangeAddress);\r\n  }\r\n\r\n  // Allows the owner to change the value tracking variables as needed.\r\n  function resetTrackedValue(\r\n    uint _grossNetworkProduct,\r\n    uint _totalDiscountGranted\r\n  ) external\r\n    onlyOwner\r\n  {\r\n    grossNetworkProduct = _grossNetworkProduct;\r\n    totalDiscountGranted = _totalDiscountGranted;\r\n\r\n    emit ResetTrackedValue(_grossNetworkProduct, _totalDiscountGranted);\r\n  }\r\n\r\n  /**\r\n   * @dev Redundant with globalBaseTokenURI() for backwards compatibility with v3 & v4 locks.\r\n   */\r\n  function getGlobalBaseTokenURI()\r\n    external\r\n    view\r\n    returns (string memory)\r\n  {\r\n    return globalBaseTokenURI;\r\n  }\r\n\r\n  /**\r\n   * @dev Redundant with globalTokenSymbol() for backwards compatibility with v3 & v4 locks.\r\n   */\r\n  function getGlobalTokenSymbol()\r\n    external\r\n    view\r\n    returns (string memory)\r\n  {\r\n    return globalTokenSymbol;\r\n  }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"globalTokenSymbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"globalTokenURI\",\"type\":\"string\"}],\"name\":\"ConfigUnlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lockOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newLockAddress\",\"type\":\"address\"}],\"name\":\"NewLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"grossNetworkProduct\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalDiscountGranted\",\"type\":\"uint256\"}],\"name\":\"ResetTrackedValue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"publicLockAddress\",\"type\":\"address\"}],\"name\":\"SetLockTemplate\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"computeAvailableDiscountFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"discount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_URI\",\"type\":\"string\"}],\"name\":\"configUnlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_expirationDuration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_keyPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxNumberOfKeys\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_lockName\",\"type\":\"string\"},{\"internalType\":\"bytes12\",\"name\":\"_salt\",\"type\":\"bytes12\"}],\"name\":\"createLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGlobalBaseTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGlobalTokenSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalBaseTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalTokenSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"grossNetworkProduct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_unlockOwner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"locks\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"deployed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalSales\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yieldedDiscountTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"publicLockAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_discount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"recordConsumedDiscount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"recordKeyPurchase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_grossNetworkProduct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalDiscountGranted\",\"type\":\"uint256\"}],\"name\":\"resetTrackedValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_exchangeAddress\",\"type\":\"address\"}],\"name\":\"setExchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_publicLockAddress\",\"type\":\"address\"}],\"name\":\"setLockTemplate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDiscountGranted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"uniswapExchanges\",\"outputs\":[{\"internalType\":\"contract IUniswapExchange\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockVersion\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"Unlock","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://fb1b335829ae6eec540b7cd3d190f5e84322bc5beb750515fe4f2b099ed87a90"}]}