{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\nA simple contract for P2P margin lending and trading in the synthetix ecosystem.\r\nThe Lender deposits sUSD to the contract and the trader deposits Eth collateral. The trader\r\nmay place trades through a trade() call, which acts as a proxy to Synthetix.exchange().\r\n\r\nKey Terms:\r\nLender: the party providing the loan by depositing sUSD.\r\nTrader: the party depositing ETH as collateral for the loan.\r\n\r\nsynth_value (sv) - Total sUSD value of the synths in the contract.\r\nloan_value (lv)  - Value owed to Lender at a given point in time.\r\ncollateral_value (cv) - The sUSD equivalent value of the eth collateral.\r\nmaintenance margin (mm) - A buffer amount (e.g., 3%) to allow for slippage in liquidations.\r\n\r\nFor the trader to remain solvent, the following should be enforced:\r\n\r\nsv - lv * (1+mm) + cv > 0\r\n\r\nIf the solvency equation is false, a liquidation() function may be successfully called. Doing so \r\nassigns the synths and the collateral to the Lender.\r\n\r\nFor withdraws while a loan is active, an initial margin (im) factor is used. im is defined\r\nas mm plus a constant (e.g., im = 3% (mm) + 1% = 4%). While a loan is active, a trader may withdraw Eth \r\ncollateral or synths only to the extent:\r\n\r\nsv - lv * (1+im) + cv > 0\r\n\r\nim and mm are stored in units of basis points (i.e., 100 equals 1%).\r\n*/\r\n\r\npragma solidity ^0.5.11;\r\n\r\ncontract SynthetixInterface {\r\n    function exchange(bytes32 sourceCurrencyKey, uint sourceAmount, bytes32 destinationCurrencyKey)\r\n        external \r\n        returns (uint amountReceived);\r\n    function synths(bytes32 currencyKey) public view returns (address);\r\n}\r\n\r\ncontract SynthInterface {\r\n    function currencyKey() public view returns (bytes32 _currencyKey);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool);\r\n}\r\n\r\ncontract ExchRatesInterface {\r\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\r\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint256[] memory);\r\n}\r\n\r\ncontract marginTrade {\r\n    // ========== CONSTANTS ==========\r\n    \r\n    bytes32 private constant sUSD = \"sUSD\";\r\n    bytes32 private constant sETH = \"sETH\";\r\n    uint constant IM_BUFFER_OVER_MM = 200;\r\n    uint constant e18 = 10**18;\r\n    uint constant SECONDS_IN_YEAR = 31557600;\r\n    \r\n    //TODO - is there a better way to do this? A change in the address should not break the system.\r\n    //mainnet addresses\r\n    address constant public exchRateAddress = 0x9D7F70AF5DF5D5CC79780032d47a34615D1F1d77;\r\n    address constant public synthetixContractAddress = 0xC011A72400E58ecD99Ee497CF89E3775d4bd732F;\r\n    \r\n    //kovan\r\n    //address constant public exchRateAddress = 0x29A74bBDFd3eBAE39BFF917AAF4dAE8D3d505cf0;\r\n    //address constant public synthetixContractAddress = 0x22f1ba6dB6ca0A065e1b7EAe6FC22b7E675310EF;\r\n    \r\n    // ========== STATE VARIABLES ==========\r\n    \r\n    address payable public lender;\r\n    address payable public trader;\r\n    uint public APR;                             // in units of basis points\r\n    uint public maxDurationSecs;                 // loan duration\r\n    uint public maxLoanAmt;                     //the maximum loan amount desired by the Trader\r\n    bytes32[] public approvedSynths;                    //list of synths that can be traded by this contract\r\n    mapping(bytes32 => uint) public lenderSynthBalances; //synths balances allocated to the Lender.\r\n    uint public lenderEthBalance;\r\n    uint public loanStartTS;                        //loan start timestamp\r\n    uint public mm;                     //maintenance margin. value is in basis point (e.g., 100 is 1%)\r\n    bool public wasLiquidated = false;\r\n    \r\n    mapping(bytes32 => address) synthToAddress;  //synth key => address of the erc20 contracts\r\n    \r\n    //The current loan balance (lv) is equal to loanBalance + the interest accrued between lastLoanTS and now;\r\n    uint256 private loanBalance;\r\n    uint private lastLoanSettleTS;\r\n    \r\n    // ========== CONSTRUCTOR ==========\r\n    /**\r\n     * @notice Deploy a new tradeProxy contract through the factory.\r\n     * @param  _lenderAddress The address of the lender.\r\n     * @param  _traderAddress The address of the Trader.\r\n     * @param  _APR The annual interest rate, paid to the lender. Expressed in units of basis points.\r\n     * @param  _maxDurationSecs The max period of the loan.\r\n     * @param  _maxLoanAmt The requested amount of sUSD that is to be borrowed by the trader.\r\n     * @param  _mm   The minimum maintenance margin.\r\n     * @param  _approvedSynths Array of synths that can be traded. Must include sUSD.\r\n     * @param  _approvedSynthAddresses Synth contract addresses of the synths.\r\n     */\r\n    \r\n    constructor(\r\n                address payable _lenderAddress, \r\n                address payable _traderAddress,\r\n                uint256 _APR,\r\n                uint256 _maxDurationSecs,\r\n                uint256 _maxLoanAmt,\r\n                uint _mm,\r\n                bytes32[] memory _approvedSynths,\r\n                address[] memory _approvedSynthAddresses\r\n                )\r\n        public\r\n    {\r\n        lender = _lenderAddress;\r\n        trader = _traderAddress; \r\n        APR = _APR;\r\n        maxDurationSecs = _maxDurationSecs;\r\n        maxLoanAmt = _maxLoanAmt;\r\n        mm = _mm;\r\n        \r\n        //check to ensure approvedSynths includes sUSD\r\n        bool sUSDFound = false;\r\n        for(uint i = 0; i < _approvedSynths.length; i++) {\r\n            if (_approvedSynths[i] == sUSD) {\r\n                sUSDFound = true;\r\n            }\r\n        }\r\n        require(sUSDFound, \"sUSD must be among the approved synths.\");\r\n        approvedSynths = _approvedSynths;\r\n        \r\n        require(approvedSynths.length == _approvedSynthAddresses.length, \"lengths dont match.\");\r\n        for (uint i = 0; i < approvedSynths.length; i++) {\r\n            synthToAddress[approvedSynths[i]] = _approvedSynthAddresses[i];\r\n        }\r\n        \r\n        //TODO ? - check to ensure synth addresses are actual Synthetix Synth addresses \r\n        //     and the currencykeys are correct and there are no duplicates ??? Alternatively,\r\n        //     do this at the application layer.\r\n    }\r\n    \r\n    function() external payable {}\r\n    \r\n    // ========== SETTERS ==========\r\n    \r\n    /**\r\n     * @notice The Trader can use this parameter to indicate whether a loan is desired\r\n     * @notice by setting the maxLoanAmt greater than the current loan balance.\r\n     */\r\n    function setMaxLoanAmount(uint256 _maxLoanAmt)\r\n        external\r\n    {\r\n        require(msg.sender == trader, \"Only the Trader can change the desired max loan amt\");\r\n        maxLoanAmt = _maxLoanAmt;\r\n    }\r\n    \r\n    // ========== FUNCTIONS ==========\r\n    \r\n     /**\r\n     * @notice Lender deposit sUSD into the contract. Must first approve the transfer.\r\n     * @param  token The sUSD contract address. \r\n     * @param amount The amount of sUSD to deposit.\r\n     */\r\n    function depositFunds(SynthInterface token, uint256 amount)\r\n        public\r\n    {\r\n        require(token.currencyKey() == sUSD, \"Loan deposit must be sUSD\"); \r\n        require(amount > 0);\r\n        \r\n        uint _svPre = traderTotSynthValueUSD();\r\n        uint _newLoanBalance = loanBalUSD() + amount;\r\n        \r\n        require(_newLoanBalance <= maxLoanAmt, \"loan amount too high\");\r\n        \r\n        //enforce solvency contstraint\r\n        require( isInitialMarginSatisfied(_svPre + amount, collValueUSD(), \r\n                                           _newLoanBalance, mm), \"Not enough collateral in the contract.\");\r\n                                           \r\n        require(token.transferFrom(msg.sender, address(this), amount), \"token transfer failed\");\r\n        \r\n        loanBalance = _newLoanBalance;\r\n        lastLoanSettleTS = now;\r\n        \r\n        if (loanStartTS == 0) {\r\n            loanStartTS = now;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Allows the trader to place a trade through synthetix.exchange.\r\n     * @param  sourceCurrencyKey The currency key of the source synth. \r\n     * @param  sourceAmount       The amount of the source synth to trade.\r\n     * @param  destCurrencyKey  The currency key of the destination synth. \r\n     */\r\n    function trade(\r\n                   bytes32 sourceCurrencyKey, \r\n                   uint sourceAmount,\r\n                   bytes32 destCurrencyKey) \r\n                   public\r\n                   returns (uint)\r\n    {\r\n        //TODO - add safety check to prevent many atomic griefing trades?\r\n       \r\n        require(msg.sender == trader);\r\n        \r\n        //Can't trade lender funds\r\n        require(synthBalanceTrader(sourceCurrencyKey) >= sourceAmount,\r\n                \"trader does not have enough balance\");\r\n        \r\n        return SynthetixInterface( synthetixContractAddress).exchange(sourceCurrencyKey,\r\n                   sourceAmount, destCurrencyKey);\r\n    }\r\n    \r\n    /**\r\n     * @notice Liquidation may be called by any address and is successful if the solvency\r\n     * @notice equation is false. Liquidation causes the Lender to be assigned the assets\r\n     * @notice of the Trader. Solvency Equation: sv - lv *(1+mm) + cv > 0\r\n     */\r\n     function liquidate()\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(!wasLiquidated, \"already liquidated\" );\r\n        \r\n        if (isLiquidationable()) {\r\n            //Liquidation; transfer all assets to the lender\r\n            lenderEthBalance = address(this).balance;\r\n            for (uint i = 0; i < approvedSynths.length; i++) {\r\n                uint _bal = SynthInterface(synthToAddress[approvedSynths[i]]).balanceOf(address(this));\r\n                lenderSynthBalances[approvedSynths[i]] = _bal;\r\n            }\r\n            wasLiquidated = true;\r\n        } else {\r\n            revert(\"not liquidation eligible\");\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * @notice Trader can call this function to withdraw collateral (eth) from the contract.\r\n    * @notice Eth is withdrawable up to the extent of: sv + cv > lv * (1+im) \r\n    * @param  amt The amount of Eth to withdraw.\r\n    * @return Whether the withdraw was successful.\r\n    */\r\n    function traderWithdrawEth(uint amt) \r\n        public\r\n        payable\r\n    {\r\n        require(msg.sender == trader, \"Only trader can withdraw eth\");\r\n        require(amt <=  address(this).balance - lenderEthBalance, \"withdraw amt too high\");\r\n        \r\n        uint usdAmt = getRate(sETH) * amt / e18;\r\n        \r\n        if (isInitialMarginSatisfied(traderTotSynthValueUSD(), collValueUSD() - usdAmt, loanBalUSD(), mm)) {\r\n            address(trader).transfer(amt);    \r\n        } else {\r\n            revert(\"Cant withdraw that much\");\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * @notice Lender can call this function, after a liquidation, to withdraw eth from the contract.\r\n    */\r\n    function lenderWithdrawEth(uint amt) \r\n        public\r\n        payable\r\n    {\r\n        require(msg.sender == lender, \"Only lender can withdraw eth\");\r\n        require(amt <=  lenderEthBalance);\r\n        address(lender).transfer(amt);  \r\n        lenderEthBalance = lenderEthBalance - amt;\r\n    }\r\n    \r\n    /**\r\n    * @notice Trader can call this function to withdraw synths from the contract.\r\n    * @notice The synths are withdrawable up to the extent of: sv + cv > lv * (1+im) \r\n    * @param  amt The amount of the synth to withdraw.\r\n    * @param  currencyKey The currency key of the synth to withdraw.\r\n    */\r\n    function traderWithdrawSynth(uint amt, bytes32 currencyKey) \r\n        public\r\n        returns (bool)\r\n    {\r\n        require(msg.sender == trader, \"Only trader can withdraw synths.\");\r\n        require(synthToAddress[currencyKey] != address(0), \"currency key not in approved list\");\r\n        \r\n        uint usdAmt = _synthValueUSD(getRate(currencyKey), amt);\r\n        \r\n        if (isInitialMarginSatisfied(traderTotSynthValueUSD() - usdAmt, collValueUSD(), loanBalUSD(), mm) ) {\r\n            return  SynthInterface( synthToAddress[currencyKey]).transfer(trader, amt); \r\n        }\r\n        revert(\"Cant withdraw that much\");\r\n    }\r\n    \r\n    /**\r\n    * @notice Lender can call this function to withdraw synths from the contract.\r\n    * @param  amt The amount of the synth to withdraw.\r\n    * @param  currencyKey The currency key of the synth to withdraw.\r\n    */\r\n    function lenderWithdrawSynth(uint amt, bytes32 currencyKey) \r\n        public\r\n        returns (bool)\r\n    {\r\n        require(msg.sender == lender, \"Only lender can withdraw synths.\");\r\n        require(lenderSynthBalances[currencyKey] >= amt, \"Withdraw amt is too high.\");\r\n        \r\n        bool result = SynthInterface( synthToAddress[currencyKey]).transfer(lender, amt); \r\n        if (result) {\r\n            lenderSynthBalances[currencyKey] = lenderSynthBalances[currencyKey] - amt;\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * @notice Trader can call this function to repay some or all of the loan amt.\r\n     * @notice If all of the loan is repayed, maxLoanAmt will be set to zero, effectively closing the loan.\r\n     * @param  amount The amount, of sUSD, to repay.\r\n     */\r\n    function traderRepayLoan(uint amount)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(msg.sender == trader, \"only trader can repay loan\");\r\n        \r\n        uint _loanBalance = loanBalUSD();\r\n        uint _amt;\r\n        if (amount > _loanBalance)\r\n            _amt = _loanBalance;\r\n        else\r\n            _amt = amount;\r\n        \r\n        require(synthBalanceTrader(sUSD) >= _amt, \"Not enough sUSD to repay.\");\r\n        \r\n        //settle loan balance and pay lender\r\n        loanBalance = _loanBalance - _amt;\r\n        lastLoanSettleTS = now;\r\n        \r\n        lenderSynthBalances[sUSD] = lenderSynthBalances[sUSD] + _amt;\r\n        \r\n        //potentially close the loan \r\n        if (loanBalance == 0) {\r\n            maxLoanAmt = 0;\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @notice If the maxLoanDuration has elapsed, either the trader or lender may\r\n     * @notice call this function .\r\n     */\r\n    function loanExpired_Close()\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(msg.sender == lender || msg.sender == trader);\r\n        require(isLoanExpired(), \"loan has not expired\");\r\n        \r\n        maxLoanAmt = 0;  //effectively close further loan deposits\r\n        \r\n        // Iterate through the synths/collateral and assign them to the lender until loan balance\r\n        // is satisfied.\r\n        uint totalRemainaingUSD = loanBalUSD();\r\n        uint _usdAssigned; uint _weiAssigned;\r\n        \r\n        //sUSD\r\n        (_usdAssigned, _weiAssigned) = _determineAssignableAmt(totalRemainaingUSD, \r\n                                                            synthBalanceTrader(sUSD),\r\n                                                            getRate(sUSD) );\r\n        if (_weiAssigned > 0) {\r\n            totalRemainaingUSD = sub(totalRemainaingUSD, _usdAssigned);\r\n            lenderSynthBalances[sUSD] = lenderSynthBalances[sUSD] + _weiAssigned;\r\n        }\r\n        if (totalRemainaingUSD == 0) {\r\n            loanBalance = 0;  \r\n            lastLoanSettleTS = now;\r\n            return true;\r\n        }\r\n        \r\n        //synths other than sUSD\r\n        for (uint i = 0; i < approvedSynths.length; i++) {\r\n            if (approvedSynths[i] != sUSD) {\r\n                bytes32 _synth = approvedSynths[i];\r\n                (_usdAssigned, _weiAssigned) = _determineAssignableAmt(totalRemainaingUSD, \r\n                                                                    synthBalanceTrader(_synth), \r\n                                                                    getRate(_synth));\r\n                if (_weiAssigned > 0) {\r\n                    totalRemainaingUSD = sub(totalRemainaingUSD, _usdAssigned);\r\n                    lenderSynthBalances[_synth] = lenderSynthBalances[_synth] + _weiAssigned;\r\n                }\r\n                if (totalRemainaingUSD == 0) {\r\n                    loanBalance = 0;  \r\n                    lastLoanSettleTS = now;\r\n                    return true;\r\n                }       \r\n            }\r\n        }\r\n        \r\n        //Eth\r\n        (_usdAssigned, _weiAssigned) = _determineAssignableAmt(totalRemainaingUSD, \r\n                                                            sub(address(this).balance, lenderEthBalance),\r\n                                                            getRate(sETH));\r\n        if (_weiAssigned > 0) {\r\n            totalRemainaingUSD = sub(totalRemainaingUSD, _usdAssigned);\r\n            lenderEthBalance = lenderEthBalance + _weiAssigned;\r\n        }\r\n        if (totalRemainaingUSD == 0) {\r\n            loanBalance = 0;  \r\n            lastLoanSettleTS = now;\r\n            return true;\r\n        }\r\n        \r\n        loanBalance = totalRemainaingUSD;  \r\n        lastLoanSettleTS = now;\r\n        return false;\r\n    }\r\n    \r\n    // VIEW FUNCTIONS\r\n    \r\n    /**\r\n     * @notice Determine if the account is below the mimimum maintenance margin.\r\n     */\r\n    function isLiquidationable()\r\n        public\r\n        view\r\n        returns (bool)\r\n    {   \r\n        if (wasLiquidated) {\r\n            return false;\r\n        }\r\n        \r\n        uint sv = traderTotSynthValueUSD();\r\n        uint lv = loanBalUSD();\r\n        uint cv = collValueUSD();\r\n        uint f = (10**18 + mm * 10*14);\r\n        \r\n        if ( (sv + cv) > mul(f, lv) / e18 ) \r\n        {\r\n            //liq not possible\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @notice Determine if the account, after deducting some value (in USD), still satisfies the\r\n     * @notice mimimum initial margin requirement. \r\n     * @param _sv Total trader synth value in USD\r\n     * @param _cv Total trader collateral value in USD\r\n     * @param _lv Total trader loan value in USD\r\n     * @param _mm  maintenance margin\r\n     */\r\n    function isInitialMarginSatisfied(uint _sv, uint _cv, uint _lv, uint _mm)\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        uint f = (10**18 + (_mm + IM_BUFFER_OVER_MM) * 10**14);\r\n        \r\n        if ( (_sv + _cv) >= mul(f, _lv)/e18 ) \r\n        {\r\n            return true; //initial margin condition still ok\r\n        }\r\n        return false;\r\n    }\r\n \r\n    /**\r\n     * @notice Retrieves the exchange rate (sUSD per unit) for a given currency key\r\n     */\r\n     function getRate(bytes32 currencyKey)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return ExchRatesInterface(exchRateAddress).rateForCurrency(currencyKey);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @notice Retrieves the exchange rates (sUSD per unit) for a list of currency keys\r\n     */\r\n     function getRates(bytes32[] memory currencyKeys)\r\n        public\r\n        view\r\n        returns (uint[] memory)\r\n    {\r\n        return ExchRatesInterface(exchRateAddress).ratesForCurrencies(currencyKeys);\r\n    }\r\n    \r\n    /**\r\n     * @notice Return total synth value, of the approved synths, in sUSD (for the Trader)\r\n     */\r\n    function traderTotSynthValueUSD()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint[] memory rates = getRates(approvedSynths);\r\n        uint value = 0;\r\n        for (uint i = 0; i < approvedSynths.length; i++) {\r\n            value = value + _synthValueUSD(rates[i], synthBalanceTrader(approvedSynths[i]));\r\n        }\r\n        \r\n        return value; \r\n    }\r\n\r\n    /**\r\n     * @notice Return the balance for the synth (in synth units) that is held by the contract and assigned \r\n     * @notice to the Trader.\r\n     */\r\n    function synthBalanceTrader(bytes32 currencyKey)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint _bal = SynthInterface(synthToAddress[currencyKey]).balanceOf(address(this));\r\n        \r\n        return _bal - lenderSynthBalances[currencyKey];\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns the actual current ballance of the loan, including outstanding interest.\r\n     */\r\n    function loanBalUSD() \r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint interest = calcInterest(APR, loanBalance, now - lastLoanSettleTS);\r\n        return loanBalance + interest;\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns the USD equivalent of the contract Eth that belongs to the lender. \r\n     */\r\n    function collValueUSD()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return mul(getRate(sETH), address(this).balance - lenderEthBalance) / 1e18;\r\n    }\r\n    \r\n    /**\r\n     * @notice Eth Balance, in wei, of the Trader. \r\n     */\r\n    function traderEthBalance()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return  sub(address(this).balance, lenderEthBalance);\r\n    }\r\n    \r\n    function isLoanExpired()\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return (now - loanStartTS) > maxDurationSecs;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @notice Convenience function to get the users Leverage multiplied by 100.\r\n     * @notice Leverage is a measure of risk and is calculated as: (sv*100) / (cv+lv)\r\n     */\r\n    function levTimes100()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint sv = traderTotSynthValueUSD();\r\n        uint lv = loanBalUSD();\r\n        uint cv = collValueUSD();\r\n        return 100 * lv / (sv + cv - lv);\r\n    }\r\n    \r\n    //\r\n    // Helper Functions\r\n    //\r\n    \r\n     /**\r\n     * @notice Calculates the simple interest, given an APR, an amount, \r\n     * @notice and an elapsed time (in seconds).\r\n     * @param  _APR The APR in basis points (1% == 100)\r\n     * @param  amount The base value for the interest calculation. \r\n     * @param  elapsedTime The time period, in seconds, for the interest calculation.\r\n     */ \r\n    function calcInterest(uint256 _APR, uint256 amount, uint256 elapsedTime)\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint n = mul(elapsedTime, 1000000);\r\n        n = mul(n, amount);\r\n        n = mul(n, _APR);\r\n        uint d = mul(SECONDS_IN_YEAR, 10000000000);\r\n        return n/d;\r\n    }\r\n    \r\n    // Given a synth and a maximimum amount in USD to assign to the Lender, determine the \r\n    // amount that can be assigned. Returns the assignable amount in USD and synth units. balWei\r\n    // is the Trader's native balance.\r\n    function _determineAssignableAmt(uint maxAssignUSD, uint balWei, uint rate)\r\n        private\r\n        pure\r\n        returns (uint amtAssignableUSD, uint amtAssignableSynth)\r\n    {\r\n        if (balWei == 0) {\r\n            return (0, 0);\r\n        }\r\n        \r\n        uint balUSD = _synthValueUSD(rate, balWei);\r\n        \r\n        if (maxAssignUSD >= balUSD) {\r\n            return (maxAssignUSD - balUSD, balWei);\r\n        } else {\r\n            return (maxAssignUSD, mul(balWei, maxAssignUSD) / balUSD) ;\r\n        }\r\n    }\r\n    \r\n    //From openzepplin SafeMath\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal\r\n        pure\r\n        returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    //Safe subtract. Returns zero if b > a    \r\n    function sub(uint256 a, uint256 b) \r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        if (b > a) {\r\n            return 0;\r\n        }\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    \r\n    function _synthValueUSD(uint rate, uint balance) \r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        return mul(rate, balance) / e18;\r\n    }    \r\n    \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_lenderAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_traderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_APR\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxDurationSecs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxLoanAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mm\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_approvedSynths\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"_approvedSynthAddresses\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"APR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"_synthValueUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approvedSynths\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collValueUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract SynthInterface\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchRateAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"getRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"currencyKeys\",\"type\":\"bytes32[]\"}],\"name\":\"getRates\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sv\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cv\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lv\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mm\",\"type\":\"uint256\"}],\"name\":\"isInitialMarginSatisfied\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLiquidationable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLoanExpired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lender\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lenderEthBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"lenderSynthBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"lenderWithdrawEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"lenderWithdrawSynth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"levTimes100\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"liquidate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loanBalUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"loanExpired_Close\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loanStartTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxDurationSecs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxLoanAmt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mm\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxLoanAmt\",\"type\":\"uint256\"}],\"name\":\"setMaxLoanAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"synthBalanceTrader\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthetixContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"destCurrencyKey\",\"type\":\"bytes32\"}],\"name\":\"trade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trader\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"traderEthBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"traderRepayLoan\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"traderTotSynthValueUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"traderWithdrawEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"traderWithdrawSynth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wasLiquidated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"marginTrade","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000084cba016a306c6c32f4043be04343dc60f1a73320000000000000000000000004145f8abc18aebe662ac01aaf3eadb8ef4b6036700000000000000000000000000000000000000000000000000000000000003e80000000000000000000000000000000000000000000000000000000000093a8000000000000000000000000000000000000000000000021e19e0c9bab2400000000000000000000000000000000000000000000000000000000000000000012c000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000000000000000000000000000000000000000000573555344000000000000000000000000000000000000000000000000000000007345544800000000000000000000000000000000000000000000000000000000734c494e4b0000000000000000000000000000000000000000000000000000006945544800000000000000000000000000000000000000000000000000000000734254430000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000050000000000000000000000002a020c1ad728f1c12735bc4877ceeca4491a4a3d0000000000000000000000009f71b6596b2c9d357f9f04f8ca772fbd6e2c211c0000000000000000000000003d663dbe79fa9752815e03e129d6703ede1c6d71000000000000000000000000c0ba711b4e128425be9245ce750d82c90b42d6d2000000000000000000000000f0ac210915bd88ea51c9eb800a4078a85927efdf","Library":"","LicenseType":"GNU GPLv2","SwarmSource":"bzzr://5d8152a237ad5874fa2fdaade5701f8652ec74fdc99a57a9edb86228be0080fd"}]}