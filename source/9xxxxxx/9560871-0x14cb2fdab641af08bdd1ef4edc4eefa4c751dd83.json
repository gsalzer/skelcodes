{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.1;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface ERC2477 {\r\n  \r\n  function tokenURIIntegrity(uint256 tokenId) external view returns(bytes memory digest, string memory hashAlgorithm);\r\n\r\n  \r\n  function tokenURISchemaIntegrity(uint256 tokenId) external view returns(bytes memory digest, string memory hashAlgorithm);\r\n}\r\n\r\ninterface Xcert {\r\n\r\n  \r\n  function create(\r\n    address _to,\r\n    uint256 _id,\r\n    bytes32 _imprint\r\n  )\r\n    external;\r\n\r\n  \r\n  function setUri(\r\n    string calldata _uriPrefix,\r\n    string calldata _uriPostfix\r\n  )\r\n    external;\r\n\r\n}\r\n\r\ninterface XcertBurnable {\r\n\r\n  \r\n  function destroy(\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n}\r\n\r\ninterface XcertMutable {\r\n\r\n  \r\n  function updateTokenURIIntegrityDigest(\r\n    uint256 _tokenId,\r\n    bytes32 _tokenURIIntegrityDigest\r\n  )\r\n    external;\r\n\r\n}\r\n\r\ninterface XcertPausable {\r\n\r\n  \r\n  function setPause(\r\n    bool _isPaused\r\n  )\r\n    external;\r\n\r\n}\r\n\r\ninterface XcertRevokable {\r\n\r\n  \r\n  function revoke(\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  \r\n  string constant OVERFLOW = \"008001\";\r\n  string constant SUBTRAHEND_GREATER_THEN_MINUEND = \"008002\";\r\n  string constant DIVISION_BY_ZERO = \"008003\";\r\n\r\n  \r\n  function mul(\r\n    uint256 _factor1,\r\n    uint256 _factor2\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 product)\r\n  {\r\n    \r\n    \r\n    \r\n    if (_factor1 == 0)\r\n    {\r\n      return 0;\r\n    }\r\n\r\n    product = _factor1 * _factor2;\r\n    require(product / _factor1 == _factor2, OVERFLOW);\r\n  }\r\n\r\n  \r\n  function div(\r\n    uint256 _dividend,\r\n    uint256 _divisor\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 quotient)\r\n  {\r\n    \r\n    require(_divisor > 0, DIVISION_BY_ZERO);\r\n    quotient = _dividend / _divisor;\r\n    \r\n  }\r\n\r\n  \r\n  function sub(\r\n    uint256 _minuend,\r\n    uint256 _subtrahend\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 difference)\r\n  {\r\n    require(_subtrahend <= _minuend, SUBTRAHEND_GREATER_THEN_MINUEND);\r\n    difference = _minuend - _subtrahend;\r\n  }\r\n\r\n  \r\n  function add(\r\n    uint256 _addend1,\r\n    uint256 _addend2\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 sum)\r\n  {\r\n    sum = _addend1 + _addend2;\r\n    require(sum >= _addend1, OVERFLOW);\r\n  }\r\n\r\n  \r\n  function mod(\r\n    uint256 _dividend,\r\n    uint256 _divisor\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 remainder)\r\n  {\r\n    require(_divisor != 0, DIVISION_BY_ZERO);\r\n    remainder = _dividend % _divisor;\r\n  }\r\n\r\n}\r\n\r\ncontract Abilitable {\r\n  using SafeMath for uint;\r\n\r\n  \r\n  string constant NOT_AUTHORIZED = \"017001\";\r\n  string constant INVALID_INPUT = \"017002\";\r\n\r\n  \r\n  uint8 constant SUPER_ABILITY = 1;\r\n\r\n  \r\n  uint8 constant ALLOW_SUPER_ABILITY = 2;\r\n\r\n  \r\n  uint8 constant EMPTY_SLOT_1 = 4;\r\n\r\n  \r\n  uint8 constant EMPTY_SLOT_2 = 8;\r\n\r\n  \r\n  uint8 constant ALL_DEFAULT_ABILITIES = 15;\r\n\r\n  \r\n  mapping(address => uint256) public addressToAbility;\r\n\r\n  \r\n  event SetAbilities(\r\n    address indexed _target,\r\n    uint256 indexed _abilities\r\n  );\r\n\r\n  \r\n  modifier hasAbilities(\r\n    uint256 _abilities\r\n  )\r\n  {\r\n    require(_abilities > 0, INVALID_INPUT);\r\n    require(\r\n      addressToAbility[msg.sender] & _abilities == _abilities,\r\n      NOT_AUTHORIZED\r\n    );\r\n    _;\r\n  }\r\n\r\n  \r\n  constructor()\r\n    public\r\n  {\r\n    addressToAbility[msg.sender] = ALL_DEFAULT_ABILITIES;\r\n  }\r\n\r\n  \r\n  function grantAbilities(\r\n    address _target,\r\n    uint256 _abilities\r\n  )\r\n    external\r\n    hasAbilities(SUPER_ABILITY)\r\n  {\r\n    addressToAbility[_target] |= _abilities;\r\n    emit SetAbilities(_target, addressToAbility[_target]);\r\n  }\r\n\r\n  \r\n  function revokeAbilities(\r\n    address _target,\r\n    uint256 _abilities\r\n  )\r\n    external\r\n    hasAbilities(SUPER_ABILITY)\r\n  {\r\n    addressToAbility[_target] &= ~_abilities;\r\n    emit SetAbilities(_target, addressToAbility[_target]);\r\n  }\r\n\r\n  \r\n  function setAbilities(\r\n    address _target,\r\n    uint256 _abilities\r\n  )\r\n    external\r\n    hasAbilities(SUPER_ABILITY)\r\n  {\r\n    addressToAbility[_target] = _abilities;\r\n    emit SetAbilities(_target, _abilities);\r\n  }\r\n\r\n  \r\n  function isAble(\r\n    address _target,\r\n    uint256 _abilities\r\n  )\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(_abilities > 0, INVALID_INPUT);\r\n    return (addressToAbility[_target] & _abilities) == _abilities;\r\n  }\r\n\r\n}\r\n\r\ninterface ERC721 {\r\n\r\n  \r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  \r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  \r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  \r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external;\r\n\r\n  \r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  \r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  \r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  \r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external;\r\n\r\n  \r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  \r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  \r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  \r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n}\r\n\r\ninterface ERC721Metadata {\r\n\r\n  \r\n  function name()\r\n    external\r\n    view\r\n    returns (string memory _name);\r\n\r\n  \r\n  function symbol()\r\n    external\r\n    view\r\n    returns (string memory _symbol);\r\n\r\n  \r\n  function tokenURI(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns (string memory);\r\n\r\n}\r\n\r\ninterface ERC721Enumerable {\r\n\r\n  \r\n  function totalSupply()\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  \r\n  function tokenByIndex(\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  \r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n}\r\n\r\ninterface ERC721TokenReceiver {\r\n\r\n  \r\n  function onERC721Received(\r\n    address _operator,\r\n    address _from,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n    returns(bytes4);\r\n\r\n}\r\n\r\ninterface ERC165 {\r\n\r\n  \r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n}\r\n\r\ncontract SupportsInterface is\r\n  ERC165\r\n{\r\n\r\n  \r\n  mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n  \r\n  constructor()\r\n    public\r\n  {\r\n    supportedInterfaces[0x01ffc9a7] = true; \r\n  }\r\n\r\n  \r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (bool)\r\n  {\r\n    return supportedInterfaces[_interfaceID];\r\n  }\r\n\r\n}\r\n\r\nlibrary AddressUtils {\r\n\r\n  \r\n  function isDeployedContract(\r\n    address _addr\r\n  )\r\n    internal\r\n    view\r\n    returns (bool addressCheck)\r\n  {\r\n    uint256 size;\r\n    assembly { size := extcodesize(_addr) } \r\n    addressCheck = size > 0;\r\n  }\r\n\r\n}\r\n\r\ncontract NFTokenMetadataEnumerable is\r\n  ERC721,\r\n  ERC721Metadata,\r\n  ERC721Enumerable,\r\n  SupportsInterface\r\n{\r\n  using SafeMath for uint256;\r\n  using AddressUtils for address;\r\n\r\n  \r\n  string constant ZERO_ADDRESS = \"006001\";\r\n  string constant NOT_VALID_NFT = \"006002\";\r\n  string constant NOT_OWNER_OR_OPERATOR = \"006003\";\r\n  string constant NOT_OWNER_APPROWED_OR_OPERATOR = \"006004\";\r\n  string constant NOT_ABLE_TO_RECEIVE_NFT = \"006005\";\r\n  string constant NFT_ALREADY_EXISTS = \"006006\";\r\n  string constant INVALID_INDEX = \"006007\";\r\n\r\n  \r\n  bytes4 constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  \r\n  string internal nftName;\r\n\r\n  \r\n  string internal nftSymbol;\r\n\r\n  \r\n  string public uriPrefix;\r\n\r\n  \r\n  string public uriPostfix;\r\n\r\n  \r\n  uint256[] internal tokens;\r\n\r\n  \r\n  mapping(uint256 => uint256) internal idToIndex;\r\n\r\n  \r\n  mapping(address => uint256[]) internal ownerToIds;\r\n\r\n  \r\n  mapping(uint256 => uint256) internal idToOwnerIndex;\r\n\r\n  \r\n  mapping (uint256 => address) internal idToOwner;\r\n\r\n  \r\n  mapping (uint256 => address) internal idToApproval;\r\n\r\n  \r\n  mapping (address => mapping (address => bool)) internal ownerToOperators;\r\n\r\n  \r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  \r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  \r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  \r\n  constructor()\r\n    public\r\n  {\r\n    supportedInterfaces[0x80ac58cd] = true; \r\n    supportedInterfaces[0x5b5e139f] = true; \r\n    supportedInterfaces[0x780e9d63] = true; \r\n  }\r\n\r\n  \r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n    override\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, _data);\r\n  }\r\n\r\n  \r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  \r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n  {\r\n    _transferFrom(_from, _to, _tokenId);\r\n  }\r\n\r\n  \r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n  {\r\n    \r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(\r\n      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\r\n      NOT_OWNER_OR_OPERATOR\r\n    );\r\n\r\n    idToApproval[_tokenId] = _approved;\r\n    emit Approval(tokenOwner, _approved, _tokenId);\r\n  }\r\n\r\n  \r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external\r\n    override\r\n  {\r\n    ownerToOperators[msg.sender][_operator] = _approved;\r\n    emit ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n  \r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_owner != address(0), ZERO_ADDRESS);\r\n    return ownerToIds[_owner].length;\r\n  }\r\n\r\n  \r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (address _owner)\r\n  {\r\n    _owner = idToOwner[_tokenId];\r\n    require(_owner != address(0), NOT_VALID_NFT);\r\n  }\r\n\r\n  \r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (address)\r\n  {\r\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\r\n    return idToApproval[_tokenId];\r\n  }\r\n\r\n  \r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (bool)\r\n  {\r\n    return ownerToOperators[_owner][_operator];\r\n  }\r\n\r\n  \r\n  function totalSupply()\r\n    external\r\n    override\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return tokens.length;\r\n  }\r\n\r\n  \r\n  function tokenByIndex(\r\n    uint256 _index\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_index < tokens.length, INVALID_INDEX);\r\n    return tokens[_index];\r\n  }\r\n\r\n  \r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_index < ownerToIds[_owner].length, INVALID_INDEX);\r\n    return ownerToIds[_owner][_index];\r\n  }\r\n\r\n  \r\n  function name()\r\n    external\r\n    override\r\n    view\r\n    returns (string memory _name)\r\n  {\r\n    _name = nftName;\r\n  }\r\n\r\n  \r\n  function symbol()\r\n    external\r\n    override\r\n    view\r\n    returns (string memory _symbol)\r\n  {\r\n    _symbol = nftSymbol;\r\n  }\r\n\r\n  \r\n  function tokenURI(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (string memory)\r\n  {\r\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\r\n    string memory uri = \"\";\r\n    if (bytes(uriPrefix).length > 0)\r\n    {\r\n      uri = string(abi.encodePacked(uriPrefix, _uint2str(_tokenId)));\r\n      if (bytes(uriPostfix).length > 0)\r\n      {\r\n        uri = string(abi.encodePacked(uri, uriPostfix));\r\n      }\r\n    }\r\n    return uri;\r\n  }\r\n\r\n  \r\n  function _setUri(\r\n    string memory _prefix,\r\n    string memory _postfix\r\n  )\r\n    internal\r\n  {\r\n    uriPrefix = _prefix;\r\n    uriPostfix = _postfix;\r\n  }\r\n\r\n  \r\n  function _create(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n\r\n    \r\n    idToOwner[_tokenId] = _to;\r\n\r\n    ownerToIds[_to].push(_tokenId);\r\n    idToOwnerIndex[_tokenId] = ownerToIds[_to].length - 1;\r\n\r\n    \r\n    tokens.push(_tokenId);\r\n    idToIndex[_tokenId] = tokens.length - 1;\r\n\r\n    emit Transfer(address(0), _to, _tokenId);\r\n  }\r\n\r\n  \r\n  function _destroy(\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    \r\n    address _owner = idToOwner[_tokenId];\r\n    require(_owner != address(0), NOT_VALID_NFT);\r\n\r\n    \r\n    if (idToApproval[_tokenId] != address(0))\r\n    {\r\n      delete idToApproval[_tokenId];\r\n    }\r\n\r\n    \r\n    assert(ownerToIds[_owner].length > 0);\r\n\r\n    uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\r\n    uint256 lastTokenIndex = ownerToIds[_owner].length - 1;\r\n    uint256 lastToken;\r\n    if (lastTokenIndex != tokenToRemoveIndex)\r\n    {\r\n      lastToken = ownerToIds[_owner][lastTokenIndex];\r\n      ownerToIds[_owner][tokenToRemoveIndex] = lastToken;\r\n      idToOwnerIndex[lastToken] = tokenToRemoveIndex;\r\n    }\r\n\r\n    delete idToOwner[_tokenId];\r\n    delete idToOwnerIndex[_tokenId];\r\n    ownerToIds[_owner].pop();\r\n\r\n    \r\n    assert(tokens.length > 0);\r\n\r\n    uint256 tokenIndex = idToIndex[_tokenId];\r\n    lastTokenIndex = tokens.length - 1;\r\n    lastToken = tokens[lastTokenIndex];\r\n\r\n    tokens[tokenIndex] = lastToken;\r\n\r\n    tokens.pop();\r\n    \r\n    idToIndex[lastToken] = tokenIndex;\r\n    idToIndex[_tokenId] = 0;\r\n\r\n    emit Transfer(_owner, address(0), _tokenId);\r\n  }\r\n\r\n  \r\n  function _transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    \r\n    require(_from != address(0), ZERO_ADDRESS);\r\n    require(idToOwner[_tokenId] == _from, NOT_VALID_NFT);\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n\r\n    \r\n    require(\r\n      _from == msg.sender\r\n      || idToApproval[_tokenId] == msg.sender\r\n      || ownerToOperators[_from][msg.sender],\r\n      NOT_OWNER_APPROWED_OR_OPERATOR\r\n    );\r\n\r\n    \r\n    if (idToApproval[_tokenId] != address(0))\r\n    {\r\n      delete idToApproval[_tokenId];\r\n    }\r\n\r\n    \r\n    assert(ownerToIds[_from].length > 0);\r\n\r\n    uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\r\n    uint256 lastTokenIndex = ownerToIds[_from].length - 1;\r\n\r\n    if (lastTokenIndex != tokenToRemoveIndex)\r\n    {\r\n      uint256 lastToken = ownerToIds[_from][lastTokenIndex];\r\n      ownerToIds[_from][tokenToRemoveIndex] = lastToken;\r\n      idToOwnerIndex[lastToken] = tokenToRemoveIndex;\r\n    }\r\n\r\n    ownerToIds[_from].pop();\r\n\r\n    \r\n    idToOwner[_tokenId] = _to;\r\n    ownerToIds[_to].push(_tokenId);\r\n    idToOwnerIndex[_tokenId] = ownerToIds[_to].length - 1;\r\n\r\n    emit Transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  \r\n  function _safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes memory _data\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    if (_to.isDeployedContract())\r\n    {\r\n      require(\r\n        ERC721TokenReceiver(_to)\r\n          .onERC721Received(msg.sender, _from, _tokenId, _data) == MAGIC_ON_ERC721_RECEIVED,\r\n        NOT_ABLE_TO_RECEIVE_NFT\r\n      );\r\n    }\r\n\r\n    _transferFrom(_from, _to, _tokenId);\r\n  }\r\n\r\n  \r\n  function _uint2str(\r\n    uint256 _i\r\n  )\r\n    internal\r\n    pure\r\n    returns (string memory str)\r\n  {\r\n    if (_i == 0)\r\n    {\r\n      return \"0\";\r\n    }\r\n    uint256 j = _i;\r\n    uint256 length;\r\n    while (j != 0)\r\n    {\r\n      length++;\r\n      j /= 10;\r\n    }\r\n    bytes memory bstr = new bytes(length);\r\n    uint256 k = length - 1;\r\n    j = _i;\r\n    while (j != 0)\r\n    {\r\n      bstr[k--] = byte(uint8(48 + j % 10));\r\n      j /= 10;\r\n    }\r\n    str = string(bstr);\r\n  }\r\n\r\n}\r\n\r\ninterface ERC20 {\r\n\r\n  \r\n  function name()\r\n    external\r\n    view\r\n    returns (string memory _name);\r\n\r\n  \r\n  function symbol()\r\n    external\r\n    view\r\n    returns (string memory _symbol);\r\n\r\n  \r\n  function decimals()\r\n    external\r\n    view\r\n    returns (uint8 _decimals);\r\n\r\n  \r\n  function totalSupply()\r\n    external\r\n    view\r\n    returns (uint256 _totalSupply);\r\n\r\n  \r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256 _balance);\r\n\r\n  \r\n  function transfer(\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    external\r\n    returns (bool _success);\r\n\r\n  \r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    external\r\n    returns (bool _success);\r\n\r\n  \r\n  function approve(\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    external\r\n    returns (bool _success);\r\n\r\n  \r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n  )\r\n    external\r\n    view\r\n    returns (uint256 _remaining);\r\n\r\n  \r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 _value\r\n  );\r\n\r\n  \r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _spender,\r\n    uint256 _value\r\n  );\r\n\r\n}\r\n\r\ncontract XcertToken is\r\n  ERC2477,\r\n  Xcert,\r\n  XcertBurnable,\r\n  XcertMutable,\r\n  XcertPausable,\r\n  XcertRevokable,\r\n  NFTokenMetadataEnumerable,\r\n  Abilitable\r\n{\r\n\r\n  \r\n  uint8 constant ABILITY_CREATE_ASSET = 16;\r\n  uint8 constant ABILITY_REVOKE_ASSET = 32;\r\n  uint8 constant ABILITY_TOGGLE_TRANSFERS = 64;\r\n  uint8 constant ABILITY_UPDATE_ASSET_URI_INTEGRITY_DIGEST = 128;\r\n  uint16 constant ABILITY_UPDATE_URI = 256;\r\n  \r\n  \r\n  \r\n  \r\n  \r\n\r\n  \r\n  bytes4 constant MUTABLE = 0x0d04c3b8;\r\n  bytes4 constant BURNABLE = 0x9d118770;\r\n  bytes4 constant PAUSABLE = 0xbedb86fb;\r\n  bytes4 constant REVOKABLE = 0x20c5429b;\r\n\r\n  \r\n  string constant HASH_ALGORITHM = 'sha256';\r\n\r\n  \r\n  string constant CAPABILITY_NOT_SUPPORTED = \"007001\";\r\n  string constant TRANSFERS_DISABLED = \"007002\";\r\n  string constant NOT_VALID_XCERT = \"007003\";\r\n  string constant NOT_XCERT_OWNER_OR_OPERATOR = \"007004\";\r\n  string constant INVALID_SIGNATURE = \"007005\";\r\n  string constant INVALID_SIGNATURE_KIND = \"007006\";\r\n  string constant CLAIM_PERFORMED = \"007007\";\r\n  string constant CLAIM_EXPIRED = \"007008\";\r\n  string constant CLAIM_CANCELED = \"007009\";\r\n  string constant NOT_OWNER = \"007010\";\r\n\r\n  \r\n  event IsPaused(bool isPaused);\r\n\r\n  \r\n  event TokenURIIntegrityDigestUpdate(\r\n    uint256 indexed _tokenId,\r\n    bytes32 _tokenURIIntegrityDigest\r\n  );\r\n\r\n  \r\n  enum SignatureKind\r\n  {\r\n    eth_sign,\r\n    trezor,\r\n    no_prefix\r\n  }\r\n\r\n  \r\n  struct SignatureData\r\n  {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n    SignatureKind kind;\r\n  }\r\n\r\n  \r\n  mapping(bytes32 => bool) public claimPerformed;\r\n\r\n  \r\n  mapping(bytes32 => bool) public claimCancelled;\r\n\r\n  \r\n  bytes32 internal schemaURIIntegrityDigest;\r\n\r\n  \r\n  mapping (uint256 => bytes32) internal idToIntegrityDigest;\r\n\r\n  \r\n  mapping (address => bool) internal addressToAuthorized;\r\n\r\n  \r\n  bool public isPaused;\r\n\r\n  \r\n  constructor()\r\n    public\r\n  {\r\n    supportedInterfaces[0x39541724] = true; \r\n  }\r\n\r\n  \r\n  function create(\r\n    address _to,\r\n    uint256 _id,\r\n    bytes32 _tokenURIIntegrityDigest\r\n  )\r\n    external\r\n    override\r\n    hasAbilities(ABILITY_CREATE_ASSET)\r\n  {\r\n    super._create(_to, _id);\r\n    idToIntegrityDigest[_id] = _tokenURIIntegrityDigest;\r\n  }\r\n\r\n  \r\n  function setUri(\r\n    string calldata _uriPrefix,\r\n    string calldata _uriPostfix\r\n  )\r\n    external\r\n    override\r\n    hasAbilities(ABILITY_UPDATE_URI)\r\n  {\r\n    super._setUri(_uriPrefix, _uriPostfix);\r\n  }\r\n\r\n  \r\n  function revoke(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    hasAbilities(ABILITY_REVOKE_ASSET)\r\n  {\r\n    require(supportedInterfaces[REVOKABLE], CAPABILITY_NOT_SUPPORTED);\r\n    super._destroy(_tokenId);\r\n    delete idToIntegrityDigest[_tokenId];\r\n  }\r\n\r\n  \r\n  function setPause(\r\n    bool _isPaused\r\n  )\r\n    external\r\n    override\r\n    hasAbilities(ABILITY_TOGGLE_TRANSFERS)\r\n  {\r\n    require(supportedInterfaces[PAUSABLE], CAPABILITY_NOT_SUPPORTED);\r\n    isPaused = _isPaused;\r\n    emit IsPaused(_isPaused);\r\n  }\r\n\r\n  \r\n  function updateTokenURIIntegrityDigest(\r\n    uint256 _tokenId,\r\n    bytes32 _tokenURIIntegrityDigest\r\n  )\r\n    external\r\n    override\r\n    hasAbilities(ABILITY_UPDATE_ASSET_URI_INTEGRITY_DIGEST)\r\n  {\r\n    require(supportedInterfaces[MUTABLE], CAPABILITY_NOT_SUPPORTED);\r\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_XCERT);\r\n    idToIntegrityDigest[_tokenId] = _tokenURIIntegrityDigest;\r\n    emit TokenURIIntegrityDigestUpdate(_tokenId, _tokenURIIntegrityDigest);\r\n  }\r\n\r\n  \r\n  function destroy(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n  {\r\n    require(supportedInterfaces[BURNABLE], CAPABILITY_NOT_SUPPORTED);\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    super._destroy(_tokenId);\r\n    require(\r\n      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\r\n      NOT_XCERT_OWNER_OR_OPERATOR\r\n    );\r\n    delete idToIntegrityDigest[_tokenId];\r\n  }\r\n\r\n  \r\n  function setApprovalForAllWithSignature(\r\n    address _owner,\r\n    address _operator,\r\n    bool _approved,\r\n    address _feeToken,\r\n    uint256 _feeValue,\r\n    address _feeRecipient,\r\n    uint256 _seed,\r\n    uint256 _expiration,\r\n    SignatureData calldata _signature\r\n  )\r\n    external\r\n  {\r\n    bytes32 claim = generateClaim(\r\n      _owner,\r\n      _operator,\r\n      _approved,\r\n      _feeToken,\r\n      _feeValue,\r\n      _feeRecipient,\r\n      _seed,\r\n      _expiration\r\n    );\r\n    require(!claimCancelled[claim], CLAIM_CANCELED);\r\n    require(\r\n      isValidSignature(\r\n        _owner,\r\n        claim,\r\n        _signature\r\n      ),\r\n      INVALID_SIGNATURE\r\n    );\r\n    require(!claimPerformed[claim], CLAIM_PERFORMED);\r\n    require(_expiration >= now, CLAIM_EXPIRED);\r\n    claimPerformed[claim] = true;\r\n    ownerToOperators[_owner][_operator] = _approved;\r\n    if (_feeRecipient == address(0)) {\r\n      _feeRecipient = msg.sender;\r\n    }\r\n    ERC20(_feeToken).transferFrom(_owner, _feeRecipient, _feeValue);\r\n    emit ApprovalForAll(_owner, _operator, _approved);\r\n  }\r\n\r\n  \r\n  function cancelSetApprovalForAllWithSignature(\r\n    address _owner,\r\n    address _operator,\r\n    bool _approved,\r\n    address _feeToken,\r\n    uint256 _feeValue,\r\n    address _feeRecipient,\r\n    uint256 _seed,\r\n    uint256 _expiration\r\n  )\r\n    external\r\n  {\r\n    require(msg.sender == _owner, NOT_OWNER);\r\n    bytes32 claim = generateClaim(\r\n      _owner,\r\n      _operator,\r\n      _approved,\r\n      _feeToken,\r\n      _feeValue,\r\n      _feeRecipient,\r\n      _seed,\r\n      _expiration\r\n    );\r\n    require(!claimPerformed[claim], CLAIM_PERFORMED);\r\n    claimCancelled[claim] = true;\r\n  }\r\n\r\n  \r\n  function generateClaim(\r\n    address _owner,\r\n    address _operator,\r\n    bool _approved,\r\n    address _feeToken,\r\n    uint256 _feeValue,\r\n    address _feeRecipient,\r\n    uint256 _seed,\r\n    uint256 _expiration\r\n  )\r\n    public\r\n    view\r\n    returns(bytes32)\r\n  {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        address(this),\r\n        _owner,\r\n        _operator,\r\n        _approved,\r\n        _feeToken,\r\n        _feeValue,\r\n        _feeRecipient,\r\n        _seed,\r\n        _expiration\r\n      )\r\n    );\r\n  }\r\n\r\n  \r\n  function isValidSignature(\r\n    address _signer,\r\n    bytes32 _claim,\r\n    SignatureData memory _signature\r\n  )\r\n    public\r\n    pure\r\n    returns (bool)\r\n  {\r\n    if (_signature.kind == SignatureKind.eth_sign)\r\n    {\r\n      return _signer == ecrecover(\r\n        keccak256(\r\n          abi.encodePacked(\r\n            \"\\x19Ethereum Signed Message:\\n32\",\r\n            _claim\r\n          )\r\n        ),\r\n        _signature.v,\r\n        _signature.r,\r\n        _signature.s\r\n      );\r\n    } else if (_signature.kind == SignatureKind.trezor)\r\n    {\r\n      return _signer == ecrecover(\r\n        keccak256(\r\n          abi.encodePacked(\r\n            \"\\x19Ethereum Signed Message:\\n\\x20\",\r\n            _claim\r\n          )\r\n        ),\r\n        _signature.v,\r\n        _signature.r,\r\n        _signature.s\r\n      );\r\n    } else if (_signature.kind == SignatureKind.no_prefix)\r\n    {\r\n      return _signer == ecrecover(\r\n        _claim,\r\n        _signature.v,\r\n        _signature.r,\r\n        _signature.s\r\n      );\r\n    }\r\n\r\n    revert(INVALID_SIGNATURE_KIND);\r\n  }\r\n\r\n  \r\n  function tokenURISchemaIntegrity(\r\n    uint256 tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns(bytes memory digest, string memory hashAlgorithm)\r\n  {\r\n    require(idToOwner[tokenId] != address(0), NOT_VALID_XCERT);\r\n    digest = abi.encodePacked(schemaURIIntegrityDigest);\r\n    hashAlgorithm = HASH_ALGORITHM;\r\n  }\r\n\r\n  \r\n  function tokenURIIntegrity(\r\n    uint256 tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns(bytes memory digest, string memory hashAlgorithm)\r\n  {\r\n    require(idToOwner[tokenId] != address(0), NOT_VALID_XCERT);\r\n    digest = abi.encodePacked(idToIntegrityDigest[tokenId]);\r\n    hashAlgorithm = HASH_ALGORITHM;\r\n  }\r\n\r\n  \r\n  function _transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    override\r\n  {\r\n    \r\n    require(!isPaused, TRANSFERS_DISABLED);\r\n    super._transferFrom(_from, _to, _tokenId);\r\n  }\r\n}\r\n\r\ncontract XcertCustom is XcertToken {\r\n\r\n  \r\n  uint8 constant ABILITY_NONE = 0;\r\n  uint16 constant ABILITY_ALL = 2047; \r\n\r\n  \r\n  constructor(\r\n    string memory _name,\r\n    string memory _symbol,\r\n    string memory _uriPrefix,\r\n    string memory _uriPostfix,\r\n    bytes32 _schemaURIIntegrityDigest,\r\n    bytes4[] memory _capabilities,\r\n    address[6] memory _addresses\r\n  )\r\n    public\r\n  {\r\n    nftName = _name;\r\n    nftSymbol = _symbol;\r\n    uriPrefix = _uriPrefix;\r\n    uriPostfix = _uriPostfix;\r\n    schemaURIIntegrityDigest = _schemaURIIntegrityDigest;\r\n    for(uint256 i = 0; i < _capabilities.length; i++)\r\n    {\r\n      supportedInterfaces[_capabilities[i]] = true;\r\n    }\r\n    addressToAbility[_addresses[1]] = ABILITY_CREATE_ASSET; \r\n    \r\n    addressToAbility[_addresses[2]] = ABILITY_UPDATE_ASSET_URI_INTEGRITY_DIGEST; \r\n    \r\n    addressToAbility[_addresses[3]] = SUPER_ABILITY; \r\n    \r\n    addressToAbility[msg.sender] = ABILITY_NONE;\r\n    addressToAbility[_addresses[0]] = ABILITY_ALL; \r\n    ownerToOperators[_addresses[0]][_addresses[4]] = true; \r\n    \r\n    ownerToOperators[_addresses[0]][_addresses[5]] = true; \r\n  }\r\n\r\n}\r\n\r\ncontract XcertDeployProxy {\r\n  \r\n  function deploy(\r\n    string memory _name,\r\n    string memory _symbol,\r\n    string memory _uriPrefix,\r\n    string memory _uriPostfix,\r\n    bytes32 _schemaURIIntegrityDigest,\r\n    bytes4[] memory _capabilities,\r\n    address[6] memory _addresses\r\n  )\r\n    public\r\n    returns (address xcert)\r\n  {\r\n    xcert = address(\r\n      new XcertCustom(\r\n        _name, _symbol, _uriPrefix, _uriPostfix, _schemaURIIntegrityDigest, _capabilities, _addresses\r\n      )\r\n    );\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_uriPrefix\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_uriPostfix\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"_schemaURIIntegrityDigest\",\"type\":\"bytes32\"},{\"internalType\":\"bytes4[]\",\"name\":\"_capabilities\",\"type\":\"bytes4[]\"},{\"internalType\":\"address[6]\",\"name\":\"_addresses\",\"type\":\"address[6]\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"xcert\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"XcertDeployProxy","CompilerVersion":"v0.6.1+commit.e6f7d5a4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"ipfs://b3fdccd7bc05662526714ac50b5ac7fb059f41c9177ef2cee66c141b0c3f87a9"}]}