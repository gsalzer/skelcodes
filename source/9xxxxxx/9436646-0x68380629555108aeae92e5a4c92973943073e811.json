{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n* Commit sha: fb3871bb35402a3e08487f77180c9b36d48d9f12\r\n* GitHub repository: https://github.com/aragonone/court-registry-migrator\r\n**/\r\n\r\n// File: @aragon/court/contracts/lib/os/ERC20.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/token/ERC20.sol\r\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function balanceOf(address _who) public view returns (uint256);\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// File: @aragon/court/contracts/lib/os/SafeERC20.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/SafeERC20.sol\r\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\nlibrary SafeERC20 {\r\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\r\n    // https://github.com/ethereum/solidity/issues/3544\r\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\r\n\r\n    /**\r\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\r\n    *      Note that this makes an external call to the token.\r\n    */\r\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\r\n        bytes memory transferCallData = abi.encodeWithSelector(\r\n            TRANSFER_SELECTOR,\r\n            _to,\r\n            _amount\r\n        );\r\n        return invokeAndCheckSuccess(address(_token), transferCallData);\r\n    }\r\n\r\n    /**\r\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\r\n    *      Note that this makes an external call to the token.\r\n    */\r\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\r\n        bytes memory transferFromCallData = abi.encodeWithSelector(\r\n            _token.transferFrom.selector,\r\n            _from,\r\n            _to,\r\n            _amount\r\n        );\r\n        return invokeAndCheckSuccess(address(_token), transferFromCallData);\r\n    }\r\n\r\n    /**\r\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\r\n    *      Note that this makes an external call to the token.\r\n    */\r\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\r\n        bytes memory approveCallData = abi.encodeWithSelector(\r\n            _token.approve.selector,\r\n            _spender,\r\n            _amount\r\n        );\r\n        return invokeAndCheckSuccess(address(_token), approveCallData);\r\n    }\r\n\r\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata) private returns (bool) {\r\n        bool ret;\r\n        assembly {\r\n            let ptr := mload(0x40)    // free memory pointer\r\n\r\n            let success := call(\r\n                gas,                  // forward all gas\r\n                _addr,                // address\r\n                0,                    // no value\r\n                add(_calldata, 0x20), // calldata start\r\n                mload(_calldata),     // calldata length\r\n                ptr,                  // write output over free memory\r\n                0x20                  // uint256 return\r\n            )\r\n\r\n            if gt(success, 0) {\r\n            // Check number of bytes returned from last function call\r\n                switch returndatasize\r\n\r\n                // No bytes returned: assume success\r\n                case 0 {\r\n                    ret := 1\r\n                }\r\n\r\n                // 32 bytes returned: check if non-zero\r\n                case 0x20 {\r\n                // Only return success if returned data was true\r\n                // Already have output in ptr\r\n                    ret := eq(mload(ptr), 1)\r\n                }\r\n\r\n                // Not sure what was returned: don't mark as success\r\n                default { }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n\r\n// File: @aragon/court/contracts/lib/os/SafeMath.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/math/SafeMath.sol\r\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\r\n\r\npragma solidity >=0.4.24 <0.6.0;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    string private constant ERROR_ADD_OVERFLOW = \"MATH_ADD_OVERFLOW\";\r\n    string private constant ERROR_SUB_UNDERFLOW = \"MATH_SUB_UNDERFLOW\";\r\n    string private constant ERROR_MUL_OVERFLOW = \"MATH_MUL_OVERFLOW\";\r\n    string private constant ERROR_DIV_ZERO = \"MATH_DIV_ZERO\";\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a, ERROR_ADD_OVERFLOW);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, ERROR_DIV_ZERO);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @aragon/court/contracts/registry/IJurorsRegistry.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\ninterface IJurorsRegistry {\r\n\r\n    /**\r\n    * @dev Assign a requested amount of juror tokens to a juror\r\n    * @param _juror Juror to add an amount of tokens to\r\n    * @param _amount Amount of tokens to be added to the available balance of a juror\r\n    */\r\n    function assignTokens(address _juror, uint256 _amount) external;\r\n\r\n    /**\r\n    * @dev Burn a requested amount of juror tokens\r\n    * @param _amount Amount of tokens to be burned\r\n    */\r\n    function burnTokens(uint256 _amount) external;\r\n\r\n    /**\r\n    * @dev Draft a set of jurors based on given requirements for a term id\r\n    * @param _params Array containing draft requirements:\r\n    *        0. bytes32 Term randomness\r\n    *        1. uint256 Dispute id\r\n    *        2. uint64  Current term id\r\n    *        3. uint256 Number of seats already filled\r\n    *        4. uint256 Number of seats left to be filled\r\n    *        5. uint64  Number of jurors required for the draft\r\n    *        6. uint16  Permyriad of the minimum active balance to be locked for the draft\r\n    *\r\n    * @return jurors List of jurors selected for the draft\r\n    * @return length Size of the list of the draft result\r\n    */\r\n    function draft(uint256[7] calldata _params) external returns (address[] memory jurors, uint256 length);\r\n\r\n    /**\r\n    * @dev Slash a set of jurors based on their votes compared to the winning ruling\r\n    * @param _termId Current term id\r\n    * @param _jurors List of juror addresses to be slashed\r\n    * @param _lockedAmounts List of amounts locked for each corresponding juror that will be either slashed or returned\r\n    * @param _rewardedJurors List of booleans to tell whether a juror's active balance has to be slashed or not\r\n    * @return Total amount of slashed tokens\r\n    */\r\n    function slashOrUnlock(uint64 _termId, address[] calldata _jurors, uint256[] calldata _lockedAmounts, bool[] calldata _rewardedJurors)\r\n        external\r\n        returns (uint256 collectedTokens);\r\n\r\n    /**\r\n    * @dev Try to collect a certain amount of tokens from a juror for the next term\r\n    * @param _juror Juror to collect the tokens from\r\n    * @param _amount Amount of tokens to be collected from the given juror and for the requested term id\r\n    * @param _termId Current term id\r\n    * @return True if the juror has enough unlocked tokens to be collected for the requested term, false otherwise\r\n    */\r\n    function collectTokens(address _juror, uint256 _amount, uint64 _termId) external returns (bool);\r\n\r\n    /**\r\n    * @dev Lock a juror's withdrawals until a certain term ID\r\n    * @param _juror Address of the juror to be locked\r\n    * @param _termId Term ID until which the juror's withdrawals will be locked\r\n    */\r\n    function lockWithdrawals(address _juror, uint64 _termId) external;\r\n\r\n    /**\r\n    * @dev Tell the active balance of a juror for a given term id\r\n    * @param _juror Address of the juror querying the active balance of\r\n    * @param _termId Term ID querying the active balance for\r\n    * @return Amount of active tokens for juror in the requested past term id\r\n    */\r\n    function activeBalanceOfAt(address _juror, uint64 _termId) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Tell the total amount of active juror tokens at the given term id\r\n    * @param _termId Term ID querying the total active balance for\r\n    * @return Total amount of active juror tokens at the given term id\r\n    */\r\n    function totalActiveBalanceAt(uint64 _termId) external view returns (uint256);\r\n}\r\n\r\n// File: @aragon/court/contracts/lib/BytesHelpers.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\nlibrary BytesHelpers {\r\n    function toBytes4(bytes memory _self) internal pure returns (bytes4 result) {\r\n        if (_self.length < 4) {\r\n            return bytes4(0);\r\n        }\r\n\r\n        assembly { result := mload(add(_self, 0x20)) }\r\n    }\r\n}\r\n\r\n// File: @aragon/court/contracts/lib/Checkpointing.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n/**\r\n* @title Checkpointing - Library to handle a historic set of numeric values\r\n*/\r\nlibrary Checkpointing {\r\n    uint256 private constant MAX_UINT192 = uint256(uint192(-1));\r\n\r\n    string private constant ERROR_VALUE_TOO_BIG = \"CHECKPOINT_VALUE_TOO_BIG\";\r\n    string private constant ERROR_CANNOT_ADD_PAST_VALUE = \"CHECKPOINT_CANNOT_ADD_PAST_VALUE\";\r\n\r\n    /**\r\n    * @dev To specify a value at a given point in time, we need to store two values:\r\n    *      - `time`: unit-time value to denote the first time when a value was registered\r\n    *      - `value`: a positive numeric value to registered at a given point in time\r\n    *\r\n    *      Note that `time` does not need to refer necessarily to a timestamp value, any time unit could be used\r\n    *      for it like block numbers, terms, etc.\r\n    */\r\n    struct Checkpoint {\r\n        uint64 time;\r\n        uint192 value;\r\n    }\r\n\r\n    /**\r\n    * @dev A history simply denotes a list of checkpoints\r\n    */\r\n    struct History {\r\n        Checkpoint[] history;\r\n    }\r\n\r\n    /**\r\n    * @dev Add a new value to a history for a given point in time. This function does not allow to add values previous\r\n    *      to the latest registered value, if the value willing to add corresponds to the latest registered value, it\r\n    *      will be updated.\r\n    * @param self Checkpoints history to be altered\r\n    * @param _time Point in time to register the given value\r\n    * @param _value Numeric value to be registered at the given point in time\r\n    */\r\n    function add(History storage self, uint64 _time, uint256 _value) internal {\r\n        require(_value <= MAX_UINT192, ERROR_VALUE_TOO_BIG);\r\n        _add192(self, _time, uint192(_value));\r\n    }\r\n\r\n    /**\r\n    * @dev Fetch the latest registered value of history, it will return zero if there was no value registered\r\n    * @param self Checkpoints history to be queried\r\n    */\r\n    function getLast(History storage self) internal view returns (uint256) {\r\n        uint256 length = self.history.length;\r\n        if (length > 0) {\r\n            return uint256(self.history[length - 1].value);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n    * @dev Fetch the most recent registered past value of a history based on a given point in time that is not known\r\n    *      how recent it is beforehand. It will return zero if there is no registered value or if given time is\r\n    *      previous to the first registered value.\r\n    *      It uses a binary search.\r\n    * @param self Checkpoints history to be queried\r\n    * @param _time Point in time to query the most recent registered past value of\r\n    */\r\n    function get(History storage self, uint64 _time) internal view returns (uint256) {\r\n        return _binarySearch(self, _time);\r\n    }\r\n\r\n    /**\r\n    * @dev Fetch the most recent registered past value of a history based on a given point in time. It will return zero\r\n    *      if there is no registered value or if given time is previous to the first registered value.\r\n    *      It uses a linear search starting from the end.\r\n    * @param self Checkpoints history to be queried\r\n    * @param _time Point in time to query the most recent registered past value of\r\n    */\r\n    function getRecent(History storage self, uint64 _time) internal view returns (uint256) {\r\n        return _backwardsLinearSearch(self, _time);\r\n    }\r\n\r\n    /**\r\n    * @dev Private function to add a new value to a history for a given point in time. This function does not allow to\r\n    *      add values previous to the latest registered value, if the value willing to add corresponds to the latest\r\n    *      registered value, it will be updated.\r\n    * @param self Checkpoints history to be altered\r\n    * @param _time Point in time to register the given value\r\n    * @param _value Numeric value to be registered at the given point in time\r\n    */\r\n    function _add192(History storage self, uint64 _time, uint192 _value) private {\r\n        uint256 length = self.history.length;\r\n        if (length == 0 || self.history[self.history.length - 1].time < _time) {\r\n            // If there was no value registered or the given point in time is after the latest registered value,\r\n            // we can insert it to the history directly.\r\n            self.history.push(Checkpoint(_time, _value));\r\n        } else {\r\n            // If the point in time given for the new value is not after the latest registered value, we must ensure\r\n            // we are only trying to update the latest value, otherwise we would be changing past data.\r\n            Checkpoint storage currentCheckpoint = self.history[length - 1];\r\n            require(_time == currentCheckpoint.time, ERROR_CANNOT_ADD_PAST_VALUE);\r\n            currentCheckpoint.value = _value;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Private function to execute a backwards linear search to find the most recent registered past value of a\r\n    *      history based on a given point in time. It will return zero if there is no registered value or if given time\r\n    *      is previous to the first registered value. Note that this function will be more suitable when we already know\r\n    *      that the time used to index the search is recent in the given history.\r\n    * @param self Checkpoints history to be queried\r\n    * @param _time Point in time to query the most recent registered past value of\r\n    */\r\n    function _backwardsLinearSearch(History storage self, uint64 _time) private view returns (uint256) {\r\n        // If there was no value registered for the given history return simply zero\r\n        uint256 length = self.history.length;\r\n        if (length == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 index = length - 1;\r\n        Checkpoint storage checkpoint = self.history[index];\r\n        while (index > 0 && checkpoint.time > _time) {\r\n            index--;\r\n            checkpoint = self.history[index];\r\n        }\r\n\r\n        return checkpoint.time > _time ? 0 : uint256(checkpoint.value);\r\n    }\r\n\r\n    /**\r\n    * @dev Private function execute a binary search to find the most recent registered past value of a history based on\r\n    *      a given point in time. It will return zero if there is no registered value or if given time is previous to\r\n    *      the first registered value. Note that this function will be more suitable when don't know how recent the\r\n    *      time used to index may be.\r\n    * @param self Checkpoints history to be queried\r\n    * @param _time Point in time to query the most recent registered past value of\r\n    */\r\n    function _binarySearch(History storage self, uint64 _time) private view returns (uint256) {\r\n        // If there was no value registered for the given history return simply zero\r\n        uint256 length = self.history.length;\r\n        if (length == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // If the requested time is equal to or after the time of the latest registered value, return latest value\r\n        uint256 lastIndex = length - 1;\r\n        if (_time >= self.history[lastIndex].time) {\r\n            return uint256(self.history[lastIndex].value);\r\n        }\r\n\r\n        // If the requested time is previous to the first registered value, return zero to denote missing checkpoint\r\n        if (_time < self.history[0].time) {\r\n            return 0;\r\n        }\r\n\r\n        // Execute a binary search between the checkpointed times of the history\r\n        uint256 low = 0;\r\n        uint256 high = lastIndex;\r\n\r\n        while (high > low) {\r\n            // No need for SafeMath: for this to overflow array size should be ~2^255\r\n            uint256 mid = (high + low + 1) / 2;\r\n            Checkpoint storage checkpoint = self.history[mid];\r\n            uint64 midTime = checkpoint.time;\r\n\r\n            if (_time > midTime) {\r\n                low = mid;\r\n            } else if (_time < midTime) {\r\n                // No need for SafeMath: high > low >= 0 => high >= 1 => mid >= 1\r\n                high = mid - 1;\r\n            } else {\r\n                return uint256(checkpoint.value);\r\n            }\r\n        }\r\n\r\n        return uint256(self.history[low].value);\r\n    }\r\n}\r\n\r\n// File: @aragon/court/contracts/lib/HexSumTree.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\n/**\r\n* @title HexSumTree - Library to operate checkpointed 16-ary (hex) sum trees.\r\n* @dev A sum tree is a particular case of a tree where the value of a node is equal to the sum of the values of its\r\n*      children. This library provides a set of functions to operate 16-ary sum trees, i.e. trees where every non-leaf\r\n*      node has 16 children and its value is equivalent to the sum of the values of all of them. Additionally, a\r\n*      checkpointed tree means that each time a value on a node is updated, its previous value will be saved to allow\r\n*      accessing historic information.\r\n*\r\n*      Example of a checkpointed binary sum tree:\r\n*\r\n*                                          CURRENT                                      PREVIOUS\r\n*\r\n*             Level 2                        100  ---------------------------------------- 70\r\n*                                       ______|_______                               ______|_______\r\n*                                      /              \\                             /              \\\r\n*             Level 1                 34              66 ------------------------- 23              47\r\n*                                _____|_____      _____|_____                 _____|_____      _____|_____\r\n*                               /           \\    /           \\               /           \\    /           \\\r\n*             Level 0          22           12  53           13 ----------- 22            1  17           30\r\n*\r\n*/\r\nlibrary HexSumTree {\r\n    using SafeMath for uint256;\r\n    using Checkpointing for Checkpointing.History;\r\n\r\n    string private constant ERROR_UPDATE_OVERFLOW = \"SUM_TREE_UPDATE_OVERFLOW\";\r\n    string private constant ERROR_KEY_DOES_NOT_EXIST = \"SUM_TREE_KEY_DOES_NOT_EXIST\";\r\n    string private constant ERROR_SEARCH_OUT_OF_BOUNDS = \"SUM_TREE_SEARCH_OUT_OF_BOUNDS\";\r\n    string private constant ERROR_MISSING_SEARCH_VALUES = \"SUM_TREE_MISSING_SEARCH_VALUES\";\r\n\r\n    // Constants used to perform tree computations\r\n    // To change any the following constants, the following relationship must be kept: 2^BITS_IN_NIBBLE = CHILDREN\r\n    // The max depth of the tree will be given by: BITS_IN_NIBBLE * MAX_DEPTH = 256 (so in this case it's 64)\r\n    uint256 private constant CHILDREN = 16;\r\n    uint256 private constant BITS_IN_NIBBLE = 4;\r\n\r\n    // All items are leaves, inserted at height or level zero. The root height will be increasing as new levels are inserted in the tree.\r\n    uint256 private constant ITEMS_LEVEL = 0;\r\n\r\n    // Tree nodes are identified with a 32-bytes length key. Leaves are identified with consecutive incremental keys\r\n    // starting with 0x0000000000000000000000000000000000000000000000000000000000000000, while non-leaf nodes' keys\r\n    // are computed based on their level and their children keys.\r\n    uint256 private constant BASE_KEY = 0;\r\n\r\n    // Timestamp used to checkpoint the first value of the tree height during initialization\r\n    uint64 private constant INITIALIZATION_INITIAL_TIME = uint64(0);\r\n\r\n    /**\r\n    * @dev The tree is stored using the following structure:\r\n    *      - nodes: A mapping indexed by a pair (level, key) with a history of the values for each node (level -> key -> value).\r\n    *      - height: A history of the heights of the tree. Minimum height is 1, a root with 16 children.\r\n    *      - nextKey: The next key to be used to identify the next new value that will be inserted into the tree.\r\n    */\r\n    struct Tree {\r\n        uint256 nextKey;\r\n        Checkpointing.History height;\r\n        mapping (uint256 => mapping (uint256 => Checkpointing.History)) nodes;\r\n    }\r\n\r\n    /**\r\n    * @dev Search params to traverse the tree caching previous results:\r\n    *      - time: Point in time to query the values being searched, this value shouldn't change during a search\r\n    *      - level: Level being analyzed for the search, it starts at the level under the root and decrements till the leaves\r\n    *      - parentKey: Key of the parent of the nodes being analyzed at the given level for the search\r\n    *      - foundValues: Number of values in the list being searched that were already found, it will go from 0 until the size of the list\r\n    *      - visitedTotal: Total sum of values that were already visited during the search, it will go from 0 until the tree total\r\n    */\r\n    struct SearchParams {\r\n        uint64 time;\r\n        uint256 level;\r\n        uint256 parentKey;\r\n        uint256 foundValues;\r\n        uint256 visitedTotal;\r\n    }\r\n\r\n    /**\r\n    * @dev Initialize tree setting the next key and first height checkpoint\r\n    */\r\n    function init(Tree storage self) internal {\r\n        self.height.add(INITIALIZATION_INITIAL_TIME, ITEMS_LEVEL + 1);\r\n        self.nextKey = BASE_KEY;\r\n    }\r\n\r\n    /**\r\n    * @dev Insert a new item to the tree at given point in time\r\n    * @param _time Point in time to register the given value\r\n    * @param _value New numeric value to be added to the tree\r\n    * @return Unique key identifying the new value inserted\r\n    */\r\n    function insert(Tree storage self, uint64 _time, uint256 _value) internal returns (uint256) {\r\n        // As the values are always stored in the leaves of the tree (level 0), the key to index each of them will be\r\n        // always incrementing, starting from zero. Add a new level if necessary.\r\n        uint256 key = self.nextKey++;\r\n        _addLevelIfNecessary(self, key, _time);\r\n\r\n        // If the new value is not zero, first set the value of the new leaf node, then add a new level at the top of\r\n        // the tree if necessary, and finally update sums cached in all the non-leaf nodes.\r\n        if (_value > 0) {\r\n            _add(self, ITEMS_LEVEL, key, _time, _value);\r\n            _updateSums(self, key, _time, _value, true);\r\n        }\r\n        return key;\r\n    }\r\n\r\n    /**\r\n    * @dev Set the value of a leaf node indexed by its key at given point in time\r\n    * @param _time Point in time to set the given value\r\n    * @param _key Key of the leaf node to be set in the tree\r\n    * @param _value New numeric value to be set for the given key\r\n    */\r\n    function set(Tree storage self, uint256 _key, uint64 _time, uint256 _value) internal {\r\n        require(_key < self.nextKey, ERROR_KEY_DOES_NOT_EXIST);\r\n\r\n        // Set the new value for the requested leaf node\r\n        uint256 lastValue = getItem(self, _key);\r\n        _add(self, ITEMS_LEVEL, _key, _time, _value);\r\n\r\n        // Update sums cached in the non-leaf nodes. Note that overflows are being checked at the end of the whole update.\r\n        if (_value > lastValue) {\r\n            _updateSums(self, _key, _time, _value - lastValue, true);\r\n        } else if (_value < lastValue) {\r\n            _updateSums(self, _key, _time, lastValue - _value, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Update the value of a non-leaf node indexed by its key at given point in time based on a delta\r\n    * @param _key Key of the leaf node to be updated in the tree\r\n    * @param _time Point in time to update the given value\r\n    * @param _delta Numeric delta to update the value of the given key\r\n    * @param _positive Boolean to tell whether the given delta should be added to or subtracted from the current value\r\n    */\r\n    function update(Tree storage self, uint256 _key, uint64 _time, uint256 _delta, bool _positive) internal {\r\n        require(_key < self.nextKey, ERROR_KEY_DOES_NOT_EXIST);\r\n\r\n        // Update the value of the requested leaf node based on the given delta\r\n        uint256 lastValue = getItem(self, _key);\r\n        uint256 newValue = _positive ? lastValue.add(_delta) : lastValue.sub(_delta);\r\n        _add(self, ITEMS_LEVEL, _key, _time, newValue);\r\n\r\n        // Update sums cached in the non-leaf nodes. Note that overflows is being checked at the end of the whole update.\r\n        _updateSums(self, _key, _time, _delta, _positive);\r\n    }\r\n\r\n    /**\r\n    * @dev Search a list of values in the tree at a given point in time. It will return a list with the nearest\r\n    *      high value in case a value cannot be found. This function assumes the given list of given values to be\r\n    *      searched is in ascending order. In case of searching a value out of bounds, it will return zeroed results.\r\n    * @param _values Ordered list of values to be searched in the tree\r\n    * @param _time Point in time to query the values being searched\r\n    * @return keys List of keys found for each requested value in the same order\r\n    * @return values List of node values found for each requested value in the same order\r\n    */\r\n    function search(Tree storage self, uint256[] memory _values, uint64 _time) internal view\r\n        returns (uint256[] memory keys, uint256[] memory values)\r\n    {\r\n        require(_values.length > 0, ERROR_MISSING_SEARCH_VALUES);\r\n\r\n        // Throw out-of-bounds error if there are no items in the tree or the highest value being searched is greater than the total\r\n        uint256 total = getRecentTotalAt(self, _time);\r\n        // No need for SafeMath: positive length of array already checked\r\n        require(total > 0 && total > _values[_values.length - 1], ERROR_SEARCH_OUT_OF_BOUNDS);\r\n\r\n        // Build search params for the first iteration\r\n        uint256 rootLevel = getRecentHeightAt(self, _time);\r\n        SearchParams memory searchParams = SearchParams(_time, rootLevel.sub(1), BASE_KEY, 0, 0);\r\n\r\n        // These arrays will be used to fill in the results. We are passing them as parameters to avoid extra copies\r\n        uint256 length = _values.length;\r\n        keys = new uint256[](length);\r\n        values = new uint256[](length);\r\n        _search(self, _values, searchParams, keys, values);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the sum of the all the items (leaves) stored in the tree, i.e. value of the root of the tree\r\n    */\r\n    function getTotal(Tree storage self) internal view returns (uint256) {\r\n        uint256 rootLevel = getHeight(self);\r\n        return getNode(self, rootLevel, BASE_KEY);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the sum of the all the items (leaves) stored in the tree, i.e. value of the root of the tree, at a given point in time\r\n    *      It uses a binary search for the root node, a linear one for the height.\r\n    * @param _time Point in time to query the sum of all the items (leaves) stored in the tree\r\n    */\r\n    function getTotalAt(Tree storage self, uint64 _time) internal view returns (uint256) {\r\n        uint256 rootLevel = getRecentHeightAt(self, _time);\r\n        return getNodeAt(self, rootLevel, BASE_KEY, _time);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the sum of the all the items (leaves) stored in the tree, i.e. value of the root of the tree, at a given point in time\r\n    *      It uses a linear search starting from the end.\r\n    * @param _time Point in time to query the sum of all the items (leaves) stored in the tree\r\n    */\r\n    function getRecentTotalAt(Tree storage self, uint64 _time) internal view returns (uint256) {\r\n        uint256 rootLevel = getRecentHeightAt(self, _time);\r\n        return getRecentNodeAt(self, rootLevel, BASE_KEY, _time);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the value of a certain leaf indexed by a given key\r\n    * @param _key Key of the leaf node querying the value of\r\n    */\r\n    function getItem(Tree storage self, uint256 _key) internal view returns (uint256) {\r\n        return getNode(self, ITEMS_LEVEL, _key);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the value of a certain leaf indexed by a given key at a given point in time\r\n    *      It uses a binary search.\r\n    * @param _key Key of the leaf node querying the value of\r\n    * @param _time Point in time to query the value of the requested leaf\r\n    */\r\n    function getItemAt(Tree storage self, uint256 _key, uint64 _time) internal view returns (uint256) {\r\n        return getNodeAt(self, ITEMS_LEVEL, _key, _time);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the value of a certain node indexed by a given (level,key) pair\r\n    * @param _level Level of the node querying the value of\r\n    * @param _key Key of the node querying the value of\r\n    */\r\n    function getNode(Tree storage self, uint256 _level, uint256 _key) internal view returns (uint256) {\r\n        return self.nodes[_level][_key].getLast();\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the value of a certain node indexed by a given (level,key) pair at a given point in time\r\n    *      It uses a binary search.\r\n    * @param _level Level of the node querying the value of\r\n    * @param _key Key of the node querying the value of\r\n    * @param _time Point in time to query the value of the requested node\r\n    */\r\n    function getNodeAt(Tree storage self, uint256 _level, uint256 _key, uint64 _time) internal view returns (uint256) {\r\n        return self.nodes[_level][_key].get(_time);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the value of a certain node indexed by a given (level,key) pair at a given point in time\r\n    *      It uses a linear search starting from the end.\r\n    * @param _level Level of the node querying the value of\r\n    * @param _key Key of the node querying the value of\r\n    * @param _time Point in time to query the value of the requested node\r\n    */\r\n    function getRecentNodeAt(Tree storage self, uint256 _level, uint256 _key, uint64 _time) internal view returns (uint256) {\r\n        return self.nodes[_level][_key].getRecent(_time);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the height of the tree\r\n    */\r\n    function getHeight(Tree storage self) internal view returns (uint256) {\r\n        return self.height.getLast();\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the height of the tree at a given point in time\r\n    *      It uses a linear search starting from the end.\r\n    * @param _time Point in time to query the height of the tree\r\n    */\r\n    function getRecentHeightAt(Tree storage self, uint64 _time) internal view returns (uint256) {\r\n        return self.height.getRecent(_time);\r\n    }\r\n\r\n    /**\r\n    * @dev Private function to update the values of all the ancestors of the given leaf node based on the delta updated\r\n    * @param _key Key of the leaf node to update the ancestors of\r\n    * @param _time Point in time to update the ancestors' values of the given leaf node\r\n    * @param _delta Numeric delta to update the ancestors' values of the given leaf node\r\n    * @param _positive Boolean to tell whether the given delta should be added to or subtracted from ancestors' values\r\n    */\r\n    function _updateSums(Tree storage self, uint256 _key, uint64 _time, uint256 _delta, bool _positive) private {\r\n        uint256 mask = uint256(-1);\r\n        uint256 ancestorKey = _key;\r\n        uint256 currentHeight = getHeight(self);\r\n        for (uint256 level = ITEMS_LEVEL + 1; level <= currentHeight; level++) {\r\n            // Build a mask to get the key of the ancestor at a certain level. For example:\r\n            // Level  0: leaves don't have children\r\n            // Level  1: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0 (up to 16 leaves)\r\n            // Level  2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00 (up to 32 leaves)\r\n            // ...\r\n            // Level 63: 0x0000000000000000000000000000000000000000000000000000000000000000 (up to 16^64 leaves - tree max height)\r\n            mask = mask << BITS_IN_NIBBLE;\r\n\r\n            // The key of the ancestor at that level \"i\" is equivalent to the \"(64 - i)-th\" most significant nibbles\r\n            // of the ancestor's key of the previous level \"i - 1\". Thus, we can compute the key of an ancestor at a\r\n            // certain level applying the mask to the ancestor's key of the previous level. Note that for the first\r\n            // iteration, the key of the ancestor of the previous level is simply the key of the leaf being updated.\r\n            ancestorKey = ancestorKey & mask;\r\n\r\n            // Update value\r\n            uint256 lastValue = getNode(self, level, ancestorKey);\r\n            uint256 newValue = _positive ? lastValue.add(_delta) : lastValue.sub(_delta);\r\n            _add(self, level, ancestorKey, _time, newValue);\r\n        }\r\n\r\n        // Check if there was an overflow. Note that we only need to check the value stored in the root since the\r\n        // sum only increases going up through the tree.\r\n        require(!_positive || getNode(self, currentHeight, ancestorKey) >= _delta, ERROR_UPDATE_OVERFLOW);\r\n    }\r\n\r\n    /**\r\n    * @dev Private function to add a new level to the tree based on a new key that will be inserted\r\n    * @param _newKey New key willing to be inserted in the tree\r\n    * @param _time Point in time when the new key will be inserted\r\n    */\r\n    function _addLevelIfNecessary(Tree storage self, uint256 _newKey, uint64 _time) private {\r\n        uint256 currentHeight = getHeight(self);\r\n        if (_shouldAddLevel(currentHeight, _newKey)) {\r\n            // Max height allowed for the tree is 64 since we are using node keys of 32 bytes. However, note that we\r\n            // are not checking if said limit has been hit when inserting new leaves to the tree, for the purpose of\r\n            // this system having 2^256 items inserted is unrealistic.\r\n            uint256 newHeight = currentHeight + 1;\r\n            uint256 rootValue = getNode(self, currentHeight, BASE_KEY);\r\n            _add(self, newHeight, BASE_KEY, _time, rootValue);\r\n            self.height.add(_time, newHeight);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Private function to register a new value in the history of a node at a given point in time\r\n    * @param _level Level of the node to add a new value at a given point in time to\r\n    * @param _key Key of the node to add a new value at a given point in time to\r\n    * @param _time Point in time to register a value for the given node\r\n    * @param _value Numeric value to be registered for the given node at a given point in time\r\n    */\r\n    function _add(Tree storage self, uint256 _level, uint256 _key, uint64 _time, uint256 _value) private {\r\n        self.nodes[_level][_key].add(_time, _value);\r\n    }\r\n\r\n    /**\r\n    * @dev Recursive pre-order traversal function\r\n    *      Every time it checks a node, it traverses the input array to find the initial subset of elements that are\r\n    *      below its accumulated value and passes that sub-array to the next iteration. Actually, the array is always\r\n    *      the same, to avoid making extra copies, it just passes the number of values already found , to avoid\r\n    *      checking values that went through a different branch. The same happens with the result lists of keys and\r\n    *      values, these are the same on every recursion step. The visited total is carried over each iteration to\r\n    *      avoid having to subtract all elements in the array.\r\n    * @param _values Ordered list of values to be searched in the tree\r\n    * @param _params Search parameters for the current recursive step\r\n    * @param _resultKeys List of keys found for each requested value in the same order\r\n    * @param _resultValues List of node values found for each requested value in the same order\r\n    */\r\n    function _search(\r\n        Tree storage self,\r\n        uint256[] memory _values,\r\n        SearchParams memory _params,\r\n        uint256[] memory _resultKeys,\r\n        uint256[] memory _resultValues\r\n    )\r\n        private\r\n        view\r\n    {\r\n        uint256 levelKeyLessSignificantNibble = _params.level.mul(BITS_IN_NIBBLE);\r\n\r\n        for (uint256 childNumber = 0; childNumber < CHILDREN; childNumber++) {\r\n            // Return if we already found enough values\r\n            if (_params.foundValues >= _values.length) {\r\n                break;\r\n            }\r\n\r\n            // Build child node key shifting the child number to the position of the less significant nibble of\r\n            // the keys for the level being analyzed, and adding it to the key of the parent node. For example,\r\n            // for a tree with height 5, if we are checking the children of the second node of the level 3, whose\r\n            // key is    0x0000000000000000000000000000000000000000000000000000000000001000, its children keys are:\r\n            // Child  0: 0x0000000000000000000000000000000000000000000000000000000000001000\r\n            // Child  1: 0x0000000000000000000000000000000000000000000000000000000000001100\r\n            // Child  2: 0x0000000000000000000000000000000000000000000000000000000000001200\r\n            // ...\r\n            // Child 15: 0x0000000000000000000000000000000000000000000000000000000000001f00\r\n            uint256 childNodeKey = _params.parentKey.add(childNumber << levelKeyLessSignificantNibble);\r\n            uint256 childNodeValue = getRecentNodeAt(self, _params.level, childNodeKey, _params.time);\r\n\r\n            // Check how many values belong to the subtree of this node. As they are ordered, it will be a contiguous\r\n            // subset starting from the beginning, so we only need to know the length of that subset.\r\n            uint256 newVisitedTotal = _params.visitedTotal.add(childNodeValue);\r\n            uint256 subtreeIncludedValues = _getValuesIncludedInSubtree(_values, _params.foundValues, newVisitedTotal);\r\n\r\n            // If there are some values included in the subtree of the child node, visit them\r\n            if (subtreeIncludedValues > 0) {\r\n                // If the child node being analyzed is a leaf, add it to the list of results a number of times equals\r\n                // to the number of values that were included in it. Otherwise, descend one level.\r\n                if (_params.level == ITEMS_LEVEL) {\r\n                    _copyFoundNode(_params.foundValues, subtreeIncludedValues, childNodeKey, _resultKeys, childNodeValue, _resultValues);\r\n                } else {\r\n                    SearchParams memory nextLevelParams = SearchParams(\r\n                        _params.time,\r\n                        _params.level - 1, // No need for SafeMath: we already checked above that the level being checked is greater than zero\r\n                        childNodeKey,\r\n                        _params.foundValues,\r\n                        _params.visitedTotal\r\n                    );\r\n                    _search(self, _values, nextLevelParams, _resultKeys, _resultValues);\r\n                }\r\n                // Update the number of values that were already found\r\n                _params.foundValues = _params.foundValues.add(subtreeIncludedValues);\r\n            }\r\n            // Update the visited total for the next node in this level\r\n            _params.visitedTotal = newVisitedTotal;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Private function to check if a new key can be added to the tree based on the current height of the tree\r\n    * @param _currentHeight Current height of the tree to check if it supports adding the given key\r\n    * @param _newKey Key willing to be added to the tree with the given current height\r\n    * @return True if the current height of the tree should be increased to add the new key, false otherwise.\r\n    */\r\n    function _shouldAddLevel(uint256 _currentHeight, uint256 _newKey) private pure returns (bool) {\r\n        // Build a mask that will match all the possible keys for the given height. For example:\r\n        // Height  1: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0 (up to 16 keys)\r\n        // Height  2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00 (up to 32 keys)\r\n        // ...\r\n        // Height 64: 0x0000000000000000000000000000000000000000000000000000000000000000 (up to 16^64 keys - tree max height)\r\n        uint256 shift = _currentHeight.mul(BITS_IN_NIBBLE);\r\n        uint256 mask = uint256(-1) << shift;\r\n\r\n        // Check if the given key can be represented in the tree with the current given height using the mask.\r\n        return (_newKey & mask) != 0;\r\n    }\r\n\r\n    /**\r\n    * @dev Private function to tell how many values of a list can be found in a subtree\r\n    * @param _values List of values being searched in ascending order\r\n    * @param _foundValues Number of values that were already found and should be ignore\r\n    * @param _subtreeTotal Total sum of the given subtree to check the numbers that are included in it\r\n    * @return Number of values in the list that are included in the given subtree\r\n    */\r\n    function _getValuesIncludedInSubtree(uint256[] memory _values, uint256 _foundValues, uint256 _subtreeTotal) private pure returns (uint256) {\r\n        // Look for all the values that can be found in the given subtree\r\n        uint256 i = _foundValues;\r\n        while (i < _values.length && _values[i] < _subtreeTotal) {\r\n            i++;\r\n        }\r\n        return i - _foundValues;\r\n    }\r\n\r\n    /**\r\n    * @dev Private function to copy a node a given number of times to a results list. This function assumes the given\r\n    *      results list have enough size to support the requested copy.\r\n    * @param _from Index of the results list to start copying the given node\r\n    * @param _times Number of times the given node will be copied\r\n    * @param _key Key of the node to be copied\r\n    * @param _resultKeys Lists of key results to copy the given node key to\r\n    * @param _value Value of the node to be copied\r\n    * @param _resultValues Lists of value results to copy the given node value to\r\n    */\r\n    function _copyFoundNode(\r\n        uint256 _from,\r\n        uint256 _times,\r\n        uint256 _key,\r\n        uint256[] memory _resultKeys,\r\n        uint256 _value,\r\n        uint256[] memory _resultValues\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        for (uint256 i = 0; i < _times; i++) {\r\n            _resultKeys[_from + i] = _key;\r\n            _resultValues[_from + i] = _value;\r\n        }\r\n    }\r\n}\r\n\r\n// File: @aragon/court/contracts/lib/PctHelpers.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\nlibrary PctHelpers {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal constant PCT_BASE = 10000; // ‱ (1 / 10,000)\r\n\r\n    function isValid(uint16 _pct) internal pure returns (bool) {\r\n        return _pct <= PCT_BASE;\r\n    }\r\n\r\n    function pct(uint256 self, uint16 _pct) internal pure returns (uint256) {\r\n        return self.mul(uint256(_pct)) / PCT_BASE;\r\n    }\r\n\r\n    function pct256(uint256 self, uint256 _pct) internal pure returns (uint256) {\r\n        return self.mul(_pct) / PCT_BASE;\r\n    }\r\n\r\n    function pctIncrease(uint256 self, uint16 _pct) internal pure returns (uint256) {\r\n        // No need for SafeMath: for addition note that `PCT_BASE` is lower than (2^256 - 2^16)\r\n        return self.mul(PCT_BASE + uint256(_pct)) / PCT_BASE;\r\n    }\r\n}\r\n\r\n// File: @aragon/court/contracts/lib/JurorsTreeSortition.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\n/**\r\n* @title JurorsTreeSortition - Library to perform jurors sortition over a `HexSumTree`\r\n*/\r\nlibrary JurorsTreeSortition {\r\n    using SafeMath for uint256;\r\n    using HexSumTree for HexSumTree.Tree;\r\n\r\n    string private constant ERROR_INVALID_INTERVAL_SEARCH = \"TREE_INVALID_INTERVAL_SEARCH\";\r\n    string private constant ERROR_SORTITION_LENGTHS_MISMATCH = \"TREE_SORTITION_LENGTHS_MISMATCH\";\r\n\r\n    /**\r\n    * @dev Search random items in the tree based on certain restrictions\r\n    * @param _termRandomness Randomness to compute the seed for the draft\r\n    * @param _disputeId Identification number of the dispute to draft jurors for\r\n    * @param _termId Current term when the draft is being computed\r\n    * @param _selectedJurors Number of jurors already selected for the draft\r\n    * @param _batchRequestedJurors Number of jurors to be selected in the given batch of the draft\r\n    * @param _roundRequestedJurors Total number of jurors requested to be drafted\r\n    * @param _sortitionIteration Number of sortitions already performed for the given draft\r\n    * @return jurorsIds List of juror ids obtained based on the requested search\r\n    * @return jurorsBalances List of active balances for each juror obtained based on the requested search\r\n    */\r\n    function batchedRandomSearch(\r\n        HexSumTree.Tree storage tree,\r\n        bytes32 _termRandomness,\r\n        uint256 _disputeId,\r\n        uint64 _termId,\r\n        uint256 _selectedJurors,\r\n        uint256 _batchRequestedJurors,\r\n        uint256 _roundRequestedJurors,\r\n        uint256 _sortitionIteration\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256[] memory jurorsIds, uint256[] memory jurorsBalances)\r\n    {\r\n        (uint256 low, uint256 high) = getSearchBatchBounds(tree, _termId, _selectedJurors, _batchRequestedJurors, _roundRequestedJurors);\r\n        uint256[] memory balances = _computeSearchRandomBalances(\r\n            _termRandomness,\r\n            _disputeId,\r\n            _sortitionIteration,\r\n            _batchRequestedJurors,\r\n            low,\r\n            high\r\n        );\r\n\r\n        (jurorsIds, jurorsBalances) = tree.search(balances, _termId);\r\n\r\n        require(jurorsIds.length == jurorsBalances.length, ERROR_SORTITION_LENGTHS_MISMATCH);\r\n        require(jurorsIds.length == _batchRequestedJurors, ERROR_SORTITION_LENGTHS_MISMATCH);\r\n    }\r\n\r\n    /**\r\n    * @dev Get the bounds for a draft batch based on the active balances of the jurors\r\n    * @param _termId Term ID of the active balances that will be used to compute the boundaries\r\n    * @param _selectedJurors Number of jurors already selected for the draft\r\n    * @param _batchRequestedJurors Number of jurors to be selected in the given batch of the draft\r\n    * @param _roundRequestedJurors Total number of jurors requested to be drafted\r\n    * @return low Low bound to be used for the sortition to draft the requested number of jurors for the given batch\r\n    * @return high High bound to be used for the sortition to draft the requested number of jurors for the given batch\r\n    */\r\n    function getSearchBatchBounds(\r\n        HexSumTree.Tree storage tree,\r\n        uint64 _termId,\r\n        uint256 _selectedJurors,\r\n        uint256 _batchRequestedJurors,\r\n        uint256 _roundRequestedJurors\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256 low, uint256 high)\r\n    {\r\n        uint256 totalActiveBalance = tree.getRecentTotalAt(_termId);\r\n        low = _selectedJurors.mul(totalActiveBalance).div(_roundRequestedJurors);\r\n\r\n        uint256 newSelectedJurors = _selectedJurors.add(_batchRequestedJurors);\r\n        high = newSelectedJurors.mul(totalActiveBalance).div(_roundRequestedJurors);\r\n    }\r\n\r\n    /**\r\n    * @dev Get a random list of active balances to be searched in the jurors tree for a given draft batch\r\n    * @param _termRandomness Randomness to compute the seed for the draft\r\n    * @param _disputeId Identification number of the dispute to draft jurors for (for randomness)\r\n    * @param _sortitionIteration Number of sortitions already performed for the given draft (for randomness)\r\n    * @param _batchRequestedJurors Number of jurors to be selected in the given batch of the draft\r\n    * @param _lowBatchBound Low bound to be used for the sortition batch to draft the requested number of jurors\r\n    * @param _highBatchBound High bound to be used for the sortition batch to draft the requested number of jurors\r\n    * @return Random list of active balances to be searched in the jurors tree for the given draft batch\r\n    */\r\n    function _computeSearchRandomBalances(\r\n        bytes32 _termRandomness,\r\n        uint256 _disputeId,\r\n        uint256 _sortitionIteration,\r\n        uint256 _batchRequestedJurors,\r\n        uint256 _lowBatchBound,\r\n        uint256 _highBatchBound\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256[] memory)\r\n    {\r\n        // Calculate the interval to be used to search the balances in the tree. Since we are using a modulo function to compute the\r\n        // random balances to be searched, intervals will be closed on the left and open on the right, for example [0,10).\r\n        require(_highBatchBound > _lowBatchBound, ERROR_INVALID_INTERVAL_SEARCH);\r\n        uint256 interval = _highBatchBound - _lowBatchBound;\r\n\r\n        // Compute an ordered list of random active balance to be searched in the jurors tree\r\n        uint256[] memory balances = new uint256[](_batchRequestedJurors);\r\n        for (uint256 batchJurorNumber = 0; batchJurorNumber < _batchRequestedJurors; batchJurorNumber++) {\r\n            // Compute a random seed using:\r\n            // - The inherent randomness associated to the term from blockhash\r\n            // - The disputeId, so 2 disputes in the same term will have different outcomes\r\n            // - The sortition iteration, to avoid getting stuck if resulting jurors are dismissed due to locked balance\r\n            // - The juror number in this batch\r\n            bytes32 seed = keccak256(abi.encodePacked(_termRandomness, _disputeId, _sortitionIteration, batchJurorNumber));\r\n\r\n            // Compute a random active balance to be searched in the jurors tree using the generated seed within the\r\n            // boundaries computed for the current batch.\r\n            balances[batchJurorNumber] = _lowBatchBound.add(uint256(seed) % interval);\r\n\r\n            // Make sure it's ordered, flip values if necessary\r\n            for (uint256 i = batchJurorNumber; i > 0 && balances[i] < balances[i - 1]; i--) {\r\n                uint256 tmp = balances[i - 1];\r\n                balances[i - 1] = balances[i];\r\n                balances[i] = tmp;\r\n            }\r\n        }\r\n        return balances;\r\n    }\r\n}\r\n\r\n// File: @aragon/court/contracts/standards/ERC900.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n// Interface for ERC900: https://eips.ethereum.org/EIPS/eip-900\r\ninterface ERC900 {\r\n    event Staked(address indexed user, uint256 amount, uint256 total, bytes data);\r\n    event Unstaked(address indexed user, uint256 amount, uint256 total, bytes data);\r\n\r\n    /**\r\n    * @dev Stake a certain amount of tokens\r\n    * @param _amount Amount of tokens to be staked\r\n    * @param _data Optional data that can be used to add signalling information in more complex staking applications\r\n    */\r\n    function stake(uint256 _amount, bytes calldata _data) external;\r\n\r\n    /**\r\n    * @dev Stake a certain amount of tokens in favor of someone\r\n    * @param _user Address to stake an amount of tokens to\r\n    * @param _amount Amount of tokens to be staked\r\n    * @param _data Optional data that can be used to add signalling information in more complex staking applications\r\n    */\r\n    function stakeFor(address _user, uint256 _amount, bytes calldata _data) external;\r\n\r\n    /**\r\n    * @dev Unstake a certain amount of tokens\r\n    * @param _amount Amount of tokens to be unstaked\r\n    * @param _data Optional data that can be used to add signalling information in more complex staking applications\r\n    */\r\n    function unstake(uint256 _amount, bytes calldata _data) external;\r\n\r\n    /**\r\n    * @dev Tell the total amount of tokens staked for an address\r\n    * @param _addr Address querying the total amount of tokens staked for\r\n    * @return Total amount of tokens staked for an address\r\n    */\r\n    function totalStakedFor(address _addr) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Tell the total amount of tokens staked\r\n    * @return Total amount of tokens staked\r\n    */\r\n    function totalStaked() external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Tell the address of the token used for staking\r\n    * @return Address of the token used for staking\r\n    */\r\n    function token() external view returns (address);\r\n\r\n    /*\r\n    * @dev Tell if the current registry supports historic information or not\r\n    * @return True if the optional history functions are implemented, false otherwise\r\n    */\r\n    function supportsHistory() external pure returns (bool);\r\n}\r\n\r\n// File: @aragon/court/contracts/standards/ApproveAndCall.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\ninterface ApproveAndCallFallBack {\r\n    /**\r\n    * @dev This allows users to use their tokens to interact with contracts in one function call instead of two\r\n    * @param _from Address of the account transferring the tokens\r\n    * @param _amount The amount of tokens approved for in the transfer\r\n    * @param _token Address of the token contract calling this function\r\n    * @param _data Optional data that can be used to add signalling information in more complex staking applications\r\n    */\r\n    function receiveApproval(address _from, uint256 _amount, address _token, bytes calldata _data) external;\r\n}\r\n\r\n// File: @aragon/court/contracts/lib/os/IsContract.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/IsContract.sol\r\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\ncontract IsContract {\r\n    /*\r\n    * NOTE: this should NEVER be used for authentication\r\n    * (see pitfalls: https://github.com/fergarrui/ethereum-security/tree/master/contracts/extcodesize).\r\n    *\r\n    * This is only intended to be used as a sanity check that an address is actually a contract,\r\n    * RATHER THAN an address not being a contract.\r\n    */\r\n    function isContract(address _target) internal view returns (bool) {\r\n        if (_target == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        uint256 size;\r\n        assembly { size := extcodesize(_target) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: @aragon/court/contracts/lib/os/SafeMath64.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/math/SafeMath64.sol\r\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n/**\r\n * @title SafeMath64\r\n * @dev Math operations for uint64 with safety checks that revert on error\r\n */\r\nlibrary SafeMath64 {\r\n    string private constant ERROR_ADD_OVERFLOW = \"MATH64_ADD_OVERFLOW\";\r\n    string private constant ERROR_SUB_UNDERFLOW = \"MATH64_SUB_UNDERFLOW\";\r\n    string private constant ERROR_MUL_OVERFLOW = \"MATH64_MUL_OVERFLOW\";\r\n    string private constant ERROR_DIV_ZERO = \"MATH64_DIV_ZERO\";\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint64 _a, uint64 _b) internal pure returns (uint64) {\r\n        uint256 c = uint256(_a) * uint256(_b);\r\n        require(c < 0x010000000000000000, ERROR_MUL_OVERFLOW); // 2**64 (less gas this way)\r\n\r\n        return uint64(c);\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint64 _a, uint64 _b) internal pure returns (uint64) {\r\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\r\n        uint64 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint64 _a, uint64 _b) internal pure returns (uint64) {\r\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\r\n        uint64 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint64 _a, uint64 _b) internal pure returns (uint64) {\r\n        uint64 c = _a + _b;\r\n        require(c >= _a, ERROR_ADD_OVERFLOW);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        require(b != 0, ERROR_DIV_ZERO);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @aragon/court/contracts/lib/os/Uint256Helpers.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/Uint256Helpers.sol\r\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\nlibrary Uint256Helpers {\r\n    uint256 private constant MAX_UINT8 = uint8(-1);\r\n    uint256 private constant MAX_UINT64 = uint64(-1);\r\n\r\n    string private constant ERROR_UINT8_NUMBER_TOO_BIG = \"UINT8_NUMBER_TOO_BIG\";\r\n    string private constant ERROR_UINT64_NUMBER_TOO_BIG = \"UINT64_NUMBER_TOO_BIG\";\r\n\r\n    function toUint8(uint256 a) internal pure returns (uint8) {\r\n        require(a <= MAX_UINT8, ERROR_UINT8_NUMBER_TOO_BIG);\r\n        return uint8(a);\r\n    }\r\n\r\n    function toUint64(uint256 a) internal pure returns (uint64) {\r\n        require(a <= MAX_UINT64, ERROR_UINT64_NUMBER_TOO_BIG);\r\n        return uint64(a);\r\n    }\r\n}\r\n\r\n// File: @aragon/court/contracts/lib/os/TimeHelpers.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/TimeHelpers.sol\r\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\ncontract TimeHelpers {\r\n    using Uint256Helpers for uint256;\r\n\r\n    /**\r\n    * @dev Returns the current block number.\r\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\r\n    *      tests.\r\n    */\r\n    function getBlockNumber() internal view returns (uint256) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current block number, converted to uint64.\r\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\r\n    *      tests.\r\n    */\r\n    function getBlockNumber64() internal view returns (uint64) {\r\n        return getBlockNumber().toUint64();\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current timestamp.\r\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\r\n    *      tests.\r\n    */\r\n    function getTimestamp() internal view returns (uint256) {\r\n        return block.timestamp; // solium-disable-line security/no-block-members\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current timestamp, converted to uint64.\r\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\r\n    *      tests.\r\n    */\r\n    function getTimestamp64() internal view returns (uint64) {\r\n        return getTimestamp().toUint64();\r\n    }\r\n}\r\n\r\n// File: @aragon/court/contracts/court/clock/IClock.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\ninterface IClock {\r\n    /**\r\n    * @dev Ensure that the current term of the clock is up-to-date\r\n    * @return Identification number of the current term\r\n    */\r\n    function ensureCurrentTerm() external returns (uint64);\r\n\r\n    /**\r\n    * @dev Transition up to a certain number of terms to leave the clock up-to-date\r\n    * @param _maxRequestedTransitions Max number of term transitions allowed by the sender\r\n    * @return Identification number of the term ID after executing the heartbeat transitions\r\n    */\r\n    function heartbeat(uint64 _maxRequestedTransitions) external returns (uint64);\r\n\r\n    /**\r\n    * @dev Ensure that a certain term has its randomness set\r\n    * @return Randomness of the current term\r\n    */\r\n    function ensureCurrentTermRandomness() external returns (bytes32);\r\n\r\n    /**\r\n    * @dev Tell the last ensured term identification number\r\n    * @return Identification number of the last ensured term\r\n    */\r\n    function getLastEnsuredTermId() external view returns (uint64);\r\n\r\n    /**\r\n    * @dev Tell the current term identification number. Note that there may be pending term transitions.\r\n    * @return Identification number of the current term\r\n    */\r\n    function getCurrentTermId() external view returns (uint64);\r\n\r\n    /**\r\n    * @dev Tell the number of terms the clock should transition to be up-to-date\r\n    * @return Number of terms the clock should transition to be up-to-date\r\n    */\r\n    function getNeededTermTransitions() external view returns (uint64);\r\n\r\n    /**\r\n    * @dev Tell the information related to a term based on its ID\r\n    * @param _termId ID of the term being queried\r\n    * @return startTime Term start time\r\n    * @return randomnessBN Block number used for randomness in the requested term\r\n    * @return randomness Randomness computed for the requested term\r\n    */\r\n    function getTerm(uint64 _termId) external view returns (uint64 startTime, uint64 randomnessBN, bytes32 randomness);\r\n\r\n    /**\r\n    * @dev Tell the randomness of a term even if it wasn't computed yet\r\n    * @param _termId Identification number of the term being queried\r\n    * @return Randomness of the requested term\r\n    */\r\n    function getTermRandomness(uint64 _termId) external view returns (bytes32);\r\n}\r\n\r\n// File: @aragon/court/contracts/court/clock/CourtClock.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\n\r\ncontract CourtClock is IClock, TimeHelpers {\r\n    using SafeMath64 for uint64;\r\n\r\n    string private constant ERROR_TERM_DOES_NOT_EXIST = \"CLK_TERM_DOES_NOT_EXIST\";\r\n    string private constant ERROR_TERM_DURATION_TOO_LONG = \"CLK_TERM_DURATION_TOO_LONG\";\r\n    string private constant ERROR_TERM_RANDOMNESS_NOT_YET = \"CLK_TERM_RANDOMNESS_NOT_YET\";\r\n    string private constant ERROR_TERM_RANDOMNESS_UNAVAILABLE = \"CLK_TERM_RANDOMNESS_UNAVAILABLE\";\r\n    string private constant ERROR_BAD_FIRST_TERM_START_TIME = \"CLK_BAD_FIRST_TERM_START_TIME\";\r\n    string private constant ERROR_TOO_MANY_TRANSITIONS = \"CLK_TOO_MANY_TRANSITIONS\";\r\n    string private constant ERROR_INVALID_TRANSITION_TERMS = \"CLK_INVALID_TRANSITION_TERMS\";\r\n    string private constant ERROR_CANNOT_DELAY_STARTED_COURT = \"CLK_CANNOT_DELAY_STARTED_COURT\";\r\n    string private constant ERROR_CANNOT_DELAY_PAST_START_TIME = \"CLK_CANNOT_DELAY_PAST_START_TIME\";\r\n\r\n    // Maximum number of term transitions a callee may have to assume in order to call certain functions that require the Court being up-to-date\r\n    uint64 internal constant MAX_AUTO_TERM_TRANSITIONS_ALLOWED = 1;\r\n\r\n    // Max duration in seconds that a term can last\r\n    uint64 internal constant MAX_TERM_DURATION = 365 days;\r\n\r\n    // Max time until first term starts since contract is deployed\r\n    uint64 internal constant MAX_FIRST_TERM_DELAY_PERIOD = 2 * MAX_TERM_DURATION;\r\n\r\n    struct Term {\r\n        uint64 startTime;              // Timestamp when the term started\r\n        uint64 randomnessBN;           // Block number for entropy\r\n        bytes32 randomness;            // Entropy from randomnessBN block hash\r\n    }\r\n\r\n    // Duration in seconds for each term of the Court\r\n    uint64 private termDuration;\r\n\r\n    // Last ensured term id\r\n    uint64 private termId;\r\n\r\n    // List of Court terms indexed by id\r\n    mapping (uint64 => Term) private terms;\r\n\r\n    event Heartbeat(uint64 previousTermId, uint64 currentTermId);\r\n    event StartTimeDelayed(uint64 previousStartTime, uint64 currentStartTime);\r\n\r\n    /**\r\n    * @dev Ensure a certain term has already been processed\r\n    * @param _termId Identification number of the term to be checked\r\n    */\r\n    modifier termExists(uint64 _termId) {\r\n        require(_termId <= termId, ERROR_TERM_DOES_NOT_EXIST);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    * @param _termParams Array containing:\r\n    *        0. _termDuration Duration in seconds per term\r\n    *        1. _firstTermStartTime Timestamp in seconds when the court will open (to give time for juror on-boarding)\r\n    */\r\n    constructor(uint64[2] memory _termParams) public {\r\n        uint64 _termDuration = _termParams[0];\r\n        uint64 _firstTermStartTime = _termParams[1];\r\n\r\n        require(_termDuration < MAX_TERM_DURATION, ERROR_TERM_DURATION_TOO_LONG);\r\n        require(_firstTermStartTime >= getTimestamp64() + _termDuration, ERROR_BAD_FIRST_TERM_START_TIME);\r\n        require(_firstTermStartTime <= getTimestamp64() + MAX_FIRST_TERM_DELAY_PERIOD, ERROR_BAD_FIRST_TERM_START_TIME);\r\n\r\n        termDuration = _termDuration;\r\n\r\n        // No need for SafeMath: we already checked values above\r\n        terms[0].startTime = _firstTermStartTime - _termDuration;\r\n    }\r\n\r\n    /**\r\n    * @notice Ensure that the current term of the Court is up-to-date. If the Court is outdated by more than `MAX_AUTO_TERM_TRANSITIONS_ALLOWED`\r\n    *         terms, the heartbeat function must be called manually instead.\r\n    * @return Identification number of the current term\r\n    */\r\n    function ensureCurrentTerm() external returns (uint64) {\r\n        return _ensureCurrentTerm();\r\n    }\r\n\r\n    /**\r\n    * @notice Transition up to `_maxRequestedTransitions` terms\r\n    * @param _maxRequestedTransitions Max number of term transitions allowed by the sender\r\n    * @return Identification number of the term ID after executing the heartbeat transitions\r\n    */\r\n    function heartbeat(uint64 _maxRequestedTransitions) external returns (uint64) {\r\n        return _heartbeat(_maxRequestedTransitions);\r\n    }\r\n\r\n    /**\r\n    * @notice Ensure that a certain term has its randomness set. As we allow to draft disputes requested for previous terms, if there\r\n    *      were mined more than 256 blocks for the current term, the blockhash of its randomness BN is no longer available, given\r\n    *      round will be able to be drafted in the following term.\r\n    * @return Randomness of the current term\r\n    */\r\n    function ensureCurrentTermRandomness() external returns (bytes32) {\r\n        // If the randomness for the given term was already computed, return\r\n        uint64 currentTermId = termId;\r\n        Term storage term = terms[currentTermId];\r\n        bytes32 termRandomness = term.randomness;\r\n        if (termRandomness != bytes32(0)) {\r\n            return termRandomness;\r\n        }\r\n\r\n        // Compute term randomness\r\n        bytes32 newRandomness = _computeTermRandomness(currentTermId);\r\n        require(newRandomness != bytes32(0), ERROR_TERM_RANDOMNESS_UNAVAILABLE);\r\n        term.randomness = newRandomness;\r\n        return newRandomness;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the term duration of the Court\r\n    * @return Duration in seconds of the Court term\r\n    */\r\n    function getTermDuration() external view returns (uint64) {\r\n        return termDuration;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the last ensured term identification number\r\n    * @return Identification number of the last ensured term\r\n    */\r\n    function getLastEnsuredTermId() external view returns (uint64) {\r\n        return _lastEnsuredTermId();\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the current term identification number. Note that there may be pending term transitions.\r\n    * @return Identification number of the current term\r\n    */\r\n    function getCurrentTermId() external view returns (uint64) {\r\n        return _currentTermId();\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the number of terms the Court should transition to be up-to-date\r\n    * @return Number of terms the Court should transition to be up-to-date\r\n    */\r\n    function getNeededTermTransitions() external view returns (uint64) {\r\n        return _neededTermTransitions();\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the information related to a term based on its ID. Note that if the term has not been reached, the\r\n    *      information returned won't be computed yet. This function allows querying future terms that were not computed yet.\r\n    * @param _termId ID of the term being queried\r\n    * @return startTime Term start time\r\n    * @return randomnessBN Block number used for randomness in the requested term\r\n    * @return randomness Randomness computed for the requested term\r\n    */\r\n    function getTerm(uint64 _termId) external view returns (uint64 startTime, uint64 randomnessBN, bytes32 randomness) {\r\n        Term storage term = terms[_termId];\r\n        return (term.startTime, term.randomnessBN, term.randomness);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the randomness of a term even if it wasn't computed yet\r\n    * @param _termId Identification number of the term being queried\r\n    * @return Randomness of the requested term\r\n    */\r\n    function getTermRandomness(uint64 _termId) external view termExists(_termId) returns (bytes32) {\r\n        return _computeTermRandomness(_termId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to ensure that the current term of the Court is up-to-date. If the Court is outdated by more than\r\n    *      `MAX_AUTO_TERM_TRANSITIONS_ALLOWED` terms, the heartbeat function must be called manually.\r\n    * @return Identification number of the resultant term ID after executing the corresponding transitions\r\n    */\r\n    function _ensureCurrentTerm() internal returns (uint64) {\r\n        // Check the required number of transitions does not exceeds the max allowed number to be processed automatically\r\n        uint64 requiredTransitions = _neededTermTransitions();\r\n        require(requiredTransitions <= MAX_AUTO_TERM_TRANSITIONS_ALLOWED, ERROR_TOO_MANY_TRANSITIONS);\r\n\r\n        // If there are no transitions pending, return the last ensured term id\r\n        if (uint256(requiredTransitions) == 0) {\r\n            return termId;\r\n        }\r\n\r\n        // Process transition if there is at least one pending\r\n        return _heartbeat(requiredTransitions);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to transition the Court terms up to a requested number of terms\r\n    * @param _maxRequestedTransitions Max number of term transitions allowed by the sender\r\n    * @return Identification number of the resultant term ID after executing the requested transitions\r\n    */\r\n    function _heartbeat(uint64 _maxRequestedTransitions) internal returns (uint64) {\r\n        // Transition the minimum number of terms between the amount requested and the amount actually needed\r\n        uint64 neededTransitions = _neededTermTransitions();\r\n        uint256 transitions = uint256(_maxRequestedTransitions < neededTransitions ? _maxRequestedTransitions : neededTransitions);\r\n        require(transitions > 0, ERROR_INVALID_TRANSITION_TERMS);\r\n\r\n        uint64 blockNumber = getBlockNumber64();\r\n        uint64 previousTermId = termId;\r\n        uint64 currentTermId = previousTermId;\r\n        for (uint256 transition = 1; transition <= transitions; transition++) {\r\n            // Term IDs are incremented by one based on the number of time periods since the Court started. Since time is represented in uint64,\r\n            // even if we chose the minimum duration possible for a term (1 second), we can ensure terms will never reach 2^64 since time is\r\n            // already assumed to fit in uint64.\r\n            Term storage previousTerm = terms[currentTermId++];\r\n            Term storage currentTerm = terms[currentTermId];\r\n            _onTermTransitioned(currentTermId);\r\n\r\n            // Set the start time of the new term. Note that we are using a constant term duration value to guarantee\r\n            // equally long terms, regardless of heartbeats.\r\n            currentTerm.startTime = previousTerm.startTime.add(termDuration);\r\n\r\n            // In order to draft a random number of jurors in a term, we use a randomness factor for each term based on a\r\n            // block number that is set once the term has started. Note that this information could not be known beforehand.\r\n            currentTerm.randomnessBN = blockNumber + 1;\r\n        }\r\n\r\n        termId = currentTermId;\r\n        emit Heartbeat(previousTermId, currentTermId);\r\n        return currentTermId;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to delay the first term start time only if it wasn't reached yet\r\n    * @param _newFirstTermStartTime New timestamp in seconds when the court will open\r\n    */\r\n    function _delayStartTime(uint64 _newFirstTermStartTime) internal {\r\n        require(_currentTermId() == 0, ERROR_CANNOT_DELAY_STARTED_COURT);\r\n\r\n        Term storage term = terms[0];\r\n        uint64 currentFirstTermStartTime = term.startTime.add(termDuration);\r\n        require(_newFirstTermStartTime > currentFirstTermStartTime, ERROR_CANNOT_DELAY_PAST_START_TIME);\r\n\r\n        // No need for SafeMath: we already checked above that `_newFirstTermStartTime` > `currentFirstTermStartTime` >= `termDuration`\r\n        term.startTime = _newFirstTermStartTime - termDuration;\r\n        emit StartTimeDelayed(currentFirstTermStartTime, _newFirstTermStartTime);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to notify when a term has been transitioned. This function must be overridden to provide custom behavior.\r\n    * @param _termId Identification number of the new current term that has been transitioned\r\n    */\r\n    function _onTermTransitioned(uint64 _termId) internal;\r\n\r\n    /**\r\n    * @dev Internal function to tell the last ensured term identification number\r\n    * @return Identification number of the last ensured term\r\n    */\r\n    function _lastEnsuredTermId() internal view returns (uint64) {\r\n        return termId;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to tell the current term identification number. Note that there may be pending term transitions.\r\n    * @return Identification number of the current term\r\n    */\r\n    function _currentTermId() internal view returns (uint64) {\r\n        return termId.add(_neededTermTransitions());\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to tell the number of terms the Court should transition to be up-to-date\r\n    * @return Number of terms the Court should transition to be up-to-date\r\n    */\r\n    function _neededTermTransitions() internal view returns (uint64) {\r\n        // Note that the Court is always initialized providing a start time for the first-term in the future. If that's the case,\r\n        // no term transitions are required.\r\n        uint64 currentTermStartTime = terms[termId].startTime;\r\n        if (getTimestamp64() < currentTermStartTime) {\r\n            return uint64(0);\r\n        }\r\n\r\n        // No need for SafeMath: we already know that the start time of the current term is in the past\r\n        return (getTimestamp64() - currentTermStartTime) / termDuration;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to compute the randomness that will be used to draft jurors for the given term. This\r\n    *      function assumes the given term exists. To determine the randomness factor for a term we use the hash of a\r\n    *      block number that is set once the term has started to ensure it cannot be known beforehand. Note that the\r\n    *      hash function being used only works for the 256 most recent block numbers.\r\n    * @param _termId Identification number of the term being queried\r\n    * @return Randomness computed for the given term\r\n    */\r\n    function _computeTermRandomness(uint64 _termId) internal view returns (bytes32) {\r\n        Term storage term = terms[_termId];\r\n        require(getBlockNumber64() > term.randomnessBN, ERROR_TERM_RANDOMNESS_NOT_YET);\r\n        return blockhash(term.randomnessBN);\r\n    }\r\n}\r\n\r\n// File: @aragon/court/contracts/court/config/IConfig.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\ninterface IConfig {\r\n\r\n    /**\r\n    * @dev Tell the full Court configuration parameters at a certain term\r\n    * @param _termId Identification number of the term querying the Court config of\r\n    * @return token Address of the token used to pay for fees\r\n    * @return fees Array containing:\r\n    *         0. jurorFee Amount of fee tokens that is paid per juror per dispute\r\n    *         1. draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    *         2. settleFee Amount of fee tokens per juror to cover round settlement cost\r\n    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *         0. evidenceTerms Max submitting evidence period duration in terms\r\n    *         1. commitTerms Commit period duration in terms\r\n    *         2. revealTerms Reveal period duration in terms\r\n    *         3. appealTerms Appeal period duration in terms\r\n    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @return pcts Array containing:\r\n    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\r\n    * @return roundParams Array containing params for rounds:\r\n    *         0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\r\n    *         1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\r\n    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    * @return appealCollateralParams Array containing params for appeal collateral:\r\n    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\r\n    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\r\n    * @return minActiveBalance Minimum amount of tokens jurors have to activate to participate in the Court\r\n    */\r\n    function getConfig(uint64 _termId) external view\r\n        returns (\r\n            ERC20 feeToken,\r\n            uint256[3] memory fees,\r\n            uint64[5] memory roundStateDurations,\r\n            uint16[2] memory pcts,\r\n            uint64[4] memory roundParams,\r\n            uint256[2] memory appealCollateralParams,\r\n            uint256 minActiveBalance\r\n        );\r\n\r\n    /**\r\n    * @dev Tell the draft config at a certain term\r\n    * @param _termId Identification number of the term querying the draft config of\r\n    * @return feeToken Address of the token used to pay for fees\r\n    * @return draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n    */\r\n    function getDraftConfig(uint64 _termId) external view returns (ERC20 feeToken, uint256 draftFee, uint16 penaltyPct);\r\n\r\n    /**\r\n    * @dev Tell the min active balance config at a certain term\r\n    * @param _termId Term querying the min active balance config of\r\n    * @return Minimum amount of tokens jurors have to activate to participate in the Court\r\n    */\r\n    function getMinActiveBalance(uint64 _termId) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Tell whether a certain holder accepts automatic withdrawals of tokens or not\r\n    * @return True if the given holder accepts automatic withdrawals of their tokens, false otherwise\r\n    */\r\n    function areWithdrawalsAllowedFor(address _holder) external view returns (bool);\r\n}\r\n\r\n// File: @aragon/court/contracts/court/config/CourtConfigData.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\ncontract CourtConfigData {\r\n    struct Config {\r\n        FeesConfig fees;                        // Full fees-related config\r\n        DisputesConfig disputes;                // Full disputes-related config\r\n        uint256 minActiveBalance;               // Minimum amount of tokens jurors have to activate to participate in the Court\r\n    }\r\n\r\n    struct FeesConfig {\r\n        ERC20 token;                            // ERC20 token to be used for the fees of the Court\r\n        uint16 finalRoundReduction;             // Permyriad of fees reduction applied for final appeal round (‱ - 1/10,000)\r\n        uint256 jurorFee;                       // Amount of tokens paid to draft a juror to adjudicate a dispute\r\n        uint256 draftFee;                       // Amount of tokens paid per round to cover the costs of drafting jurors\r\n        uint256 settleFee;                      // Amount of tokens paid per round to cover the costs of slashing jurors\r\n    }\r\n\r\n    struct DisputesConfig {\r\n        uint64 evidenceTerms;                   // Max submitting evidence period duration in terms\r\n        uint64 commitTerms;                     // Committing period duration in terms\r\n        uint64 revealTerms;                     // Revealing period duration in terms\r\n        uint64 appealTerms;                     // Appealing period duration in terms\r\n        uint64 appealConfirmTerms;              // Confirmation appeal period duration in terms\r\n        uint16 penaltyPct;                      // Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n        uint64 firstRoundJurorsNumber;          // Number of jurors drafted on first round\r\n        uint64 appealStepFactor;                // Factor in which the jurors number is increased on each appeal\r\n        uint64 finalRoundLockTerms;             // Period a coherent juror in the final round will remain locked\r\n        uint256 maxRegularAppealRounds;         // Before the final appeal\r\n        uint256 appealCollateralFactor;         // Permyriad multiple of dispute fees required to appeal a preliminary ruling (‱ - 1/10,000)\r\n        uint256 appealConfirmCollateralFactor;  // Permyriad multiple of dispute fees required to confirm appeal (‱ - 1/10,000)\r\n    }\r\n\r\n    struct DraftConfig {\r\n        ERC20 feeToken;                         // ERC20 token to be used for the fees of the Court\r\n        uint16 penaltyPct;                      // Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n        uint256 draftFee;                       // Amount of tokens paid per round to cover the costs of drafting jurors\r\n    }\r\n}\r\n\r\n// File: @aragon/court/contracts/court/config/CourtConfig.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract CourtConfig is IConfig, CourtConfigData {\r\n    using SafeMath64 for uint64;\r\n    using PctHelpers for uint256;\r\n\r\n    string private constant ERROR_TOO_OLD_TERM = \"CONF_TOO_OLD_TERM\";\r\n    string private constant ERROR_INVALID_PENALTY_PCT = \"CONF_INVALID_PENALTY_PCT\";\r\n    string private constant ERROR_INVALID_FINAL_ROUND_REDUCTION_PCT = \"CONF_INVALID_FINAL_ROUND_RED_PCT\";\r\n    string private constant ERROR_INVALID_MAX_APPEAL_ROUNDS = \"CONF_INVALID_MAX_APPEAL_ROUNDS\";\r\n    string private constant ERROR_LARGE_ROUND_PHASE_DURATION = \"CONF_LARGE_ROUND_PHASE_DURATION\";\r\n    string private constant ERROR_BAD_INITIAL_JURORS_NUMBER = \"CONF_BAD_INITIAL_JURORS_NUMBER\";\r\n    string private constant ERROR_BAD_APPEAL_STEP_FACTOR = \"CONF_BAD_APPEAL_STEP_FACTOR\";\r\n    string private constant ERROR_ZERO_COLLATERAL_FACTOR = \"CONF_ZERO_COLLATERAL_FACTOR\";\r\n    string private constant ERROR_ZERO_MIN_ACTIVE_BALANCE = \"CONF_ZERO_MIN_ACTIVE_BALANCE\";\r\n\r\n    // Max number of terms that each of the different adjudication states can last (if lasted 1h, this would be a year)\r\n    uint64 internal constant MAX_ADJ_STATE_DURATION = 8670;\r\n\r\n    // Cap the max number of regular appeal rounds\r\n    uint256 internal constant MAX_REGULAR_APPEAL_ROUNDS_LIMIT = 10;\r\n\r\n    // Future term ID in which a config change has been scheduled\r\n    uint64 private configChangeTermId;\r\n\r\n    // List of all the configs used in the Court\r\n    Config[] private configs;\r\n\r\n    // List of configs indexed by id\r\n    mapping (uint64 => uint256) private configIdByTerm;\r\n\r\n    // Holders opt-in config for automatic withdrawals\r\n    mapping (address => bool) private withdrawalsAllowed;\r\n\r\n    event NewConfig(uint64 fromTermId, uint64 courtConfigId);\r\n    event AutomaticWithdrawalsAllowedChanged(address indexed holder, bool allowed);\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    * @param _feeToken Address of the token contract that is used to pay for fees\r\n    * @param _fees Array containing:\r\n    *        0. jurorFee Amount of fee tokens that is paid per juror per dispute\r\n    *        1. draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    *        2. settleFee Amount of fee tokens per juror to cover round settlement cost\r\n    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *        0. evidenceTerms Max submitting evidence period duration in terms\r\n    *        1. commitTerms Commit period duration in terms\r\n    *        2. revealTerms Reveal period duration in terms\r\n    *        3. appealTerms Appeal period duration in terms\r\n    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @param _pcts Array containing:\r\n    *        0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\r\n    * @param _roundParams Array containing params for rounds:\r\n    *        0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\r\n    *        1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\r\n    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    *        3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\r\n    * @param _appealCollateralParams Array containing params for appeal collateral:\r\n    *        0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\r\n    *        1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\r\n    * @param _minActiveBalance Minimum amount of juror tokens that can be activated\r\n    */\r\n    constructor(\r\n        ERC20 _feeToken,\r\n        uint256[3] memory _fees,\r\n        uint64[5] memory _roundStateDurations,\r\n        uint16[2] memory _pcts,\r\n        uint64[4] memory _roundParams,\r\n        uint256[2] memory _appealCollateralParams,\r\n        uint256 _minActiveBalance\r\n    )\r\n        public\r\n    {\r\n        // Leave config at index 0 empty for non-scheduled config changes\r\n        configs.length = 1;\r\n        _setConfig(\r\n            0,\r\n            0,\r\n            _feeToken,\r\n            _fees,\r\n            _roundStateDurations,\r\n            _pcts,\r\n            _roundParams,\r\n            _appealCollateralParams,\r\n            _minActiveBalance\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Set the automatic withdrawals config for the sender to `_allowed`\r\n    * @param _allowed Whether or not the automatic withdrawals are allowed by the sender\r\n    */\r\n    function setAutomaticWithdrawals(bool _allowed) external {\r\n        withdrawalsAllowed[msg.sender] = _allowed;\r\n        emit AutomaticWithdrawalsAllowedChanged(msg.sender, _allowed);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the full Court configuration parameters at a certain term\r\n    * @param _termId Identification number of the term querying the Court config of\r\n    * @return token Address of the token used to pay for fees\r\n    * @return fees Array containing:\r\n    *         0. jurorFee Amount of fee tokens that is paid per juror per dispute\r\n    *         1. draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    *         2. settleFee Amount of fee tokens per juror to cover round settlement cost\r\n    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *         0. evidenceTerms Max submitting evidence period duration in terms\r\n    *         1. commitTerms Commit period duration in terms\r\n    *         2. revealTerms Reveal period duration in terms\r\n    *         3. appealTerms Appeal period duration in terms\r\n    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @return pcts Array containing:\r\n    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\r\n    * @return roundParams Array containing params for rounds:\r\n    *         0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\r\n    *         1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\r\n    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    * @return appealCollateralParams Array containing params for appeal collateral:\r\n    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\r\n    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\r\n    * @return minActiveBalance Minimum amount of tokens jurors have to activate to participate in the Court\r\n    */\r\n    function getConfig(uint64 _termId) external view\r\n        returns (\r\n            ERC20 feeToken,\r\n            uint256[3] memory fees,\r\n            uint64[5] memory roundStateDurations,\r\n            uint16[2] memory pcts,\r\n            uint64[4] memory roundParams,\r\n            uint256[2] memory appealCollateralParams,\r\n            uint256 minActiveBalance\r\n        );\r\n\r\n    /**\r\n    * @dev Tell the draft config at a certain term\r\n    * @param _termId Identification number of the term querying the draft config of\r\n    * @return feeToken Address of the token used to pay for fees\r\n    * @return draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n    */\r\n    function getDraftConfig(uint64 _termId) external view returns (ERC20 feeToken, uint256 draftFee, uint16 penaltyPct);\r\n\r\n    /**\r\n    * @dev Tell the min active balance config at a certain term\r\n    * @param _termId Term querying the min active balance config of\r\n    * @return Minimum amount of tokens jurors have to activate to participate in the Court\r\n    */\r\n    function getMinActiveBalance(uint64 _termId) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Tell whether a certain holder accepts automatic withdrawals of tokens or not\r\n    * @param _holder Address of the token holder querying if withdrawals are allowed for\r\n    * @return True if the given holder accepts automatic withdrawals of their tokens, false otherwise\r\n    */\r\n    function areWithdrawalsAllowedFor(address _holder) external view returns (bool) {\r\n        return withdrawalsAllowed[_holder];\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the term identification number of the next scheduled config change\r\n    * @return Term identification number of the next scheduled config change\r\n    */\r\n    function getConfigChangeTermId() external view returns (uint64) {\r\n        return configChangeTermId;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal to make sure to set a config for the new term, it will copy the previous term config if none\r\n    * @param _termId Identification number of the new current term that has been transitioned\r\n    */\r\n    function _ensureTermConfig(uint64 _termId) internal {\r\n        // If the term being transitioned had no config change scheduled, keep the previous one\r\n        uint256 currentConfigId = configIdByTerm[_termId];\r\n        if (currentConfigId == 0) {\r\n            uint256 previousConfigId = configIdByTerm[_termId.sub(1)];\r\n            configIdByTerm[_termId] = previousConfigId;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Assumes that sender it's allowed (either it's from governor or it's on init)\r\n    * @param _termId Identification number of the current Court term\r\n    * @param _fromTermId Identification number of the term in which the config will be effective at\r\n    * @param _feeToken Address of the token contract that is used to pay for fees.\r\n    * @param _fees Array containing:\r\n    *        0. jurorFee Amount of fee tokens that is paid per juror per dispute\r\n    *        1. draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    *        2. settleFee Amount of fee tokens per juror to cover round settlement cost\r\n    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *        0. evidenceTerms Max submitting evidence period duration in terms\r\n    *        1. commitTerms Commit period duration in terms\r\n    *        2. revealTerms Reveal period duration in terms\r\n    *        3. appealTerms Appeal period duration in terms\r\n    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @param _pcts Array containing:\r\n    *        0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\r\n    * @param _roundParams Array containing params for rounds:\r\n    *        0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\r\n    *        1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\r\n    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    *        3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\r\n    * @param _appealCollateralParams Array containing params for appeal collateral:\r\n    *        0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\r\n    *        1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\r\n    * @param _minActiveBalance Minimum amount of juror tokens that can be activated\r\n    */\r\n    function _setConfig(\r\n        uint64 _termId,\r\n        uint64 _fromTermId,\r\n        ERC20 _feeToken,\r\n        uint256[3] memory _fees,\r\n        uint64[5] memory _roundStateDurations,\r\n        uint16[2] memory _pcts,\r\n        uint64[4] memory _roundParams,\r\n        uint256[2] memory _appealCollateralParams,\r\n        uint256 _minActiveBalance\r\n    )\r\n        internal\r\n    {\r\n        // If the current term is not zero, changes must be scheduled at least after the current period.\r\n        // No need to ensure delays for on-going disputes since these already use their creation term for that.\r\n        require(_termId == 0 || _fromTermId > _termId, ERROR_TOO_OLD_TERM);\r\n\r\n        // Make sure appeal collateral factors are greater than zero\r\n        require(_appealCollateralParams[0] > 0 && _appealCollateralParams[1] > 0, ERROR_ZERO_COLLATERAL_FACTOR);\r\n\r\n        // Make sure the given penalty and final round reduction pcts are not greater than 100%\r\n        require(PctHelpers.isValid(_pcts[0]), ERROR_INVALID_PENALTY_PCT);\r\n        require(PctHelpers.isValid(_pcts[1]), ERROR_INVALID_FINAL_ROUND_REDUCTION_PCT);\r\n\r\n        // Disputes must request at least one juror to be drafted initially\r\n        require(_roundParams[0] > 0, ERROR_BAD_INITIAL_JURORS_NUMBER);\r\n\r\n        // Prevent that further rounds have zero jurors\r\n        require(_roundParams[1] > 0, ERROR_BAD_APPEAL_STEP_FACTOR);\r\n\r\n        // Make sure the max number of appeals allowed does not reach the limit\r\n        uint256 _maxRegularAppealRounds = _roundParams[2];\r\n        bool isMaxAppealRoundsValid = _maxRegularAppealRounds > 0 && _maxRegularAppealRounds <= MAX_REGULAR_APPEAL_ROUNDS_LIMIT;\r\n        require(isMaxAppealRoundsValid, ERROR_INVALID_MAX_APPEAL_ROUNDS);\r\n\r\n        // Make sure each adjudication round phase duration is valid\r\n        for (uint i = 0; i < _roundStateDurations.length; i++) {\r\n            require(_roundStateDurations[i] > 0 && _roundStateDurations[i] < MAX_ADJ_STATE_DURATION, ERROR_LARGE_ROUND_PHASE_DURATION);\r\n        }\r\n\r\n        // Make sure min active balance is not zero\r\n        require(_minActiveBalance > 0, ERROR_ZERO_MIN_ACTIVE_BALANCE);\r\n\r\n        // If there was a config change already scheduled, reset it (in that case we will overwrite last array item).\r\n        // Otherwise, schedule a new config.\r\n        if (configChangeTermId > _termId) {\r\n            configIdByTerm[configChangeTermId] = 0;\r\n        } else {\r\n            configs.length++;\r\n        }\r\n\r\n        uint64 courtConfigId = uint64(configs.length - 1);\r\n        Config storage config = configs[courtConfigId];\r\n\r\n        config.fees = FeesConfig({\r\n            token: _feeToken,\r\n            jurorFee: _fees[0],\r\n            draftFee: _fees[1],\r\n            settleFee: _fees[2],\r\n            finalRoundReduction: _pcts[1]\r\n        });\r\n\r\n        config.disputes = DisputesConfig({\r\n            evidenceTerms: _roundStateDurations[0],\r\n            commitTerms: _roundStateDurations[1],\r\n            revealTerms: _roundStateDurations[2],\r\n            appealTerms: _roundStateDurations[3],\r\n            appealConfirmTerms: _roundStateDurations[4],\r\n            penaltyPct: _pcts[0],\r\n            firstRoundJurorsNumber: _roundParams[0],\r\n            appealStepFactor: _roundParams[1],\r\n            maxRegularAppealRounds: _maxRegularAppealRounds,\r\n            finalRoundLockTerms: _roundParams[3],\r\n            appealCollateralFactor: _appealCollateralParams[0],\r\n            appealConfirmCollateralFactor: _appealCollateralParams[1]\r\n        });\r\n\r\n        config.minActiveBalance = _minActiveBalance;\r\n\r\n        configIdByTerm[_fromTermId] = courtConfigId;\r\n        configChangeTermId = _fromTermId;\r\n\r\n        emit NewConfig(_fromTermId, courtConfigId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the Court config for a given term\r\n    * @param _termId Identification number of the term querying the Court config of\r\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\r\n    * @return token Address of the token used to pay for fees\r\n    * @return fees Array containing:\r\n    *         0. jurorFee Amount of fee tokens that is paid per juror per dispute\r\n    *         1. draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    *         2. settleFee Amount of fee tokens per juror to cover round settlement cost\r\n    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *         0. evidenceTerms Max submitting evidence period duration in terms\r\n    *         1. commitTerms Commit period duration in terms\r\n    *         2. revealTerms Reveal period duration in terms\r\n    *         3. appealTerms Appeal period duration in terms\r\n    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @return pcts Array containing:\r\n    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\r\n    * @return roundParams Array containing params for rounds:\r\n    *         0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\r\n    *         1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\r\n    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    *         3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\r\n    * @return appealCollateralParams Array containing params for appeal collateral:\r\n    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\r\n    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\r\n    * @return minActiveBalance Minimum amount of juror tokens that can be activated\r\n    */\r\n    function _getConfigAt(uint64 _termId, uint64 _lastEnsuredTermId) internal view\r\n        returns (\r\n            ERC20 feeToken,\r\n            uint256[3] memory fees,\r\n            uint64[5] memory roundStateDurations,\r\n            uint16[2] memory pcts,\r\n            uint64[4] memory roundParams,\r\n            uint256[2] memory appealCollateralParams,\r\n            uint256 minActiveBalance\r\n        )\r\n    {\r\n        Config storage config = _getConfigFor(_termId, _lastEnsuredTermId);\r\n\r\n        FeesConfig storage feesConfig = config.fees;\r\n        feeToken = feesConfig.token;\r\n        fees = [feesConfig.jurorFee, feesConfig.draftFee, feesConfig.settleFee];\r\n\r\n        DisputesConfig storage disputesConfig = config.disputes;\r\n        roundStateDurations = [\r\n            disputesConfig.evidenceTerms,\r\n            disputesConfig.commitTerms,\r\n            disputesConfig.revealTerms,\r\n            disputesConfig.appealTerms,\r\n            disputesConfig.appealConfirmTerms\r\n        ];\r\n        pcts = [disputesConfig.penaltyPct, feesConfig.finalRoundReduction];\r\n        roundParams = [\r\n            disputesConfig.firstRoundJurorsNumber,\r\n            disputesConfig.appealStepFactor,\r\n            uint64(disputesConfig.maxRegularAppealRounds),\r\n            disputesConfig.finalRoundLockTerms\r\n        ];\r\n        appealCollateralParams = [disputesConfig.appealCollateralFactor, disputesConfig.appealConfirmCollateralFactor];\r\n\r\n        minActiveBalance = config.minActiveBalance;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the draft config at a certain term\r\n    * @param _termId Identification number of the term querying the draft config of\r\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\r\n    * @return feeToken Address of the token used to pay for fees\r\n    * @return draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n    */\r\n    function _getDraftConfig(uint64 _termId,  uint64 _lastEnsuredTermId) internal view\r\n        returns (ERC20 feeToken, uint256 draftFee, uint16 penaltyPct)\r\n    {\r\n        Config storage config = _getConfigFor(_termId, _lastEnsuredTermId);\r\n        return (config.fees.token, config.fees.draftFee, config.disputes.penaltyPct);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the min active balance config for a given term\r\n    * @param _termId Identification number of the term querying the min active balance config of\r\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\r\n    * @return Minimum amount of juror tokens that can be activated at the given term\r\n    */\r\n    function _getMinActiveBalance(uint64 _termId, uint64 _lastEnsuredTermId) internal view returns (uint256) {\r\n        Config storage config = _getConfigFor(_termId, _lastEnsuredTermId);\r\n        return config.minActiveBalance;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the Court config for a given term\r\n    * @param _termId Identification number of the term querying the min active balance config of\r\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\r\n    * @return Court config for the given term\r\n    */\r\n    function _getConfigFor(uint64 _termId, uint64 _lastEnsuredTermId) internal view returns (Config storage) {\r\n        uint256 id = _getConfigIdFor(_termId, _lastEnsuredTermId);\r\n        return configs[id];\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the Court config ID for a given term\r\n    * @param _termId Identification number of the term querying the Court config of\r\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\r\n    * @return Identification number of the config for the given terms\r\n    */\r\n    function _getConfigIdFor(uint64 _termId, uint64 _lastEnsuredTermId) internal view returns (uint256) {\r\n        // If the given term is lower or equal to the last ensured Court term, it is safe to use a past Court config\r\n        if (_termId <= _lastEnsuredTermId) {\r\n            return configIdByTerm[_termId];\r\n        }\r\n\r\n        // If the given term is in the future but there is a config change scheduled before it, use the incoming config\r\n        uint64 scheduledChangeTermId = configChangeTermId;\r\n        if (scheduledChangeTermId <= _termId) {\r\n            return configIdByTerm[scheduledChangeTermId];\r\n        }\r\n\r\n        // If no changes are scheduled, use the Court config of the last ensured term\r\n        return configIdByTerm[_lastEnsuredTermId];\r\n    }\r\n}\r\n\r\n// File: @aragon/court/contracts/court/controller/Controller.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\n\r\ncontract Controller is IsContract, CourtClock, CourtConfig {\r\n    string private constant ERROR_SENDER_NOT_GOVERNOR = \"CTR_SENDER_NOT_GOVERNOR\";\r\n    string private constant ERROR_INVALID_GOVERNOR_ADDRESS = \"CTR_INVALID_GOVERNOR_ADDRESS\";\r\n    string private constant ERROR_IMPLEMENTATION_NOT_CONTRACT = \"CTR_IMPLEMENTATION_NOT_CONTRACT\";\r\n    string private constant ERROR_INVALID_IMPLS_INPUT_LENGTH = \"CTR_INVALID_IMPLS_INPUT_LENGTH\";\r\n\r\n    address private constant ZERO_ADDRESS = address(0);\r\n\r\n    // DisputeManager module ID - keccak256(abi.encodePacked(\"DISPUTE_MANAGER\"))\r\n    bytes32 internal constant DISPUTE_MANAGER = 0x14a6c70f0f6d449c014c7bbc9e68e31e79e8474fb03b7194df83109a2d888ae6;\r\n\r\n    // Treasury module ID - keccak256(abi.encodePacked(\"TREASURY\"))\r\n    bytes32 internal constant TREASURY = 0x06aa03964db1f7257357ef09714a5f0ca3633723df419e97015e0c7a3e83edb7;\r\n\r\n    // Voting module ID - keccak256(abi.encodePacked(\"VOTING\"))\r\n    bytes32 internal constant VOTING = 0x7cbb12e82a6d63ff16fe43977f43e3e2b247ecd4e62c0e340da8800a48c67346;\r\n\r\n    // JurorsRegistry module ID - keccak256(abi.encodePacked(\"JURORS_REGISTRY\"))\r\n    bytes32 internal constant JURORS_REGISTRY = 0x3b21d36b36308c830e6c4053fb40a3b6d79dde78947fbf6b0accd30720ab5370;\r\n\r\n    // Subscriptions module ID - keccak256(abi.encodePacked(\"SUBSCRIPTIONS\"))\r\n    bytes32 internal constant SUBSCRIPTIONS = 0x2bfa3327fe52344390da94c32a346eeb1b65a8b583e4335a419b9471e88c1365;\r\n\r\n    /**\r\n    * @dev Governor of the whole system. Set of three addresses to recover funds, change configuration settings and setup modules\r\n    */\r\n    struct Governor {\r\n        address funds;      // This address can be unset at any time. It is allowed to recover funds from the ControlledRecoverable modules\r\n        address config;     // This address is meant not to be unset. It is allowed to change the different configurations of the whole system\r\n        address modules;    // This address can be unset at any time. It is allowed to plug/unplug modules from the system\r\n    }\r\n\r\n    // Governor addresses of the system\r\n    Governor private governor;\r\n\r\n    // List of modules registered for the system indexed by ID\r\n    mapping (bytes32 => address) internal modules;\r\n\r\n    event ModuleSet(bytes32 id, address addr);\r\n    event FundsGovernorChanged(address previousGovernor, address currentGovernor);\r\n    event ConfigGovernorChanged(address previousGovernor, address currentGovernor);\r\n    event ModulesGovernorChanged(address previousGovernor, address currentGovernor);\r\n\r\n    /**\r\n    * @dev Ensure the msg.sender is the funds governor\r\n    */\r\n    modifier onlyFundsGovernor {\r\n        require(msg.sender == governor.funds, ERROR_SENDER_NOT_GOVERNOR);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Ensure the msg.sender is the modules governor\r\n    */\r\n    modifier onlyConfigGovernor {\r\n        require(msg.sender == governor.config, ERROR_SENDER_NOT_GOVERNOR);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Ensure the msg.sender is the modules governor\r\n    */\r\n    modifier onlyModulesGovernor {\r\n        require(msg.sender == governor.modules, ERROR_SENDER_NOT_GOVERNOR);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    * @param _termParams Array containing:\r\n    *        0. _termDuration Duration in seconds per term\r\n    *        1. _firstTermStartTime Timestamp in seconds when the court will open (to give time for juror on-boarding)\r\n    * @param _governors Array containing:\r\n    *        0. _fundsGovernor Address of the funds governor\r\n    *        1. _configGovernor Address of the config governor\r\n    *        2. _modulesGovernor Address of the modules governor\r\n    * @param _feeToken Address of the token contract that is used to pay for fees\r\n    * @param _fees Array containing:\r\n    *        0. jurorFee Amount of fee tokens that is paid per juror per dispute\r\n    *        1. draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    *        2. settleFee Amount of fee tokens per juror to cover round settlement cost\r\n    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *        0. evidenceTerms Max submitting evidence period duration in terms\r\n    *        1. commitTerms Commit period duration in terms\r\n    *        2. revealTerms Reveal period duration in terms\r\n    *        3. appealTerms Appeal period duration in terms\r\n    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @param _pcts Array containing:\r\n    *        0. penaltyPct Permyriad of min active tokens balance to be locked to each drafted jurors (‱ - 1/10,000)\r\n    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\r\n    * @param _roundParams Array containing params for rounds:\r\n    *        0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\r\n    *        1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\r\n    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    *        3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\r\n    * @param _appealCollateralParams Array containing params for appeal collateral:\r\n    *        1. appealCollateralFactor Permyriad multiple of dispute fees required to appeal a preliminary ruling\r\n    *        2. appealConfirmCollateralFactor Permyriad multiple of dispute fees required to confirm appeal\r\n    * @param _minActiveBalance Minimum amount of juror tokens that can be activated\r\n    */\r\n    constructor(\r\n        uint64[2] memory _termParams,\r\n        address[3] memory _governors,\r\n        ERC20 _feeToken,\r\n        uint256[3] memory _fees,\r\n        uint64[5] memory _roundStateDurations,\r\n        uint16[2] memory _pcts,\r\n        uint64[4] memory _roundParams,\r\n        uint256[2] memory _appealCollateralParams,\r\n        uint256 _minActiveBalance\r\n    )\r\n        public\r\n        CourtClock(_termParams)\r\n        CourtConfig(_feeToken, _fees, _roundStateDurations, _pcts, _roundParams, _appealCollateralParams, _minActiveBalance)\r\n    {\r\n        _setFundsGovernor(_governors[0]);\r\n        _setConfigGovernor(_governors[1]);\r\n        _setModulesGovernor(_governors[2]);\r\n    }\r\n\r\n    /**\r\n    * @notice Change Court configuration params\r\n    * @param _fromTermId Identification number of the term in which the config will be effective at\r\n    * @param _feeToken Address of the token contract that is used to pay for fees\r\n    * @param _fees Array containing:\r\n    *        0. jurorFee Amount of fee tokens that is paid per juror per dispute\r\n    *        1. draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    *        2. settleFee Amount of fee tokens per juror to cover round settlement cost\r\n    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *        0. evidenceTerms Max submitting evidence period duration in terms\r\n    *        1. commitTerms Commit period duration in terms\r\n    *        2. revealTerms Reveal period duration in terms\r\n    *        3. appealTerms Appeal period duration in terms\r\n    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @param _pcts Array containing:\r\n    *        0. penaltyPct Permyriad of min active tokens balance to be locked to each drafted jurors (‱ - 1/10,000)\r\n    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\r\n    * @param _roundParams Array containing params for rounds:\r\n    *        0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\r\n    *        1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\r\n    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    *        3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\r\n    * @param _appealCollateralParams Array containing params for appeal collateral:\r\n    *        1. appealCollateralFactor Permyriad multiple of dispute fees required to appeal a preliminary ruling\r\n    *        2. appealConfirmCollateralFactor Permyriad multiple of dispute fees required to confirm appeal\r\n    * @param _minActiveBalance Minimum amount of juror tokens that can be activated\r\n    */\r\n    function setConfig(\r\n        uint64 _fromTermId,\r\n        ERC20 _feeToken,\r\n        uint256[3] calldata _fees,\r\n        uint64[5] calldata _roundStateDurations,\r\n        uint16[2] calldata _pcts,\r\n        uint64[4] calldata _roundParams,\r\n        uint256[2] calldata _appealCollateralParams,\r\n        uint256 _minActiveBalance\r\n    )\r\n        external\r\n        onlyConfigGovernor\r\n    {\r\n        uint64 currentTermId = _ensureCurrentTerm();\r\n        _setConfig(\r\n            currentTermId,\r\n            _fromTermId,\r\n            _feeToken,\r\n            _fees,\r\n            _roundStateDurations,\r\n            _pcts,\r\n            _roundParams,\r\n            _appealCollateralParams,\r\n            _minActiveBalance\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Delay the Court start time to `_newFirstTermStartTime`\r\n    * @param _newFirstTermStartTime New timestamp in seconds when the court will open\r\n    */\r\n    function delayStartTime(uint64 _newFirstTermStartTime) external onlyConfigGovernor {\r\n        _delayStartTime(_newFirstTermStartTime);\r\n    }\r\n\r\n    /**\r\n    * @notice Change funds governor address to `_newFundsGovernor`\r\n    * @param _newFundsGovernor Address of the new funds governor to be set\r\n    */\r\n    function changeFundsGovernor(address _newFundsGovernor) external onlyFundsGovernor {\r\n        require(_newFundsGovernor != ZERO_ADDRESS, ERROR_INVALID_GOVERNOR_ADDRESS);\r\n        _setFundsGovernor(_newFundsGovernor);\r\n    }\r\n\r\n    /**\r\n    * @notice Change config governor address to `_newConfigGovernor`\r\n    * @param _newConfigGovernor Address of the new config governor to be set\r\n    */\r\n    function changeConfigGovernor(address _newConfigGovernor) external onlyConfigGovernor {\r\n        require(_newConfigGovernor != ZERO_ADDRESS, ERROR_INVALID_GOVERNOR_ADDRESS);\r\n        _setConfigGovernor(_newConfigGovernor);\r\n    }\r\n\r\n    /**\r\n    * @notice Change modules governor address to `_newModulesGovernor`\r\n    * @param _newModulesGovernor Address of the new governor to be set\r\n    */\r\n    function changeModulesGovernor(address _newModulesGovernor) external onlyModulesGovernor {\r\n        require(_newModulesGovernor != ZERO_ADDRESS, ERROR_INVALID_GOVERNOR_ADDRESS);\r\n        _setModulesGovernor(_newModulesGovernor);\r\n    }\r\n\r\n    /**\r\n    * @notice Remove the funds governor. Set the funds governor to the zero address.\r\n    * @dev This action cannot be rolled back, once the funds governor has been unset, funds cannot be recovered from recoverable modules anymore\r\n    */\r\n    function ejectFundsGovernor() external onlyFundsGovernor {\r\n        _setFundsGovernor(ZERO_ADDRESS);\r\n    }\r\n\r\n    /**\r\n    * @notice Remove the modules governor. Set the modules governor to the zero address.\r\n    * @dev This action cannot be rolled back, once the modules governor has been unset, system modules cannot be changed anymore\r\n    */\r\n    function ejectModulesGovernor() external onlyModulesGovernor {\r\n        _setModulesGovernor(ZERO_ADDRESS);\r\n    }\r\n\r\n    /**\r\n    * @notice Set module `_id` to `_addr`\r\n    * @param _id ID of the module to be set\r\n    * @param _addr Address of the module to be set\r\n    */\r\n    function setModule(bytes32 _id, address _addr) external onlyModulesGovernor {\r\n        _setModule(_id, _addr);\r\n    }\r\n\r\n    /**\r\n    * @notice Set many modules at once\r\n    * @param _ids List of ids of each module to be set\r\n    * @param _addresses List of addressed of each the module to be set\r\n    */\r\n    function setModules(bytes32[] calldata _ids, address[] calldata _addresses) external onlyModulesGovernor {\r\n        require(_ids.length == _addresses.length, ERROR_INVALID_IMPLS_INPUT_LENGTH);\r\n\r\n        for (uint256 i = 0; i < _ids.length; i++) {\r\n            _setModule(_ids[i], _addresses[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the full Court configuration parameters at a certain term\r\n    * @param _termId Identification number of the term querying the Court config of\r\n    * @return token Address of the token used to pay for fees\r\n    * @return fees Array containing:\r\n    *         0. jurorFee Amount of fee tokens that is paid per juror per dispute\r\n    *         1. draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    *         2. settleFee Amount of fee tokens per juror to cover round settlement cost\r\n    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *         0. evidenceTerms Max submitting evidence period duration in terms\r\n    *         1. commitTerms Commit period duration in terms\r\n    *         2. revealTerms Reveal period duration in terms\r\n    *         3. appealTerms Appeal period duration in terms\r\n    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @return pcts Array containing:\r\n    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\r\n    * @return roundParams Array containing params for rounds:\r\n    *         0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\r\n    *         1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\r\n    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    *         3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\r\n    * @return appealCollateralParams Array containing params for appeal collateral:\r\n    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\r\n    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\r\n    */\r\n    function getConfig(uint64 _termId) external view\r\n        returns (\r\n            ERC20 feeToken,\r\n            uint256[3] memory fees,\r\n            uint64[5] memory roundStateDurations,\r\n            uint16[2] memory pcts,\r\n            uint64[4] memory roundParams,\r\n            uint256[2] memory appealCollateralParams,\r\n            uint256 minActiveBalance\r\n        )\r\n    {\r\n        uint64 lastEnsuredTermId = _lastEnsuredTermId();\r\n        return _getConfigAt(_termId, lastEnsuredTermId);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the draft config at a certain term\r\n    * @param _termId Identification number of the term querying the draft config of\r\n    * @return feeToken Address of the token used to pay for fees\r\n    * @return draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n    */\r\n    function getDraftConfig(uint64 _termId) external view returns (ERC20 feeToken, uint256 draftFee, uint16 penaltyPct) {\r\n        uint64 lastEnsuredTermId = _lastEnsuredTermId();\r\n        return _getDraftConfig(_termId, lastEnsuredTermId);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the min active balance config at a certain term\r\n    * @param _termId Identification number of the term querying the min active balance config of\r\n    * @return Minimum amount of tokens jurors have to activate to participate in the Court\r\n    */\r\n    function getMinActiveBalance(uint64 _termId) external view returns (uint256) {\r\n        uint64 lastEnsuredTermId = _lastEnsuredTermId();\r\n        return _getMinActiveBalance(_termId, lastEnsuredTermId);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the address of the funds governor\r\n    * @return Address of the funds governor\r\n    */\r\n    function getFundsGovernor() external view returns (address) {\r\n        return governor.funds;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the address of the config governor\r\n    * @return Address of the config governor\r\n    */\r\n    function getConfigGovernor() external view returns (address) {\r\n        return governor.config;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the address of the modules governor\r\n    * @return Address of the modules governor\r\n    */\r\n    function getModulesGovernor() external view returns (address) {\r\n        return governor.modules;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell address of a module based on a given ID\r\n    * @param _id ID of the module being queried\r\n    * @return Address of the requested module\r\n    */\r\n    function getModule(bytes32 _id) external view returns (address) {\r\n        return _getModule(_id);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the address of the DisputeManager module\r\n    * @return Address of the DisputeManager module\r\n    */\r\n    function getDisputeManager() external view returns (address) {\r\n        return _getDisputeManager();\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the address of the Treasury module\r\n    * @return Address of the Treasury module\r\n    */\r\n    function getTreasury() external view returns (address) {\r\n        return _getModule(TREASURY);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the address of the Voting module\r\n    * @return Address of the Voting module\r\n    */\r\n    function getVoting() external view returns (address) {\r\n        return _getModule(VOTING);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the address of the JurorsRegistry module\r\n    * @return Address of the JurorsRegistry module\r\n    */\r\n    function getJurorsRegistry() external view returns (address) {\r\n        return _getModule(JURORS_REGISTRY);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the address of the Subscriptions module\r\n    * @return Address of the Subscriptions module\r\n    */\r\n    function getSubscriptions() external view returns (address) {\r\n        return _getSubscriptions();\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to set the address of the funds governor\r\n    * @param _newFundsGovernor Address of the new config governor to be set\r\n    */\r\n    function _setFundsGovernor(address _newFundsGovernor) internal {\r\n        emit FundsGovernorChanged(governor.funds, _newFundsGovernor);\r\n        governor.funds = _newFundsGovernor;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to set the address of the config governor\r\n    * @param _newConfigGovernor Address of the new config governor to be set\r\n    */\r\n    function _setConfigGovernor(address _newConfigGovernor) internal {\r\n        emit ConfigGovernorChanged(governor.config, _newConfigGovernor);\r\n        governor.config = _newConfigGovernor;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to set the address of the modules governor\r\n    * @param _newModulesGovernor Address of the new modules governor to be set\r\n    */\r\n    function _setModulesGovernor(address _newModulesGovernor) internal {\r\n        emit ModulesGovernorChanged(governor.modules, _newModulesGovernor);\r\n        governor.modules = _newModulesGovernor;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to set a module\r\n    * @param _id Id of the module to be set\r\n    * @param _addr Address of the module to be set\r\n    */\r\n    function _setModule(bytes32 _id, address _addr) internal {\r\n        require(isContract(_addr), ERROR_IMPLEMENTATION_NOT_CONTRACT);\r\n        modules[_id] = _addr;\r\n        emit ModuleSet(_id, _addr);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to notify when a term has been transitioned\r\n    * @param _termId Identification number of the new current term that has been transitioned\r\n    */\r\n    function _onTermTransitioned(uint64 _termId) internal {\r\n        _ensureTermConfig(_termId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to tell the address of the DisputeManager module\r\n    * @return Address of the DisputeManager module\r\n    */\r\n    function _getDisputeManager() internal view returns (address) {\r\n        return _getModule(DISPUTE_MANAGER);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to tell the address of the Subscriptions module\r\n    * @return Address of the Subscriptions module\r\n    */\r\n    function _getSubscriptions() internal view returns (address) {\r\n        return _getModule(SUBSCRIPTIONS);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to tell address of a module based on a given ID\r\n    * @param _id ID of the module being queried\r\n    * @return Address of the requested module\r\n    */\r\n    function _getModule(bytes32 _id) internal view returns (address) {\r\n        return modules[_id];\r\n    }\r\n}\r\n\r\n// File: @aragon/court/contracts/court/config/ConfigConsumer.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\n\r\ncontract ConfigConsumer is CourtConfigData {\r\n    /**\r\n    * @dev Internal function to fetch the address of the Config module from the controller\r\n    * @return Address of the Config module\r\n    */\r\n    function _courtConfig() internal view returns (IConfig);\r\n\r\n    /**\r\n    * @dev Internal function to get the Court config for a certain term\r\n    * @param _termId Identification number of the term querying the Court config of\r\n    * @return Court config for the given term\r\n    */\r\n    function _getConfigAt(uint64 _termId) internal view returns (Config memory) {\r\n        (ERC20 _feeToken,\r\n        uint256[3] memory _fees,\r\n        uint64[5] memory _roundStateDurations,\r\n        uint16[2] memory _pcts,\r\n        uint64[4] memory _roundParams,\r\n        uint256[2] memory _appealCollateralParams,\r\n        uint256 _minActiveBalance) = _courtConfig().getConfig(_termId);\r\n\r\n        Config memory config;\r\n\r\n        config.fees = FeesConfig({\r\n            token: _feeToken,\r\n            jurorFee: _fees[0],\r\n            draftFee: _fees[1],\r\n            settleFee: _fees[2],\r\n            finalRoundReduction: _pcts[1]\r\n        });\r\n\r\n        config.disputes = DisputesConfig({\r\n            evidenceTerms: _roundStateDurations[0],\r\n            commitTerms: _roundStateDurations[1],\r\n            revealTerms: _roundStateDurations[2],\r\n            appealTerms: _roundStateDurations[3],\r\n            appealConfirmTerms: _roundStateDurations[4],\r\n            penaltyPct: _pcts[0],\r\n            firstRoundJurorsNumber: _roundParams[0],\r\n            appealStepFactor: _roundParams[1],\r\n            maxRegularAppealRounds: _roundParams[2],\r\n            finalRoundLockTerms: _roundParams[3],\r\n            appealCollateralFactor: _appealCollateralParams[0],\r\n            appealConfirmCollateralFactor: _appealCollateralParams[1]\r\n        });\r\n\r\n        config.minActiveBalance = _minActiveBalance;\r\n\r\n        return config;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the draft config for a given term\r\n    * @param _termId Identification number of the term querying the draft config of\r\n    * @return Draft config for the given term\r\n    */\r\n    function _getDraftConfig(uint64 _termId) internal view returns (DraftConfig memory) {\r\n        (ERC20 feeToken, uint256 draftFee, uint16 penaltyPct) = _courtConfig().getDraftConfig(_termId);\r\n        return DraftConfig({ feeToken: feeToken, draftFee: draftFee, penaltyPct: penaltyPct });\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the min active balance config for a given term\r\n    * @param _termId Identification number of the term querying the min active balance config of\r\n    * @return Minimum amount of juror tokens that can be activated\r\n    */\r\n    function _getMinActiveBalance(uint64 _termId) internal view returns (uint256) {\r\n        return _courtConfig().getMinActiveBalance(_termId);\r\n    }\r\n}\r\n\r\n// File: @aragon/court/contracts/voting/ICRVotingOwner.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\ninterface ICRVotingOwner {\r\n    /**\r\n    * @dev Ensure votes can be committed for a vote instance, revert otherwise\r\n    * @param _voteId ID of the vote instance to request the weight of a voter for\r\n    */\r\n    function ensureCanCommit(uint256 _voteId) external;\r\n\r\n    /**\r\n    * @dev Ensure a certain voter can commit votes for a vote instance, revert otherwise\r\n    * @param _voteId ID of the vote instance to request the weight of a voter for\r\n    * @param _voter Address of the voter querying the weight of\r\n    */\r\n    function ensureCanCommit(uint256 _voteId, address _voter) external;\r\n\r\n    /**\r\n    * @dev Ensure a certain voter can reveal votes for vote instance, revert otherwise\r\n    * @param _voteId ID of the vote instance to request the weight of a voter for\r\n    * @param _voter Address of the voter querying the weight of\r\n    * @return Weight of the requested juror for the requested vote instance\r\n    */\r\n    function ensureCanReveal(uint256 _voteId, address _voter) external returns (uint64);\r\n}\r\n\r\n// File: @aragon/court/contracts/voting/ICRVoting.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\ninterface ICRVoting {\r\n    /**\r\n    * @dev Create a new vote instance\r\n    * @dev This function can only be called by the CRVoting owner\r\n    * @param _voteId ID of the new vote instance to be created\r\n    * @param _possibleOutcomes Number of possible outcomes for the new vote instance to be created\r\n    */\r\n    function create(uint256 _voteId, uint8 _possibleOutcomes) external;\r\n\r\n    /**\r\n    * @dev Get the winning outcome of a vote instance\r\n    * @param _voteId ID of the vote instance querying the winning outcome of\r\n    * @return Winning outcome of the given vote instance or refused in case it's missing\r\n    */\r\n    function getWinningOutcome(uint256 _voteId) external view returns (uint8);\r\n\r\n    /**\r\n    * @dev Get the tally of an outcome for a certain vote instance\r\n    * @param _voteId ID of the vote instance querying the tally of\r\n    * @param _outcome Outcome querying the tally of\r\n    * @return Tally of the outcome being queried for the given vote instance\r\n    */\r\n    function getOutcomeTally(uint256 _voteId, uint8 _outcome) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Tell whether an outcome is valid for a given vote instance or not\r\n    * @param _voteId ID of the vote instance to check the outcome of\r\n    * @param _outcome Outcome to check if valid or not\r\n    * @return True if the given outcome is valid for the requested vote instance, false otherwise\r\n    */\r\n    function isValidOutcome(uint256 _voteId, uint8 _outcome) external view returns (bool);\r\n\r\n    /**\r\n    * @dev Get the outcome voted by a voter for a certain vote instance\r\n    * @param _voteId ID of the vote instance querying the outcome of\r\n    * @param _voter Address of the voter querying the outcome of\r\n    * @return Outcome of the voter for the given vote instance\r\n    */\r\n    function getVoterOutcome(uint256 _voteId, address _voter) external view returns (uint8);\r\n\r\n    /**\r\n    * @dev Tell whether a voter voted in favor of a certain outcome in a vote instance or not\r\n    * @param _voteId ID of the vote instance to query if a voter voted in favor of a certain outcome\r\n    * @param _outcome Outcome to query if the given voter voted in favor of\r\n    * @param _voter Address of the voter to query if voted in favor of the given outcome\r\n    * @return True if the given voter voted in favor of the given outcome, false otherwise\r\n    */\r\n    function hasVotedInFavorOf(uint256 _voteId, uint8 _outcome, address _voter) external view returns (bool);\r\n\r\n    /**\r\n    * @dev Filter a list of voters based on whether they voted in favor of a certain outcome in a vote instance or not\r\n    * @param _voteId ID of the vote instance to be checked\r\n    * @param _outcome Outcome to filter the list of voters of\r\n    * @param _voters List of addresses of the voters to be filtered\r\n    * @return List of results to tell whether a voter voted in favor of the given outcome or not\r\n    */\r\n    function getVotersInFavorOf(uint256 _voteId, uint8 _outcome, address[] calldata _voters) external view returns (bool[] memory);\r\n}\r\n\r\n// File: @aragon/court/contracts/treasury/ITreasury.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\ninterface ITreasury {\r\n    /**\r\n    * @dev Assign a certain amount of tokens to an account\r\n    * @param _token ERC20 token to be assigned\r\n    * @param _to Address of the recipient that will be assigned the tokens to\r\n    * @param _amount Amount of tokens to be assigned to the recipient\r\n    */\r\n    function assign(ERC20 _token, address _to, uint256 _amount) external;\r\n\r\n    /**\r\n    * @dev Withdraw a certain amount of tokens\r\n    * @param _token ERC20 token to be withdrawn\r\n    * @param _to Address of the recipient that will receive the tokens\r\n    * @param _amount Amount of tokens to be withdrawn from the sender\r\n    */\r\n    function withdraw(ERC20 _token, address _to, uint256 _amount) external;\r\n}\r\n\r\n// File: @aragon/court/contracts/arbitration/IArbitrator.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\ninterface IArbitrator {\r\n    /**\r\n    * @dev Create a dispute over the Arbitrable sender with a number of possible rulings\r\n    * @param _possibleRulings Number of possible rulings allowed for the dispute\r\n    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\r\n    * @return Dispute identification number\r\n    */\r\n    function createDispute(uint256 _possibleRulings, bytes calldata _metadata) external returns (uint256);\r\n\r\n    /**\r\n    * @dev Close the evidence period of a dispute\r\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\r\n    */\r\n    function closeEvidencePeriod(uint256 _disputeId) external;\r\n\r\n    /**\r\n    * @dev Execute the Arbitrable associated to a dispute based on its final ruling\r\n    * @param _disputeId Identification number of the dispute to be executed\r\n    */\r\n    function executeRuling(uint256 _disputeId) external;\r\n\r\n    /**\r\n    * @dev Tell the dispute fees information to create a dispute\r\n    * @return recipient Address where the corresponding dispute fees must be transferred to\r\n    * @return feeToken ERC20 token used for the fees\r\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\r\n    */\r\n    function getDisputeFees() external view returns (address recipient, ERC20 feeToken, uint256 feeAmount);\r\n\r\n    /**\r\n    * @dev Tell the subscription fees information for a subscriber to be up-to-date\r\n    * @param _subscriber Address of the account paying the subscription fees for\r\n    * @return recipient Address where the corresponding subscriptions fees must be transferred to\r\n    * @return feeToken ERC20 token used for the subscription fees\r\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\r\n    */\r\n    function getSubscriptionFees(address _subscriber) external view returns (address recipient, ERC20 feeToken, uint256 feeAmount);\r\n}\r\n\r\n// File: @aragon/court/contracts/standards/ERC165.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\ninterface ERC165 {\r\n    /**\r\n    * @dev Query if a contract implements a certain interface\r\n    * @param _interfaceId The interface identifier being queried, as specified in ERC-165\r\n    * @return True if the contract implements the requested interface and if its not 0xffffffff, false otherwise\r\n    */\r\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool);\r\n}\r\n\r\n// File: @aragon/court/contracts/arbitration/IArbitrable.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\ncontract IArbitrable is ERC165 {\r\n    bytes4 internal constant ERC165_INTERFACE_ID = bytes4(0x01ffc9a7);\r\n    bytes4 internal constant ARBITRABLE_INTERFACE_ID = bytes4(0x88f3ee69);\r\n\r\n    /**\r\n    * @dev Emitted when an IArbitrable instance's dispute is ruled by an IArbitrator\r\n    * @param arbitrator IArbitrator instance ruling the dispute\r\n    * @param disputeId Identification number of the dispute being ruled by the arbitrator\r\n    * @param ruling Ruling given by the arbitrator\r\n    */\r\n    event Ruled(IArbitrator indexed arbitrator, uint256 indexed disputeId, uint256 ruling);\r\n\r\n    /**\r\n    * @dev Emitted when new evidence is submitted for the IArbitrable instance's dispute\r\n    * @param disputeId Identification number of the dispute receiving new evidence\r\n    * @param submitter Address of the account submitting the evidence\r\n    * @param evidence Data submitted for the evidence of the dispute\r\n    * @param finished Whether or not the submitter has finished submitting evidence\r\n    */\r\n    event EvidenceSubmitted(uint256 indexed disputeId, address indexed submitter, bytes evidence, bool finished);\r\n\r\n    /**\r\n    * @dev Submit evidence for a dispute\r\n    * @param _disputeId Id of the dispute in the Court\r\n    * @param _evidence Data submitted for the evidence related to the dispute\r\n    * @param _finished Whether or not the submitter has finished submitting evidence\r\n    */\r\n    function submitEvidence(uint256 _disputeId, bytes calldata _evidence, bool _finished) external;\r\n\r\n    /**\r\n    * @dev Give a ruling for a certain dispute, the account calling it must have rights to rule on the contract\r\n    * @param _disputeId Identification number of the dispute to be ruled\r\n    * @param _ruling Ruling given by the arbitrator, where 0 is reserved for \"refused to make a decision\"\r\n    */\r\n    function rule(uint256 _disputeId, uint256 _ruling) external;\r\n\r\n    /**\r\n    * @dev ERC165 - Query if a contract implements a certain interface\r\n    * @param _interfaceId The interface identifier being queried, as specified in ERC-165\r\n    * @return True if this contract supports the given interface, false otherwise\r\n    */\r\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool) {\r\n        return _interfaceId == ARBITRABLE_INTERFACE_ID || _interfaceId == ERC165_INTERFACE_ID;\r\n    }\r\n}\r\n\r\n// File: @aragon/court/contracts/disputes/IDisputeManager.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\ninterface IDisputeManager {\r\n    enum DisputeState {\r\n        PreDraft,\r\n        Adjudicating,\r\n        Ruled\r\n    }\r\n\r\n    enum AdjudicationState {\r\n        Invalid,\r\n        Committing,\r\n        Revealing,\r\n        Appealing,\r\n        ConfirmingAppeal,\r\n        Ended\r\n    }\r\n\r\n    /**\r\n    * @dev Create a dispute to be drafted in a future term\r\n    * @param _subject Arbitrable instance creating the dispute\r\n    * @param _possibleRulings Number of possible rulings allowed for the drafted jurors to vote on the dispute\r\n    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\r\n    * @return Dispute identification number\r\n    */\r\n    function createDispute(IArbitrable _subject, uint8 _possibleRulings, bytes calldata _metadata) external returns (uint256);\r\n\r\n    /**\r\n    * @dev Close the evidence period of a dispute\r\n    * @param _subject IArbitrable instance requesting to close the evidence submission period\r\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\r\n    */\r\n    function closeEvidencePeriod(IArbitrable _subject, uint256 _disputeId) external;\r\n\r\n    /**\r\n    * @dev Draft jurors for the next round of a dispute\r\n    * @param _disputeId Identification number of the dispute to be drafted\r\n    */\r\n    function draft(uint256 _disputeId) external;\r\n\r\n    /**\r\n    * @dev Appeal round of a dispute in favor of a certain ruling\r\n    * @param _disputeId Identification number of the dispute being appealed\r\n    * @param _roundId Identification number of the dispute round being appealed\r\n    * @param _ruling Ruling appealing a dispute round in favor of\r\n    */\r\n    function createAppeal(uint256 _disputeId, uint256 _roundId, uint8 _ruling) external;\r\n\r\n    /**\r\n    * @dev Confirm appeal for a round of a dispute in favor of a ruling\r\n    * @param _disputeId Identification number of the dispute confirming an appeal of\r\n    * @param _roundId Identification number of the dispute round confirming an appeal of\r\n    * @param _ruling Ruling being confirmed against a dispute round appeal\r\n    */\r\n    function confirmAppeal(uint256 _disputeId, uint256 _roundId, uint8 _ruling) external;\r\n\r\n    /**\r\n    * @dev Compute the final ruling for a dispute\r\n    * @param _disputeId Identification number of the dispute to compute its final ruling\r\n    * @return subject Arbitrable instance associated to the dispute\r\n    * @return finalRuling Final ruling decided for the given dispute\r\n    */\r\n    function computeRuling(uint256 _disputeId) external returns (IArbitrable subject, uint8 finalRuling);\r\n\r\n    /**\r\n    * @dev Settle penalties for a round of a dispute\r\n    * @param _disputeId Identification number of the dispute to settle penalties for\r\n    * @param _roundId Identification number of the dispute round to settle penalties for\r\n    * @param _jurorsToSettle Maximum number of jurors to be slashed in this call\r\n    */\r\n    function settlePenalties(uint256 _disputeId, uint256 _roundId, uint256 _jurorsToSettle) external;\r\n\r\n    /**\r\n    * @dev Claim rewards for a round of a dispute for juror\r\n    * @dev For regular rounds, it will only reward winning jurors\r\n    * @param _disputeId Identification number of the dispute to settle rewards for\r\n    * @param _roundId Identification number of the dispute round to settle rewards for\r\n    * @param _juror Address of the juror to settle their rewards\r\n    */\r\n    function settleReward(uint256 _disputeId, uint256 _roundId, address _juror) external;\r\n\r\n    /**\r\n    * @dev Settle appeal deposits for a round of a dispute\r\n    * @param _disputeId Identification number of the dispute to settle appeal deposits for\r\n    * @param _roundId Identification number of the dispute round to settle appeal deposits for\r\n    */\r\n    function settleAppealDeposit(uint256 _disputeId, uint256 _roundId) external;\r\n\r\n    /**\r\n    * @dev Tell the amount of token fees required to create a dispute\r\n    * @return feeToken ERC20 token used for the fees\r\n    * @return feeAmount Total amount of fees to be paid for a dispute at the given term\r\n    */\r\n    function getDisputeFees() external view returns (ERC20 feeToken, uint256 feeAmount);\r\n\r\n    /**\r\n    * @dev Tell information of a certain dispute\r\n    * @param _disputeId Identification number of the dispute being queried\r\n    * @return subject Arbitrable subject being disputed\r\n    * @return possibleRulings Number of possible rulings allowed for the drafted jurors to vote on the dispute\r\n    * @return state Current state of the dispute being queried: pre-draft, adjudicating, or ruled\r\n    * @return finalRuling The winning ruling in case the dispute is finished\r\n    * @return lastRoundId Identification number of the last round created for the dispute\r\n    * @return createTermId Identification number of the term when the dispute was created\r\n    */\r\n    function getDispute(uint256 _disputeId) external view\r\n        returns (IArbitrable subject, uint8 possibleRulings, DisputeState state, uint8 finalRuling, uint256 lastRoundId, uint64 createTermId);\r\n\r\n    /**\r\n    * @dev Tell information of a certain adjudication round\r\n    * @param _disputeId Identification number of the dispute being queried\r\n    * @param _roundId Identification number of the round being queried\r\n    * @return draftTerm Term from which the requested round can be drafted\r\n    * @return delayedTerms Number of terms the given round was delayed based on its requested draft term id\r\n    * @return jurorsNumber Number of jurors requested for the round\r\n    * @return selectedJurors Number of jurors already selected for the requested round\r\n    * @return settledPenalties Whether or not penalties have been settled for the requested round\r\n    * @return collectedTokens Amount of juror tokens that were collected from slashed jurors for the requested round\r\n    * @return coherentJurors Number of jurors that voted in favor of the final ruling in the requested round\r\n    * @return state Adjudication state of the requested round\r\n    */\r\n    function getRound(uint256 _disputeId, uint256 _roundId) external view\r\n        returns (\r\n            uint64 draftTerm,\r\n            uint64 delayedTerms,\r\n            uint64 jurorsNumber,\r\n            uint64 selectedJurors,\r\n            uint256 jurorFees,\r\n            bool settledPenalties,\r\n            uint256 collectedTokens,\r\n            uint64 coherentJurors,\r\n            AdjudicationState state\r\n        );\r\n\r\n    /**\r\n    * @dev Tell appeal-related information of a certain adjudication round\r\n    * @param _disputeId Identification number of the dispute being queried\r\n    * @param _roundId Identification number of the round being queried\r\n    * @return maker Address of the account appealing the given round\r\n    * @return appealedRuling Ruling confirmed by the appealer of the given round\r\n    * @return taker Address of the account confirming the appeal of the given round\r\n    * @return opposedRuling Ruling confirmed by the appeal taker of the given round\r\n    */\r\n    function getAppeal(uint256 _disputeId, uint256 _roundId) external view\r\n        returns (address maker, uint64 appealedRuling, address taker, uint64 opposedRuling);\r\n\r\n    /**\r\n    * @dev Tell information related to the next round due to an appeal of a certain round given.\r\n    * @param _disputeId Identification number of the dispute being queried\r\n    * @param _roundId Identification number of the round requesting the appeal details of\r\n    * @return nextRoundStartTerm Term ID from which the next round will start\r\n    * @return nextRoundJurorsNumber Jurors number for the next round\r\n    * @return newDisputeState New state for the dispute associated to the given round after the appeal\r\n    * @return feeToken ERC20 token used for the next round fees\r\n    * @return jurorFees Total amount of fees to be distributed between the winning jurors of the next round\r\n    * @return totalFees Total amount of fees for a regular round at the given term\r\n    * @return appealDeposit Amount to be deposit of fees for a regular round at the given term\r\n    * @return confirmAppealDeposit Total amount of fees for a regular round at the given term\r\n    */\r\n    function getNextRoundDetails(uint256 _disputeId, uint256 _roundId) external view\r\n        returns (\r\n            uint64 nextRoundStartTerm,\r\n            uint64 nextRoundJurorsNumber,\r\n            DisputeState newDisputeState,\r\n            ERC20 feeToken,\r\n            uint256 totalFees,\r\n            uint256 jurorFees,\r\n            uint256 appealDeposit,\r\n            uint256 confirmAppealDeposit\r\n        );\r\n\r\n    /**\r\n    * @dev Tell juror-related information of a certain adjudication round\r\n    * @param _disputeId Identification number of the dispute being queried\r\n    * @param _roundId Identification number of the round being queried\r\n    * @param _juror Address of the juror being queried\r\n    * @return weight Juror weight drafted for the requested round\r\n    * @return rewarded Whether or not the given juror was rewarded based on the requested round\r\n    */\r\n    function getJuror(uint256 _disputeId, uint256 _roundId, address _juror) external view returns (uint64 weight, bool rewarded);\r\n}\r\n\r\n// File: @aragon/court/contracts/subscriptions/ISubscriptions.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\ninterface ISubscriptions {\r\n    /**\r\n    * @dev Tell whether a certain subscriber has paid all the fees up to current period or not\r\n    * @param _subscriber Address of subscriber being checked\r\n    * @return True if subscriber has paid all the fees up to current period, false otherwise\r\n    */\r\n    function isUpToDate(address _subscriber) external view returns (bool);\r\n\r\n    /**\r\n    * @dev Tell the minimum amount of fees to pay and resulting last paid period for a given subscriber in order to be up-to-date\r\n    * @param _subscriber Address of the subscriber willing to pay\r\n    * @return feeToken ERC20 token used for the subscription fees\r\n    * @return amountToPay Amount of subscription fee tokens to be paid\r\n    * @return newLastPeriodId Identification number of the resulting last paid period\r\n    */\r\n    function getOwedFeesDetails(address _subscriber) external view returns (ERC20, uint256, uint256);\r\n}\r\n\r\n// File: @aragon/court/contracts/court/controller/Controlled.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Controlled is IsContract, ConfigConsumer {\r\n    string private constant ERROR_CONTROLLER_NOT_CONTRACT = \"CTD_CONTROLLER_NOT_CONTRACT\";\r\n    string private constant ERROR_SENDER_NOT_CONTROLLER = \"CTD_SENDER_NOT_CONTROLLER\";\r\n    string private constant ERROR_SENDER_NOT_CONFIG_GOVERNOR = \"CTD_SENDER_NOT_CONFIG_GOVERNOR\";\r\n    string private constant ERROR_SENDER_NOT_DISPUTES_MODULE = \"CTD_SENDER_NOT_DISPUTES_MODULE\";\r\n\r\n    // Address of the controller\r\n    Controller internal controller;\r\n\r\n    /**\r\n    * @dev Ensure the msg.sender is the controller's config governor\r\n    */\r\n    modifier onlyConfigGovernor {\r\n        require(msg.sender == _configGovernor(), ERROR_SENDER_NOT_CONFIG_GOVERNOR);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Ensure the msg.sender is the controller\r\n    */\r\n    modifier onlyController() {\r\n        require(msg.sender == address(controller), ERROR_SENDER_NOT_CONTROLLER);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Ensure the msg.sender is the DisputeManager module\r\n    */\r\n    modifier onlyDisputeManager() {\r\n        require(msg.sender == address(_disputeManager()), ERROR_SENDER_NOT_DISPUTES_MODULE);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    * @param _controller Address of the controller\r\n    */\r\n    constructor(Controller _controller) public {\r\n        require(isContract(address(_controller)), ERROR_CONTROLLER_NOT_CONTRACT);\r\n        controller = _controller;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the address of the controller\r\n    * @return Address of the controller\r\n    */\r\n    function getController() external view returns (Controller) {\r\n        return controller;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to ensure the Court term is up-to-date, it will try to update it if not\r\n    * @return Identification number of the current Court term\r\n    */\r\n    function _ensureCurrentTerm() internal returns (uint64) {\r\n        return _clock().ensureCurrentTerm();\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to fetch the last ensured term ID of the Court\r\n    * @return Identification number of the last ensured term\r\n    */\r\n    function _getLastEnsuredTermId() internal view returns (uint64) {\r\n        return _clock().getLastEnsuredTermId();\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to tell the current term identification number\r\n    * @return Identification number of the current term\r\n    */\r\n    function _getCurrentTermId() internal view returns (uint64) {\r\n        return _clock().getCurrentTermId();\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to fetch the controller's config governor\r\n    * @return Address of the controller's governor\r\n    */\r\n    function _configGovernor() internal view returns (address) {\r\n        return controller.getConfigGovernor();\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to fetch the address of the DisputeManager module from the controller\r\n    * @return Address of the DisputeManager module\r\n    */\r\n    function _disputeManager() internal view returns (IDisputeManager) {\r\n        return IDisputeManager(controller.getDisputeManager());\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to fetch the address of the Treasury module implementation from the controller\r\n    * @return Address of the Treasury module implementation\r\n    */\r\n    function _treasury() internal view returns (ITreasury) {\r\n        return ITreasury(controller.getTreasury());\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to fetch the address of the Voting module implementation from the controller\r\n    * @return Address of the Voting module implementation\r\n    */\r\n    function _voting() internal view returns (ICRVoting) {\r\n        return ICRVoting(controller.getVoting());\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to fetch the address of the Voting module owner from the controller\r\n    * @return Address of the Voting module owner\r\n    */\r\n    function _votingOwner() internal view returns (ICRVotingOwner) {\r\n        return ICRVotingOwner(address(_disputeManager()));\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to fetch the address of the JurorRegistry module implementation from the controller\r\n    * @return Address of the JurorRegistry module implementation\r\n    */\r\n    function _jurorsRegistry() internal view returns (IJurorsRegistry) {\r\n        return IJurorsRegistry(controller.getJurorsRegistry());\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to fetch the address of the Subscriptions module implementation from the controller\r\n    * @return Address of the Subscriptions module implementation\r\n    */\r\n    function _subscriptions() internal view returns (ISubscriptions) {\r\n        return ISubscriptions(controller.getSubscriptions());\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to fetch the address of the Clock module from the controller\r\n    * @return Address of the Clock module\r\n    */\r\n    function _clock() internal view returns (IClock) {\r\n        return IClock(controller);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to fetch the address of the Config module from the controller\r\n    * @return Address of the Config module\r\n    */\r\n    function _courtConfig() internal view returns (IConfig) {\r\n        return IConfig(controller);\r\n    }\r\n}\r\n\r\n// File: @aragon/court/contracts/court/controller/ControlledRecoverable.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\n\r\ncontract ControlledRecoverable is Controlled {\r\n    using SafeERC20 for ERC20;\r\n\r\n    string private constant ERROR_SENDER_NOT_FUNDS_GOVERNOR = \"CTD_SENDER_NOT_FUNDS_GOVERNOR\";\r\n    string private constant ERROR_INSUFFICIENT_RECOVER_FUNDS = \"CTD_INSUFFICIENT_RECOVER_FUNDS\";\r\n    string private constant ERROR_RECOVER_TOKEN_FUNDS_FAILED = \"CTD_RECOVER_TOKEN_FUNDS_FAILED\";\r\n\r\n    event RecoverFunds(ERC20 token, address recipient, uint256 balance);\r\n\r\n    /**\r\n    * @dev Ensure the msg.sender is the controller's funds governor\r\n    */\r\n    modifier onlyFundsGovernor {\r\n        require(msg.sender == controller.getFundsGovernor(), ERROR_SENDER_NOT_FUNDS_GOVERNOR);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    * @param _controller Address of the controller\r\n    */\r\n    constructor(Controller _controller) Controlled(_controller) public {\r\n        // solium-disable-previous-line no-empty-blocks\r\n    }\r\n\r\n    /**\r\n    * @notice Transfer all `_token` tokens to `_to`\r\n    * @param _token ERC20 token to be recovered\r\n    * @param _to Address of the recipient that will be receive all the funds of the requested token\r\n    */\r\n    function recoverFunds(ERC20 _token, address _to) external onlyFundsGovernor {\r\n        uint256 balance = _token.balanceOf(address(this));\r\n        require(balance > 0, ERROR_INSUFFICIENT_RECOVER_FUNDS);\r\n        require(_token.safeTransfer(_to, balance), ERROR_RECOVER_TOKEN_FUNDS_FAILED);\r\n        emit RecoverFunds(_token, _to, balance);\r\n    }\r\n}\r\n\r\n// File: @aragon/court/contracts/registry/JurorsRegistry.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract JurorsRegistry is ControlledRecoverable, IJurorsRegistry, ERC900, ApproveAndCallFallBack {\r\n    using SafeERC20 for ERC20;\r\n    using SafeMath for uint256;\r\n    using PctHelpers for uint256;\r\n    using BytesHelpers for bytes;\r\n    using HexSumTree for HexSumTree.Tree;\r\n    using JurorsTreeSortition for HexSumTree.Tree;\r\n\r\n    string private constant ERROR_NOT_CONTRACT = \"JR_NOT_CONTRACT\";\r\n    string private constant ERROR_INVALID_ZERO_AMOUNT = \"JR_INVALID_ZERO_AMOUNT\";\r\n    string private constant ERROR_INVALID_ACTIVATION_AMOUNT = \"JR_INVALID_ACTIVATION_AMOUNT\";\r\n    string private constant ERROR_INVALID_DEACTIVATION_AMOUNT = \"JR_INVALID_DEACTIVATION_AMOUNT\";\r\n    string private constant ERROR_INVALID_LOCKED_AMOUNTS_LENGTH = \"JR_INVALID_LOCKED_AMOUNTS_LEN\";\r\n    string private constant ERROR_INVALID_REWARDED_JURORS_LENGTH = \"JR_INVALID_REWARDED_JURORS_LEN\";\r\n    string private constant ERROR_ACTIVE_BALANCE_BELOW_MIN = \"JR_ACTIVE_BALANCE_BELOW_MIN\";\r\n    string private constant ERROR_NOT_ENOUGH_AVAILABLE_BALANCE = \"JR_NOT_ENOUGH_AVAILABLE_BALANCE\";\r\n    string private constant ERROR_CANNOT_REDUCE_DEACTIVATION_REQUEST = \"JR_CANT_REDUCE_DEACTIVATION_REQ\";\r\n    string private constant ERROR_TOKEN_TRANSFER_FAILED = \"JR_TOKEN_TRANSFER_FAILED\";\r\n    string private constant ERROR_TOKEN_APPROVE_NOT_ALLOWED = \"JR_TOKEN_APPROVE_NOT_ALLOWED\";\r\n    string private constant ERROR_BAD_TOTAL_ACTIVE_BALANCE_LIMIT = \"JR_BAD_TOTAL_ACTIVE_BAL_LIMIT\";\r\n    string private constant ERROR_TOTAL_ACTIVE_BALANCE_EXCEEDED = \"JR_TOTAL_ACTIVE_BALANCE_EXCEEDED\";\r\n    string private constant ERROR_WITHDRAWALS_LOCK = \"JR_WITHDRAWALS_LOCK\";\r\n\r\n    // Address that will be used to burn juror tokens\r\n    address internal constant BURN_ACCOUNT = address(0x000000000000000000000000000000000000dEaD);\r\n\r\n    // Maximum number of sortition iterations allowed per draft call\r\n    uint256 internal constant MAX_DRAFT_ITERATIONS = 10;\r\n\r\n    /**\r\n    * @dev Jurors have three kind of balances, these are:\r\n    *      - active: tokens activated for the Court that can be locked in case the juror is drafted\r\n    *      - locked: amount of active tokens that are locked for a draft\r\n    *      - available: tokens that are not activated for the Court and can be withdrawn by the juror at any time\r\n    *\r\n    *      Due to a gas optimization for drafting, the \"active\" tokens are stored in a `HexSumTree`, while the others\r\n    *      are stored in this contract as `lockedBalance` and `availableBalance` respectively. Given that the jurors'\r\n    *      active balances cannot be affected during the current Court term, if jurors want to deactivate some of their\r\n    *      active tokens, their balance will be updated for the following term, and they won't be allowed to\r\n    *      withdraw them until the current term has ended.\r\n    *\r\n    *      Note that even though jurors balances are stored separately, all the balances are held by this contract.\r\n    */\r\n    struct Juror {\r\n        uint256 id;                                 // Key in the jurors tree used for drafting\r\n        uint256 lockedBalance;                      // Maximum amount of tokens that can be slashed based on the juror's drafts\r\n        uint256 availableBalance;                   // Available tokens that can be withdrawn at any time\r\n        uint64 withdrawalsLockTermId;               // Term ID until which the juror's withdrawals will be locked\r\n        DeactivationRequest deactivationRequest;    // Juror's pending deactivation request\r\n    }\r\n\r\n    /**\r\n    * @dev Given that the jurors balances cannot be affected during a Court term, if jurors want to deactivate some\r\n    *      of their tokens, the tree will always be updated for the following term, and they won't be able to\r\n    *      withdraw the requested amount until the current term has finished. Thus, we need to keep track the term\r\n    *      when a token deactivation was requested and its corresponding amount.\r\n    */\r\n    struct DeactivationRequest {\r\n        uint256 amount;                             // Amount requested for deactivation\r\n        uint64 availableTermId;                     // Term ID when jurors can withdraw their requested deactivation tokens\r\n    }\r\n\r\n    /**\r\n    * @dev Internal struct to wrap all the params required to perform jurors drafting\r\n    */\r\n    struct DraftParams {\r\n        bytes32 termRandomness;                     // Randomness seed to be used for the draft\r\n        uint256 disputeId;                          // ID of the dispute being drafted\r\n        uint64 termId;                              // Term ID of the dispute's draft term\r\n        uint256 selectedJurors;                     // Number of jurors already selected for the draft\r\n        uint256 batchRequestedJurors;               // Number of jurors to be selected in the given batch of the draft\r\n        uint256 roundRequestedJurors;               // Total number of jurors requested to be drafted\r\n        uint256 draftLockAmount;                    // Amount of tokens to be locked to each drafted juror\r\n        uint256 iteration;                          // Sortition iteration number\r\n    }\r\n\r\n    // Maximum amount of total active balance that can be held in the registry\r\n    uint256 internal totalActiveBalanceLimit;\r\n\r\n    // Juror ERC20 token\r\n    ERC20 internal jurorsToken;\r\n\r\n    // Mapping of juror data indexed by address\r\n    mapping (address => Juror) internal jurorsByAddress;\r\n\r\n    // Mapping of juror addresses indexed by id\r\n    mapping (uint256 => address) internal jurorsAddressById;\r\n\r\n    // Tree to store jurors active balance by term for the drafting process\r\n    HexSumTree.Tree internal tree;\r\n\r\n    event JurorActivated(address indexed juror, uint64 fromTermId, uint256 amount, address sender);\r\n    event JurorDeactivationRequested(address indexed juror, uint64 availableTermId, uint256 amount);\r\n    event JurorDeactivationProcessed(address indexed juror, uint64 availableTermId, uint256 amount, uint64 processedTermId);\r\n    event JurorDeactivationUpdated(address indexed juror, uint64 availableTermId, uint256 amount, uint64 updateTermId);\r\n    event JurorBalanceLocked(address indexed juror, uint256 amount);\r\n    event JurorBalanceUnlocked(address indexed juror, uint256 amount);\r\n    event JurorSlashed(address indexed juror, uint256 amount, uint64 effectiveTermId);\r\n    event JurorTokensAssigned(address indexed juror, uint256 amount);\r\n    event JurorTokensBurned(uint256 amount);\r\n    event JurorTokensCollected(address indexed juror, uint256 amount, uint64 effectiveTermId);\r\n    event TotalActiveBalanceLimitChanged(uint256 previousTotalActiveBalanceLimit, uint256 currentTotalActiveBalanceLimit);\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    * @param _controller Address of the controller\r\n    * @param _jurorToken Address of the ERC20 token to be used as juror token for the registry\r\n    * @param _totalActiveBalanceLimit Maximum amount of total active balance that can be held in the registry\r\n    */\r\n    constructor(Controller _controller, ERC20 _jurorToken, uint256 _totalActiveBalanceLimit)\r\n        ControlledRecoverable(_controller)\r\n        public\r\n    {\r\n        // No need to explicitly call `Controlled` constructor since `ControlledRecoverable` is already doing it\r\n        require(isContract(address(_jurorToken)), ERROR_NOT_CONTRACT);\r\n\r\n        jurorsToken = _jurorToken;\r\n        _setTotalActiveBalanceLimit(_totalActiveBalanceLimit);\r\n\r\n        tree.init();\r\n        // First tree item is an empty juror\r\n        assert(tree.insert(0, 0) == 0);\r\n    }\r\n\r\n    /**\r\n    * @notice Activate `_amount == 0 ? 'all available tokens' : @tokenAmount(self.token(), _amount)` for the next term\r\n    * @param _amount Amount of juror tokens to be activated for the next term\r\n    */\r\n    function activate(uint256 _amount) external {\r\n        _activateTokens(msg.sender, _amount, msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @notice Deactivate `_amount == 0 ? 'all unlocked tokens' : @tokenAmount(self.token(), _amount)` for the next term\r\n    * @param _amount Amount of juror tokens to be deactivated for the next term\r\n    */\r\n    function deactivate(uint256 _amount) external {\r\n        uint64 termId = _ensureCurrentTerm();\r\n        Juror storage juror = jurorsByAddress[msg.sender];\r\n        uint256 unlockedActiveBalance = _lastUnlockedActiveBalanceOf(juror);\r\n        uint256 amountToDeactivate = _amount == 0 ? unlockedActiveBalance : _amount;\r\n        require(amountToDeactivate > 0, ERROR_INVALID_ZERO_AMOUNT);\r\n        require(amountToDeactivate <= unlockedActiveBalance, ERROR_INVALID_DEACTIVATION_AMOUNT);\r\n\r\n        // No need for SafeMath: we already checked values above\r\n        uint256 futureActiveBalance = unlockedActiveBalance - amountToDeactivate;\r\n        uint256 minActiveBalance = _getMinActiveBalance(termId);\r\n        require(futureActiveBalance == 0 || futureActiveBalance >= minActiveBalance, ERROR_INVALID_DEACTIVATION_AMOUNT);\r\n\r\n        _createDeactivationRequest(msg.sender, amountToDeactivate);\r\n    }\r\n\r\n    /**\r\n    * @notice Stake `@tokenAmount(self.token(), _amount)` for the sender to the Court\r\n    * @param _amount Amount of tokens to be staked\r\n    * @param _data Optional data that can be used to request the activation of the transferred tokens\r\n    */\r\n    function stake(uint256 _amount, bytes calldata _data) external {\r\n        _stake(msg.sender, msg.sender, _amount, _data);\r\n    }\r\n\r\n    /**\r\n    * @notice Stake `@tokenAmount(self.token(), _amount)` for `_to` to the Court\r\n    * @param _to Address to stake an amount of tokens to\r\n    * @param _amount Amount of tokens to be staked\r\n    * @param _data Optional data that can be used to request the activation of the transferred tokens\r\n    */\r\n    function stakeFor(address _to, uint256 _amount, bytes calldata _data) external {\r\n        _stake(msg.sender, _to, _amount, _data);\r\n    }\r\n\r\n    /**\r\n    * @notice Unstake `@tokenAmount(self.token(), _amount)` for `_to` from the Court\r\n    * @param _amount Amount of tokens to be unstaked\r\n    * @param _data Optional data is never used by this function, only logged\r\n    */\r\n    function unstake(uint256 _amount, bytes calldata _data) external {\r\n        _unstake(msg.sender, _amount, _data);\r\n    }\r\n\r\n    /**\r\n    * @dev Callback of approveAndCall, allows staking directly with a transaction to the token contract.\r\n    * @param _from Address making the transfer\r\n    * @param _amount Amount of tokens to transfer\r\n    * @param _token Address of the token\r\n    * @param _data Optional data that can be used to request the activation of the transferred tokens\r\n    */\r\n    function receiveApproval(address _from, uint256 _amount, address _token, bytes calldata _data) external {\r\n        require(msg.sender == _token && _token == address(jurorsToken), ERROR_TOKEN_APPROVE_NOT_ALLOWED);\r\n        _stake(_from, _from, _amount, _data);\r\n    }\r\n\r\n    /**\r\n    * @notice Process a token deactivation requested for `_juror` if there is any\r\n    * @param _juror Address of the juror to process the deactivation request of\r\n    */\r\n    function processDeactivationRequest(address _juror) external {\r\n        uint64 termId = _ensureCurrentTerm();\r\n        _processDeactivationRequest(_juror, termId);\r\n    }\r\n\r\n    /**\r\n    * @notice Assign `@tokenAmount(self.token(), _amount)` to the available balance of `_juror`\r\n    * @param _juror Juror to add an amount of tokens to\r\n    * @param _amount Amount of tokens to be added to the available balance of a juror\r\n    */\r\n    function assignTokens(address _juror, uint256 _amount) external onlyDisputeManager {\r\n        if (_amount > 0) {\r\n            _updateAvailableBalanceOf(_juror, _amount, true);\r\n            emit JurorTokensAssigned(_juror, _amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Burn `@tokenAmount(self.token(), _amount)`\r\n    * @param _amount Amount of tokens to be burned\r\n    */\r\n    function burnTokens(uint256 _amount) external onlyDisputeManager {\r\n        if (_amount > 0) {\r\n            _updateAvailableBalanceOf(BURN_ACCOUNT, _amount, true);\r\n            emit JurorTokensBurned(_amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Draft a set of jurors based on given requirements for a term id\r\n    * @param _params Array containing draft requirements:\r\n    *        0. bytes32 Term randomness\r\n    *        1. uint256 Dispute id\r\n    *        2. uint64  Current term id\r\n    *        3. uint256 Number of seats already filled\r\n    *        4. uint256 Number of seats left to be filled\r\n    *        5. uint64  Number of jurors required for the draft\r\n    *        6. uint16  Permyriad of the minimum active balance to be locked for the draft\r\n    *\r\n    * @return jurors List of jurors selected for the draft\r\n    * @return length Size of the list of the draft result\r\n    */\r\n    function draft(uint256[7] calldata _params) external onlyDisputeManager returns (address[] memory jurors, uint256 length) {\r\n        DraftParams memory draftParams = _buildDraftParams(_params);\r\n        jurors = new address[](draftParams.batchRequestedJurors);\r\n\r\n        // Jurors returned by the tree multi-sortition may not have enough unlocked active balance to be drafted. Thus,\r\n        // we compute several sortitions until all the requested jurors are selected. To guarantee a different set of\r\n        // jurors on each sortition, the iteration number will be part of the random seed to be used in the sortition.\r\n        // Note that we are capping the number of iterations to avoid an OOG error, which means that this function could\r\n        // return less jurors than the requested number.\r\n\r\n        for (draftParams.iteration = 0;\r\n             length < draftParams.batchRequestedJurors && draftParams.iteration < MAX_DRAFT_ITERATIONS;\r\n             draftParams.iteration++\r\n        ) {\r\n            (uint256[] memory jurorIds, uint256[] memory activeBalances) = _treeSearch(draftParams);\r\n\r\n            for (uint256 i = 0; i < jurorIds.length && length < draftParams.batchRequestedJurors; i++) {\r\n                // We assume the selected jurors are registered in the registry, we are not checking their addresses exist\r\n                address jurorAddress = jurorsAddressById[jurorIds[i]];\r\n                Juror storage juror = jurorsByAddress[jurorAddress];\r\n\r\n                // Compute new locked balance for a juror based on the penalty applied when being drafted\r\n                uint256 newLockedBalance = juror.lockedBalance.add(draftParams.draftLockAmount);\r\n\r\n                // Check if there is any deactivation requests for the next term. Drafts are always computed for the current term\r\n                // but we have to make sure we are locking an amount that will exist in the next term.\r\n                uint256 nextTermDeactivationRequestAmount = _deactivationRequestedAmountForTerm(juror, draftParams.termId + 1);\r\n\r\n                // Check if juror has enough active tokens to lock the requested amount for the draft, skip it otherwise.\r\n                uint256 currentActiveBalance = activeBalances[i];\r\n                if (currentActiveBalance >= newLockedBalance) {\r\n\r\n                    // Check if the amount of active tokens for the next term is enough to lock the required amount for\r\n                    // the draft. Otherwise, reduce the requested deactivation amount of the next term.\r\n                    // Next term deactivation amount should always be less than current active balance, but we make sure using SafeMath\r\n                    uint256 nextTermActiveBalance = currentActiveBalance.sub(nextTermDeactivationRequestAmount);\r\n                    if (nextTermActiveBalance < newLockedBalance) {\r\n                        // No need for SafeMath: we already checked values above\r\n                        _reduceDeactivationRequest(jurorAddress, newLockedBalance - nextTermActiveBalance, draftParams.termId);\r\n                    }\r\n\r\n                    // Update the current active locked balance of the juror\r\n                    juror.lockedBalance = newLockedBalance;\r\n                    jurors[length++] = jurorAddress;\r\n                    emit JurorBalanceLocked(jurorAddress, draftParams.draftLockAmount);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Slash a set of jurors based on their votes compared to the winning ruling. This function will unlock the\r\n    *         corresponding locked balances of those jurors that are set to be slashed.\r\n    * @param _termId Current term id\r\n    * @param _jurors List of juror addresses to be slashed\r\n    * @param _lockedAmounts List of amounts locked for each corresponding juror that will be either slashed or returned\r\n    * @param _rewardedJurors List of booleans to tell whether a juror's active balance has to be slashed or not\r\n    * @return Total amount of slashed tokens\r\n    */\r\n    function slashOrUnlock(uint64 _termId, address[] calldata _jurors, uint256[] calldata _lockedAmounts, bool[] calldata _rewardedJurors)\r\n        external\r\n        onlyDisputeManager\r\n        returns (uint256)\r\n    {\r\n        require(_jurors.length == _lockedAmounts.length, ERROR_INVALID_LOCKED_AMOUNTS_LENGTH);\r\n        require(_jurors.length == _rewardedJurors.length, ERROR_INVALID_REWARDED_JURORS_LENGTH);\r\n\r\n        uint64 nextTermId = _termId + 1;\r\n        uint256 collectedTokens;\r\n\r\n        for (uint256 i = 0; i < _jurors.length; i++) {\r\n            uint256 lockedAmount = _lockedAmounts[i];\r\n            address jurorAddress = _jurors[i];\r\n            Juror storage juror = jurorsByAddress[jurorAddress];\r\n            juror.lockedBalance = juror.lockedBalance.sub(lockedAmount);\r\n\r\n            // Slash juror if requested. Note that there's no need to check if there was a deactivation\r\n            // request since we're working with already locked balances.\r\n            if (_rewardedJurors[i]) {\r\n                emit JurorBalanceUnlocked(jurorAddress, lockedAmount);\r\n            } else {\r\n                collectedTokens = collectedTokens.add(lockedAmount);\r\n                tree.update(juror.id, nextTermId, lockedAmount, false);\r\n                emit JurorSlashed(jurorAddress, lockedAmount, nextTermId);\r\n            }\r\n        }\r\n\r\n        return collectedTokens;\r\n    }\r\n\r\n    /**\r\n    * @notice Try to collect `@tokenAmount(self.token(), _amount)` from `_juror` for the term #`_termId + 1`.\r\n    * @dev This function tries to decrease the active balance of a juror for the next term based on the requested\r\n    *      amount. It can be seen as a way to early-slash a juror's active balance.\r\n    * @param _juror Juror to collect the tokens from\r\n    * @param _amount Amount of tokens to be collected from the given juror and for the requested term id\r\n    * @param _termId Current term id\r\n    * @return True if the juror has enough unlocked tokens to be collected for the requested term, false otherwise\r\n    */\r\n    function collectTokens(address _juror, uint256 _amount, uint64 _termId) external onlyDisputeManager returns (bool) {\r\n        if (_amount == 0) {\r\n            return true;\r\n        }\r\n\r\n        uint64 nextTermId = _termId + 1;\r\n        Juror storage juror = jurorsByAddress[_juror];\r\n        uint256 unlockedActiveBalance = _lastUnlockedActiveBalanceOf(juror);\r\n        uint256 nextTermDeactivationRequestAmount = _deactivationRequestedAmountForTerm(juror, nextTermId);\r\n\r\n        // Check if the juror has enough unlocked tokens to collect the requested amount\r\n        // Note that we're also considering the deactivation request if there is any\r\n        uint256 totalUnlockedActiveBalance = unlockedActiveBalance.add(nextTermDeactivationRequestAmount);\r\n        if (_amount > totalUnlockedActiveBalance) {\r\n            return false;\r\n        }\r\n\r\n        // Check if the amount of active tokens is enough to collect the requested amount, otherwise reduce the requested deactivation amount of\r\n        // the next term. Note that this behaviour is different to the one when drafting jurors since this function is called as a side effect\r\n        // of a juror deliberately voting in a final round, while drafts occur randomly.\r\n        if (_amount > unlockedActiveBalance) {\r\n            // No need for SafeMath: amounts were already checked above\r\n            uint256 amountToReduce = _amount - unlockedActiveBalance;\r\n            _reduceDeactivationRequest(_juror, amountToReduce, _termId);\r\n        }\r\n        tree.update(juror.id, nextTermId, _amount, false);\r\n\r\n        emit JurorTokensCollected(_juror, _amount, nextTermId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Lock `_juror`'s withdrawals until term #`_termId`\r\n    * @dev This is intended for jurors who voted in a final round and were coherent with the final ruling to prevent 51% attacks\r\n    * @param _juror Address of the juror to be locked\r\n    * @param _termId Term ID until which the juror's withdrawals will be locked\r\n    */\r\n    function lockWithdrawals(address _juror, uint64 _termId) external onlyDisputeManager {\r\n        Juror storage juror = jurorsByAddress[_juror];\r\n        juror.withdrawalsLockTermId = _termId;\r\n    }\r\n\r\n    /**\r\n    * @notice Set new limit of total active balance of juror tokens\r\n    * @param _totalActiveBalanceLimit New limit of total active balance of juror tokens\r\n    */\r\n    function setTotalActiveBalanceLimit(uint256 _totalActiveBalanceLimit) external onlyConfigGovernor {\r\n        _setTotalActiveBalanceLimit(_totalActiveBalanceLimit);\r\n    }\r\n\r\n    /**\r\n    * @dev ERC900 - Tell the address of the token used for staking\r\n    * @return Address of the token used for staking\r\n    */\r\n    function token() external view returns (address) {\r\n        return address(jurorsToken);\r\n    }\r\n\r\n    /**\r\n    * @dev ERC900 - Tell the total amount of juror tokens held by the registry contract\r\n    * @return Amount of juror tokens held by the registry contract\r\n    */\r\n    function totalStaked() external view returns (uint256) {\r\n        return jurorsToken.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the total amount of active juror tokens\r\n    * @return Total amount of active juror tokens\r\n    */\r\n    function totalActiveBalance() external view returns (uint256) {\r\n        return tree.getTotal();\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the total amount of active juror tokens at the given term id\r\n    * @param _termId Term ID querying the total active balance for\r\n    * @return Total amount of active juror tokens at the given term id\r\n    */\r\n    function totalActiveBalanceAt(uint64 _termId) external view returns (uint256) {\r\n        return _totalActiveBalanceAt(_termId);\r\n    }\r\n\r\n    /**\r\n    * @dev ERC900 - Tell the total amount of tokens of juror. This includes the active balance, the available\r\n    *      balances, and the pending balance for deactivation. Note that we don't have to include the locked\r\n    *      balances since these represent the amount of active tokens that are locked for drafts, i.e. these\r\n    *      are included in the active balance of the juror.\r\n    * @param _juror Address of the juror querying the total amount of tokens staked of\r\n    * @return Total amount of tokens of a juror\r\n    */\r\n    function totalStakedFor(address _juror) external view returns (uint256) {\r\n        return _totalStakedFor(_juror);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the balance information of a juror\r\n    * @param _juror Address of the juror querying the balance information of\r\n    * @return active Amount of active tokens of a juror\r\n    * @return available Amount of available tokens of a juror\r\n    * @return locked Amount of active tokens that are locked due to ongoing disputes\r\n    * @return pendingDeactivation Amount of active tokens that were requested for deactivation\r\n    */\r\n    function balanceOf(address _juror) external view returns (uint256 active, uint256 available, uint256 locked, uint256 pendingDeactivation) {\r\n        return _balanceOf(_juror);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the balance information of a juror, fecthing tree one at a given term\r\n    * @param _juror Address of the juror querying the balance information of\r\n    * @param _termId Term ID querying the active balance for\r\n    * @return active Amount of active tokens of a juror\r\n    * @return available Amount of available tokens of a juror\r\n    * @return locked Amount of active tokens that are locked due to ongoing disputes\r\n    * @return pendingDeactivation Amount of active tokens that were requested for deactivation\r\n    */\r\n    function balanceOfAt(address _juror, uint64 _termId) external view\r\n        returns (uint256 active, uint256 available, uint256 locked, uint256 pendingDeactivation)\r\n    {\r\n        Juror storage juror = jurorsByAddress[_juror];\r\n\r\n        active = _existsJuror(juror) ? tree.getItemAt(juror.id, _termId) : 0;\r\n        (available, locked, pendingDeactivation) = _getBalances(juror);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the active balance of a juror for a given term id\r\n    * @param _juror Address of the juror querying the active balance of\r\n    * @param _termId Term ID querying the active balance for\r\n    * @return Amount of active tokens for juror in the requested past term id\r\n    */\r\n    function activeBalanceOfAt(address _juror, uint64 _termId) external view returns (uint256) {\r\n        return _activeBalanceOfAt(_juror, _termId);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the amount of active tokens of a juror at the last ensured term that are not locked due to ongoing disputes\r\n    * @param _juror Address of the juror querying the unlocked balance of\r\n    * @return Amount of active tokens of a juror that are not locked due to ongoing disputes\r\n    */\r\n    function unlockedActiveBalanceOf(address _juror) external view returns (uint256) {\r\n        Juror storage juror = jurorsByAddress[_juror];\r\n        return _currentUnlockedActiveBalanceOf(juror);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the pending deactivation details for a juror\r\n    * @param _juror Address of the juror whose info is requested\r\n    * @return amount Amount to be deactivated\r\n    * @return availableTermId Term in which the deactivated amount will be available\r\n    */\r\n    function getDeactivationRequest(address _juror) external view returns (uint256 amount, uint64 availableTermId) {\r\n        DeactivationRequest storage request = jurorsByAddress[_juror].deactivationRequest;\r\n        return (request.amount, request.availableTermId);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the withdrawals lock term ID for a juror\r\n    * @param _juror Address of the juror whose info is requested\r\n    * @return Term ID until which the juror's withdrawals will be locked\r\n    */\r\n    function getWithdrawalsLockTermId(address _juror) external view returns (uint64) {\r\n        return jurorsByAddress[_juror].withdrawalsLockTermId;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the identification number associated to a juror address\r\n    * @param _juror Address of the juror querying the identification number of\r\n    * @return Identification number associated to a juror address, zero in case it wasn't registered yet\r\n    */\r\n    function getJurorId(address _juror) external view returns (uint256) {\r\n        return jurorsByAddress[_juror].id;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the maximum amount of total active balance that can be held in the registry\r\n    * @return Maximum amount of total active balance that can be held in the registry\r\n    */\r\n    function totalJurorsActiveBalanceLimit() external view returns (uint256) {\r\n        return totalActiveBalanceLimit;\r\n    }\r\n\r\n    /**\r\n    * @dev ERC900 - Tell if the current registry supports historic information or not\r\n    * @return Always false\r\n    */\r\n    function supportsHistory() external pure returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to activate a given amount of tokens for a juror.\r\n    *      This function assumes that the given term is the current term and has already been ensured.\r\n    * @param _juror Address of the juror to activate tokens\r\n    * @param _amount Amount of juror tokens to be activated\r\n    * @param _sender Address of the account requesting the activation\r\n    */\r\n    function _activateTokens(address _juror, uint256 _amount, address _sender) internal {\r\n        uint64 termId = _ensureCurrentTerm();\r\n\r\n        // Try to clean a previous deactivation request if any\r\n        _processDeactivationRequest(_juror, termId);\r\n\r\n        uint256 availableBalance = jurorsByAddress[_juror].availableBalance;\r\n        uint256 amountToActivate = _amount == 0 ? availableBalance : _amount;\r\n        require(amountToActivate > 0, ERROR_INVALID_ZERO_AMOUNT);\r\n        require(amountToActivate <= availableBalance, ERROR_INVALID_ACTIVATION_AMOUNT);\r\n\r\n        uint64 nextTermId = termId + 1;\r\n        _checkTotalActiveBalance(nextTermId, amountToActivate);\r\n        Juror storage juror = jurorsByAddress[_juror];\r\n        uint256 minActiveBalance = _getMinActiveBalance(nextTermId);\r\n\r\n        if (_existsJuror(juror)) {\r\n            // Even though we are adding amounts, let's check the new active balance is greater than or equal to the\r\n            // minimum active amount. Note that the juror might have been slashed.\r\n            uint256 activeBalance = tree.getItem(juror.id);\r\n            require(activeBalance.add(amountToActivate) >= minActiveBalance, ERROR_ACTIVE_BALANCE_BELOW_MIN);\r\n            tree.update(juror.id, nextTermId, amountToActivate, true);\r\n        } else {\r\n            require(amountToActivate >= minActiveBalance, ERROR_ACTIVE_BALANCE_BELOW_MIN);\r\n            juror.id = tree.insert(nextTermId, amountToActivate);\r\n            jurorsAddressById[juror.id] = _juror;\r\n        }\r\n\r\n        _updateAvailableBalanceOf(_juror, amountToActivate, false);\r\n        emit JurorActivated(_juror, nextTermId, amountToActivate, _sender);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to create a token deactivation request for a juror. Jurors will be allowed\r\n    *      to process a deactivation request from the next term.\r\n    * @param _juror Address of the juror to create a token deactivation request for\r\n    * @param _amount Amount of juror tokens requested for deactivation\r\n    */\r\n    function _createDeactivationRequest(address _juror, uint256 _amount) internal {\r\n        uint64 termId = _ensureCurrentTerm();\r\n\r\n        // Try to clean a previous deactivation request if possible\r\n        _processDeactivationRequest(_juror, termId);\r\n\r\n        uint64 nextTermId = termId + 1;\r\n        Juror storage juror = jurorsByAddress[_juror];\r\n        DeactivationRequest storage request = juror.deactivationRequest;\r\n        request.amount = request.amount.add(_amount);\r\n        request.availableTermId = nextTermId;\r\n        tree.update(juror.id, nextTermId, _amount, false);\r\n\r\n        emit JurorDeactivationRequested(_juror, nextTermId, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to process a token deactivation requested by a juror. It will move the requested amount\r\n    *      to the available balance of the juror if the term when the deactivation was requested has already finished.\r\n    * @param _juror Address of the juror to process the deactivation request of\r\n    * @param _termId Current term id\r\n    */\r\n    function _processDeactivationRequest(address _juror, uint64 _termId) internal {\r\n        Juror storage juror = jurorsByAddress[_juror];\r\n        DeactivationRequest storage request = juror.deactivationRequest;\r\n        uint64 deactivationAvailableTermId = request.availableTermId;\r\n\r\n        // If there is a deactivation request, ensure that the deactivation term has been reached\r\n        if (deactivationAvailableTermId == uint64(0) || _termId < deactivationAvailableTermId) {\r\n            return;\r\n        }\r\n\r\n        uint256 deactivationAmount = request.amount;\r\n        // Note that we can use a zeroed term ID to denote void here since we are storing\r\n        // the minimum allowed term to deactivate tokens which will always be at least 1.\r\n        request.availableTermId = uint64(0);\r\n        request.amount = 0;\r\n        _updateAvailableBalanceOf(_juror, deactivationAmount, true);\r\n\r\n        emit JurorDeactivationProcessed(_juror, deactivationAvailableTermId, deactivationAmount, _termId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to reduce a token deactivation requested by a juror. It assumes the deactivation request\r\n    *      cannot be processed for the given term yet.\r\n    * @param _juror Address of the juror to reduce the deactivation request of\r\n    * @param _amount Amount to be reduced from the current deactivation request\r\n    * @param _termId Term ID in which the deactivation request is being reduced\r\n    */\r\n    function _reduceDeactivationRequest(address _juror, uint256 _amount, uint64 _termId) internal {\r\n        Juror storage juror = jurorsByAddress[_juror];\r\n        DeactivationRequest storage request = juror.deactivationRequest;\r\n        uint256 currentRequestAmount = request.amount;\r\n        require(currentRequestAmount >= _amount, ERROR_CANNOT_REDUCE_DEACTIVATION_REQUEST);\r\n\r\n        // No need for SafeMath: we already checked values above\r\n        uint256 newRequestAmount = currentRequestAmount - _amount;\r\n        request.amount = newRequestAmount;\r\n\r\n        // Move amount back to the tree\r\n        tree.update(juror.id, _termId + 1, _amount, true);\r\n\r\n        emit JurorDeactivationUpdated(_juror, request.availableTermId, newRequestAmount, _termId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to stake an amount of tokens for a juror\r\n    * @param _from Address sending the amount of tokens to be deposited\r\n    * @param _juror Address of the juror to deposit the tokens to\r\n    * @param _amount Amount of tokens to be deposited\r\n    * @param _data Optional data that can be used to request the activation of the deposited tokens\r\n    */\r\n    function _stake(address _from, address _juror, uint256 _amount, bytes memory _data) internal {\r\n        require(_amount > 0, ERROR_INVALID_ZERO_AMOUNT);\r\n        _updateAvailableBalanceOf(_juror, _amount, true);\r\n\r\n        // Activate tokens if it was requested by the sender. Note that there's no need to check\r\n        // the activation amount since we have just added it to the available balance of the juror.\r\n        if (_data.toBytes4() == JurorsRegistry(this).activate.selector) {\r\n            _activateTokens(_juror, _amount, _from);\r\n        }\r\n\r\n        emit Staked(_juror, _amount, _totalStakedFor(_juror), _data);\r\n        require(jurorsToken.safeTransferFrom(_from, address(this), _amount), ERROR_TOKEN_TRANSFER_FAILED);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to unstake an amount of tokens of a juror\r\n    * @param _juror Address of the juror to to unstake the tokens of\r\n    * @param _amount Amount of tokens to be unstaked\r\n    * @param _data Optional data is never used by this function, only logged\r\n    */\r\n    function _unstake(address _juror, uint256 _amount, bytes memory _data) internal {\r\n        require(_amount > 0, ERROR_INVALID_ZERO_AMOUNT);\r\n\r\n        // Try to process a deactivation request for the current term if there is one. Note that we don't need to ensure\r\n        // the current term this time since deactivation requests always work with future terms, which means that if\r\n        // the current term is outdated, it will never match the deactivation term id. We avoid ensuring the term here\r\n        // to avoid forcing jurors to do that in order to withdraw their available balance. Same applies to final round locks.\r\n        uint64 lastEnsuredTermId = _getLastEnsuredTermId();\r\n\r\n        // Check that juror's withdrawals are not locked\r\n        uint64 withdrawalsLockTermId = jurorsByAddress[_juror].withdrawalsLockTermId;\r\n        require(withdrawalsLockTermId == 0 || withdrawalsLockTermId < lastEnsuredTermId, ERROR_WITHDRAWALS_LOCK);\r\n\r\n        _processDeactivationRequest(_juror, lastEnsuredTermId);\r\n\r\n        _updateAvailableBalanceOf(_juror, _amount, false);\r\n        emit Unstaked(_juror, _amount, _totalStakedFor(_juror), _data);\r\n        require(jurorsToken.safeTransfer(_juror, _amount), ERROR_TOKEN_TRANSFER_FAILED);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to update the available balance of a juror\r\n    * @param _juror Juror to update the available balance of\r\n    * @param _amount Amount of tokens to be added to or removed from the available balance of a juror\r\n    * @param _positive True if the given amount should be added, or false to remove it from the available balance\r\n    */\r\n    function _updateAvailableBalanceOf(address _juror, uint256 _amount, bool _positive) internal {\r\n        // We are not using a require here to avoid reverting in case any of the treasury maths reaches this point\r\n        // with a zeroed amount value. Instead, we are doing this validation in the external entry points such as\r\n        // stake, unstake, activate, deactivate, among others.\r\n        if (_amount == 0) {\r\n            return;\r\n        }\r\n\r\n        Juror storage juror = jurorsByAddress[_juror];\r\n        if (_positive) {\r\n            juror.availableBalance = juror.availableBalance.add(_amount);\r\n        } else {\r\n            require(_amount <= juror.availableBalance, ERROR_NOT_ENOUGH_AVAILABLE_BALANCE);\r\n            // No need for SafeMath: we already checked values right above\r\n            juror.availableBalance -= _amount;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to set new limit of total active balance of juror tokens\r\n    * @param _totalActiveBalanceLimit New limit of total active balance of juror tokens\r\n    */\r\n    function _setTotalActiveBalanceLimit(uint256 _totalActiveBalanceLimit) internal {\r\n        require(_totalActiveBalanceLimit > 0, ERROR_BAD_TOTAL_ACTIVE_BALANCE_LIMIT);\r\n        emit TotalActiveBalanceLimitChanged(totalActiveBalanceLimit, _totalActiveBalanceLimit);\r\n        totalActiveBalanceLimit = _totalActiveBalanceLimit;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to tell the total amount of tokens of juror\r\n    * @param _juror Address of the juror querying the total amount of tokens staked of\r\n    * @return Total amount of tokens of a juror\r\n    */\r\n    function _totalStakedFor(address _juror) internal view returns (uint256) {\r\n        (uint256 active, uint256 available, , uint256 pendingDeactivation) = _balanceOf(_juror);\r\n        return available.add(active).add(pendingDeactivation);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to tell the balance information of a juror\r\n    * @param _juror Address of the juror querying the balance information of\r\n    * @return active Amount of active tokens of a juror\r\n    * @return available Amount of available tokens of a juror\r\n    * @return locked Amount of active tokens that are locked due to ongoing disputes\r\n    * @return pendingDeactivation Amount of active tokens that were requested for deactivation\r\n    */\r\n    function _balanceOf(address _juror) internal view returns (uint256 active, uint256 available, uint256 locked, uint256 pendingDeactivation) {\r\n        Juror storage juror = jurorsByAddress[_juror];\r\n\r\n        active = _existsJuror(juror) ? tree.getItem(juror.id) : 0;\r\n        (available, locked, pendingDeactivation) = _getBalances(juror);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the active balance of a juror for a given term id\r\n    * @param _juror Address of the juror querying the active balance of\r\n    * @param _termId Term ID querying the active balance for\r\n    * @return Amount of active tokens for juror in the requested past term id\r\n    */\r\n    function _activeBalanceOfAt(address _juror, uint64 _termId) internal view returns (uint256) {\r\n        Juror storage juror = jurorsByAddress[_juror];\r\n        return _existsJuror(juror) ? tree.getItemAt(juror.id, _termId) : 0;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the amount of active tokens of a juror that are not locked due to ongoing disputes\r\n    *      It will use the last value, that might be in a future term\r\n    * @param _juror Juror querying the unlocked active balance of\r\n    * @return Amount of active tokens of a juror that are not locked due to ongoing disputes\r\n    */\r\n    function _lastUnlockedActiveBalanceOf(Juror storage _juror) internal view returns (uint256) {\r\n        return _existsJuror(_juror) ? tree.getItem(_juror.id).sub(_juror.lockedBalance) : 0;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the amount of active tokens at the last ensured term of a juror that are not locked due to ongoing disputes\r\n    * @param _juror Juror querying the unlocked active balance of\r\n    * @return Amount of active tokens of a juror that are not locked due to ongoing disputes\r\n    */\r\n    function _currentUnlockedActiveBalanceOf(Juror storage _juror) internal view returns (uint256) {\r\n        uint64 lastEnsuredTermId = _getLastEnsuredTermId();\r\n        return _existsJuror(_juror) ? tree.getItemAt(_juror.id, lastEnsuredTermId).sub(_juror.lockedBalance) : 0;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to check if a juror was already registered\r\n    * @param _juror Juror to be checked\r\n    * @return True if the given juror was already registered, false otherwise\r\n    */\r\n    function _existsJuror(Juror storage _juror) internal view returns (bool) {\r\n        return _juror.id != 0;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the amount of a deactivation request for a given term id\r\n    * @param _juror Juror to query the deactivation request amount of\r\n    * @param _termId Term ID of the deactivation request to be queried\r\n    * @return Amount of the deactivation request for the given term, 0 otherwise\r\n    */\r\n    function _deactivationRequestedAmountForTerm(Juror storage _juror, uint64 _termId) internal view returns (uint256) {\r\n        DeactivationRequest storage request = _juror.deactivationRequest;\r\n        return request.availableTermId == _termId ? request.amount : 0;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to tell the total amount of active juror tokens at the given term id\r\n    * @param _termId Term ID querying the total active balance for\r\n    * @return Total amount of active juror tokens at the given term id\r\n    */\r\n    function _totalActiveBalanceAt(uint64 _termId) internal view returns (uint256) {\r\n        // This function will return always the same values, the only difference remains on gas costs. In case we look for a\r\n        // recent term, in this case current or future ones, we perform a backwards linear search from the last checkpoint.\r\n        // Otherwise, a binary search is computed.\r\n        bool recent = _termId >= _getLastEnsuredTermId();\r\n        return recent ? tree.getRecentTotalAt(_termId) : tree.getTotalAt(_termId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to check if its possible to add a given new amount to the registry or not\r\n    * @param _termId Term ID when the new amount will be added\r\n    * @param _amount Amount of tokens willing to be added to the registry\r\n    */\r\n    function _checkTotalActiveBalance(uint64 _termId, uint256 _amount) internal view {\r\n        uint256 currentTotalActiveBalance = _totalActiveBalanceAt(_termId);\r\n        uint256 newTotalActiveBalance = currentTotalActiveBalance.add(_amount);\r\n        require(newTotalActiveBalance <= totalActiveBalanceLimit, ERROR_TOTAL_ACTIVE_BALANCE_EXCEEDED);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the local balance information of a juror (that is not on the tree)\r\n    * @param _juror Address of the juror querying the balance information of\r\n    * @return available Amount of available tokens of a juror\r\n    * @return locked Amount of active tokens that are locked due to ongoing disputes\r\n    * @return pendingDeactivation Amount of active tokens that were requested for deactivation\r\n    */\r\n    function _getBalances(Juror storage _juror) internal view returns (uint256 available, uint256 locked, uint256 pendingDeactivation) {\r\n        available = _juror.availableBalance;\r\n        locked = _juror.lockedBalance;\r\n        pendingDeactivation = _juror.deactivationRequest.amount;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to search jurors in the tree based on certain search restrictions\r\n    * @param _params Draft params to be used for the jurors search\r\n    * @return ids List of juror ids obtained based on the requested search\r\n    * @return activeBalances List of active balances for each juror obtained based on the requested search\r\n    */\r\n    function _treeSearch(DraftParams memory _params) internal view returns (uint256[] memory ids, uint256[] memory activeBalances) {\r\n        (ids, activeBalances) = tree.batchedRandomSearch(\r\n            _params.termRandomness,\r\n            _params.disputeId,\r\n            _params.termId,\r\n            _params.selectedJurors,\r\n            _params.batchRequestedJurors,\r\n            _params.roundRequestedJurors,\r\n            _params.iteration\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Private function to parse a certain set given of draft params\r\n    * @param _params Array containing draft requirements:\r\n    *        0. bytes32 Term randomness\r\n    *        1. uint256 Dispute id\r\n    *        2. uint64  Current term id\r\n    *        3. uint256 Number of seats already filled\r\n    *        4. uint256 Number of seats left to be filled\r\n    *        5. uint64  Number of jurors required for the draft\r\n    *        6. uint16  Permyriad of the minimum active balance to be locked for the draft\r\n    *\r\n    * @return Draft params object parsed\r\n    */\r\n    function _buildDraftParams(uint256[7] memory _params) private view returns (DraftParams memory) {\r\n        uint64 termId = uint64(_params[2]);\r\n        uint256 minActiveBalance = _getMinActiveBalance(termId);\r\n\r\n        return DraftParams({\r\n            termRandomness: bytes32(_params[0]),\r\n            disputeId: _params[1],\r\n            termId: termId,\r\n            selectedJurors: _params[3],\r\n            batchRequestedJurors: _params[4],\r\n            roundRequestedJurors: _params[5],\r\n            draftLockAmount: minActiveBalance.pct(uint16(_params[6])),\r\n            iteration: 0\r\n        });\r\n    }\r\n}\r\n\r\n// File: contracts/JurorsRegistryMigrator.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract JurorsRegistryMigrator is IDisputeManager {\r\n    string constant internal ERROR_TOKEN_DOES_NOT_MATCH = \"JRM_TOKEN_DOES_NOT_MATCH\";\r\n    string constant internal ERROR_CONTROLLER_DOES_NOT_MATCH = \"JRM_CONTROLLER_DOES_NOT_MATCH\";\r\n    string constant internal ERROR_BALANCE_TO_MIGRATE_ZERO = \"JRM_BALANCE_TO_MIGRATE_ZERO\";\r\n    string constant internal ERROR_ANJ_APPROVAL_FAILED = \"JRM_ANJ_APPROVAL_FAILED\";\r\n    string constant internal ERROR_MIGRATION_IN_PROGRESS = \"JRM_MIGRATION_IN_PROGRESS\";\r\n    string constant internal ERROR_CLOSE_TRANSFER_FAILED = \"JRM_CLOSE_TRANSFER_FAILED\";\r\n    string constant internal ERROR_COURT_TERM_HAS_PASSED = \"JRM_COURT_TERM_HAS_PASSED\";\r\n    string constant internal ERROR_SENDER_NOT_FUNDS_GOVERNOR = \"JRM_SENDER_NOT_FUNDS_GOVERNOR\";\r\n\r\n    ERC20 public token;\r\n    uint64 public termId;\r\n    Controller public controller;\r\n    JurorsRegistry public oldRegistry;\r\n    JurorsRegistry public newRegistry;\r\n\r\n    event TokensMigrated(address indexed juror, uint256 amount);\r\n    event MigrationClosed(uint256 amount);\r\n\r\n    modifier onlyFundsGovernor() {\r\n        address fundsGovernor = controller.getFundsGovernor();\r\n        require(fundsGovernor == msg.sender, ERROR_SENDER_NOT_FUNDS_GOVERNOR);\r\n        _;\r\n    }\r\n\r\n    constructor (JurorsRegistry _oldRegistry, JurorsRegistry _newRegistry) public {\r\n        address oldRegistryToken = _oldRegistry.token();\r\n        address newRegistryToken = _newRegistry.token();\r\n        require(oldRegistryToken == newRegistryToken, ERROR_TOKEN_DOES_NOT_MATCH);\r\n\r\n        Controller oldRegistryController = _oldRegistry.getController();\r\n        Controller newRegistryController = _newRegistry.getController();\r\n        require(oldRegistryController == newRegistryController, ERROR_CONTROLLER_DOES_NOT_MATCH);\r\n\r\n        token = ERC20(oldRegistryToken);\r\n        oldRegistry = _oldRegistry;\r\n        newRegistry = _newRegistry;\r\n        controller = oldRegistryController;\r\n        termId = oldRegistryController.getCurrentTermId();\r\n    }\r\n\r\n    function migrate(address[] calldata _jurors) external {\r\n        uint64 currentTermId = _ensureMigrationTerm();\r\n\r\n        for (uint256 i = 0; i < _jurors.length; i++) {\r\n            _migrate(_jurors[i], currentTermId);\r\n        }\r\n    }\r\n\r\n    function migrate(address _juror) external {\r\n        uint64 currentTermId = _ensureMigrationTerm();\r\n        _migrate(_juror, currentTermId);\r\n    }\r\n\r\n    function close() external onlyFundsGovernor {\r\n        uint256 balance = token.balanceOf(address(this));\r\n        emit MigrationClosed(balance);\r\n\r\n        if (balance > 0) {\r\n            require(token.transfer(address(oldRegistry), balance), ERROR_CLOSE_TRANSFER_FAILED);\r\n        }\r\n    }\r\n\r\n    function _migrate(address _juror, uint64 _currentTermId) internal {\r\n        uint256 balanceToBeMigrated = oldRegistry.activeBalanceOfAt(_juror, _currentTermId + 1);\r\n        require(balanceToBeMigrated > 0, ERROR_BALANCE_TO_MIGRATE_ZERO);\r\n\r\n        oldRegistry.collectTokens(_juror, balanceToBeMigrated, _currentTermId);\r\n        require(token.approve(address(newRegistry), balanceToBeMigrated), ERROR_ANJ_APPROVAL_FAILED);\r\n        newRegistry.stakeFor(_juror, balanceToBeMigrated, abi.encodePacked(keccak256(\"activate(uint256)\")));\r\n\r\n        emit TokensMigrated(_juror, balanceToBeMigrated);\r\n    }\r\n\r\n    function _ensureMigrationTerm() internal view returns (uint64) {\r\n        uint64 currentTerm = controller.getCurrentTermId();\r\n        require(termId == currentTerm, ERROR_COURT_TERM_HAS_PASSED);\r\n        return currentTerm;\r\n    }\r\n\r\n    /** DISPUTE MANAGER METHODS **/\r\n    // solium-disable function-order\r\n\r\n    function createDispute(IArbitrable /* _subject */, uint8 /* _possibleRulings */, bytes calldata /* _metadata */) external returns (uint256) {\r\n        revert(ERROR_MIGRATION_IN_PROGRESS);\r\n    }\r\n\r\n    function closeEvidencePeriod(IArbitrable /* _subject */, uint256 /* _disputeId */) external {\r\n        revert(ERROR_MIGRATION_IN_PROGRESS);\r\n    }\r\n\r\n    function draft(uint256 /* _disputeId */) external {\r\n        revert(ERROR_MIGRATION_IN_PROGRESS);\r\n    }\r\n\r\n    function createAppeal(uint256 /* _disputeId */, uint256 /* _roundId */, uint8 /* _ruling */) external {\r\n        revert(ERROR_MIGRATION_IN_PROGRESS);\r\n    }\r\n\r\n    function confirmAppeal(uint256 /* _disputeId */, uint256 /* _roundId */, uint8 /* _ruling */) external {\r\n        revert(ERROR_MIGRATION_IN_PROGRESS);\r\n    }\r\n\r\n    function computeRuling(uint256 /* _disputeId */) external returns (IArbitrable /* subject */, uint8 /* finalRuling */) {\r\n        revert(ERROR_MIGRATION_IN_PROGRESS);\r\n    }\r\n\r\n    function settlePenalties(uint256 /* _disputeId */, uint256 /* _roundId */, uint256 /* _jurorsToSettle */) external {\r\n        revert(ERROR_MIGRATION_IN_PROGRESS);\r\n    }\r\n\r\n    function settleReward(uint256 /* _disputeId */, uint256 /* _roundId */, address /* _juror */) external {\r\n        revert(ERROR_MIGRATION_IN_PROGRESS);\r\n    }\r\n\r\n    function settleAppealDeposit(uint256 /* _disputeId */, uint256 /* _roundId */) external {\r\n        revert(ERROR_MIGRATION_IN_PROGRESS);\r\n    }\r\n\r\n    function getDisputeFees() external view returns (ERC20 /* feeToken */, uint256 /* feeAmount */) {\r\n        revert(ERROR_MIGRATION_IN_PROGRESS);\r\n    }\r\n\r\n    function getDispute(uint256 /* _disputeId */) external view\r\n        returns (\r\n            IArbitrable /* subject */,\r\n            uint8 /* possibleRulings */,\r\n            DisputeState /* state */,\r\n            uint8 /* finalRuling */,\r\n            uint256 /* lastRoundId */,\r\n            uint64 /* createTermId */\r\n        )\r\n    {\r\n        revert(ERROR_MIGRATION_IN_PROGRESS);\r\n    }\r\n\r\n    function getRound(uint256 /* _disputeId */, uint256 /* _roundId */) external view\r\n        returns (\r\n            uint64 /* draftTerm */,\r\n            uint64 /* delayedTerms */,\r\n            uint64 /* jurorsNumber */,\r\n            uint64 /* selectedJurors */,\r\n            uint256 /* jurorFees */,\r\n            bool /* settledPenalties */,\r\n            uint256 /* collectedTokens */,\r\n            uint64 /* coherentJurors */,\r\n            AdjudicationState /* state */\r\n        )\r\n    {\r\n        revert(ERROR_MIGRATION_IN_PROGRESS);\r\n    }\r\n\r\n    function getAppeal(uint256 /* _disputeId */, uint256 /* _roundId */) external view\r\n        returns (address /* maker */, uint64 /* appealedRuling */, address /* taker */, uint64 /* opposedRuling */)\r\n    {\r\n        revert(ERROR_MIGRATION_IN_PROGRESS);\r\n    }\r\n\r\n    function getNextRoundDetails(uint256 /* _disputeId */, uint256 /* _roundId */) external view\r\n        returns (\r\n            uint64 /* nextRoundStartTerm */,\r\n            uint64 /* nextRoundJurorsNumber */,\r\n            DisputeState /* newDisputeState */,\r\n            ERC20 /* feeToken */,\r\n            uint256 /* totalFees */,\r\n            uint256 /* jurorFees */,\r\n            uint256 /* appealDeposit */,\r\n            uint256 /* confirmAppealDeposit */\r\n        )\r\n    {\r\n        revert(ERROR_MIGRATION_IN_PROGRESS);\r\n    }\r\n\r\n    function getJuror(uint256 /* _disputeId */, uint256 /* _roundId */, address /* _juror */) external view\r\n        returns (uint64 /* weight */, bool /* rewarded */)\r\n    {\r\n        revert(ERROR_MIGRATION_IN_PROGRESS);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"createAppeal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"createDispute\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jurors\",\"type\":\"address[]\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"getJuror\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"draft\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getAppeal\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDisputeFees\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"settleReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"settlePenalties\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oldRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"termId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"confirmAppeal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"computeRuling\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"closeEvidencePeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getNextRoundDetails\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_juror\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getDispute\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"settleAppealDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_oldRegistry\",\"type\":\"address\"},{\"name\":\"_newRegistry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"juror\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensMigrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MigrationClosed\",\"type\":\"event\"}]","ContractName":"JurorsRegistryMigrator","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"3000","ConstructorArguments":"000000000000000000000000f9dda954adf5e54b89f988c1560553a0a387cce10000000000000000000000000f7471c1df2021ff45f112878f755aabe7aa16bf","Library":"","LicenseType":"None","SwarmSource":"bzzr://3ee1c2a204a90f4eefd4e1759e45d24e255535d13b710bc036f0870c5c0324aa"}]}