{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add \n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes_slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes_slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n                \n                for { \n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint _start,\n        uint _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_bytes.length >= (_start + _length));\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\n        require(_bytes.length >= (_start + 20));\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\n        require(_bytes.length >= (_start + 1));\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\n        require(_bytes.length >= (_start + 2));\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\n        require(_bytes.length >= (_start + 4));\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\n        require(_bytes.length >= (_start + 8));\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\n        require(_bytes.length >= (_start + 12));\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\n        require(_bytes.length >= (_start + 16));\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\n        require(_bytes.length >= (_start + 32));\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\n        require(_bytes.length >= (_start + 32));\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes_slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes_slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following \n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\ncontract EpochTokenLocker {\n    using SafeMath for uint256;\n\n    /** @dev Number of seconds a batch is lasting*/\n    uint32 public constant BATCH_TIME = 300;\n\n    // User => Token => BalanceState\n    mapping(address => mapping(address => BalanceState)) private balanceStates;\n\n    // user => token => lastCreditBatchId\n    mapping(address => mapping(address => uint32)) public lastCreditBatchId;\n\n    struct BalanceState {\n        uint256 balance;\n        PendingFlux pendingDeposits; // deposits will be credited in any future epoch, i.e. currentStateIndex > batchId\n        PendingFlux pendingWithdraws; // withdraws are allowed in any future epoch, i.e. currentStateIndex > batchId\n    }\n\n    struct PendingFlux {\n        uint256 amount;\n        uint32 batchId;\n    }\n\n    event Deposit(address indexed user, address indexed token, uint256 amount, uint32 batchId);\n\n    event WithdrawRequest(address indexed user, address indexed token, uint256 amount, uint32 batchId);\n\n    event Withdraw(address indexed user, address indexed token, uint256 amount);\n\n    /** @dev credits user with deposit amount on next epoch (given by getCurrentBatchId)\n     * @param token address of token to be deposited\n     * @param amount number of token(s) to be credited to user's account\n     *\n     * Emits an {Deposit} event with relevent deposit information.\n     *\n     * Requirements:\n     * - token transfer to contract is successfull\n     */\n    function deposit(address token, uint256 amount) public {\n        updateDepositsBalance(msg.sender, token);\n        SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), amount);\n        // solhint-disable-next-line max-line-length\n        balanceStates[msg.sender][token].pendingDeposits.amount = balanceStates[msg.sender][token].pendingDeposits.amount.add(\n            amount\n        );\n        balanceStates[msg.sender][token].pendingDeposits.batchId = getCurrentBatchId();\n        emit Deposit(msg.sender, token, amount, getCurrentBatchId());\n    }\n\n    /** @dev Signals and initiates user's intent to withdraw.\n     * @param token address of token to be withdrawn\n     * @param amount number of token(s) to be withdrawn\n     *\n     * Emits an {WithdrawRequest} event with relevent request information.\n     */\n    function requestWithdraw(address token, uint256 amount) public {\n        requestFutureWithdraw(token, amount, getCurrentBatchId());\n    }\n\n    /** @dev Signals and initiates user's intent to withdraw.\n     * @param token address of token to be withdrawn\n     * @param amount number of token(s) to be withdrawn\n     * @param batchId state index at which request is to be made.\n     *\n     * Emits an {WithdrawRequest} event with relevent request information.\n     */\n    function requestFutureWithdraw(address token, uint256 amount, uint32 batchId) public {\n        // First process pendingWithdraw (if any), as otherwise balances might increase for currentBatchId - 1\n        if (hasValidWithdrawRequest(msg.sender, token)) {\n            withdraw(msg.sender, token);\n        }\n        require(batchId >= getCurrentBatchId(), \"Request cannot be made in the past\");\n        balanceStates[msg.sender][token].pendingWithdraws = PendingFlux({amount: amount, batchId: batchId});\n        emit WithdrawRequest(msg.sender, token, amount, batchId);\n    }\n\n    /** @dev Claims pending withdraw - can be called on behalf of others\n     * @param token address of token to be withdrawn\n     * @param user address of user who withdraw is being claimed.\n     *\n     * Emits an {Withdraw} event stating that `user` withdrew `amount` of `token`\n     *\n     * Requirements:\n     * - withdraw was requested in previous epoch\n     * - token was received from exchange in current auction batch\n     */\n    function withdraw(address user, address token) public {\n        updateDepositsBalance(user, token); // withdrawn amount may have been deposited in previous epoch\n        require(\n            balanceStates[user][token].pendingWithdraws.batchId < getCurrentBatchId(),\n            \"withdraw was not registered previously\"\n        );\n        require(\n            lastCreditBatchId[user][token] < getCurrentBatchId(),\n            \"Withdraw not possible for token that is traded in the current auction\"\n        );\n        uint256 amount = Math.min(balanceStates[user][token].balance, balanceStates[user][token].pendingWithdraws.amount);\n\n        balanceStates[user][token].balance = balanceStates[user][token].balance.sub(amount);\n        delete balanceStates[user][token].pendingWithdraws;\n\n        SafeERC20.safeTransfer(IERC20(token), user, amount);\n        emit Withdraw(user, token, amount);\n    }\n\n    /**\n     * Public view functions\n     */\n    /** @dev getter function used to display pending deposit\n     * @param user address of user\n     * @param token address of ERC20 token\n     * return amount and batchId of deposit's transfer if any (else 0)\n     */\n    function getPendingDeposit(address user, address token) public view returns (uint256, uint32) {\n        PendingFlux memory pendingDeposit = balanceStates[user][token].pendingDeposits;\n        return (pendingDeposit.amount, pendingDeposit.batchId);\n    }\n\n    /** @dev getter function used to display pending withdraw\n     * @param user address of user\n     * @param token address of ERC20 token\n     * return amount and batchId when withdraw was requested if any (else 0)\n     */\n    function getPendingWithdraw(address user, address token) public view returns (uint256, uint32) {\n        PendingFlux memory pendingWithdraw = balanceStates[user][token].pendingWithdraws;\n        return (pendingWithdraw.amount, pendingWithdraw.batchId);\n    }\n\n    /** @dev getter function to determine current auction id.\n     * return current batchId\n     */\n    function getCurrentBatchId() public view returns (uint32) {\n        // solhint-disable-next-line not-rely-on-time\n        return uint32(now / BATCH_TIME);\n    }\n\n    /** @dev used to determine how much time is left in a batch\n     * return seconds remaining in current batch\n     */\n    function getSecondsRemainingInBatch() public view returns (uint256) {\n        // solhint-disable-next-line not-rely-on-time\n        return BATCH_TIME - (now % BATCH_TIME);\n    }\n\n    /** @dev fetches and returns user's balance\n     * @param user address of user\n     * @param token address of ERC20 token\n     * return Current `token` balance of `user`'s account\n     */\n    function getBalance(address user, address token) public view returns (uint256) {\n        uint256 balance = balanceStates[user][token].balance;\n        if (balanceStates[user][token].pendingDeposits.batchId < getCurrentBatchId()) {\n            balance = balance.add(balanceStates[user][token].pendingDeposits.amount);\n        }\n        if (balanceStates[user][token].pendingWithdraws.batchId < getCurrentBatchId()) {\n            balance = balance.sub(Math.min(balanceStates[user][token].pendingWithdraws.amount, balance));\n        }\n        return balance;\n    }\n\n    /** @dev Used to determine if user has a valid pending withdraw request of specific token\n     * @param user address of user\n     * @param token address of ERC20 token\n     * return true if `user` has valid withdraw request for `token`, otherwise false\n     */\n    function hasValidWithdrawRequest(address user, address token) public view returns (bool) {\n        return\n            balanceStates[user][token].pendingWithdraws.batchId < getCurrentBatchId() &&\n            balanceStates[user][token].pendingWithdraws.batchId > 0;\n    }\n\n    /**\n     * internal functions\n     */\n    /**\n     * The following function should be used to update any balances within an epoch, which\n     * will not be immediately final. E.g. the BatchExchange credits new balances to\n     * the buyers in an auction, but as there are might be better solutions, the updates are\n     * not final. In order to prevent withdraws from non-final updates, we disallow withdraws\n     * by setting lastCreditBatchId to the current batchId and allow only withdraws in batches\n     * with a higher batchId.\n     */\n    function addBalanceAndBlockWithdrawForThisBatch(address user, address token, uint256 amount) internal {\n        if (hasValidWithdrawRequest(user, token)) {\n            lastCreditBatchId[user][token] = getCurrentBatchId();\n        }\n        addBalance(user, token, amount);\n    }\n\n    function addBalance(address user, address token, uint256 amount) internal {\n        updateDepositsBalance(user, token);\n        balanceStates[user][token].balance = balanceStates[user][token].balance.add(amount);\n    }\n\n    /**\n     * The following function should be used to subtract amounts from the current balances state.\n     * For the substraction the current withdrawRequests are considered and they are effectively reducing\n     * the available balance.\n     */\n    function subtractBalance(address user, address token, uint256 amount) internal {\n        require(amount <= getBalance(user, token), \"Amount exceeds user's balance.\");\n        subtractBalanceUnchecked(user, token, amount);\n    }\n\n    /**\n     * The following function should be used to substract amounts from the current balance\n     * state, if the pending withdrawRequests are not considered and should not effectively reduce\n     * the available balance.\n     * For example, the reversion of trades from a previous batch-solution do not\n     * need to consider withdrawRequests. This is the case as withdraws are blocked for one\n     * batch for accounts having credited funds in a previous submission.\n     * PendingWithdraws must also be ignored since otherwise for the reversion of trades,\n     * a solution reversion could be blocked: A bigger withdrawRequest could set the return value of\n     * getBalance(user, token) to zero, although the user was just credited tokens in\n     * the last submission. In this situation, during the unwinding of the previous orders,\n     * the check `amount <= getBalance(user, token)` would fail and the reversion would be blocked.\n     */\n    function subtractBalanceUnchecked(address user, address token, uint256 amount) internal {\n        updateDepositsBalance(user, token);\n        balanceStates[user][token].balance = balanceStates[user][token].balance.sub(amount);\n    }\n\n    function updateDepositsBalance(address user, address token) private {\n        uint256 batchId = balanceStates[user][token].pendingDeposits.batchId;\n        if (batchId > 0 && batchId < getCurrentBatchId()) {\n            // batchId > 0 is checked in order save an SSTORE in case there is no pending deposit\n            balanceStates[user][token].balance = balanceStates[user][token].balance.add(\n                balanceStates[user][token].pendingDeposits.amount\n            );\n            delete balanceStates[user][token].pendingDeposits;\n        }\n    }\n}\n\nlibrary IdToAddressBiMap {\n    struct Data {\n        mapping(uint16 => address) idToAddress;\n        mapping(address => uint16) addressToId;\n    }\n\n    function hasId(Data storage self, uint16 id) public view returns (bool) {\n        return self.idToAddress[id + 1] != address(0);\n    }\n\n    function hasAddress(Data storage self, address addr) public view returns (bool) {\n        return self.addressToId[addr] != 0;\n    }\n\n    function getAddressAt(Data storage self, uint16 id) public view returns (address) {\n        require(hasId(self, id), \"Must have ID to get Address\");\n        return self.idToAddress[id + 1];\n    }\n\n    function getId(Data storage self, address addr) public view returns (uint16) {\n        require(hasAddress(self, addr), \"Must have Address to get ID\");\n        return self.addressToId[addr] - 1;\n    }\n\n    function insert(Data storage self, uint16 id, address addr) public returns (bool) {\n        require(addr != address(0), \"Cannot insert zero address\");\n        require(id != uint16(-1), \"Cannot insert max uint16\");\n        // Ensure bijectivity of the mappings\n        if (self.addressToId[addr] != 0 || self.idToAddress[id + 1] != address(0)) {\n            return false;\n        }\n        self.idToAddress[id + 1] = addr;\n        self.addressToId[addr] = id + 1;\n        return true;\n    }\n\n}\n\nlibrary IterableAppendOnlySet {\n    struct Data {\n        mapping(address => address) nextMap;\n        address last;\n    }\n\n    function insert(Data storage self, address value) public returns (bool) {\n        if (contains(self, value)) {\n            return false;\n        }\n        self.nextMap[self.last] = value;\n        self.last = value;\n        return true;\n    }\n\n    function contains(Data storage self, address value) public view returns (bool) {\n        require(value != address(0), \"Inserting address(0) is not supported\");\n        return self.nextMap[value] != address(0) || (self.last == value);\n    }\n\n    function first(Data storage self) public view returns (address) {\n        require(self.last != address(0), \"Trying to get first from empty set\");\n        return self.nextMap[address(0)];\n    }\n\n    function next(Data storage self, address value) public view returns (address) {\n        require(contains(self, value), \"Trying to get next of non-existent element\");\n        require(value != self.last, \"Trying to get next of last element\");\n        return self.nextMap[value];\n    }\n\n    function size(Data storage self) public view returns (uint256) {\n        if (self.last == address(0)) {\n            return 0;\n        }\n        uint256 count = 1;\n        address current = first(self);\n        while (current != self.last) {\n            current = next(self, current);\n            count++;\n        }\n        return count;\n    }\n\n    function atIndex(Data storage self, uint256 index) public view returns (address) {\n        require(index < size(self), \"requested index too large\");\n        address res = first(self);\n        for (uint256 i = 0; i < index; i++) {\n            res = next(self, res);\n        }\n        return res;\n    }\n}\n\nlibrary GnosisMath {\n    /*\n     *  Constants\n     */\n    // This is equal to 1 in our calculations\n    uint public constant ONE = 0x10000000000000000;\n    uint public constant LN2 = 0xb17217f7d1cf79ac;\n    uint public constant LOG2_E = 0x171547652b82fe177;\n\n    /*\n     *  Public functions\n     */\n    /// @dev Returns natural exponential function value of given x\n    /// @param x x\n    /// @return e**x\n    function exp(int x) public pure returns (uint) {\n        // revert if x is > MAX_POWER, where\n        // MAX_POWER = int(mp.floor(mp.log(mpf(2**256 - 1) / ONE) * ONE))\n        require(x <= 2454971259878909886679);\n        // return 0 if exp(x) is tiny, using\n        // MIN_POWER = int(mp.floor(mp.log(mpf(1) / ONE) * ONE))\n        if (x < -818323753292969962227) return 0;\n        // Transform so that e^x -> 2^x\n        x = x * int(ONE) / int(LN2);\n        // 2^x = 2^whole(x) * 2^frac(x)\n        //       ^^^^^^^^^^ is a bit shift\n        // so Taylor expand on z = frac(x)\n        int shift;\n        uint z;\n        if (x >= 0) {\n            shift = x / int(ONE);\n            z = uint(x % int(ONE));\n        } else {\n            shift = x / int(ONE) - 1;\n            z = ONE - uint(-x % int(ONE));\n        }\n        // 2^x = 1 + (ln 2) x + (ln 2)^2/2! x^2 + ...\n        //\n        // Can generate the z coefficients using mpmath and the following lines\n        // >>> from mpmath import mp\n        // >>> mp.dps = 100\n        // >>> ONE =  0x10000000000000000\n        // >>> print('\\n'.join(hex(int(mp.log(2)**i / mp.factorial(i) * ONE)) for i in range(1, 7)))\n        // 0xb17217f7d1cf79ab\n        // 0x3d7f7bff058b1d50\n        // 0xe35846b82505fc5\n        // 0x276556df749cee5\n        // 0x5761ff9e299cc4\n        // 0xa184897c363c3\n        uint zpow = z;\n        uint result = ONE;\n        result += 0xb17217f7d1cf79ab * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x3d7f7bff058b1d50 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0xe35846b82505fc5 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x276556df749cee5 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x5761ff9e299cc4 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0xa184897c363c3 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0xffe5fe2c4586 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x162c0223a5c8 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x1b5253d395e * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x1e4cf5158b * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x1e8cac735 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x1c3bd650 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x1816193 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x131496 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0xe1b7 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x9c7 * zpow / ONE;\n        if (shift >= 0) {\n            if (result >> (256 - shift) > 0) return (2 ** 256 - 1);\n            return result << shift;\n        } else return result >> (-shift);\n    }\n\n    /// @dev Returns natural logarithm value of given x\n    /// @param x x\n    /// @return ln(x)\n    function ln(uint x) public pure returns (int) {\n        require(x > 0);\n        // binary search for floor(log2(x))\n        int ilog2 = floorLog2(x);\n        int z;\n        if (ilog2 < 0) z = int(x << uint(-ilog2));\n        else z = int(x >> uint(ilog2));\n        // z = x * 2^-⌊log₂x⌋\n        // so 1 <= z < 2\n        // and ln z = ln x - ⌊log₂x⌋/log₂e\n        // so just compute ln z using artanh series\n        // and calculate ln x from that\n        int term = (z - int(ONE)) * int(ONE) / (z + int(ONE));\n        int halflnz = term;\n        int termpow = term * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 3;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 5;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 7;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 9;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 11;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 13;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 15;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 17;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 19;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 21;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 23;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 25;\n        return (ilog2 * int(ONE)) * int(ONE) / int(LOG2_E) + 2 * halflnz;\n    }\n\n    /// @dev Returns base 2 logarithm value of given x\n    /// @param x x\n    /// @return logarithmic value\n    function floorLog2(uint x) public pure returns (int lo) {\n        lo = -64;\n        int hi = 193;\n        // I use a shift here instead of / 2 because it floors instead of rounding towards 0\n        int mid = (hi + lo) >> 1;\n        while ((lo + 1) < hi) {\n            if (mid < 0 && x << uint(-mid) < ONE || mid >= 0 && x >> uint(mid) < ONE) hi = mid;\n            else lo = mid;\n            mid = (hi + lo) >> 1;\n        }\n    }\n\n    /// @dev Returns maximum of an array\n    /// @param nums Numbers to look through\n    /// @return Maximum number\n    function max(int[] memory nums) public pure returns (int maxNum) {\n        require(nums.length > 0);\n        maxNum = -2 ** 255;\n        for (uint i = 0; i < nums.length; i++) if (nums[i] > maxNum) maxNum = nums[i];\n    }\n\n    /// @dev Returns whether an add operation causes an overflow\n    /// @param a First addend\n    /// @param b Second addend\n    /// @return Did no overflow occur?\n    function safeToAdd(uint a, uint b) internal pure returns (bool) {\n        return a + b >= a;\n    }\n\n    /// @dev Returns whether a subtraction operation causes an underflow\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Did no underflow occur?\n    function safeToSub(uint a, uint b) internal pure returns (bool) {\n        return a >= b;\n    }\n\n    /// @dev Returns whether a multiply operation causes an overflow\n    /// @param a First factor\n    /// @param b Second factor\n    /// @return Did no overflow occur?\n    function safeToMul(uint a, uint b) internal pure returns (bool) {\n        return b == 0 || a * b / b == a;\n    }\n\n    /// @dev Returns sum if no overflow occurred\n    /// @param a First addend\n    /// @param b Second addend\n    /// @return Sum\n    function add(uint a, uint b) internal pure returns (uint) {\n        require(safeToAdd(a, b));\n        return a + b;\n    }\n\n    /// @dev Returns difference if no overflow occurred\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Difference\n    function sub(uint a, uint b) internal pure returns (uint) {\n        require(safeToSub(a, b));\n        return a - b;\n    }\n\n    /// @dev Returns product if no overflow occurred\n    /// @param a First factor\n    /// @param b Second factor\n    /// @return Product\n    function mul(uint a, uint b) internal pure returns (uint) {\n        require(safeToMul(a, b));\n        return a * b;\n    }\n\n    /// @dev Returns whether an add operation causes an overflow\n    /// @param a First addend\n    /// @param b Second addend\n    /// @return Did no overflow occur?\n    function safeToAdd(int a, int b) internal pure returns (bool) {\n        return (b >= 0 && a + b >= a) || (b < 0 && a + b < a);\n    }\n\n    /// @dev Returns whether a subtraction operation causes an underflow\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Did no underflow occur?\n    function safeToSub(int a, int b) internal pure returns (bool) {\n        return (b >= 0 && a - b <= a) || (b < 0 && a - b > a);\n    }\n\n    /// @dev Returns whether a multiply operation causes an overflow\n    /// @param a First factor\n    /// @param b Second factor\n    /// @return Did no overflow occur?\n    function safeToMul(int a, int b) internal pure returns (bool) {\n        return (b == 0) || (a * b / b == a);\n    }\n\n    /// @dev Returns sum if no overflow occurred\n    /// @param a First addend\n    /// @param b Second addend\n    /// @return Sum\n    function add(int a, int b) internal pure returns (int) {\n        require(safeToAdd(a, b));\n        return a + b;\n    }\n\n    /// @dev Returns difference if no overflow occurred\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Difference\n    function sub(int a, int b) internal pure returns (int) {\n        require(safeToSub(a, b));\n        return a - b;\n    }\n\n    /// @dev Returns product if no overflow occurred\n    /// @param a First factor\n    /// @param b Second factor\n    /// @return Product\n    function mul(int a, int b) internal pure returns (int) {\n        require(safeToMul(a, b));\n        return a * b;\n    }\n}\n\ncontract Token {\n    /*\n     *  Events\n     */\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n\n    /*\n     *  Public functions\n     */\n    function transfer(address to, uint value) public returns (bool);\n    function transferFrom(address from, address to, uint value) public returns (bool);\n    function approve(address spender, uint value) public returns (bool);\n    function balanceOf(address owner) public view returns (uint);\n    function allowance(address owner, address spender) public view returns (uint);\n    function totalSupply() public view returns (uint);\n}\n\ncontract Proxied {\n    address public masterCopy;\n}\n\ncontract Proxy is Proxied {\n    /// @dev Constructor function sets address of master copy contract.\n    /// @param _masterCopy Master copy address.\n    constructor(address _masterCopy) public {\n        require(_masterCopy != address(0), \"The master copy is required\");\n        masterCopy = _masterCopy;\n    }\n\n    /// @dev Fallback function forwards all transactions and returns all received return data.\n    function() external payable {\n        address _masterCopy = masterCopy;\n        assembly {\n            calldatacopy(0, 0, calldatasize)\n            let success := delegatecall(not(0), _masterCopy, 0, calldatasize, 0, 0)\n            returndatacopy(0, 0, returndatasize)\n            switch success\n                case 0 {\n                    revert(0, returndatasize)\n                }\n                default {\n                    return(0, returndatasize)\n                }\n        }\n    }\n}\n\ncontract StandardTokenData {\n    /*\n     *  Storage\n     */\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowances;\n    uint totalTokens;\n}\n\ncontract GnosisStandardToken is Token, StandardTokenData {\n    using GnosisMath for *;\n\n    /*\n     *  Public functions\n     */\n    /// @dev Transfers sender's tokens to a given address. Returns success\n    /// @param to Address of token receiver\n    /// @param value Number of tokens to transfer\n    /// @return Was transfer successful?\n    function transfer(address to, uint value) public returns (bool) {\n        if (!balances[msg.sender].safeToSub(value) || !balances[to].safeToAdd(value)) {\n            return false;\n        }\n\n        balances[msg.sender] -= value;\n        balances[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success\n    /// @param from Address from where tokens are withdrawn\n    /// @param to Address to where tokens are sent\n    /// @param value Number of tokens to transfer\n    /// @return Was transfer successful?\n    function transferFrom(address from, address to, uint value) public returns (bool) {\n        if (!balances[from].safeToSub(value) || !allowances[from][msg.sender].safeToSub(\n            value\n        ) || !balances[to].safeToAdd(value)) {\n            return false;\n        }\n        balances[from] -= value;\n        allowances[from][msg.sender] -= value;\n        balances[to] += value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    /// @dev Sets approved amount of tokens for spender. Returns success\n    /// @param spender Address of allowed account\n    /// @param value Number of approved tokens\n    /// @return Was approval successful?\n    function approve(address spender, uint value) public returns (bool) {\n        allowances[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /// @dev Returns number of allowed tokens for given address\n    /// @param owner Address of token owner\n    /// @param spender Address of token spender\n    /// @return Remaining allowance for spender\n    function allowance(address owner, address spender) public view returns (uint) {\n        return allowances[owner][spender];\n    }\n\n    /// @dev Returns number of tokens owned by given address\n    /// @param owner Address of token owner\n    /// @return Balance of owner\n    function balanceOf(address owner) public view returns (uint) {\n        return balances[owner];\n    }\n\n    /// @dev Returns total supply of tokens\n    /// @return Total supply\n    function totalSupply() public view returns (uint) {\n        return totalTokens;\n    }\n}\n\ncontract TokenOWL is Proxied, GnosisStandardToken {\n    using GnosisMath for *;\n\n    string public constant name = \"OWL Token\";\n    string public constant symbol = \"OWL\";\n    uint8 public constant decimals = 18;\n\n    struct masterCopyCountdownType {\n        address masterCopy;\n        uint timeWhenAvailable;\n    }\n\n    masterCopyCountdownType masterCopyCountdown;\n\n    address public creator;\n    address public minter;\n\n    event Minted(address indexed to, uint256 amount);\n    event Burnt(address indexed from, address indexed user, uint256 amount);\n\n    modifier onlyCreator() {\n        // R1\n        require(msg.sender == creator, \"Only the creator can perform the transaction\");\n        _;\n    }\n    /// @dev trickers the update process via the proxyMaster for a new address _masterCopy\n    /// updating is only possible after 30 days\n    function startMasterCopyCountdown(address _masterCopy) public onlyCreator {\n        require(address(_masterCopy) != address(0), \"The master copy must be a valid address\");\n\n        // Update masterCopyCountdown\n        masterCopyCountdown.masterCopy = _masterCopy;\n        masterCopyCountdown.timeWhenAvailable = now + 30 days;\n    }\n\n    /// @dev executes the update process via the proxyMaster for a new address _masterCopy\n    function updateMasterCopy() public onlyCreator {\n        require(address(masterCopyCountdown.masterCopy) != address(0), \"The master copy must be a valid address\");\n        require(\n            block.timestamp >= masterCopyCountdown.timeWhenAvailable,\n            \"It's not possible to update the master copy during the waiting period\"\n        );\n\n        // Update masterCopy\n        masterCopy = masterCopyCountdown.masterCopy;\n    }\n\n    function getMasterCopy() public view returns (address) {\n        return masterCopy;\n    }\n\n    /// @dev Set minter. Only the creator of this contract can call this.\n    /// @param newMinter The new address authorized to mint this token\n    function setMinter(address newMinter) public onlyCreator {\n        minter = newMinter;\n    }\n\n    /// @dev change owner/creator of the contract. Only the creator/owner of this contract can call this.\n    /// @param newOwner The new address, which should become the owner\n    function setNewOwner(address newOwner) public onlyCreator {\n        creator = newOwner;\n    }\n\n    /// @dev Mints OWL.\n    /// @param to Address to which the minted token will be given\n    /// @param amount Amount of OWL to be minted\n    function mintOWL(address to, uint amount) public {\n        require(minter != address(0), \"The minter must be initialized\");\n        require(msg.sender == minter, \"Only the minter can mint OWL\");\n        balances[to] = balances[to].add(amount);\n        totalTokens = totalTokens.add(amount);\n        emit Minted(to, amount);\n        emit Transfer(address(0), to, amount);\n    }\n\n    /// @dev Burns OWL.\n    /// @param user Address of OWL owner\n    /// @param amount Amount of OWL to be burnt\n    function burnOWL(address user, uint amount) public {\n        allowances[user][msg.sender] = allowances[user][msg.sender].sub(amount);\n        balances[user] = balances[user].sub(amount);\n        totalTokens = totalTokens.sub(amount);\n        emit Burnt(msg.sender, user, amount);\n        emit Transfer(user, address(0), amount);\n    }\n\n    function getMasterCopyCountdown() public view returns (address, uint) {\n        return (masterCopyCountdown.masterCopy, masterCopyCountdown.timeWhenAvailable);\n    }\n}\n\nlibrary SafeCast {\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return uint8(value);\n    }\n}\n\nlibrary SignedSafeMath {\n    int256 constant private INT256_MIN = -2**255;\n\n    /**\n     * @dev Multiplies two signed integers, reverts on overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two signed integers, reverts on overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two signed integers, reverts on overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n\nlibrary TokenConservation {\n    using SignedSafeMath for int256;\n\n    /** @dev initialize the token conservation data structure\n     * @param tokenIdsForPrice sorted list of tokenIds for which token conservation should be checked\n     */\n    function init(uint16[] memory tokenIdsForPrice) internal pure returns (int256[] memory) {\n        return new int256[](tokenIdsForPrice.length + 1);\n    }\n\n    /** @dev returns the token imbalance of the fee token\n     * @param self internal datastructure created by TokenConservation.init()\n     */\n    function feeTokenImbalance(int256[] memory self) internal pure returns (int256) {\n        return self[0];\n    }\n\n    /** @dev updated token conservation array.\n     * @param self internal datastructure created by TokenConservation.init()\n     * @param buyToken id of token whose imbalance should be subtracted from\n     * @param sellToken id of token whose imbalance should be added to\n     * @param tokenIdsForPrice sorted list of tokenIds\n     * @param buyAmount amount to be subtracted at `self[buyTokenIndex]`\n     * @param sellAmount amount to be added at `self[sellTokenIndex]`\n     */\n    function updateTokenConservation(\n        int256[] memory self,\n        uint16 buyToken,\n        uint16 sellToken,\n        uint16[] memory tokenIdsForPrice,\n        uint128 buyAmount,\n        uint128 sellAmount\n    ) internal pure {\n        uint256 buyTokenIndex = findPriceIndex(buyToken, tokenIdsForPrice);\n        uint256 sellTokenIndex = findPriceIndex(sellToken, tokenIdsForPrice);\n        self[buyTokenIndex] = self[buyTokenIndex].sub(int256(buyAmount));\n        self[sellTokenIndex] = self[sellTokenIndex].add(int256(sellAmount));\n    }\n\n    /** @dev Ensures all array's elements are zero except the first.\n     * @param self internal datastructure created by TokenConservation.init()\n     * @return true if all, but first element of self are zero else false\n     */\n    function checkTokenConservation(int256[] memory self) internal pure {\n        require(self[0] > 0, \"Token conservation at 0 must be positive.\");\n        for (uint256 i = 1; i < self.length; i++) {\n            require(self[i] == 0, \"Token conservation does not hold\");\n        }\n    }\n\n    /** @dev Token ordering is verified by submitSolution. Required because binary search is used to fetch token info.\n     * @param tokenIdsForPrice list of tokenIds\n     * @return true if tokenIdsForPrice is sorted else false\n     */\n    function checkPriceOrdering(uint16[] memory tokenIdsForPrice) internal pure returns (bool) {\n        for (uint256 i = 1; i < tokenIdsForPrice.length; i++) {\n            if (tokenIdsForPrice[i] <= tokenIdsForPrice[i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /** @dev implementation of binary search on sorted list returns token id\n     * @param tokenId element whose index is to be found\n     * @param tokenIdsForPrice list of (sorted) tokenIds for which binary search is applied.\n     * @return `index` in `tokenIdsForPrice` where `tokenId` appears (reverts if not found).\n     */\n    function findPriceIndex(uint16 tokenId, uint16[] memory tokenIdsForPrice) private pure returns (uint256) {\n        // Fee token is not included in tokenIdsForPrice\n        if (tokenId == 0) {\n            return 0;\n        }\n        // binary search for the other tokens\n        uint256 leftValue = 0;\n        uint256 rightValue = tokenIdsForPrice.length - 1;\n        while (rightValue >= leftValue) {\n            uint256 middleValue = (leftValue + rightValue) / 2;\n            if (tokenIdsForPrice[middleValue] == tokenId) {\n                // shifted one to the right to account for fee token at index 0\n                return middleValue + 1;\n            } else if (tokenIdsForPrice[middleValue] < tokenId) {\n                leftValue = middleValue + 1;\n            } else {\n                rightValue = middleValue - 1;\n            }\n        }\n        revert(\"Price not provided for token\");\n    }\n}\n\ncontract BatchExchange is EpochTokenLocker {\n    using SafeCast for uint256;\n    using SafeMath for uint128;\n    using BytesLib for bytes32;\n    using BytesLib for bytes;\n    using TokenConservation for int256[];\n    using TokenConservation for uint16[];\n    using IterableAppendOnlySet for IterableAppendOnlySet.Data;\n\n    /** @dev Maximum number of touched orders in auction (used in submitSolution) */\n    uint256 public constant MAX_TOUCHED_ORDERS = 30;\n\n    /** @dev Fee charged for adding a token */\n    uint256 public constant FEE_FOR_LISTING_TOKEN_IN_OWL = 10 ether;\n\n    /** @dev minimum allowed value (in WEI) of any prices or executed trade amounts */\n    uint128 public constant AMOUNT_MINIMUM = 10**4;\n\n    /** @dev Numerator or denominator used in orders, which do not track its usedAmount*/\n    uint128 public constant UNLIMITED_ORDER_AMOUNT = uint128(-1);\n\n    /** Corresponds to percentage that competing solution must improve on current\n     * (p = IMPROVEMENT_DENOMINATOR + 1 / IMPROVEMENT_DENOMINATOR)\n     */\n    uint256 public constant IMPROVEMENT_DENOMINATOR = 100; // 1%\n\n    /** @dev A fixed integer used to evaluate fees as a fraction of trade execution 1/FEE_DENOMINATOR */\n    uint128 public constant FEE_DENOMINATOR = 1000;\n\n    /** @dev The number of bytes a single auction element is serialized into */\n    uint128 public constant ENCODED_AUCTION_ELEMENT_WIDTH = 112;\n\n    /** @dev maximum number of tokens that can be listed for exchange */\n    // solhint-disable-next-line var-name-mixedcase\n    uint256 public MAX_TOKENS;\n\n    /** @dev Current number of tokens listed/available for exchange */\n    uint16 public numTokens;\n\n    /** @dev The feeToken of the exchange will be the OWL Token */\n    TokenOWL public feeToken;\n\n    /** @dev mapping of type userAddress -> List[Order] where all the user's orders are stored */\n    mapping(address => Order[]) public orders;\n\n    /** @dev mapping of type tokenId -> curentPrice of tokenId */\n    mapping(uint16 => uint128) public currentPrices;\n\n    /** @dev Sufficient information for current winning auction solution */\n    SolutionData public latestSolution;\n\n    // Iterable set of all users, required to collect auction information\n    IterableAppendOnlySet.Data private allUsers;\n    IdToAddressBiMap.Data private registeredTokens;\n\n    struct Order {\n        uint16 buyToken;\n        uint16 sellToken;\n        uint32 validFrom; // order is valid from auction collection period: validFrom inclusive\n        uint32 validUntil; // order is valid till auction collection period: validUntil inclusive\n        uint128 priceNumerator;\n        uint128 priceDenominator;\n        uint128 usedAmount; // remainingAmount = priceDenominator - usedAmount\n    }\n\n    struct TradeData {\n        address owner;\n        uint128 volume;\n        uint16 orderId;\n    }\n\n    struct SolutionData {\n        uint32 batchId;\n        TradeData[] trades;\n        uint16[] tokenIdsForPrice;\n        address solutionSubmitter;\n        uint256 feeReward;\n        uint256 objectiveValue;\n    }\n\n    event OrderPlacement(\n        address indexed owner,\n        uint16 index,\n        uint16 indexed buyToken,\n        uint16 indexed sellToken,\n        uint32 validFrom,\n        uint32 validUntil,\n        uint128 priceNumerator,\n        uint128 priceDenominator\n    );\n\n    event TokenListing(address token, uint16 id);\n\n    /** @dev Event emitted when an order is cancelled but still valid in the batch that is\n     * currently being solved. It remains in storage but will not be tradable in any future\n     * batch to be solved.\n     */\n    event OrderCancellation(address indexed owner, uint16 id);\n\n    /** @dev Event emitted when an order is removed from storage.\n     */\n    event OrderDeletion(address indexed owner, uint16 id);\n\n    /** @dev Event emitted when a new trade is settled\n     */\n    event Trade(\n        address indexed owner,\n        uint16 indexed orderId,\n        uint16 indexed sellToken,\n        // Solidity only supports three indexed arguments\n        uint16 buyToken,\n        uint128 executedSellAmount,\n        uint128 executedBuyAmount\n    );\n\n    /** @dev Event emitted when an already exectued trade gets reverted\n     */\n    event TradeReversion(\n        address indexed owner,\n        uint16 indexed orderId,\n        uint16 indexed sellToken,\n        // Solidity only supports three indexed arguments\n        uint16 buyToken,\n        uint128 executedSellAmount,\n        uint128 executedBuyAmount\n    );\n\n    /** @dev Event emitted for each solution that is submitted\n     */\n    event SolutionSubmission(\n        address indexed submitter,\n        uint256 utility,\n        uint256 disregardedUtility,\n        uint256 burntFees,\n        uint256 lastAuctionBurntFees,\n        uint128[] prices,\n        uint16[] tokenIdsForPrice\n    );\n\n    /** @dev Constructor determines exchange parameters\n     * @param maxTokens The maximum number of tokens that can be listed.\n     * @param _feeToken Address of ERC20 fee token.\n     */\n    constructor(uint256 maxTokens, address _feeToken) public {\n        // All solutions for the batches must have normalized prices. The following line sets the\n        // price of OWL to 10**18 for all solutions and hence enforces a normalization.\n        currentPrices[0] = 1 ether;\n        MAX_TOKENS = maxTokens;\n        feeToken = TokenOWL(_feeToken);\n        // The burn functionallity of OWL requires an approval.\n        // In the following line the approval is set for all future burn calls.\n        feeToken.approve(address(this), uint256(-1));\n        addToken(_feeToken); // feeToken will always have the token index 0\n    }\n\n    /** @dev Used to list a new token on the contract: Hence, making it available for exchange in an auction.\n     * @param token ERC20 token to be listed.\n     *\n     * Requirements:\n     * - `maxTokens` has not already been reached\n     * - `token` has not already been added\n     */\n    function addToken(address token) public {\n        require(numTokens < MAX_TOKENS, \"Max tokens reached\");\n        if (numTokens > 0) {\n            // Only charge fees for tokens other than the fee token itself\n            feeToken.burnOWL(msg.sender, FEE_FOR_LISTING_TOKEN_IN_OWL);\n        }\n        require(IdToAddressBiMap.insert(registeredTokens, numTokens, token), \"Token already registered\");\n        emit TokenListing(token, numTokens);\n        numTokens++;\n    }\n\n    /** @dev A user facing function used to place limit sell orders in auction with expiry defined by batchId\n     * @param buyToken id of token to be bought\n     * @param sellToken id of token to be sold\n     * @param validUntil batchId representing order's expiry\n     * @param buyAmount relative minimum amount of requested buy amount\n     * @param sellAmount maximum amount of sell token to be exchanged\n     * @return orderId defined as the index in user's order array\n     *\n     * Emits an {OrderPlacement} event with all relevant order details.\n     */\n    function placeOrder(uint16 buyToken, uint16 sellToken, uint32 validUntil, uint128 buyAmount, uint128 sellAmount)\n        public\n        returns (uint256)\n    {\n        return placeOrderInternal(buyToken, sellToken, getCurrentBatchId(), validUntil, buyAmount, sellAmount);\n    }\n\n    /** @dev A user facing function used to place limit sell orders in auction with expiry defined by batchId\n     * Note that parameters are passed as arrays and the indices correspond to each order.\n     * @param buyTokens ids of tokens to be bought\n     * @param sellTokens ids of tokens to be sold\n     * @param validFroms batchIds representing order's validity start time\n     * @param validUntils batchIds representing order's expiry\n     * @param buyAmounts relative minimum amount of requested buy amounts\n     * @param sellAmounts maximum amounts of sell token to be exchanged\n     * @return `orderIds` an array of indices in which `msg.sender`'s orders are included\n     *\n     * Emits an {OrderPlacement} event with all relevant order details.\n     */\n    function placeValidFromOrders(\n        uint16[] memory buyTokens,\n        uint16[] memory sellTokens,\n        uint32[] memory validFroms,\n        uint32[] memory validUntils,\n        uint128[] memory buyAmounts,\n        uint128[] memory sellAmounts\n    ) public returns (uint16[] memory orderIds) {\n        orderIds = new uint16[](buyTokens.length);\n        for (uint256 i = 0; i < buyTokens.length; i++) {\n            orderIds[i] = placeOrderInternal(\n                buyTokens[i],\n                sellTokens[i],\n                validFroms[i],\n                validUntils[i],\n                buyAmounts[i],\n                sellAmounts[i]\n            );\n        }\n    }\n\n    /** @dev a user facing function used to cancel orders. If the order is valid for the batch that is currently\n     * being solved, it sets order expiry to that batchId. Otherwise it removes it from storage. Can be called\n     * multiple times (e.g. to eventually free storage once order is expired).\n     *\n     * @param orderIds referencing the indices of user's orders to be cancelled\n     *\n     * Emits an {OrderCancellation} or {OrderDeletion} with sender's address and orderId\n     */\n    function cancelOrders(uint16[] memory orderIds) public {\n        uint32 batchIdBeingSolved = getCurrentBatchId() - 1;\n        for (uint16 i = 0; i < orderIds.length; i++) {\n            if (!checkOrderValidity(orders[msg.sender][orderIds[i]], batchIdBeingSolved)) {\n                delete orders[msg.sender][orderIds[i]];\n                emit OrderDeletion(msg.sender, orderIds[i]);\n            } else {\n                orders[msg.sender][orderIds[i]].validUntil = batchIdBeingSolved;\n                emit OrderCancellation(msg.sender, orderIds[i]);\n            }\n        }\n    }\n\n    /** @dev A user facing wrapper to cancel and place new orders in the same transaction.\n     * @param cancellations indices of orders to be cancelled\n     * @param buyTokens ids of tokens to be bought in new orders\n     * @param sellTokens ids of tokens to be sold in new orders\n     * @param validFroms batchIds representing order's validity start time in new orders\n     * @param validUntils batchIds represnnting order's expiry in new orders\n     * @param buyAmounts relative minimum amount of requested buy amounts in new orders\n     * @param sellAmounts maximum amounts of sell token to be exchanged in new orders\n     * @return an array of indices in which `msg.sender`'s new orders are included\n     *\n     * Emits {OrderCancellation} events for all cancelled orders and {OrderPlacement} events with relevant new order details.\n     */\n    function replaceOrders(\n        uint16[] memory cancellations,\n        uint16[] memory buyTokens,\n        uint16[] memory sellTokens,\n        uint32[] memory validFroms,\n        uint32[] memory validUntils,\n        uint128[] memory buyAmounts,\n        uint128[] memory sellAmounts\n    ) public returns (uint16[] memory) {\n        cancelOrders(cancellations);\n        return placeValidFromOrders(buyTokens, sellTokens, validFroms, validUntils, buyAmounts, sellAmounts);\n    }\n\n    /** @dev a solver facing function called for auction settlement\n     * @param batchId index of auction solution is referring to\n     * @param owners array of addresses corresponding to touched orders\n     * @param orderIds array of order indices used in parallel with owners to identify touched order\n     * @param buyVolumes executed buy amounts for each order identified by index of owner-orderId arrays\n     * @param prices list of prices for touched tokens indexed by next parameter\n     * @param tokenIdsForPrice price[i] is the price for the token with tokenID tokenIdsForPrice[i]\n     * @return the computed objective value of the solution\n     *\n     * Requirements:\n     * - Solutions for this `batchId` are currently being accepted.\n     * - Claimed objetive value is a great enough improvement on the current winning solution\n     * - Fee Token price is non-zero\n     * - `tokenIdsForPrice` is sorted.\n     * - Number of touched orders does not exceed `MAX_TOUCHED_ORDERS`.\n     * - Each touched order is valid at current `batchId`.\n     * - Each touched order's `executedSellAmount` does not exceed its remaining amount.\n     * - Limit Price of each touched order is respected.\n     * - Solution's objective evaluation must be positive.\n     *\n     * Sub Requirements: Those nested within other functions\n     * - checkAndOverrideObjectiveValue; Objetive value is a great enough improvement on the current winning solution\n     * - checkTokenConservation; for all, non-fee, tokens total amount sold == total amount bought\n     */\n    function submitSolution(\n        uint32 batchId,\n        uint256 claimedObjectiveValue,\n        address[] memory owners,\n        uint16[] memory orderIds,\n        uint128[] memory buyVolumes,\n        uint128[] memory prices,\n        uint16[] memory tokenIdsForPrice\n    ) public returns (uint256) {\n        require(acceptingSolutions(batchId), \"Solutions are no longer accepted for this batch\");\n        require(\n            isObjectiveValueSufficientlyImproved(claimedObjectiveValue),\n            \"Claimed objective doesn't sufficiently improve current solution\"\n        );\n        require(verifyAmountThreshold(prices), \"At least one price lower than AMOUNT_MINIMUM\");\n        require(tokenIdsForPrice[0] != 0, \"Fee token has fixed price!\");\n        require(tokenIdsForPrice.checkPriceOrdering(), \"prices are not ordered by tokenId\");\n        require(owners.length <= MAX_TOUCHED_ORDERS, \"Solution exceeds MAX_TOUCHED_ORDERS\");\n        // Further assumptions are: owners.length == orderIds.length && owners.length == buyVolumes.length\n        // && prices.length == tokenIdsForPrice.length\n        // These assumptions are not checked explicitly, as violations of these constraints can not be used\n        // to create a beneficial situation\n        uint256 lastAuctionBurntFees = burnPreviousAuctionFees();\n        undoCurrentSolution();\n        updateCurrentPrices(prices, tokenIdsForPrice);\n        delete latestSolution.trades;\n        int256[] memory tokenConservation = TokenConservation.init(tokenIdsForPrice);\n        uint256 utility = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            Order memory order = orders[owners[i]][orderIds[i]];\n            require(checkOrderValidity(order, batchId), \"Order is invalid\");\n            (uint128 executedBuyAmount, uint128 executedSellAmount) = getTradedAmounts(buyVolumes[i], order);\n            require(executedBuyAmount >= AMOUNT_MINIMUM, \"buy amount less than AMOUNT_MINIMUM\");\n            require(executedSellAmount >= AMOUNT_MINIMUM, \"sell amount less than AMOUNT_MINIMUM\");\n            tokenConservation.updateTokenConservation(\n                order.buyToken,\n                order.sellToken,\n                tokenIdsForPrice,\n                executedBuyAmount,\n                executedSellAmount\n            );\n            require(getRemainingAmount(order) >= executedSellAmount, \"executedSellAmount bigger than specified in order\");\n            // Ensure executed price is not lower than the order price:\n            //       executedSellAmount / executedBuyAmount <= order.priceDenominator / order.priceNumerator\n            require(\n                executedSellAmount.mul(order.priceNumerator) <= executedBuyAmount.mul(order.priceDenominator),\n                \"limit price not satisfied\"\n            );\n            // accumulate utility before updateRemainingOrder, but after limitPrice verified!\n            utility = utility.add(evaluateUtility(executedBuyAmount, order));\n            updateRemainingOrder(owners[i], orderIds[i], executedSellAmount);\n            addBalanceAndBlockWithdrawForThisBatch(owners[i], tokenIdToAddressMap(order.buyToken), executedBuyAmount);\n            emit Trade(owners[i], orderIds[i], order.sellToken, order.buyToken, executedSellAmount, executedBuyAmount);\n        }\n        // Perform all subtractions after additions to avoid negative values\n        for (uint256 i = 0; i < owners.length; i++) {\n            Order memory order = orders[owners[i]][orderIds[i]];\n            (, uint128 executedSellAmount) = getTradedAmounts(buyVolumes[i], order);\n            subtractBalance(owners[i], tokenIdToAddressMap(order.sellToken), executedSellAmount);\n        }\n        uint256 disregardedUtility = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            disregardedUtility = disregardedUtility.add(evaluateDisregardedUtility(orders[owners[i]][orderIds[i]], owners[i]));\n        }\n        uint256 burntFees = uint256(tokenConservation.feeTokenImbalance()) / 2;\n        // burntFees ensures direct trades (when available) yield better solutions than longer rings\n        uint256 objectiveValue = utility.add(burntFees).sub(disregardedUtility);\n        checkAndOverrideObjectiveValue(objectiveValue);\n        grantRewardToSolutionSubmitter(burntFees);\n        tokenConservation.checkTokenConservation();\n        documentTrades(batchId, owners, orderIds, buyVolumes, tokenIdsForPrice);\n\n        emit SolutionSubmission(\n            msg.sender,\n            utility,\n            disregardedUtility,\n            burntFees,\n            lastAuctionBurntFees,\n            prices,\n            tokenIdsForPrice\n        );\n        return (objectiveValue);\n    }\n\n    /**\n     * Public View Methods\n     */\n    /** @dev View returning ID of listed tokens\n     * @param addr address of listed token.\n     * @return tokenId as stored within the contract.\n     */\n    function tokenAddressToIdMap(address addr) public view returns (uint16) {\n        return IdToAddressBiMap.getId(registeredTokens, addr);\n    }\n\n    /** @dev View returning address of listed token by ID\n     * @param id tokenId as stored, via BiMap, within the contract.\n     * @return address of (listed) token\n     */\n    function tokenIdToAddressMap(uint16 id) public view returns (address) {\n        return IdToAddressBiMap.getAddressAt(registeredTokens, id);\n    }\n\n    /** @dev View returning a bool attesting whether token was already added\n     * @param addr address of the token to be checked\n     * @return bool attesting whether token was already added\n     */\n    function hasToken(address addr) public view returns (bool) {\n        return IdToAddressBiMap.hasAddress(registeredTokens, addr);\n    }\n\n    /** @dev View returning all byte-encoded sell orders for specified user\n     * @param user address of user whose orders are being queried\n     * @param offset uint determining the starting orderIndex\n     * @param pageSize uint determining the count of elements to be viewed\n     * @return encoded bytes representing all orders\n     */\n    function getEncodedUserOrdersPaginated(address user, uint16 offset, uint16 pageSize)\n        public\n        view\n        returns (bytes memory elements)\n    {\n        for (uint16 i = offset; i < Math.min(orders[user].length, offset + pageSize); i++) {\n            elements = elements.concat(\n                encodeAuctionElement(user, getBalance(user, tokenIdToAddressMap(orders[user][i].sellToken)), orders[user][i])\n            );\n        }\n        return elements;\n    }\n\n    /** @dev View returning all byte-encoded users in paginated form\n     * @param previousPageUser address of last user received in last pages (address(0) for first page)\n     * @param pageSize uint determining the count of users to be returned per page\n     * @return encoded packed bytes of user addresses\n     */\n    function getUsersPaginated(address previousPageUser, uint16 pageSize) public view returns (bytes memory users) {\n        if (allUsers.size() == 0) {\n            return users;\n        }\n        uint16 count = 0;\n        address current = previousPageUser;\n        if (current == address(0)) {\n            current = allUsers.first();\n            users = users.concat(abi.encodePacked(current));\n            count++;\n        }\n        while (count < pageSize && current != allUsers.last) {\n            current = allUsers.next(current);\n            users = users.concat(abi.encodePacked(current));\n            count++;\n        }\n        return users;\n    }\n\n    /** @dev View returning all byte-encoded sell orders for specified user\n     * @param user address of user whose orders are being queried\n     * @return encoded bytes representing all orders\n     */\n    function getEncodedUserOrders(address user) public view returns (bytes memory elements) {\n        return getEncodedUserOrdersPaginated(user, 0, uint16(-1));\n    }\n\n    /** @dev View returning byte-encoded sell orders in paginated form\n     * @param previousPageUser address of last user received in the previous page (address(0) for first page)\n     * @param previousPageUserOffset the number of orders received for the last user on the previous page (0 for first page).\n     * @param pageSize uint determining the count of orders to be returned per page\n     * @return encoded bytes representing a page of orders ordered by (user, index)\n     */\n    function getEncodedUsersPaginated(address previousPageUser, uint16 previousPageUserOffset, uint16 pageSize)\n        public\n        view\n        returns (bytes memory elements)\n    {\n        if (allUsers.size() == 0) {\n            return elements;\n        }\n        uint16 currentOffset = previousPageUserOffset;\n        address currentUser = previousPageUser;\n        if (currentUser == address(0x0)) {\n            currentUser = allUsers.first();\n        }\n        while (elements.length / ENCODED_AUCTION_ELEMENT_WIDTH < pageSize) {\n            elements = elements.concat(\n                getEncodedUserOrdersPaginated(\n                    currentUser,\n                    currentOffset,\n                    pageSize - uint16(elements.length / ENCODED_AUCTION_ELEMENT_WIDTH)\n                )\n            );\n            if (currentUser == allUsers.last) {\n                return elements;\n            }\n            currentOffset = 0;\n            currentUser = allUsers.next(currentUser);\n        }\n    }\n\n    /** @dev View returning all byte-encoded sell orders\n     * @return encoded bytes representing all orders ordered by (user, index)\n     */\n    function getEncodedOrders() public view returns (bytes memory elements) {\n        if (allUsers.size() > 0) {\n            address user = allUsers.first();\n            bool stop = false;\n            while (!stop) {\n                elements = elements.concat(getEncodedUserOrders(user));\n                if (user == allUsers.last) {\n                    stop = true;\n                } else {\n                    user = allUsers.next(user);\n                }\n            }\n        }\n        return elements;\n    }\n\n    function acceptingSolutions(uint32 batchId) public view returns (bool) {\n        return batchId == getCurrentBatchId() - 1 && getSecondsRemainingInBatch() >= 1 minutes;\n    }\n\n    /** @dev gets the objective value of currently winning solution.\n     * @return objective function evaluation of the currently winning solution, or zero if no solution proposed.\n     */\n    function getCurrentObjectiveValue() public view returns (uint256) {\n        if (latestSolution.batchId == getCurrentBatchId() - 1) {\n            return latestSolution.objectiveValue;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * Private Functions\n     */\n    function placeOrderInternal(\n        uint16 buyToken,\n        uint16 sellToken,\n        uint32 validFrom,\n        uint32 validUntil,\n        uint128 buyAmount,\n        uint128 sellAmount\n    ) private returns (uint16) {\n        require(IdToAddressBiMap.hasId(registeredTokens, buyToken), \"Buy token must be listed\");\n        require(IdToAddressBiMap.hasId(registeredTokens, sellToken), \"Sell token must be listed\");\n        require(buyToken != sellToken, \"Exchange tokens not distinct\");\n        require(validFrom >= getCurrentBatchId(), \"Orders can't be placed in the past\");\n        orders[msg.sender].push(\n            Order({\n                buyToken: buyToken,\n                sellToken: sellToken,\n                validFrom: validFrom,\n                validUntil: validUntil,\n                priceNumerator: buyAmount,\n                priceDenominator: sellAmount,\n                usedAmount: 0\n            })\n        );\n        uint16 orderId = (orders[msg.sender].length - 1).toUint16();\n        emit OrderPlacement(msg.sender, orderId, buyToken, sellToken, validFrom, validUntil, buyAmount, sellAmount);\n        allUsers.insert(msg.sender);\n        return orderId;\n    }\n\n    /** @dev called at the end of submitSolution with a value of tokenConservation / 2\n     * @param feeReward amount to be rewarded to the solver\n     */\n    function grantRewardToSolutionSubmitter(uint256 feeReward) private {\n        latestSolution.feeReward = feeReward;\n        addBalanceAndBlockWithdrawForThisBatch(msg.sender, tokenIdToAddressMap(0), feeReward);\n    }\n\n    /** @dev called during solution submission to burn fees from previous auction\n     * @return amount of OWL burnt\n     */\n    function burnPreviousAuctionFees() private returns (uint256) {\n        if (!currentBatchHasSolution()) {\n            feeToken.burnOWL(address(this), latestSolution.feeReward);\n            return latestSolution.feeReward;\n        }\n        return 0;\n    }\n\n    /** @dev Called from within submitSolution to update the token prices.\n     * @param prices list of prices for touched tokens only, first price is always fee token price\n     * @param tokenIdsForPrice price[i] is the price for the token with tokenID tokenIdsForPrice[i]\n     */\n    function updateCurrentPrices(uint128[] memory prices, uint16[] memory tokenIdsForPrice) private {\n        for (uint256 i = 0; i < latestSolution.tokenIdsForPrice.length; i++) {\n            currentPrices[latestSolution.tokenIdsForPrice[i]] = 0;\n        }\n        for (uint256 i = 0; i < tokenIdsForPrice.length; i++) {\n            currentPrices[tokenIdsForPrice[i]] = prices[i];\n        }\n    }\n\n    /** @dev Updates an order's remaing requested sell amount upon (partial) execution of a standing order\n     * @param owner order's corresponding user address\n     * @param orderId index of order in list of owner's orders\n     * @param executedAmount proportion of order's requested sellAmount that was filled.\n     */\n    function updateRemainingOrder(address owner, uint16 orderId, uint128 executedAmount) private {\n        if (isOrderWithLimitedAmount(orders[owner][orderId])) {\n            orders[owner][orderId].usedAmount = orders[owner][orderId].usedAmount.add(executedAmount).toUint128();\n        }\n    }\n\n    /** @dev The inverse of updateRemainingOrder, called when reverting a solution in favour of a better one.\n     * @param owner order's corresponding user address\n     * @param orderId index of order in list of owner's orders\n     * @param executedAmount proportion of order's requested sellAmount that was filled.\n     */\n    function revertRemainingOrder(address owner, uint16 orderId, uint128 executedAmount) private {\n        if (isOrderWithLimitedAmount(orders[owner][orderId])) {\n            orders[owner][orderId].usedAmount = orders[owner][orderId].usedAmount.sub(executedAmount).toUint128();\n        }\n    }\n\n    /** @dev Checks whether an order is intended to track its usedAmount\n     * @param order order under inspection\n     * @return true if the given order does track its usedAmount\n     */\n    function isOrderWithLimitedAmount(Order memory order) private pure returns (bool) {\n        return order.priceNumerator != UNLIMITED_ORDER_AMOUNT && order.priceDenominator != UNLIMITED_ORDER_AMOUNT;\n    }\n\n    /** @dev This function writes solution information into contract storage\n     * @param batchId index of referenced auction\n     * @param owners array of addresses corresponding to touched orders\n     * @param orderIds array of order indices used in parallel with owners to identify touched order\n     * @param volumes executed buy amounts for each order identified by index of owner-orderId arrays\n     * @param tokenIdsForPrice price[i] is the price for the token with tokenID tokenIdsForPrice[i]\n     */\n    function documentTrades(\n        uint32 batchId,\n        address[] memory owners,\n        uint16[] memory orderIds,\n        uint128[] memory volumes,\n        uint16[] memory tokenIdsForPrice\n    ) private {\n        latestSolution.batchId = batchId;\n        for (uint256 i = 0; i < owners.length; i++) {\n            latestSolution.trades.push(TradeData({owner: owners[i], orderId: orderIds[i], volume: volumes[i]}));\n        }\n        latestSolution.tokenIdsForPrice = tokenIdsForPrice;\n        latestSolution.solutionSubmitter = msg.sender;\n    }\n\n    /** @dev reverts all relevant contract storage relating to an overwritten auction solution.\n     */\n    function undoCurrentSolution() private {\n        if (currentBatchHasSolution()) {\n            for (uint256 i = 0; i < latestSolution.trades.length; i++) {\n                address owner = latestSolution.trades[i].owner;\n                uint16 orderId = latestSolution.trades[i].orderId;\n                Order memory order = orders[owner][orderId];\n                (, uint128 sellAmount) = getTradedAmounts(latestSolution.trades[i].volume, order);\n                addBalance(owner, tokenIdToAddressMap(order.sellToken), sellAmount);\n            }\n            for (uint256 i = 0; i < latestSolution.trades.length; i++) {\n                address owner = latestSolution.trades[i].owner;\n                uint16 orderId = latestSolution.trades[i].orderId;\n                Order memory order = orders[owner][orderId];\n                (uint128 buyAmount, uint128 sellAmount) = getTradedAmounts(latestSolution.trades[i].volume, order);\n                revertRemainingOrder(owner, orderId, sellAmount);\n                subtractBalanceUnchecked(owner, tokenIdToAddressMap(order.buyToken), buyAmount);\n                emit TradeReversion(owner, orderId, order.sellToken, order.buyToken, sellAmount, buyAmount);\n            }\n            // subtract granted fees:\n            subtractBalanceUnchecked(latestSolution.solutionSubmitter, tokenIdToAddressMap(0), latestSolution.feeReward);\n        }\n    }\n\n    /** @dev determines if value is better than currently and updates if it is.\n     * @param newObjectiveValue proposed value to be updated if a great enough improvement on the current objective value\n     */\n    function checkAndOverrideObjectiveValue(uint256 newObjectiveValue) private {\n        require(\n            isObjectiveValueSufficientlyImproved(newObjectiveValue),\n            \"New objective doesn't sufficiently improve current solution\"\n        );\n        latestSolution.objectiveValue = newObjectiveValue;\n    }\n\n    // Private view\n    /** @dev Evaluates utility of executed trade\n     * @param execBuy represents proportion of order executed (in terms of buy amount)\n     * @param order the sell order whose utility is being evaluated\n     * @return Utility = ((execBuy * order.sellAmt - execSell * order.buyAmt) * price.buyToken) / order.sellAmt\n     */\n    function evaluateUtility(uint128 execBuy, Order memory order) private view returns (uint256) {\n        // Utility = ((execBuy * order.sellAmt - execSell * order.buyAmt) * price.buyToken) / order.sellAmt\n        uint256 execSellTimesBuy = getExecutedSellAmount(execBuy, currentPrices[order.buyToken], currentPrices[order.sellToken])\n            .mul(order.priceNumerator);\n\n        uint256 roundedUtility = execBuy.sub(execSellTimesBuy.div(order.priceDenominator)).mul(currentPrices[order.buyToken]);\n        uint256 utilityError = execSellTimesBuy.mod(order.priceDenominator).mul(currentPrices[order.buyToken]).div(\n            order.priceDenominator\n        );\n        return roundedUtility.sub(utilityError);\n    }\n\n    /** @dev computes a measure of how much of an order was disregarded (only valid when limit price is respected)\n     * @param order the sell order whose disregarded utility is being evaluated\n     * @param user address of order's owner\n     * @return disregardedUtility of the order (after it has been applied)\n     * Note that:\n     * |disregardedUtility| = (limitTerm * leftoverSellAmount) / order.sellAmount\n     * where limitTerm = price.SellToken * order.sellAmt - order.buyAmt * price.buyToken / (1 - phi)\n     * and leftoverSellAmount = order.sellAmt - execSellAmt\n     * Balances and orders have all been updated so: sellAmount - execSellAmt == remainingAmount(order).\n     * For correctness, we take the minimum of this with the user's token balance.\n     */\n    function evaluateDisregardedUtility(Order memory order, address user) private view returns (uint256) {\n        uint256 leftoverSellAmount = Math.min(getRemainingAmount(order), getBalance(user, tokenIdToAddressMap(order.sellToken)));\n        uint256 limitTermLeft = currentPrices[order.sellToken].mul(order.priceDenominator);\n        uint256 limitTermRight = order.priceNumerator.mul(currentPrices[order.buyToken]).mul(FEE_DENOMINATOR).div(\n            FEE_DENOMINATOR - 1\n        );\n        uint256 limitTerm = 0;\n        if (limitTermLeft > limitTermRight) {\n            limitTerm = limitTermLeft.sub(limitTermRight);\n        }\n        return leftoverSellAmount.mul(limitTerm).div(order.priceDenominator);\n    }\n\n    /** @dev Evaluates executedBuy amount based on prices and executedBuyAmout (fees included)\n     * @param executedBuyAmount amount of buyToken executed for purchase in batch auction\n     * @param buyTokenPrice uniform clearing price of buyToken\n     * @param sellTokenPrice uniform clearing price of sellToken\n     * @return executedSellAmount as expressed in Equation (2)\n     * https://github.com/gnosis/dex-contracts/issues/173#issuecomment-526163117\n     * execSellAmount * p[sellToken] * (1 - phi) == execBuyAmount * p[buyToken]\n     * where phi = 1/FEE_DENOMINATOR\n     * Note that: 1 - phi = (FEE_DENOMINATOR - 1) / FEE_DENOMINATOR\n     * And so, 1/(1-phi) = FEE_DENOMINATOR / (FEE_DENOMINATOR - 1)\n     * execSellAmount = (execBuyAmount * p[buyToken]) / (p[sellToken] * (1 - phi))\n     *                = (execBuyAmount * buyTokenPrice / sellTokenPrice) * FEE_DENOMINATOR / (FEE_DENOMINATOR - 1)\n     * in order to minimize rounding errors, the order of operations is switched\n     *                = ((executedBuyAmount * buyTokenPrice) / (FEE_DENOMINATOR - 1)) * FEE_DENOMINATOR) / sellTokenPrice\n     */\n    function getExecutedSellAmount(uint128 executedBuyAmount, uint128 buyTokenPrice, uint128 sellTokenPrice)\n        private\n        pure\n        returns (uint128)\n    {\n        /* solium-disable indentation */\n        return\n            uint256(executedBuyAmount)\n                .mul(buyTokenPrice)\n                .div(FEE_DENOMINATOR - 1)\n                .mul(FEE_DENOMINATOR)\n                .div(sellTokenPrice)\n                .toUint128();\n        /* solium-enable indentation */\n    }\n\n    /** @dev used to determine if solution if first provided in current batch\n     * @return true if `latestSolution` is storing a solution for current batch, else false\n     */\n    function currentBatchHasSolution() private view returns (bool) {\n        return latestSolution.batchId == getCurrentBatchId() - 1;\n    }\n\n    // Private view\n    /** @dev Compute trade execution based on executedBuyAmount and relevant token prices\n     * @param executedBuyAmount executed buy amount\n     * @param order contains relevant buy-sell token information\n     * @return (executedBuyAmount, executedSellAmount)\n     */\n    function getTradedAmounts(uint128 executedBuyAmount, Order memory order) private view returns (uint128, uint128) {\n        uint128 executedSellAmount = getExecutedSellAmount(\n            executedBuyAmount,\n            currentPrices[order.buyToken],\n            currentPrices[order.sellToken]\n        );\n        return (executedBuyAmount, executedSellAmount);\n    }\n\n    /** @dev Checks that the proposed objective value is a significant enough improvement on the latest one\n     * @param objectiveValue the proposed objective value to check\n     * @return true if the objectiveValue is a significant enough improvement, false otherwise\n     */\n    function isObjectiveValueSufficientlyImproved(uint256 objectiveValue) private view returns (bool) {\n        return (objectiveValue.mul(IMPROVEMENT_DENOMINATOR) > getCurrentObjectiveValue().mul(IMPROVEMENT_DENOMINATOR + 1));\n    }\n\n    // Private pure\n    /** @dev used to determine if an order is valid for specific auction/batch\n     * @param order object whose validity is in question\n     * @param batchId auction index of validity\n     * @return true if order is valid in auction batchId else false\n     */\n    function checkOrderValidity(Order memory order, uint32 batchId) private pure returns (bool) {\n        return order.validFrom <= batchId && order.validUntil >= batchId;\n    }\n\n    /** @dev computes the remaining sell amount for a given order\n     * @param order the order for which remaining amount should be calculated\n     * @return the remaining sell amount\n     */\n    function getRemainingAmount(Order memory order) private pure returns (uint128) {\n        return order.priceDenominator - order.usedAmount;\n    }\n\n    /** @dev called only by getEncodedOrders and used to pack auction info into bytes\n     * @param user list of tokenIds\n     * @param sellTokenBalance user's account balance of sell token\n     * @param order a sell order\n     * @return byte encoded, packed, concatenation of relevant order information\n     */\n    function encodeAuctionElement(address user, uint256 sellTokenBalance, Order memory order)\n        private\n        pure\n        returns (bytes memory element)\n    {\n        element = abi.encodePacked(user);\n        element = element.concat(abi.encodePacked(sellTokenBalance));\n        element = element.concat(abi.encodePacked(order.buyToken));\n        element = element.concat(abi.encodePacked(order.sellToken));\n        element = element.concat(abi.encodePacked(order.validFrom));\n        element = element.concat(abi.encodePacked(order.validUntil));\n        element = element.concat(abi.encodePacked(order.priceNumerator));\n        element = element.concat(abi.encodePacked(order.priceDenominator));\n        element = element.concat(abi.encodePacked(getRemainingAmount(order)));\n        return element;\n    }\n\n    /** @dev determines if value is better than currently and updates if it is.\n     * @param amounts array of values to be verified with AMOUNT_MINIMUM\n     */\n    function verifyAmountThreshold(uint128[] memory amounts) private pure returns (bool) {\n        for (uint256 i = 0; i < amounts.length; i++) {\n            if (amounts[i] < AMOUNT_MINIMUM) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\ncontract BatchExchangeViewer {\n    using BytesLib for bytes;\n    using SafeMath for uint256;\n\n    uint8 public constant AUCTION_ELEMENT_WIDTH = 112;\n    uint16 public constant LARGE_PAGE_SIZE = 5000;\n    // Can be used by external contracts to indicate no filter as it doesn't seem possible\n    // to create an empty memory array in solidity.\n    uint16[] public ALL_TOKEN_FILTER;\n\n    BatchExchange batchExchange;\n\n    constructor(BatchExchange exchange) public {\n        batchExchange = exchange;\n    }\n\n    /** @dev Queries the orderbook for the auction that is still accepting orders\n     *  @param tokenFilter all returned order will have buy *and* sell token from this list (leave empty for \"no filter\")\n     *  @return encoded bytes representing orders, maxed at 5000 elements\n     */\n    function getOpenOrderBook(address[] memory tokenFilter) public view returns (bytes memory) {\n        (bytes memory elements, , , ) = getOpenOrderBookPaginated(tokenFilter, address(0), 0, LARGE_PAGE_SIZE);\n        require(elements.length < LARGE_PAGE_SIZE * AUCTION_ELEMENT_WIDTH, \"Orderbook too large, use paginated view functions\");\n        return elements;\n    }\n\n    /** @dev Queries a page of the orderbook for the auction that is still accepting orders\n     *  @param tokenFilter all returned order will have buy *and* sell token from this list (leave empty for \"no filter\")\n     *  @param previousPageUser address taken from nextPageUser return value from last page (address(0) for first page)\n     *  @param previousPageUserOffset offset taken nextPageUserOffset return value from last page (0 for first page)\n     *  @param maxPageSize count of elements to be returned per page (same value is used for subqueries on the exchange)\n     *  @return encoded bytes representing orders and page information for next page\n     */\n    function getOpenOrderBookPaginated(\n        address[] memory tokenFilter,\n        address previousPageUser,\n        uint16 previousPageUserOffset,\n        uint16 maxPageSize\n    ) public view returns (bytes memory elements, bool hasNextPage, address nextPageUser, uint16 nextPageUserOffset) {\n        uint32 batch = batchExchange.getCurrentBatchId();\n        return\n            getFilteredOrdersPaginated(\n                batch,\n                batch,\n                batch + 1,\n                getTokenIdsFromAdresses(tokenFilter),\n                previousPageUser,\n                previousPageUserOffset,\n                maxPageSize\n            );\n    }\n\n    /** @dev Queries the orderbook for the auction that is currently being solved\n     *  @param tokenFilter all returned order will have buy *and* sell token from this list (leave empty for \"no filter\")\n     *  @return encoded bytes representing orders, maxed at 5000 elements\n     */\n    function getFinalizedOrderBook(address[] memory tokenFilter) public view returns (bytes memory) {\n        (bytes memory elements, , , ) = getFinalizedOrderBookPaginated(tokenFilter, address(0), 0, LARGE_PAGE_SIZE);\n        require(elements.length < LARGE_PAGE_SIZE * AUCTION_ELEMENT_WIDTH, \"Orderbook too large, use paginated view functions\");\n        return elements;\n    }\n\n    /** @dev Queries a page of the orderbook for the auction that is currently being solved\n     *  @param tokenFilter all returned order will have buy *and* sell token from this list (leave empty for \"no filter\")\n     *  @param previousPageUser address taken from nextPageUser return value from last page (address(0) for first page)\n     *  @param previousPageUserOffset offset taken nextPageUserOffset return value from last page (0 for first page)\n     *  @param maxPageSize count of elements to be returned per page (same value is used for subqueries on the exchange)\n     *  @return encoded bytes representing orders and page information for next page\n     */\n    function getFinalizedOrderBookPaginated(\n        address[] memory tokenFilter,\n        address previousPageUser,\n        uint16 previousPageUserOffset,\n        uint16 maxPageSize\n    ) public view returns (bytes memory elements, bool hasNextPage, address nextPageUser, uint16 nextPageUserOffset) {\n        uint32 batch = batchExchange.getCurrentBatchId();\n        return\n            getFilteredOrdersPaginated(\n                batch - 1,\n                batch - 1,\n                batch,\n                getTokenIdsFromAdresses(tokenFilter),\n                previousPageUser,\n                previousPageUserOffset,\n                maxPageSize\n            );\n    }\n\n    /** @dev Queries a page in the list of all orders\n     *  @param maxValidFrom all returned orders will have a validFrom <= this value (they were placed at or before that batch)\n     *  @param minValidUntil all returned orders will have a validUntil >= this value (validity ends at or after that batch)\n     *  @param sellBalanceTargetBatchIndex the batchIndex at which we are expecting the sellTokenBalance to be valid\n        (e.g. in the current live orderbook we want to include sellBalances that are valid in currentBatch + 1).\n     *  @param tokenFilter all returned order will have buy *and* sell token from this list (leave empty for \"no filter\")\n     *  @param previousPageUser address taken from nextPageUser return value from last page (address(0) for first page)\n     *  @param previousPageUserOffset offset taken nextPageUserOffset return value from last page (0 for first page)\n     *  @param maxPageSize maximum count of elements to be returned per page (same value is used for subqueries on the exchange)\n     *  @return encoded bytes representing orders and page information for next page. Result can contain less elements than\n     *  maxPageSize if remaining gas is low.\n     */\n    function getFilteredOrdersPaginated(\n        uint32 maxValidFrom,\n        uint32 minValidUntil,\n        uint32 sellBalanceTargetBatchIndex,\n        uint16[] memory tokenFilter,\n        address previousPageUser,\n        uint16 previousPageUserOffset,\n        uint16 maxPageSize\n    ) public view returns (bytes memory elements, bool hasNextPage, address nextPageUser, uint16 nextPageUserOffset) {\n        nextPageUser = previousPageUser;\n        nextPageUserOffset = previousPageUserOffset;\n        hasNextPage = true;\n        uint256 gasLeftBeforePage = gasleft();\n        // Continue while more pages exist or we used more than 1/2 of remaining gas in previous page\n        while (hasNextPage && 2 * gasleft() > gasLeftBeforePage) {\n            gasLeftBeforePage = gasleft();\n            bytes memory unfiltered = getEncodedOrdersPaginated(nextPageUser, nextPageUserOffset, maxPageSize);\n            hasNextPage = unfiltered.length / AUCTION_ELEMENT_WIDTH == maxPageSize;\n            for (uint16 index = 0; index < unfiltered.length / AUCTION_ELEMENT_WIDTH; index++) {\n                // make sure we don't overflow index * AUCTION_ELEMENT_WIDTH\n                bytes memory element = unfiltered.slice(uint256(index) * AUCTION_ELEMENT_WIDTH, AUCTION_ELEMENT_WIDTH);\n                element = updateSellTokenBalanceForBatchId(element, sellBalanceTargetBatchIndex);\n                if (\n                    maxValidFrom >= getValidFrom(element) &&\n                    minValidUntil <= getValidUntil(element) &&\n                    matchesTokenFilter(getBuyToken(element), getSellToken(element), tokenFilter)\n                ) {\n                    elements = elements.concat(element);\n                }\n                // Update pagination info\n                address user = getUser(element);\n                if (user == nextPageUser) {\n                    nextPageUserOffset += 1;\n                } else {\n                    nextPageUserOffset = 1;\n                    nextPageUser = user;\n                }\n                if (elements.length / AUCTION_ELEMENT_WIDTH >= maxPageSize) {\n                    // We are at capacity, return\n                    return (elements, hasNextPage, nextPageUser, nextPageUserOffset);\n                }\n            }\n        }\n        return (elements, hasNextPage, nextPageUser, nextPageUserOffset);\n    }\n\n    /** @dev View returning byte-encoded sell orders in paginated form. It has the same behavior as\n     * BatchExchange.getEncodedUsersPaginated but uses less memory and thus is more gas efficient.\n     * @param previousPageUser address of last user received in the previous page (address(0) for first page)\n     * @param previousPageUserOffset the number of orders received for the last user on the previous page (0 for first page).\n     * @param pageSize uint determining the count of orders to be returned per page\n     * @return encoded bytes representing a page of orders ordered by (user, index)\n     */\n    function getEncodedOrdersPaginated(address previousPageUser, uint16 previousPageUserOffset, uint256 pageSize)\n        public\n        view\n        returns (bytes memory)\n    {\n        bytes memory elements = new bytes(pageSize * AUCTION_ELEMENT_WIDTH);\n        uint16 currentOffset = previousPageUserOffset;\n        uint256 index = 0;\n        address currentUser = previousPageUser;\n        while (index < pageSize) {\n            bytes memory element = batchExchange.getEncodedUserOrdersPaginated(currentUser, currentOffset, 1);\n            if (element.length > 0) {\n                currentOffset += 1;\n                for (uint256 i = 0; i < element.length; i++) {\n                    elements[(index * AUCTION_ELEMENT_WIDTH) + i] = element[i];\n                }\n                index += 1;\n            } else {\n                currentOffset = 0;\n                bytes memory nextUser = batchExchange.getUsersPaginated(currentUser, 1);\n                if (nextUser.length > 0) {\n                    currentUser = nextUser.toAddress(0);\n                } else {\n                    break;\n                }\n            }\n        }\n        setLength(elements, index * AUCTION_ELEMENT_WIDTH);\n        return elements;\n    }\n\n    function matchesTokenFilter(uint16 buyToken, uint16 sellToken, uint16[] memory filter) public pure returns (bool) {\n        // An empty filter is interpreted as \"select all\"\n        if (filter.length == 0) {\n            return true;\n        }\n        (bool foundBuyToken, bool foundSellToken) = (false, false);\n        for (uint256 index = 0; index < filter.length; index++) {\n            if (filter[index] == buyToken) {\n                foundBuyToken = true;\n            }\n            if (filter[index] == sellToken) {\n                foundSellToken = true;\n            }\n        }\n        return foundBuyToken && foundSellToken;\n    }\n\n    function getUser(bytes memory element) public pure returns (address) {\n        bytes memory slice = element.slice(0, 20);\n        return slice.toAddress(0);\n    }\n\n    function getSellTokenBalance(bytes memory element) public pure returns (uint256) {\n        bytes memory slice = element.slice(20, 52);\n        return slice.toUint(0);\n    }\n\n    function updateSellTokenBalance(bytes memory element, uint256 amount) public pure returns (bytes memory) {\n        return element.slice(0, 20).concat(abi.encodePacked(amount)).concat(element.slice(52, AUCTION_ELEMENT_WIDTH - 52));\n    }\n\n    function getBuyToken(bytes memory element) public pure returns (uint16) {\n        bytes memory slice = element.slice(52, 2);\n        return slice.toUint16(0);\n    }\n\n    function getSellToken(bytes memory element) public pure returns (uint16) {\n        bytes memory slice = element.slice(54, 2);\n        return slice.toUint16(0);\n    }\n\n    function getValidFrom(bytes memory element) public pure returns (uint32) {\n        bytes memory slice = element.slice(56, 4);\n        return slice.toUint32(0);\n    }\n\n    function getValidUntil(bytes memory element) public pure returns (uint32) {\n        bytes memory slice = element.slice(60, 4);\n        return slice.toUint32(0);\n    }\n\n    function getTokenIdsFromAdresses(address[] memory tokenIds) public view returns (uint16[] memory) {\n        uint16[] memory result = new uint16[](tokenIds.length);\n        for (uint256 index = 0; index < tokenIds.length; index++) {\n            result[index] = batchExchange.tokenAddressToIdMap(tokenIds[index]);\n        }\n        return result;\n    }\n\n    function updateSellTokenBalanceForBatchId(bytes memory element, uint32 targetBatchIndex) public view returns (bytes memory) {\n        address user = getUser(element);\n        uint16 sellToken = getSellToken(element);\n        address sellTokenAddress = batchExchange.tokenIdToAddressMap(sellToken);\n        uint256 sellTokenBalance = getSellTokenBalance(element);\n        (uint256 depositAmount, uint32 depositBatch) = batchExchange.getPendingDeposit(user, sellTokenAddress);\n        // The deposit is not valid currently but will be valid at target batch, thus add to balance\n        if (depositBatch >= batchExchange.getCurrentBatchId() && depositBatch < targetBatchIndex) {\n            sellTokenBalance = sellTokenBalance.add(depositAmount);\n        }\n        (uint256 withdrawAmount, uint32 withdrawBatch) = batchExchange.getPendingWithdraw(user, sellTokenAddress);\n        // The withdraw is not valid currently but will be valid at target batch, thus subtract from balance\n        if (withdrawBatch >= batchExchange.getCurrentBatchId() && withdrawBatch < targetBatchIndex) {\n            sellTokenBalance = sellTokenBalance.sub(Math.min(sellTokenBalance, withdrawAmount));\n        }\n        return updateSellTokenBalance(element, sellTokenBalance);\n    }\n\n    /**\n     * @dev Sets the length of the given buffer (truncating any items exceeding the length).\n     * Note, that this can lead to memory leakage or undefined behavior if length  is larger than the size\n     * that was originally allocated by the buffer.\n     */\n    function setLength(bytes memory buffer, uint256 length) public pure {\n        assembly {\n            mstore(buffer, length)\n        }\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"buyToken\",\"type\":\"uint16\"},{\"name\":\"sellToken\",\"type\":\"uint16\"},{\"name\":\"filter\",\"type\":\"uint16[]\"}],\"name\":\"matchesTokenFilter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"maxValidFrom\",\"type\":\"uint32\"},{\"name\":\"minValidUntil\",\"type\":\"uint32\"},{\"name\":\"sellBalanceTargetBatchIndex\",\"type\":\"uint32\"},{\"name\":\"tokenFilter\",\"type\":\"uint16[]\"},{\"name\":\"previousPageUser\",\"type\":\"address\"},{\"name\":\"previousPageUserOffset\",\"type\":\"uint16\"},{\"name\":\"maxPageSize\",\"type\":\"uint16\"}],\"name\":\"getFilteredOrdersPaginated\",\"outputs\":[{\"name\":\"elements\",\"type\":\"bytes\"},{\"name\":\"hasNextPage\",\"type\":\"bool\"},{\"name\":\"nextPageUser\",\"type\":\"address\"},{\"name\":\"nextPageUserOffset\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenFilter\",\"type\":\"address[]\"}],\"name\":\"getFinalizedOrderBook\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenIds\",\"type\":\"address[]\"}],\"name\":\"getTokenIdsFromAdresses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"element\",\"type\":\"bytes\"}],\"name\":\"getSellToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"buffer\",\"type\":\"bytes\"},{\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"setLength\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"element\",\"type\":\"bytes\"}],\"name\":\"getSellTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"element\",\"type\":\"bytes\"}],\"name\":\"getValidUntil\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenFilter\",\"type\":\"address[]\"}],\"name\":\"getOpenOrderBook\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"element\",\"type\":\"bytes\"},{\"name\":\"targetBatchIndex\",\"type\":\"uint32\"}],\"name\":\"updateSellTokenBalanceForBatchId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"element\",\"type\":\"bytes\"}],\"name\":\"getUser\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenFilter\",\"type\":\"address[]\"},{\"name\":\"previousPageUser\",\"type\":\"address\"},{\"name\":\"previousPageUserOffset\",\"type\":\"uint16\"},{\"name\":\"maxPageSize\",\"type\":\"uint16\"}],\"name\":\"getFinalizedOrderBookPaginated\",\"outputs\":[{\"name\":\"elements\",\"type\":\"bytes\"},{\"name\":\"hasNextPage\",\"type\":\"bool\"},{\"name\":\"nextPageUser\",\"type\":\"address\"},{\"name\":\"nextPageUserOffset\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"previousPageUser\",\"type\":\"address\"},{\"name\":\"previousPageUserOffset\",\"type\":\"uint16\"},{\"name\":\"pageSize\",\"type\":\"uint256\"}],\"name\":\"getEncodedOrdersPaginated\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"element\",\"type\":\"bytes\"}],\"name\":\"getBuyToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LARGE_PAGE_SIZE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AUCTION_ELEMENT_WIDTH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ALL_TOKEN_FILTER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenFilter\",\"type\":\"address[]\"},{\"name\":\"previousPageUser\",\"type\":\"address\"},{\"name\":\"previousPageUserOffset\",\"type\":\"uint16\"},{\"name\":\"maxPageSize\",\"type\":\"uint16\"}],\"name\":\"getOpenOrderBookPaginated\",\"outputs\":[{\"name\":\"elements\",\"type\":\"bytes\"},{\"name\":\"hasNextPage\",\"type\":\"bool\"},{\"name\":\"nextPageUser\",\"type\":\"address\"},{\"name\":\"nextPageUserOffset\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"element\",\"type\":\"bytes\"}],\"name\":\"getValidFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"element\",\"type\":\"bytes\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updateSellTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"exchange\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"BatchExchangeViewer","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006f400810b62df8e13fded51be75ff5393eaa841f","Library":"","LicenseType":"","SwarmSource":""}]}