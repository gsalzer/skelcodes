{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: contracts/interfaces/IBridgeValidators.sol\n\npragma solidity 0.4.24;\n\ninterface IBridgeValidators {\n    function isValidator(address _validator) external view returns (bool);\n    function requiredSignatures() external view returns (uint256);\n    function owner() external view returns (address);\n}\n\n// File: contracts/libraries/Message.sol\n\npragma solidity 0.4.24;\n\n\nlibrary Message {\n    // function uintToString(uint256 inputValue) internal pure returns (string) {\n    //     // figure out the length of the resulting string\n    //     uint256 length = 0;\n    //     uint256 currentValue = inputValue;\n    //     do {\n    //         length++;\n    //         currentValue /= 10;\n    //     } while (currentValue != 0);\n    //     // allocate enough memory\n    //     bytes memory result = new bytes(length);\n    //     // construct the string backwards\n    //     uint256 i = length - 1;\n    //     currentValue = inputValue;\n    //     do {\n    //         result[i--] = byte(48 + currentValue % 10);\n    //         currentValue /= 10;\n    //     } while (currentValue != 0);\n    //     return string(result);\n    // }\n\n    function addressArrayContains(address[] array, address value) internal pure returns (bool) {\n        for (uint256 i = 0; i < array.length; i++) {\n            if (array[i] == value) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // layout of message :: bytes:\n    // offset  0: 32 bytes :: uint256 - message length\n    // offset 32: 20 bytes :: address - recipient address\n    // offset 52: 32 bytes :: uint256 - value\n    // offset 84: 32 bytes :: bytes32 - transaction hash\n    // offset 104: 20 bytes :: address - contract address to prevent double spending\n\n    // mload always reads 32 bytes.\n    // so we can and have to start reading recipient at offset 20 instead of 32.\n    // if we were to read at 32 the address would contain part of value and be corrupted.\n    // when reading from offset 20 mload will read 12 bytes (most of them zeros) followed\n    // by the 20 recipient address bytes and correctly convert it into an address.\n    // this saves some storage/gas over the alternative solution\n    // which is padding address to 32 bytes and reading recipient at offset 32.\n    // for more details see discussion in:\n    // https://github.com/paritytech/parity-bridge/issues/61\n    function parseMessage(bytes message)\n        internal\n        pure\n        returns (address recipient, uint256 amount, bytes32 txHash, address contractAddress)\n    {\n        require(isMessageValid(message));\n        assembly {\n            recipient := mload(add(message, 20))\n            amount := mload(add(message, 52))\n            txHash := mload(add(message, 84))\n            contractAddress := mload(add(message, 104))\n        }\n    }\n\n    function isMessageValid(bytes _msg) internal pure returns (bool) {\n        return _msg.length == requiredMessageLength();\n    }\n\n    function requiredMessageLength() internal pure returns (uint256) {\n        return 104;\n    }\n\n    function recoverAddressFromSignedMessage(bytes signature, bytes message, bool isAMBMessage)\n        internal\n        pure\n        returns (address)\n    {\n        require(signature.length == 65);\n        bytes32 r;\n        bytes32 s;\n        bytes1 v;\n\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := mload(add(signature, 0x60))\n        }\n        return ecrecover(hashMessage(message, isAMBMessage), uint8(v), r, s);\n    }\n\n    function hashMessage(bytes message, bool isAMBMessage) internal pure returns (bytes32) {\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n\";\n        if (isAMBMessage) {\n            return keccak256(abi.encodePacked(prefix, uintToString(message.length), message));\n        } else {\n            string memory msgLength = \"104\";\n            return keccak256(abi.encodePacked(prefix, msgLength, message));\n        }\n    }\n\n    function hasEnoughValidSignatures(\n        bytes _message,\n        uint8[] _vs,\n        bytes32[] _rs,\n        bytes32[] _ss,\n        IBridgeValidators _validatorContract,\n        bool isAMBMessage\n    ) internal view {\n        require(isAMBMessage || (!isAMBMessage && isMessageValid(_message)));\n        uint256 requiredSignatures = _validatorContract.requiredSignatures();\n        // It is not necessary to check that arrays have the same length since it will be handled\n        // during attempt to access to the corresponding elements in the loop and the call will be reverted.\n        // It will save gas for the rational validators actions and still be safe enough from security point of view\n        require(_vs.length >= requiredSignatures);\n        bytes32 hash = hashMessage(_message, isAMBMessage);\n        address[] memory encounteredAddresses = new address[](requiredSignatures);\n\n        for (uint256 i = 0; i < requiredSignatures; i++) {\n            address recoveredAddress = ecrecover(hash, _vs[i], _rs[i], _ss[i]);\n            require(_validatorContract.isValidator(recoveredAddress));\n            require(!addressArrayContains(encounteredAddresses, recoveredAddress));\n            encounteredAddresses[i] = recoveredAddress;\n        }\n    }\n\n    function hasEnoughValidSignatures(\n        bytes _message,\n        bytes _signatures,\n        IBridgeValidators _validatorContract,\n        bool isAMBMessage\n    ) internal view {\n        require(isAMBMessage || (!isAMBMessage && isMessageValid(_message)));\n        uint256 requiredSignatures = _validatorContract.requiredSignatures();\n        uint256 amount;\n        assembly {\n            amount := and(mload(add(_signatures, 1)), 0xff)\n        }\n        require(amount >= requiredSignatures);\n        bytes32 hash = hashMessage(_message, isAMBMessage);\n        address[] memory encounteredAddresses = new address[](requiredSignatures);\n\n        for (uint256 i = 0; i < requiredSignatures; i++) {\n            uint8 v;\n            bytes32 r;\n            bytes32 s;\n            uint256 posr = 33 + amount + 32 * i;\n            uint256 poss = posr + 32 * amount;\n            assembly {\n                v := mload(add(_signatures, add(2, i)))\n                r := mload(add(_signatures, posr))\n                s := mload(add(_signatures, poss))\n            }\n\n            address recoveredAddress = ecrecover(hash, v, r, s);\n            require(_validatorContract.isValidator(recoveredAddress));\n            require(!addressArrayContains(encounteredAddresses, recoveredAddress));\n            encounteredAddresses[i] = recoveredAddress;\n        }\n    }\n\n    function uintToString(uint256 i) internal pure returns (string) {\n        if (i == 0) return \"0\";\n        uint256 j = i;\n        uint256 length;\n        while (j != 0) {\n            length++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(length);\n        uint256 k = length - 1;\n        while (i != 0) {\n            bstr[k--] = bytes1(48 + (i % 10));\n            i /= 10;\n        }\n        return string(bstr);\n    }\n}\n\n// File: contracts/libraries/ArbitraryMessage.sol\n\npragma solidity 0.4.24;\n\n\n\nlibrary ArbitraryMessage {\n    // layout of message :: bytes:\n    // offset  0: 32 bytes :: uint256 - message length\n    // offset 32: 32 bytes :: bytes32 txHash\n    // offset 52: 20 bytes :: address - sender address\n    // offset 72: 20 bytes :: address - executor contract\n    // offset 104: 32 bytes :: uint256 - gasLimit\n    // offset 136: 1 bytes :: bytes1 - dataType\n    // (optional) 137: 32 bytes :: uint256 - gasPrice\n    // (optional) 137: 1 bytes :: bytes1 - gasPriceSpeed\n\n    // bytes 1 to 32 are 0 because message length is stored as little endian.\n    // mload always reads 32 bytes.\n    // so we can and have to start reading recipient at offset 20 instead of 32.\n    // if we were to read at 32 the address would contain part of value and be corrupted.\n    // when reading from offset 20 mload will read 12 zero bytes followed\n    // by the 20 recipient address bytes and correctly convert it into an address.\n    // this saves some storage/gas over the alternative solution\n    // which is padding address to 32 bytes and reading recipient at offset 32.\n    // for more details see discussion in:\n    // https://github.com/paritytech/parity-bridge/issues/61\n\n    function unpackData(bytes _data, bool applyDataOffset)\n        internal\n        pure\n        returns (\n            address sender,\n            address executor,\n            bytes32 txHash,\n            uint256 gasLimit,\n            bytes1 dataType,\n            uint256 gasPrice,\n            bytes memory data\n        )\n    {\n        uint256 dataOffset = 0;\n        uint256 datasize;\n        // 32 (tx hash) + 20 (sender)  + 20 (executor) + 32 (gasLimit) + 1 (dataType)\n        uint256 srcdataptr = 32 + 20 + 20 + 32 + 1;\n        assembly {\n            txHash := mload(add(_data, 32))\n            sender := mload(add(_data, 52))\n            executor := mload(add(_data, 72))\n            gasLimit := mload(add(_data, 104))\n            dataType := and(mload(add(_data, 136)), 0xFF00000000000000000000000000000000000000000000000000000000000000)\n            switch dataType\n                case 0x0000000000000000000000000000000000000000000000000000000000000000 {\n                    gasPrice := 0\n                }\n                case 0x0100000000000000000000000000000000000000000000000000000000000000 {\n                    gasPrice := mload(add(_data, 137)) // 32\n                    srcdataptr := add(srcdataptr, 0x20)\n                }\n                case 0x0200000000000000000000000000000000000000000000000000000000000000 {\n                    gasPrice := 0\n                    srcdataptr := add(srcdataptr, 0x01)\n                }\n            datasize := sub(mload(_data), srcdataptr)\n        }\n        data = new bytes(datasize);\n        assembly {\n            // BYTES_HEADER_SIZE\n            let dataptr := add(data, 32)\n            if eq(applyDataOffset, 1) {\n                dataOffset := 32\n            }\n            // 68 = 4 (selector) + 32 (bytes header) + 32 (bytes length)\n            calldatacopy(dataptr, add(add(68, srcdataptr), dataOffset), datasize)\n        }\n    }\n}\n\n// File: contracts/interfaces/IUpgradeabilityOwnerStorage.sol\n\npragma solidity 0.4.24;\n\ninterface IUpgradeabilityOwnerStorage {\n    function upgradeabilityOwner() external view returns (address);\n}\n\n// File: contracts/upgradeable_contracts/Upgradeable.sol\n\npragma solidity 0.4.24;\n\n\ncontract Upgradeable {\n    // Avoid using onlyUpgradeabilityOwner name to prevent issues with implementation from proxy contract\n    modifier onlyIfUpgradeabilityOwner() {\n        require(msg.sender == IUpgradeabilityOwnerStorage(this).upgradeabilityOwner());\n        /* solcov ignore next */\n        _;\n    }\n}\n\n// File: contracts/upgradeability/EternalStorage.sol\n\npragma solidity 0.4.24;\n\n/**\n * @title EternalStorage\n * @dev This contract holds all the necessary state variables to carry out the storage of any contract.\n */\ncontract EternalStorage {\n    mapping(bytes32 => uint256) internal uintStorage;\n    mapping(bytes32 => string) internal stringStorage;\n    mapping(bytes32 => address) internal addressStorage;\n    mapping(bytes32 => bytes) internal bytesStorage;\n    mapping(bytes32 => bool) internal boolStorage;\n    mapping(bytes32 => int256) internal intStorage;\n\n}\n\n// File: contracts/upgradeable_contracts/Initializable.sol\n\npragma solidity 0.4.24;\n\n\ncontract Initializable is EternalStorage {\n    bytes32 internal constant INITIALIZED = 0x0a6f646cd611241d8073675e00d1a1ff700fbf1b53fcf473de56d1e6e4b714ba; // keccak256(abi.encodePacked(\"isInitialized\"))\n\n    function setInitialize() internal {\n        boolStorage[INITIALIZED] = true;\n    }\n\n    function isInitialized() public view returns (bool) {\n        return boolStorage[INITIALIZED];\n    }\n}\n\n// File: contracts/upgradeable_contracts/InitializableBridge.sol\n\npragma solidity 0.4.24;\n\n\ncontract InitializableBridge is Initializable {\n    bytes32 internal constant DEPLOYED_AT_BLOCK = 0xb120ceec05576ad0c710bc6e85f1768535e27554458f05dcbb5c65b8c7a749b0; // keccak256(abi.encodePacked(\"deployedAtBlock\"))\n\n    function deployedAtBlock() external view returns (uint256) {\n        return uintStorage[DEPLOYED_AT_BLOCK];\n    }\n}\n\n// File: openzeppelin-solidity/contracts/AddressUtils.sol\n\npragma solidity ^0.4.24;\n\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary AddressUtils {\n\n  /**\n   * Returns whether the target address is a contract\n   * @dev This function will return false if invoked during the constructor of a contract,\n   * as the code is not actually created until after the constructor finishes.\n   * @param _addr address to check\n   * @return whether the target address is a contract\n   */\n  function isContract(address _addr) internal view returns (bool) {\n    uint256 size;\n    // XXX Currently there is no better way to check if there is a contract in an address\n    // than to check the size of the code at that address.\n    // See https://ethereum.stackexchange.com/a/14016/36603\n    // for more details about how this works.\n    // TODO Check this again before the Serenity release, because all addresses will be\n    // contracts then.\n    // solium-disable-next-line security/no-inline-assembly\n    assembly { size := extcodesize(_addr) }\n    return size > 0;\n  }\n\n}\n\n// File: contracts/upgradeable_contracts/ValidatorStorage.sol\n\npragma solidity 0.4.24;\n\ncontract ValidatorStorage {\n    bytes32 internal constant VALIDATOR_CONTRACT = 0x5a74bb7e202fb8e4bf311841c7d64ec19df195fee77d7e7ae749b27921b6ddfe; // keccak256(abi.encodePacked(\"validatorContract\"))\n}\n\n// File: contracts/upgradeable_contracts/Validatable.sol\n\npragma solidity 0.4.24;\n\n\n\n\ncontract Validatable is EternalStorage, ValidatorStorage {\n    function validatorContract() public view returns (IBridgeValidators) {\n        return IBridgeValidators(addressStorage[VALIDATOR_CONTRACT]);\n    }\n\n    modifier onlyValidator() {\n        require(validatorContract().isValidator(msg.sender));\n        /* solcov ignore next */\n        _;\n    }\n\n    function requiredSignatures() public view returns (uint256) {\n        return validatorContract().requiredSignatures();\n    }\n\n}\n\n// File: contracts/upgradeable_contracts/Ownable.sol\n\npragma solidity 0.4.24;\n\n\n\n/**\n * @title Ownable\n * @dev This contract has an owner address providing basic authorization control\n */\ncontract Ownable is EternalStorage {\n    bytes4 internal constant UPGRADEABILITY_OWNER = 0x6fde8202; // upgradeabilityOwner()\n\n    /**\n    * @dev Event to show ownership has been transferred\n    * @param previousOwner representing the address of the previous owner\n    * @param newOwner representing the address of the new owner\n    */\n    event OwnershipTransferred(address previousOwner, address newOwner);\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(msg.sender == owner());\n        /* solcov ignore next */\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any account other than contract itself or owner.\n    */\n    modifier onlyRelevantSender() {\n        // proxy owner if used through proxy, address(0) otherwise\n        require(\n            !address(this).call(abi.encodeWithSelector(UPGRADEABILITY_OWNER)) || // covers usage without calling through storage proxy\n                msg.sender == IUpgradeabilityOwnerStorage(this).upgradeabilityOwner() || // covers usage through regular proxy calls\n                msg.sender == address(this) // covers calls through upgradeAndCall proxy method\n        );\n        /* solcov ignore next */\n        _;\n    }\n\n    bytes32 internal constant OWNER = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0; // keccak256(abi.encodePacked(\"owner\"))\n\n    /**\n    * @dev Tells the address of the owner\n    * @return the address of the owner\n    */\n    function owner() public view returns (address) {\n        return addressStorage[OWNER];\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param newOwner the address to transfer ownership to.\n    */\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0));\n        setOwner(newOwner);\n    }\n\n    /**\n    * @dev Sets a new owner address\n    */\n    function setOwner(address newOwner) internal {\n        emit OwnershipTransferred(owner(), newOwner);\n        addressStorage[OWNER] = newOwner;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n\npragma solidity ^0.4.24;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address _who) public view returns (uint256);\n  function transfer(address _to, uint256 _value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n\npragma solidity ^0.4.24;\n\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address _owner, address _spender)\n    public view returns (uint256);\n\n  function transferFrom(address _from, address _to, uint256 _value)\n    public returns (bool);\n\n  function approve(address _spender, uint256 _value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: contracts/upgradeable_contracts/Sacrifice.sol\n\npragma solidity 0.4.24;\n\ncontract Sacrifice {\n    constructor(address _recipient) public payable {\n        selfdestruct(_recipient);\n    }\n}\n\n// File: contracts/upgradeable_contracts/Claimable.sol\n\npragma solidity 0.4.24;\n\n\n\ncontract Claimable {\n    bytes4 internal constant TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n\n    modifier validAddress(address _to) {\n        require(_to != address(0));\n        /* solcov ignore next */\n        _;\n    }\n\n    function claimValues(address _token, address _to) internal {\n        if (_token == address(0)) {\n            claimNativeCoins(_to);\n        } else {\n            claimErc20Tokens(_token, _to);\n        }\n    }\n\n    function claimNativeCoins(address _to) internal {\n        uint256 value = address(this).balance;\n        if (!_to.send(value)) {\n            (new Sacrifice).value(value)(_to);\n        }\n    }\n\n    function claimErc20Tokens(address _token, address _to) internal {\n        ERC20Basic token = ERC20Basic(_token);\n        uint256 balance = token.balanceOf(this);\n        safeTransfer(_token, _to, balance);\n    }\n\n    function safeTransfer(address _token, address _to, uint256 _value) internal {\n        bytes memory returnData;\n        bool returnDataResult;\n        bytes memory callData = abi.encodeWithSelector(TRANSFER, _to, _value);\n        assembly {\n            let result := call(gas, _token, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n            returnData := mload(0)\n            returnDataResult := mload(0)\n\n            switch result\n                case 0 {\n                    revert(0, 0)\n                }\n        }\n\n        // Return data is optional\n        if (returnData.length > 0) {\n            require(returnDataResult);\n        }\n    }\n}\n\n// File: contracts/upgradeable_contracts/VersionableBridge.sol\n\npragma solidity 0.4.24;\n\ncontract VersionableBridge {\n    function getBridgeInterfacesVersion() external pure returns (uint64 major, uint64 minor, uint64 patch) {\n        return (2, 5, 0);\n    }\n\n    /* solcov ignore next */\n    function getBridgeMode() external pure returns (bytes4);\n}\n\n// File: contracts/upgradeable_contracts/BasicBridge.sol\n\npragma solidity 0.4.24;\n\n\n\n\n\n\n\n\ncontract BasicBridge is InitializableBridge, Validatable, Ownable, Upgradeable, Claimable, VersionableBridge {\n    event GasPriceChanged(uint256 gasPrice);\n    event RequiredBlockConfirmationChanged(uint256 requiredBlockConfirmations);\n\n    bytes32 internal constant GAS_PRICE = 0x55b3774520b5993024893d303890baa4e84b1244a43c60034d1ced2d3cf2b04b; // keccak256(abi.encodePacked(\"gasPrice\"))\n    bytes32 internal constant REQUIRED_BLOCK_CONFIRMATIONS = 0x916daedf6915000ff68ced2f0b6773fe6f2582237f92c3c95bb4d79407230071; // keccak256(abi.encodePacked(\"requiredBlockConfirmations\"))\n\n    function setGasPrice(uint256 _gasPrice) external onlyOwner {\n        require(_gasPrice > 0);\n        uintStorage[GAS_PRICE] = _gasPrice;\n        emit GasPriceChanged(_gasPrice);\n    }\n\n    function gasPrice() external view returns (uint256) {\n        return uintStorage[GAS_PRICE];\n    }\n\n    function setRequiredBlockConfirmations(uint256 _blockConfirmations) external onlyOwner {\n        require(_blockConfirmations > 0);\n        uintStorage[REQUIRED_BLOCK_CONFIRMATIONS] = _blockConfirmations;\n        emit RequiredBlockConfirmationChanged(_blockConfirmations);\n    }\n\n    function requiredBlockConfirmations() external view returns (uint256) {\n        return uintStorage[REQUIRED_BLOCK_CONFIRMATIONS];\n    }\n\n    function claimTokens(address _token, address _to) public onlyIfUpgradeabilityOwner validAddress(_to) {\n        claimValues(_token, _to);\n    }\n}\n\n// File: contracts/upgradeable_contracts/arbitrary_message/BasicAMB.sol\n\npragma solidity 0.4.24;\n\n\ncontract BasicAMB is BasicBridge {\n    bytes32 internal constant MAX_GAS_PER_TX = 0x2670ecc91ec356e32067fd27b36614132d727b84a1e03e08f412a4f2cf075974; // keccak256(abi.encodePacked(\"maxGasPerTx\"))\n\n    function initialize(\n        address _validatorContract,\n        uint256 _maxGasPerTx,\n        uint256 _gasPrice,\n        uint256 _requiredBlockConfirmations,\n        address _owner\n    ) external onlyRelevantSender returns (bool) {\n        require(!isInitialized());\n        require(_validatorContract != address(0) && AddressUtils.isContract(_validatorContract));\n        require(_gasPrice > 0);\n        require(_requiredBlockConfirmations > 0);\n\n        addressStorage[VALIDATOR_CONTRACT] = _validatorContract;\n        uintStorage[DEPLOYED_AT_BLOCK] = block.number;\n        uintStorage[MAX_GAS_PER_TX] = _maxGasPerTx;\n        uintStorage[GAS_PRICE] = _gasPrice;\n        uintStorage[REQUIRED_BLOCK_CONFIRMATIONS] = _requiredBlockConfirmations;\n        setOwner(_owner);\n        setInitialize();\n\n        emit RequiredBlockConfirmationChanged(_requiredBlockConfirmations);\n        emit GasPriceChanged(_gasPrice);\n\n        return isInitialized();\n    }\n\n    function getBridgeMode() external pure returns (bytes4 _data) {\n        return 0x2544fbb9; // bytes4(keccak256(abi.encodePacked(\"arbitrary-message-bridge-core\")))\n    }\n\n    function maxGasPerTx() public view returns (uint256) {\n        return uintStorage[MAX_GAS_PER_TX];\n    }\n\n    function setMaxGasPerTx(uint256 _maxGasPerTx) external onlyOwner {\n        uintStorage[MAX_GAS_PER_TX] = _maxGasPerTx;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.4.24;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    assert(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    assert(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    assert(c >= _a);\n    return c;\n  }\n}\n\n// File: contracts/upgradeable_contracts/arbitrary_message/MessageDelivery.sol\n\npragma solidity 0.4.24;\n\n\n\ncontract MessageDelivery is BasicAMB {\n    using SafeMath for uint256;\n\n    function requireToPassMessage(address _contract, bytes _data, uint256 _gas) public {\n        require(_gas >= getMinimumGasUsage(_data) && _gas <= maxGasPerTx());\n        emitEventOnMessageRequest(abi.encodePacked(msg.sender, _contract, _gas, uint8(0x00), _data));\n    }\n\n    function getMinimumGasUsage(bytes _data) public pure returns (uint256 gas) {\n        //From Ethereum Yellow Paper\n        // 68 gas is paid for every non-zero byte of data or code for a transaction\n        return _data.length.mul(68);\n    }\n\n    /* solcov ignore next */\n    function emitEventOnMessageRequest(bytes encodedData) internal;\n}\n\n// File: contracts/libraries/Bytes.sol\n\npragma solidity 0.4.24;\n\n/**\n * @title Bytes\n * @dev Helper methods to transform bytes to other solidity types.\n */\nlibrary Bytes {\n    /**\n    * @dev Truncate bytes array if its size is more than 32 bytes\n    * and pads the array with zeros from the right side if its size is less than 32.\n    * @param _bytes to be converted to bytes32 type\n    * @return bytes32 type of the firsts 32 bytes array in parameter.\n    */\n    function bytesToBytes32(bytes _bytes) internal pure returns (bytes32 result) {\n        assembly {\n            result := mload(add(_bytes, 32))\n        }\n    }\n\n    /**\n    * @dev Truncate bytes array if its size is more than 20 bytes\n    * and pads the array with zeros from the right side if its size is less than 20.\n    * @param _bytes to be converted to address type\n    * @return address included in the firsts 20 bytes of the bytes array in parameter.\n    */\n    function bytesToAddress(bytes _bytes) internal pure returns (address addr) {\n        assembly {\n            addr := mload(add(_bytes, 20))\n        }\n    }\n}\n\n// File: contracts/upgradeable_contracts/arbitrary_message/MessageProcessor.sol\n\npragma solidity 0.4.24;\n\n\n\ncontract MessageProcessor is EternalStorage {\n    bytes32 internal constant MESSAGE_SENDER = 0x7b58b2a669d8e0992eae9eaef641092c0f686fd31070e7236865557fa1571b5b; // keccak256(abi.encodePacked(\"messageSender\"))\n    bytes32 internal constant TRANSACTION_HASH = 0x7bce44346b9831b0c81437a092605c6fc51612016e2c51e62f21d829e434bcf6; // keccak256(abi.encodePacked(\"transactionHash\"))\n\n    function messageCallStatus(bytes32 _txHash) external view returns (bool) {\n        return boolStorage[keccak256(abi.encodePacked(\"messageCallStatus\", _txHash))];\n    }\n\n    function setMessageCallStatus(bytes32 _txHash, bool _status) internal {\n        boolStorage[keccak256(abi.encodePacked(\"messageCallStatus\", _txHash))] = _status;\n    }\n\n    function failedMessageDataHash(bytes32 _txHash) external view returns (bytes32) {\n        return Bytes.bytesToBytes32(bytesStorage[keccak256(abi.encodePacked(\"failedMessageDataHash\", _txHash))]);\n    }\n\n    function setFailedMessageDataHash(bytes32 _txHash, bytes data) internal {\n        bytesStorage[keccak256(abi.encodePacked(\"failedMessageDataHash\", _txHash))] = abi.encodePacked(keccak256(data));\n    }\n\n    function failedMessageReceiver(bytes32 _txHash) external view returns (address) {\n        return addressStorage[keccak256(abi.encodePacked(\"failedMessageReceiver\", _txHash))];\n    }\n\n    function setFailedMessageReceiver(bytes32 _txHash, address _receiver) internal {\n        addressStorage[keccak256(abi.encodePacked(\"failedMessageReceiver\", _txHash))] = _receiver;\n    }\n\n    function failedMessageSender(bytes32 _txHash) external view returns (address) {\n        return addressStorage[keccak256(abi.encodePacked(\"failedMessageSender\", _txHash))];\n    }\n\n    function setFailedMessageSender(bytes32 _txHash, address _sender) internal {\n        addressStorage[keccak256(abi.encodePacked(\"failedMessageSender\", _txHash))] = _sender;\n    }\n\n    function messageSender() external view returns (address) {\n        return addressStorage[MESSAGE_SENDER];\n    }\n\n    function setMessageSender(address _sender) internal {\n        addressStorage[MESSAGE_SENDER] = _sender;\n    }\n\n    function transactionHash() external view returns (bytes32) {\n        return Bytes.bytesToBytes32(bytesStorage[TRANSACTION_HASH]);\n    }\n\n    function setTransactionHash(bytes32 _txHash) internal {\n        bytesStorage[TRANSACTION_HASH] = abi.encodePacked(_txHash);\n    }\n\n    function processMessage(\n        address sender,\n        address executor,\n        bytes32 txHash,\n        uint256 gasLimit,\n        bytes1, /* dataType */\n        uint256, /* gasPrice */\n        bytes memory data\n    ) internal {\n        bool status = _passMessage(sender, executor, data, gasLimit, txHash);\n\n        setMessageCallStatus(txHash, status);\n        if (!status) {\n            setFailedMessageDataHash(txHash, data);\n            setFailedMessageReceiver(txHash, executor);\n            setFailedMessageSender(txHash, sender);\n        }\n        emitEventOnMessageProcessed(sender, executor, txHash, status);\n    }\n\n    function _passMessage(address _sender, address _contract, bytes _data, uint256 _gas, bytes32 _txHash)\n        internal\n        returns (bool)\n    {\n        setMessageSender(_sender);\n        setTransactionHash(_txHash);\n        bool status = _contract.call.gas(_gas)(_data);\n        setMessageSender(address(0));\n        setTransactionHash(bytes32(0));\n        return status;\n    }\n\n    /* solcov ignore next */\n    function emitEventOnMessageProcessed(address sender, address executor, bytes32 txHash, bool status) internal;\n}\n\n// File: contracts/upgradeable_contracts/MessageRelay.sol\n\npragma solidity 0.4.24;\n\n\ncontract MessageRelay is EternalStorage {\n    function relayedMessages(bytes32 _txHash) public view returns (bool) {\n        return boolStorage[keccak256(abi.encodePacked(\"relayedMessages\", _txHash))];\n    }\n\n    function setRelayedMessages(bytes32 _txHash, bool _status) internal {\n        boolStorage[keccak256(abi.encodePacked(\"relayedMessages\", _txHash))] = _status;\n    }\n}\n\n// File: contracts/upgradeable_contracts/arbitrary_message/BasicForeignAMB.sol\n\npragma solidity 0.4.24;\n\n\n\n\n\n\n\ncontract BasicForeignAMB is BasicAMB, MessageRelay, MessageDelivery, MessageProcessor {\n    function executeSignatures(bytes _data, bytes _signatures) external {\n        Message.hasEnoughValidSignatures(_data, _signatures, validatorContract(), true);\n\n        address sender;\n        address executor;\n        bytes32 txHash;\n        uint256 gasLimit;\n        bytes1 dataType;\n        uint256 gasPrice;\n        bytes memory data;\n\n        (sender, executor, txHash, gasLimit, dataType, gasPrice, data) = ArbitraryMessage.unpackData(_data, true);\n        require(!relayedMessages(txHash));\n        setRelayedMessages(txHash, true);\n        processMessage(sender, executor, txHash, gasLimit, dataType, gasPrice, data);\n    }\n}\n\n// File: contracts/upgradeable_contracts/arbitrary_message/ForeignAMB.sol\n\npragma solidity 0.4.24;\n\n\ncontract ForeignAMB is BasicForeignAMB {\n    event UserRequestForAffirmation(bytes encodedData);\n    event RelayedMessage(\n        address indexed sender,\n        address indexed executor,\n        bytes32 indexed transactionHash,\n        bool status\n    );\n\n    function emitEventOnMessageRequest(bytes encodedData) internal {\n        emit UserRequestForAffirmation(encodedData);\n    }\n\n    function emitEventOnMessageProcessed(address sender, address executor, bytes32 txHash, bool status) internal {\n        emit RelayedMessage(sender, executor, txHash, status);\n    }\n}\n","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"transactionHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_txHash\",\"type\":\"bytes32\"}],\"name\":\"relayedMessages\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requiredBlockConfirmations\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_signatures\",\"type\":\"bytes\"}],\"name\":\"executeSignatures\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"getMinimumGasUsage\",\"outputs\":[{\"name\":\"gas\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_txHash\",\"type\":\"bytes32\"}],\"name\":\"failedMessageReceiver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBridgeMode\",\"outputs\":[{\"name\":\"_data\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_txHash\",\"type\":\"bytes32\"}],\"name\":\"failedMessageSender\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_validatorContract\",\"type\":\"address\"},{\"name\":\"_maxGasPerTx\",\"type\":\"uint256\"},{\"name\":\"_gasPrice\",\"type\":\"uint256\"},{\"name\":\"_requiredBlockConfirmations\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxGasPerTx\",\"type\":\"uint256\"}],\"name\":\"setMaxGasPerTx\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requiredSignatures\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"validatorContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployedAtBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBridgeInterfacesVersion\",\"outputs\":[{\"name\":\"major\",\"type\":\"uint64\"},{\"name\":\"minor\",\"type\":\"uint64\"},{\"name\":\"patch\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_blockConfirmations\",\"type\":\"uint256\"}],\"name\":\"setRequiredBlockConfirmations\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gasPrice\",\"type\":\"uint256\"}],\"name\":\"setGasPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_txHash\",\"type\":\"bytes32\"}],\"name\":\"messageCallStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"messageSender\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_gas\",\"type\":\"uint256\"}],\"name\":\"requireToPassMessage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_txHash\",\"type\":\"bytes32\"}],\"name\":\"failedMessageDataHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxGasPerTx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"encodedData\",\"type\":\"bytes\"}],\"name\":\"UserRequestForAffirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"RelayedMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gasPrice\",\"type\":\"uint256\"}],\"name\":\"GasPriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requiredBlockConfirmations\",\"type\":\"uint256\"}],\"name\":\"RequiredBlockConfirmationChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ForeignAMB","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://d38e363aff1ba34a834003ae527a0fb7621daf82206e2463e802253b3daa2085"}]}