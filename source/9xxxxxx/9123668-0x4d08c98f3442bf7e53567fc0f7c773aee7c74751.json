{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n* @title Tellor Getters\r\n* @dev Oracle contract with all tellor getter functions. The logic for the functions on this contract\r\n* is saved on the TellorGettersLibrary, TellorTransfer, TellorGettersLibrary, and TellorStake\r\n*/\r\ncontract TellorGetters {\r\n    using SafeMath for uint256;\r\n\r\n    using TellorTransfer for TellorStorage.TellorStorageStruct;\r\n    using TellorGettersLibrary for TellorStorage.TellorStorageStruct;\r\n    using TellorStake for TellorStorage.TellorStorageStruct;\r\n\r\n    TellorStorage.TellorStorageStruct tellor;\r\n\r\n    /**\r\n    * @param _user address\r\n    * @param _spender address\r\n    * @return Returns the remaining allowance of tokens granted to the _spender from the _user\r\n    */\r\n    function allowance(address _user, address _spender) external view returns (uint256) {\r\n        return tellor.allowance(_user, _spender);\r\n    }\r\n\r\n    /**\r\n    * @dev This function returns whether or not a given user is allowed to trade a given amount\r\n    * @param _user address\r\n    * @param _amount uint of amount\r\n    * @return true if the user is alloed to trade the amount specified\r\n    */\r\n    function allowedToTrade(address _user, uint256 _amount) external view returns (bool) {\r\n        return tellor.allowedToTrade(_user, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets balance of owner specified\r\n    * @param _user is the owner address used to look up the balance\r\n    * @return Returns the balance associated with the passed in _user\r\n    */\r\n    function balanceOf(address _user) external view returns (uint256) {\r\n        return tellor.balanceOf(_user);\r\n    }\r\n\r\n    /**\r\n    * @dev Queries the balance of _user at a specific _blockNumber\r\n    * @param _user The address from which the balance will be retrieved\r\n    * @param _blockNumber The block number when the balance is queried\r\n    * @return The balance at _blockNumber\r\n    */\r\n    function balanceOfAt(address _user, uint256 _blockNumber) external view returns (uint256) {\r\n        return tellor.balanceOfAt(_user, _blockNumber);\r\n    }\r\n\r\n    /**\r\n    * @dev This function tells you if a given challenge has been completed by a given miner\r\n    * @param _challenge the challenge to search for\r\n    * @param _miner address that you want to know if they solved the challenge\r\n    * @return true if the _miner address provided solved the\r\n    */\r\n    function didMine(bytes32 _challenge, address _miner) external view returns (bool) {\r\n        return tellor.didMine(_challenge, _miner);\r\n    }\r\n\r\n    /**\r\n    * @dev Checks if an address voted in a given dispute\r\n    * @param _disputeId to look up\r\n    * @param _address to look up\r\n    * @return bool of whether or not party voted\r\n    */\r\n    function didVote(uint256 _disputeId, address _address) external view returns (bool) {\r\n        return tellor.didVote(_disputeId, _address);\r\n    }\r\n\r\n    /**\r\n    * @dev allows Tellor to read data from the addressVars mapping\r\n    * @param _data is the keccak256(\"variable_name\") of the variable that is being accessed.\r\n    * These are examples of how the variables are saved within other functions:\r\n    * addressVars[keccak256(\"_owner\")]\r\n    * addressVars[keccak256(\"tellorContract\")]\r\n    */\r\n    function getAddressVars(bytes32 _data) external view returns (address) {\r\n        return tellor.getAddressVars(_data);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets all dispute variables\r\n    * @param _disputeId to look up\r\n    * @return bytes32 hash of dispute\r\n    * @return bool executed where true if it has been voted on\r\n    * @return bool disputeVotePassed\r\n    * @return bool isPropFork true if the dispute is a proposed fork\r\n    * @return address of reportedMiner\r\n    * @return address of reportingParty\r\n    * @return address of proposedForkAddress\r\n    * @return uint of requestId\r\n    * @return uint of timestamp\r\n    * @return uint of value\r\n    * @return uint of minExecutionDate\r\n    * @return uint of numberOfVotes\r\n    * @return uint of blocknumber\r\n    * @return uint of minerSlot\r\n    * @return uint of quorum\r\n    * @return uint of fee\r\n    * @return int count of the current tally\r\n    */\r\n    function getAllDisputeVars(uint256 _disputeId)\r\n        public\r\n        view\r\n        returns (bytes32, bool, bool, bool, address, address, address, uint256[9] memory, int256)\r\n    {\r\n        return tellor.getAllDisputeVars(_disputeId);\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function for variables for the requestId being currently mined(currentRequestId)\r\n    * @return current challenge, curretnRequestId, level of difficulty, api/query string, and granularity(number of decimals requested), total tip for the request\r\n    */\r\n    function getCurrentVariables() external view returns (bytes32, uint256, uint256, string memory, uint256, uint256) {\r\n        return tellor.getCurrentVariables();\r\n    }\r\n\r\n    /**\r\n    * @dev Checks if a given hash of miner,requestId has been disputed\r\n    * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId));\r\n    * @return uint disputeId\r\n    */\r\n    function getDisputeIdByDisputeHash(bytes32 _hash) external view returns (uint256) {\r\n        return tellor.getDisputeIdByDisputeHash(_hash);\r\n    }\r\n\r\n    /**\r\n    * @dev Checks for uint variables in the disputeUintVars mapping based on the disuputeId\r\n    * @param _disputeId is the dispute id;\r\n    * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\r\n    * the variables/strings used to save the data in the mapping. The variables names are\r\n    * commented out under the disputeUintVars under the Dispute struct\r\n    * @return uint value for the bytes32 data submitted\r\n    */\r\n    function getDisputeUintVars(uint256 _disputeId, bytes32 _data) external view returns (uint256) {\r\n        return tellor.getDisputeUintVars(_disputeId, _data);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the a value for the latest timestamp available\r\n    * @return value for timestamp of last proof of work submited\r\n    * @return true if the is a timestamp for the lastNewValue\r\n    */\r\n    function getLastNewValue() external view returns (uint256, bool) {\r\n        return tellor.getLastNewValue();\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the a value for the latest timestamp available\r\n    * @param _requestId being requested\r\n    * @return value for timestamp of last proof of work submited and if true if it exist or 0 and false if it doesn't\r\n    */\r\n    function getLastNewValueById(uint256 _requestId) external view returns (uint256, bool) {\r\n        return tellor.getLastNewValueById(_requestId);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets blocknumber for mined timestamp\r\n    * @param _requestId to look up\r\n    * @param _timestamp is the timestamp to look up blocknumber\r\n    * @return uint of the blocknumber which the dispute was mined\r\n    */\r\n    function getMinedBlockNum(uint256 _requestId, uint256 _timestamp) external view returns (uint256) {\r\n        return tellor.getMinedBlockNum(_requestId, _timestamp);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\r\n    * @param _requestId to look up\r\n    * @param _timestamp is the timestamp to look up miners for\r\n    * @return the 5 miners' addresses\r\n    */\r\n    function getMinersByRequestIdAndTimestamp(uint256 _requestId, uint256 _timestamp) external view returns (address[5] memory) {\r\n        return tellor.getMinersByRequestIdAndTimestamp(_requestId, _timestamp);\r\n    }\r\n\r\n    /**\r\n    * @dev Get the name of the token\r\n    * return string of the token name\r\n    */\r\n    function getName() external view returns (string memory) {\r\n        return tellor.getName();\r\n    }\r\n\r\n    /**\r\n    * @dev Counts the number of values that have been submited for the request\r\n    * if called for the currentRequest being mined it can tell you how many miners have submitted a value for that\r\n    * request so far\r\n    * @param _requestId the requestId to look up\r\n    * @return uint count of the number of values received for the requestId\r\n    */\r\n    function getNewValueCountbyRequestId(uint256 _requestId) external view returns (uint256) {\r\n        return tellor.getNewValueCountbyRequestId(_requestId);\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function for the specified requestQ index\r\n    * @param _index to look up in the requestQ array\r\n    * @return uint of reqeuestId\r\n    */\r\n    function getRequestIdByRequestQIndex(uint256 _index) external view returns (uint256) {\r\n        return tellor.getRequestIdByRequestQIndex(_index);\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function for requestId based on timestamp\r\n    * @param _timestamp to check requestId\r\n    * @return uint of reqeuestId\r\n    */\r\n    function getRequestIdByTimestamp(uint256 _timestamp) external view returns (uint256) {\r\n        return tellor.getRequestIdByTimestamp(_timestamp);\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function for requestId based on the queryHash\r\n    * @param _request is the hash(of string api and granularity) to check if a request already exists\r\n    * @return uint requestId\r\n    */\r\n    function getRequestIdByQueryHash(bytes32 _request) external view returns (uint256) {\r\n        return tellor.getRequestIdByQueryHash(_request);\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function for the requestQ array\r\n    * @return the requestQ arrray\r\n    */\r\n    function getRequestQ() public view returns (uint256[51] memory) {\r\n        return tellor.getRequestQ();\r\n    }\r\n\r\n    /**\r\n    * @dev Allowes access to the uint variables saved in the apiUintVars under the requestDetails struct\r\n    * for the requestId specified\r\n    * @param _requestId to look up\r\n    * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\r\n    * the variables/strings used to save the data in the mapping. The variables names are\r\n    * commented out under the apiUintVars under the requestDetails struct\r\n    * @return uint value of the apiUintVars specified in _data for the requestId specified\r\n    */\r\n    function getRequestUintVars(uint256 _requestId, bytes32 _data) external view returns (uint256) {\r\n        return tellor.getRequestUintVars(_requestId, _data);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the API struct variables that are not mappings\r\n    * @param _requestId to look up\r\n    * @return string of api to query\r\n    * @return string of symbol of api to query\r\n    * @return bytes32 hash of string\r\n    * @return bytes32 of the granularity(decimal places) requested\r\n    * @return uint of index in requestQ array\r\n    * @return uint of current payout/tip for this requestId\r\n    */\r\n    function getRequestVars(uint256 _requestId) external view returns (string memory, string memory, bytes32, uint256, uint256, uint256) {\r\n        return tellor.getRequestVars(_requestId);\r\n    }\r\n\r\n    /**\r\n    * @dev This function allows users to retireve all information about a staker\r\n    * @param _staker address of staker inquiring about\r\n    * @return uint current state of staker\r\n    * @return uint startDate of staking\r\n    */\r\n    function getStakerInfo(address _staker) external view returns (uint256, uint256) {\r\n        return tellor.getStakerInfo(_staker);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\r\n    * @param _requestId to look up\r\n    * @param _timestamp is the timestampt to look up miners for\r\n    * @return address[5] array of 5 addresses ofminers that mined the requestId\r\n    */\r\n    function getSubmissionsByTimestamp(uint256 _requestId, uint256 _timestamp) external view returns (uint256[5] memory) {\r\n        return tellor.getSubmissionsByTimestamp(_requestId, _timestamp);\r\n    }\r\n\r\n    /**\r\n    * @dev Get the symbol of the token\r\n    * return string of the token symbol\r\n    */\r\n    function getSymbol() external view returns (string memory) {\r\n        return tellor.getSymbol();\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the timestamp for the value based on their index\r\n    * @param _requestID is the requestId to look up\r\n    * @param _index is the value index to look up\r\n    * @return uint timestamp\r\n    */\r\n    function getTimestampbyRequestIDandIndex(uint256 _requestID, uint256 _index) external view returns (uint256) {\r\n        return tellor.getTimestampbyRequestIDandIndex(_requestID, _index);\r\n    }\r\n\r\n    /**\r\n    * @dev Getter for the variables saved under the TellorStorageStruct uintVars variable\r\n    * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\r\n    * the variables/strings used to save the data in the mapping. The variables names are\r\n    * commented out under the uintVars under the TellorStorageStruct struct\r\n    * This is an example of how data is saved into the mapping within other functions:\r\n    * self.uintVars[keccak256(\"stakerCount\")]\r\n    * @return uint of specified variable\r\n    */\r\n    function getUintVar(bytes32 _data) public view returns (uint256) {\r\n        return tellor.getUintVar(_data);\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function for next requestId on queue/request with highest payout at time the function is called\r\n    * @return onDeck/info on request with highest payout-- RequestId, Totaltips, and API query string\r\n    */\r\n    function getVariablesOnDeck() external view returns (uint256, uint256, string memory) {\r\n        return tellor.getVariablesOnDeck();\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\r\n    * @param _requestId to look up\r\n    * @param _timestamp is the timestamp to look up miners for\r\n    * @return bool true if requestId/timestamp is under dispute\r\n    */\r\n    function isInDispute(uint256 _requestId, uint256 _timestamp) external view returns (bool) {\r\n        return tellor.isInDispute(_requestId, _timestamp);\r\n    }\r\n\r\n    /**\r\n    * @dev Retreive value from oracle based on timestamp\r\n    * @param _requestId being requested\r\n    * @param _timestamp to retreive data/value from\r\n    * @return value for timestamp submitted\r\n    */\r\n    function retrieveData(uint256 _requestId, uint256 _timestamp) external view returns (uint256) {\r\n        return tellor.retrieveData(_requestId, _timestamp);\r\n    }\r\n\r\n    /**\r\n    * @dev Getter for the total_supply of oracle tokens\r\n    * @return uint total supply\r\n    */\r\n    function totalSupply() external view returns (uint256) {\r\n        return tellor.totalSupply();\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n* @title Tellor Master\r\n* @dev This is the Master contract with all tellor getter functions and delegate call to Tellor.\r\n* The logic for the functions on this contract is saved on the TellorGettersLibrary, TellorTransfer,\r\n* TellorGettersLibrary, and TellorStake\r\n*/\r\ncontract TellorMaster is TellorGetters {\r\n    event NewTellorAddress(address _newTellor);\r\n\r\n    /**\r\n    * @dev The constructor sets the original `tellorStorageOwner` of the contract to the sender\r\n    * account, the tellor contract to the Tellor master address and owner to the Tellor master owner address\r\n    * @param _tellorContract is the address for the tellor contract\r\n    */\r\n    constructor(address _tellorContract) public {\r\n        tellor.init();\r\n        tellor.addressVars[keccak256(\"_owner\")] = msg.sender;\r\n        tellor.addressVars[keccak256(\"_deity\")] = msg.sender;\r\n        tellor.addressVars[keccak256(\"tellorContract\")] = _tellorContract;\r\n        emit NewTellorAddress(_tellorContract);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\r\n    * @dev Only needs to be in library\r\n    * @param _newDeity the new Deity in the contract\r\n    */\r\n\r\n    function changeDeity(address _newDeity) external {\r\n        tellor.changeDeity(_newDeity);\r\n    }\r\n\r\n    /**\r\n    * @dev  allows for the deity to make fast upgrades.  Deity should be 0 address if decentralized\r\n    * @param _tellorContract the address of the new Tellor Contract\r\n    */\r\n    function changeTellorContract(address _tellorContract) external {\r\n        tellor.changeTellorContract(_tellorContract);\r\n    }\r\n\r\n    /**\r\n    * @dev This is the fallback function that allows contracts to call the tellor contract at the address stored\r\n    */\r\n    function() external payable {\r\n        address addr = tellor.addressVars[keccak256(\"tellorContract\")];\r\n        bytes memory _calldata = msg.data;\r\n        assembly {\r\n            let result := delegatecall(not(0), addr, add(_calldata, 0x20), mload(_calldata), 0, 0)\r\n            let size := returndatasize\r\n            let ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\r\n            // if the call returned error data, forward it\r\n            switch result\r\n                case 0 {\r\n                    revert(ptr, size)\r\n                }\r\n                default {\r\n                    return(ptr, size)\r\n                }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n* @title Tellor Transfer\r\n* @dev Contais the methods related to transfers and ERC20. Tellor.sol and TellorGetters.sol\r\n* reference this library for function's logic.\r\n*/\r\nlibrary TellorTransfer {\r\n    using SafeMath for uint256;\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value); //ERC20 Approval event\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value); //ERC20 Transfer Event\r\n\r\n    /*Functions*/\r\n\r\n    /**\r\n    * @dev Allows for a transfer of tokens to _to\r\n    * @param _to The address to send tokens to\r\n    * @param _amount The amount of tokens to send\r\n    * @return true if transfer is successful\r\n    */\r\n    function transfer(TellorStorage.TellorStorageStruct storage self, address _to, uint256 _amount) public returns (bool success) {\r\n        doTransfer(self, msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Send _amount tokens to _to from _from on the condition it\r\n    * is approved by _from\r\n    * @param _from The address holding the tokens being transferred\r\n    * @param _to The address of the recipient\r\n    * @param _amount The amount of tokens to be transferred\r\n    * @return True if the transfer was successful\r\n    */\r\n    function transferFrom(TellorStorage.TellorStorageStruct storage self, address _from, address _to, uint256 _amount)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(self.allowed[_from][msg.sender] >= _amount, \"Allowance is wrong\");\r\n        self.allowed[_from][msg.sender] -= _amount;\r\n        doTransfer(self, _from, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev This function approves a _spender an _amount of tokens to use\r\n    * @param _spender address\r\n    * @param _amount amount the spender is being approved for\r\n    * @return true if spender appproved successfully\r\n    */\r\n    function approve(TellorStorage.TellorStorageStruct storage self, address _spender, uint256 _amount) public returns (bool) {\r\n        require(_spender != address(0), \"Spender is 0-address\");\r\n        self.allowed[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @param _user address of party with the balance\r\n    * @param _spender address of spender of parties said balance\r\n    * @return Returns the remaining allowance of tokens granted to the _spender from the _user\r\n    */\r\n    function allowance(TellorStorage.TellorStorageStruct storage self, address _user, address _spender) public view returns (uint256) {\r\n        return self.allowed[_user][_spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Completes POWO transfers by updating the balances on the current block number\r\n    * @param _from address to transfer from\r\n    * @param _to addres to transfer to\r\n    * @param _amount to transfer\r\n    */\r\n    function doTransfer(TellorStorage.TellorStorageStruct storage self, address _from, address _to, uint256 _amount) public {\r\n        require(_amount > 0, \"Tried to send non-positive amount\");\r\n        require(_to != address(0), \"Receiver is 0 address\");\r\n        //allowedToTrade checks the stakeAmount is removed from balance if the _user is staked\r\n        require(allowedToTrade(self, _from, _amount), \"Stake amount was not removed from balance\");\r\n        uint256 previousBalance = balanceOfAt(self, _from, block.number);\r\n        updateBalanceAtNow(self.balances[_from], previousBalance - _amount);\r\n        previousBalance = balanceOfAt(self, _to, block.number);\r\n        require(previousBalance + _amount >= previousBalance, \"Overflow happened\"); // Check for overflow\r\n        updateBalanceAtNow(self.balances[_to], previousBalance + _amount);\r\n        emit Transfer(_from, _to, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets balance of owner specified\r\n    * @param _user is the owner address used to look up the balance\r\n    * @return Returns the balance associated with the passed in _user\r\n    */\r\n    function balanceOf(TellorStorage.TellorStorageStruct storage self, address _user) public view returns (uint256) {\r\n        return balanceOfAt(self, _user, block.number);\r\n    }\r\n\r\n    /**\r\n    * @dev Queries the balance of _user at a specific _blockNumber\r\n    * @param _user The address from which the balance will be retrieved\r\n    * @param _blockNumber The block number when the balance is queried\r\n    * @return The balance at _blockNumber specified\r\n    */\r\n    function balanceOfAt(TellorStorage.TellorStorageStruct storage self, address _user, uint256 _blockNumber) public view returns (uint256) {\r\n        if ((self.balances[_user].length == 0) || (self.balances[_user][0].fromBlock > _blockNumber)) {\r\n            return 0;\r\n        } else {\r\n            return getBalanceAt(self.balances[_user], _blockNumber);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Getter for balance for owner on the specified _block number\r\n    * @param checkpoints gets the mapping for the balances[owner]\r\n    * @param _block is the block number to search the balance on\r\n    * @return the balance at the checkpoint\r\n    */\r\n    function getBalanceAt(TellorStorage.Checkpoint[] storage checkpoints, uint256 _block) public view returns (uint256) {\r\n        if (checkpoints.length == 0) return 0;\r\n        if (_block >= checkpoints[checkpoints.length - 1].fromBlock) return checkpoints[checkpoints.length - 1].value;\r\n        if (_block < checkpoints[0].fromBlock) return 0;\r\n        // Binary search of the value in the array\r\n        uint256 min = 0;\r\n        uint256 max = checkpoints.length - 1;\r\n        while (max > min) {\r\n            uint256 mid = (max + min + 1) / 2;\r\n            if (checkpoints[mid].fromBlock <= _block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid - 1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }\r\n\r\n    /**\r\n    * @dev This function returns whether or not a given user is allowed to trade a given amount\r\n    * and removing the staked amount from their balance if they are staked\r\n    * @param _user address of user\r\n    * @param _amount to check if the user can spend\r\n    * @return true if they are allowed to spend the amount being checked\r\n    */\r\n    function allowedToTrade(TellorStorage.TellorStorageStruct storage self, address _user, uint256 _amount) public view returns (bool) {\r\n        if (self.stakerDetails[_user].currentStatus > 0) {\r\n            //Removes the stakeAmount from balance if the _user is staked\r\n            if (balanceOf(self, _user).sub(self.uintVars[keccak256(\"stakeAmount\")]).sub(_amount) >= 0) {\r\n                return true;\r\n            }\r\n        } else if (balanceOf(self, _user).sub(_amount) >= 0) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * @dev Updates balance for from and to on the current block number via doTransfer\r\n    * @param checkpoints gets the mapping for the balances[owner]\r\n    * @param _value is the new balance\r\n    */\r\n    function updateBalanceAtNow(TellorStorage.Checkpoint[] storage checkpoints, uint256 _value) public {\r\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\r\n            TellorStorage.Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\r\n            newCheckPoint.fromBlock = uint128(block.number);\r\n            newCheckPoint.value = uint128(_value);\r\n        } else {\r\n            TellorStorage.Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\r\n            oldCheckPoint.value = uint128(_value);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n//import \"./SafeMath.sol\";\r\n\r\n/**\r\n* @title Tellor Dispute\r\n* @dev Contains the methods related to disputes. Tellor.sol references this library for function's logic.\r\n*/\r\n\r\nlibrary TellorDispute {\r\n    using SafeMath for uint256;\r\n    using SafeMath for int256;\r\n\r\n    //emitted when a new dispute is initialized\r\n    event NewDispute(uint256 indexed _disputeId, uint256 indexed _requestId, uint256 _timestamp, address _miner);\r\n    //emitted when a new vote happens\r\n    event Voted(uint256 indexed _disputeID, bool _position, address indexed _voter);\r\n    //emitted upon dispute tally\r\n    event DisputeVoteTallied(uint256 indexed _disputeID, int256 _result, address indexed _reportedMiner, address _reportingParty, bool _active);\r\n    event NewTellorAddress(address _newTellor); //emmited when a proposed fork is voted true\r\n\r\n    /*Functions*/\r\n\r\n    /**\r\n    * @dev Helps initialize a dispute by assigning it a disputeId\r\n    * when a miner returns a false on the validate array(in Tellor.ProofOfWork) it sends the\r\n    * invalidated value information to POS voting\r\n    * @param _requestId being disputed\r\n    * @param _timestamp being disputed\r\n    * @param _minerIndex the index of the miner that submitted the value being disputed. Since each official value\r\n    * requires 5 miners to submit a value.\r\n    */\r\n    function beginDispute(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _timestamp, uint256 _minerIndex) public {\r\n        TellorStorage.Request storage _request = self.requestDetails[_requestId];\r\n        //require that no more than a day( (24 hours * 60 minutes)/10minutes=144 blocks) has gone by since the value was \"mined\"\r\n        require(now - _timestamp <= 1 days, \"The value was mined more than a day ago\");\r\n        require(_request.minedBlockNum[_timestamp] > 0, \"Mined block is 0\");\r\n        require(_minerIndex < 5, \"Miner index is wrong\");\r\n\r\n        //_miner is the miner being disputed. For every mined value 5 miners are saved in an array and the _minerIndex\r\n        //provided by the party initiating the dispute\r\n        address _miner = _request.minersByValue[_timestamp][_minerIndex];\r\n        bytes32 _hash = keccak256(abi.encodePacked(_miner, _requestId, _timestamp));\r\n\r\n        //Ensures that a dispute is not already open for the that miner, requestId and timestamp\r\n        require(self.disputeIdByDisputeHash[_hash] == 0, \"Dispute is already open\");\r\n        TellorTransfer.doTransfer(self, msg.sender, address(this), self.uintVars[keccak256(\"disputeFee\")]);\r\n\r\n        //Increase the dispute count by 1\r\n        self.uintVars[keccak256(\"disputeCount\")] = self.uintVars[keccak256(\"disputeCount\")] + 1;\r\n\r\n        //Sets the new disputeCount as the disputeId\r\n        uint256 disputeId = self.uintVars[keccak256(\"disputeCount\")];\r\n\r\n        //maps the dispute hash to the disputeId\r\n        self.disputeIdByDisputeHash[_hash] = disputeId;\r\n        //maps the dispute to the Dispute struct\r\n        self.disputesById[disputeId] = TellorStorage.Dispute({\r\n            hash: _hash,\r\n            isPropFork: false,\r\n            reportedMiner: _miner,\r\n            reportingParty: msg.sender,\r\n            proposedForkAddress: address(0),\r\n            executed: false,\r\n            disputeVotePassed: false,\r\n            tally: 0\r\n        });\r\n\r\n        //Saves all the dispute variables for the disputeId\r\n        self.disputesById[disputeId].disputeUintVars[keccak256(\"requestId\")] = _requestId;\r\n        self.disputesById[disputeId].disputeUintVars[keccak256(\"timestamp\")] = _timestamp;\r\n        self.disputesById[disputeId].disputeUintVars[keccak256(\"value\")] = _request.valuesByTimestamp[_timestamp][_minerIndex];\r\n        self.disputesById[disputeId].disputeUintVars[keccak256(\"minExecutionDate\")] = now + 7 days;\r\n        self.disputesById[disputeId].disputeUintVars[keccak256(\"blockNumber\")] = block.number;\r\n        self.disputesById[disputeId].disputeUintVars[keccak256(\"minerSlot\")] = _minerIndex;\r\n        self.disputesById[disputeId].disputeUintVars[keccak256(\"fee\")] = self.uintVars[keccak256(\"disputeFee\")];\r\n\r\n        //Values are sorted as they come in and the official value is the median of the first five\r\n        //So the \"official value\" miner is always minerIndex==2. If the official value is being\r\n        //disputed, it sets its status to inDispute(currentStatus = 3) so that users are made aware it is under dispute\r\n        if (_minerIndex == 2) {\r\n            self.requestDetails[_requestId].inDispute[_timestamp] = true;\r\n        }\r\n        self.stakerDetails[_miner].currentStatus = 3;\r\n        emit NewDispute(disputeId, _requestId, _timestamp, _miner);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows token holders to vote\r\n    * @param _disputeId is the dispute id\r\n    * @param _supportsDispute is the vote (true=the dispute has basis false = vote against dispute)\r\n    */\r\n    function vote(TellorStorage.TellorStorageStruct storage self, uint256 _disputeId, bool _supportsDispute) public {\r\n        TellorStorage.Dispute storage disp = self.disputesById[_disputeId];\r\n\r\n        //Get the voteWeight or the balance of the user at the time/blockNumber the disupte began\r\n        uint256 voteWeight = TellorTransfer.balanceOfAt(self, msg.sender, disp.disputeUintVars[keccak256(\"blockNumber\")]);\r\n\r\n        //Require that the msg.sender has not voted\r\n        require(disp.voted[msg.sender] != true, \"Sender has already voted\");\r\n\r\n        //Requre that the user had a balance >0 at time/blockNumber the disupte began\r\n        require(voteWeight > 0, \"User balance is 0\");\r\n\r\n        //ensures miners that are under dispute cannot vote\r\n        require(self.stakerDetails[msg.sender].currentStatus != 3, \"Miner is under dispute\");\r\n\r\n        //Update user voting status to true\r\n        disp.voted[msg.sender] = true;\r\n\r\n        //Update the number of votes for the dispute\r\n        disp.disputeUintVars[keccak256(\"numberOfVotes\")] += 1;\r\n\r\n        //Update the quorum by adding the voteWeight\r\n        disp.disputeUintVars[keccak256(\"quorum\")] += voteWeight;\r\n\r\n        //If the user supports the dispute increase the tally for the dispute by the voteWeight\r\n        //otherwise decrease it\r\n        if (_supportsDispute) {\r\n            disp.tally = disp.tally.add(int256(voteWeight));\r\n        } else {\r\n            disp.tally = disp.tally.sub(int256(voteWeight));\r\n        }\r\n\r\n        //Let the network know the user has voted on the dispute and their casted vote\r\n        emit Voted(_disputeId, _supportsDispute, msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev tallies the votes.\r\n    * @param _disputeId is the dispute id\r\n    */\r\n    function tallyVotes(TellorStorage.TellorStorageStruct storage self, uint256 _disputeId) public {\r\n        TellorStorage.Dispute storage disp = self.disputesById[_disputeId];\r\n        TellorStorage.Request storage _request = self.requestDetails[disp.disputeUintVars[keccak256(\"requestId\")]];\r\n\r\n        //Ensure this has not already been executed/tallied\r\n        require(disp.executed == false, \"Dispute has been already executed\");\r\n\r\n        //Ensure the time for voting has elapsed\r\n        require(now > disp.disputeUintVars[keccak256(\"minExecutionDate\")], \"Time for voting haven't elapsed\");\r\n\r\n        //If the vote is not a proposed fork\r\n        if (disp.isPropFork == false) {\r\n            TellorStorage.StakeInfo storage stakes = self.stakerDetails[disp.reportedMiner];\r\n            //If the vote for disputing a value is succesful(disp.tally >0) then unstake the reported\r\n            // miner and transfer the stakeAmount and dispute fee to the reporting party\r\n            if (disp.tally > 0) {\r\n\r\n                //if reported miner stake has not been slashed yet, slash them and return the fee to reporting party\r\n                if (stakes.currentStatus == 3) {\r\n                    //Changing the currentStatus and startDate unstakes the reported miner and allows for the\r\n                    //transfer of the stakeAmount\r\n                    stakes.currentStatus = 0;\r\n                    stakes.startDate = now - (now % 86400);\r\n     \r\n                    //Decreases the stakerCount since the miner's stake is being slashed\r\n                    self.uintVars[keccak256(\"stakerCount\")]--;\r\n                    updateDisputeFee(self);\r\n     \r\n                    //Transfers the StakeAmount from the reporded miner to the reporting party\r\n                    TellorTransfer.doTransfer(self, disp.reportedMiner, disp.reportingParty, self.uintVars[keccak256(\"stakeAmount\")]);\r\n     \r\n                    //Returns the dispute fee to the reportingParty\r\n                    TellorTransfer.doTransfer(self, address(this), disp.reportingParty, disp.disputeUintVars[keccak256(\"fee\")]);\r\n                    \r\n                //if reported miner stake was already slashed, return the fee to other reporting paties\r\n                } else{\r\n                    TellorTransfer.doTransfer(self, address(this), disp.reportingParty, disp.disputeUintVars[keccak256(\"fee\")]);\r\n                }\r\n\r\n                //Set the dispute state to passed/true\r\n                disp.disputeVotePassed = true;\r\n\r\n\r\n                //If the dispute was succeful(miner found guilty) then update the timestamp value to zero\r\n                //so that users don't use this datapoint\r\n                if (_request.inDispute[disp.disputeUintVars[keccak256(\"timestamp\")]] == true) {\r\n                    _request.finalValues[disp.disputeUintVars[keccak256(\"timestamp\")]] = 0;\r\n                }\r\n                //If the vote for disputing a value is unsuccesful then update the miner status from being on\r\n                //dispute(currentStatus=3) to staked(currentStatus =1) and tranfer the dispute fee to the miner\r\n            } else {\r\n                //Update the miner's current status to staked(currentStatus = 1)\r\n                stakes.currentStatus = 1;\r\n                //tranfer the dispute fee to the miner\r\n                TellorTransfer.doTransfer(self, address(this), disp.reportedMiner, disp.disputeUintVars[keccak256(\"fee\")]);\r\n                if (_request.inDispute[disp.disputeUintVars[keccak256(\"timestamp\")]] == true) {\r\n                    _request.inDispute[disp.disputeUintVars[keccak256(\"timestamp\")]] = false;\r\n                }\r\n            }\r\n            //If the vote is for a proposed fork require a 20% quorum before executing the update to the new tellor contract address\r\n        } else {\r\n            if (disp.tally > 0) {\r\n                require(\r\n                    disp.disputeUintVars[keccak256(\"quorum\")] > ((self.uintVars[keccak256(\"total_supply\")] * 20) / 100),\r\n                    \"Quorum is not reached\"\r\n                );\r\n                self.addressVars[keccak256(\"tellorContract\")] = disp.proposedForkAddress;\r\n                disp.disputeVotePassed = true;\r\n                emit NewTellorAddress(disp.proposedForkAddress);\r\n            }\r\n        }\r\n\r\n        //update the dispute status to executed\r\n        disp.executed = true;\r\n        emit DisputeVoteTallied(_disputeId, disp.tally, disp.reportedMiner, disp.reportingParty, disp.disputeVotePassed);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows for a fork to be proposed\r\n    * @param _propNewTellorAddress address for new proposed Tellor\r\n    */\r\n    function proposeFork(TellorStorage.TellorStorageStruct storage self, address _propNewTellorAddress) public {\r\n        bytes32 _hash = keccak256(abi.encodePacked(_propNewTellorAddress));\r\n        require(self.disputeIdByDisputeHash[_hash] == 0, \"\");\r\n        TellorTransfer.doTransfer(self, msg.sender, address(this), self.uintVars[keccak256(\"disputeFee\")]); //This is the fork fee\r\n        self.uintVars[keccak256(\"disputeCount\")]++;\r\n        uint256 disputeId = self.uintVars[keccak256(\"disputeCount\")];\r\n        self.disputeIdByDisputeHash[_hash] = disputeId;\r\n        self.disputesById[disputeId] = TellorStorage.Dispute({\r\n            hash: _hash,\r\n            isPropFork: true,\r\n            reportedMiner: msg.sender,\r\n            reportingParty: msg.sender,\r\n            proposedForkAddress: _propNewTellorAddress,\r\n            executed: false,\r\n            disputeVotePassed: false,\r\n            tally: 0\r\n        });\r\n        self.disputesById[disputeId].disputeUintVars[keccak256(\"blockNumber\")] = block.number;\r\n        self.disputesById[disputeId].disputeUintVars[keccak256(\"fee\")] = self.uintVars[keccak256(\"disputeFee\")];\r\n        self.disputesById[disputeId].disputeUintVars[keccak256(\"minExecutionDate\")] = now + 7 days;\r\n    }\r\n\r\n    /**\r\n    * @dev this function allows the dispute fee to fluctuate based on the number of miners on the system.\r\n    * The floor for the fee is 15e18.\r\n    */\r\n    function updateDisputeFee(TellorStorage.TellorStorageStruct storage self) public {\r\n        //if the number of staked miners divided by the target count of staked miners is less than 1\r\n        if ((self.uintVars[keccak256(\"stakerCount\")] * 1000) / self.uintVars[keccak256(\"targetMiners\")] < 1000) {\r\n            //Set the dispute fee at stakeAmt * (1- stakerCount/targetMiners)\r\n            //or at the its minimum of 15e18\r\n            self.uintVars[keccak256(\"disputeFee\")] = SafeMath.max(\r\n                15e18,\r\n                self.uintVars[keccak256(\"stakeAmount\")].mul(\r\n                    1000 - (self.uintVars[keccak256(\"stakerCount\")] * 1000) / self.uintVars[keccak256(\"targetMiners\")]\r\n                ) /\r\n                    1000\r\n            );\r\n        } else {\r\n            //otherwise set the dispute fee at 15e18 (the floor/minimum fee allowed)\r\n            self.uintVars[keccak256(\"disputeFee\")] = 15e18;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n* itle Tellor Dispute\r\n* @dev Contais the methods related to miners staking and unstaking. Tellor.sol\r\n* references this library for function's logic.\r\n*/\r\n\r\nlibrary TellorStake {\r\n    event NewStake(address indexed _sender); //Emits upon new staker\r\n    event StakeWithdrawn(address indexed _sender); //Emits when a staker is now no longer staked\r\n    event StakeWithdrawRequested(address indexed _sender); //Emits when a staker begins the 7 day withdraw period\r\n\r\n    /*Functions*/\r\n\r\n    /**\r\n    * @dev This function stakes the five initial miners, sets the supply and all the constant variables.\r\n    * This function is called by the constructor function on TellorMaster.sol\r\n    */\r\n    function init(TellorStorage.TellorStorageStruct storage self) public {\r\n        require(self.uintVars[keccak256(\"decimals\")] == 0, \"Too many decimals\");\r\n        //Give this contract 6000 Tellor Tributes so that it can stake the initial 6 miners\r\n        TellorTransfer.updateBalanceAtNow(self.balances[address(this)], 2**256 - 1 - 6000e18);\r\n\r\n        // //the initial 5 miner addresses are specfied below\r\n        // //changed payable[5] to 6\r\n        address payable[6] memory _initalMiners = [\r\n            address(0xE037EC8EC9ec423826750853899394dE7F024fee),\r\n            address(0xcdd8FA31AF8475574B8909F135d510579a8087d3),\r\n            address(0xb9dD5AfD86547Df817DA2d0Fb89334A6F8eDd891),\r\n            address(0x230570cD052f40E14C14a81038c6f3aa685d712B),\r\n            address(0x3233afA02644CCd048587F8ba6e99b3C00A34DcC),\r\n            address(0xe010aC6e0248790e08F42d5F697160DEDf97E024)\r\n        ];\r\n        //Stake each of the 5 miners specified above\r\n        for (uint256 i = 0; i < 6; i++) {\r\n            //6th miner to allow for dispute\r\n            //Miner balance is set at 1000e18 at the block that this function is ran\r\n            TellorTransfer.updateBalanceAtNow(self.balances[_initalMiners[i]], 1000e18);\r\n\r\n            newStake(self, _initalMiners[i]);\r\n        }\r\n\r\n        //update the total suppply\r\n        self.uintVars[keccak256(\"total_supply\")] += 6000e18; //6th miner to allow for dispute\r\n        //set Constants\r\n        self.uintVars[keccak256(\"decimals\")] = 18;\r\n        self.uintVars[keccak256(\"targetMiners\")] = 200;\r\n        self.uintVars[keccak256(\"stakeAmount\")] = 1000e18;\r\n        self.uintVars[keccak256(\"disputeFee\")] = 970e18;\r\n        self.uintVars[keccak256(\"timeTarget\")] = 600;\r\n        self.uintVars[keccak256(\"timeOfLastNewValue\")] = now - (now % self.uintVars[keccak256(\"timeTarget\")]);\r\n        self.uintVars[keccak256(\"difficulty\")] = 1;\r\n    }\r\n\r\n    /**\r\n    * @dev This function allows stakers to request to withdraw their stake (no longer stake)\r\n    * once they lock for withdraw(stakes.currentStatus = 2) they are locked for 7 days before they\r\n    * can withdraw the deposit\r\n    */\r\n    function requestStakingWithdraw(TellorStorage.TellorStorageStruct storage self) public {\r\n        TellorStorage.StakeInfo storage stakes = self.stakerDetails[msg.sender];\r\n        //Require that the miner is staked\r\n        require(stakes.currentStatus == 1, \"Miner is not staked\");\r\n\r\n        //Change the miner staked to locked to be withdrawStake\r\n        stakes.currentStatus = 2;\r\n\r\n        //Change the startDate to now since the lock up period begins now\r\n        //and the miner can only withdraw 7 days later from now(check the withdraw function)\r\n        stakes.startDate = now - (now % 86400);\r\n\r\n        //Reduce the staker count\r\n        self.uintVars[keccak256(\"stakerCount\")] -= 1;\r\n        TellorDispute.updateDisputeFee(self);\r\n        emit StakeWithdrawRequested(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev This function allows users to withdraw their stake after a 7 day waiting period from request\r\n    */\r\n    function withdrawStake(TellorStorage.TellorStorageStruct storage self) public {\r\n        TellorStorage.StakeInfo storage stakes = self.stakerDetails[msg.sender];\r\n        //Require the staker has locked for withdraw(currentStatus ==2) and that 7 days have\r\n        //passed by since they locked for withdraw\r\n        require(now - (now % 86400) - stakes.startDate >= 7 days, \"7 days didn't pass\");\r\n        require(stakes.currentStatus == 2, \"Miner was not locked for withdrawal\");\r\n        stakes.currentStatus = 0;\r\n        emit StakeWithdrawn(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev This function allows miners to deposit their stake.\r\n    */\r\n    function depositStake(TellorStorage.TellorStorageStruct storage self) public {\r\n        newStake(self, msg.sender);\r\n        //self adjusting disputeFee\r\n        TellorDispute.updateDisputeFee(self);\r\n    }\r\n\r\n    /**\r\n    * @dev This function is used by the init function to succesfully stake the initial 5 miners.\r\n    * The function updates their status/state and status start date so they are locked it so they can't withdraw\r\n    * and updates the number of stakers in the system.\r\n    */\r\n    function newStake(TellorStorage.TellorStorageStruct storage self, address staker) internal {\r\n        require(TellorTransfer.balanceOf(self, staker) >= self.uintVars[keccak256(\"stakeAmount\")], \"Balance is lower than stake amount\");\r\n        //Ensure they can only stake if they are not currrently staked or if their stake time frame has ended\r\n        //and they are currently locked for witdhraw\r\n        require(self.stakerDetails[staker].currentStatus == 0 || self.stakerDetails[staker].currentStatus == 2, \"Miner is in the wrong state\");\r\n        self.uintVars[keccak256(\"stakerCount\")] += 1;\r\n        self.stakerDetails[staker] = TellorStorage.StakeInfo({\r\n            currentStatus: 1, //this resets their stake start date to today\r\n            startDate: now - (now % 86400)\r\n        });\r\n        emit NewStake(staker);\r\n    }\r\n}\r\n\r\n\r\n//Slightly modified SafeMath library - includes a min and max function, removes useless div function\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function add(int256 a, int256 b) internal pure returns (int256 c) {\r\n        if (b > 0) {\r\n            c = a + b;\r\n            assert(c >= a);\r\n        } else {\r\n            c = a + b;\r\n            assert(c <= a);\r\n        }\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    function max(int256 a, int256 b) internal pure returns (uint256) {\r\n        return a > b ? uint256(a) : uint256(b);\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function sub(int256 a, int256 b) internal pure returns (int256 c) {\r\n        if (b > 0) {\r\n            c = a - b;\r\n            assert(c <= a);\r\n        } else {\r\n            c = a - b;\r\n            assert(c >= a);\r\n        }\r\n\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Tellor Oracle Storage Library\r\n * @dev Contains all the variables/structs used by Tellor\r\n */\r\n\r\nlibrary TellorStorage {\r\n    //Internal struct for use in proof-of-work submission\r\n    struct Details {\r\n        uint256 value;\r\n        address miner;\r\n    }\r\n\r\n    struct Dispute {\r\n        bytes32 hash; //unique hash of dispute: keccak256(_miner,_requestId,_timestamp)\r\n        int256 tally; //current tally of votes for - against measure\r\n        bool executed; //is the dispute settled\r\n        bool disputeVotePassed; //did the vote pass?\r\n        bool isPropFork; //true for fork proposal NEW\r\n        address reportedMiner; //miner who alledgedly submitted the 'bad value' will get disputeFee if dispute vote fails\r\n        address reportingParty; //miner reporting the 'bad value'-pay disputeFee will get reportedMiner's stake if dispute vote passes\r\n        address proposedForkAddress; //new fork address (if fork proposal)\r\n        mapping(bytes32 => uint256) disputeUintVars;\r\n        //Each of the variables below is saved in the mapping disputeUintVars for each disputeID\r\n        //e.g. TellorStorageStruct.DisputeById[disputeID].disputeUintVars[keccak256(\"requestId\")]\r\n        //These are the variables saved in this mapping:\r\n        // uint keccak256(\"requestId\");//apiID of disputed value\r\n        // uint keccak256(\"timestamp\");//timestamp of distputed value\r\n        // uint keccak256(\"value\"); //the value being disputed\r\n        // uint keccak256(\"minExecutionDate\");//7 days from when dispute initialized\r\n        // uint keccak256(\"numberOfVotes\");//the number of parties who have voted on the measure\r\n        // uint keccak256(\"blockNumber\");// the blocknumber for which votes will be calculated from\r\n        // uint keccak256(\"minerSlot\"); //index in dispute array\r\n        // uint keccak256(\"quorum\"); //quorum for dispute vote NEW\r\n        // uint keccak256(\"fee\"); //fee paid corresponding to dispute\r\n        mapping(address => bool) voted; //mapping of address to whether or not they voted\r\n    }\r\n\r\n    struct StakeInfo {\r\n        uint256 currentStatus; //0-not Staked, 1=Staked, 2=LockedForWithdraw 3= OnDispute\r\n        uint256 startDate; //stake start date\r\n    }\r\n\r\n    //Internal struct to allow balances to be queried by blocknumber for voting purposes\r\n    struct Checkpoint {\r\n        uint128 fromBlock; // fromBlock is the block number that the value was generated from\r\n        uint128 value; // value is the amount of tokens at a specific block number\r\n    }\r\n\r\n    struct Request {\r\n        string queryString; //id to string api\r\n        string dataSymbol; //short name for api request\r\n        bytes32 queryHash; //hash of api string and granularity e.g. keccak256(abi.encodePacked(_sapi,_granularity))\r\n        uint256[] requestTimestamps; //array of all newValueTimestamps requested\r\n        mapping(bytes32 => uint256) apiUintVars;\r\n        //Each of the variables below is saved in the mapping apiUintVars for each api request\r\n        //e.g. requestDetails[_requestId].apiUintVars[keccak256(\"totalTip\")]\r\n        //These are the variables saved in this mapping:\r\n        // uint keccak256(\"granularity\"); //multiplier for miners\r\n        // uint keccak256(\"requestQPosition\"); //index in requestQ\r\n        // uint keccak256(\"totalTip\");//bonus portion of payout\r\n        mapping(uint256 => uint256) minedBlockNum; //[apiId][minedTimestamp]=>block.number\r\n        //This the time series of finalValues stored by the contract where uint UNIX timestamp is mapped to value\r\n        mapping(uint256 => uint256) finalValues;\r\n        mapping(uint256 => bool) inDispute; //checks if API id is in dispute or finalized.\r\n        mapping(uint256 => address[5]) minersByValue;\r\n        mapping(uint256 => uint256[5]) valuesByTimestamp;\r\n    }\r\n\r\n    struct TellorStorageStruct {\r\n        bytes32 currentChallenge; //current challenge to be solved\r\n        uint256[51] requestQ; //uint50 array of the top50 requests by payment amount\r\n        uint256[] newValueTimestamps; //array of all timestamps requested\r\n        Details[5] currentMiners; //This struct is for organizing the five mined values to find the median\r\n        mapping(bytes32 => address) addressVars;\r\n        //Address fields in the Tellor contract are saved the addressVars mapping\r\n        //e.g. addressVars[keccak256(\"tellorContract\")] = address\r\n        //These are the variables saved in this mapping:\r\n        // address keccak256(\"tellorContract\");//Tellor address\r\n        // address  keccak256(\"_owner\");//Tellor Owner address\r\n        // address  keccak256(\"_deity\");//Tellor Owner that can do things at will\r\n        mapping(bytes32 => uint256) uintVars;\r\n        //uint fields in the Tellor contract are saved the uintVars mapping\r\n        //e.g. uintVars[keccak256(\"decimals\")] = uint\r\n        //These are the variables saved in this mapping:\r\n        // keccak256(\"decimals\");    //18 decimal standard ERC20\r\n        // keccak256(\"disputeFee\");//cost to dispute a mined value\r\n        // keccak256(\"disputeCount\");//totalHistoricalDisputes\r\n        // keccak256(\"total_supply\"); //total_supply of the token in circulation\r\n        // keccak256(\"stakeAmount\");//stakeAmount for miners (we can cut gas if we just hardcode it in...or should it be variable?)\r\n        // keccak256(\"stakerCount\"); //number of parties currently staked\r\n        // keccak256(\"timeOfLastNewValue\"); // time of last challenge solved\r\n        // keccak256(\"difficulty\"); // Difficulty of current block\r\n        // keccak256(\"currentTotalTips\"); //value of highest api/timestamp PayoutPool\r\n        // keccak256(\"currentRequestId\"); //API being mined--updates with the ApiOnQ Id\r\n        // keccak256(\"requestCount\"); // total number of requests through the system\r\n        // keccak256(\"slotProgress\");//Number of miners who have mined this value so far\r\n        // keccak256(\"miningReward\");//Mining Reward in PoWo tokens given to all miners per value\r\n        // keccak256(\"timeTarget\"); //The time between blocks (mined Oracle values)\r\n        //This is a boolean that tells you if a given challenge has been completed by a given miner\r\n        mapping(bytes32 => mapping(address => bool)) minersByChallenge;\r\n        mapping(uint256 => uint256) requestIdByTimestamp; //minedTimestamp to apiId\r\n        mapping(uint256 => uint256) requestIdByRequestQIndex; //link from payoutPoolIndex (position in payout pool array) to apiId\r\n        mapping(uint256 => Dispute) disputesById; //disputeId=> Dispute details\r\n        mapping(address => Checkpoint[]) balances; //balances of a party given blocks\r\n        mapping(address => mapping(address => uint256)) allowed; //allowance for a given party and approver\r\n        mapping(address => StakeInfo) stakerDetails; //mapping from a persons address to their staking info\r\n        mapping(uint256 => Request) requestDetails; //mapping of apiID to details\r\n        mapping(bytes32 => uint256) requestIdByQueryHash; // api bytes32 gets an id = to count of requests array\r\n        mapping(bytes32 => uint256) disputeIdByDisputeHash; //maps a hash to an ID for each dispute\r\n    }\r\n}\r\n\r\n\r\n\r\n//Functions for retrieving min and Max in 51 length array (requestQ)\r\n//Taken partly from: https://github.com/modular-network/ethereum-libraries-array-utils/blob/master/contracts/Array256Lib.sol\r\n\r\nlibrary Utilities {\r\n    /**\r\n    * @dev Returns the minimum value in an array.\r\n    */\r\n    function getMax(uint256[51] memory data) internal pure returns (uint256 max, uint256 maxIndex) {\r\n        max = data[1];\r\n        maxIndex;\r\n        for (uint256 i = 1; i < data.length; i++) {\r\n            if (data[i] > max) {\r\n                max = data[i];\r\n                maxIndex = i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the minimum value in an array.\r\n    */\r\n    function getMin(uint256[51] memory data) internal pure returns (uint256 min, uint256 minIndex) {\r\n        minIndex = data.length - 1;\r\n        min = data[minIndex];\r\n        for (uint256 i = data.length - 1; i > 0; i--) {\r\n            if (data[i] < min) {\r\n                min = data[i];\r\n                minIndex = i;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n* @title Tellor Getters Library\r\n* @dev This is the getter library for all variables in the Tellor Tributes system. TellorGetters references this\r\n* libary for the getters logic\r\n*/\r\nlibrary TellorGettersLibrary {\r\n    using SafeMath for uint256;\r\n\r\n    event NewTellorAddress(address _newTellor); //emmited when a proposed fork is voted true\r\n\r\n    /*Functions*/\r\n\r\n    //The next two functions are onlyOwner functions.  For Tellor to be truly decentralized, we will need to transfer the Deity to the 0 address.\r\n    //Only needs to be in library\r\n    /**\r\n    * @dev This function allows us to set a new Deity (or remove it)\r\n    * @param _newDeity address of the new Deity of the tellor system\r\n    */\r\n    function changeDeity(TellorStorage.TellorStorageStruct storage self, address _newDeity) internal {\r\n        require(self.addressVars[keccak256(\"_deity\")] == msg.sender, \"Sender is not deity\");\r\n        self.addressVars[keccak256(\"_deity\")] = _newDeity;\r\n    }\r\n\r\n    //Only needs to be in library\r\n    /**\r\n    * @dev This function allows the deity to upgrade the Tellor System\r\n    * @param _tellorContract address of new updated TellorCore contract\r\n    */\r\n    function changeTellorContract(TellorStorage.TellorStorageStruct storage self, address _tellorContract) internal {\r\n        require(self.addressVars[keccak256(\"_deity\")] == msg.sender, \"Sender is not deity\");\r\n        self.addressVars[keccak256(\"tellorContract\")] = _tellorContract;\r\n        emit NewTellorAddress(_tellorContract);\r\n    }\r\n\r\n    /*Tellor Getters*/\r\n\r\n    /**\r\n    * @dev This function tells you if a given challenge has been completed by a given miner\r\n    * @param _challenge the challenge to search for\r\n    * @param _miner address that you want to know if they solved the challenge\r\n    * @return true if the _miner address provided solved the\r\n    */\r\n    function didMine(TellorStorage.TellorStorageStruct storage self, bytes32 _challenge, address _miner) internal view returns (bool) {\r\n        return self.minersByChallenge[_challenge][_miner];\r\n    }\r\n\r\n    /**\r\n    * @dev Checks if an address voted in a dispute\r\n    * @param _disputeId to look up\r\n    * @param _address of voting party to look up\r\n    * @return bool of whether or not party voted\r\n    */\r\n    function didVote(TellorStorage.TellorStorageStruct storage self, uint256 _disputeId, address _address) internal view returns (bool) {\r\n        return self.disputesById[_disputeId].voted[_address];\r\n    }\r\n\r\n    /**\r\n    * @dev allows Tellor to read data from the addressVars mapping\r\n    * @param _data is the keccak256(\"variable_name\") of the variable that is being accessed.\r\n    * These are examples of how the variables are saved within other functions:\r\n    * addressVars[keccak256(\"_owner\")]\r\n    * addressVars[keccak256(\"tellorContract\")]\r\n    */\r\n    function getAddressVars(TellorStorage.TellorStorageStruct storage self, bytes32 _data) internal view returns (address) {\r\n        return self.addressVars[_data];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets all dispute variables\r\n    * @param _disputeId to look up\r\n    * @return bytes32 hash of dispute\r\n    * @return bool executed where true if it has been voted on\r\n    * @return bool disputeVotePassed\r\n    * @return bool isPropFork true if the dispute is a proposed fork\r\n    * @return address of reportedMiner\r\n    * @return address of reportingParty\r\n    * @return address of proposedForkAddress\r\n    * @return uint of requestId\r\n    * @return uint of timestamp\r\n    * @return uint of value\r\n    * @return uint of minExecutionDate\r\n    * @return uint of numberOfVotes\r\n    * @return uint of blocknumber\r\n    * @return uint of minerSlot\r\n    * @return uint of quorum\r\n    * @return uint of fee\r\n    * @return int count of the current tally\r\n    */\r\n    function getAllDisputeVars(TellorStorage.TellorStorageStruct storage self, uint256 _disputeId)\r\n        internal\r\n        view\r\n        returns (bytes32, bool, bool, bool, address, address, address, uint256[9] memory, int256)\r\n    {\r\n        TellorStorage.Dispute storage disp = self.disputesById[_disputeId];\r\n        return (\r\n            disp.hash,\r\n            disp.executed,\r\n            disp.disputeVotePassed,\r\n            disp.isPropFork,\r\n            disp.reportedMiner,\r\n            disp.reportingParty,\r\n            disp.proposedForkAddress,\r\n            [\r\n                disp.disputeUintVars[keccak256(\"requestId\")],\r\n                disp.disputeUintVars[keccak256(\"timestamp\")],\r\n                disp.disputeUintVars[keccak256(\"value\")],\r\n                disp.disputeUintVars[keccak256(\"minExecutionDate\")],\r\n                disp.disputeUintVars[keccak256(\"numberOfVotes\")],\r\n                disp.disputeUintVars[keccak256(\"blockNumber\")],\r\n                disp.disputeUintVars[keccak256(\"minerSlot\")],\r\n                disp.disputeUintVars[keccak256(\"quorum\")],\r\n                disp.disputeUintVars[keccak256(\"fee\")]\r\n            ],\r\n            disp.tally\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function for variables for the requestId being currently mined(currentRequestId)\r\n    * @return current challenge, curretnRequestId, level of difficulty, api/query string, and granularity(number of decimals requested), total tip for the request\r\n    */\r\n    function getCurrentVariables(TellorStorage.TellorStorageStruct storage self)\r\n        internal\r\n        view\r\n        returns (bytes32, uint256, uint256, string memory, uint256, uint256)\r\n    {\r\n        return (\r\n            self.currentChallenge,\r\n            self.uintVars[keccak256(\"currentRequestId\")],\r\n            self.uintVars[keccak256(\"difficulty\")],\r\n            self.requestDetails[self.uintVars[keccak256(\"currentRequestId\")]].queryString,\r\n            self.requestDetails[self.uintVars[keccak256(\"currentRequestId\")]].apiUintVars[keccak256(\"granularity\")],\r\n            self.requestDetails[self.uintVars[keccak256(\"currentRequestId\")]].apiUintVars[keccak256(\"totalTip\")]\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Checks if a given hash of miner,requestId has been disputed\r\n    * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId));\r\n    * @return uint disputeId\r\n    */\r\n    function getDisputeIdByDisputeHash(TellorStorage.TellorStorageStruct storage self, bytes32 _hash) internal view returns (uint256) {\r\n        return self.disputeIdByDisputeHash[_hash];\r\n    }\r\n\r\n    /**\r\n    * @dev Checks for uint variables in the disputeUintVars mapping based on the disuputeId\r\n    * @param _disputeId is the dispute id;\r\n    * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\r\n    * the variables/strings used to save the data in the mapping. The variables names are\r\n    * commented out under the disputeUintVars under the Dispute struct\r\n    * @return uint value for the bytes32 data submitted\r\n    */\r\n    function getDisputeUintVars(TellorStorage.TellorStorageStruct storage self, uint256 _disputeId, bytes32 _data)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return self.disputesById[_disputeId].disputeUintVars[_data];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the a value for the latest timestamp available\r\n    * @return value for timestamp of last proof of work submited\r\n    * @return true if the is a timestamp for the lastNewValue\r\n    */\r\n    function getLastNewValue(TellorStorage.TellorStorageStruct storage self) internal view returns (uint256, bool) {\r\n        return (\r\n            retrieveData(\r\n                self,\r\n                self.requestIdByTimestamp[self.uintVars[keccak256(\"timeOfLastNewValue\")]],\r\n                self.uintVars[keccak256(\"timeOfLastNewValue\")]\r\n            ),\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the a value for the latest timestamp available\r\n    * @param _requestId being requested\r\n    * @return value for timestamp of last proof of work submited and if true if it exist or 0 and false if it doesn't\r\n    */\r\n    function getLastNewValueById(TellorStorage.TellorStorageStruct storage self, uint256 _requestId) internal view returns (uint256, bool) {\r\n        TellorStorage.Request storage _request = self.requestDetails[_requestId];\r\n        if (_request.requestTimestamps.length > 0) {\r\n            return (retrieveData(self, _requestId, _request.requestTimestamps[_request.requestTimestamps.length - 1]), true);\r\n        } else {\r\n            return (0, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Gets blocknumber for mined timestamp\r\n    * @param _requestId to look up\r\n    * @param _timestamp is the timestamp to look up blocknumber\r\n    * @return uint of the blocknumber which the dispute was mined\r\n    */\r\n    function getMinedBlockNum(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _timestamp)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return self.requestDetails[_requestId].minedBlockNum[_timestamp];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\r\n    * @param _requestId to look up\r\n    * @param _timestamp is the timestamp to look up miners for\r\n    * @return the 5 miners' addresses\r\n    */\r\n    function getMinersByRequestIdAndTimestamp(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _timestamp)\r\n        internal\r\n        view\r\n        returns (address[5] memory)\r\n    {\r\n        return self.requestDetails[_requestId].minersByValue[_timestamp];\r\n    }\r\n\r\n    /**\r\n    * @dev Get the name of the token\r\n    * @return string of the token name\r\n    */\r\n    function getName(TellorStorage.TellorStorageStruct storage self) internal pure returns (string memory) {\r\n        return \"Tellor Tributes\";\r\n    }\r\n\r\n    /**\r\n    * @dev Counts the number of values that have been submited for the request\r\n    * if called for the currentRequest being mined it can tell you how many miners have submitted a value for that\r\n    * request so far\r\n    * @param _requestId the requestId to look up\r\n    * @return uint count of the number of values received for the requestId\r\n    */\r\n    function getNewValueCountbyRequestId(TellorStorage.TellorStorageStruct storage self, uint256 _requestId) internal view returns (uint256) {\r\n        return self.requestDetails[_requestId].requestTimestamps.length;\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function for the specified requestQ index\r\n    * @param _index to look up in the requestQ array\r\n    * @return uint of reqeuestId\r\n    */\r\n    function getRequestIdByRequestQIndex(TellorStorage.TellorStorageStruct storage self, uint256 _index) internal view returns (uint256) {\r\n        require(_index <= 50, \"RequestQ index is above 50\");\r\n        return self.requestIdByRequestQIndex[_index];\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function for requestId based on timestamp\r\n    * @param _timestamp to check requestId\r\n    * @return uint of reqeuestId\r\n    */\r\n    function getRequestIdByTimestamp(TellorStorage.TellorStorageStruct storage self, uint256 _timestamp) internal view returns (uint256) {\r\n        return self.requestIdByTimestamp[_timestamp];\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function for requestId based on the qeuaryHash\r\n    * @param _queryHash hash(of string api and granularity) to check if a request already exists\r\n    * @return uint requestId\r\n    */\r\n    function getRequestIdByQueryHash(TellorStorage.TellorStorageStruct storage self, bytes32 _queryHash) internal view returns (uint256) {\r\n        return self.requestIdByQueryHash[_queryHash];\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function for the requestQ array\r\n    * @return the requestQ arrray\r\n    */\r\n    function getRequestQ(TellorStorage.TellorStorageStruct storage self) internal view returns (uint256[51] memory) {\r\n        return self.requestQ;\r\n    }\r\n\r\n    /**\r\n    * @dev Allowes access to the uint variables saved in the apiUintVars under the requestDetails struct\r\n    * for the requestId specified\r\n    * @param _requestId to look up\r\n    * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\r\n    * the variables/strings used to save the data in the mapping. The variables names are\r\n    * commented out under the apiUintVars under the requestDetails struct\r\n    * @return uint value of the apiUintVars specified in _data for the requestId specified\r\n    */\r\n    function getRequestUintVars(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, bytes32 _data)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return self.requestDetails[_requestId].apiUintVars[_data];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the API struct variables that are not mappings\r\n    * @param _requestId to look up\r\n    * @return string of api to query\r\n    * @return string of symbol of api to query\r\n    * @return bytes32 hash of string\r\n    * @return bytes32 of the granularity(decimal places) requested\r\n    * @return uint of index in requestQ array\r\n    * @return uint of current payout/tip for this requestId\r\n    */\r\n    function getRequestVars(TellorStorage.TellorStorageStruct storage self, uint256 _requestId)\r\n        internal\r\n        view\r\n        returns (string memory, string memory, bytes32, uint256, uint256, uint256)\r\n    {\r\n        TellorStorage.Request storage _request = self.requestDetails[_requestId];\r\n        return (\r\n            _request.queryString,\r\n            _request.dataSymbol,\r\n            _request.queryHash,\r\n            _request.apiUintVars[keccak256(\"granularity\")],\r\n            _request.apiUintVars[keccak256(\"requestQPosition\")],\r\n            _request.apiUintVars[keccak256(\"totalTip\")]\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev This function allows users to retireve all information about a staker\r\n    * @param _staker address of staker inquiring about\r\n    * @return uint current state of staker\r\n    * @return uint startDate of staking\r\n    */\r\n    function getStakerInfo(TellorStorage.TellorStorageStruct storage self, address _staker) internal view returns (uint256, uint256) {\r\n        return (self.stakerDetails[_staker].currentStatus, self.stakerDetails[_staker].startDate);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\r\n    * @param _requestId to look up\r\n    * @param _timestamp is the timestampt to look up miners for\r\n    * @return address[5] array of 5 addresses ofminers that mined the requestId\r\n    */\r\n    function getSubmissionsByTimestamp(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _timestamp)\r\n        internal\r\n        view\r\n        returns (uint256[5] memory)\r\n    {\r\n        return self.requestDetails[_requestId].valuesByTimestamp[_timestamp];\r\n    }\r\n\r\n    /**\r\n    * @dev Get the symbol of the token\r\n    * @return string of the token symbol\r\n    */\r\n    function getSymbol(TellorStorage.TellorStorageStruct storage self) internal pure returns (string memory) {\r\n        return \"TT\";\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the timestamp for the value based on their index\r\n    * @param _requestID is the requestId to look up\r\n    * @param _index is the value index to look up\r\n    * @return uint timestamp\r\n    */\r\n    function getTimestampbyRequestIDandIndex(TellorStorage.TellorStorageStruct storage self, uint256 _requestID, uint256 _index)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return self.requestDetails[_requestID].requestTimestamps[_index];\r\n    }\r\n\r\n    /**\r\n    * @dev Getter for the variables saved under the TellorStorageStruct uintVars variable\r\n    * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\r\n    * the variables/strings used to save the data in the mapping. The variables names are\r\n    * commented out under the uintVars under the TellorStorageStruct struct\r\n    * This is an example of how data is saved into the mapping within other functions:\r\n    * self.uintVars[keccak256(\"stakerCount\")]\r\n    * @return uint of specified variable\r\n    */\r\n    function getUintVar(TellorStorage.TellorStorageStruct storage self, bytes32 _data) internal view returns (uint256) {\r\n        return self.uintVars[_data];\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function for next requestId on queue/request with highest payout at time the function is called\r\n    * @return onDeck/info on request with highest payout-- RequestId, Totaltips, and API query string\r\n    */\r\n    function getVariablesOnDeck(TellorStorage.TellorStorageStruct storage self) internal view returns (uint256, uint256, string memory) {\r\n        uint256 newRequestId = getTopRequestID(self);\r\n        return (\r\n            newRequestId,\r\n            self.requestDetails[newRequestId].apiUintVars[keccak256(\"totalTip\")],\r\n            self.requestDetails[newRequestId].queryString\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function for the request with highest payout. This function is used within the getVariablesOnDeck function\r\n    * @return uint _requestId of request with highest payout at the time the function is called\r\n    */\r\n    function getTopRequestID(TellorStorage.TellorStorageStruct storage self) internal view returns (uint256 _requestId) {\r\n        uint256 _max;\r\n        uint256 _index;\r\n        (_max, _index) = Utilities.getMax(self.requestQ);\r\n        _requestId = self.requestIdByRequestQIndex[_index];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\r\n    * @param _requestId to look up\r\n    * @param _timestamp is the timestamp to look up miners for\r\n    * @return bool true if requestId/timestamp is under dispute\r\n    */\r\n    function isInDispute(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _timestamp) internal view returns (bool) {\r\n        return self.requestDetails[_requestId].inDispute[_timestamp];\r\n    }\r\n\r\n    /**\r\n    * @dev Retreive value from oracle based on requestId/timestamp\r\n    * @param _requestId being requested\r\n    * @param _timestamp to retreive data/value from\r\n    * @return uint value for requestId/timestamp submitted\r\n    */\r\n    function retrieveData(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _timestamp)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return self.requestDetails[_requestId].finalValues[_timestamp];\r\n    }\r\n\r\n    /**\r\n    * @dev Getter for the total_supply of oracle tokens\r\n    * @return uint total supply\r\n    */\r\n    function totalSupply(TellorStorage.TellorStorageStruct storage self) internal view returns (uint256) {\r\n        return self.uintVars[keccak256(\"total_supply\")];\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Tellor Oracle System Library\r\n * @dev Contains the functions' logic for the Tellor contract where miners can submit the proof of work\r\n * along with the value and smart contracts can requestData and tip miners.\r\n */\r\nlibrary TellorLibrary {\r\n    using SafeMath for uint256;\r\n\r\n    event TipAdded(address indexed _sender, uint256 indexed _requestId, uint256 _tip, uint256 _totalTips);\r\n    //Emits upon someone adding value to a pool; msg.sender, amount added, and timestamp incentivized to be mined\r\n    event DataRequested(\r\n        address indexed _sender,\r\n        string _query,\r\n        string _querySymbol,\r\n        uint256 _granularity,\r\n        uint256 indexed _requestId,\r\n        uint256 _totalTips\r\n    );\r\n    //emits when a new challenge is created (either on mined block or when a new request is pushed forward on waiting system)\r\n    event NewChallenge(\r\n        bytes32 _currentChallenge,\r\n        uint256 indexed _currentRequestId,\r\n        uint256 _difficulty,\r\n        uint256 _multiplier,\r\n        string _query,\r\n        uint256 _totalTips\r\n    );\r\n    //emits when a the payout of another request is higher after adding to the payoutPool or submitting a request\r\n    event NewRequestOnDeck(uint256 indexed _requestId, string _query, bytes32 _onDeckQueryHash, uint256 _onDeckTotalTips);\r\n    //Emits upon a successful Mine, indicates the blocktime at point of the mine and the value mined\r\n    event NewValue(uint256 indexed _requestId, uint256 _time, uint256 _value, uint256 _totalTips, bytes32 _currentChallenge);\r\n    //Emits upon each mine (5 total) and shows the miner, nonce, and value submitted\r\n    event NonceSubmitted(address indexed _miner, string _nonce, uint256 indexed _requestId, uint256 _value, bytes32 _currentChallenge);\r\n    event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\r\n    event OwnershipProposed(address indexed _previousOwner, address indexed _newOwner);\r\n\r\n    /*Functions*/\r\n\r\n    /*This is a cheat for demo purposes, will delete upon actual launch*/\r\n/*    function theLazyCoon(TellorStorage.TellorStorageStruct storage self,address _address, uint _amount) public {\r\n        self.uintVars[keccak256(\"total_supply\")] += _amount;\r\n        TellorTransfer.updateBalanceAtNow(self.balances[_address],_amount);\r\n    } */\r\n\r\n    /**\r\n    * @dev Add tip to Request value from oracle\r\n    * @param _requestId being requested to be mined\r\n    * @param _tip amount the requester is willing to pay to be get on queue. Miners\r\n    * mine the onDeckQueryHash, or the api with the highest payout pool\r\n    */\r\n    function addTip(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _tip) public {\r\n        require(_requestId > 0, \"RequestId is 0\");\r\n\r\n        //If the tip > 0 transfer the tip to this contract\r\n        if (_tip > 0) {\r\n            TellorTransfer.doTransfer(self, msg.sender, address(this), _tip);\r\n        }\r\n\r\n        //Update the information for the request that should be mined next based on the tip submitted\r\n        updateOnDeck(self, _requestId, _tip);\r\n        emit TipAdded(msg.sender, _requestId, _tip, self.requestDetails[_requestId].apiUintVars[keccak256(\"totalTip\")]);\r\n    }\r\n\r\n    /**\r\n    * @dev Request to retreive value from oracle based on timestamp. The tip is not required to be\r\n    * greater than 0 because there are no tokens in circulation for the initial(genesis) request\r\n    * @param _c_sapi string API being requested be mined\r\n    * @param _c_symbol is the short string symbol for the api request\r\n    * @param _granularity is the number of decimals miners should include on the submitted value\r\n    * @param _tip amount the requester is willing to pay to be get on queue. Miners\r\n    * mine the onDeckQueryHash, or the api with the highest payout pool\r\n    */\r\n    function requestData(\r\n        TellorStorage.TellorStorageStruct storage self,\r\n        string memory _c_sapi,\r\n        string memory _c_symbol,\r\n        uint256 _granularity,\r\n        uint256 _tip\r\n    ) public {\r\n        //Require at least one decimal place\r\n        require(_granularity > 0, \"Too few decimal places\");\r\n\r\n        //But no more than 18 decimal places\r\n        require(_granularity <= 1e18, \"Too many decimal places\");\r\n\r\n        //If it has been requested before then add the tip to it otherwise create the queryHash for it\r\n        string memory _sapi = _c_sapi;\r\n        string memory _symbol = _c_symbol;\r\n        require(bytes(_sapi).length > 0, \"API string length is 0\");\r\n        require(bytes(_symbol).length < 64, \"API string symbol is greater than 64\");\r\n        bytes32 _queryHash = keccak256(abi.encodePacked(_sapi, _granularity));\r\n\r\n        //If this is the first time the API and granularity combination has been requested then create the API and granularity hash\r\n        //otherwise the tip will be added to the requestId submitted\r\n        if (self.requestIdByQueryHash[_queryHash] == 0) {\r\n            self.uintVars[keccak256(\"requestCount\")]++;\r\n            uint256 _requestId = self.uintVars[keccak256(\"requestCount\")];\r\n            self.requestDetails[_requestId] = TellorStorage.Request({\r\n                queryString: _sapi,\r\n                dataSymbol: _symbol,\r\n                queryHash: _queryHash,\r\n                requestTimestamps: new uint256[](0)\r\n            });\r\n            self.requestDetails[_requestId].apiUintVars[keccak256(\"granularity\")] = _granularity;\r\n            self.requestDetails[_requestId].apiUintVars[keccak256(\"requestQPosition\")] = 0;\r\n            self.requestDetails[_requestId].apiUintVars[keccak256(\"totalTip\")] = 0;\r\n            self.requestIdByQueryHash[_queryHash] = _requestId;\r\n\r\n            //If the tip > 0 it tranfers the tip to this contract\r\n            if (_tip > 0) {\r\n                TellorTransfer.doTransfer(self, msg.sender, address(this), _tip);\r\n            }\r\n            updateOnDeck(self, _requestId, _tip);\r\n            emit DataRequested(\r\n                msg.sender,\r\n                self.requestDetails[_requestId].queryString,\r\n                self.requestDetails[_requestId].dataSymbol,\r\n                _granularity,\r\n                _requestId,\r\n                _tip\r\n            );\r\n            //Add tip to existing request id since this is not the first time the api and granularity have been requested\r\n        } else {\r\n            addTip(self, self.requestIdByQueryHash[_queryHash], _tip);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev This fucntion is called by submitMiningSolution and adjusts the difficulty, sorts and stores the first\r\n    * 5 values received, pays the miners, the dev share and assigns a new challenge\r\n    * @param _nonce or solution for the PoW  for the requestId\r\n    * @param _requestId for the current request being mined\r\n    */\r\n    function newBlock(TellorStorage.TellorStorageStruct storage self, string memory _nonce, uint256 _requestId) internal {\r\n        TellorStorage.Request storage _request = self.requestDetails[_requestId];\r\n\r\n        // If the difference between the timeTarget and how long it takes to solve the challenge this updates the challenge\r\n        //difficulty up or donw by the difference between the target time and how long it took to solve the prevous challenge\r\n        //otherwise it sets it to 1\r\n        int256 _change = int256(SafeMath.min(1200, (now - self.uintVars[keccak256(\"timeOfLastNewValue\")])));\r\n        _change = (int256(self.uintVars[keccak256(\"difficulty\")]) * (int256(self.uintVars[keccak256(\"timeTarget\")]) - _change)) / 4000;\r\n\r\n        if (_change < 2 && _change > -2) {\r\n            if (_change >= 0) {\r\n                _change = 1;\r\n            } else {\r\n                _change = -1;\r\n            }\r\n        }\r\n\r\n        if ((int256(self.uintVars[keccak256(\"difficulty\")]) + _change) <= 0) {\r\n            self.uintVars[keccak256(\"difficulty\")] = 1;\r\n        } else {\r\n            self.uintVars[keccak256(\"difficulty\")] = uint256(int256(self.uintVars[keccak256(\"difficulty\")]) + _change);\r\n        }\r\n\r\n        //Sets time of value submission rounded to 1 minute\r\n        uint256 _timeOfLastNewValue = now - (now % 1 minutes);\r\n        self.uintVars[keccak256(\"timeOfLastNewValue\")] = _timeOfLastNewValue;\r\n\r\n        //The sorting algorithm that sorts the values of the first five values that come in\r\n        TellorStorage.Details[5] memory a = self.currentMiners;\r\n        uint256 i;\r\n        for (i = 1; i < 5; i++) {\r\n            uint256 temp = a[i].value;\r\n            address temp2 = a[i].miner;\r\n            uint256 j = i;\r\n            while (j > 0 && temp < a[j - 1].value) {\r\n                a[j].value = a[j - 1].value;\r\n                a[j].miner = a[j - 1].miner;\r\n                j--;\r\n            }\r\n            if (j < i) {\r\n                a[j].value = temp;\r\n                a[j].miner = temp2;\r\n            }\r\n        }\r\n\r\n        //Pay the miners\r\n        for (i = 0; i < 5; i++) {\r\n            TellorTransfer.doTransfer(self, address(this), a[i].miner, 5e18 + self.uintVars[keccak256(\"currentTotalTips\")] / 5);\r\n        }\r\n        emit NewValue(\r\n            _requestId,\r\n            _timeOfLastNewValue,\r\n            a[2].value,\r\n            self.uintVars[keccak256(\"currentTotalTips\")] - (self.uintVars[keccak256(\"currentTotalTips\")] % 5),\r\n            self.currentChallenge\r\n        );\r\n\r\n        //update the total supply\r\n        self.uintVars[keccak256(\"total_supply\")] += 275e17;\r\n\r\n        //pay the dev-share\r\n        TellorTransfer.doTransfer(self, address(this), self.addressVars[keccak256(\"_owner\")], 25e17); //The ten there is the devshare\r\n        //Save the official(finalValue), timestamp of it, 5 miners and their submitted values for it, and its block number\r\n        _request.finalValues[_timeOfLastNewValue] = a[2].value;\r\n        _request.requestTimestamps.push(_timeOfLastNewValue);\r\n        //these are miners by timestamp\r\n        _request.minersByValue[_timeOfLastNewValue] = [a[0].miner, a[1].miner, a[2].miner, a[3].miner, a[4].miner];\r\n        _request.valuesByTimestamp[_timeOfLastNewValue] = [a[0].value, a[1].value, a[2].value, a[3].value, a[4].value];\r\n        _request.minedBlockNum[_timeOfLastNewValue] = block.number;\r\n        //map the timeOfLastValue to the requestId that was just mined\r\n\r\n        self.requestIdByTimestamp[_timeOfLastNewValue] = _requestId;\r\n        //add timeOfLastValue to the newValueTimestamps array\r\n        self.newValueTimestamps.push(_timeOfLastNewValue);\r\n        //re-start the count for the slot progress to zero before the new request mining starts\r\n        self.uintVars[keccak256(\"slotProgress\")] = 0;\r\n        uint256 _topId = TellorGettersLibrary.getTopRequestID(self);\r\n        self.uintVars[keccak256(\"currentRequestId\")] = _topId;\r\n        //if the currentRequestId is not zero(currentRequestId exists/something is being mined) select the requestId with the hightest payout\r\n        //else wait for a new tip to mine\r\n        if (_topId > 0) {\r\n            //Update the current request to be mined to the requestID with the highest payout\r\n            self.uintVars[keccak256(\"currentTotalTips\")] = self.requestDetails[_topId].apiUintVars[keccak256(\"totalTip\")];\r\n            //Remove the currentRequestId/onDeckRequestId from the requestQ array containing the rest of the 50 requests\r\n            self.requestQ[self.requestDetails[_topId].apiUintVars[keccak256(\"requestQPosition\")]] = 0;\r\n\r\n            //unmap the currentRequestId/onDeckRequestId from the requestIdByRequestQIndex\r\n            self.requestIdByRequestQIndex[self.requestDetails[_topId].apiUintVars[keccak256(\"requestQPosition\")]] = 0;\r\n\r\n            //Remove the requestQposition for the currentRequestId/onDeckRequestId since it will be mined next\r\n            self.requestDetails[_topId].apiUintVars[keccak256(\"requestQPosition\")] = 0;\r\n\r\n            //Reset the requestId TotalTip to 0 for the currentRequestId/onDeckRequestId since it will be mined next\r\n            //and the tip is going to the current timestamp miners. The tip for the API needs to be reset to zero\r\n            self.requestDetails[_topId].apiUintVars[keccak256(\"totalTip\")] = 0;\r\n\r\n            //gets the max tip in the in the requestQ[51] array and its index within the array??\r\n            uint256 newRequestId = TellorGettersLibrary.getTopRequestID(self);\r\n            //Issue the the next challenge\r\n            self.currentChallenge = keccak256(abi.encodePacked(_nonce, self.currentChallenge, blockhash(block.number - 1))); // Save hash for next proof\r\n            emit NewChallenge(\r\n                self.currentChallenge,\r\n                _topId,\r\n                self.uintVars[keccak256(\"difficulty\")],\r\n                self.requestDetails[_topId].apiUintVars[keccak256(\"granularity\")],\r\n                self.requestDetails[_topId].queryString,\r\n                self.uintVars[keccak256(\"currentTotalTips\")]\r\n            );\r\n            emit NewRequestOnDeck(\r\n                newRequestId,\r\n                self.requestDetails[newRequestId].queryString,\r\n                self.requestDetails[newRequestId].queryHash,\r\n                self.requestDetails[newRequestId].apiUintVars[keccak256(\"totalTip\")]\r\n            );\r\n        } else {\r\n            self.uintVars[keccak256(\"currentTotalTips\")] = 0;\r\n            self.currentChallenge = \"\";\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Proof of work is called by the miner when they submit the solution (proof of work and value)\r\n    * @param _nonce uint submitted by miner\r\n    * @param _requestId the apiId being mined\r\n    * @param _value of api query\r\n    */\r\n    function submitMiningSolution(TellorStorage.TellorStorageStruct storage self, string memory _nonce, uint256 _requestId, uint256 _value)\r\n        public\r\n    {\r\n        //requre miner is staked\r\n        require(self.stakerDetails[msg.sender].currentStatus == 1, \"Miner status is not staker\");\r\n\r\n        //Check the miner is submitting the pow for the current request Id\r\n        require(_requestId == self.uintVars[keccak256(\"currentRequestId\")], \"RequestId is wrong\");\r\n\r\n        //Saving the challenge information as unique by using the msg.sender\r\n        require(\r\n            uint256(\r\n                sha256(abi.encodePacked(ripemd160(abi.encodePacked(keccak256(abi.encodePacked(self.currentChallenge, msg.sender, _nonce))))))\r\n            ) %\r\n                self.uintVars[keccak256(\"difficulty\")] ==\r\n                0,\r\n            \"Challenge information is not saved\"\r\n        );\r\n\r\n        //Make sure the miner does not submit a value more than once\r\n        require(self.minersByChallenge[self.currentChallenge][msg.sender] == false, \"Miner already submitted the value\");\r\n\r\n        //Save the miner and value received\r\n        self.currentMiners[self.uintVars[keccak256(\"slotProgress\")]].value = _value;\r\n        self.currentMiners[self.uintVars[keccak256(\"slotProgress\")]].miner = msg.sender;\r\n\r\n        //Add to the count how many values have been submitted, since only 5 are taken per request\r\n        self.uintVars[keccak256(\"slotProgress\")]++;\r\n\r\n        //Update the miner status to true once they submit a value so they don't submit more than once\r\n        self.minersByChallenge[self.currentChallenge][msg.sender] = true;\r\n\r\n        emit NonceSubmitted(msg.sender, _nonce, _requestId, _value, self.currentChallenge);\r\n\r\n        //If 5 values have been received, adjust the difficulty otherwise sort the values until 5 are received\r\n        if (self.uintVars[keccak256(\"slotProgress\")] == 5) {\r\n            newBlock(self, _nonce, _requestId);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to propose transfer control of the contract to a\r\n    * newOwner and the ownership is pending until the new owner calls the claimOwnership\r\n    * function\r\n    * @param _pendingOwner The address to transfer ownership to.\r\n    */\r\n    function proposeOwnership(TellorStorage.TellorStorageStruct storage self, address payable _pendingOwner) internal {\r\n        require(msg.sender == self.addressVars[keccak256(\"_owner\")], \"Sender is not owner\");\r\n        emit OwnershipProposed(self.addressVars[keccak256(\"_owner\")], _pendingOwner);\r\n        self.addressVars[keccak256(\"pending_owner\")] = _pendingOwner;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the new owner to claim control of the contract\r\n    */\r\n    function claimOwnership(TellorStorage.TellorStorageStruct storage self) internal {\r\n        require(msg.sender == self.addressVars[keccak256(\"pending_owner\")], \"Sender is not pending owner\");\r\n        emit OwnershipTransferred(self.addressVars[keccak256(\"_owner\")], self.addressVars[keccak256(\"pending_owner\")]);\r\n        self.addressVars[keccak256(\"_owner\")] = self.addressVars[keccak256(\"pending_owner\")];\r\n    }\r\n\r\n    /**\r\n    * @dev This function updates APIonQ and the requestQ when requestData or addTip are ran\r\n    * @param _requestId being requested\r\n    * @param _tip is the tip to add\r\n    */\r\n    function updateOnDeck(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _tip) internal {\r\n        TellorStorage.Request storage _request = self.requestDetails[_requestId];\r\n        uint256 onDeckRequestId = TellorGettersLibrary.getTopRequestID(self);\r\n        //If the tip >0 update the tip for the requestId\r\n        if (_tip > 0) {\r\n            _request.apiUintVars[keccak256(\"totalTip\")] = _request.apiUintVars[keccak256(\"totalTip\")].add(_tip);\r\n        }\r\n        //Set _payout for the submitted request\r\n        uint256 _payout = _request.apiUintVars[keccak256(\"totalTip\")];\r\n\r\n        //If there is no current request being mined\r\n        //then set the currentRequestId to the requestid of the requestData or addtip requestId submitted,\r\n        // the totalTips to the payout/tip submitted, and issue a new mining challenge\r\n        if (self.uintVars[keccak256(\"currentRequestId\")] == 0) {\r\n            _request.apiUintVars[keccak256(\"totalTip\")] = 0;\r\n            self.uintVars[keccak256(\"currentRequestId\")] = _requestId;\r\n            self.uintVars[keccak256(\"currentTotalTips\")] = _payout;\r\n            self.currentChallenge = keccak256(abi.encodePacked(_payout, self.currentChallenge, blockhash(block.number - 1))); // Save hash for next proof\r\n            emit NewChallenge(\r\n                self.currentChallenge,\r\n                self.uintVars[keccak256(\"currentRequestId\")],\r\n                self.uintVars[keccak256(\"difficulty\")],\r\n                self.requestDetails[self.uintVars[keccak256(\"currentRequestId\")]].apiUintVars[keccak256(\"granularity\")],\r\n                self.requestDetails[self.uintVars[keccak256(\"currentRequestId\")]].queryString,\r\n                self.uintVars[keccak256(\"currentTotalTips\")]\r\n            );\r\n        } else {\r\n            //If there is no OnDeckRequestId\r\n            //then replace/add the requestId to be the OnDeckRequestId, queryHash and OnDeckTotalTips(current highest payout, aside from what\r\n            //is being currently mined)\r\n            if (_payout > self.requestDetails[onDeckRequestId].apiUintVars[keccak256(\"totalTip\")] || (onDeckRequestId == 0)) {\r\n                //let everyone know the next on queue has been replaced\r\n                emit NewRequestOnDeck(_requestId, _request.queryString, _request.queryHash, _payout);\r\n            }\r\n\r\n            //if the request is not part of the requestQ[51] array\r\n            //then add to the requestQ[51] only if the _payout/tip is greater than the minimum(tip) in the requestQ[51] array\r\n            if (_request.apiUintVars[keccak256(\"requestQPosition\")] == 0) {\r\n                uint256 _min;\r\n                uint256 _index;\r\n                (_min, _index) = Utilities.getMin(self.requestQ);\r\n                //we have to zero out the oldOne\r\n                //if the _payout is greater than the current minimum payout in the requestQ[51] or if the minimum is zero\r\n                //then add it to the requestQ array aand map its index information to the requestId and the apiUintvars\r\n                if (_payout > _min || _min == 0) {\r\n                    self.requestQ[_index] = _payout;\r\n                    self.requestDetails[self.requestIdByRequestQIndex[_index]].apiUintVars[keccak256(\"requestQPosition\")] = 0;\r\n                    self.requestIdByRequestQIndex[_index] = _requestId;\r\n                    _request.apiUintVars[keccak256(\"requestQPosition\")] = _index;\r\n                }\r\n                // else if the requestid is part of the requestQ[51] then update the tip for it\r\n            } else if (_tip > 0) {\r\n                self.requestQ[_request.apiUintVars[keccak256(\"requestQPosition\")]] += _tip;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Tellor Oracle System\r\n * @dev Oracle contract where miners can submit the proof of work along with the value.\r\n * The logic for this contract is in TellorLibrary.sol, TellorDispute.sol, TellorStake.sol,\r\n * and TellorTransfer.sol\r\n */\r\ncontract Tellor {\r\n    using SafeMath for uint256;\r\n\r\n    using TellorDispute for TellorStorage.TellorStorageStruct;\r\n    using TellorLibrary for TellorStorage.TellorStorageStruct;\r\n    using TellorStake for TellorStorage.TellorStorageStruct;\r\n    using TellorTransfer for TellorStorage.TellorStorageStruct;\r\n\r\n    TellorStorage.TellorStorageStruct tellor;\r\n\r\n    /*Functions*/\r\n\r\n    /*This is a cheat for demo purposes, will delete upon actual launch*/\r\n/*    function theLazyCoon(address _address, uint _amount) public {\r\n        tellor.theLazyCoon(_address,_amount);\r\n    }*/\r\n\r\n    /**\r\n    * @dev Helps initialize a dispute by assigning it a disputeId\r\n    * when a miner returns a false on the validate array(in Tellor.ProofOfWork) it sends the\r\n    * invalidated value information to POS voting\r\n    * @param _requestId being disputed\r\n    * @param _timestamp being disputed\r\n    * @param _minerIndex the index of the miner that submitted the value being disputed. Since each official value\r\n    * requires 5 miners to submit a value.\r\n    */\r\n    function beginDispute(uint256 _requestId, uint256 _timestamp, uint256 _minerIndex) external {\r\n        tellor.beginDispute(_requestId, _timestamp, _minerIndex);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows token holders to vote\r\n    * @param _disputeId is the dispute id\r\n    * @param _supportsDispute is the vote (true=the dispute has basis false = vote against dispute)\r\n    */\r\n    function vote(uint256 _disputeId, bool _supportsDispute) external {\r\n        tellor.vote(_disputeId, _supportsDispute);\r\n    }\r\n\r\n    /**\r\n    * @dev tallies the votes.\r\n    * @param _disputeId is the dispute id\r\n    */\r\n    function tallyVotes(uint256 _disputeId) external {\r\n        tellor.tallyVotes(_disputeId);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows for a fork to be proposed\r\n    * @param _propNewTellorAddress address for new proposed Tellor\r\n    */\r\n    function proposeFork(address _propNewTellorAddress) external {\r\n        tellor.proposeFork(_propNewTellorAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev Add tip to Request value from oracle\r\n    * @param _requestId being requested to be mined\r\n    * @param _tip amount the requester is willing to pay to be get on queue. Miners\r\n    * mine the onDeckQueryHash, or the api with the highest payout pool\r\n    */\r\n    function addTip(uint256 _requestId, uint256 _tip) external {\r\n        tellor.addTip(_requestId, _tip);\r\n    }\r\n\r\n    /**\r\n    * @dev Request to retreive value from oracle based on timestamp. The tip is not required to be\r\n    * greater than 0 because there are no tokens in circulation for the initial(genesis) request\r\n    * @param _c_sapi string API being requested be mined\r\n    * @param _c_symbol is the short string symbol for the api request\r\n    * @param _granularity is the number of decimals miners should include on the submitted value\r\n    * @param _tip amount the requester is willing to pay to be get on queue. Miners\r\n    * mine the onDeckQueryHash, or the api with the highest payout pool\r\n    */\r\n    function requestData(string calldata _c_sapi, string calldata _c_symbol, uint256 _granularity, uint256 _tip) external {\r\n        tellor.requestData(_c_sapi, _c_symbol, _granularity, _tip);\r\n    }\r\n\r\n    /**\r\n    * @dev Proof of work is called by the miner when they submit the solution (proof of work and value)\r\n    * @param _nonce uint submitted by miner\r\n    * @param _requestId the apiId being mined\r\n    * @param _value of api query\r\n    */\r\n    function submitMiningSolution(string calldata _nonce, uint256 _requestId, uint256 _value) external {\r\n        tellor.submitMiningSolution(_nonce, _requestId, _value);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to propose transfer control of the contract to a\r\n    * newOwner and the ownership is pending until the new owner calls the claimOwnership\r\n    * function\r\n    * @param _pendingOwner The address to transfer ownership to.\r\n    */\r\n    function proposeOwnership(address payable _pendingOwner) external {\r\n        tellor.proposeOwnership(_pendingOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the new owner to claim control of the contract\r\n    */\r\n    function claimOwnership() external {\r\n        tellor.claimOwnership();\r\n    }\r\n\r\n    /**\r\n    * @dev This function allows miners to deposit their stake.\r\n    */\r\n    function depositStake() external {\r\n        tellor.depositStake();\r\n    }\r\n\r\n    /**\r\n    * @dev This function allows stakers to request to withdraw their stake (no longer stake)\r\n    * once they lock for withdraw(stakes.currentStatus = 2) they are locked for 7 days before they\r\n    * can withdraw the stake\r\n    */\r\n    function requestStakingWithdraw() external {\r\n        tellor.requestStakingWithdraw();\r\n    }\r\n\r\n    /**\r\n    * @dev This function allows users to withdraw their stake after a 7 day waiting period from request\r\n    */\r\n    function withdrawStake() external {\r\n        tellor.withdrawStake();\r\n    }\r\n\r\n    /**\r\n    * @dev This function approves a _spender an _amount of tokens to use\r\n    * @param _spender address\r\n    * @param _amount amount the spender is being approved for\r\n    * @return true if spender appproved successfully\r\n    */\r\n    function approve(address _spender, uint256 _amount) external returns (bool) {\r\n        return tellor.approve(_spender, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows for a transfer of tokens to _to\r\n    * @param _to The address to send tokens to\r\n    * @param _amount The amount of tokens to send\r\n    * @return true if transfer is successful\r\n    */\r\n    function transfer(address _to, uint256 _amount) external returns (bool) {\r\n        return tellor.transfer(_to, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Sends _amount tokens to _to from _from on the condition it\r\n    * is approved by _from\r\n    * @param _from The address holding the tokens being transferred\r\n    * @param _to The address of the recipient\r\n    * @param _amount The amount of tokens to be transferred\r\n    * @return True if the transfer was successful\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool) {\r\n        return tellor.transferFrom(_from, _to, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows users to access the token's name\r\n    */\r\n    function name() external pure returns (string memory) {\r\n        return \"Tellor Tributes\";\r\n    }\r\n\r\n    /**\r\n    * @dev Allows users to access the token's symbol\r\n    */\r\n    function symbol() external pure returns (string memory) {\r\n        return \"TRB\";\r\n    }\r\n\r\n    /**\r\n    * @dev Allows users to access the number of decimals\r\n    */\r\n    function decimals() external pure returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n}\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/*\r\n * @title Price/numberic Pull Oracle mapping contract\r\n*/\r\n\r\ncontract OracleIDDescriptions {\r\n\r\n    /*Variables*/\r\n    mapping(uint=>bytes32) tellorIDtoBytesID;\r\n    mapping(bytes32 => uint) bytesIDtoTellorID;\r\n    mapping(uint => int) tellorCodeToStatusCode;\r\n    mapping(int => uint) statusCodeToTellorCode;\r\n    address public owner;\r\n\r\n    /*Events*/\r\n    event TellorIdMappedToBytes(uint _requestID, bytes32 _id);\r\n    event StatusMapped(uint _tellorStatus, int _status);\r\n    \r\n\r\n    /*Functions*/\r\n    constructor() public{\r\n        owner =msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev This fucntion allows for ownership transfer\r\n    * @param newOwner is the address for the new owner\r\n    */\r\n    function transferOwnership(address payable newOwner) external {\r\n        require(msg.sender == owner, \"Sender is not owner\");\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n    * @dev This fuction allows the owner to map the tellor uint data status code to the standarized \r\n    * ADO int status code such as null, retreived etc...\r\n    * _tellorStatus uint the tellor status\r\n    * _status the data ADO standarized int status\r\n    */\r\n    function defineTellorCodeToStatusCode(uint _tellorStatus, int _status) external{\r\n        require(msg.sender == owner, \"Sender is not owner\");\r\n        tellorCodeToStatusCode[_tellorStatus] = _status;\r\n        statusCodeToTellorCode[_status] = _tellorStatus;\r\n        emit StatusMapped(_tellorStatus, _status);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows owner to map the standarized bytes32 Id to a specific requestID from Tellor\r\n    * The dev should ensure the _requestId exists otherwise request the data on Tellor to get a requestId\r\n    * _requestID is the existing Tellor RequestID \r\n    * _id is the descption of the ID in bytes \r\n    */ \r\n    function defineTellorIdToBytesID(uint _requestID, bytes32 _id) external{\r\n        require(msg.sender == owner, \"Sender is not owner\");\r\n        tellorIDtoBytesID[_requestID] = _id;\r\n        bytesIDtoTellorID[_id] = _requestID;\r\n        emit TellorIdMappedToBytes(_requestID,_id);\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function for the uint Tellor status code from the specified int ADO standarized status code\r\n    * @param _status the int ADO standarized status\r\n    * @return _tellorStatus uint \r\n    */ \r\n    function getTellorStatusFromStatus(int _status) public view returns(uint _tellorStatus){\r\n        return statusCodeToTellorCode[_status];\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function of the int ADO standarized status code from the specified Tellor uint status\r\n    * @param _tellorStatus uint \r\n    * @return _status the int ADO standarized status\r\n    */ \r\n    function getStatusFromTellorStatus (uint _tellorStatus) public view returns(int _status) {\r\n        return tellorCodeToStatusCode[_tellorStatus];\r\n    }\r\n    \r\n    /**\r\n    * @dev Getter function of the Tellor RequestID based on the specified bytes32 ADO standaraized _id\r\n    * @param _id is the bytes32 descriptor mapped to an existing Tellor's requestId\r\n    * @return _requestId is Tellor's requestID corresnpoding to _id\r\n    */ \r\n    function getTellorIdFromBytes(bytes32 _id) public view  returns(uint _requestId)  {\r\n       return bytesIDtoTellorID[_id];\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function of the bytes32 ADO standaraized _id based on the specified Tellor RequestID \r\n    * @param _requestId is Tellor's requestID\r\n    * @return _id is the bytes32 descriptor mapped to an existing Tellor's requestId\r\n    */ \r\n    function getBytesFromTellorID(uint _requestId) public view returns(bytes32 _id) {\r\n        return tellorIDtoBytesID[_requestId];\r\n    }\r\n\r\n}\r\n\r\n/*\r\n@title ADOInterface \r\n@notice This inteface is the standard interface for price oracles\r\n*/\r\n\r\ninterface ADOInterface {\r\n        function resultFor(bytes32 Id) view external returns (uint256 timestamp, int256 outcome, int256 status);\r\n}\r\n\r\n/**\r\n* @title UserContract\r\n* This contracts creates for easy integration to the Tellor Tellor System\r\n* This contract holds the Ether and Tributes for interacting with the system\r\n* Note it is centralized (we can set the price of Tellor Tributes)\r\n* Once the tellor system is running, this can be set properly.\r\n* Note deploy through centralized 'Tellor Master contract'\r\n*/\r\ncontract UserContract is ADOInterface{\r\n    //in Loyas per ETH.  so at 200$ ETH price and 3$ Trib price -- (3/200 * 1e18)\r\n    uint256 public tributePrice;\r\n    address payable public owner;\r\n    address payable public tellorStorageAddress;\r\n    address public oracleIDDescriptionsAddress;\r\n    Tellor _tellor;\r\n    TellorMaster _tellorm;\r\n    OracleIDDescriptions descriptions;\r\n\r\n    event OwnershipTransferred(address _previousOwner, address _newOwner);\r\n    event NewPriceSet(uint256 _newPrice);\r\n    event NewDescriptorSet(address _descriptorSet);\r\n\r\n    /*Constructor*/\r\n    /**\r\n    * @dev the constructor sets the storage address and owner\r\n    * @param _storage is the TellorMaster address ???\r\n    */\r\n    constructor(address payable _storage) public {\r\n        tellorStorageAddress = _storage;\r\n        _tellor = Tellor(tellorStorageAddress); //we should delcall here\r\n        _tellorm = TellorMaster(tellorStorageAddress);\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /*Functions*/\r\n    /*\r\n    * @dev Allows the owner to set the address for the oracleID descriptors\r\n    * used by the ADO members for price key value pairs standarization \r\n    * _oracleDescriptos is the address for the OracleIDDescptions contract\r\n    */\r\n    function setOracleIDDescriptors(address _oracleDescriptors) external {\r\n        require(msg.sender == owner, \"Sender is not owner\");\r\n        oracleIDDescriptionsAddress = _oracleDescriptors;\r\n        descriptions = OracleIDDescriptions(_oracleDescriptors);\r\n        emit NewDescriptorSet(_oracleDescriptors);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address payable newOwner) external {\r\n        require(msg.sender == owner, \"Sender is not owner\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n    * @dev This function allows the owner to withdraw the ETH paid for requests\r\n    */\r\n    function withdrawEther() external {\r\n        require(msg.sender == owner, \"Sender is not owner\");\r\n        owner.transfer(address(this).balance);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the contract owner(Tellor) to withdraw any Tributes left on this contract\r\n    */\r\n    function withdrawTokens() external {\r\n        require(msg.sender == owner, \"Sender is not owner\");\r\n        _tellor.transfer(owner, _tellorm.balanceOf(address(this)));\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the user to submit a request for data to the oracle using ETH\r\n    * @param c_sapi string API being requested to be mined\r\n    * @param _c_symbol is the short string symbol for the api request\r\n    * @param _granularity is the number of decimals miners should include on the submitted value\r\n    */\r\n    function requestDataWithEther(string calldata c_sapi, string calldata _c_symbol, uint256 _granularity) external payable {\r\n        uint _amount = (msg.value / tributePrice)*1e18;\r\n        require(_tellorm.balanceOf(address(this)) >= _amount, \"Balance is lower than tip amount\");\r\n        _tellor.requestData(c_sapi, _c_symbol, _granularity, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the user to tip miners using ether\r\n    * @param _apiId to tip\r\n    */\r\n    function addTipWithEther(uint256 _apiId) external payable {\r\n        uint _amount = (msg.value / tributePrice)*1e18;\r\n        require(_tellorm.balanceOf(address(this)) >= _amount, \"Balance is lower than tip amount\");\r\n        _tellor.addTip(_apiId, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the owner to set the Tribute token price.\r\n    * @param _price to set for Tellor Tribute token\r\n    */\r\n    function setPrice(uint256 _price) public {\r\n        require(msg.sender == owner, \"Sender is not owner\");\r\n        tributePrice = _price;\r\n        emit NewPriceSet(_price);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the user to get the latest value for the requestId specified\r\n    * @param _requestId is the requestId to look up the value for\r\n    * @return bool true if it is able to retreive a value, the value, and the value's timestamp\r\n    */\r\n    function getCurrentValue(uint256 _requestId) public view returns (bool ifRetrieve, uint256 value, uint256 _timestampRetrieved) {\r\n        uint256 _count = _tellorm.getNewValueCountbyRequestId(_requestId);\r\n        if (_count > 0) {\r\n            _timestampRetrieved = _tellorm.getTimestampbyRequestIDandIndex(_requestId, _count - 1); //will this work with a zero index? (or insta hit?)\r\n            return (true, _tellorm.retrieveData(_requestId, _timestampRetrieved), _timestampRetrieved);\r\n        }\r\n        return (false, 0, 0);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the user to get the latest value for the requestId specified using the \r\n    * ADO specification for the standard inteface for price oracles\r\n    * @param _bytesId is the ADO standarized bytes32 price/key value pair identifier\r\n    * @return the timestamp, outcome or value/ and the status code (for retreived, null, etc...)\r\n    */\r\n    function resultFor(bytes32 _bytesId) view external returns (uint256 timestamp, int outcome, int status) {\r\n        uint _id = descriptions.getTellorIdFromBytes(_bytesId);\r\n        if (_id > 0){\r\n            bool _didGet;\r\n            uint256 _returnedValue;\r\n            uint256 _timestampRetrieved;\r\n            (_didGet,_returnedValue,_timestampRetrieved) = getCurrentValue(_id);\r\n            if(_didGet){\r\n                return (_timestampRetrieved, int(_returnedValue),descriptions.getStatusFromTellorStatus(1));\r\n            }\r\n            else{\r\n                return (0,0,descriptions.getStatusFromTellorStatus(2));\r\n            }\r\n        }\r\n        return (0, 0, descriptions.getStatusFromTellorStatus(0));\r\n    }\r\n    /**\r\n    * @dev Allows the user to get the first verified value for the requestId after the specified timestamp\r\n    * @param _requestId is the requestId to look up the value for\r\n    * @param _timestamp after which to search for first verified value\r\n    * @return bool true if it is able to retreive a value, the value, and the value's timestamp, the timestamp after\r\n    * which it searched for the first verified value\r\n    */\r\n    function getFirstVerifiedDataAfter(uint256 _requestId, uint256 _timestamp) public view returns (bool, uint256, uint256 _timestampRetrieved) {\r\n        uint256 _count = _tellorm.getNewValueCountbyRequestId(_requestId);\r\n        if (_count > 0) {\r\n            for (uint256 i = _count; i > 0; i--) {\r\n                if (\r\n                    _tellorm.getTimestampbyRequestIDandIndex(_requestId, i - 1) > _timestamp &&\r\n                    _tellorm.getTimestampbyRequestIDandIndex(_requestId, i - 1) < block.timestamp - 86400\r\n                ) {\r\n                    _timestampRetrieved = _tellorm.getTimestampbyRequestIDandIndex(_requestId, i - 1); //will this work with a zero index? (or insta hit?)\r\n                }\r\n            }\r\n            if (_timestampRetrieved > 0) {\r\n                return (true, _tellorm.retrieveData(_requestId, _timestampRetrieved), _timestampRetrieved);\r\n            }\r\n        }\r\n        return (false, 0, 0);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the user to get the first value for the requestId after the specified timestamp\r\n    * @param _requestId is the requestId to look up the value for\r\n    * @param _timestamp after which to search for first verified value\r\n    * @return bool true if it is able to retreive a value, the value, and the value's timestamp\r\n    */\r\n    function getAnyDataAfter(uint256 _requestId, uint256 _timestamp)\r\n        public\r\n        view\r\n        returns (bool _ifRetrieve, uint256 _value, uint256 _timestampRetrieved)\r\n    {\r\n        uint256 _count = _tellorm.getNewValueCountbyRequestId(_requestId);\r\n        if (_count > 0) {\r\n            for (uint256 i = _count; i > 0; i--) {\r\n                if (_tellorm.getTimestampbyRequestIDandIndex(_requestId, i - 1) >= _timestamp) {\r\n                    _timestampRetrieved = _tellorm.getTimestampbyRequestIDandIndex(_requestId, i - 1); //will this work with a zero index? (or insta hit?)\r\n                }\r\n            }\r\n            if (_timestampRetrieved > 0) {\r\n                return (true, _tellorm.retrieveData(_requestId, _timestampRetrieved), _timestampRetrieved);\r\n            }\r\n        }\r\n        return (false, 0, 0);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n* @title UsingTellor\r\n* This contracts creates for easy integration to the Tellor Tellor System\r\n*/\r\ncontract UsingTellor is ADOInterface{\r\n    UserContract tellorUserContract;\r\n    address payable public owner;\r\n\r\n    event OwnershipTransferred(address _previousOwner, address _newOwner);\r\n\r\n    /*Constructor*/\r\n    /**\r\n    * @dev This function sents the owner and userContract address\r\n    * @param _userContract is the UserContract.sol address\r\n    */\r\n    constructor(address _userContract) public {\r\n        tellorUserContract = UserContract(_userContract);\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /*Functions*/\r\n    /**\r\n    * @dev Allows the user to get the latest value for the requestId specified\r\n    * @param _requestId is the requestId to look up the value for\r\n    * @return bool true if it is able to retreive a value, the value, and the value's timestamp\r\n    */\r\n    function getCurrentValue(uint256 _requestId) public view returns (bool ifRetrieve, uint256 value, uint256 _timestampRetrieved) {\r\n        return tellorUserContract.getCurrentValue(_requestId);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the user to get the latest value for the requestId specified using the \r\n    * ADO specification for the standard inteface for price oracles\r\n    * @param _bytesId is the ADO standarized bytes32 price/key value pair identifier\r\n    * @return the timestamp, outcome or value/ and the status code (for retreived, null, etc...)\r\n    */\r\n    function resultFor(bytes32 _bytesId) view external returns (uint256 timestamp,int256 outcome, int256 status){\r\n        return tellorUserContract.resultFor(_bytesId);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the user to get the first verified value for the requestId after the specified timestamp\r\n    * @param _requestId is the requestId to look up the value for\r\n    * @param _timestamp after which to search for first verified value\r\n    * @return bool true if it is able to retreive a value, the value, and the value's timestamp, the timestamp after\r\n    * which it searched for the first verified value\r\n    */\r\n    function getFirstVerifiedDataAfter(uint256 _requestId, uint256 _timestamp) public view returns (bool, uint256, uint256 _timestampRetrieved) {\r\n        return tellorUserContract.getFirstVerifiedDataAfter(_requestId, _timestamp);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the user to get the first value for the requestId after the specified timestamp\r\n    * @param _requestId is the requestId to look up the value for\r\n    * @param _timestamp after which to search for first verified value\r\n    * @return bool true if it is able to retreive a value, the value, and the value's timestamp\r\n    */\r\n    function getAnyDataAfter(uint256 _requestId, uint256 _timestamp)\r\n        public\r\n        view\r\n        returns (bool _ifRetrieve, uint256 _value, uint256 _timestampRetrieved)\r\n    {\r\n        return tellorUserContract.getAnyDataAfter(_requestId, _timestamp);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the user to submit a request for data to the oracle using Tributes\r\n    * Allowing this prevents us from increasing spread too high (since if we set the price too hight\r\n    * users will just go to an exchange and get tokens from there)\r\n    * @param _request string API being requested to be mined\r\n    * @param _symbol is the short string symbol for the api request\r\n    * @param _granularity is the number of decimals miners should include on the submitted value\r\n    * @param _tip amount the requester is willing to pay to be get on queue. Miners\r\n    * mine the onDeckQueryHash, or the api with the highest payout pool\r\n    */\r\n    function requestData(string calldata _request, string calldata _symbol, uint256 _granularity, uint256 _tip) external {\r\n        Tellor _tellor = Tellor(tellorUserContract.tellorStorageAddress());\r\n        if (_tip > 0) {\r\n            require(_tellor.transferFrom(msg.sender, address(this), _tip), \"Transfer failed\");\r\n        }\r\n        _tellor.requestData(_request, _symbol, _granularity, _tip);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the user to submit a request for data to the oracle using ETH\r\n    * @param _request string API being requested to be mined\r\n    * @param _symbol is the short string symbol for the api request\r\n    * @param _granularity is the number of decimals miners should include on the submitted value\r\n    */\r\n    function requestDataWithEther(string calldata _request, string calldata _symbol, uint256 _granularity) external payable {\r\n        tellorUserContract.requestDataWithEther.value(msg.value)(_request, _symbol, _granularity);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the user to tip miners for the specified request using Tributes\r\n    * @param _requestId to tip\r\n    * @param _tip amount\r\n    */\r\n    function addTip(uint256 _requestId, uint256 _tip) public {\r\n        Tellor _tellor = Tellor(tellorUserContract.tellorStorageAddress());\r\n        require(_tellor.transferFrom(msg.sender, address(this), _tip), \"Transfer failed\");\r\n        _tellor.addTip(_requestId, _tip);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows user to add tip with Ether by sending the ETH to the userContract and exchanging it for Tributes\r\n    * at the price specified by the userContract owner.\r\n    * @param _requestId to tip\r\n    */\r\n    function addTipWithEther(uint256 _requestId) public payable {\r\n        UserContract(tellorUserContract).addTipWithEther.value(msg.value)(_requestId);\r\n    }\r\n\r\n    /**\r\n    * @dev allows owner to set the user contract address\r\n    * @param _userContract address\r\n    */\r\n    function setUserContract(address _userContract) public {\r\n        require(msg.sender == owner, \"Sender is not owner\"); //who should this be?\r\n        tellorUserContract = UserContract(_userContract);\r\n    }\r\n\r\n    /**\r\n    * @dev allows owner to transfer ownership\r\n    * @param _newOwner address\r\n    */\r\n    function transferOwnership(address payable _newOwner) external {\r\n        require(msg.sender == owner, \"Sender is not owner\");\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"addTipWithEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getCurrentValue\",\"outputs\":[{\"name\":\"ifRetrieve\",\"type\":\"bool\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"_timestampRetrieved\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_request\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_granularity\",\"type\":\"uint256\"},{\"name\":\"_tip\",\"type\":\"uint256\"}],\"name\":\"requestData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_requestId\",\"type\":\"uint256\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getFirstVerifiedDataAfter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"_timestampRetrieved\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_requestId\",\"type\":\"uint256\"},{\"name\":\"_tip\",\"type\":\"uint256\"}],\"name\":\"addTip\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userContract\",\"type\":\"address\"}],\"name\":\"setUserContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_request\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_granularity\",\"type\":\"uint256\"}],\"name\":\"requestDataWithEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_bytesId\",\"type\":\"bytes32\"}],\"name\":\"resultFor\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"outcome\",\"type\":\"int256\"},{\"name\":\"status\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_requestId\",\"type\":\"uint256\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getAnyDataAfter\",\"outputs\":[{\"name\":\"_ifRetrieve\",\"type\":\"bool\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_timestampRetrieved\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_userContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"UsingTellor","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000009459fdafd6fdce14e04b3487a656fbca0b953ea","Library":"","LicenseType":"None","SwarmSource":"bzzr://f75e42ddaed334ad09c4555e9af61c41584dc2e67b7762c41cc97c3e8d13c6f3"}]}