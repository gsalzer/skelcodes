{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/IOwnable.sol\r\n\r\n// Adaped from \"@0x/contracts-utils/contracts/src/interfaces/IOwnable.sol\";\r\n\r\npragma solidity ^0.5.5;\r\n\r\n\r\ncontract IOwnable {\r\n\r\n    function transferOwnership1(address newOwner)\r\n        public;\r\n\r\n    function transferOwnership2(address newOwner)\r\n        public;\r\n}\r\n\r\n// File: contracts/Ownable.sol\r\n\r\n// Adaped from \"@0x/contracts-utils/contracts/src/Ownable.sol\";\r\n\r\npragma solidity ^0.5.5;\r\n\r\n\r\n\r\ncontract Ownable is\r\n    IOwnable\r\n{\r\n    address public owner1;\r\n    address public owner2;\r\n\r\n    constructor ()\r\n        public\r\n    {\r\n        owner1 = msg.sender;\r\n        owner2 = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(\r\n            (msg.sender == owner1) || (msg.sender == owner2),\r\n            \"ONLY_CONTRACT_OWNER\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function transferOwnership1(address newOwner)\r\n        public\r\n        onlyOwner\r\n    {\r\n        if (newOwner != address(0)) {\r\n            owner1 = newOwner;\r\n        }\r\n    }\r\n\r\n    function transferOwnership2(address newOwner)\r\n        public\r\n        onlyOwner\r\n    {\r\n        if (newOwner != address(0)) {\r\n            owner2 = newOwner;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/Registry.sol\r\n\r\n/*\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity ^0.5.5;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\ncontract Registry is\r\n    Ownable\r\n{\r\n\r\n\r\n    // Pause. When true, Registry updates (writes) are paused.\r\n    bool public paused = false;\r\n\r\n\r\n    /***  Microsponsors Registry Data:  ***/\r\n\r\n\r\n    // Array of registrant addresses,\r\n    // regardless of isWhitelisted status\r\n    address[] private registrants;\r\n\r\n    // Map registrant's address => isWhitelisted status.\r\n    // Addresses authorized to transact.\r\n    mapping (address => bool) public isWhitelisted;\r\n\r\n    // Map each registrant's address to the `block.timestamp`\r\n    // when the address was first registered\r\n    mapping (address => uint) public registrantTimestamp;\r\n\r\n    // Map each registrant's address to the address that referred them.\r\n    mapping (address => address) private registrantToReferrer;\r\n\r\n    // Map each referrer's address to array of addresses they referred.\r\n    mapping (address => address[]) private referrerToRegistrants;\r\n\r\n    // Map address => array of ContentId structs.\r\n    // Using struct because there is not mapping to an array of strings in Solidity at this time.\r\n    struct ContentIdStruct {\r\n        string contentId;\r\n    }\r\n    mapping (address => ContentIdStruct[]) private addressToContentIds;\r\n\r\n    // Map contentId => address (for reverse-lookups)\r\n    mapping (string => address) private contentIdToAddress;\r\n\r\n\r\n    /***  Constructor  ***/\r\n\r\n    constructor ()\r\n        public\r\n    {\r\n\r\n    }\r\n\r\n\r\n    /*** Admin Pause: Adapted from OpenZeppelin (via Cryptokitties) ***/\r\n\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS paused\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Called by contract owner to pause actions on this contract\r\n    function pause() external onlyOwner whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /// @dev Called by contract owner to unpause the smart contract.\r\n    /// @notice This is public rather than external so it can be called by\r\n    ///  derived contracts.\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n    }\r\n\r\n\r\n    /***  Admin: Registry Management  ***/\r\n\r\n\r\n    /// @dev Admin registers an address with a contentId.\r\n    /// @param target Address to add or remove from whitelist.\r\n    /// @param contentId To map the target's address to. UTF8-encoded SRN (a string).\r\n    /// @param isApproved Whitelist status to assign to the address.\r\n    function adminUpdate(\r\n        address target,\r\n        string memory contentId,\r\n        bool isApproved\r\n    )\r\n        public\r\n        onlyOwner\r\n        whenNotPaused\r\n    {\r\n\r\n        address previousOwner = contentIdToAddress[contentId];\r\n\r\n        if (previousOwner != target) {\r\n\r\n            // If contentId already belongs to another owner address\r\n            // it must be explicitly removed by admin remove fn\r\n            // which will also remove that address from whitelist\r\n            // if this was its only contentId\r\n            if (previousOwner != 0x0000000000000000000000000000000000000000) {\r\n                adminRemoveContentIdFromAddress(previousOwner, contentId);\r\n            }\r\n\r\n            // Assign content id to new registrant address\r\n            addressToContentIds[target].push( ContentIdStruct(contentId) );\r\n            contentIdToAddress[contentId] = target;\r\n\r\n        }\r\n\r\n        if (!hasRegistered(target)) {\r\n            registrants.push(target);\r\n            registrantTimestamp[target] = block.timestamp;\r\n        }\r\n\r\n        isWhitelisted[target] = isApproved;\r\n\r\n    }\r\n\r\n\r\n    function adminUpdateWithReferrer(\r\n        address target,\r\n        string memory contentId,\r\n        bool isApproved,\r\n        address referrer\r\n    )\r\n        public\r\n        onlyOwner\r\n        whenNotPaused\r\n    {\r\n\r\n        // Revert transaction (refund gas) if\r\n        // the referrer is not whitelisted\r\n        require(\r\n            isWhitelisted[referrer],\r\n            'INVALID_REFERRER'\r\n        );\r\n\r\n        adminUpdate(target, contentId, isApproved);\r\n\r\n        adminUpdateReferrer(target, referrer);\r\n\r\n    }\r\n\r\n\r\n    function adminUpdateReferrer(\r\n        address registrant,\r\n        address referrer\r\n    )\r\n        public\r\n        onlyOwner\r\n        whenNotPaused\r\n    {\r\n\r\n        // Revert transaction (refund gas) if\r\n        // the registrant has never registered\r\n        require(\r\n            hasRegistered(registrant),\r\n            'INVALID_REGISTRANT'\r\n        );\r\n\r\n        // Revert transaction (refund gas) if\r\n        // the referrer is not whitelisted\r\n        require(\r\n            isWhitelisted[referrer],\r\n            'INVALID_REFERRER'\r\n        );\r\n\r\n        // Revert transaction (refund gas) if\r\n        // the registrant and referrer are the same\r\n        require(\r\n            registrant != referrer,\r\n            'INVALID_REFERRER'\r\n        );\r\n\r\n        require(\r\n            registrantToReferrer[registrant] != referrer,\r\n            'REFERRER_UPDATE_IS_REDUNDANT'\r\n        );\r\n\r\n        address previousReferrer = registrantToReferrer[registrant];\r\n\r\n        // If the registrant had a previous referrer, remove the registrant\r\n        // from referrerToRegistrants[previousReferrer] array\r\n        if (previousReferrer != 0x0000000000000000000000000000000000000000) {\r\n            address[] memory a = referrerToRegistrants[previousReferrer];\r\n            for (uint i = 0; i < a.length; i++) {\r\n                if (a[i] == registrant) {\r\n                    referrerToRegistrants[previousReferrer][i] = 0x0000000000000000000000000000000000000000;\r\n                }\r\n            }\r\n        }\r\n\r\n        registrantToReferrer[registrant] = referrer;\r\n        referrerToRegistrants[referrer].push(registrant);\r\n\r\n    }\r\n\r\n    /// @dev Admin updates whitelist status for a given address.\r\n    /// @param target Address to update.\r\n    /// @param isApproved Whitelist status to assign to address.\r\n    function adminUpdateWhitelistStatus(\r\n        address target,\r\n        bool isApproved\r\n    )\r\n        external\r\n        onlyOwner\r\n        whenNotPaused\r\n    {\r\n\r\n        // Revert transaction (refund gas) if\r\n        // the requested whitelist status update is redundant\r\n        require(\r\n            isApproved != isWhitelisted[target],\r\n            'NO_STATUS_UPDATE_REQUIRED'\r\n        );\r\n\r\n        // Disallow users with no associated content ids\r\n        // (ex: admin or user themselves may have removed content ids)\r\n        if (isApproved == true) {\r\n            require(\r\n                getNumContentIds(target) > 0,\r\n                'ADDRESS_HAS_NO_ASSOCIATED_CONTENT_IDS'\r\n            );\r\n        }\r\n\r\n        isWhitelisted[target] = isApproved;\r\n\r\n    }\r\n\r\n    /// @dev Admin removes a contentId from a given address.\r\n    function adminRemoveContentIdFromAddress(\r\n        address target,\r\n        string memory contentId\r\n    )\r\n        public\r\n        onlyOwner\r\n        whenNotPaused\r\n    {\r\n\r\n        require(\r\n            contentIdToAddress[contentId] == target,\r\n            'CONTENT_ID_DOES_NOT_BELONG_TO_ADDRESS'\r\n        );\r\n\r\n        contentIdToAddress[contentId] = address(0x0000000000000000000000000000000000000000);\r\n\r\n        // Remove content id from addressToContentIds mapping\r\n        // by replacing it with empty string\r\n        ContentIdStruct[] memory m = addressToContentIds[target];\r\n        for (uint i = 0; i < m.length; i++) {\r\n            if (stringsMatch(contentId, m[i].contentId)) {\r\n                addressToContentIds[target][i] = ContentIdStruct('');\r\n            }\r\n        }\r\n\r\n        // If address has no valid content ids left, remove from Whitelist\r\n        if (getNumContentIds(target) == 0) {\r\n            isWhitelisted[target] = false;\r\n        }\r\n\r\n    }\r\n\r\n    /// @dev Admin removes *all* contentIds from a given address.\r\n    function adminRemoveAllContentIdsFromAddress(\r\n        address target\r\n    )\r\n        public\r\n        onlyOwner\r\n        whenNotPaused\r\n    {\r\n\r\n        // Loop thru content ids from addressToContentIds mapping\r\n        // by replacing each with empty string\r\n        ContentIdStruct[] memory m = addressToContentIds[target];\r\n        for (uint i = 0; i < m.length; i++) {\r\n            addressToContentIds[target][i] = ContentIdStruct('');\r\n        }\r\n\r\n        // Remove from whitelist\r\n        isWhitelisted[target] = false;\r\n\r\n    }\r\n\r\n\r\n    /*** Admin read-only functions ***/\r\n\r\n\r\n    /// @dev Admin gets address mapped to a contentId,\r\n    ///      regardless of isWhitelist status.\r\n    function adminGetAddressByContentId(\r\n        string calldata contentId\r\n    )\r\n        external\r\n        view\r\n        onlyOwner\r\n        returns (address target)\r\n    {\r\n\r\n        return contentIdToAddress[contentId];\r\n\r\n    }\r\n\r\n    /// @dev Admin gets contentIds mapped to any address,\r\n    ///      regardless of whitelist status. There is a\r\n    ///      public-facing version of this below that only returns\r\n    ///      content ids for whitelisted accounts.\r\n    /// @param target Ethereum address to return contentIds for.\r\n    function adminGetContentIdsByAddress(\r\n        address target\r\n    )\r\n        external\r\n        view\r\n        onlyOwner\r\n        returns (string[] memory)\r\n    {\r\n\r\n        ContentIdStruct[] memory m = addressToContentIds[target];\r\n        string[] memory r = new string[](m.length);\r\n\r\n        for (uint i = 0; i < m.length; i++) {\r\n            r[i] =  m[i].contentId;\r\n        }\r\n\r\n        return r;\r\n\r\n    }\r\n\r\n\r\n    /// @dev Returns valid whitelisted account address by registrant index number,\r\n    ///      regardless of whitelist status.\r\n    function adminGetRegistrantByIndex (\r\n        uint index\r\n    )\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n\r\n        // Will throw error if specified index does not exist\r\n        return registrants[index];\r\n\r\n    }\r\n\r\n\r\n    /*** User-facing functions for reading registry state ***/\r\n\r\n\r\n    /// @dev Any address can check if an address has *ever* registered,\r\n    /// regardless of isWhitelisted status\r\n    function hasRegistered (\r\n        address target\r\n    )\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n\r\n        bool _hasRegistered = false;\r\n        for (uint i=0; i<registrants.length; i++) {\r\n            if (registrants[i] == target) {\r\n                return _hasRegistered = true;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /// @dev Returns count of all addresses that have *ever* registered,\r\n    /// regardless of their isWhitelisted status\r\n    function getRegistrantCount ()\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n\r\n        return registrants.length;\r\n\r\n    }\r\n\r\n    /// @dev Returns valid whitelisted account address by registrant index number.\r\n    function getRegistrantByIndex (\r\n        uint index\r\n    )\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n\r\n        // Will throw error if specified index does not exist\r\n        address target = registrants[index];\r\n\r\n        require(\r\n            isWhitelisted[target],\r\n            'INVALID_ADDRESS'\r\n        );\r\n\r\n        return target;\r\n    }\r\n\r\n    function getRegistrantToReferrer(address registrant)\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n\r\n        return registrantToReferrer[registrant];\r\n\r\n    }\r\n\r\n    function getReferrerToRegistrants(address referrer)\r\n        external\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n\r\n        return referrerToRegistrants[referrer];\r\n\r\n    }\r\n\r\n    /// @dev *Any* address can get a valid whitelisted account's contentIds.\r\n    ///      In practice, this is called from dapp(s).\r\n    function getContentIdsByAddress(\r\n        address target\r\n    )\r\n        external\r\n        view\r\n        returns (string[] memory)\r\n    {\r\n\r\n        require(\r\n            isWhitelisted[target],\r\n            'INVALID_ADDRESS'\r\n        );\r\n\r\n        ContentIdStruct[] memory m = addressToContentIds[target];\r\n        string[] memory r = new string[](m.length);\r\n\r\n        for (uint i = 0; i < m.length; i++) {\r\n            r[i] =  m[i].contentId;\r\n        }\r\n\r\n        return r;\r\n\r\n    }\r\n\r\n    /// @dev *Any* address can get a valid whitelisted account's\r\n    ///      address if they pass in (one of) its contentId(s).\r\n    function getAddressByContentId(\r\n        string calldata contentId\r\n    )\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n\r\n        address target = contentIdToAddress[contentId];\r\n\r\n        require(\r\n            isWhitelisted[target],\r\n            'INVALID_ADDRESS'\r\n        );\r\n\r\n        return target;\r\n    }\r\n\r\n\r\n    /*** User-facing functions to update an account's own registry state ***/\r\n\r\n\r\n    /// @dev Valid whitelisted address can remove its own content id.\r\n    function removeContentIdFromAddress(\r\n        string calldata contentId\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n\r\n        require(\r\n            isWhitelisted[msg.sender],\r\n            'INVALID_SENDER'\r\n        );\r\n\r\n        require(\r\n            contentIdToAddress[contentId] == msg.sender,\r\n            'CONTENT_ID_DOES_NOT_BELONG_TO_SENDER'\r\n        );\r\n\r\n        contentIdToAddress[contentId] = address(0x0000000000000000000000000000000000000000);\r\n\r\n        // Remove content id from addressToContentIds mapping\r\n        // by replacing it with empty string\r\n        ContentIdStruct[] memory m = addressToContentIds[msg.sender];\r\n        for (uint i = 0; i < m.length; i++) {\r\n            if (stringsMatch(contentId, m[i].contentId)) {\r\n                addressToContentIds[msg.sender][i] = ContentIdStruct('');\r\n            }\r\n        }\r\n\r\n        // If address has no valid content ids left, remove from Whitelist\r\n        if (getNumContentIds(msg.sender) == 0) {\r\n            isWhitelisted[msg.sender] = false;\r\n        }\r\n\r\n    }\r\n\r\n    /// @dev Valid whitelisted address can remove *all* contentIds from itself.\r\n    function removeAllContentIdsFromAddress(\r\n        address target\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n\r\n        require(\r\n            isWhitelisted[msg.sender],\r\n            'INVALID_SENDER'\r\n        );\r\n\r\n        require(\r\n            target == msg.sender,\r\n            'INVALID_SENDER'\r\n        );\r\n\r\n        // Loop thru content ids from addressToContentIds mapping\r\n        // by replacing each with empty string\r\n        ContentIdStruct[] memory m = addressToContentIds[target];\r\n        for (uint i = 0; i < m.length; i++) {\r\n            addressToContentIds[target][i] = ContentIdStruct('');\r\n        }\r\n\r\n        // Remove from whitelist\r\n        isWhitelisted[target] = false;\r\n\r\n    }\r\n\r\n\r\n    /*** User roles and authorizations: Contract-to-contract read functions  ***/\r\n\r\n\r\n    /**\r\n     * The following functions check user Roles and Authorizations.\r\n     * For now, most of them simply check `isWhitelisted()` in this contract.\r\n     * But the long-term idea here is to create a path for Microsponsors\r\n     * to federate: allowing other organizations to create their own\r\n     * exchange front-ends with their own set of granular rules about minting,\r\n     * selling and re-selling tokens, cross-exchange arbitrage, etc etc.\r\n     */\r\n\r\n\r\n    /// @dev Valid whitelisted address validates registration of its own\r\n    ///      Content ID. In practice, this will be used by Microsponsors'\r\n    ///      ERC-721 for validating that an address is authorized to mint()\r\n    ///      a time slot for a given content id.\r\n    function isContentIdRegisteredToCaller(\r\n        uint32 federationId,\r\n        string memory contentId\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n\r\n        // Minimal checks around federationId here in case\r\n        // other Federation registries wish to read from this one\r\n        require(federationId > 0, 'INVALID_FEDERATION_ID');\r\n\r\n        // Check tx.origin (vs msg.sender) since this *is likely* invoked by\r\n        // another contract\r\n        require(\r\n            isWhitelisted[tx.origin],\r\n            'INVALID_SENDER'\r\n        );\r\n\r\n        address registrantAddress = contentIdToAddress[contentId];\r\n\r\n        require(\r\n            registrantAddress == tx.origin,\r\n            'INVALID_SENDER'\r\n        );\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    function isMinter(\r\n        uint32 federationId,\r\n        address account\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n\r\n        // Minimal checks around federationId here in case\r\n        // other Federation registries wish to read from this one\r\n        require(federationId > 0, 'INVALID_FEDERATION_ID');\r\n\r\n        require(\r\n            isWhitelisted[account],\r\n            'INVALID_MINTER'\r\n        );\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    function isAuthorizedTransferFrom(\r\n        uint32 federationId,\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        address minter,\r\n        address owner\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n\r\n        // Minimal checks around federationId here in case\r\n        // other Federation registries wish to read from this one\r\n        require(federationId > 0, 'INVALID_FEDERATION_ID');\r\n\r\n        // The Minter must be whitelisted\r\n        require(\r\n            isWhitelisted[minter],\r\n            'INVALID_TRANSFER_MINTER'\r\n        );\r\n\r\n        require(\r\n            tokenId > 0,\r\n            'INVALID_TOKEN_ID'\r\n        );\r\n\r\n        require(\r\n            from != to,\r\n            'INVALID_TRANSFER'\r\n        );\r\n\r\n        require(\r\n            owner != address(0),\r\n            'INVALID_TRANSFER'\r\n        );\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n    /***  Helpers  ***/\r\n\r\n\r\n    function stringsMatch (\r\n        string memory a,\r\n        string memory b\r\n    )\r\n        private\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))) );\r\n    }\r\n\r\n\r\n    function getNumContentIds (\r\n        address target\r\n    )\r\n        private\r\n        view\r\n        returns (uint16)\r\n    {\r\n\r\n        ContentIdStruct[] memory m = addressToContentIds[target];\r\n        uint16 counter = 0;\r\n        for (uint i = 0; i < m.length; i++) {\r\n            // Omit entries that are empty strings\r\n            // (from contentIds that were removed by admin or user)\r\n            if (!stringsMatch('', m[i].contentId)) {\r\n                counter++;\r\n            }\r\n        }\r\n\r\n        return counter;\r\n\r\n    }\r\n\r\n\r\n    /*** Prevent Accidents! ***/\r\n\r\n\r\n    /// @notice No tipping!\r\n    /// @dev Reject all Ether from being sent here.\r\n    /// (Hopefully, we can prevent user accidents.)\r\n    ///  Hat-tip to Cryptokitties.\r\n    function() external payable {\r\n        require(\r\n            msg.sender == address(0)\r\n        );\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"getContentIdsByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"string[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"adminGetRegistrantByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"federationId\",\"type\":\"uint32\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"minter\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"isAuthorizedTransferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"federationId\",\"type\":\"uint32\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"removeAllContentIdsFromAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"registrant\",\"type\":\"address\"}],\"name\":\"getRegistrantToReferrer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"getReferrerToRegistrants\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"adminGetContentIdsByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"string[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"adminRemoveAllContentIdsFromAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contentId\",\"type\":\"string\"}],\"name\":\"getAddressByContentId\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contentId\",\"type\":\"string\"}],\"name\":\"adminGetAddressByContentId\",\"outputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRegistrantCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRegistrantByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"hasRegistered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"federationId\",\"type\":\"uint32\"},{\"name\":\"contentId\",\"type\":\"string\"}],\"name\":\"isContentIdRegisteredToCaller\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"registrant\",\"type\":\"address\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"adminUpdateReferrer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"registrantTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contentId\",\"type\":\"string\"}],\"name\":\"removeContentIdFromAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"contentId\",\"type\":\"string\"},{\"name\":\"isApproved\",\"type\":\"bool\"}],\"name\":\"adminUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"contentId\",\"type\":\"string\"}],\"name\":\"adminRemoveContentIdFromAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"isApproved\",\"type\":\"bool\"}],\"name\":\"adminUpdateWhitelistStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"contentId\",\"type\":\"string\"},{\"name\":\"isApproved\",\"type\":\"bool\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"adminUpdateWithReferrer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Registry","CompilerVersion":"v0.5.5+commit.47a71e8f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"byzantium","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://a529162f18f5d7ff18e455c541754a61772039075f32476783e37ea26fcb9a88"}]}