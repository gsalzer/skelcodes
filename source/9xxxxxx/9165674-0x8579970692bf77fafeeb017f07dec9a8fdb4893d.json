{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\n\ncontract IStructuredStorage {\n\n    function setProxyLogicContractAndDeployer(address _proxyLogicContract, address _deployer) external;\n    function setProxyLogicContract(address _proxyLogicContract) external;\n\n    // *** Getter Methods ***\n    function getUint(bytes32 _key) external view returns(uint);\n    function getString(bytes32 _key) external view returns(string);\n    function getAddress(bytes32 _key) external view returns(address);\n    function getBytes(bytes32 _key) external view returns(bytes);\n    function getBool(bytes32 _key) external view returns(bool);\n    function getInt(bytes32 _key) external view returns(int);\n    function getBytes32(bytes32 _key) external view returns(bytes32);\n\n    // *** Getter Methods For Arrays ***\n    function getBytes32Array(bytes32 _key) external view returns (bytes32[]);\n    function getAddressArray(bytes32 _key) external view returns (address[]);\n    function getUintArray(bytes32 _key) external view returns (uint[]);\n    function getIntArray(bytes32 _key) external view returns (int[]);\n    function getBoolArray(bytes32 _key) external view returns (bool[]);\n\n    // *** Setter Methods ***\n    function setUint(bytes32 _key, uint _value) external;\n    function setString(bytes32 _key, string _value) external;\n    function setAddress(bytes32 _key, address _value) external;\n    function setBytes(bytes32 _key, bytes _value) external;\n    function setBool(bytes32 _key, bool _value) external;\n    function setInt(bytes32 _key, int _value) external;\n    function setBytes32(bytes32 _key, bytes32 _value) external;\n\n    // *** Setter Methods For Arrays ***\n    function setBytes32Array(bytes32 _key, bytes32[] _value) external;\n    function setAddressArray(bytes32 _key, address[] _value) external;\n    function setUintArray(bytes32 _key, uint[] _value) external;\n    function setIntArray(bytes32 _key, int[] _value) external;\n    function setBoolArray(bytes32 _key, bool[] _value) external;\n\n    // *** Delete Methods ***\n    function deleteUint(bytes32 _key) external;\n    function deleteString(bytes32 _key) external;\n    function deleteAddress(bytes32 _key) external;\n    function deleteBytes(bytes32 _key) external;\n    function deleteBool(bytes32 _key) external;\n    function deleteInt(bytes32 _key) external;\n    function deleteBytes32(bytes32 _key) external;\n}\n\ncontract ITwoKeySingletoneRegistryFetchAddress {\n    function getContractProxyAddress(string _contractName) public view returns (address);\n    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n    function getLatestCampaignApprovedVersion(string campaignType) public view returns (string);\n}\n\ninterface ITwoKeySingletonesRegistry {\n\n    /**\n    * @dev This event will be emitted every time a new proxy is created\n    * @param proxy representing the address of the proxy created\n    */\n    event ProxyCreated(address proxy);\n\n\n    /**\n    * @dev This event will be emitted every time a new implementation is registered\n    * @param version representing the version name of the registered implementation\n    * @param implementation representing the address of the registered implementation\n    * @param contractName is the name of the contract we added new version\n    */\n    event VersionAdded(string version, address implementation, string contractName);\n\n    /**\n    * @dev Registers a new version with its implementation address\n    * @param version representing the version name of the new implementation to be registered\n    * @param implementation representing the address of the new implementation to be registered\n    */\n    function addVersion(string _contractName, string version, address implementation) public;\n\n    /**\n    * @dev Tells the address of the implementation for a given version\n    * @param _contractName is the name of the contract we're querying\n    * @param version to query the implementation of\n    * @return address of the implementation registered for the given version\n    */\n    function getVersion(string _contractName, string version) public view returns (address);\n}\n\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    require(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    require(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    require(c >= _a);\n    return c;\n  }\n}\n\ncontract UpgradeabilityStorage {\n    // Versions registry\n    ITwoKeySingletonesRegistry internal registry;\n\n    // Address of the current implementation\n    address internal _implementation;\n\n    /**\n    * @dev Tells the address of the current implementation\n    * @return address of the current implementation\n    */\n    function implementation() public view returns (address) {\n        return _implementation;\n    }\n}\n\ncontract Upgradeable is UpgradeabilityStorage {\n    /**\n     * @dev Validates the caller is the versions registry.\n     * @param sender representing the address deploying the initial behavior of the contract\n     */\n    function initialize(address sender) public payable {\n        require(msg.sender == address(registry));\n    }\n}\n\ncontract TwoKeyMaintainersRegistryAbstract is Upgradeable {\n    /**\n     * All keys used for the storage contract.\n     * Saved as a constants to avoid any potential typos\n     */\n    string constant _isMaintainer = \"isMaintainer\";\n    string constant _isCoreDev = \"isCoreDev\";\n    string constant _idToMaintainer = \"idToMaintainer\";\n    string constant _idToCoreDev = \"idToCoreDev\";\n    string constant _numberOfMaintainers = \"numberOfMaintainers\";\n    string constant _numberOfCoreDevs = \"numberOfCoreDevs\";\n    string constant _numberOfActiveMaintainers = \"numberOfActiveMaintainers\";\n    string constant _numberOfActiveCoreDevs = \"numberOfActiveCoreDevs\";\n\n    //For all math operations we use safemath\n    using SafeMath for *;\n\n    // Flag which will make function setInitialParams callable only once\n    bool initialized;\n\n    address public TWO_KEY_SINGLETON_REGISTRY;\n\n    IStructuredStorage public PROXY_STORAGE_CONTRACT;\n\n\n    /**\n     * @notice Function which can be called only once, and is used as replacement for a constructor\n     * @param _twoKeySingletonRegistry is the address of TWO_KEY_SINGLETON_REGISTRY contract\n     * @param _proxyStorage is the address of proxy of storage contract\n     * @param _maintainers is the array of initial maintainers we'll kick off contract with\n     */\n    function setInitialParams(\n        address _twoKeySingletonRegistry,\n        address _proxyStorage,\n        address [] _maintainers,\n        address [] _coreDevs\n    )\n    public\n    {\n        require(initialized == false);\n\n        TWO_KEY_SINGLETON_REGISTRY = _twoKeySingletonRegistry;\n\n        PROXY_STORAGE_CONTRACT = IStructuredStorage(_proxyStorage);\n\n        //Deployer is also maintainer\n        addMaintainer(msg.sender);\n\n        //Set initial maintainers\n        for(uint i=0; i<_maintainers.length; i++) {\n            addMaintainer(_maintainers[i]);\n        }\n\n        //Set initial core devs\n        for(uint j=0; j<_coreDevs.length; j++) {\n            addCoreDev(_coreDevs[j]);\n        }\n\n        //Once this executes, this function will not be possible to call again.\n        initialized = true;\n    }\n\n\n    /**\n     * @notice Function which will determine if address is maintainer\n     */\n    function checkIsAddressMaintainer(address _sender) public view returns (bool) {\n        return isMaintainer(_sender);\n    }\n\n    /**\n     * @notice Function which will determine if address is core dev\n     */\n    function checkIsAddressCoreDev(address _sender) public view returns (bool) {\n        return isCoreDev(_sender);\n    }\n\n    /**\n     * @notice Function to get all maintainers set DURING CAMPAIGN CREATION\n     */\n    function getAllMaintainers()\n    public\n    view\n    returns (address[])\n    {\n        uint numberOfMaintainersTotal = getNumberOfMaintainers();\n        uint numberOfActiveMaintainers = getNumberOfActiveMaintainers();\n        address [] memory activeMaintainers = new address[](numberOfActiveMaintainers);\n\n        uint counter = 0;\n        for(uint i=0; i<numberOfMaintainersTotal; i++) {\n            address maintainer = getMaintainerPerId(i);\n            if(isMaintainer(maintainer)) {\n                activeMaintainers[counter] = maintainer;\n                counter = counter.add(1);\n            }\n        }\n        return activeMaintainers;\n    }\n\n\n    /**\n     * @notice Function to get all maintainers set DURING CAMPAIGN CREATION\n     */\n    function getAllCoreDevs()\n    public\n    view\n    returns (address[])\n    {\n        uint numberOfCoreDevsTotal = getNumberOfCoreDevs();\n        uint numberOfActiveCoreDevs = getNumberOfActiveCoreDevs();\n        address [] memory activeCoreDevs = new address[](numberOfActiveCoreDevs);\n\n        uint counter = 0;\n        for(uint i=0; i<numberOfActiveCoreDevs; i++) {\n            address coreDev= getCoreDevPerId(i);\n            if(isCoreDev(coreDev)) {\n                activeCoreDevs[counter] = coreDev;\n                counter = counter.add(1);\n            }\n        }\n        return activeCoreDevs;\n    }\n\n    /**\n     * @notice Function to check if address is maintainer\n     * @param _address is the address we're checking if it's maintainer or not\n     */\n    function isMaintainer(\n        address _address\n    )\n    internal\n    view\n    returns (bool)\n    {\n        bytes32 keyHash = keccak256(_isMaintainer, _address);\n        return PROXY_STORAGE_CONTRACT.getBool(keyHash);\n    }\n\n    /**\n     * @notice Function to check if address is coreDev\n     * @param _address is the address we're checking if it's coreDev or not\n     */\n    function isCoreDev(\n        address _address\n    )\n    internal\n    view\n    returns (bool)\n    {\n        bytes32 keyHash = keccak256(_isCoreDev, _address);\n        return PROXY_STORAGE_CONTRACT.getBool(keyHash);\n    }\n\n    /**\n     * @notice Function which will add maintainer\n     * @param _maintainer is the address of new maintainer we're adding\n     */\n    function addMaintainer(\n        address _maintainer\n    )\n    internal\n    {\n\n        bytes32 keyHashIsMaintainer = keccak256(_isMaintainer, _maintainer);\n\n        // Fetch the id for the new maintainer\n        uint id = getNumberOfMaintainers();\n\n        // Generate keyHash for this maintainer\n        bytes32 keyHashIdToMaintainer = keccak256(_idToMaintainer, id);\n\n        // Representing number of different maintainers\n        incrementNumberOfMaintainers();\n        // Representing number of currently active maintainers\n        incrementNumberOfActiveMaintainers();\n\n        PROXY_STORAGE_CONTRACT.setAddress(keyHashIdToMaintainer, _maintainer);\n        PROXY_STORAGE_CONTRACT.setBool(keyHashIsMaintainer, true);\n    }\n\n\n    /**\n     * @notice Function which will add maintainer\n     * @param _coreDev is the address of new maintainer we're adding\n     */\n    function addCoreDev(\n        address _coreDev\n    )\n    internal\n    {\n\n        bytes32 keyHashIsCoreDev = keccak256(_isCoreDev, _coreDev);\n\n        // Fetch the id for the new core dev\n        uint id = getNumberOfCoreDevs();\n\n        // Generate keyHash for this core dev\n        bytes32 keyHashIdToCoreDev= keccak256(_idToCoreDev, id);\n\n        // Representing number of different core devs\n        incrementNumberOfCoreDevs();\n        // Representing number of currently active core devs\n        incrementNumberOfActiveCoreDevs();\n\n        PROXY_STORAGE_CONTRACT.setAddress(keyHashIdToCoreDev, _coreDev);\n        PROXY_STORAGE_CONTRACT.setBool(keyHashIsCoreDev, true);\n    }\n\n    /**\n     * @notice Function which will remove maintainer\n     * @param _maintainer is the address of the maintainer we're removing\n     */\n    function removeMaintainer(\n        address _maintainer\n    )\n    internal\n    {\n        bytes32 keyHashIsMaintainer = keccak256(_isMaintainer, _maintainer);\n        decrementNumberOfActiveMaintainers();\n        PROXY_STORAGE_CONTRACT.setBool(keyHashIsMaintainer, false);\n    }\n\n    /**\n     * @notice Function which will remove maintainer\n     * @param _coreDev is the address of the maintainer we're removing\n     */\n    function removeCoreDev(\n        address _coreDev\n    )\n    internal\n    {\n        bytes32 keyHashIsCoreDev = keccak256(_isCoreDev , _coreDev);\n        decrementNumberOfActiveCoreDevs();\n        PROXY_STORAGE_CONTRACT.setBool(keyHashIsCoreDev, false);\n    }\n\n    function getNumberOfMaintainers()\n    public\n    view\n    returns (uint)\n    {\n        return PROXY_STORAGE_CONTRACT.getUint(keccak256(_numberOfMaintainers));\n    }\n\n    function getNumberOfCoreDevs()\n    public\n    view\n    returns (uint)\n    {\n        return PROXY_STORAGE_CONTRACT.getUint(keccak256(_numberOfCoreDevs));\n    }\n\n    function getNumberOfActiveMaintainers()\n    public\n    view\n    returns (uint)\n    {\n        return PROXY_STORAGE_CONTRACT.getUint(keccak256(_numberOfActiveMaintainers));\n    }\n\n    function getNumberOfActiveCoreDevs()\n    public\n    view\n    returns (uint)\n    {\n        return PROXY_STORAGE_CONTRACT.getUint(keccak256(_numberOfActiveCoreDevs));\n    }\n\n\n    function incrementNumberOfMaintainers()\n    internal\n    {\n        bytes32 keyHashNumberOfMaintainers = keccak256(_numberOfMaintainers);\n        PROXY_STORAGE_CONTRACT.setUint(\n            keyHashNumberOfMaintainers,\n            PROXY_STORAGE_CONTRACT.getUint(keyHashNumberOfMaintainers).add(1)\n        );\n    }\n\n\n    function incrementNumberOfCoreDevs()\n    internal\n    {\n        bytes32 keyHashNumberOfCoreDevs = keccak256(_numberOfCoreDevs);\n        PROXY_STORAGE_CONTRACT.setUint(\n            keyHashNumberOfCoreDevs,\n            PROXY_STORAGE_CONTRACT.getUint(keyHashNumberOfCoreDevs).add(1)\n        );\n    }\n\n\n    function incrementNumberOfActiveMaintainers()\n    internal\n    {\n        bytes32 keyHashNumberOfActiveMaintainers = keccak256(_numberOfActiveMaintainers);\n        PROXY_STORAGE_CONTRACT.setUint(\n            keyHashNumberOfActiveMaintainers,\n            PROXY_STORAGE_CONTRACT.getUint(keyHashNumberOfActiveMaintainers).add(1)\n        );\n    }\n\n    function incrementNumberOfActiveCoreDevs()\n    internal\n    {\n        bytes32 keyHashNumberToActiveCoreDevs= keccak256(_numberOfActiveCoreDevs);\n        PROXY_STORAGE_CONTRACT.setUint(\n            keyHashNumberToActiveCoreDevs,\n            PROXY_STORAGE_CONTRACT.getUint(keyHashNumberToActiveCoreDevs).add(1)\n        );\n    }\n\n    function decrementNumberOfActiveMaintainers()\n    internal\n    {\n        bytes32 keyHashNumberOfActiveMaintainers = keccak256(_numberOfActiveMaintainers);\n        PROXY_STORAGE_CONTRACT.setUint(\n            keyHashNumberOfActiveMaintainers,\n            PROXY_STORAGE_CONTRACT.getUint(keyHashNumberOfActiveMaintainers).sub(1)\n        );\n    }\n\n    function decrementNumberOfActiveCoreDevs()\n    internal\n    {\n        bytes32 keyHashNumberToActiveCoreDevs = keccak256(_numberOfActiveCoreDevs);\n        PROXY_STORAGE_CONTRACT.setUint(\n            keyHashNumberToActiveCoreDevs,\n            PROXY_STORAGE_CONTRACT.getUint(keyHashNumberToActiveCoreDevs).sub(1)\n        );\n    }\n\n    function getMaintainerPerId(\n        uint _id\n    )\n    public\n    view\n    returns (address)\n    {\n        return PROXY_STORAGE_CONTRACT.getAddress(keccak256(_idToMaintainer,_id));\n    }\n\n\n    function getCoreDevPerId(\n        uint _id\n    )\n    public\n    view\n    returns (address)\n    {\n        return PROXY_STORAGE_CONTRACT.getAddress(keccak256(_idToCoreDev,_id));\n    }\n\n\n    // Internal function to fetch address from TwoKeyRegistry\n    function getAddressFromTwoKeySingletonRegistry(string contractName) internal view returns (address) {\n        return ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY)\n        .getContractProxyAddress(contractName);\n    }\n\n}\n\ncontract TwoKeyMaintainersRegistry is TwoKeyMaintainersRegistryAbstract {\n    /**\n     * @notice Modifier to restrict calling the method to anyone but twoKeyAdmin\n     */\n    modifier onlyTwoKeyAdmin() {\n        address twoKeyAdmin = getAddressFromTwoKeySingletonRegistry(\"TwoKeyAdmin\");\n        require(msg.sender == address(twoKeyAdmin));\n        _;\n    }\n\n    /**\n     * @notice Function which can add new maintainers, in general it's array because this supports adding multiple addresses in 1 trnx\n     * @dev only twoKeyAdmin contract is eligible to mutate state of maintainers\n     * @param _maintainers is the array of maintainer addresses\n     */\n    function addMaintainers(\n        address [] _maintainers\n    )\n    public\n    onlyTwoKeyAdmin\n    {\n        uint numberOfMaintainersToAdd = _maintainers.length;\n        for(uint i=0; i<numberOfMaintainersToAdd; i++) {\n            addMaintainer(_maintainers[i]);\n        }\n    }\n\n    /**\n     * @notice Function which can add new core devs, in general it's array because this supports adding multiple addresses in 1 trnx\n     * @dev only twoKeyAdmin contract is eligible to mutate state of core devs\n     * @param _coreDevs is the array of core developer addresses\n     */\n    function addCoreDevs(\n        address [] _coreDevs\n    )\n    public\n    onlyTwoKeyAdmin\n    {\n        uint numberOfCoreDevsToAdd = _coreDevs.length;\n        for(uint i=0; i<numberOfCoreDevsToAdd; i++) {\n            addCoreDev(_coreDevs[i]);\n        }\n    }\n\n    /**\n     * @notice Function which can remove some maintainers, in general it's array because this supports adding multiple addresses in 1 trnx\n     * @dev only twoKeyAdmin contract is eligible to mutate state of maintainers\n     * @param _maintainers is the array of maintainer addresses\n     */\n    function removeMaintainers(\n        address [] _maintainers\n    )\n    public\n    onlyTwoKeyAdmin\n    {\n        //If state variable, .balance, or .length is used several times, holding its value in a local variable is more gas efficient.\n        uint numberOfMaintainers = _maintainers.length;\n\n        for(uint i=0; i<numberOfMaintainers; i++) {\n            removeMaintainer(_maintainers[i]);\n        }\n    }\n\n    /**\n     * @notice Function which can remove some maintainers, in general it's array because this supports adding multiple addresses in 1 trnx\n     * @dev only twoKeyAdmin contract is eligible to mutate state of maintainers\n     * @param _coreDevs is the array of maintainer addresses\n     */\n    function removeCoreDevs(\n        address [] _coreDevs\n    )\n    public\n    onlyTwoKeyAdmin\n    {\n        //If state variable, .balance, or .length is used several times, holding its value in a local variable is more gas efficient.\n        uint numberOfCoreDevs = _coreDevs.length;\n\n        for(uint i=0; i<numberOfCoreDevs; i++) {\n            removeCoreDev(_coreDevs[i]);\n        }\n    }\n\n\n}\n\n","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"PROXY_STORAGE_CONTRACT\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maintainers\",\"type\":\"address[]\"}],\"name\":\"addMaintainers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_coreDevs\",\"type\":\"address[]\"}],\"name\":\"addCoreDevs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllCoreDevs\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getCoreDevPerId\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllMaintainers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_twoKeySingletonRegistry\",\"type\":\"address\"},{\"name\":\"_proxyStorage\",\"type\":\"address\"},{\"name\":\"_maintainers\",\"type\":\"address[]\"},{\"name\":\"_coreDevs\",\"type\":\"address[]\"}],\"name\":\"setInitialParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"checkIsAddressMaintainer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maintainers\",\"type\":\"address[]\"}],\"name\":\"removeMaintainers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumberOfCoreDevs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumberOfMaintainers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TWO_KEY_SINGLETON_REGISTRY\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getMaintainerPerId\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_coreDevs\",\"type\":\"address[]\"}],\"name\":\"removeCoreDevs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumberOfActiveMaintainers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"checkIsAddressCoreDev\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumberOfActiveCoreDevs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TwoKeyMaintainersRegistry","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}