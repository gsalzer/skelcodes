{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Tether trading contract\r\n*/\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract USDT_Initializable {\r\n  bool private initialized;\r\n  bool private initializing;\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n    _;\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  function isConstructor() private view returns (bool) {\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  uint256[50] private ______gap;\r\n}\r\n\r\ncontract LocalCoinSwapTetherEscrow is USDT_Initializable {\r\n    /***********************\r\n    +   Global settings   +\r\n    ***********************/\r\n\r\n    address public arbitrator;\r\n    address public owner;\r\n    address public relayer;\r\n    uint256 public feesAvailableForWithdraw;\r\n    // The contract address of the ERC20 token handled by this smart contract, can only be set once\r\n    TetherERC20 public tokenContract;\r\n    // The minimum value under which we will not accept the creation of escrow\r\n    uint16 public minimumValue = 1;\r\n    uint32 public requestCancellationMinimumTime = 2 hours;\r\n\r\n    /***********************\r\n    +   Escrow Structure   +\r\n    ***********************/\r\n\r\n    struct Escrow {\r\n        // Set so we know the trade has already been created\r\n        bool exists;\r\n        uint32 sellerCanCancelAfter;\r\n        // The total cost of gas spent by relaying parties. This amount will be\r\n        //   emmitted to us once the escrow is finished for accounting purposes.\r\n        uint128 totalGasFeesSpentByRelayer;\r\n    }\r\n    // Mapping of active trades. Key is a hash of the trade data\r\n    mapping (bytes32 => Escrow) public escrows;\r\n\r\n    /***********************\r\n    +  Instruction types  +\r\n    ***********************/\r\n\r\n    // Called when the buyer marks payment as sent. Locks funds in escrow\r\n    uint8 constant INSTRUCTION_SELLER_CANNOT_CANCEL = 0x01;\r\n    // Buyer cancelling\r\n    uint8 constant INSTRUCTION_BUYER_CANCEL = 0x02;\r\n    // Seller cancelling\r\n    uint8 constant INSTRUCTION_SELLER_CANCEL = 0x03;\r\n    // Seller requesting to cancel. Begins a window for buyer to object\r\n    uint8 constant INSTRUCTION_SELLER_REQUEST_CANCEL = 0x04;\r\n    // Seller releasing funds to the buyer\r\n    uint8 constant INSTRUCTION_RELEASE = 0x05;\r\n    // Either party permitting the arbitrator to resolve a dispute\r\n    uint8 constant INSTRUCTION_RESOLVE = 0x06;\r\n\r\n    /***********************\r\n    +       Events        +\r\n    ***********************/\r\n\r\n    event Created(bytes32 _tradeHash);\r\n    event SellerCancelDisabled(bytes32 _tradeHash);\r\n    event SellerRequestedCancel(bytes32 _tradeHash);\r\n    event CancelledBySeller(bytes32 _tradeHash, uint128 totalGasFeesSpentByRelayer);\r\n    event CancelledByBuyer(bytes32 _tradeHash, uint128 totalGasFeesSpentByRelayer);\r\n    event Released(bytes32 _tradeHash, uint128 totalGasFeesSpentByRelayer);\r\n    event DisputeResolved(bytes32 _tradeHash, uint128 totalGasFeesSpentByRelayer);\r\n\r\n    /***********************\r\n    +     Initializer      +\r\n    ***********************/\r\n\r\n    function initialize(address initialOwner, TetherERC20 contractAddress\r\n    ) public initializer {\r\n        owner = initialOwner;\r\n        arbitrator = initialOwner;\r\n        relayer = initialOwner;\r\n        requestCancellationMinimumTime = 2 hours;\r\n        tokenContract = contractAddress;\r\n        minimumValue = 1;\r\n    }\r\n\r\n    /***********************\r\n    +    Handle Trades     +\r\n    ***********************/\r\n\r\n    /// @notice Create and fund a new escrow.\r\n    /// @param _tradeID The unique ID of the trade, generated by localcoinswap.com\r\n    /// @param _seller The selling party\r\n    /// @param _buyer The buying party\r\n    /// @param _value The amount of the escrow, exclusive of the fee\r\n    /// @param _fee localcoinswap's commission in 1/10000ths\r\n    /// @param _paymentWindowInSeconds The time in seconds from escrow creation that the seller can cancel after\r\n    /// @param _expiry This transaction must be created before this time\r\n    /// @param _v Signature \"v\" component\r\n    /// @param _r Signature \"r\" component\r\n    /// @param _s Signature \"s\" component\r\n    function createEscrow(\r\n      /**\r\n       * Create a new escrow and add it to `escrows`.\r\n       * _tradeHash is created by hashing _tradeID, _seller, _buyer, _value and _fee variables. These variables must be supplied on future contract calls.\r\n       * v, r and s is the signature data supplied from the api. The sig is keccak256(_tradeHash, _paymentWindowInSeconds, _expiry).\r\n       */\r\n      bytes16 _tradeID, // The unique ID of the trade, generated by us\r\n      address _seller, // The selling party of the trade\r\n      address _buyer, // The buying party of the trade\r\n      uint256 _value, // The token amount being held in escrow\r\n      uint16 _fee, // Our fee in 1/10000ths of a token\r\n      uint32 _paymentWindowInSeconds, // The time in seconds from contract creation that the buyer has to mark as paid\r\n      uint32 _expiry, // Provided by us. This transaction must be created before this time.\r\n      uint8 _v, // Signature value\r\n      bytes32 _r, // Signature value\r\n      bytes32 _s // Signature value\r\n    ) external payable {\r\n        bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeID, _seller, _buyer, _value, _fee));\r\n        require(!escrows[_tradeHash].exists, \"Trade already exists in escrow mapping\");\r\n        bytes32 _invitationHash = keccak256(abi.encodePacked(\r\n            _tradeHash,\r\n            _paymentWindowInSeconds,\r\n            _expiry\r\n        ));\r\n        require(_value > minimumValue, \"Escrow value must be greater than minimum value\"); // Check escrow value is greater than minimum value\r\n        require(block.timestamp < _expiry, \"Trade has already expired\"); // solium-disable-line\r\n        require(recoverAddress(_invitationHash, _v, _r, _s) == relayer, \"Transaction signature did not come from relayer\");\r\n        tokenContract.transferFrom(msg.sender, address(this), _value);\r\n        uint32 _sellerCanCancelAfter = _paymentWindowInSeconds == 0 ? 1 : uint32(block.timestamp) + _paymentWindowInSeconds; // solium-disable-line\r\n        escrows[_tradeHash] = Escrow(true, _sellerCanCancelAfter, 0);\r\n        emit Created(_tradeHash);\r\n    }\r\n\r\n    /// @notice Release ether in escrow to the buyer. Direct call option.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @return bool\r\n    function release(\r\n        bytes16 _tradeID,\r\n        address payable _seller,\r\n        address payable _buyer,\r\n        uint256 _value,\r\n        uint16 _fee\r\n    ) external returns (bool){\r\n        require(msg.sender == _seller, \"Must be seller\");\r\n        return doRelease(_tradeID, _seller, _buyer, _value, _fee, 0);\r\n    }\r\n\r\n    uint16 constant GAS_doRelease = 46588;\r\n    /// @notice Release escrow to the buyer. This completes it and removes it from the mapping.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @param _additionalGas Additional gas to be deducted after this operation\r\n    /// @return bool\r\n    function doRelease(\r\n        bytes16 _tradeID,\r\n        address payable _seller,\r\n        address payable _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        Escrow memory _escrow;\r\n        bytes32 _tradeHash;\r\n        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        if (!_escrow.exists) return false;\r\n        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer\r\n                ? (GAS_doRelease + _additionalGas ) * uint128(tx.gasprice)\r\n                : 0\r\n            );\r\n        delete escrows[_tradeHash];\r\n        emit Released(_tradeHash, _gasFees);\r\n        transferMinusFees(_buyer, _value, _fee);\r\n        return true;\r\n    }\r\n\r\n    uint16 constant GAS_doResolveDispute = 36100;\r\n    /// @notice Called by the arbitrator to resolve a dispute. Requires a signature from either party.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @param _v Signature \"v\" component\r\n    /// @param _r Signature \"r\" component\r\n    /// @param _s Signature \"s\" component\r\n    /// @param _buyerPercent What % should be distributed to the buyer (this is usually 0 or 100)\r\n    function resolveDispute(\r\n        bytes16 _tradeID,\r\n        address payable _seller,\r\n        address payable _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        uint8 _buyerPercent\r\n    ) external onlyArbitrator {\r\n        address _signature = recoverAddress(keccak256(abi.encodePacked(\r\n            _tradeID,\r\n            INSTRUCTION_RESOLVE\r\n        )), _v, _r, _s);\r\n        require(_signature == _buyer || _signature == _seller, \"Must be buyer or seller\");\r\n\r\n        Escrow memory _escrow;\r\n        bytes32 _tradeHash;\r\n        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        require(_escrow.exists, \"Escrow does not exist\");\r\n        require(_buyerPercent <= 100, \"_buyerPercent must be 100 or lower\");\r\n\r\n        _escrow.totalGasFeesSpentByRelayer += (GAS_doResolveDispute * uint128(tx.gasprice));\r\n\r\n        delete escrows[_tradeHash];\r\n        emit DisputeResolved(_tradeHash, _escrow.totalGasFeesSpentByRelayer);\r\n        if (_buyerPercent > 0) {\r\n          // If dispute goes to buyer take the fee\r\n          uint256 _totalFees = (_value * _fee / 10000);\r\n          // Prevent underflow\r\n          require(_value * _buyerPercent / 100 - _totalFees <= _value, \"Overflow error\");\r\n          feesAvailableForWithdraw += _totalFees;\r\n          tokenContract.transfer(_buyer, _value * _buyerPercent / 100 - _totalFees);\r\n        }\r\n        if (_buyerPercent < 100) {\r\n          tokenContract.transfer(_seller, _value * (100 - _buyerPercent) / 100);\r\n        }\r\n    }\r\n\r\n    /// @notice Disable the seller from cancelling (i.e. \"mark as paid\"). Direct call option.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @return bool\r\n    function disableSellerCancel(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee\r\n    ) external returns (bool) {\r\n        require(msg.sender == _buyer, \"Must be buyer\");\r\n        return doDisableSellerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\r\n    }\r\n\r\n    /// @notice Cancel the escrow as a buyer. Direct call option.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @return bool\r\n    function buyerCancel(\r\n      bytes16 _tradeID,\r\n      address payable _seller,\r\n      address payable _buyer,\r\n      uint256 _value,\r\n      uint16 _fee\r\n    ) external returns (bool) {\r\n        require(msg.sender == _buyer, \"Must be buyer\");\r\n        return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\r\n    }\r\n\r\n    /// @notice Request to cancel as a seller. Direct call option.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @return bool\r\n    function sellerRequestCancel(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee\r\n    ) external returns (bool) {\r\n        require(msg.sender == _seller, \"Must be seller\");\r\n        return doSellerRequestCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\r\n    }\r\n\r\n    /// @notice Increase the amount of gas used during the trade, tracking is for accounting purposes\r\n    /// @param _tradeHash Trade hash\r\n    /// @param _gas Gas cost\r\n    function increaseGasSpent(bytes32 _tradeHash, uint128 _gas) private {\r\n        escrows[_tradeHash].totalGasFeesSpentByRelayer += _gas * uint128(tx.gasprice);\r\n    }\r\n\r\n    /// @notice Transfer the value of an escrow, minus the fees. We do not explicity handle gas costs of relayer\r\n    /// @param _to Recipient address\r\n    /// @param _value Value of the transfer\r\n    /// @param _fee Commission in 1/10000ths\r\n    function transferMinusFees(\r\n        address payable _to,\r\n        uint256 _value,\r\n        uint16 _fee\r\n    ) private {\r\n        uint256 _totalFees = (_value * _fee / 10000);\r\n        // Prevent underflow\r\n        if(_value - _totalFees > _value) {\r\n            return;\r\n        }\r\n        // Add fees to the pot for localcoinswap to withdraw\r\n        feesAvailableForWithdraw += _totalFees;\r\n        tokenContract.transfer(_to, _value - _totalFees);\r\n    }\r\n\r\n    uint16 constant GAS_doDisableSellerCancel = 28944;\r\n    /// @notice Prevents the seller from cancelling an escrow. Used to \"mark as paid\" by the buyer.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @param _additionalGas Additional gas to be deducted after this operation\r\n    /// @return bool\r\n    function doDisableSellerCancel(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        Escrow memory _escrow;\r\n        bytes32 _tradeHash;\r\n        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        if (!_escrow.exists) return false;\r\n        if(_escrow.sellerCanCancelAfter == 0) return false;\r\n        escrows[_tradeHash].sellerCanCancelAfter = 0;\r\n        emit SellerCancelDisabled(_tradeHash);\r\n        if (msg.sender == relayer) {\r\n          increaseGasSpent(_tradeHash, GAS_doDisableSellerCancel + _additionalGas);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    uint16 constant GAS_doBuyerCancel = 46255;\r\n    /// @notice Cancels the trade and returns the ether to the seller. Can only be called the buyer.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @param _additionalGas Additional gas to be deducted after this operation\r\n    /// @return bool\r\n    function doBuyerCancel(\r\n        bytes16 _tradeID,\r\n        address payable _seller,\r\n        address payable _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        Escrow memory _escrow;\r\n        bytes32 _tradeHash;\r\n        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        require(_escrow.exists, \"Escrow does not exist\");\r\n        if (!_escrow.exists) {\r\n            return false;\r\n        }\r\n        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer\r\n                ? (GAS_doBuyerCancel + _additionalGas ) * uint128(tx.gasprice)\r\n                : 0\r\n            );\r\n        delete escrows[_tradeHash];\r\n        emit CancelledByBuyer(_tradeHash, _gasFees);\r\n        transferMinusFees(_seller, _value, 0);\r\n        return true;\r\n    }\r\n\r\n    uint16 constant GAS_doSellerCancel = 46815;\r\n    /// @notice Returns the ether in escrow to the seller. Called by the seller. Sometimes unavailable.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @param _additionalGas Additional gas to be deducted after this operation\r\n    /// @return bool\r\n    function doSellerCancel(\r\n        bytes16 _tradeID,\r\n        address payable _seller,\r\n        address payable _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        Escrow memory _escrow;\r\n        bytes32 _tradeHash;\r\n        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        if (!_escrow.exists) {\r\n            return false;\r\n        }\r\n        if(_escrow.sellerCanCancelAfter <= 1 || _escrow.sellerCanCancelAfter > block.timestamp) { // solium-disable-line\r\n            return false;\r\n        }\r\n        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer\r\n                ? (GAS_doSellerCancel + _additionalGas ) * uint128(tx.gasprice)\r\n                : 0\r\n            );\r\n        delete escrows[_tradeHash];\r\n        emit CancelledBySeller(_tradeHash, _gasFees);\r\n        transferMinusFees(_seller, _value, 0);\r\n        return true;\r\n    }\r\n\r\n    uint16 constant GAS_doSellerRequestCancel = 29507;\r\n    /// @notice Request to cancel. Used if the buyer is unresponsive. Begins a countdown timer.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @param _additionalGas Additional gas to be deducted after this operation\r\n    /// @return bool\r\n    function doSellerRequestCancel(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        // Called on unlimited payment window trades where the buyer is not responding\r\n        Escrow memory _escrow;\r\n        bytes32 _tradeHash;\r\n        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        if (!_escrow.exists) {\r\n            return false;\r\n        }\r\n        if(_escrow.sellerCanCancelAfter != 1) {\r\n            return false;\r\n        }\r\n        escrows[_tradeHash].sellerCanCancelAfter = uint32(block.timestamp) // solium-disable-line\r\n            + requestCancellationMinimumTime;\r\n        emit SellerRequestedCancel(_tradeHash);\r\n        if (msg.sender == relayer) {\r\n          increaseGasSpent(_tradeHash, GAS_doSellerRequestCancel + _additionalGas);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /***********************\r\n    +        Relays        +\r\n    ***********************/\r\n\r\n    /// @notice Relay multiple signed instructions from parties of escrows.\r\n    /// @param _tradeID List of _tradeID values\r\n    /// @param _seller List of _seller values\r\n    /// @param _buyer List of _buyer values\r\n    /// @param _value List of _value values\r\n    /// @param _fee List of _fee values\r\n    /// @param _maximumGasPrice List of _maximumGasPrice values\r\n    /// @param _v List of signature \"v\" components\r\n    /// @param _r List of signature \"r\" components\r\n    /// @param _s List of signature \"s\" components\r\n    /// @param _instructionByte List of _instructionByte values\r\n    /// @return bool List of results\r\n    uint16 constant GAS_batchRelayBaseCost = 28500;\r\n    function batchRelay(\r\n        bytes16[] memory _tradeID,\r\n        address payable[] memory _seller,\r\n        address payable[] memory _buyer,\r\n        uint256[] memory _value,\r\n        uint16[] memory _fee,\r\n        uint128[] memory _maximumGasPrice,\r\n        uint8[] memory _v,\r\n        bytes32[] memory _r,\r\n        bytes32[] memory _s,\r\n        uint8[] memory _instructionByte\r\n    ) public returns (bool[] memory) {\r\n        bool[] memory _results = new bool[](_tradeID.length);\r\n        uint128 _additionalGas = uint128(msg.sender == relayer ? GAS_batchRelayBaseCost / _tradeID.length : 0);\r\n        for (uint8 i = 0; i < _tradeID.length; i++) {\r\n            _results[i] = relay(\r\n                _tradeID[i],\r\n                _seller[i],\r\n                _buyer[i],\r\n                _value[i],\r\n                _fee[i],\r\n                _maximumGasPrice[i],\r\n                _v[i],\r\n                _r[i],\r\n                _s[i],\r\n                _instructionByte[i],\r\n                _additionalGas\r\n            );\r\n        }\r\n        return _results;\r\n    }\r\n\r\n    /// @notice Relay a signed instruction from a party of an escrow.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @param _maximumGasPrice Maximum gas price permitted for the relayer (set by the instructor)\r\n    /// @param _v Signature \"v\" component\r\n    /// @param _r Signature \"r\" component\r\n    /// @param _s Signature \"s\" component\r\n    /// @param _additionalGas Additional gas to be deducted after this operation\r\n    /// @return bool\r\n    function relay(\r\n        bytes16 _tradeID,\r\n        address payable _seller,\r\n        address payable _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint128 _maximumGasPrice,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        uint8 _instructionByte,\r\n        uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        address _relayedSender = getRelayedSender(\r\n            _tradeID,\r\n            _instructionByte,\r\n            _maximumGasPrice,\r\n            _v,\r\n            _r,\r\n            _s\r\n        );\r\n        if (_relayedSender == _buyer) {\r\n            // Buyer's instructions:\r\n            if (_instructionByte == INSTRUCTION_SELLER_CANNOT_CANCEL) {\r\n                // Disable seller from cancelling\r\n                return doDisableSellerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\n            } else if (_instructionByte == INSTRUCTION_BUYER_CANCEL) {\r\n                // Cancel\r\n                return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\n            }\r\n        } else if (_relayedSender == _seller) {\r\n            // Seller's instructions:\r\n            if (_instructionByte == INSTRUCTION_RELEASE) {\r\n                // Release\r\n                return doRelease(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\n            } else if (_instructionByte == INSTRUCTION_SELLER_CANCEL) {\r\n                // Cancel\r\n                return doSellerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\n            } else if (_instructionByte == INSTRUCTION_SELLER_REQUEST_CANCEL){\r\n                // Request to cancel\r\n                return doSellerRequestCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\n            }\r\n        } else {\r\n            require(msg.sender == _seller, \"Unrecognised party\");\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /***********************\r\n    +        Setters       +\r\n    ***********************/\r\n\r\n    /// @notice Set the arbitrator to a new address. Only the owner can call this.\r\n    /// @param _newArbitrator Address of the replacement arbitrator\r\n    function setArbitrator(address _newArbitrator) external onlyOwner {\r\n        /**\r\n         * Set the arbitrator to a new address. Only the owner can call this.\r\n         * @param address _newArbitrator\r\n         */\r\n        arbitrator = _newArbitrator;\r\n    }\r\n\r\n    /// @notice Change the owner to a new address. Only the owner can call this.\r\n    /// @param _newOwner Address of the replacement owner\r\n    function setOwner(address _newOwner) external onlyOwner {\r\n        /**\r\n         * Change the owner to a new address. Only the owner can call this.\r\n         * @param address _newOwner\r\n         */\r\n        owner = _newOwner;\r\n    }\r\n\r\n    /// @notice Change the relayer to a new address. Only the owner can call this.\r\n    /// @param _newRelayer Address of the replacement relayer\r\n    function setRelayer(address _newRelayer) external onlyOwner {\r\n        /**\r\n         * Change the relayer to a new address. Only the owner can call this.\r\n         * @param address _newRelayer\r\n         */\r\n        relayer = _newRelayer;\r\n    }\r\n\r\n    /// @notice Change the minimum escrow value. Only the owner can call this.\r\n    /// @param _newMinimumValue uint16 of the new minimum value\r\n    function setMinimumValue(uint16 _newMinimumValue) external onlyOwner {\r\n        /**\r\n         * Change the value to a new minimum value. Only the owner can call this.\r\n         * @param uint16 _newMinimumValue\r\n         */\r\n        minimumValue = _newMinimumValue;\r\n    }\r\n\r\n    /// @notice Change the requestCancellationMinimumTime. Only the owner can call this.\r\n    /// @param _newRequestCancellationMinimumTime Replacement\r\n    function setRequestCancellationMinimumTime(uint32 _newRequestCancellationMinimumTime) external onlyOwner {\r\n        /**\r\n         * Change the requestCancellationMinimumTime. Only the owner can call this.\r\n         * @param uint32 _newRequestCancellationMinimumTime\r\n         */\r\n        requestCancellationMinimumTime = _newRequestCancellationMinimumTime;\r\n    }\r\n\r\n    /***********************\r\n    +   Helper Functions   +\r\n    ***********************/\r\n\r\n    /// @notice Withdraw fees collected by the contract. Only the owner can call this.\r\n    /// @param _to Address to withdraw fees in to\r\n    /// @param _amount Amount to withdraw\r\n    function withdrawFees(address payable _to, uint256 _amount) external onlyOwner {\r\n        // This check also prevents underflow\r\n        require(_amount <= feesAvailableForWithdraw, \"Amount is higher than amount available\");\r\n        feesAvailableForWithdraw -= _amount;\r\n        tokenContract.transfer(_to, _amount);\r\n    }\r\n\r\n    /// @notice Hashes the values and returns the matching escrow object and trade hash.\r\n    /// @dev Returns an empty escrow struct and 0 _tradeHash if not found.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @return Escrow\r\n    function getEscrowAndHash(\r\n      /**\r\n       * Hashes the values and returns the matching escrow object and trade hash.\r\n       * Returns an empty escrow struct and 0 _tradeHash if not found\r\n       */\r\n      bytes16 _tradeID,\r\n      address _seller,\r\n      address _buyer,\r\n      uint256 _value,\r\n      uint16 _fee\r\n    ) private view returns (Escrow storage, bytes32) {\r\n        bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeID, _seller, _buyer, _value, _fee));\r\n        return (escrows[_tradeHash], _tradeHash);\r\n    }\r\n\r\n    /// @notice Returns an empty escrow struct and 0 _tradeHash if not found.\r\n    /// @param _h Data to be hashed\r\n    /// @param _v Signature \"v\" component\r\n    /// @param _r Signature \"r\" component\r\n    /// @param _s Signature \"s\" component\r\n    /// @return address\r\n    function recoverAddress(\r\n        bytes32 _h,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) private pure returns (address) {\r\n        bytes memory _prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 _prefixedHash = keccak256(abi.encodePacked(_prefix, _h));\r\n        return ecrecover(_prefixedHash, _v, _r, _s);\r\n    }\r\n\r\n    /// @notice Get the sender of the signed instruction.\r\n    /// @param _tradeID Identifier of the trade\r\n    /// @param _instructionByte Identifier of the instruction\r\n    /// @param _maximumGasPrice Maximum gas price permitted by the sender\r\n    /// @param _v Signature \"v\" component\r\n    /// @param _r Signature \"r\" component\r\n    /// @param _s Signature \"s\" component\r\n    /// @return address\r\n    function getRelayedSender(\r\n      bytes16 _tradeID, // The unique ID of the trade, generated by us\r\n      uint8 _instructionByte, // The desired action of the user, matching an ACTION_* constant\r\n      uint128 _maximumGasPrice, // The maximum gas price the user is willing to pay\r\n      uint8 _v, // Signature value\r\n      bytes32 _r, // Signature value\r\n      bytes32 _s // Signature value\r\n    ) private view returns (address) {\r\n        bytes32 _hash = keccak256(abi.encodePacked(_tradeID, _instructionByte, _maximumGasPrice));\r\n        require(tx.gasprice < _maximumGasPrice, \"Gas price is higher than maximum gas price\");\r\n        return recoverAddress(_hash, _v, _r, _s);\r\n    }\r\n\r\n    /// @notice Send ERC20 tokens away. This function allows the owner to withdraw stuck ERC20 tokens.\r\n    /// @param _tokenContract Token contract\r\n    /// @param _transferTo Recipient\r\n    /// @param _value Value\r\n    function transferToken(TetherERC20 _tokenContract, address _transferTo, uint256 _value) external onlyOwner {\r\n        /**\r\n         * If ERC20 tokens are sent to this contract, they will be trapped forever.\r\n         * This function is way for us to withdraw them so we can get them back to their rightful owner\r\n         */\r\n         _tokenContract.transfer(_transferTo, _value);\r\n    }\r\n\r\n    /// @notice Send ERC20 tokens away. This function allows the owner to withdraw stuck ERC20 tokens.\r\n    /// @param _tokenContract Token contract\r\n    /// @param _transferTo Recipient\r\n    /// @param _transferFrom Sender\r\n    /// @param _value Value\r\n    function transferTokenFrom(TetherERC20 _tokenContract, address _transferTo, address _transferFrom, uint256 _value) external onlyOwner {\r\n        /**\r\n         * If ERC20 tokens are sent to this contract, they will be trapped forever.\r\n         * This function is way for us to withdraw them so we can get them back to their rightful owner\r\n         */\r\n         _tokenContract.transferFrom(_transferTo, _transferFrom, _value);\r\n    }\r\n\r\n    /// @notice Send ERC20 tokens away. This function allows the owner to withdraw stuck ERC20 tokens.\r\n    /// @param _tokenContract Token contract\r\n    /// @param _spender Spender address\r\n    /// @param _value Value\r\n    function approveToken(TetherERC20 _tokenContract, address _spender, uint256 _value) external onlyOwner {\r\n        /**\r\n         * If ERC20 tokens are sent to this contract, they will be trapped forever.\r\n         * This function is way for us to withdraw them so we can get them back to their rightful owner\r\n         */\r\n         _tokenContract.approve(_spender, _value);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only the current owner can change the owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyArbitrator() {\r\n        require(msg.sender == arbitrator, \"Only the current owner can change the arbitrator\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract TetherERC20 {\r\n    function transfer(address _to, uint _value) public;\r\n    function transferFrom(address _from, address _to, uint _value) public;\r\n    function approve(address _spender, uint _value) public;\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newRequestCancellationMinimumTime\",\"type\":\"uint32\"}],\"name\":\"setRequestCancellationMinimumTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMinimumValue\",\"type\":\"uint16\"}],\"name\":\"setMinimumValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"},{\"name\":\"_buyerPercent\",\"type\":\"uint8\"}],\"name\":\"resolveDispute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"buyerCancel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"escrows\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"},{\"name\":\"sellerCanCancelAfter\",\"type\":\"uint32\"},{\"name\":\"totalGasFeesSpentByRelayer\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"initialOwner\",\"type\":\"address\"},{\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requestCancellationMinimumTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"disableSellerCancel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRelayer\",\"type\":\"address\"}],\"name\":\"setRelayer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"sellerRequestCancel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"arbitrator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"relayer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16[]\"},{\"name\":\"_seller\",\"type\":\"address[]\"},{\"name\":\"_buyer\",\"type\":\"address[]\"},{\"name\":\"_value\",\"type\":\"uint256[]\"},{\"name\":\"_fee\",\"type\":\"uint16[]\"},{\"name\":\"_maximumGasPrice\",\"type\":\"uint128[]\"},{\"name\":\"_v\",\"type\":\"uint8[]\"},{\"name\":\"_r\",\"type\":\"bytes32[]\"},{\"name\":\"_s\",\"type\":\"bytes32[]\"},{\"name\":\"_instructionByte\",\"type\":\"uint8[]\"}],\"name\":\"batchRelay\",\"outputs\":[{\"name\":\"\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newArbitrator\",\"type\":\"address\"}],\"name\":\"setArbitrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approveToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feesAvailableForWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_transferTo\",\"type\":\"address\"},{\"name\":\"_transferFrom\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferTokenFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"release\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"},{\"name\":\"_paymentWindowInSeconds\",\"type\":\"uint32\"},{\"name\":\"_expiry\",\"type\":\"uint32\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"createEscrow\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_transferTo\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"SellerCancelDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"SellerRequestedCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tradeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"totalGasFeesSpentByRelayer\",\"type\":\"uint128\"}],\"name\":\"CancelledBySeller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tradeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"totalGasFeesSpentByRelayer\",\"type\":\"uint128\"}],\"name\":\"CancelledByBuyer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tradeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"totalGasFeesSpentByRelayer\",\"type\":\"uint128\"}],\"name\":\"Released\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tradeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"totalGasFeesSpentByRelayer\",\"type\":\"uint128\"}],\"name\":\"DisputeResolved\",\"type\":\"event\"}]","ContractName":"LocalCoinSwapTetherEscrow","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://5b63f870dba536f43bf0d8b711c0bb6534bd19137b7251d82c43755401d0326a"}]}