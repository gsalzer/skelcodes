{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\nlibrary LibMathSigned {\r\n    int256 private constant _WAD = 10**18;\r\n    int256 private constant _INT256_MIN = -2**255;\r\n\r\n    function WAD() internal pure returns (int256) {\r\n        return _WAD;\r\n    }\r\n\r\n    // additive inverse\r\n    function neg(int256 a) internal pure returns (int256) {\r\n        return sub(int256(0), a);\r\n    }\r\n\r\n    /**\r\n     * @dev wmultiplies two signed integers, reverts on overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        require(!(a == -1 && b == _INT256_MIN), \"wmultiplication overflow\");\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \"wmultiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer wdivision of two signed integers truncating the quotient, reverts on wdivision by zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"wdivision by zero\");\r\n        require(!(b == -1 && a == _INT256_MIN), \"wdivision overflow\");\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two signed integers, reverts on overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"subtraction overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two signed integers, reverts on overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function wmul(int256 x, int256 y) internal pure returns (int256 z) {\r\n        z = roundHalfUp(mul(x, y), _WAD) / _WAD;\r\n    }\r\n\r\n    // solium-disable-next-line security/no-assign-params\r\n    function wdiv(int256 x, int256 y) internal pure returns (int256 z) {\r\n        if (y < 0) {\r\n            y = -y;\r\n            x = -x;\r\n        }\r\n        z = roundHalfUp(mul(x, _WAD), y) / y;\r\n    }\r\n\r\n    // solium-disable-next-line security/no-assign-params\r\n    function wfrac(int256 x, int256 y, int256 z) internal pure returns (int256 r) {\r\n        int256 t = mul(x, y);\r\n        if (z < 0) {\r\n            z = -z;\r\n            t = -t;\r\n        }\r\n        r = roundHalfUp(t, z) / z;\r\n    }\r\n\r\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    // quotient and remainder\r\n    function pwdiv(int256 x, int256 y) internal pure returns (int256 z, int256 m) {\r\n        z = wdiv(x, y);\r\n        m = sub(wmul(y, z), x);\r\n    }\r\n\r\n    function toUint256(int256 x) internal pure returns (uint256) {\r\n        require(x >= 0, \"int overflow\");\r\n        return uint256(x);\r\n    }\r\n\r\n    // x ^ n\r\n    // NOTE: n is a normal integer, do not shift 18 decimals\r\n    // solium-disable-next-line security/no-assign-params\r\n    function wpowi(int256 x, int256 n) internal pure returns (int256 z) {\r\n        z = n % 2 != 0 ? x : _WAD;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = wmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = wmul(z, x);\r\n            }\r\n        }\r\n    }\r\n\r\n    uint8 internal constant fixed_digits = 18;\r\n    int256 internal constant fixed_1 = 1000000000000000000;\r\n    int256 internal constant fixed_e = 2718281828459045235;\r\n    uint8 internal constant longer_digits = 36;\r\n    int256 internal constant longer_fixed_log_e_1_5 = 405465108108164381978013115464349137;\r\n    int256 internal constant longer_fixed_1 = 1000000000000000000000000000000000000;\r\n    int256 internal constant longer_fixed_log_e_10 = 2302585092994045684017991454684364208;\r\n\r\n    // ROUND_HALF_UP rule helper. 0.5 ≈ 1, 0.4 ≈ 0, -0.5 ≈ -1, -0.4 ≈ 0\r\n    function roundHalfUp(int256 x, int256 y) internal pure returns (int256) {\r\n        require(y > 0, \"roundHalfUp only supports y > 0\");\r\n        if (x >= 0) {\r\n            return add(x, y / 2);\r\n        }\r\n        return sub(x, y / 2);\r\n    }\r\n\r\n    // function roundFloor(int256 x, int256 y) internal pure returns (int256) {\r\n    //     require(y > 0, \"roundHalfUp only supports y > 0\");\r\n    //     if (x >= 0 || x % _WAD == 0) {\r\n    //         return x;\r\n    //     }\r\n    //     return sub(x, y);\r\n    // }\r\n\r\n    // function roundCeil(int256 x, int256 y) internal pure returns (int256) {\r\n    //     require(y > 0, \"roundHalfUp only supports y > 0\");\r\n    //     if (x <= 0 || x % _WAD == 0) {\r\n    //         return x;\r\n    //     }\r\n    //     return add(x, y);\r\n    // }\r\n\r\n    // Log(e, x)\r\n    // solium-disable-next-line security/no-assign-params\r\n    function wln(int256 x) internal pure returns (int256) {\r\n        require(x > 0, \"logE of negative number\");\r\n        require(x <= 10000000000000000000000000000000000000000, \"logE only accepts v <= 1e22 * 1e18\"); // in order to prevent using safe-math\r\n        int256 r = 0;\r\n        uint8 extra_digits = longer_digits - fixed_digits;\r\n        int256 t = int256(uint256(10)**uint256(extra_digits));\r\n\r\n        while (x <= fixed_1 / 10) {\r\n            x = x * 10;\r\n            r -= longer_fixed_log_e_10;\r\n        }\r\n        while (x >= 10 * fixed_1) {\r\n            x = x / 10;\r\n            r += longer_fixed_log_e_10;\r\n        }\r\n        while (x < fixed_1) {\r\n            x = wmul(x, fixed_e);\r\n            r -= longer_fixed_1;\r\n        }\r\n        while (x > fixed_e) {\r\n            x = wdiv(x, fixed_e);\r\n            r += longer_fixed_1;\r\n        }\r\n        if (x == fixed_1) {\r\n            return roundHalfUp(r, t) / t;\r\n        }\r\n        if (x == fixed_e) {\r\n            return fixed_1 + roundHalfUp(r, t) / t;\r\n        }\r\n        x *= t;\r\n\r\n        //               x^2   x^3   x^4\r\n        // Ln(1+x) = x - --- + --- - --- + ...\r\n        //                2     3     4\r\n        // when -1 < x < 1, O(x^n) < ε => when n = 36, 0 < x < 0.316\r\n        //\r\n        //                    2    x           2    x          2    x\r\n        // Ln(a+x) = Ln(a) + ---(------)^1  + ---(------)^3 + ---(------)^5 + ...\r\n        //                    1   2a+x         3   2a+x        5   2a+x\r\n        //\r\n        // Let x = v - a\r\n        //                  2   v-a         2   v-a        2   v-a\r\n        // Ln(v) = Ln(a) + ---(-----)^1  + ---(-----)^3 + ---(-----)^5 + ...\r\n        //                  1   v+a         3   v+a        5   v+a\r\n        // when n = 36, 1 < v < 3.423\r\n        r = r + longer_fixed_log_e_1_5;\r\n        int256 a1_5 = (3 * longer_fixed_1) / 2;\r\n        int256 m = (longer_fixed_1 * (x - a1_5)) / (x + a1_5);\r\n        r = r + 2 * m;\r\n        int256 m2 = (m * m) / longer_fixed_1;\r\n        uint8 i = 3;\r\n        while (true) {\r\n            m = (m * m2) / longer_fixed_1;\r\n            r = r + (2 * m) / int256(i);\r\n            i += 2;\r\n            if (i >= 3 + 2 * fixed_digits) {\r\n                break;\r\n            }\r\n        }\r\n        return roundHalfUp(r, t) / t;\r\n    }\r\n\r\n    // Log(b, x)\r\n    function logBase(int256 base, int256 x) internal pure returns (int256) {\r\n        return wdiv(wln(x), wln(base));\r\n    }\r\n\r\n    function ceil(int256 x, int256 m) internal pure returns (int256) {\r\n        require(x >= 0, \"ceil need x >= 0\");\r\n        require(m > 0, \"ceil need m > 0\");\r\n        return (sub(add(x, m), 1) / m) * m;\r\n    }\r\n}\r\n\r\nlibrary LibMathUnsigned {\r\n    uint256 private constant _WAD = 10**18;\r\n    uint256 private constant _UINT256_MAX = 2**255 - 1;\r\n\r\n    function WAD() internal pure returns (uint256) {\r\n        return _WAD;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"Unaddition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"Unsubtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"Unmultiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"Undivision by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, y), _WAD / 2) / _WAD;\r\n    }\r\n\r\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, _WAD), y / 2) / y;\r\n    }\r\n\r\n    function wfrac(uint256 x, uint256 y, uint256 z) internal pure returns (uint256 r) {\r\n        r = mul(x, y) / z;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    // quotient and remainder\r\n    function pwdiv(uint256 x, uint256 y) internal pure returns (uint256 z, uint256 m) {\r\n        z = wdiv(x, y);\r\n        m = sub(wmul(y, z), x);\r\n    }\r\n\r\n    function toInt256(uint256 x) internal pure returns (int256) {\r\n        require(x <= _UINT256_MAX, \"uint256 overflow\");\r\n        return int256(x);\r\n    }\r\n\r\n    function mod(uint256 x, uint256 m) internal pure returns (uint256) {\r\n        require(m != 0, \"mod by zero\");\r\n        return x % m;\r\n    }\r\n\r\n    function ceil(uint256 x, uint256 m) internal pure returns (uint256) {\r\n        require(m > 0, \"ceil need m > 0\");\r\n        return (sub(add(x, m), 1) / m) * m;\r\n    }\r\n}\r\n\r\nlibrary LibEIP712 {\r\n    string internal constant DOMAIN_NAME = \"Mai Protocol\";\r\n\r\n    struct OrderSignature {\r\n        bytes32 config;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n    /**\r\n     * Hash of the EIP712 Domain Separator Schema\r\n     */\r\n    bytes32 private constant EIP712_DOMAIN_TYPEHASH = keccak256(abi.encodePacked(\"EIP712Domain(string name)\"));\r\n\r\n    bytes32 private constant DOMAIN_SEPARATOR = keccak256(\r\n        abi.encodePacked(EIP712_DOMAIN_TYPEHASH, keccak256(bytes(DOMAIN_NAME)))\r\n    );\r\n\r\n    /**\r\n     * Calculates EIP712 encoding for a hash struct in this EIP712 Domain.\r\n     *\r\n     * @param eip712hash The EIP712 hash struct.\r\n     * @return EIP712 hash applied to this EIP712 Domain.\r\n     */\r\n    function hashEIP712Message(bytes32 eip712hash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, eip712hash));\r\n    }\r\n}\r\n\r\nlibrary LibSignature {\r\n    enum SignatureMethod {ETH_SIGN, EIP712}\r\n\r\n    struct OrderSignature {\r\n        bytes32 config;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n    /**\r\n     * Validate a signature given a hash calculated from the order data, the signer, and the\r\n     * signature data passed in with the order.\r\n     *\r\n     * This function will revert the transaction if the signature method is invalid.\r\n     *\r\n     * @param signature The signature data passed along with the order to validate against\r\n     * @param hash Hash bytes calculated by taking the EIP712 hash of the passed order data\r\n     * @param signerAddress The address of the signer\r\n     * @return True if the calculated signature matches the order signature data, false otherwise.\r\n     */\r\n    function isValidSignature(OrderSignature memory signature, bytes32 hash, address signerAddress)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        uint8 method = uint8(signature.config[1]);\r\n        address recovered;\r\n        uint8 v = uint8(signature.config[0]);\r\n\r\n        if (method == uint8(SignatureMethod.ETH_SIGN)) {\r\n            recovered = ecrecover(\r\n                keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)),\r\n                v,\r\n                signature.r,\r\n                signature.s\r\n            );\r\n        } else if (method == uint8(SignatureMethod.EIP712)) {\r\n            recovered = ecrecover(hash, v, signature.r, signature.s);\r\n        } else {\r\n            revert(\"invalid sign method\");\r\n        }\r\n\r\n        return signerAddress == recovered;\r\n    }\r\n}\r\n\r\nlibrary LibOrder {\r\n    using LibMathSigned for int256;\r\n    using LibMathUnsigned for uint256;\r\n\r\n    bytes32 public constant EIP712_ORDER_TYPE = keccak256(\r\n        abi.encodePacked(\r\n            \"Order(address trader,address broker,address perpetual,uint256 amount,uint256 price,bytes32 data)\"\r\n        )\r\n    );\r\n\r\n    int256 public constant FEE_RATE_BASE = 100000;\r\n    uint256 public constant ONE = 1e18;\r\n\r\n    struct Order {\r\n        address trader;\r\n        address broker;\r\n        address perpetual;\r\n        uint256 amount;\r\n        uint256 price;\r\n        /**\r\n         * Data contains the following values packed into 32 bytes\r\n         * ╔════════════════════╤═══════════════════════════════════════════════════════════╗\r\n         * ║                    │ length(bytes)   desc                                      ║\r\n         * ╟────────────────────┼───────────────────────────────────────────────────────────╢\r\n         * ║ version            │ 1               order version                             ║\r\n         * ║ side               │ 1               0: buy (long), 1: sell (short)            ║\r\n         * ║ isMarketOrder      │ 1               0: limitOrder, 1: marketOrder             ║\r\n         * ║ expiredAt          │ 5               order expiration time in seconds          ║\r\n         * ║ asMakerFeeRate     │ 2               maker fee rate (base 100,000)             ║\r\n         * ║ asTakerFeeRate     │ 2               taker fee rate (base 100,000)             ║\r\n         * ║ (d) makerRebateRate│ 2               rebate rate for maker (base 100)          ║\r\n         * ║ salt               │ 8               salt                                      ║\r\n         * ║ isMakerOnly        │ 1               is maker only                             ║\r\n         * ║ isInversed         │ 1               is inversed contract                      ║\r\n         * ║                    │ 8               reserved                                  ║\r\n         * ╚════════════════════╧═══════════════════════════════════════════════════════════╝\r\n         */\r\n        bytes32 data;\r\n    }\r\n\r\n    struct OrderParam {\r\n        address trader;\r\n        uint256 amount;\r\n        uint256 price;\r\n        bytes32 data;\r\n        LibSignature.OrderSignature signature;\r\n    }\r\n\r\n    function getOrderHash(OrderParam memory orderParam, address perpetual, address broker)\r\n        internal\r\n        pure\r\n        returns (bytes32 orderHash)\r\n    {\r\n        Order memory order = getOrder(orderParam, perpetual, broker);\r\n        orderHash = LibEIP712.hashEIP712Message(hashOrder(order));\r\n        return orderHash;\r\n    }\r\n\r\n    function getOrderHash(Order memory order) internal pure returns (bytes32 orderHash) {\r\n        orderHash = LibEIP712.hashEIP712Message(hashOrder(order));\r\n        return orderHash;\r\n    }\r\n\r\n    function getOrder(OrderParam memory orderParam, address perpetual, address broker)\r\n        internal\r\n        pure\r\n        returns (LibOrder.Order memory order)\r\n    {\r\n        order.trader = orderParam.trader;\r\n        order.broker = broker;\r\n        order.perpetual = perpetual;\r\n        order.amount = orderParam.amount;\r\n        order.price = orderParam.price;\r\n        order.data = orderParam.data;\r\n    }\r\n\r\n    function hashOrder(Order memory order) internal pure returns (bytes32 result) {\r\n        bytes32 orderType = EIP712_ORDER_TYPE;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let start := sub(order, 32)\r\n            let tmp := mload(start)\r\n            mstore(start, orderType)\r\n            result := keccak256(start, 224)\r\n            mstore(start, tmp)\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function getOrderVersion(OrderParam memory orderParam) internal pure returns (uint256) {\r\n        return uint256(uint8(bytes1(orderParam.data)));\r\n    }\r\n\r\n    function getExpiredAt(OrderParam memory orderParam) internal pure returns (uint256) {\r\n        return uint256(uint40(bytes5(orderParam.data << (8 * 3))));\r\n    }\r\n\r\n    function isSell(OrderParam memory orderParam) internal pure returns (bool) {\r\n        bool sell = uint8(orderParam.data[1]) == 1;\r\n        return isInversed(orderParam) ? !sell : sell;\r\n    }\r\n\r\n    function getPrice(OrderParam memory orderParam) internal pure returns (uint256) {\r\n        return isInversed(orderParam) ? ONE.wdiv(orderParam.price) : orderParam.price;\r\n    }\r\n\r\n    function isMarketOrder(OrderParam memory orderParam) internal pure returns (bool) {\r\n        return uint8(orderParam.data[2]) == 1;\r\n    }\r\n\r\n    function isMarketBuy(OrderParam memory orderParam) internal pure returns (bool) {\r\n        return !isSell(orderParam) && isMarketOrder(orderParam);\r\n    }\r\n\r\n    function isMakerOnly(OrderParam memory orderParam) internal pure returns (bool) {\r\n        return uint8(orderParam.data[22]) == 1;\r\n    }\r\n\r\n    function isInversed(OrderParam memory orderParam) internal pure returns (bool) {\r\n        return uint8(orderParam.data[23]) == 1;\r\n    }\r\n\r\n    function side(OrderParam memory orderParam) internal pure returns (LibTypes.Side) {\r\n        return isSell(orderParam) ? LibTypes.Side.SHORT : LibTypes.Side.LONG;\r\n    }\r\n\r\n    function makerFeeRate(OrderParam memory orderParam) internal pure returns (int256) {\r\n        return int256(int16(bytes2(orderParam.data << (8 * 8)))).mul(LibMathSigned.WAD()).div(FEE_RATE_BASE);\r\n    }\r\n\r\n    function takerFeeRate(OrderParam memory orderParam) internal pure returns (int256) {\r\n        return int256(int16(bytes2(orderParam.data << (8 * 10)))).mul(LibMathSigned.WAD()).div(FEE_RATE_BASE);\r\n    }\r\n}\r\n\r\nlibrary LibTypes {\r\n    enum Side {FLAT, SHORT, LONG}\r\n\r\n    enum Status {NORMAL, SETTLING, SETTLED}\r\n\r\n    function counterSide(Side side) internal pure returns (Side) {\r\n        if (side == Side.LONG) {\r\n            return Side.SHORT;\r\n        } else if (side == Side.SHORT) {\r\n            return Side.LONG;\r\n        }\r\n        return side;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////\r\n    // Perpetual\r\n    //////////////////////////////////////////////////////////////////////////\r\n    struct PerpGovernanceConfig {\r\n        uint256 initialMarginRate;\r\n        uint256 maintenanceMarginRate;\r\n        uint256 liquidationPenaltyRate;\r\n        uint256 penaltyFundRate;\r\n        int256 takerDevFeeRate;\r\n        int256 makerDevFeeRate;\r\n        uint256 lotSize;\r\n        uint256 tradingLotSize;\r\n    }\r\n\r\n    // CollateralAccount represents cash account of user\r\n    struct CollateralAccount {\r\n        // currernt deposited erc20 token amount, representing in decimals 18\r\n        int256 balance;\r\n        // the amount of withdrawal applied by user\r\n        // which allowed to withdraw in the future but not available in trading\r\n        int256 appliedBalance;\r\n        // applied balance will be appled only when the block height below is reached\r\n        uint256 appliedHeight;\r\n    }\r\n\r\n    struct PositionAccount {\r\n        LibTypes.Side side;\r\n        uint256 size;\r\n        uint256 entryValue;\r\n        int256 entrySocialLoss;\r\n        int256 entryFundingLoss;\r\n    }\r\n\r\n    struct BrokerRecord {\r\n        address broker;\r\n        uint256 appliedHeight;\r\n    }\r\n\r\n    struct Broker {\r\n        BrokerRecord previous;\r\n        BrokerRecord current;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////\r\n    // AMM\r\n    //////////////////////////////////////////////////////////////////////////\r\n    struct AMMGovernanceConfig {\r\n        uint256 poolFeeRate;\r\n        uint256 poolDevFeeRate;\r\n        int256 emaAlpha;\r\n        uint256 updatePremiumPrize;\r\n        int256 markPremiumLimit;\r\n        int256 fundingDampener;\r\n    }\r\n\r\n    struct FundingState {\r\n        uint256 lastFundingTime;\r\n        int256 lastPremium;\r\n        int256 lastEMAPremium;\r\n        uint256 lastIndexPrice;\r\n        int256 accumulatedFundingPerContract;\r\n    }\r\n}\r\n\r\ninterface IPerpetualProxy {\r\n    // a gas-optimized version of position*\r\n    struct PoolAccount {\r\n        uint256 positionSize;\r\n        uint256 positionEntryValue;\r\n        int256 cashBalance;\r\n        int256 socialLossPerContract;\r\n        int256 positionEntrySocialLoss;\r\n        int256 positionEntryFundingLoss;\r\n    }\r\n\r\n    function self() external view returns (address);\r\n\r\n    function perpetual() external view returns (address);\r\n\r\n    function devAddress() external view returns (address);\r\n\r\n    function currentBroker(address guy) external view returns (address);\r\n\r\n    function markPrice() external returns (uint256);\r\n\r\n    function settlementPrice() external view returns (uint256);\r\n\r\n    function availableMargin(address guy) external returns (int256);\r\n\r\n    function getPoolAccount() external view returns (PoolAccount memory pool);\r\n\r\n    function cashBalance() external view returns (int256);\r\n\r\n    function positionSize() external view returns (uint256);\r\n\r\n    function positionSide() external view returns (LibTypes.Side);\r\n\r\n    function positionEntryValue() external view returns (uint256);\r\n\r\n    function positionEntrySocialLoss() external view returns (int256);\r\n\r\n    function positionEntryFundingLoss() external view returns (int256);\r\n\r\n    // function isEmergency() external view returns (bool);\r\n\r\n    // function isGlobalSettled() external view returns (bool);\r\n\r\n    function status() external view returns (LibTypes.Status);\r\n\r\n    function socialLossPerContract(LibTypes.Side side) external view returns (int256);\r\n\r\n    function transferBalanceIn(address from, uint256 amount) external;\r\n\r\n    function transferBalanceOut(address to, uint256 amount) external;\r\n\r\n    function transferBalanceTo(address from, address to, uint256 amount) external;\r\n\r\n    function trade(address guy, LibTypes.Side side, uint256 price, uint256 amount) external returns (uint256);\r\n\r\n    function setBrokerFor(address guy, address broker) external;\r\n\r\n    function depositFor(address guy, uint256 amount) external;\r\n\r\n    function depositEtherFor(address guy) external payable;\r\n\r\n    function withdrawFor(address payable guy, uint256 amount) external;\r\n\r\n    function isSafe(address guy) external returns (bool);\r\n\r\n    function isSafeWithPrice(address guy, uint256 currentMarkPrice) external returns (bool);\r\n\r\n    function isProxySafe() external returns (bool);\r\n\r\n    function isProxySafeWithPrice(uint256 currentMarkPrice) external returns (bool);\r\n\r\n    function isIMSafe(address guy) external returns (bool);\r\n\r\n    function isIMSafeWithPrice(address guy, uint256 currentMarkPrice) external returns (bool);\r\n\r\n    function lotSize() external view returns (uint256);\r\n\r\n    function tradingLotSize() external view returns (uint256);\r\n}\r\n\r\ninterface IAMM {\r\n    function shareTokenAddress() external view returns (address);\r\n\r\n    function lastFundingState() external view returns (LibTypes.FundingState memory);\r\n\r\n    function getGovernance() external view returns (LibTypes.AMMGovernanceConfig memory);\r\n\r\n    function perpetualProxy() external view returns (IPerpetualProxy);\r\n\r\n    function currentMarkPrice() external returns (uint256);\r\n\r\n    function currentAvailableMargin() external returns (uint256);\r\n\r\n    function currentFairPrice() external returns (uint256);\r\n\r\n    function positionSize() external returns (uint256);\r\n\r\n    function currentAccumulatedFundingPerContract() external returns (int256);\r\n\r\n    function settleShare(uint256 shareAmount) external;\r\n\r\n    function buy(uint256 amount, uint256 limitPrice, uint256 deadline) external returns (uint256);\r\n\r\n    function sell(uint256 amount, uint256 limitPrice, uint256 deadline) external returns (uint256);\r\n\r\n    function buyFromWhitelisted(address trader, uint256 amount, uint256 limitPrice, uint256 deadline)\r\n        external\r\n        returns (uint256);\r\n\r\n    function sellFromWhitelisted(address trader, uint256 amount, uint256 limitPrice, uint256 deadline)\r\n        external\r\n        returns (uint256);\r\n\r\n    function buyFrom(address trader, uint256 amount, uint256 limitPrice, uint256 deadline) external returns (uint256);\r\n\r\n    function sellFrom(address trader, uint256 amount, uint256 limitPrice, uint256 deadline) external returns (uint256);\r\n}\r\n\r\ninterface IPerpetual {\r\n    function devAddress() external view returns (address);\r\n\r\n    function getCashBalance(address guy) external view returns (LibTypes.CollateralAccount memory);\r\n\r\n    function getPosition(address guy) external view returns (LibTypes.PositionAccount memory);\r\n\r\n    function getBroker(address guy) external view returns (LibTypes.Broker memory);\r\n\r\n    function getGovernance() external view returns (LibTypes.PerpGovernanceConfig memory);\r\n\r\n    function status() external view returns (LibTypes.Status);\r\n\r\n    function settlementPrice() external view returns (uint256);\r\n\r\n    function globalConfig() external view returns (address);\r\n\r\n    function collateral() external view returns (address);\r\n\r\n    function isWhitelisted(address account) external view returns (bool);\r\n\r\n    function currentBroker(address guy) external view returns (address);\r\n\r\n    function amm() external view returns (IAMM);\r\n\r\n    function totalSize(LibTypes.Side side) external view returns (uint256);\r\n\r\n    function markPrice() external returns (uint256);\r\n\r\n    function socialLossPerContract(LibTypes.Side side) external view returns (int256);\r\n\r\n    function availableMargin(address guy) external returns (int256);\r\n\r\n    function positionMargin(address guy) external view returns (uint256);\r\n\r\n    function maintenanceMargin(address guy) external view returns (uint256);\r\n\r\n    function isSafe(address guy) external returns (bool);\r\n\r\n    function isSafeWithPrice(address guy, uint256 currentMarkPrice) external returns (bool);\r\n\r\n    function isIMSafe(address guy) external returns (bool);\r\n\r\n    function isIMSafeWithPrice(address guy, uint256 currentMarkPrice) external returns (bool);\r\n\r\n    function tradePosition(address guy, LibTypes.Side side, uint256 price, uint256 amount) external returns (uint256);\r\n\r\n    function transferCashBalance(address from, address to, uint256 amount) external;\r\n\r\n    function setBrokerFor(address guy, address broker) external;\r\n\r\n    function depositFor(address guy, uint256 amount) external;\r\n\r\n    function depositEtherFor(address guy) external payable;\r\n\r\n    function withdrawFor(address payable guy, uint256 amount) external;\r\n\r\n    function liquidate(address guy, uint256 amount) external returns (uint256, uint256);\r\n\r\n    function liquidateFrom(address from, address guy, uint256 amount) external returns (uint256, uint256);\r\n\r\n    function insuranceFundBalance() external view returns (int256);\r\n}\r\n\r\ncontract Exchange {\r\n    using LibMathSigned for int256;\r\n    using LibMathUnsigned for uint256;\r\n    using LibOrder for LibOrder.Order;\r\n    using LibOrder for LibOrder.OrderParam;\r\n    using LibSignature for LibSignature.OrderSignature;\r\n\r\n    uint256 public constant SUPPORTED_ORDER_VERSION = 2;\r\n\r\n    enum OrderStatus {EXPIRED, CANCELLED, FILLABLE, FULLY_FILLED}\r\n\r\n    mapping(bytes32 => uint256) public filled;\r\n    mapping(bytes32 => bool) public cancelled;\r\n\r\n    event MatchWithOrders(\r\n        address perpetual,\r\n        LibOrder.OrderParam takerOrderParam,\r\n        LibOrder.OrderParam makerOrderParam,\r\n        uint256 amount\r\n    );\r\n    event MatchWithAMM(address perpetual, LibOrder.OrderParam takerOrderParam, uint256 amount);\r\n    event Cancel(bytes32 indexed orderHash);\r\n\r\n    function matchOrders(\r\n        LibOrder.OrderParam memory takerOrderParam,\r\n        LibOrder.OrderParam[] memory makerOrderParams,\r\n        address _perpetual,\r\n        uint256[] memory amounts\r\n    ) public {\r\n        require(!takerOrderParam.isMakerOnly(), \"taker order is maker only\");\r\n\r\n        IPerpetual perpetual = IPerpetual(_perpetual);\r\n        require(perpetual.status() == LibTypes.Status.NORMAL, \"wrong perpetual status\");\r\n\r\n        uint256 tradingLotSize = perpetual.getGovernance().tradingLotSize;\r\n        bytes32 takerOrderHash = validateOrderParam(perpetual, takerOrderParam);\r\n        uint256 takerFilledAmount = filled[takerOrderHash];\r\n        uint256 takerOpened;\r\n\r\n        for (uint256 i = 0; i < makerOrderParams.length; i++) {\r\n            require(takerOrderParam.trader != makerOrderParams[i].trader, \"self trade\");\r\n            require(takerOrderParam.isInversed() == makerOrderParams[i].isInversed(), \"invalid inversed pair\");\r\n            require(takerOrderParam.isSell() != makerOrderParams[i].isSell(), \"invalid side\");\r\n            require(!makerOrderParams[i].isMarketOrder(), \"market order cannot be maker\");\r\n\r\n            validatePrice(takerOrderParam, makerOrderParams[i]);\r\n\r\n            bytes32 makerOrderHash = validateOrderParam(perpetual, makerOrderParams[i]);\r\n            uint256 makerFilledAmount = filled[makerOrderHash];\r\n\r\n            require(amounts[i] <= takerOrderParam.amount.sub(takerFilledAmount), \"taker overfilled\");\r\n            require(amounts[i] <= makerOrderParams[i].amount.sub(makerFilledAmount), \"maker overfilled\");\r\n            require(amounts[i].mod(tradingLotSize) == 0, \"invalid trading lot size\");\r\n\r\n            uint256 opened = fillOrder(perpetual, takerOrderParam, makerOrderParams[i], amounts[i]);\r\n\r\n            takerOpened = takerOpened.add(opened);\r\n            filled[makerOrderHash] = makerFilledAmount.add(amounts[i]);\r\n            takerFilledAmount = takerFilledAmount.add(amounts[i]);\r\n        }\r\n\r\n        // all trades done, check taker safe.\r\n        if (takerOpened > 0) {\r\n            require(perpetual.isIMSafe(takerOrderParam.trader), \"taker margin\");\r\n        } else {\r\n            require(perpetual.isSafe(takerOrderParam.trader), \"maker unsafe\");\r\n        }\r\n        require(perpetual.isSafe(msg.sender), \"broker unsafe\");\r\n\r\n        filled[takerOrderHash] = takerFilledAmount;\r\n    }\r\n\r\n    function fillOrder(\r\n        IPerpetual perpetual,\r\n        LibOrder.OrderParam memory takerOrderParam,\r\n        LibOrder.OrderParam memory makerOrderParam,\r\n        uint256 amount\r\n    ) internal returns (uint256) {\r\n        uint256 price = makerOrderParam.getPrice();\r\n        uint256 takerOpened = perpetual.tradePosition(takerOrderParam.trader, takerOrderParam.side(), price, amount);\r\n        uint256 makerOpened = perpetual.tradePosition(makerOrderParam.trader, makerOrderParam.side(), price, amount);\r\n\r\n        // trading fee\r\n        int256 takerTradingFee = amount.wmul(price).toInt256().wmul(takerOrderParam.takerFeeRate());\r\n        claimTradingFee(perpetual, takerOrderParam.trader, takerTradingFee);\r\n        int256 makerTradingFee = amount.wmul(price).toInt256().wmul(makerOrderParam.makerFeeRate());\r\n        claimTradingFee(perpetual, makerOrderParam.trader, makerTradingFee);\r\n\r\n        // dev fee\r\n        claimTakerDevFee(perpetual, takerOrderParam.trader, price, takerOpened, amount.sub(takerOpened));\r\n        claimMakerDevFee(perpetual, makerOrderParam.trader, price, makerOpened, amount.sub(makerOpened));\r\n        if (makerOpened > 0) {\r\n            require(perpetual.isIMSafe(makerOrderParam.trader), \"maker margin\");\r\n        } else {\r\n            require(perpetual.isSafe(makerOrderParam.trader), \"maker unsafe\");\r\n        }\r\n\r\n        emit MatchWithOrders(address(perpetual), takerOrderParam, makerOrderParam, amount);\r\n\r\n        return takerOpened;\r\n    }\r\n\r\n    function matchOrderWithAMM(LibOrder.OrderParam memory takerOrderParam, address _perpetual, uint256 amount) public {\r\n        require(!takerOrderParam.isMakerOnly(), \"taker order is maker only\");\r\n\r\n        IPerpetual perpetual = IPerpetual(_perpetual);\r\n        IAMM amm = IAMM(perpetual.amm());\r\n\r\n        require(amount.mod(perpetual.getGovernance().tradingLotSize) == 0, \"invalid trading lot size\");\r\n\r\n        bytes32 takerOrderHash = validateOrderParam(perpetual, takerOrderParam);\r\n        uint256 takerFilledAmount = filled[takerOrderHash];\r\n        require(amount <= takerOrderParam.amount.sub(takerFilledAmount), \"taker overfilled\");\r\n\r\n        // trading with pool\r\n        uint256 takerOpened;\r\n        uint256 price = takerOrderParam.getPrice();\r\n        if (takerOrderParam.isSell()) {\r\n            takerOpened = amm.sellFromWhitelisted(\r\n                takerOrderParam.trader,\r\n                amount,\r\n                price,\r\n                takerOrderParam.getExpiredAt()\r\n            );\r\n        } else {\r\n            takerOpened = amm.buyFromWhitelisted(takerOrderParam.trader, amount, price, takerOrderParam.getExpiredAt());\r\n        }\r\n        filled[takerOrderHash] = filled[takerOrderHash].add(amount);\r\n\r\n        emit MatchWithAMM(_perpetual, takerOrderParam, amount);\r\n    }\r\n\r\n    function validatePrice(LibOrder.OrderParam memory takerOrderParam, LibOrder.OrderParam memory makerOrderParam)\r\n        internal\r\n        pure\r\n    {\r\n        if (takerOrderParam.isMarketOrder()) {\r\n            return;\r\n        }\r\n        uint256 takerPrice = takerOrderParam.getPrice();\r\n        uint256 makerPrice = makerOrderParam.getPrice();\r\n        require(takerOrderParam.isSell() ? takerPrice <= makerPrice : takerPrice >= makerPrice, \"price not match\");\r\n    }\r\n\r\n    function validateOrderParam(IPerpetual perpetual, LibOrder.OrderParam memory orderParam)\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        address broker = perpetual.currentBroker(orderParam.trader);\r\n        require(broker == msg.sender, \"invalid broker\");\r\n        require(orderParam.getOrderVersion() == 2, \"unsupported version\");\r\n        require(orderParam.getExpiredAt() >= block.timestamp, \"order expired\");\r\n\r\n        bytes32 orderHash = orderParam.getOrderHash(address(perpetual), broker);\r\n        require(orderParam.signature.isValidSignature(orderHash, orderParam.trader), \"invalid signature\");\r\n        require(filled[orderHash] < orderParam.amount, \"fullfilled order\");\r\n\r\n        return orderHash;\r\n    }\r\n\r\n    function claimTradingFee(IPerpetual perpetual, address trader, int256 fee) internal {\r\n        if (fee > 0) {\r\n            perpetual.transferCashBalance(trader, msg.sender, fee.toUint256());\r\n        } else if (fee < 0) {\r\n            perpetual.transferCashBalance(msg.sender, trader, fee.neg().toUint256());\r\n        }\r\n    }\r\n\r\n    function cancelOrder(LibOrder.Order memory order) public {\r\n        require(msg.sender == order.trader || msg.sender == order.broker, \"invalid caller\");\r\n\r\n        bytes32 orderHash = order.getOrderHash();\r\n        cancelled[orderHash] = true;\r\n\r\n        emit Cancel(orderHash);\r\n    }\r\n\r\n    function claimDevFee(\r\n        IPerpetual perpetual,\r\n        address guy,\r\n        uint256 price,\r\n        uint256 openedAmount,\r\n        uint256 closedAmount,\r\n        int256 feeRate\r\n    ) internal {\r\n        if (feeRate == 0) {\r\n            return;\r\n        }\r\n        int256 hard = price.wmul(openedAmount).toInt256().wmul(feeRate);\r\n        int256 soft = price.wmul(closedAmount).toInt256().wmul(feeRate);\r\n        int256 fee = hard.add(soft);\r\n        address devAddress = perpetual.devAddress();\r\n        if (fee > 0) {\r\n            int256 available = perpetual.availableMargin(guy);\r\n            require(available >= hard, \"dev margin\");\r\n            fee = fee.min(available);\r\n            perpetual.transferCashBalance(guy, devAddress, fee.toUint256());\r\n        } else if (fee < 0) {\r\n            perpetual.transferCashBalance(devAddress, guy, fee.neg().toUint256());\r\n            require(perpetual.isSafe(devAddress), \"dev unsafe\");\r\n        }\r\n    }\r\n\r\n    function claimTakerDevFee(\r\n        IPerpetual perpetual,\r\n        address guy,\r\n        uint256 price,\r\n        uint256 openedAmount,\r\n        uint256 closedAmount\r\n    ) internal {\r\n        int256 rate = perpetual.getGovernance().takerDevFeeRate;\r\n        claimDevFee(perpetual, guy, price, openedAmount, closedAmount, rate);\r\n    }\r\n\r\n    function claimMakerDevFee(\r\n        IPerpetual perpetual,\r\n        address guy,\r\n        uint256 price,\r\n        uint256 openedAmount,\r\n        uint256 closedAmount\r\n    ) internal {\r\n        int256 rate = perpetual.getGovernance().makerDevFeeRate;\r\n        claimDevFee(perpetual, guy, price, openedAmount, closedAmount, rate);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"config\",\"type\":\"bytes32\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"takerOrderParam\",\"type\":\"tuple\"},{\"name\":\"_perpetual\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"matchOrderWithAMM\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"filled\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"broker\",\"type\":\"address\"},{\"name\":\"perpetual\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes32\"}],\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"cancelled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"config\",\"type\":\"bytes32\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"takerOrderParam\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"config\",\"type\":\"bytes32\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"makerOrderParams\",\"type\":\"tuple[]\"},{\"name\":\"_perpetual\",\"type\":\"address\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"matchOrders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SUPPORTED_ORDER_VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"perpetual\",\"type\":\"address\"},{\"components\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"config\",\"type\":\"bytes32\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"indexed\":false,\"name\":\"takerOrderParam\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"config\",\"type\":\"bytes32\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"indexed\":false,\"name\":\"makerOrderParam\",\"type\":\"tuple\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MatchWithOrders\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"perpetual\",\"type\":\"address\"},{\"components\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"config\",\"type\":\"bytes32\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"indexed\":false,\"name\":\"takerOrderParam\",\"type\":\"tuple\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MatchWithAMM\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"Cancel\",\"type\":\"event\"}]","ContractName":"Exchange","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://d8d1615c136c211b2a787e2265287c4c0b6208125c2e6618c90a3426452e8c38"}]}