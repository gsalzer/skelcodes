{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.13;\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error.\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n\n\n/// @title EventMetadata\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.2.0\ncontract EventMetadata {\n\n    event MetadataSet(bytes metadata);\n\n    // state functions\n\n    function _setMetadata(bytes memory metadata) internal {\n        emit MetadataSet(metadata);\n    }\n}\n\n\n\n/// @title Operated\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.2.0\ncontract Operated {\n\n    address private _operator;\n\n    event OperatorUpdated(address operator);\n\n    // state functions\n\n    function _setOperator(address operator) internal {\n\n        // can only be called when operator is null\n        require(_operator == address(0), \"operator already set\");\n\n        // cannot set to address 0\n        require(operator != address(0), \"cannot set operator to address 0\");\n\n        // set operator in storage\n        _operator = operator;\n\n        // emit event\n        emit OperatorUpdated(operator);\n    }\n\n    function _transferOperator(address operator) internal {\n\n        // requires existing operator\n        require(_operator != address(0), \"only when operator set\");\n\n        // cannot set to address 0\n        require(operator != address(0), \"cannot set operator to address 0\");\n\n        // set operator in storage\n        _operator = operator;\n\n        // emit event\n        emit OperatorUpdated(operator);\n    }\n\n    function _renounceOperator() internal {\n\n        // requires existing operator\n        require(_operator != address(0), \"only when operator set\");\n\n        // set operator in storage\n        _operator = address(0);\n\n        // emit event\n        emit OperatorUpdated(address(0));\n    }\n\n    // view functions\n\n    function getOperator() public view returns (address operator) {\n        return _operator;\n    }\n\n    function isOperator(address caller) internal view returns (bool ok) {\n        return caller == _operator;\n    }\n\n}\n\n\n/* @title DecimalMath\n * @dev taken from https://github.com/PolymathNetwork/polymath-core\n * @dev Apache v2 License\n */\nlibrary DecimalMath {\n    using SafeMath for uint256;\n\n    uint256 internal constant e18 = uint256(10) ** uint256(18);\n\n    /**\n     * @notice This function multiplies two decimals represented as (decimal * 10**DECIMALS)\n     * @return uint256 Result of multiplication represented as (decimal * 10**DECIMALS)\n     */\n    function mul(uint256 x, uint256 y) internal pure returns(uint256 z) {\n        z = SafeMath.add(SafeMath.mul(x, y), (e18) / 2) / (e18);\n    }\n\n    /**\n     * @notice This function divides two decimals represented as (decimal * 10**DECIMALS)\n     * @return uint256 Result of division represented as (decimal * 10**DECIMALS)\n     */\n    function div(uint256 x, uint256 y) internal pure returns(uint256 z) {\n        z = SafeMath.add(SafeMath.mul(x, (e18)), y / 2) / y;\n    }\n\n}\n\n\n/// @title iFactory\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.2.0\ninterface iFactory {\n\n    event InstanceCreated(address indexed instance, address indexed creator, bytes callData);\n\n    function create(bytes calldata callData) external returns (address instance);\n    function createSalty(bytes calldata callData, bytes32 salt) external returns (address instance);\n    function getInitSelector() external view returns (bytes4 initSelector);\n    function getInstanceRegistry() external view returns (address instanceRegistry);\n    function getTemplate() external view returns (address template);\n    function getSaltyInstance(address creator, bytes calldata callData, bytes32 salt) external view returns (address instance, bool validity);\n    function getNextNonceInstance(address creator, bytes calldata callData) external view returns (address instance);\n\n    function getInstanceCreator(address instance) external view returns (address creator);\n    function getInstanceType() external view returns (bytes4 instanceType);\n    function getInstanceCount() external view returns (uint256 count);\n    function getInstance(uint256 index) external view returns (address instance);\n    function getInstances() external view returns (address[] memory instances);\n    function getPaginatedInstances(uint256 startIndex, uint256 endIndex) external view returns (address[] memory instances);\n}\n\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\n\n/// @title Deposit\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.2.0\n/// @dev State Machine: https://github.com/erasureprotocol/erasure-protocol/blob/v1.2.0/docs/state-machines/modules/Deposit.png\ncontract Deposit {\n\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _deposit;\n\n    event DepositIncreased(address user, uint256 amount, uint256 newDeposit);\n    event DepositDecreased(address user, uint256 amount, uint256 newDeposit);\n\n    function _increaseDeposit(address user, uint256 amountToAdd) internal returns (uint256 newDeposit) {\n        // calculate new deposit amount\n        newDeposit = _deposit[user].add(amountToAdd);\n\n        // set new stake to storage\n        _deposit[user] = newDeposit;\n\n        // emit event\n        emit DepositIncreased(user, amountToAdd, newDeposit);\n\n        // return\n        return newDeposit;\n    }\n\n    function _decreaseDeposit(address user, uint256 amountToRemove) internal returns (uint256 newDeposit) {\n        // get current deposit\n        uint256 currentDeposit = _deposit[user];\n\n        // check if sufficient deposit\n        require(currentDeposit >= amountToRemove, \"insufficient deposit to remove\");\n\n        // calculate new deposit amount\n        newDeposit = currentDeposit.sub(amountToRemove);\n\n        // set new stake to storage\n        _deposit[user] = newDeposit;\n\n        // emit event\n        emit DepositDecreased(user, amountToRemove, newDeposit);\n\n        // return\n        return newDeposit;\n    }\n\n    function _clearDeposit(address user) internal returns (uint256 amountRemoved) {\n        // get current deposit\n        uint256 currentDeposit = _deposit[user];\n\n        // remove deposit\n        _decreaseDeposit(user, currentDeposit);\n\n        // return\n        return currentDeposit;\n    }\n\n    // view functions\n\n    function getDeposit(address user) public view returns (uint256 deposit) {\n        return _deposit[user];\n    }\n\n}\n\n\n\n/// @title iNMR\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.2.0\ncontract iNMR {\n\n    // ERC20\n    function totalSupply() external returns (uint256);\n    function balanceOf(address _owner) external returns (uint256);\n    function allowance(address _owner, address _spender) external returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool ok);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool ok);\n    function approve(address _spender, uint256 _value) external returns (bool ok);\n    function changeApproval(address _spender, uint256 _oldValue, uint256 _newValue) external returns (bool ok);\n\n    /// @dev Behavior has changed to match OpenZeppelin's `ERC20Burnable.burn(uint256 amount)`\n    /// @dev Destoys `amount` tokens from `msg.sender`, reducing the total supply.\n    ///\n    /// Emits a `Transfer` event with `to` set to the zero address.\n    /// Requirements:\n    /// - `account` must have at least `amount` tokens.\n    function mint(uint256 _value) external returns (bool ok);\n\n    /// @dev Behavior has changed to match OpenZeppelin's `ERC20Burnable.burnFrom(address account, uint256 amount)`\n    /// @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n    /// from the caller's allowance.\n    ///\n    /// Emits an `Approval` event indicating the updated allowance.\n    /// Emits a `Transfer` event with `to` set to the zero address.\n    ///\n    /// Requirements:\n    /// - `account` must have at least `amount` tokens.\n    /// - `account` must have approved `msg.sender` with allowance of at least `amount` tokens.\n    function numeraiTransfer(address _to, uint256 _value) external returns (bool ok);\n}\n\n\n\n/// @title Template\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.2.0\ncontract Template {\n\n    address private _factory;\n\n    // modifiers\n\n    modifier initializeTemplate() {\n        // set factory\n        _factory = msg.sender;\n\n        // only allow function to be `DELEGATECALL`ed from within a constructor.\n        uint32 codeSize;\n        assembly { codeSize := extcodesize(address) }\n        require(codeSize == 0, \"must be called within contract constructor\");\n        _;\n    }\n\n    // view functions\n\n    function getCreator() public view returns (address creator) {\n        // iFactory(...) would revert if _factory address is not actually a factory contract\n        return iFactory(_factory).getInstanceCreator(address(this));\n    }\n\n    function isCreator(address caller) internal view returns (bool ok) {\n        return (caller == getCreator());\n    }\n\n    function getFactory() public view returns (address factory) {\n        return _factory;\n    }\n\n}\n\n\n/// @title BurnNMR\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.2.0\n/// @notice Allows for calling NMR burn functions using regular openzeppelin ERC20Burnable interface and revert on failure.\ncontract BurnNMR {\n\n    // address of the token\n    address private constant _Token = address(0x1776e1F26f98b1A5dF9cD347953a26dd3Cb46671);\n\n    /// @notice Burns a specific amount of NMR from this contract.\n    /// @param value uint256 The amount of NMR (18 decimals) to be burned.\n    function _burn(uint256 value) internal {\n        require(iNMR(_Token).mint(value), \"nmr burn failed\");\n    }\n\n    /// @dev Burns a specific amount of NMR from the target address and decrements allowance.\n    /// @param from address The account whose tokens will be burned.\n    /// @param value uint256 The amount of NMR (18 decimals) to be burned.\n    function _burnFrom(address from, uint256 value) internal {\n        require(iNMR(_Token).numeraiTransfer(from, value), \"nmr burnFrom failed\");\n    }\n\n    /// @notice Get the NMR token address.\n    /// @return token address The NMR token address.\n    function getToken() public pure returns (address token) {\n        token = _Token;\n    }\n\n}\n\n\n\n\n\n\n/// @title Staking\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.2.0\n/// @dev State Machine: https://github.com/erasureprotocol/erasure-protocol/blob/v1.2.0/docs/state-machines/modules/Staking.png\ncontract Staking is Deposit, BurnNMR {\n\n    using SafeMath for uint256;\n\n    event StakeAdded(address staker, address funder, uint256 amount);\n    event StakeTaken(address staker, address recipient, uint256 amount);\n    event StakeBurned(address staker, uint256 amount);\n\n    function _addStake(address staker, address funder, uint256 amountToAdd) internal {\n        // update deposit\n        Deposit._increaseDeposit(staker, amountToAdd);\n\n        // transfer the stake amount\n        require(IERC20(BurnNMR.getToken()).transferFrom(funder, address(this), amountToAdd), \"token transfer failed\");\n\n        // emit event\n        emit StakeAdded(staker, funder, amountToAdd);\n    }\n\n    function _takeStake(address staker, address recipient, uint256 amountToTake) internal returns (uint256 newStake) {\n        // update deposit\n        uint256 newDeposit = Deposit._decreaseDeposit(staker, amountToTake);\n\n        // transfer the stake amount\n        require(IERC20(BurnNMR.getToken()).transfer(recipient, amountToTake), \"token transfer failed\");\n\n        // emit event\n        emit StakeTaken(staker, recipient, amountToTake);\n\n        // return\n        return newDeposit;\n    }\n\n    function _takeFullStake(address staker, address recipient) internal returns (uint256 amountTaken) {\n        // get deposit\n        uint256 currentDeposit = Deposit.getDeposit(staker);\n\n        // take full stake\n        _takeStake(staker, recipient, currentDeposit);\n\n        // return\n        return currentDeposit;\n    }\n\n    function _burnStake(address staker, uint256 amountToBurn) internal returns (uint256 newStake) {\n        // update deposit\n        uint256 newDeposit = Deposit._decreaseDeposit(staker, amountToBurn);\n\n        // burn the stake amount\n        BurnNMR._burn(amountToBurn);\n\n        // emit event\n        emit StakeBurned(staker, amountToBurn);\n\n        // return\n        return newDeposit;\n    }\n\n    function _burnFullStake(address staker) internal returns (uint256 amountBurned) {\n        // get deposit\n        uint256 currentDeposit = Deposit.getDeposit(staker);\n\n        // burn full stake\n        _burnStake(staker, currentDeposit);\n\n        // return\n        return currentDeposit;\n    }\n\n    // view functions\n\n    function getStake(address staker) public view returns (uint256 stake) {\n        return Deposit.getDeposit(staker);\n    }\n\n}\n\n\n\n\n/// @title Griefing\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.2.0\n/// @dev State Machine: https://github.com/erasureprotocol/erasure-protocol/blob/v1.2.0/docs/state-machines/modules/Griefing.png\ncontract Griefing is Staking {\n\n    enum RatioType { NaN, Inf, Dec }\n\n    mapping (address => GriefRatio) private _griefRatio;\n    struct GriefRatio {\n        uint256 ratio;\n        RatioType ratioType;\n   }\n\n    event RatioSet(address staker, uint256 ratio, RatioType ratioType);\n    event Griefed(address punisher, address staker, uint256 punishment, uint256 cost, bytes message);\n\n    uint256 internal constant e18 = uint256(10) ** uint256(18);\n\n    // state functions\n\n    /// @notice Set the grief ratio and type for a given staker\n    /// @param staker Address of the staker\n    /// @param ratio Uint256 number (18 decimals)\n    ///              NOTE: ratio must be 0 if ratioType is Inf or NaN\n    /// @param ratioType Griefing.RatioType number. Ratio Type must be one of the following three values:\n    ///                   - Dec: Ratio is a decimal number with 18 decimals\n    ///                   - Inf: Punishment at no cost\n    ///                   - NaN: No Punishment\n    function _setRatio(address staker, uint256 ratio, RatioType ratioType) internal {\n        if (ratioType == RatioType.NaN || ratioType == RatioType.Inf) {\n            require(ratio == 0, \"ratio must be 0 when ratioType is NaN or Inf\");\n        }\n\n        // set data in storage\n        _griefRatio[staker].ratio = ratio;\n        _griefRatio[staker].ratioType = ratioType;\n\n        // emit event\n        emit RatioSet(staker, ratio, ratioType);\n    }\n\n    /// @notice Punish a stake through griefing\n    ///         NOTE: the cost of the punishment is taken form the account of the punisher. This therefore requires appropriate ERC-20 token approval.\n    /// @param punisher Address of the punisher\n    /// @param staker Address of the staker\n    /// @param punishment Amount of NMR (18 decimals) to punish\n    /// @param message Bytes reason string for the punishment\n    /// @return cost Amount of NMR (18 decimals) to pay\n    function _grief(\n        address punisher,\n        address staker,\n        uint256 punishment,\n        bytes memory message\n    ) internal returns (uint256 cost) {\n        // get grief data from storage\n        uint256 ratio = _griefRatio[staker].ratio;\n        RatioType ratioType = _griefRatio[staker].ratioType;\n\n        require(ratioType != RatioType.NaN, \"no punishment allowed\");\n\n        // calculate cost\n        // getCost also acts as a guard when _setRatio is not called before\n        cost = getCost(ratio, punishment, ratioType);\n\n        // burn the cost from the punisher's balance\n        BurnNMR._burnFrom(punisher, cost);\n\n        // burn the punishment from the target's stake\n        Staking._burnStake(staker, punishment);\n\n        // emit event\n        emit Griefed(punisher, staker, punishment, cost, message);\n\n        // return\n        return cost;\n    }\n\n    // view functions\n\n    /// @notice Get the ratio of a staker\n    /// @param staker Address of the staker\n    /// @return ratio Uint256 number (18 decimals)\n    /// @return ratioType Griefing.RatioType number. Ratio Type must be one of the following three values:\n    ///                   - Dec: Ratio is a decimal number with 18 decimals\n    ///                   - Inf: Punishment at no cost\n    ///                   - NaN: No Punishment\n    function getRatio(address staker) public view returns (uint256 ratio, RatioType ratioType) {\n        // get stake data from storage\n        return (_griefRatio[staker].ratio, _griefRatio[staker].ratioType);\n    }\n\n    // pure functions\n\n    /// @notice Get exact cost for a given punishment and ratio\n    /// @param ratio Uint256 number (18 decimals)\n    /// @param punishment Amount of NMR (18 decimals) to punish\n    /// @param ratioType Griefing.RatioType number. Ratio Type must be one of the following three values:\n    ///                   - Dec: Ratio is a decimal number with 18 decimals\n    ///                   - Inf: Punishment at no cost\n    ///                   - NaN: No Punishment\n    /// @return cost Amount of NMR (18 decimals) to pay\n    function getCost(uint256 ratio, uint256 punishment, RatioType ratioType) public pure returns(uint256 cost) {\n        if (ratioType == RatioType.Dec) {\n            return DecimalMath.mul(SafeMath.mul(punishment, e18), ratio) / e18;\n        }\n        if (ratioType == RatioType.Inf)\n            return 0;\n        if (ratioType == RatioType.NaN)\n            revert(\"ratioType cannot be RatioType.NaN\");\n    }\n\n    /// @notice Get approximate punishment for a given cost and ratio.\n    ///         The punishment is an approximate value due to quantization / rounding.\n    /// @param ratio Uint256 number (18 decimals)\n    /// @param cost Amount of NMR (18 decimals) to pay\n    /// @param ratioType Griefing.RatioType number. Ratio Type must be one of the following three values:\n    ///                   - Dec: Ratio is a decimal number with 18 decimals\n    ///                   - Inf: Punishment at no cost\n    ///                   - NaN: No Punishment\n    /// @return punishment Approximate amount of NMR (18 decimals) to punish\n    function getPunishment(uint256 ratio, uint256 cost, RatioType ratioType) public pure returns(uint256 punishment) {\n        if (ratioType == RatioType.Dec) {\n            return DecimalMath.div(SafeMath.mul(cost, e18), ratio) / e18;\n        }\n        if (ratioType == RatioType.Inf)\n            revert(\"ratioType cannot be RatioType.Inf\");\n        if (ratioType == RatioType.NaN)\n            revert(\"ratioType cannot be RatioType.NaN\");\n    }\n\n}\n\n\n\n\n\n\n/// @title SimpleGriefing\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.2.0\n/// @dev State Machine: https://github.com/erasureprotocol/erasure-protocol/blob/v1.2.0/docs/state-machines/agreements/SimpleGriefing.png\n/// @notice This agreement template allows a staker to grant permission to a counterparty to punish, reward, or release their stake.\n///         A new instance is initialized by the factory using the `initData` received. See the `initialize()` function for details on initialization parameters.\n///         Notable features:\n///             - The staker can increase the stake at any time.\n///             - The counterparty can increase, release, or punish the stake at any time.\n///             - The agreement can be terminated by the counterparty by releasing or punishing the full stake amount. Note it is always possible for the staker to increase their stake again.\n///             - Punishments use griefing which requires the counterparty to pay an appropriate amount based on the desired punishment and a predetermined ratio.\n///             - An operator can optionally be defined to grant full permissions to a trusted external address or contract.\ncontract SimpleGriefing is Griefing, EventMetadata, Operated, Template {\n\n    using SafeMath for uint256;\n\n    Data private _data;\n    struct Data {\n        address staker;\n        address counterparty;\n    }\n\n    event Initialized(address operator, address staker, address counterparty, uint256 ratio, Griefing.RatioType ratioType, bytes metadata);\n\n    /// @notice Constructor used to initialize the agreement parameters.\n    ///         All parameters are passed as ABI-encoded calldata to the factory. This calldata must include the function selector.\n    /// @dev Access Control: only factory\n    ///      State Machine: before all\n    /// @param operator address of the operator that overrides access control. Optional parameter. Passing the address(0) will disable operator functionality.\n    /// @param staker address of the staker who owns the stake. Required parameter. This address is the only one able to retrieve the stake and cannot be changed.\n    /// @param counterparty address of the counterparty who has the right to reward, release, and punish the stake. Required parameter. This address cannot be changed.\n    /// @param ratio uint256 number (18 decimals) used to determine punishment cost. Required parameter. See Griefing module for details on valid input.\n    /// @param ratioType Griefing.RatioType number used to determine punishment cost. Required parameter. See Griefing module for details on valid input.\n    /// @param metadata bytes data (any format) to emit as event on initialization. Optional parameter.\n    function initialize(\n        address operator,\n        address staker,\n        address counterparty,\n        uint256 ratio,\n        Griefing.RatioType ratioType,\n        bytes memory metadata\n    ) public initializeTemplate() {\n        // set storage values\n        _data.staker = staker;\n        _data.counterparty = counterparty;\n\n        // set operator\n        if (operator != address(0)) {\n            Operated._setOperator(operator);\n        }\n\n        // set griefing ratio\n        Griefing._setRatio(staker, ratio, ratioType);\n\n        // set metadata\n        if (metadata.length != 0) {\n            EventMetadata._setMetadata(metadata);\n        }\n\n        // log initialization params\n        emit Initialized(operator, staker, counterparty, ratio, ratioType, metadata);\n    }\n\n    // state functions\n\n    /// @notice Emit metadata event\n    /// @dev Access Control: operator\n    ///      State Machine: always\n    /// @param metadata bytes data (any format) to emit as event\n    function setMetadata(bytes memory metadata) public {\n        // restrict access\n        require(Operated.isOperator(msg.sender), \"only operator\");\n\n        // update metadata\n        EventMetadata._setMetadata(metadata);\n    }\n\n    /// @notice Called by the staker to increase the stake\n    ///          - tokens (ERC-20) are transfered from the caller and requires approval of this contract for appropriate amount\n    /// @dev Access Control: staker OR operator\n    ///      State Machine: anytime\n    /// @param amountToAdd uint256 amount of NMR (18 decimals) to be added to the stake\n    function increaseStake(uint256 amountToAdd) public {\n        // restrict access\n        require(isStaker(msg.sender) || Operated.isOperator(msg.sender), \"only staker or operator\");\n\n        // add stake\n        Staking._addStake(_data.staker, msg.sender, amountToAdd);\n    }\n\n    /// @notice Called by the counterparty to increase the stake\n    ///          - tokens (ERC-20) are transfered from the caller and requires approval of this contract for appropriate amount\n    /// @dev Access Control: counterparty OR operator\n    ///      State Machine: anytime\n    /// @param amountToAdd uint256 amount of NMR (18 decimals) to be added to the stake\n    function reward(uint256 amountToAdd) public {\n        // restrict access\n        require(isCounterparty(msg.sender) || Operated.isOperator(msg.sender), \"only counterparty or operator\");\n\n        // add stake\n        Staking._addStake(_data.staker, msg.sender, amountToAdd);\n    }\n\n    /// @notice Called by the counterparty to punish the stake\n    ///          - burns the punishment from the stake and a proportional amount from the counterparty balance\n    ///          - the cost of the punishment is calculated with the `Griefing.getCost()` function using the predetermined griefing ratio\n    ///          - tokens (ERC-20) are burned from the caller and requires approval of this contract for appropriate amount\n    /// @dev Access Control: counterparty OR operator\n    ///      State Machine: anytime\n    /// @param punishment uint256 amount of NMR (18 decimals) to be burned from the stake\n    /// @param message bytes data (any format) to emit as event giving reason for the punishment\n    /// @return cost uint256 amount of NMR (18 decimals) it cost to perform punishment\n    function punish(uint256 punishment, bytes memory message) public returns (uint256 cost) {\n        // restrict access\n        require(isCounterparty(msg.sender) || Operated.isOperator(msg.sender), \"only counterparty or operator\");\n\n        // execute griefing\n        cost = Griefing._grief(msg.sender, _data.staker, punishment, message);\n    }\n\n    /// @notice Called by the counterparty to release the stake to the staker\n    /// @dev Access Control: counterparty OR operator\n    ///      State Machine: anytime\n    /// @param amountToRelease uint256 amount of NMR (18 decimals) to be released from the stake\n    function releaseStake(uint256 amountToRelease) public {\n        // restrict access\n        require(isCounterparty(msg.sender) || Operated.isOperator(msg.sender), \"only counterparty or operator\");\n\n        // release stake back to the staker\n        Staking._takeStake(_data.staker, _data.staker, amountToRelease);\n    }\n\n    /// @notice Called by the operator to transfer control to new operator\n    /// @dev Access Control: operator\n    ///      State Machine: anytime\n    /// @param operator address of the new operator\n    function transferOperator(address operator) public {\n        // restrict access\n        require(Operated.isOperator(msg.sender), \"only operator\");\n\n        // transfer operator\n        Operated._transferOperator(operator);\n    }\n\n    /// @notice Called by the operator to renounce control\n    /// @dev Access Control: operator\n    ///      State Machine: anytime\n    function renounceOperator() public {\n        // restrict access\n        require(Operated.isOperator(msg.sender), \"only operator\");\n\n        // renounce operator\n        Operated._renounceOperator();\n    }\n\n    // view functions\n\n    /// @notice Get the address of the staker (if set)\n    /// @return staker address of the staker\n    function getStaker() public view returns (address staker) {\n        return _data.staker;\n    }\n\n    /// @notice Validate if the address matches the stored staker address\n    /// @param caller address to validate\n    /// @return validity bool true if matching address\n    function isStaker(address caller) internal view returns (bool validity) {\n        return caller == getStaker();\n    }\n\n    /// @notice Get the address of the counterparty (if set)\n    /// @return counterparty address of counterparty account\n    function getCounterparty() public view returns (address counterparty) {\n        return _data.counterparty;\n    }\n\n    /// @notice Validate if the address matches the stored counterparty address\n    /// @param caller address to validate\n    /// @return validity bool true if matching address\n    function isCounterparty(address caller) internal view returns (bool validity) {\n        return caller == getCounterparty();\n    }\n\n    /// @notice Get the current stake of the agreement\n    /// @return stake uint256 amount of NMR (18 decimals) staked\n    function getCurrentStake() public view returns (uint256 stake) {\n        return Staking.getStake(_data.staker);\n    }\n\n    enum AgreementStatus { isInitialized, isStaked }\n    /// @notice Get the status of the state machine\n    /// @return status AgreementStatus from the following states:\n    ///          - isInitialized: initialized but no deposits made\n    ///          - isStaked: stake is deposited\n    function getAgreementStatus() public view returns (AgreementStatus status) {\n        if (getCurrentStake() > 0) {\n            return AgreementStatus.isStaked;\n        } else {\n            return AgreementStatus.isInitialized;\n        }\n    }\n\n    /// @notice Validate if the state machine is in the AgreementStatus.isInitialized state\n    /// @return validity bool true if correct state\n    function isInitialized() internal view returns (bool validity) {\n        return getAgreementStatus() == AgreementStatus.isInitialized;\n    }\n\n    /// @notice Validate if the state machine is in the AgreementStatus.isStaked state\n    /// @return validity bool true if correct state\n    function isStaked() internal view returns (bool validity) {\n        return getAgreementStatus() == AgreementStatus.isStaked;\n    }\n}\n","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDeposit\",\"type\":\"uint256\"}],\"name\":\"DepositDecreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDeposit\",\"type\":\"uint256\"}],\"name\":\"DepositIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"punisher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"punishment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"Griefed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"counterparty\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum Griefing.RatioType\",\"name\":\"ratioType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"MetadataSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum Griefing.RatioType\",\"name\":\"ratioType\",\"type\":\"uint8\"}],\"name\":\"RatioSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"funder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeTaken\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAgreementStatus\",\"outputs\":[{\"internalType\":\"enum SimpleGriefing.AgreementStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"punishment\",\"type\":\"uint256\"},{\"internalType\":\"enum Griefing.RatioType\",\"name\":\"ratioType\",\"type\":\"uint8\"}],\"name\":\"getCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCounterparty\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"counterparty\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCreator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"internalType\":\"enum Griefing.RatioType\",\"name\":\"ratioType\",\"type\":\"uint8\"}],\"name\":\"getPunishment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"punishment\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"enum Griefing.RatioType\",\"name\":\"ratioType\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStaker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToAdd\",\"type\":\"uint256\"}],\"name\":\"increaseStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"counterparty\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"enum Griefing.RatioType\",\"name\":\"ratioType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"punishment\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"punish\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToRelease\",\"type\":\"uint256\"}],\"name\":\"releaseStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToAdd\",\"type\":\"uint256\"}],\"name\":\"reward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"setMetadata\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"transferOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SimpleGriefing","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://3770a33a9573e03534e5a555a777e1ea7b01c915ff986b8b33cb388445506827"}]}