{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-03-04\r\n*/\r\n\r\npragma solidity 0.5.11; // optimization runs: 200, evm version: petersburg\r\n// WARNING - `executeActionWithAtomicBatchCalls` has a `bytes[]` argument that\r\n// requires ABIEncoderV2. Exercise caution when calling that specific function.\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface DharmaSmartWalletImplementationV1Interface {\r\n  event CallSuccess(\r\n    bytes32 actionID,\r\n    bool rolledBack,\r\n    uint256 nonce,\r\n    address to,\r\n    bytes data,\r\n    bytes returnData\r\n  );\r\n\r\n  event CallFailure(\r\n    bytes32 actionID,\r\n    uint256 nonce,\r\n    address to,\r\n    bytes data,\r\n    string revertReason\r\n  );\r\n\r\n  // ABIEncoderV2 uses an array of Calls for executing generic batch calls.\r\n  struct Call {\r\n    address to;\r\n    bytes data;\r\n  }\r\n\r\n  // ABIEncoderV2 uses an array of CallReturns for handling generic batch calls.\r\n  struct CallReturn {\r\n    bool ok;\r\n    bytes returnData;\r\n  }\r\n\r\n  function withdrawEther(\r\n    uint256 amount,\r\n    address payable recipient,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external returns (bool ok);\r\n\r\n  function executeAction(\r\n    address to,\r\n    bytes calldata data,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external returns (bool ok, bytes memory returnData);\r\n\r\n  function recover(address newUserSigningKey) external;\r\n\r\n  function executeActionWithAtomicBatchCalls(\r\n    Call[] calldata calls,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external returns (bool[] memory ok, bytes[] memory returnData);\r\n\r\n  function getNextGenericActionID(\r\n    address to,\r\n    bytes calldata data,\r\n    uint256 minimumActionGas\r\n  ) external view returns (bytes32 actionID);\r\n\r\n  function getGenericActionID(\r\n    address to,\r\n    bytes calldata data,\r\n    uint256 nonce,\r\n    uint256 minimumActionGas\r\n  ) external view returns (bytes32 actionID);\r\n\r\n  function getNextGenericAtomicBatchActionID(\r\n    Call[] calldata calls,\r\n    uint256 minimumActionGas\r\n  ) external view returns (bytes32 actionID);\r\n\r\n  function getGenericAtomicBatchActionID(\r\n    Call[] calldata calls,\r\n    uint256 nonce,\r\n    uint256 minimumActionGas\r\n  ) external view returns (bytes32 actionID);\r\n}\r\n\r\n\r\ninterface DharmaSmartWalletImplementationV3Interface {\r\n  event Cancel(uint256 cancelledNonce);\r\n  event EthWithdrawal(uint256 amount, address recipient);\r\n}\r\n\r\n\r\ninterface DharmaSmartWalletImplementationV4Interface {\r\n  event Escaped();\r\n\r\n  function setEscapeHatch(\r\n    address account,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external;\r\n\r\n  function removeEscapeHatch(\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external;\r\n\r\n  function permanentlyDisableEscapeHatch(\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external;\r\n\r\n  function escape() external;\r\n}\r\n\r\n\r\ninterface DharmaSmartWalletImplementationV7Interface {\r\n  // Fires when a new user signing key is set on the smart wallet.\r\n  event NewUserSigningKey(address userSigningKey);\r\n\r\n  // Fires when an error occurs as part of an attempted action.\r\n  event ExternalError(address indexed source, string revertReason);\r\n\r\n  // The smart wallet recognizes DAI, USDC, ETH, and SAI as supported assets.\r\n  enum AssetType {\r\n    DAI,\r\n    USDC,\r\n    ETH,\r\n    SAI\r\n  }\r\n\r\n  // Actions, or protected methods (i.e. not deposits) each have an action type.\r\n  enum ActionType {\r\n    Cancel,\r\n    SetUserSigningKey,\r\n    Generic,\r\n    GenericAtomicBatch,\r\n    SAIWithdrawal,\r\n    USDCWithdrawal,\r\n    ETHWithdrawal,\r\n    SetEscapeHatch,\r\n    RemoveEscapeHatch,\r\n    DisableEscapeHatch,\r\n    DAIWithdrawal,\r\n    SignatureVerification,\r\n    TradeEthForDai,\r\n    DAIBorrow,\r\n    USDCBorrow\r\n  }\r\n\r\n  function initialize(address userSigningKey) external;\r\n\r\n  function repayAndDeposit() external;\r\n\r\n  function withdrawDai(\r\n    uint256 amount,\r\n    address recipient,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external returns (bool ok);\r\n\r\n  function withdrawUSDC(\r\n    uint256 amount,\r\n    address recipient,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external returns (bool ok);\r\n\r\n  function cancel(\r\n    uint256 minimumActionGas,\r\n    bytes calldata signature\r\n  ) external;\r\n\r\n  function setUserSigningKey(\r\n    address userSigningKey,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external;\r\n\r\n  function migrateSaiToDai() external;\r\n\r\n  function migrateCSaiToDDai() external;\r\n\r\n  function migrateCDaiToDDai() external;\r\n\r\n  function migrateCUSDCToDUSDC() external;\r\n\r\n  function getBalances() external view returns (\r\n    uint256 daiBalance,\r\n    uint256 usdcBalance,\r\n    uint256 etherBalance,\r\n    uint256 dDaiUnderlyingDaiBalance,\r\n    uint256 dUsdcUnderlyingUsdcBalance,\r\n    uint256 dEtherUnderlyingEtherBalance // always returns zero\r\n  );\r\n\r\n  function getUserSigningKey() external view returns (address userSigningKey);\r\n\r\n  function getNonce() external view returns (uint256 nonce);\r\n\r\n  function getNextCustomActionID(\r\n    ActionType action,\r\n    uint256 amount,\r\n    address recipient,\r\n    uint256 minimumActionGas\r\n  ) external view returns (bytes32 actionID);\r\n\r\n  function getCustomActionID(\r\n    ActionType action,\r\n    uint256 amount,\r\n    address recipient,\r\n    uint256 nonce,\r\n    uint256 minimumActionGas\r\n  ) external view returns (bytes32 actionID);\r\n\r\n  function getVersion() external pure returns (uint256 version);\r\n}\r\n\r\n\r\ninterface DharmaSmartWalletImplementationV8Interface {\r\n  function tradeEthForDaiAndMintDDai(\r\n    uint256 ethToSupply,\r\n    uint256 minimumDaiReceived,\r\n    address target,\r\n    bytes calldata data,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external returns (bool ok, bytes memory returnData);\r\n\r\n  function getNextEthForDaiActionID(\r\n    uint256 ethToSupply,\r\n    uint256 minimumDaiReceived,\r\n    address target,\r\n    bytes calldata data,\r\n    uint256 minimumActionGas\r\n  ) external view returns (bytes32 actionID);\r\n\r\n  function getEthForDaiActionID(\r\n    uint256 ethToSupply,\r\n    uint256 minimumDaiReceived,\r\n    address target,\r\n    bytes calldata data,\r\n    uint256 nonce,\r\n    uint256 minimumActionGas\r\n  ) external view returns (bytes32 actionID);\r\n}\r\n\r\n\r\ninterface ERC20Interface {\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  function balanceOf(address account) external view returns (uint256);\r\n  function allowance(\r\n    address owner, address spender\r\n  ) external view returns (uint256);\r\n}\r\n\r\n\r\ninterface ERC1271Interface {\r\n  function isValidSignature(\r\n    bytes calldata data, bytes calldata signature\r\n  ) external view returns (bytes4 magicValue);\r\n}\r\n\r\n\r\ninterface CTokenInterface {\r\n  function redeem(uint256 redeemAmount) external returns (uint256 err);\r\n  function transfer(address recipient, uint256 value) external returns (bool);\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  function balanceOf(address account) external view returns (uint256 balance);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n}\r\n\r\n\r\ninterface DTokenInterface {\r\n  // These external functions trigger accrual on the dToken and backing cToken.\r\n  function mint(uint256 underlyingToSupply) external returns (uint256 dTokensMinted);\r\n  function redeem(uint256 dTokensToBurn) external returns (uint256 underlyingReceived);\r\n  function redeemUnderlying(uint256 underlyingToReceive) external returns (uint256 dTokensBurned);\r\n\r\n  // These external functions only trigger accrual on the dToken.\r\n  function mintViaCToken(uint256 cTokensToSupply) external returns (uint256 dTokensMinted);\r\n\r\n  // View and pure functions do not trigger accrual on the dToken or the cToken.\r\n  function balanceOfUnderlying(address account) external view returns (uint256 underlyingBalance);\r\n}\r\n\r\n\r\ninterface USDCV1Interface {\r\n  function isBlacklisted(address _account) external view returns (bool);\r\n  function paused() external view returns (bool);\r\n}\r\n\r\n\r\ninterface DharmaKeyRegistryInterface {\r\n  function getKey() external view returns (address key);\r\n}\r\n\r\n\r\ninterface DharmaEscapeHatchRegistryInterface {\r\n  function setEscapeHatch(address newEscapeHatch) external;\r\n\r\n  function removeEscapeHatch() external;\r\n\r\n  function permanentlyDisableEscapeHatch() external;\r\n\r\n  function getEscapeHatch() external view returns (\r\n    bool exists, address escapeHatch\r\n  );\r\n}\r\n\r\n\r\ninterface SaiToDaiMigratorInterface {\r\n  function swapSaiToDai(uint256 balance) external;\r\n}\r\n\r\n\r\ninterface TradeHelperInterface {\r\n  function trade(\r\n    address target, bytes calldata data\r\n  ) external payable returns (uint256 daiReceived);\r\n}\r\n\r\n\r\ninterface RevertReasonHelperInterface {\r\n  function reason(uint256 code) external pure returns (string memory);\r\n}\r\n\r\n\r\nlibrary Address {\r\n  function isContract(address account) internal view returns (bool) {\r\n    uint256 size;\r\n    assembly { size := extcodesize(account) }\r\n    return size > 0;\r\n  }\r\n}\r\n\r\n\r\nlibrary ECDSA {\r\n  function recover(\r\n    bytes32 hash, bytes memory signature\r\n  ) internal pure returns (address) {\r\n    if (signature.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    assembly {\r\n      r := mload(add(signature, 0x20))\r\n      s := mload(add(signature, 0x40))\r\n      v := byte(0, mload(add(signature, 0x60)))\r\n    }\r\n\r\n    if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n      return address(0);\r\n    }\r\n\r\n    if (v != 27 && v != 28) {\r\n      return address(0);\r\n    }\r\n\r\n    return ecrecover(hash, v, r, s);\r\n  }\r\n\r\n  function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title DharmaSmartWalletImplementationV8 (staging version)\r\n * @author 0age\r\n * @notice The V8 implementation for the Dharma smart wallet is a non-custodial,\r\n * meta-transaction-enabled wallet with helper functions to facilitate lending\r\n * funds through Dharma Dai and Dharma USD Coin (which in turn use CompoundV2),\r\n * and with an added security backstop provided by Dharma Labs prior to making\r\n * withdrawals. It adds support for Dharma Dai and Dharma USD Coin - they employ\r\n * the respective cTokens as backing tokens and mint and redeem them internally\r\n * as interest-bearing collateral. This implementation also contains methods to\r\n * support account recovery, escape hatch functionality, and generic actions,\r\n * including in an atomic batch. The smart wallet instances utilizing this\r\n * implementation are deployed through the Dharma Smart Wallet Factory via\r\n * `CREATE2`, which allows for their address to be known ahead of time, and any\r\n * Dai or USDC that has already been sent into that address will automatically\r\n * be deposited into the respective Dharma Token upon deployment of the new\r\n * smart wallet instance. V8 also supports Eth-to-Dai trades.\r\n */\r\ncontract DharmaSmartWalletImplementationV8Staging is\r\n  DharmaSmartWalletImplementationV1Interface,\r\n  DharmaSmartWalletImplementationV3Interface,\r\n  DharmaSmartWalletImplementationV4Interface,\r\n  DharmaSmartWalletImplementationV7Interface,\r\n  DharmaSmartWalletImplementationV8Interface,\r\n  ERC1271Interface {\r\n  using Address for address;\r\n  using ECDSA for bytes32;\r\n  // WARNING: DO NOT REMOVE OR REORDER STORAGE WHEN WRITING NEW IMPLEMENTATIONS!\r\n\r\n  // The user signing key associated with this account is in storage slot 0.\r\n  // It is the core differentiator when it comes to the account in question.\r\n  address private _userSigningKey;\r\n\r\n  // The nonce associated with this account is in storage slot 1. Every time a\r\n  // signature is submitted, it must have the appropriate nonce, and once it has\r\n  // been accepted the nonce will be incremented.\r\n  uint256 private _nonce;\r\n\r\n  // The self-call context flag is in storage slot 2. Some protected functions\r\n  // may only be called externally from calls originating from other methods on\r\n  // this contract, which enables appropriate exception handling on reverts.\r\n  // Any storage should only be set immediately preceding a self-call and should\r\n  // be cleared upon entering the protected function being called.\r\n  bytes4 internal _selfCallContext;\r\n\r\n  // END STORAGE DECLARATIONS - DO NOT REMOVE OR REORDER STORAGE ABOVE HERE!\r\n\r\n  // The smart wallet version will be used when constructing valid signatures.\r\n  uint256 internal constant _DHARMA_SMART_WALLET_VERSION = 8;\r\n\r\n  // DharmaKeyRegistryV2Staging holds a public key to verify meta-transactions.\r\n  DharmaKeyRegistryInterface internal constant _DHARMA_KEY_REGISTRY = (\r\n    DharmaKeyRegistryInterface(0x00000000006c7f32F0cD1eA4C1383558eb68802D)\r\n  );\r\n\r\n  // Account recovery uses a hard-coded staging version of the recovery manager.\r\n  address internal constant _ACCOUNT_RECOVERY_MANAGER = address(\r\n    0x2a7E7718b755F9868E6B64DD18C6886707DD9c10\r\n  );\r\n\r\n  // Users can designate an \"escape hatch\" account with the ability to sweep all\r\n  // funds from their smart wallet by using the Dharma Escape Hatch Registry.\r\n  DharmaEscapeHatchRegistryInterface internal constant _ESCAPE_HATCH_REGISTRY = (\r\n    DharmaEscapeHatchRegistryInterface(0x00000000005280B515004B998a944630B6C663f8)\r\n  );\r\n\r\n  // Interface with dDai, dUSDC, Dai, USDC, Sai, cSai, cDai, cUSDC, & migrator.\r\n  DTokenInterface internal constant _DDAI = DTokenInterface(\r\n    0x00000000001876eB1444c986fD502e618c587430 // mainnet\r\n  );\r\n\r\n  DTokenInterface internal constant _DUSDC = DTokenInterface(\r\n    0x00000000008943c65cAf789FFFCF953bE156f6f8 // mainnet\r\n  );\r\n\r\n  ERC20Interface internal constant _DAI = ERC20Interface(\r\n    0x6B175474E89094C44Da98b954EedeAC495271d0F // mainnet\r\n  );\r\n\r\n  ERC20Interface internal constant _USDC = ERC20Interface(\r\n    0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 // mainnet\r\n  );\r\n\r\n  ERC20Interface internal constant _SAI = ERC20Interface(\r\n    0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359 // mainnet\r\n  );\r\n\r\n  CTokenInterface internal constant _CSAI = CTokenInterface(\r\n    0xF5DCe57282A584D2746FaF1593d3121Fcac444dC // mainnet\r\n  );\r\n\r\n  CTokenInterface internal constant _CDAI = CTokenInterface(\r\n    0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643 // mainnet\r\n  );\r\n\r\n  CTokenInterface internal constant _CUSDC = CTokenInterface(\r\n    0x39AA39c021dfbaE8faC545936693aC917d5E7563 // mainnet\r\n  );\r\n\r\n  SaiToDaiMigratorInterface internal constant _MIGRATOR = SaiToDaiMigratorInterface(\r\n    0xc73e0383F3Aff3215E6f04B0331D58CeCf0Ab849 // mainnet\r\n  );\r\n  \r\n  // The \"trade helper\" facilitates Eth-to-Dai trades in an isolated context.\r\n  TradeHelperInterface internal constant _TRADE_HELPER = TradeHelperInterface(\r\n    0x979Cee879BbeA69c050A3cB158b97F402524E4b3\r\n  );\r\n\r\n  // The \"revert reason helper\" contains a collection of revert reason strings.\r\n  RevertReasonHelperInterface internal constant _REVERT_REASON_HELPER = (\r\n    RevertReasonHelperInterface(0x9C0ccB765D3f5035f8b5Dd30fE375d5F4997D8E4)\r\n  );\r\n\r\n  // Compound returns a value of 0 to indicate success, or lack of an error.\r\n  uint256 internal constant _COMPOUND_SUCCESS = 0;\r\n\r\n  // ERC-1271 must return this magic value when `isValidSignature` is called.\r\n  bytes4 internal constant _ERC_1271_MAGIC_VALUE = bytes4(0x20c13b0b);\r\n\r\n  // Minimum supported deposit & non-maximum withdrawal size is .001 underlying.\r\n  uint256 private constant _JUST_UNDER_ONE_1000th_DAI = 999999999999999;\r\n  uint256 private constant _JUST_UNDER_ONE_1000th_USDC = 999;\r\n\r\n  // Specify the amount of gas to supply when making Ether transfers.\r\n  uint256 private constant _ETH_TRANSFER_GAS = 4999;\r\n\r\n  /**\r\n   * @notice Accept Ether in the fallback.\r\n   */\r\n  function () external payable {}\r\n\r\n  /**\r\n   * @notice In the initializer, set up the initial user signing key, set\r\n   * approval on the Dharma Dai and Dharma USD Coin contracts, and deposit any\r\n   * Dai or USDC already at this address to receive dDai or dUSDC. Note that\r\n   * this initializer is only callable while the smart wallet instance is still\r\n   * in the contract creation phase.\r\n   * @param userSigningKey address The initial user signing key for the smart\r\n   * wallet.\r\n   */\r\n  function initialize(address userSigningKey) external {\r\n    // Ensure that this function is only callable during contract construction.\r\n    assembly { if extcodesize(address) { revert(0, 0) } }\r\n\r\n    // Set up the user's signing key and emit a corresponding event.\r\n    _setUserSigningKey(userSigningKey);\r\n\r\n    // Approve the dDai contract to transfer Dai on behalf of this contract.\r\n    if (_setFullApproval(AssetType.DAI)) {\r\n      // Get the current Dai balance on this contract.\r\n      uint256 daiBalance = _DAI.balanceOf(address(this));\r\n\r\n      // Try to deposit the full Dai balance to Dharma Dai.\r\n      _depositDharmaToken(AssetType.DAI, daiBalance);\r\n    }\r\n\r\n    // Approve the dUSDC contract to transfer USDC on behalf of this contract.\r\n    if (_setFullApproval(AssetType.USDC)) {\r\n      // Get the current USDC balance on this contract.\r\n      uint256 usdcBalance = _USDC.balanceOf(address(this));\r\n\r\n      // Try to deposit the full Dai balance to Dharma USDC.\r\n      _depositDharmaToken(AssetType.USDC, usdcBalance);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Deposit all Dai and USDC currently residing at this address and\r\n   * receive Dharma Dai or Dharma USD Coin in return. Note that \"repay\" is not\r\n   * currently implemented, though it may be in a future implementation. If some\r\n   * step of this function fails, the function itself will still succeed, but an\r\n   * `ExternalError` with information on what went wrong will be emitted.\r\n   */\r\n  function repayAndDeposit() external {\r\n    // Get the current Dai balance on this contract.\r\n    uint256 daiBalance = _DAI.balanceOf(address(this));\r\n\r\n    // If there is any Dai balance, check for adequate approval for dDai.\r\n    if (daiBalance > 0) {\r\n      uint256 daiAllowance = _DAI.allowance(address(this), address(_DDAI));\r\n      // If allowance is insufficient, try to set it before depositing.\r\n      if (daiAllowance < daiBalance) {\r\n        if (_setFullApproval(AssetType.DAI)) {\r\n          // Deposit the full available Dai balance to Dharma Dai.\r\n          _depositDharmaToken(AssetType.DAI, daiBalance);\r\n        }\r\n      // Otherwise, just go ahead and try the Dai deposit.\r\n      } else {\r\n        // Deposit the full available Dai balance to Dharma Dai.\r\n        _depositDharmaToken(AssetType.DAI, daiBalance);\r\n      }\r\n    }\r\n\r\n    // Get the current USDC balance on this contract.\r\n    uint256 usdcBalance = _USDC.balanceOf(address(this));\r\n\r\n    // If there is any USDC balance, check for adequate approval for dUSDC.\r\n    if (usdcBalance > 0) {\r\n      uint256 usdcAllowance = _USDC.allowance(address(this), address(_DUSDC));\r\n      // If allowance is insufficient, try to set it before depositing.\r\n      if (usdcAllowance < usdcBalance) {\r\n        if (_setFullApproval(AssetType.USDC)) {\r\n          // Deposit the full available USDC balance to Dharma USDC.\r\n          _depositDharmaToken(AssetType.USDC, usdcBalance);\r\n        }\r\n      // Otherwise, just go ahead and try the USDC deposit.\r\n      } else {\r\n        // Deposit the full available USDC balance to Dharma USDC.\r\n        _depositDharmaToken(AssetType.USDC, usdcBalance);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Withdraw Dai to a provided recipient address by redeeming the\r\n   * underlying Dai from the dDai contract and transferring it to the recipient.\r\n   * All Dai in Dharma Dai and in the smart wallet itself can be withdrawn by\r\n   * providing an amount of uint256(-1) or 0xfff...fff. This function can be\r\n   * called directly by the account set as the global key on the Dharma Key\r\n   * Registry, or by any relayer that provides a signed message from the same\r\n   * keyholder. The nonce used for the signature must match the current nonce on\r\n   * the smart wallet, and gas supplied to the call must exceed the specified\r\n   * minimum action gas, plus the gas that will be spent before the gas check is\r\n   * reached - usually somewhere around 25,000 gas. If the withdrawal fails, an\r\n   * `ExternalError` with additional details on what went wrong will be emitted.\r\n   * Note that some dust may still be left over, even in the event of a max\r\n   * withdrawal, due to the fact that Dai has a higher precision than dDai. Also\r\n   * note that the withdrawal will fail in the event that Compound does not have\r\n   * sufficient Dai available to withdraw.\r\n   * @param amount uint256 The amount of Dai to withdraw.\r\n   * @param recipient address The account to transfer the withdrawn Dai to.\r\n   * @param minimumActionGas uint256 The minimum amount of gas that must be\r\n   * provided to this call - be aware that additional gas must still be included\r\n   * to account for the cost of overhead incurred up until the start of this\r\n   * function call.\r\n   * @param userSignature bytes A signature that resolves to the public key\r\n   * set for this account in storage slot zero, `_userSigningKey`. If the user\r\n   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\r\n   * will be used. A unique hash returned from `getCustomActionID` is prefixed\r\n   * and hashed to create the message hash for the signature.\r\n   * @param dharmaSignature bytes A signature that resolves to the public key\r\n   * returned for this account from the Dharma Key Registry. A unique hash\r\n   * returned from `getCustomActionID` is prefixed and hashed to create the\r\n   * signed message.\r\n   * @return True if the withdrawal succeeded, otherwise false.\r\n   */\r\n  function withdrawDai(\r\n    uint256 amount,\r\n    address recipient,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external returns (bool ok) {\r\n    // Ensure caller and/or supplied signatures are valid and increment nonce.\r\n    _validateActionAndIncrementNonce(\r\n      ActionType.DAIWithdrawal,\r\n      abi.encode(amount, recipient),\r\n      minimumActionGas,\r\n      userSignature,\r\n      dharmaSignature\r\n    );\r\n\r\n    // Ensure that an amount of at least 0.001 Dai has been supplied.\r\n    require(amount > _JUST_UNDER_ONE_1000th_DAI, _revertReason(0));\r\n\r\n    // Ensure that a non-zero recipient has been supplied.\r\n    require(recipient != address(0), _revertReason(1));\r\n\r\n    // Set the self-call context in order to call _withdrawDaiAtomic.\r\n    _selfCallContext = this.withdrawDai.selector;\r\n\r\n    // Make the atomic self-call - if redeemUnderlying fails on dDai, it will\r\n    // succeed but nothing will happen except firing an ExternalError event. If\r\n    // the second part of the self-call (the Dai transfer) fails, it will revert\r\n    // and roll back the first part of the call as well as fire an ExternalError\r\n    // event after returning from the failed call.\r\n    bytes memory returnData;\r\n    (ok, returnData) = address(this).call(abi.encodeWithSelector(\r\n      this._withdrawDaiAtomic.selector, amount, recipient\r\n    ));\r\n\r\n    // If the atomic call failed, emit an event signifying a transfer failure.\r\n    if (!ok) {\r\n      emit ExternalError(address(_DAI), _revertReason(2));\r\n    } else {\r\n      // Set ok to false if the call succeeded but the withdrawal failed.\r\n      ok = abi.decode(returnData, (bool));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Protected function that can only be called from `withdrawDai` on\r\n   * this contract. It will attempt to withdraw the supplied amount of Dai, or\r\n   * the maximum amount if specified using `uint256(-1)`, to the supplied\r\n   * recipient address by redeeming the underlying Dai from the dDai contract\r\n   * and transferring it to the recipient. An ExternalError will be emitted and\r\n   * the transfer will be skipped if the call to `redeem` or `redeemUnderlying`\r\n   * fails, and any revert will be caught by `withdrawDai` and diagnosed in\r\n   * order to emit an appropriate `ExternalError` as well.\r\n   * @param amount uint256 The amount of Dai to withdraw.\r\n   * @param recipient address The account to transfer the withdrawn Dai to.\r\n   * @return True if the withdrawal succeeded, otherwise false.\r\n   */\r\n  function _withdrawDaiAtomic(\r\n    uint256 amount,\r\n    address recipient\r\n  ) external returns (bool success) {\r\n    // Ensure caller is this contract and self-call context is correctly set.\r\n    _enforceSelfCallFrom(this.withdrawDai.selector);\r\n\r\n    // If amount = 0xfff...fff, withdraw the maximum amount possible.\r\n    bool maxWithdraw = (amount == uint256(-1));\r\n    if (maxWithdraw) {\r\n      // First attempt to redeem all dDai if there is a balance.\r\n      _withdrawMaxFromDharmaToken(AssetType.DAI);\r\n\r\n      // Then transfer all Dai to recipient if there is a balance.\r\n      require(_transferMax(_DAI, recipient, false));\r\n      success = true;\r\n    } else {\r\n      // Attempt to withdraw specified Dai from Dharma Dai before proceeding.\r\n      if (_withdrawFromDharmaToken(AssetType.DAI, amount)) {\r\n        // At this point Dai transfer should never fail - wrap it just in case.\r\n        require(_DAI.transfer(recipient, amount));\r\n        success = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Withdraw USDC to a provided recipient address by redeeming the\r\n   * underlying USDC from the dUSDC contract and transferring it to recipient.\r\n   * All USDC in Dharma USD Coin and in the smart wallet itself can be withdrawn\r\n   * by providing an amount of uint256(-1) or 0xfff...fff. This function can be\r\n   * called directly by the account set as the global key on the Dharma Key\r\n   * Registry, or by any relayer that provides a signed message from the same\r\n   * keyholder. The nonce used for the signature must match the current nonce on\r\n   * the smart wallet, and gas supplied to the call must exceed the specified\r\n   * minimum action gas, plus the gas that will be spent before the gas check is\r\n   * reached - usually somewhere around 25,000 gas. If the withdrawal fails, an\r\n   * `ExternalError` with additional details on what went wrong will be emitted.\r\n   * Note that the USDC contract can be paused and also allows for blacklisting\r\n   * accounts - either of these possibilities may cause a withdrawal to fail. In\r\n   * addition, Compound may not have sufficient USDC available at the time to\r\n   * withdraw.\r\n   * @param amount uint256 The amount of USDC to withdraw.\r\n   * @param recipient address The account to transfer the withdrawn USDC to.\r\n   * @param minimumActionGas uint256 The minimum amount of gas that must be\r\n   * provided to this call - be aware that additional gas must still be included\r\n   * to account for the cost of overhead incurred up until the start of this\r\n   * function call.\r\n   * @param userSignature bytes A signature that resolves to the public key\r\n   * set for this account in storage slot zero, `_userSigningKey`. If the user\r\n   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\r\n   * will be used. A unique hash returned from `getCustomActionID` is prefixed\r\n   * and hashed to create the message hash for the signature.\r\n   * @param dharmaSignature bytes A signature that resolves to the public key\r\n   * returned for this account from the Dharma Key Registry. A unique hash\r\n   * returned from `getCustomActionID` is prefixed and hashed to create the\r\n   * signed message.\r\n   * @return True if the withdrawal succeeded, otherwise false.\r\n   */\r\n  function withdrawUSDC(\r\n    uint256 amount,\r\n    address recipient,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external returns (bool ok) {\r\n    // Ensure caller and/or supplied signatures are valid and increment nonce.\r\n    _validateActionAndIncrementNonce(\r\n      ActionType.USDCWithdrawal,\r\n      abi.encode(amount, recipient),\r\n      minimumActionGas,\r\n      userSignature,\r\n      dharmaSignature\r\n    );\r\n\r\n    // Ensure that an amount of at least 0.001 USDC has been supplied.\r\n    require(amount > _JUST_UNDER_ONE_1000th_USDC, _revertReason(3));\r\n\r\n    // Ensure that a non-zero recipient has been supplied.\r\n    require(recipient != address(0), _revertReason(1));\r\n\r\n    // Set the self-call context in order to call _withdrawUSDCAtomic.\r\n    _selfCallContext = this.withdrawUSDC.selector;\r\n\r\n    // Make the atomic self-call - if redeemUnderlying fails on dUSDC, it will\r\n    // succeed but nothing will happen except firing an ExternalError event. If\r\n    // the second part of the self-call (USDC transfer) fails, it will revert\r\n    // and roll back the first part of the call as well as fire an ExternalError\r\n    // event after returning from the failed call.\r\n    bytes memory returnData;\r\n    (ok, returnData) = address(this).call(abi.encodeWithSelector(\r\n      this._withdrawUSDCAtomic.selector, amount, recipient\r\n    ));\r\n    if (!ok) {\r\n      // Find out why USDC transfer reverted (doesn't give revert reasons).\r\n      _diagnoseAndEmitUSDCSpecificError(_USDC.transfer.selector);\r\n    } else {\r\n      // Set ok to false if the call succeeded but the withdrawal failed.\r\n      ok = abi.decode(returnData, (bool));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Protected function that can only be called from `withdrawUSDC` on\r\n   * this contract. It will attempt to withdraw the supplied amount of USDC, or\r\n   * the maximum amount if specified using `uint256(-1)`, to the supplied\r\n   * recipient address by redeeming the underlying USDC from the dUSDC contract\r\n   * and transferring it to the recipient. An ExternalError will be emitted and\r\n   * the transfer will be skipped if the call to `redeemUnderlying` fails, and\r\n   * any revert will be caught by `withdrawUSDC` and diagnosed in order to emit\r\n   * an appropriate ExternalError as well.\r\n   * @param amount uint256 The amount of USDC to withdraw.\r\n   * @param recipient address The account to transfer the withdrawn USDC to.\r\n   * @return True if the withdrawal succeeded, otherwise false.\r\n   */\r\n  function _withdrawUSDCAtomic(\r\n    uint256 amount,\r\n    address recipient\r\n  ) external returns (bool success) {\r\n    // Ensure caller is this contract and self-call context is correctly set.\r\n    _enforceSelfCallFrom(this.withdrawUSDC.selector);\r\n\r\n    // If amount = 0xfff...fff, withdraw the maximum amount possible.\r\n    bool maxWithdraw = (amount == uint256(-1));\r\n    if (maxWithdraw) {\r\n      // Attempt to redeem all dUSDC from Dharma USDC if there is a balance.\r\n      _withdrawMaxFromDharmaToken(AssetType.USDC);\r\n\r\n      // Then transfer all USDC to recipient if there is a balance.\r\n      require(_transferMax(_USDC, recipient, false));\r\n      success = true;\r\n    } else {\r\n      // Attempt to withdraw specified USDC from Dharma USDC before proceeding.\r\n      if (_withdrawFromDharmaToken(AssetType.USDC, amount)) {\r\n        // Ensure that the USDC transfer does not fail.\r\n        require(_USDC.transfer(recipient, amount));\r\n        success = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Withdraw Ether to a provided recipient address by transferring it\r\n   * to a recipient. This is only intended to be utilized on V7 as a mechanism\r\n   * for recovering Ether from this contract.\r\n   * @param amount uint256 The amount of Ether to withdraw.\r\n   * @param recipient address The account to transfer the Ether to.\r\n   * @param minimumActionGas uint256 The minimum amount of gas that must be\r\n   * provided to this call - be aware that additional gas must still be included\r\n   * to account for the cost of overhead incurred up until the start of this\r\n   * function call.\r\n   * @param userSignature bytes A signature that resolves to the public key\r\n   * set for this account in storage slot zero, `_userSigningKey`. If the user\r\n   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\r\n   * will be used. A unique hash returned from `getCustomActionID` is prefixed\r\n   * and hashed to create the message hash for the signature.\r\n   * @param dharmaSignature bytes A signature that resolves to the public key\r\n   * returned for this account from the Dharma Key Registry. A unique hash\r\n   * returned from `getCustomActionID` is prefixed and hashed to create the\r\n   * signed message.\r\n   * @return True if the transfer succeeded, otherwise false.\r\n   */\r\n  function withdrawEther(\r\n    uint256 amount,\r\n    address payable recipient,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external returns (bool ok) {\r\n    // Ensure caller and/or supplied signatures are valid and increment nonce.\r\n    _validateActionAndIncrementNonce(\r\n      ActionType.ETHWithdrawal,\r\n      abi.encode(amount, recipient),\r\n      minimumActionGas,\r\n      userSignature,\r\n      dharmaSignature\r\n    );\r\n\r\n    // Ensure that a non-zero amount of Ether has been supplied.\r\n    require(amount > 0, _revertReason(4));\r\n\r\n    // Ensure that a non-zero recipient has been supplied.\r\n    require(recipient != address(0), _revertReason(1));\r\n\r\n    // Attempt to transfer Ether to the recipient and emit an appropriate event.\r\n    ok = _transferETH(recipient, amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Allow a signatory to increment the nonce at any point. The current\r\n   * nonce needs to be provided as an argument to the signature so as not to\r\n   * enable griefing attacks. All arguments can be omitted if called directly.\r\n   * No value is returned from this function - it will either succeed or revert.\r\n   * @param minimumActionGas uint256 The minimum amount of gas that must be\r\n   * provided to this call - be aware that additional gas must still be included\r\n   * to account for the cost of overhead incurred up until the start of this\r\n   * function call.\r\n   * @param signature bytes A signature that resolves to either the public key\r\n   * set for this account in storage slot zero, `_userSigningKey`, or the public\r\n   * key returned for this account from the Dharma Key Registry. A unique hash\r\n   * returned from `getCustomActionID` is prefixed and hashed to create the\r\n   * signed message.\r\n   */\r\n  function cancel(\r\n    uint256 minimumActionGas,\r\n    bytes calldata signature\r\n  ) external {\r\n    // Get the current nonce.\r\n    uint256 nonceToCancel = _nonce;\r\n\r\n    // Ensure the caller or the supplied signature is valid and increment nonce.\r\n    _validateActionAndIncrementNonce(\r\n      ActionType.Cancel,\r\n      abi.encode(),\r\n      minimumActionGas,\r\n      signature,\r\n      signature\r\n    );\r\n\r\n    // Emit an event to validate that the nonce is no longer valid.\r\n    emit Cancel(nonceToCancel);\r\n  }\r\n\r\n  /**\r\n   * @notice Perform a generic call to another contract. Note that accounts with\r\n   * no code may not be specified, nor may the smart wallet itself or the escape\r\n   * hatch registry. In order to increment the nonce and invalidate the\r\n   * signatures, a call to this function with a valid target, signatutes, and\r\n   * gas will always succeed. To determine whether the call made as part of the\r\n   * action was successful or not, either the return values or the `CallSuccess`\r\n   * or `CallFailure` event can be used.\r\n   * @param to address The contract to call.\r\n   * @param data bytes The calldata to provide when making the call.\r\n   * @param minimumActionGas uint256 The minimum amount of gas that must be\r\n   * provided to this call - be aware that additional gas must still be included\r\n   * to account for the cost of overhead incurred up until the start of this\r\n   * function call.\r\n   * @param userSignature bytes A signature that resolves to the public key\r\n   * set for this account in storage slot zero, `_userSigningKey`. If the user\r\n   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\r\n   * will be used. A unique hash returned from `getCustomActionID` is prefixed\r\n   * and hashed to create the message hash for the signature.\r\n   * @param dharmaSignature bytes A signature that resolves to the public key\r\n   * returned for this account from the Dharma Key Registry. A unique hash\r\n   * returned from `getCustomActionID` is prefixed and hashed to create the\r\n   * signed message.\r\n   * @return A boolean signifying the status of the call, as well as any data\r\n   * returned from the call.\r\n   */\r\n  function executeAction(\r\n    address to,\r\n    bytes calldata data,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external returns (bool ok, bytes memory returnData) {\r\n    // Ensure that the `to` address is a contract and is not this contract.\r\n    _ensureValidGenericCallTarget(to);\r\n\r\n    // Ensure caller and/or supplied signatures are valid and increment nonce.\r\n    (bytes32 actionID, uint256 nonce) = _validateActionAndIncrementNonce(\r\n      ActionType.Generic,\r\n      abi.encode(to, data),\r\n      minimumActionGas,\r\n      userSignature,\r\n      dharmaSignature\r\n    );\r\n\r\n    // Note: from this point on, there are no reverts (apart from out-of-gas or\r\n    // call-depth-exceeded) originating from this action. However, the call\r\n    // itself may revert, in which case the function will return `false`, along\r\n    // with the revert reason encoded as bytes, and fire an CallFailure event.\r\n\r\n    // Perform the action via low-level call and set return values using result.\r\n    (ok, returnData) = to.call(data);\r\n\r\n    // Emit a CallSuccess or CallFailure event based on the outcome of the call.\r\n    if (ok) {\r\n      // Note: while the call succeeded, the action may still have \"failed\"\r\n      // (for example, successful calls to Compound can still return an error).\r\n      emit CallSuccess(actionID, false, nonce, to, data, returnData);\r\n    } else {\r\n      // Note: while the call failed, the nonce will still be incremented, which\r\n      // will invalidate all supplied signatures.\r\n      emit CallFailure(actionID, nonce, to, data, string(returnData));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Allow signatory to set a new user signing key. The current nonce\r\n   * needs to be provided as an argument to the signature so as not to enable\r\n   * griefing attacks. No value is returned from this function - it will either\r\n   * succeed or revert.\r\n   * @param userSigningKey address The new user signing key to set on this smart\r\n   * wallet.\r\n   * @param minimumActionGas uint256 The minimum amount of gas that must be\r\n   * provided to this call - be aware that additional gas must still be included\r\n   * to account for the cost of overhead incurred up until the start of this\r\n   * function call.\r\n   * @param userSignature bytes A signature that resolves to the public key\r\n   * set for this account in storage slot zero, `_userSigningKey`. If the user\r\n   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\r\n   * will be used. A unique hash returned from `getCustomActionID` is prefixed\r\n   * and hashed to create the message hash for the signature.\r\n   * @param dharmaSignature bytes A signature that resolves to the public key\r\n   * returned for this account from the Dharma Key Registry. A unique hash\r\n   * returned from `getCustomActionID` is prefixed and hashed to create the\r\n   * signed message.\r\n   */\r\n  function setUserSigningKey(\r\n    address userSigningKey,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external {\r\n    // Ensure caller and/or supplied signatures are valid and increment nonce.\r\n    _validateActionAndIncrementNonce(\r\n      ActionType.SetUserSigningKey,\r\n      abi.encode(userSigningKey),\r\n      minimumActionGas,\r\n      userSignature,\r\n      dharmaSignature\r\n    );\r\n\r\n    // Set new user signing key on smart wallet and emit a corresponding event.\r\n    _setUserSigningKey(userSigningKey);\r\n  }\r\n\r\n  /**\r\n   * @notice Set a dedicated address as the \"escape hatch\" account. This account\r\n   * can then call `escape()` at any point to \"sweep\" the entire Dai, USDC,\r\n   * residual cDai, cUSDC, dDai, dUSDC, and Ether balance from the smart wallet.\r\n   * This function call will revert if the smart wallet has previously called\r\n   * `permanentlyDisableEscapeHatch` at any point and disabled the escape hatch.\r\n   * No value is returned from this function - it will either succeed or revert.\r\n   * @param account address The account to set as the escape hatch account.\r\n   * @param minimumActionGas uint256 The minimum amount of gas that must be\r\n   * provided to this call - be aware that additional gas must still be included\r\n   * to account for the cost of overhead incurred up until the start of this\r\n   * function call.\r\n   * @param userSignature bytes A signature that resolves to the public key\r\n   * set for this account in storage slot zero, `_userSigningKey`. If the user\r\n   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\r\n   * will be used. A unique hash returned from `getCustomActionID` is prefixed\r\n   * and hashed to create the message hash for the signature.\r\n   * @param dharmaSignature bytes A signature that resolves to the public key\r\n   * returned for this account from the Dharma Key Registry. A unique hash\r\n   * returned from `getCustomActionID` is prefixed and hashed to create the\r\n   * signed message.\r\n   */\r\n  function setEscapeHatch(\r\n    address account,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external {\r\n    // Ensure caller and/or supplied signatures are valid and increment nonce.\r\n    _validateActionAndIncrementNonce(\r\n      ActionType.SetEscapeHatch,\r\n      abi.encode(account),\r\n      minimumActionGas,\r\n      userSignature,\r\n      dharmaSignature\r\n    );\r\n\r\n    // Ensure that an escape hatch account has been provided.\r\n    require(account != address(0), _revertReason(5));\r\n\r\n    // Set a new escape hatch for the smart wallet unless it has been disabled.\r\n    _ESCAPE_HATCH_REGISTRY.setEscapeHatch(account);\r\n  }\r\n\r\n  /**\r\n   * @notice Remove the \"escape hatch\" account if one is currently set. This\r\n   * function call will revert if the smart wallet has previously called\r\n   * `permanentlyDisableEscapeHatch` at any point and disabled the escape hatch.\r\n   * No value is returned from this function - it will either succeed or revert.\r\n   * @param minimumActionGas uint256 The minimum amount of gas that must be\r\n   * provided to this call - be aware that additional gas must still be included\r\n   * to account for the cost of overhead incurred up until the start of this\r\n   * function call.\r\n   * @param userSignature bytes A signature that resolves to the public key\r\n   * set for this account in storage slot zero, `_userSigningKey`. If the user\r\n   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\r\n   * will be used. A unique hash returned from `getCustomActionID` is prefixed\r\n   * and hashed to create the message hash for the signature.\r\n   * @param dharmaSignature bytes A signature that resolves to the public key\r\n   * returned for this account from the Dharma Key Registry. A unique hash\r\n   * returned from `getCustomActionID` is prefixed and hashed to create the\r\n   * signed message.\r\n   */\r\n  function removeEscapeHatch(\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external {\r\n    // Ensure caller and/or supplied signatures are valid and increment nonce.\r\n    _validateActionAndIncrementNonce(\r\n      ActionType.RemoveEscapeHatch,\r\n      abi.encode(),\r\n      minimumActionGas,\r\n      userSignature,\r\n      dharmaSignature\r\n    );\r\n\r\n    // Remove the escape hatch for the smart wallet if one is currently set.\r\n    _ESCAPE_HATCH_REGISTRY.removeEscapeHatch();\r\n  }\r\n\r\n  /**\r\n   * @notice Permanently disable the \"escape hatch\" mechanism for this smart\r\n   * wallet. This function call will revert if the smart wallet has already\r\n   * called `permanentlyDisableEscapeHatch` at any point in the past. No value\r\n   * is returned from this function - it will either succeed or revert.\r\n   * @param minimumActionGas uint256 The minimum amount of gas that must be\r\n   * provided to this call - be aware that additional gas must still be included\r\n   * to account for the cost of overhead incurred up until the start of this\r\n   * function call.\r\n   * @param userSignature bytes A signature that resolves to the public key\r\n   * set for this account in storage slot zero, `_userSigningKey`. If the user\r\n   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\r\n   * will be used. A unique hash returned from `getCustomActionID` is prefixed\r\n   * and hashed to create the message hash for the signature.\r\n   * @param dharmaSignature bytes A signature that resolves to the public key\r\n   * returned for this account from the Dharma Key Registry. A unique hash\r\n   * returned from `getCustomActionID` is prefixed and hashed to create the\r\n   * signed message.\r\n   */\r\n  function permanentlyDisableEscapeHatch(\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external {\r\n    // Ensure caller and/or supplied signatures are valid and increment nonce.\r\n    _validateActionAndIncrementNonce(\r\n      ActionType.DisableEscapeHatch,\r\n      abi.encode(),\r\n      minimumActionGas,\r\n      userSignature,\r\n      dharmaSignature\r\n    );\r\n\r\n    // Permanently disable the escape hatch mechanism for this smart wallet.\r\n    _ESCAPE_HATCH_REGISTRY.permanentlyDisableEscapeHatch();\r\n  }\r\n\r\n  /**\r\n   * @notice Swap Ether for Dai and use it to mint Dharma Dai. The trade is\r\n   * facilitated by a \"trade helper\" contract in order to protect against\r\n   * malicious calls related to processing swaps via potentially unsafe call\r\n   * targets or other parameters. In the event that a swap does not result in\r\n   * sufficient Dai being received, the swap will be rolled back. In either\r\n   * case the nonce will still be incremented as long as signatures are valid.\r\n   * @param ethToSupply uint256 The Ether to supply as part of the swap.\r\n   * @param minimumDaiReceived uint256 The minimum amount of Dai that must be\r\n   * received in exchange for the supplied Ether.\r\n   * @param target address The contract that the trade helper should call in\r\n   * order to facilitate the swap.\r\n   * @param data bytes The payload that will be passed to the target, along with\r\n   * the supplied Ether, by the trade helper in order to facilitate the swap.\r\n   * @param minimumActionGas uint256 The minimum amount of gas that must be\r\n   * provided to this call - be aware that additional gas must still be included\r\n   * to account for the cost of overhead incurred up until the start of this\r\n   * function call.\r\n   * @param userSignature bytes A signature that resolves to the public key\r\n   * set for this account in storage slot zero, `_userSigningKey`. If the user\r\n   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\r\n   * will be used. A unique hash returned from `getEthForDaiActionID` is prefixed\r\n   * and hashed to create the message hash for the signature.\r\n   * @param dharmaSignature bytes A signature that resolves to the public key\r\n   * returned for this account from the Dharma Key Registry. A unique hash\r\n   * returned from `getEthForDaiActionIDActionID` is prefixed and hashed to\r\n   * create the signed message.\r\n   */\r\n  function tradeEthForDaiAndMintDDai(\r\n    uint256 ethToSupply,\r\n    uint256 minimumDaiReceived,\r\n    address target,\r\n    bytes calldata data,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external returns (bool ok, bytes memory returnData) {\r\n    // Ensure caller and/or supplied signatures are valid and increment nonce.\r\n    _validateActionAndIncrementNonce(\r\n      ActionType.TradeEthForDai,\r\n      abi.encode(ethToSupply, minimumDaiReceived, target, data),\r\n      minimumActionGas,\r\n      userSignature,\r\n      dharmaSignature\r\n    );\r\n\r\n    // Ensure that an amount of at least 0.001 Dai will be received.\r\n    require(minimumDaiReceived > _JUST_UNDER_ONE_1000th_DAI, _revertReason(31));\r\n\r\n    // Set the self-call context in order to call _tradeEthForDaiAndMintDDaiAtomic.\r\n    _selfCallContext = this.tradeEthForDaiAndMintDDai.selector;\r\n\r\n    // Make the atomic self-call - if the swap fails or the received dai is not\r\n    // greater than or equal to the requirement, it will revert and roll back the\r\n    // atomic call as well as fire an ExternalError. If dDai is not successfully\r\n    // minted, the swap will succeed but an ExternalError for dDai will be fired.\r\n    bytes memory returnData;\r\n    (ok, returnData) = address(this).call(abi.encodeWithSelector(\r\n      this._tradeEthForDaiAndMintDDaiAtomic.selector,\r\n      ethToSupply, minimumDaiReceived, target, data\r\n    ));\r\n\r\n    // If the atomic call failed, emit an event signifying a trade failure.\r\n    if (!ok) {\r\n      emit ExternalError(\r\n        address(_TRADE_HELPER), _decodeRevertReason(returnData)\r\n      );\r\n    }\r\n  }\r\n  \r\n  function _tradeEthForDaiAndMintDDaiAtomic(\r\n    uint256 ethToSupply,\r\n    uint256 minimumDaiReceived,\r\n    address target,\r\n    bytes calldata data\r\n  ) external returns (bool ok, bytes memory returnData) {\r\n    // Ensure caller is this contract and self-call context is correctly set.\r\n    _enforceSelfCallFrom(this.tradeEthForDaiAndMintDDai.selector);\r\n    \r\n    // Perform the swap using the supplied Ether amount, target, and data.\r\n    uint256 daiReceived = _TRADE_HELPER.trade.value(ethToSupply)(target, data);\r\n    \r\n    // Ensure that sufficient Dai was returned as a result of the swap. \r\n    require(daiReceived >= minimumDaiReceived, _revertReason(32));\r\n    \r\n    // Attempt to deposit the dai received and mint Dharma Dai.\r\n    _depositDharmaToken(AssetType.DAI, daiReceived);\r\n  }\r\n\r\n  /**\r\n   * @notice Allow the designated escape hatch account to  \"sweep\" the entire\r\n   * Sai, Dai, USDC, residual dDai, dUSDC, cSai, cDai & cUSDC, and Ether balance\r\n   * from the smart wallet. The call will revert for any other caller, or if\r\n   * there is no escape hatch account on this smart wallet. First, an attempt\r\n   * will be made to redeem any dDai or dUSDC that is currently deposited in a\r\n   * dToken. Then, attempts will be made to transfer all Sai, Dai, USDC,\r\n   * residual cSai, cDai & cUSDC, and Ether to the escape hatch account. If any\r\n   * portion of this operation does not succeed, it will simply be skipped,\r\n   * allowing the rest of the operation to proceed. Finally, an `Escaped` event\r\n   * will be emitted. No value is returned from this function - it will either\r\n   * succeed or revert.\r\n   */\r\n  function escape() external {\r\n    // Get the escape hatch account, if one exists, for this account.\r\n    (bool exists, address escapeHatch) = _ESCAPE_HATCH_REGISTRY.getEscapeHatch();\r\n\r\n    // Ensure that an escape hatch is currently set for this smart wallet.\r\n    require(exists, _revertReason(6));\r\n\r\n    // Ensure that the escape hatch account is the caller.\r\n    require(msg.sender == escapeHatch, _revertReason(7));\r\n\r\n    // Attempt to redeem all dDai for Dai on Dharma Dai.\r\n    _withdrawMaxFromDharmaToken(AssetType.DAI);\r\n\r\n    // Attempt to redeem all dUSDC for USDC on Dharma USDC.\r\n    _withdrawMaxFromDharmaToken(AssetType.USDC);\r\n\r\n    // Attempt to transfer the total Dai balance to the caller.\r\n    _transferMax(_DAI, msg.sender, true);\r\n\r\n    // Attempt to transfer the total USDC balance to the caller.\r\n    _transferMax(_USDC, msg.sender, true);\r\n\r\n    // Attempt to transfer any residual cSai to the caller.\r\n    _transferMax(ERC20Interface(address(_CSAI)), msg.sender, true);\r\n\r\n    // Attempt to transfer any residual cDai to the caller.\r\n    _transferMax(ERC20Interface(address(_CDAI)), msg.sender, true);\r\n\r\n    // Attempt to transfer any residual cUSDC to the caller.\r\n    _transferMax(ERC20Interface(address(_CUSDC)), msg.sender, true);\r\n\r\n    // Attempt to transfer any residual dDai to the caller.\r\n    _transferMax(ERC20Interface(address(_DDAI)), msg.sender, true);\r\n\r\n    // Attempt to transfer any residual dUSDC to the caller.\r\n    _transferMax(ERC20Interface(address(_DUSDC)), msg.sender, true);\r\n\r\n    // Determine if there is Ether at this address that should be transferred.\r\n    uint256 balance = address(this).balance;\r\n    if (balance > 0) {\r\n      // Attempt to transfer any Ether to caller and emit an appropriate event.\r\n      _transferETH(msg.sender, balance);\r\n    }\r\n\r\n    // Emit an `Escaped` event.\r\n    emit Escaped();\r\n  }\r\n\r\n  /**\r\n   * @notice Allow the account recovery manager to set a new user signing key on\r\n   * the smart wallet. The call will revert for any other caller. The account\r\n   * recovery manager implements a set of controls around the process, including\r\n   * a timelock and an option to permanently opt out of account recover. No\r\n   * value is returned from this function - it will either succeed or revert.\r\n   * @param newUserSigningKey address The new user signing key to set on this\r\n   * smart wallet.\r\n   */\r\n  function recover(address newUserSigningKey) external {\r\n    require(msg.sender == _ACCOUNT_RECOVERY_MANAGER, _revertReason(8));\r\n\r\n    // Increment nonce to prevent signature reuse should original key be reset.\r\n    _nonce++;\r\n\r\n    // Set up the user's new dharma key and emit a corresponding event.\r\n    _setUserSigningKey(newUserSigningKey);\r\n  }\r\n\r\n  /**\r\n   * @notice Convert all available Sai for Dai. If the conversion fails, or if\r\n   * the realized exchange rate is less than 1:1, the call will revert. Note\r\n   * that cSai is not included as part of this operation.\r\n   */\r\n  function migrateSaiToDai() external {\r\n    // Swap the current Sai balance on this contract for Dai.\r\n    _swapSaiForDai(_SAI.balanceOf(address(this)));\r\n  }\r\n\r\n  /**\r\n   * @notice This call is no longer supported.\r\n   */\r\n  function migrateCSaiToDDai() external {\r\n    revert();\r\n  }\r\n\r\n  /**\r\n   * @notice Redeem all available cDAI for Dai and use that Dai to mint dDai. If\r\n   * any step in the process fails, the call will revert and prior steps will be\r\n   * rolled back. Also note that existing Sai and Dai are not included as part\r\n   * of this operation.\r\n   */\r\n  function migrateCDaiToDDai() external {\r\n     _migrateCTokenToDToken(AssetType.DAI);\r\n  }\r\n\r\n  /**\r\n   * @notice Redeem all available cUSDC for USDC and use that USDC to mint\r\n   * dUSDC. If any step in the process fails, the call will revert and prior\r\n   * steps will be rolled back. Also note that existing USDC is not included as\r\n   * part of this operation.\r\n   */\r\n  function migrateCUSDCToDUSDC() external {\r\n     _migrateCTokenToDToken(AssetType.USDC);\r\n  }\r\n\r\n  /**\r\n   * @notice View function to retrieve the Dai and USDC balances held by the\r\n   * smart wallet, both directly and held in Dharma Dai and Dharma USD Coin, as\r\n   * well as the Ether balance (the underlying dEther balance will always return\r\n   * zero in this implementation, as there is no dEther yet).\r\n   * @return The Dai balance, the USDC balance, the Ether balance, the\r\n   * underlying Dai balance of the dDai balance, and the underlying USDC balance\r\n   * of the dUSDC balance (zero will always be returned as the underlying Ether\r\n   * balance of the dEther balance in this implementation).\r\n   */\r\n  function getBalances() external view returns (\r\n    uint256 daiBalance,\r\n    uint256 usdcBalance,\r\n    uint256 etherBalance,\r\n    uint256 dDaiUnderlyingDaiBalance,\r\n    uint256 dUsdcUnderlyingUsdcBalance,\r\n    uint256 dEtherUnderlyingEtherBalance // always returns 0\r\n  ) {\r\n    daiBalance = _DAI.balanceOf(address(this));\r\n    usdcBalance = _USDC.balanceOf(address(this));\r\n    etherBalance = address(this).balance;\r\n    dDaiUnderlyingDaiBalance = _DDAI.balanceOfUnderlying(address(this));\r\n    dUsdcUnderlyingUsdcBalance = _DUSDC.balanceOfUnderlying(address(this));\r\n  }\r\n\r\n  /**\r\n   * @notice View function for getting the current user signing key for the\r\n   * smart wallet.\r\n   * @return The current user signing key.\r\n   */\r\n  function getUserSigningKey() external view returns (address userSigningKey) {\r\n    userSigningKey = _userSigningKey;\r\n  }\r\n\r\n  /**\r\n   * @notice View function for getting the current nonce of the smart wallet.\r\n   * This nonce is incremented whenever an action is taken that requires a\r\n   * signature and/or a specific caller.\r\n   * @return The current nonce.\r\n   */\r\n  function getNonce() external view returns (uint256 nonce) {\r\n    nonce = _nonce;\r\n  }\r\n\r\n  /**\r\n   * @notice View function that, given an action type and arguments, will return\r\n   * the action ID or message hash that will need to be prefixed (according to\r\n   * EIP-191 0x45), hashed, and signed by both the user signing key and by the\r\n   * key returned for this smart wallet by the Dharma Key Registry in order to\r\n   * construct a valid signature for the corresponding action. Any nonce value\r\n   * may be supplied, which enables constructing valid message hashes for\r\n   * multiple future actions ahead of time.\r\n   * @param action uint8 The type of action, designated by it's index. Valid\r\n   * custom actions in V7 include Cancel (0), SetUserSigningKey (1),\r\n   * DAIWithdrawal (10), USDCWithdrawal (5), ETHWithdrawal (6),\r\n   * SetEscapeHatch (7), RemoveEscapeHatch (8), and DisableEscapeHatch (9).\r\n   * @param amount uint256 The amount to withdraw for Withdrawal actions. This\r\n   * value is ignored for non-withdrawal action types.\r\n   * @param recipient address The account to transfer withdrawn funds to or the\r\n   * new user signing key. This value is ignored for Cancel, RemoveEscapeHatch,\r\n   * and DisableEscapeHatch action types.\r\n   * @param minimumActionGas uint256 The minimum amount of gas that must be\r\n   * provided to this call - be aware that additional gas must still be included\r\n   * to account for the cost of overhead incurred up until the start of this\r\n   * function call.\r\n   * @return The action ID, which will need to be prefixed, hashed and signed in\r\n   * order to construct a valid signature.\r\n   */\r\n  function getNextCustomActionID(\r\n    ActionType action,\r\n    uint256 amount,\r\n    address recipient,\r\n    uint256 minimumActionGas\r\n  ) external view returns (bytes32 actionID) {\r\n    // Determine the actionID - this serves as a signature hash for an action.\r\n    actionID = _getActionID(\r\n      action,\r\n      _validateCustomActionTypeAndGetArguments(action, amount, recipient),\r\n      _nonce,\r\n      minimumActionGas,\r\n      _userSigningKey,\r\n      _getDharmaSigningKey()\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice View function that, given an action type and arguments, will return\r\n   * the action ID or message hash that will need to be prefixed (according to\r\n   * EIP-191 0x45), hashed, and signed by both the user signing key and by the\r\n   * key returned for this smart wallet by the Dharma Key Registry in order to\r\n   * construct a valid signature for the corresponding action. The current nonce\r\n   * will be used, which means that it will only be valid for the next action\r\n   * taken.\r\n   * @param action uint8 The type of action, designated by it's index. Valid\r\n   * custom actions in V7 include Cancel (0), SetUserSigningKey (1),\r\n   * DAIWithdrawal (10), USDCWithdrawal (5), ETHWithdrawal (6),\r\n   * SetEscapeHatch (7), RemoveEscapeHatch (8), and DisableEscapeHatch (9).\r\n   * @param amount uint256 The amount to withdraw for Withdrawal actions. This\r\n   * value is ignored for non-withdrawal action types.\r\n   * @param recipient address The account to transfer withdrawn funds to or the\r\n   * new user signing key. This value is ignored for Cancel, RemoveEscapeHatch,\r\n   * and DisableEscapeHatch action types.\r\n   * @param nonce uint256 The nonce to use.\r\n   * @param minimumActionGas uint256 The minimum amount of gas that must be\r\n   * provided to this call - be aware that additional gas must still be included\r\n   * to account for the cost of overhead incurred up until the start of this\r\n   * function call.\r\n   * @return The action ID, which will need to be prefixed, hashed and signed in\r\n   * order to construct a valid signature.\r\n   */\r\n  function getCustomActionID(\r\n    ActionType action,\r\n    uint256 amount,\r\n    address recipient,\r\n    uint256 nonce,\r\n    uint256 minimumActionGas\r\n  ) external view returns (bytes32 actionID) {\r\n    // Determine the actionID - this serves as a signature hash for an action.\r\n    actionID = _getActionID(\r\n      action,\r\n      _validateCustomActionTypeAndGetArguments(action, amount, recipient),\r\n      nonce,\r\n      minimumActionGas,\r\n      _userSigningKey,\r\n      _getDharmaSigningKey()\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice View function that, given an action type and arguments, will return\r\n   * the action ID or message hash that will need to be prefixed (according to\r\n   * EIP-191 0x45), hashed, and signed by both the user signing key and by the\r\n   * key returned for this smart wallet by the Dharma Key Registry in order to\r\n   * construct a valid signature for a given generic action. The current nonce\r\n   * will be used, which means that it will only be valid for the next action\r\n   * taken.\r\n   * @param to address The target to call into as part of the generic action.\r\n   * @param data bytes The data to supply when calling into the target.\r\n   * @param minimumActionGas uint256 The minimum amount of gas that must be\r\n   * provided to this call - be aware that additional gas must still be included\r\n   * to account for the cost of overhead incurred up until the start of this\r\n   * function call.\r\n   * @return The action ID, which will need to be prefixed, hashed and signed in\r\n   * order to construct a valid signature.\r\n   */\r\n  function getNextGenericActionID(\r\n    address to,\r\n    bytes calldata data,\r\n    uint256 minimumActionGas\r\n  ) external view returns (bytes32 actionID) {\r\n    // Determine the actionID - this serves as a signature hash for an action.\r\n    actionID = _getActionID(\r\n      ActionType.Generic,\r\n      abi.encode(to, data),\r\n      _nonce,\r\n      minimumActionGas,\r\n      _userSigningKey,\r\n      _getDharmaSigningKey()\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice View function that, given an action type and arguments, will return\r\n   * the action ID or message hash that will need to be prefixed (according to\r\n   * EIP-191 0x45), hashed, and signed by both the user signing key and by the\r\n   * key returned for this smart wallet by the Dharma Key Registry in order to\r\n   * construct a valid signature for a given generic action. Any nonce value may\r\n   * be supplied, which enables constructing valid message hashes for multiple\r\n   * future actions ahead of time.\r\n   * @param to address The target to call into as part of the generic action.\r\n   * @param data bytes The data to supply when calling into the target.\r\n   * @param nonce uint256 The nonce to use.\r\n   * @param minimumActionGas uint256 The minimum amount of gas that must be\r\n   * provided to this call - be aware that additional gas must still be included\r\n   * to account for the cost of overhead incurred up until the start of this\r\n   * function call.\r\n   * @return The action ID, which will need to be prefixed, hashed and signed in\r\n   * order to construct a valid signature.\r\n   */\r\n  function getGenericActionID(\r\n    address to,\r\n    bytes calldata data,\r\n    uint256 nonce,\r\n    uint256 minimumActionGas\r\n  ) external view returns (bytes32 actionID) {\r\n    // Determine the actionID - this serves as a signature hash for an action.\r\n    actionID = _getActionID(\r\n      ActionType.Generic,\r\n      abi.encode(to, data),\r\n      nonce,\r\n      minimumActionGas,\r\n      _userSigningKey,\r\n      _getDharmaSigningKey()\r\n    );\r\n  }\r\n\r\n  // TODO: add natspec\r\n  function getNextEthForDaiActionID(\r\n    uint256 ethToSupply,\r\n    uint256 minimumDaiReceived,\r\n    address target,\r\n    bytes calldata data,\r\n    uint256 minimumActionGas\r\n  ) external view returns (bytes32 actionID) {\r\n    // Determine the actionID - this serves as a signature hash for an action.\r\n    actionID = _getActionID(\r\n      ActionType.TradeEthForDai,\r\n      abi.encode(ethToSupply, minimumDaiReceived, target, data),\r\n      _nonce,\r\n      minimumActionGas,\r\n      _userSigningKey,\r\n      _getDharmaSigningKey()\r\n    );\r\n  }\r\n\r\n  // TODO: add natspec\r\n  function getEthForDaiActionID(\r\n    uint256 ethToSupply,\r\n    uint256 minimumDaiReceived,\r\n    address target,\r\n    bytes calldata data,\r\n    uint256 nonce,\r\n    uint256 minimumActionGas\r\n  ) external view returns (bytes32 actionID) {\r\n    // Determine the actionID - this serves as a signature hash for an action.\r\n    actionID = _getActionID(\r\n      ActionType.TradeEthForDai,\r\n      abi.encode(ethToSupply, minimumDaiReceived, target, data),\r\n      nonce,\r\n      minimumActionGas,\r\n      _userSigningKey,\r\n      _getDharmaSigningKey()\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice View function that implements ERC-1271 and validates a set of\r\n   * signatures, one from the owner (using ERC-1271 as well if the user signing\r\n   * key is a contract) and one from the Dharma Key Registry against the\r\n   * supplied data. The data must be ABI encoded as (bytes32, bytes), where the\r\n   * first bytes32 parameter represents the hash digest for validating the\r\n   * supplied signatures and the second bytes parameter contains context for the\r\n   * requested validation. The two signatures are packed together, with the one\r\n   * from Dharma coming first and that from the user coming second - this is so\r\n   * that, in future versions, multiple user signatures may be supplied if the\r\n   * associated key ring requires them.\r\n   * @param data bytes The data used to validate the signature.\r\n   * @param signatures bytes The two signatures, each 65 bytes - one from the\r\n   * owner (using ERC-1271 as well if the user signing key is a contract) and\r\n   * one from the Dharma Key Registry.\r\n   * @return The 4-byte magic value to signify a valid signature in ERC-1271, if\r\n   * the signatures are both valid.\r\n   */\r\n  function isValidSignature(\r\n    bytes calldata data, bytes calldata signatures\r\n  ) external view returns (bytes4 magicValue) {\r\n    // Get message hash digest and any additional context from data argument.\r\n    bytes32 digest;\r\n    bytes memory context;\r\n\r\n    if (data.length == 32) {\r\n      digest = abi.decode(data, (bytes32));\r\n    } else {\r\n      require(data.length >= 64, _revertReason(30));\r\n      (digest, context) = abi.decode(data, (bytes32, bytes));\r\n    }\r\n\r\n    // Get Dharma signature & user signature from combined signatures argument.\r\n    require(signatures.length == 130, _revertReason(11));\r\n    bytes memory signaturesInMemory = signatures;\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n    assembly {\r\n      r := mload(add(signaturesInMemory, 0x20))\r\n      s := mload(add(signaturesInMemory, 0x40))\r\n      v := byte(0, mload(add(signaturesInMemory, 0x60)))\r\n    }\r\n    bytes memory dharmaSignature = abi.encodePacked(r, s, v);\r\n\r\n    assembly {\r\n      r := mload(add(signaturesInMemory, 0x61))\r\n      s := mload(add(signaturesInMemory, 0x81))\r\n      v := byte(0, mload(add(signaturesInMemory, 0xa1)))\r\n    }\r\n    bytes memory userSignature = abi.encodePacked(r, s, v);\r\n\r\n    // Validate user signature with `SignatureVerification` as the action type.\r\n    require(\r\n      _validateUserSignature(\r\n        digest,\r\n        ActionType.SignatureVerification,\r\n        context,\r\n        _userSigningKey,\r\n        userSignature\r\n      ),\r\n      _revertReason(12)\r\n    );\r\n\r\n    // Recover Dharma signature against key returned from Dharma Key Registry.\r\n    require(\r\n      _getDharmaSigningKey() == digest.recover(dharmaSignature),\r\n      _revertReason(13)\r\n    );\r\n\r\n    // Return the ERC-1271 magic value to indicate success.\r\n    magicValue = _ERC_1271_MAGIC_VALUE;\r\n  }\r\n\r\n  /**\r\n   * @notice Pure function for getting the current Dharma Smart Wallet version.\r\n   * @return The current Dharma Smart Wallet version.\r\n   */\r\n  function getVersion() external pure returns (uint256 version) {\r\n    version = _DHARMA_SMART_WALLET_VERSION;\r\n  }\r\n\r\n  /**\r\n   * @notice Perform a series of generic calls to other contracts. If any call\r\n   * fails during execution, the preceding calls will be rolled back, but their\r\n   * original return data will still be accessible. Calls that would otherwise\r\n   * occur after the failed call will not be executed. Note that accounts with\r\n   * no code may not be specified, nor may the smart wallet itself or the escape\r\n   * hatch registry. In order to increment the nonce and invalidate the\r\n   * signatures, a call to this function with valid targets, signatutes, and gas\r\n   * will always succeed. To determine whether each call made as part of the\r\n   * action was successful or not, either the corresponding return value or the\r\n   * corresponding `CallSuccess` or `CallFailure` event can be used - note that\r\n   * even calls that return a success status will have been rolled back unless\r\n   * all of the calls returned a success status. Finally, note that this\r\n   * function must currently be implemented as a public function (instead of as\r\n   * an external one) due to an ABIEncoderV2 `UnimplementedFeatureError`.\r\n   * @param calls Call[] A struct containing the target and calldata to provide\r\n   * when making each call.\r\n   * @param minimumActionGas uint256 The minimum amount of gas that must be\r\n   * provided to this call - be aware that additional gas must still be included\r\n   * to account for the cost of overhead incurred up until the start of this\r\n   * function call.\r\n   * @param userSignature bytes A signature that resolves to the public key\r\n   * set for this account in storage slot zero, `_userSigningKey`. If the user\r\n   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\r\n   * will be used. A unique hash returned from `getCustomActionID` is prefixed\r\n   * and hashed to create the message hash for the signature.\r\n   * @param dharmaSignature bytes A signature that resolves to the public key\r\n   * returned for this account from the Dharma Key Registry. A unique hash\r\n   * returned from `getCustomActionID` is prefixed and hashed to create the\r\n   * signed message.\r\n   * @return An array of structs signifying the status of each call, as well as\r\n   * any data returned from that call. Calls that are not executed will return\r\n   * empty data.\r\n   */\r\n  function executeActionWithAtomicBatchCalls(\r\n    Call[] memory calls,\r\n    uint256 minimumActionGas,\r\n    bytes memory userSignature,\r\n    bytes memory dharmaSignature\r\n  ) public returns (bool[] memory ok, bytes[] memory returnData) {\r\n    // Ensure that each `to` address is a contract and is not this contract.\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      _ensureValidGenericCallTarget(calls[i].to);\r\n    }\r\n\r\n    // Ensure caller and/or supplied signatures are valid and increment nonce.\r\n    (bytes32 actionID, uint256 nonce) = _validateActionAndIncrementNonce(\r\n      ActionType.GenericAtomicBatch,\r\n      abi.encode(calls),\r\n      minimumActionGas,\r\n      userSignature,\r\n      dharmaSignature\r\n    );\r\n\r\n    // Note: from this point on, there are no reverts (apart from out-of-gas or\r\n    // call-depth-exceeded) originating from this contract. However, one of the\r\n    // calls may revert, in which case the function will return `false`, along\r\n    // with the revert reason encoded as bytes, and fire an CallFailure event.\r\n\r\n    // Specify length of returned values in order to work with them in memory.\r\n    ok = new bool[](calls.length);\r\n    returnData = new bytes[](calls.length);\r\n\r\n    // Set self-call context to call _executeActionWithAtomicBatchCallsAtomic.\r\n    _selfCallContext = this.executeActionWithAtomicBatchCalls.selector;\r\n\r\n    // Make the atomic self-call - if any call fails, calls that preceded it\r\n    // will be rolled back and calls that follow it will not be made.\r\n    (bool externalOk, bytes memory rawCallResults) = address(this).call(\r\n      abi.encodeWithSelector(\r\n        this._executeActionWithAtomicBatchCallsAtomic.selector, calls\r\n      )\r\n    );\r\n\r\n    // Parse data returned from self-call into each call result and store / log.\r\n    CallReturn[] memory callResults = abi.decode(rawCallResults, (CallReturn[]));\r\n    for (uint256 i = 0; i < callResults.length; i++) {\r\n      Call memory currentCall = calls[i];\r\n\r\n      // Set the status and the return data / revert reason from the call.\r\n      ok[i] = callResults[i].ok;\r\n      returnData[i] = callResults[i].returnData;\r\n\r\n      // Emit CallSuccess or CallFailure event based on the outcome of the call.\r\n      if (callResults[i].ok) {\r\n        // Note: while the call succeeded, the action may still have \"failed\".\r\n        emit CallSuccess(\r\n          actionID,\r\n          !externalOk, // If another call failed this will have been rolled back\r\n          nonce,\r\n          currentCall.to,\r\n          currentCall.data,\r\n          callResults[i].returnData\r\n        );\r\n      } else {\r\n        // Note: while the call failed, the nonce will still be incremented,\r\n        // which will invalidate all supplied signatures.\r\n        emit CallFailure(\r\n          actionID,\r\n          nonce,\r\n          currentCall.to,\r\n          currentCall.data,\r\n          string(callResults[i].returnData)\r\n        );\r\n\r\n        // exit early - any calls after the first failed call will not execute.\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Protected function that can only be called from\r\n   * `executeActionWithAtomicBatchCalls` on this contract. It will attempt to\r\n   * perform each specified call, populating the array of results as it goes,\r\n   * unless a failure occurs, at which point it will revert and \"return\" the\r\n   * array of results as revert data. Otherwise, it will simply return the array\r\n   * upon successful completion of each call. Finally, note that this function\r\n   * must currently be implemented as a public function (instead of as an\r\n   * external one) due to an ABIEncoderV2 `UnimplementedFeatureError`.\r\n   * @param calls Call[] A struct containing the target and calldata to provide\r\n   * when making each call.\r\n   * @return An array of structs signifying the status of each call, as well as\r\n   * any data returned from that call. Calls that are not executed will return\r\n   * empty data. If any of the calls fail, the array will be returned as revert\r\n   * data.\r\n   */\r\n  function _executeActionWithAtomicBatchCallsAtomic(\r\n    Call[] memory calls\r\n  ) public returns (CallReturn[] memory callResults) {\r\n    // Ensure caller is this contract and self-call context is correctly set.\r\n    _enforceSelfCallFrom(this.executeActionWithAtomicBatchCalls.selector);\r\n\r\n    bool rollBack = false;\r\n    callResults = new CallReturn[](calls.length);\r\n\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      // Perform low-level call and set return values using result.\r\n      (bool ok, bytes memory returnData) = calls[i].to.call(calls[i].data);\r\n      callResults[i] = CallReturn({ok: ok, returnData: returnData});\r\n      if (!ok) {\r\n        // Exit early - any calls after the first failed call will not execute.\r\n        rollBack = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (rollBack) {\r\n      // Wrap in length encoding and revert (provide data instead of a string).\r\n      bytes memory callResultsBytes = abi.encode(callResults);\r\n      assembly { revert(add(32, callResultsBytes), mload(callResultsBytes)) }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice View function that, given an action type and arguments, will return\r\n   * the action ID or message hash that will need to be prefixed (according to\r\n   * EIP-191 0x45), hashed, and signed by both the user signing key and by the\r\n   * key returned for this smart wallet by the Dharma Key Registry in order to\r\n   * construct a valid signature for a given generic atomic batch action. The\r\n   * current nonce will be used, which means that it will only be valid for the\r\n   * next action taken. Finally, note that this function must currently be\r\n   * implemented as a public function (instead of as an external one) due to an\r\n   * ABIEncoderV2 `UnimplementedFeatureError`.\r\n   * @param calls Call[] A struct containing the target and calldata to provide\r\n   * when making each call.\r\n   * @param calls Call[] A struct containing the target and calldata to provide\r\n   * when making each call.\r\n   * @param minimumActionGas uint256 The minimum amount of gas that must be\r\n   * provided to this call - be aware that additional gas must still be included\r\n   * to account for the cost of overhead incurred up until the start of this\r\n   * function call.\r\n   * @return The action ID, which will need to be prefixed, hashed and signed in\r\n   * order to construct a valid signature.\r\n   */\r\n  function getNextGenericAtomicBatchActionID(\r\n    Call[] memory calls,\r\n    uint256 minimumActionGas\r\n  ) public view returns (bytes32 actionID) {\r\n    // Determine the actionID - this serves as a signature hash for an action.\r\n    actionID = _getActionID(\r\n      ActionType.GenericAtomicBatch,\r\n      abi.encode(calls),\r\n      _nonce,\r\n      minimumActionGas,\r\n      _userSigningKey,\r\n      _getDharmaSigningKey()\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice View function that, given an action type and arguments, will return\r\n   * the action ID or message hash that will need to be prefixed (according to\r\n   * EIP-191 0x45), hashed, and signed by both the user signing key and by the\r\n   * key returned for this smart wallet by the Dharma Key Registry in order to\r\n   * construct a valid signature for a given generic atomic batch action. Any\r\n   * nonce value may be supplied, which enables constructing valid message\r\n   * hashes for multiple future actions ahead of time. Finally, note that this\r\n   * function must currently be implemented as a public function (instead of as\r\n   * an external one) due to an ABIEncoderV2 `UnimplementedFeatureError`.\r\n   * @param calls Call[] A struct containing the target and calldata to provide\r\n   * when making each call.\r\n   * @param calls Call[] A struct containing the target and calldata to provide\r\n   * when making each call.\r\n   * @param nonce uint256 The nonce to use.\r\n   * @param minimumActionGas uint256 The minimum amount of gas that must be\r\n   * provided to this call - be aware that additional gas must still be included\r\n   * to account for the cost of overhead incurred up until the start of this\r\n   * function call.\r\n   * @return The action ID, which will need to be prefixed, hashed and signed in\r\n   * order to construct a valid signature.\r\n   */\r\n  function getGenericAtomicBatchActionID(\r\n    Call[] memory calls,\r\n    uint256 nonce,\r\n    uint256 minimumActionGas\r\n  ) public view returns (bytes32 actionID) {\r\n    // Determine the actionID - this serves as a signature hash for an action.\r\n    actionID = _getActionID(\r\n      ActionType.GenericAtomicBatch,\r\n      abi.encode(calls),\r\n      nonce,\r\n      minimumActionGas,\r\n      _userSigningKey,\r\n      _getDharmaSigningKey()\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function for setting a new user signing key. Called by the\r\n   * initializer, by the `setUserSigningKey` function, and by the `recover`\r\n   * function. A `NewUserSigningKey` event will also be emitted.\r\n   * @param userSigningKey address The new user signing key to set on this smart\r\n   * wallet.\r\n   */\r\n  function _setUserSigningKey(address userSigningKey) internal {\r\n    // Ensure that a user signing key is set on this smart wallet.\r\n    require(userSigningKey != address(0), _revertReason(14));\r\n\r\n    _userSigningKey = userSigningKey;\r\n    emit NewUserSigningKey(userSigningKey);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function for converting a Sai balance to Dai. The total\r\n   * amount of received Dai must be greater than or equal to the total amount of\r\n   * swapped Sai.\r\n   * @param saiToSwap uint256 The amount of Sai to swap.\r\n   * @return The amount of Dai received as part of the swap.\r\n   */\r\n  function _swapSaiForDai(uint256 saiToSwap) internal returns (uint256 dai) {\r\n    // If the balance is non-zero, check if migrator has adequate approval.\r\n    if (saiToSwap > 0) {\r\n      uint256 allowance = _SAI.allowance(address(this), address(_MIGRATOR));\r\n      \r\n      // Ensure that allowance is sufficient before calling the migrator.\r\n      if (saiToSwap > allowance) {\r\n        // Approve migrator contract to transfer Sai on behalf of this wallet.\r\n        require(\r\n          _SAI.approve(address(_MIGRATOR), uint256(-1)), _revertReason(15)\r\n        );\r\n      }\r\n\r\n      // Get the current Dai balance on this contract.\r\n      uint256 currentDaiBalance = _DAI.balanceOf(address(this));\r\n\r\n      // Call migrator contract to swap the supplied Sai balance for Dai.\r\n      _MIGRATOR.swapSaiToDai(saiToSwap);\r\n\r\n      // Return the difference between the pre-swap and post-swap Dai balances.\r\n      dai = _DAI.balanceOf(address(this)) - currentDaiBalance;\r\n\r\n      // Ensure that the Sai-to-Dai exchange rate was at least 1-to-1.\r\n      require(dai >= saiToSwap, _revertReason(16));\r\n    } else {\r\n      // Explicitly specify a change in balance of zero if no swap occurred.\r\n      dai = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function for setting the allowance of a given ERC20 asset\r\n   * to the maximum value. This enables the corresponding dToken for the asset\r\n   * to pull in tokens in order to make deposits.\r\n   * @param asset uint256 The ID of the asset, either Dai (0) or USDC (1).\r\n   * @return True if the approval succeeded, otherwise false.\r\n   */\r\n  function _setFullApproval(AssetType asset) internal returns (bool ok) {\r\n    // Get asset's underlying token address and corresponding dToken address.\r\n    address token;\r\n    address dToken;\r\n    if (asset == AssetType.DAI) {\r\n      token = address(_DAI);\r\n      dToken = address(_DDAI);\r\n    } else {\r\n      token = address(_USDC);\r\n      dToken = address(_DUSDC);\r\n    }\r\n\r\n    // Approve dToken contract to transfer underlying on behalf of this wallet.\r\n    (ok, ) = address(token).call(abi.encodeWithSelector(\r\n      // Note: since both Tokens have the same interface, just use DAI's.\r\n      _DAI.approve.selector, dToken, uint256(-1)\r\n    ));\r\n\r\n    // Emit a corresponding event if the approval failed.\r\n    if (!ok) {\r\n      if (asset == AssetType.DAI) {\r\n        emit ExternalError(address(_DAI), _revertReason(17));\r\n      } else {\r\n        // Find out why USDC transfer reverted (it doesn't give revert reasons).\r\n        _diagnoseAndEmitUSDCSpecificError(_USDC.approve.selector);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function for depositing a given ERC20 asset and balance on\r\n   * the corresponding dToken. No value is returned, as no additional steps need\r\n   * to be conditionally performed after the deposit.\r\n   * @param asset uint256 The ID of the asset, either Dai (0) or USDC (1).\r\n   * @param balance uint256 The amount of the asset to deposit. Note that an\r\n   * attempt to deposit \"dust\" (i.e. very small amounts) may result in fewer\r\n   * dTokens being minted than is implied by the current exchange rate due to a\r\n   * lack of sufficient precision on the tokens in question.\r\n   */\r\n  function _depositDharmaToken(AssetType asset, uint256 balance) internal {\r\n    // Only perform a deposit if the balance is at least .001 Dai or USDC.\r\n    if (\r\n      asset == AssetType.DAI && balance > _JUST_UNDER_ONE_1000th_DAI ||\r\n      asset == AssetType.USDC && balance > _JUST_UNDER_ONE_1000th_USDC\r\n    ) {\r\n      // Get dToken address for the asset type.\r\n      address dToken = asset == AssetType.DAI ? address(_DDAI) : address(_DUSDC);\r\n\r\n      // Attempt to mint the balance on the dToken contract.\r\n      (bool ok, bytes memory data) = dToken.call(abi.encodeWithSelector(\r\n        // Note: since both dTokens have the same interface, just use dDai's.\r\n        _DDAI.mint.selector, balance\r\n      ));\r\n\r\n      // Log an external error if something went wrong with the attempt.\r\n      _checkDharmaTokenInteractionAndLogAnyErrors(\r\n        asset, _DDAI.mint.selector, ok, data\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function for withdrawing a given underlying asset balance\r\n   * from the corresponding dToken. Note that the requested balance may not be\r\n   * currently available on Compound, which will cause the withdrawal to fail.\r\n   * @param asset uint256 The asset's ID, either Dai (0) or USDC (1).\r\n   * @param balance uint256 The amount of the asset to withdraw, denominated in\r\n   * the underlying token. Note that an attempt to withdraw \"dust\" (i.e. very\r\n   * small amounts) may result in 0 underlying tokens being redeemed, or in\r\n   * fewer tokens being redeemed than is implied by the current exchange rate\r\n   * (due to lack of sufficient precision on the tokens).\r\n   * @return True if the withdrawal succeeded, otherwise false.\r\n   */\r\n  function _withdrawFromDharmaToken(\r\n    AssetType asset, uint256 balance\r\n  ) internal returns (bool success) {\r\n    // Get dToken address for the asset type. (No custom ETH withdrawal action.)\r\n    address dToken = asset == AssetType.DAI ? address(_DDAI) : address(_DUSDC);\r\n\r\n    // Attempt to redeem the underlying balance from the dToken contract.\r\n    (bool ok, bytes memory data) = dToken.call(abi.encodeWithSelector(\r\n      // Note: function selector is the same for each dToken so just use dDai's.\r\n      _DDAI.redeemUnderlying.selector, balance\r\n    ));\r\n\r\n    // Log an external error if something went wrong with the attempt.\r\n    success = _checkDharmaTokenInteractionAndLogAnyErrors(\r\n      asset, _DDAI.redeemUnderlying.selector, ok, data\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function for withdrawing the total underlying asset\r\n   * balance from the corresponding dToken. Note that the requested balance may\r\n   * not be currently available on Compound, which will cause the withdrawal to\r\n   * fail.\r\n   * @param asset uint256 The asset's ID, either Dai (0) or USDC (1).\r\n   */\r\n  function _withdrawMaxFromDharmaToken(AssetType asset) internal {\r\n    // Get dToken address for the asset type. (No custom ETH withdrawal action.)\r\n    address dToken = asset == AssetType.DAI ? address(_DDAI) : address(_DUSDC);\r\n\r\n    // Try to retrieve the current dToken balance for this account.\r\n    ERC20Interface dTokenBalance;\r\n    (bool ok, bytes memory data) = dToken.call(abi.encodeWithSelector(\r\n      dTokenBalance.balanceOf.selector, address(this)\r\n    ));\r\n\r\n    uint256 redeemAmount = 0;\r\n    if (ok && data.length == 32) {\r\n      redeemAmount = abi.decode(data, (uint256));\r\n    } else {\r\n      // Something went wrong with the balance check - log an ExternalError.\r\n      _checkDharmaTokenInteractionAndLogAnyErrors(\r\n        asset, dTokenBalance.balanceOf.selector, ok, data\r\n      );\r\n    }\r\n\r\n    // Only perform the call to redeem if there is a non-zero balance.\r\n    if (redeemAmount > 0) {\r\n      // Attempt to redeem the underlying balance from the dToken contract.\r\n      (ok, data) = dToken.call(abi.encodeWithSelector(\r\n        // Function selector is the same for all dTokens, so just use dDai's.\r\n        _DDAI.redeem.selector, redeemAmount\r\n      ));\r\n\r\n      // Log an external error if something went wrong with the attempt.\r\n      _checkDharmaTokenInteractionAndLogAnyErrors(\r\n        asset, _DDAI.redeem.selector, ok, data\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function for transferring the total underlying balance of\r\n   * the corresponding token to a designated recipient. It will return true if\r\n   * tokens were successfully transferred (or there is no balance), signified by\r\n   * the boolean returned by the transfer function, or the call status if the\r\n   * `suppressRevert` boolean is set to true.\r\n   * @param token IERC20 The interface of the token in question.\r\n   * @param recipient address The account that will receive the tokens.\r\n   * @param suppressRevert bool A boolean indicating whether reverts should be\r\n   * suppressed or not. Used by the escape hatch so that a problematic transfer\r\n   * will not block the rest of the call from executing.\r\n   * @return True if tokens were successfully transferred or if there is no\r\n   * balance, else false.\r\n   */\r\n  function _transferMax(\r\n    ERC20Interface token, address recipient, bool suppressRevert\r\n  ) internal returns (bool success) {\r\n    // Get the current balance on the smart wallet for the supplied ERC20 token.\r\n    uint256 balance = 0;\r\n    bool balanceCheckWorked = true;\r\n    if (!suppressRevert) {\r\n      balance = token.balanceOf(address(this));\r\n    } else {\r\n      // Try to retrieve current token balance for this account with 1/2 gas.\r\n      (bool ok, bytes memory data) = address(token).call.gas(gasleft() / 2)(\r\n        abi.encodeWithSelector(token.balanceOf.selector, address(this))\r\n      );\r\n\r\n      if (ok && data.length == 32) {\r\n        balance = abi.decode(data, (uint256));\r\n      } else {\r\n        // Something went wrong with the balance check.\r\n        balanceCheckWorked = false;\r\n      }\r\n    }\r\n\r\n    // Only perform the call to transfer if there is a non-zero balance.\r\n    if (balance > 0) {\r\n      if (!suppressRevert) {\r\n        // Perform the transfer and pass along the returned boolean (or revert).\r\n        success = token.transfer(recipient, balance);\r\n      } else {\r\n        // Attempt transfer with 1/2 gas, allow reverts, and return call status.\r\n        (success, ) = address(token).call.gas(gasleft() / 2)(\r\n          abi.encodeWithSelector(token.transfer.selector, recipient, balance)\r\n        );\r\n      }\r\n    } else {\r\n      // Skip the transfer and return true as long as the balance check worked.\r\n      success = balanceCheckWorked;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function for transferring Ether to a designated recipient.\r\n   * It will return true and emit an `EthWithdrawal` event if Ether was\r\n   * successfully transferred - otherwise, it will return false and emit an\r\n   * `ExternalError` event.\r\n   * @param recipient address payable The account that will receive the Ether.\r\n   * @param amount uint256 The amount of Ether to transfer.\r\n   * @return True if Ether was successfully transferred, else false.\r\n   */\r\n  function _transferETH(\r\n    address payable recipient, uint256 amount\r\n  ) internal returns (bool success) {\r\n    // Attempt to transfer any Ether to caller and emit an event if it fails.\r\n    (success, ) = recipient.call.gas(_ETH_TRANSFER_GAS).value(amount)(\"\");\r\n    if (!success) {\r\n      emit ExternalError(recipient, _revertReason(18));\r\n    } else {\r\n      emit EthWithdrawal(amount, recipient);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function for validating supplied gas (if specified),\r\n   * retrieving the signer's public key from the Dharma Key Registry, deriving\r\n   * the action ID, validating the provided caller and/or signatures using that\r\n   * action ID, and incrementing the nonce. This function serves as the\r\n   * entrypoint for all protected \"actions\" on the smart wallet, and is the only\r\n   * area where these functions should revert (other than due to out-of-gas\r\n   * errors, which can be guarded against by supplying a minimum action gas\r\n   * requirement).\r\n   * @param action uint8 The type of action, designated by it's index. Valid\r\n   * actions in V7 include Cancel (0), SetUserSigningKey (1), Generic (2),\r\n   * GenericAtomicBatch (3), DAIWithdrawal (10), USDCWithdrawal (5),\r\n   * ETHWithdrawal (6), SetEscapeHatch (7), RemoveEscapeHatch (8), and\r\n   * DisableEscapeHatch (9).\r\n   * @param arguments bytes ABI-encoded arguments for the action.\r\n   * @param minimumActionGas uint256 The minimum amount of gas that must be\r\n   * provided to this call - be aware that additional gas must still be included\r\n   * to account for the cost of overhead incurred up until the start of this\r\n   * function call.\r\n   * @param userSignature bytes A signature that resolves to the public key\r\n   * set for this account in storage slot zero, `_userSigningKey`. If the user\r\n   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\r\n   * will be used. A unique hash returned from `getCustomActionID` is prefixed\r\n   * and hashed to create the message hash for the signature.\r\n   * @param dharmaSignature bytes A signature that resolves to the public key\r\n   * returned for this account from the Dharma Key Registry. A unique hash\r\n   * returned from `getCustomActionID` is prefixed and hashed to create the\r\n   * signed message.\r\n   * @return The nonce of the current action (prior to incrementing it).\r\n   */\r\n  function _validateActionAndIncrementNonce(\r\n    ActionType action,\r\n    bytes memory arguments,\r\n    uint256 minimumActionGas,\r\n    bytes memory userSignature,\r\n    bytes memory dharmaSignature\r\n  ) internal returns (bytes32 actionID, uint256 actionNonce) {\r\n    // Ensure that the current gas exceeds the minimum required action gas.\r\n    // This prevents griefing attacks where an attacker can invalidate a\r\n    // signature without providing enough gas for the action to succeed. Also\r\n    // note that some gas will be spent before this check is reached - supplying\r\n    // ~30,000 additional gas should suffice when submitting transactions. To\r\n    // skip this requirement, supply zero for the minimumActionGas argument.\r\n    if (minimumActionGas != 0) {\r\n      require(gasleft() >= minimumActionGas, _revertReason(19));\r\n    }\r\n\r\n    // Get the current nonce for the action to be performed.\r\n    actionNonce = _nonce;\r\n\r\n    // Get the user signing key that will be used to verify their signature.\r\n    address userSigningKey = _userSigningKey;\r\n\r\n    // Get the Dharma signing key that will be used to verify their signature.\r\n    address dharmaSigningKey = _getDharmaSigningKey();\r\n\r\n    // Determine the actionID - this serves as the signature hash.\r\n    actionID = _getActionID(\r\n      action,\r\n      arguments,\r\n      actionNonce,\r\n      minimumActionGas,\r\n      userSigningKey,\r\n      dharmaSigningKey\r\n    );\r\n\r\n    // Compute the message hash - the hashed, EIP-191-0x45-prefixed action ID.\r\n    bytes32 messageHash = actionID.toEthSignedMessageHash();\r\n\r\n    // Actions other than Cancel require both signatures; Cancel only needs one.\r\n    if (action != ActionType.Cancel) {\r\n      // Validate user signing key signature unless it is `msg.sender`.\r\n      if (msg.sender != userSigningKey) {\r\n        require(\r\n          _validateUserSignature(\r\n            messageHash, action, arguments, userSigningKey, userSignature\r\n          ),\r\n          _revertReason(20)\r\n        );\r\n      }\r\n\r\n      // Validate Dharma signing key signature unless it is `msg.sender`.\r\n      if (msg.sender != dharmaSigningKey) {\r\n        require(\r\n          dharmaSigningKey == messageHash.recover(dharmaSignature),\r\n          _revertReason(21)\r\n        );\r\n      }\r\n    } else {\r\n      // Validate signing key signature unless user or Dharma is `msg.sender`.\r\n      if (msg.sender != userSigningKey && msg.sender != dharmaSigningKey) {\r\n        require(\r\n          dharmaSigningKey == messageHash.recover(dharmaSignature) ||\r\n          _validateUserSignature(\r\n            messageHash, action, arguments, userSigningKey, userSignature\r\n          ),\r\n          _revertReason(22)\r\n        );\r\n      }\r\n    }\r\n\r\n    // Increment nonce in order to prevent reuse of signatures after the call.\r\n    _nonce++;\r\n  }\r\n\r\n  /**\r\n   * @notice Use all available cTokens to mint the respective dTokens. If any\r\n   * step in the process fails, the call will revert and prior steps will be\r\n   * rolled back. Also note that existing underlying tokens are not included as\r\n   * part of this operation.\r\n   */\r\n  function _migrateCTokenToDToken(AssetType token) internal {\r\n    CTokenInterface cToken;\r\n    DTokenInterface dToken;\r\n\r\n    if (token == AssetType.DAI) {\r\n      cToken = _CDAI;\r\n      dToken = _DDAI;\r\n    } else {\r\n      cToken = _CUSDC;\r\n      dToken = _DUSDC;\r\n    }\r\n\r\n    // Get the current cToken balance for this account.\r\n    uint256 balance = cToken.balanceOf(address(this));\r\n\r\n    // Only perform the conversion if there is a non-zero balance.\r\n    if (balance > 0) {    \r\n      // If the allowance is insufficient, set it before depositing.\r\n      if (cToken.allowance(address(this), address(dToken)) < balance) {\r\n        require(cToken.approve(address(dToken), uint256(-1)), _revertReason(23));\r\n      }\r\n      \r\n      // Deposit the new balance on the Dharma Token.\r\n      require(dToken.mintViaCToken(balance) > 0, _revertReason(24));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to determine whether a call to a given dToken\r\n   * succeeded, and to emit a relevant ExternalError event if it failed.\r\n   * @param asset uint256 The ID of the asset, either Dai (0) or USDC (1).\r\n   * @param functionSelector bytes4 The function selector that was called on the\r\n   * corresponding dToken of the asset type.\r\n   * @param ok bool A boolean representing whether the call returned or\r\n   * reverted.\r\n   * @param data bytes The data provided by the returned or reverted call.\r\n   * @return True if the interaction was successful, otherwise false. This will\r\n   * be used to determine if subsequent steps in the action should be attempted\r\n   * or not, specifically a transfer following a withdrawal.\r\n   */\r\n  function _checkDharmaTokenInteractionAndLogAnyErrors(\r\n    AssetType asset,\r\n    bytes4 functionSelector,\r\n    bool ok,\r\n    bytes memory data\r\n  ) internal returns (bool success) {\r\n    // Log an external error if something went wrong with the attempt.\r\n    if (ok) {\r\n      if (data.length == 32) {\r\n        uint256 amount = abi.decode(data, (uint256));\r\n        if (amount > 0) {\r\n          success = true;\r\n        } else {\r\n          // Get called contract address, name of contract, and function name.\r\n          (address account, string memory name, string memory functionName) = (\r\n            _getDharmaTokenDetails(asset, functionSelector)\r\n          );\r\n\r\n          emit ExternalError(\r\n            account,\r\n            string(\r\n              abi.encodePacked(\r\n                name,\r\n                \" gave no tokens calling \",\r\n                functionName,\r\n                \".\"\r\n              )\r\n            )\r\n          );         \r\n        }\r\n      } else {\r\n        // Get called contract address, name of contract, and function name.\r\n        (address account, string memory name, string memory functionName) = (\r\n          _getDharmaTokenDetails(asset, functionSelector)\r\n        );\r\n\r\n        emit ExternalError(\r\n          account,\r\n          string(\r\n            abi.encodePacked(\r\n              name,\r\n              \" gave bad data calling \",\r\n              functionName,\r\n              \".\"\r\n            )\r\n          )\r\n        );        \r\n      }\r\n      \r\n    } else {\r\n      // Get called contract address, name of contract, and function name.\r\n      (address account, string memory name, string memory functionName) = (\r\n        _getDharmaTokenDetails(asset, functionSelector)\r\n      );\r\n\r\n      // Decode the revert reason in the event one was returned.\r\n      string memory revertReason = _decodeRevertReason(data);\r\n\r\n      emit ExternalError(\r\n        account,\r\n        string(\r\n          abi.encodePacked(\r\n            name,\r\n            \" reverted calling \",\r\n            functionName,\r\n            \": \",\r\n            revertReason\r\n          )\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to diagnose the reason that a call to the USDC\r\n   * contract failed and to emit a corresponding ExternalError event. USDC can\r\n   * blacklist accounts and pause the contract, which can both cause a transfer\r\n   * or approval to fail.\r\n   * @param functionSelector bytes4 The function selector that was called on the\r\n   * USDC contract.\r\n   */\r\n  function _diagnoseAndEmitUSDCSpecificError(bytes4 functionSelector) internal {\r\n    // Determine the name of the function that was called on USDC.\r\n    string memory functionName;\r\n    if (functionSelector == _USDC.transfer.selector) {\r\n      functionName = \"transfer\";\r\n    } else {\r\n      functionName = \"approve\";\r\n    }\r\n    \r\n    USDCV1Interface usdcNaughty = USDCV1Interface(address(_USDC));\r\n\r\n    // Find out why USDC transfer reverted (it doesn't give revert reasons).\r\n    if (usdcNaughty.isBlacklisted(address(this))) {\r\n      emit ExternalError(\r\n        address(_USDC),\r\n        string(\r\n          abi.encodePacked(\r\n            functionName, \" failed - USDC has blacklisted this user.\"\r\n          )\r\n        )\r\n      );\r\n    } else { // Note: `else if` breaks coverage.\r\n      if (usdcNaughty.paused()) {\r\n        emit ExternalError(\r\n          address(_USDC),\r\n          string(\r\n            abi.encodePacked(\r\n              functionName, \" failed - USDC contract is currently paused.\"\r\n            )\r\n          )\r\n        );\r\n      } else {\r\n        emit ExternalError(\r\n          address(_USDC),\r\n          string(\r\n            abi.encodePacked(\r\n              \"USDC contract reverted on \", functionName, \".\"\r\n            )\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to ensure that protected functions can only be\r\n   * called from this contract and that they have the appropriate context set.\r\n   * The self-call context is then cleared. It is used as an additional guard\r\n   * against reentrancy, especially once generic actions are supported by the\r\n   * smart wallet in future versions.\r\n   * @param selfCallContext bytes4 The expected self-call context, equal to the\r\n   * function selector of the approved calling function.\r\n   */\r\n  function _enforceSelfCallFrom(bytes4 selfCallContext) internal {\r\n    // Ensure caller is this contract and self-call context is correctly set.\r\n    require(\r\n      msg.sender == address(this) && _selfCallContext == selfCallContext,\r\n      _revertReason(25)\r\n    );\r\n\r\n    // Clear the self-call context.\r\n    delete _selfCallContext;\r\n  }\r\n\r\n  /**\r\n   * @notice Internal view function for validating a user's signature. If the\r\n   * user's signing key does not have contract code, it will be validated via\r\n   * ecrecover; otherwise, it will be validated using ERC-1271, passing the\r\n   * message hash that was signed, the action type, and the arguments as data.\r\n   * @param messageHash bytes32 The message hash that is signed by the user. It\r\n   * is derived by prefixing (according to EIP-191 0x45) and hashing an actionID\r\n   * returned from `getCustomActionID`.\r\n   * @param action uint8 The type of action, designated by it's index. Valid\r\n   * actions in V7 include Cancel (0), SetUserSigningKey (1), Generic (2),\r\n   * GenericAtomicBatch (3), DAIWithdrawal (10), USDCWithdrawal (5),\r\n   * ETHWithdrawal (6), SetEscapeHatch (7), RemoveEscapeHatch (8), and\r\n   * DisableEscapeHatch (9).\r\n   * @param arguments bytes ABI-encoded arguments for the action.\r\n   * @param userSignature bytes A signature that resolves to the public key\r\n   * set for this account in storage slot zero, `_userSigningKey`. If the user\r\n   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\r\n   * will be used.\r\n   * @return A boolean representing the validity of the supplied user signature.\r\n   */\r\n  function _validateUserSignature(\r\n    bytes32 messageHash,\r\n    ActionType action,\r\n    bytes memory arguments,\r\n    address userSigningKey,\r\n    bytes memory userSignature\r\n  ) internal view returns (bool valid) {\r\n    if (!userSigningKey.isContract()) {\r\n      valid = userSigningKey == messageHash.recover(userSignature);\r\n    } else {\r\n      bytes memory data = abi.encode(messageHash, action, arguments);\r\n      valid = (\r\n        ERC1271Interface(userSigningKey).isValidSignature(\r\n          data, userSignature\r\n        ) == _ERC_1271_MAGIC_VALUE\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal view function to get the Dharma signing key for the smart\r\n   * wallet from the Dharma Key Registry. This key can be set for each specific\r\n   * smart wallet - if none has been set, a global fallback key will be used.\r\n   * @return The address of the Dharma signing key, or public key corresponding\r\n   * to the secondary signer.\r\n   */\r\n  function _getDharmaSigningKey() internal view returns (\r\n    address dharmaSigningKey\r\n  ) {\r\n    dharmaSigningKey = _DHARMA_KEY_REGISTRY.getKey();\r\n  }\r\n\r\n  /**\r\n   * @notice Internal view function that, given an action type and arguments,\r\n   * will return the action ID or message hash that will need to be prefixed\r\n   * (according to EIP-191 0x45), hashed, and signed by the key designated by\r\n   * the Dharma Key Registry in order to construct a valid signature for the\r\n   * corresponding action. The current nonce will be supplied to this function\r\n   * when reconstructing an action ID during protected function execution based\r\n   * on the supplied parameters.\r\n   * @param action uint8 The type of action, designated by it's index. Valid\r\n   * actions in V7 include Cancel (0), SetUserSigningKey (1), Generic (2),\r\n   * GenericAtomicBatch (3), DAIWithdrawal (10), USDCWithdrawal (5),\r\n   * ETHWithdrawal (6), SetEscapeHatch (7), RemoveEscapeHatch (8), and\r\n   * DisableEscapeHatch (9).\r\n   * @param arguments bytes ABI-encoded arguments for the action.\r\n   * @param nonce uint256 The nonce to use.\r\n   * @param minimumActionGas uint256 The minimum amount of gas that must be\r\n   * provided to this call - be aware that additional gas must still be included\r\n   * to account for the cost of overhead incurred up until the start of this\r\n   * function call.\r\n   * @param dharmaSigningKey address The address of the secondary key, or public\r\n   * key corresponding to the secondary signer.\r\n   * @return The action ID, which will need to be prefixed, hashed and signed in\r\n   * order to construct a valid signature.\r\n   */\r\n  function _getActionID(\r\n    ActionType action,\r\n    bytes memory arguments,\r\n    uint256 nonce,\r\n    uint256 minimumActionGas,\r\n    address userSigningKey,\r\n    address dharmaSigningKey\r\n  ) internal view returns (bytes32 actionID) {\r\n    // actionID is constructed according to EIP-191-0x45 to prevent replays.\r\n    actionID = keccak256(\r\n      abi.encodePacked(\r\n        address(this),\r\n        _DHARMA_SMART_WALLET_VERSION,\r\n        userSigningKey,\r\n        dharmaSigningKey,\r\n        nonce,\r\n        minimumActionGas,\r\n        action,\r\n        arguments\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function to get the dToken address, it's name, and\r\n   * the name of the called function, based on a supplied asset type and\r\n   * function selector. It is used to help construct ExternalError events.\r\n   * @param asset uint256 The ID of the asset, either Dai (0) or USDC (1).\r\n   * @param functionSelector bytes4 The function selector that was called on the\r\n   * corresponding dToken of the asset type.\r\n   * @return The dToken address, it's name, and the name of the called function.\r\n   */\r\n  function _getDharmaTokenDetails(\r\n    AssetType asset,\r\n    bytes4 functionSelector\r\n  ) internal pure returns (\r\n    address account,\r\n    string memory name,\r\n    string memory functionName\r\n  ) {\r\n    if (asset == AssetType.DAI) {\r\n      account = address(_DDAI);\r\n      name = \"Dharma Dai\";\r\n    } else {\r\n      account = address(_DUSDC);\r\n      name = \"Dharma USD Coin\";\r\n    }\r\n\r\n    // Note: since both dTokens have the same interface, just use dDai's.\r\n    if (functionSelector == _DDAI.mint.selector) {\r\n      functionName = \"mint\";\r\n    } else {\r\n      if (functionSelector == ERC20Interface(account).balanceOf.selector) {\r\n        functionName = \"balanceOf\";\r\n      } else {\r\n        functionName = string(abi.encodePacked(\r\n          \"redeem\",\r\n          functionSelector == _DDAI.redeem.selector ? \"\" : \"Underlying\"\r\n        ));\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal view function to ensure that a given `to` address provided\r\n   * as part of a generic action is valid. Calls cannot be performed to accounts\r\n   * without code or back into the smart wallet itself. Additionally, generic\r\n   * calls cannot supply the address of the Dharma Escape Hatch registry - the\r\n   * specific, designated functions must be used in order to make calls into it.\r\n   * @param to address The address that will be targeted by the generic call.\r\n   */\r\n  function _ensureValidGenericCallTarget(address to) internal view {\r\n    require(to.isContract(), _revertReason(26));\r\n\r\n    require(to != address(this), _revertReason(27));\r\n\r\n    require(to != address(_ESCAPE_HATCH_REGISTRY), _revertReason(28));\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function to ensure that a given action type is a\r\n   * \"custom\" action type (i.e. is not a generic action type) and to construct\r\n   * the \"arguments\" input to an actionID based on that action type.\r\n   * @param action uint8 The type of action, designated by it's index. Valid\r\n   * custom actions in V7 include Cancel (0), SetUserSigningKey (1),\r\n   * DAIWithdrawal (10), USDCWithdrawal (5), ETHWithdrawal (6),\r\n   * SetEscapeHatch (7), RemoveEscapeHatch (8), and DisableEscapeHatch (9).\r\n   * @param amount uint256 The amount to withdraw for Withdrawal actions. This\r\n   * value is ignored for all non-withdrawal action types.\r\n   * @param recipient address The account to transfer withdrawn funds to or the\r\n   * new user signing key. This value is ignored for Cancel, RemoveEscapeHatch,\r\n   * and DisableEscapeHatch action types.\r\n   * @return A bytes array containing the arguments that will be provided as\r\n   * a component of the inputs when constructing a custom action ID.\r\n   */\r\n  function _validateCustomActionTypeAndGetArguments(\r\n    ActionType action, uint256 amount, address recipient\r\n  ) internal pure returns (bytes memory arguments) {\r\n    // Ensure that the action type is a valid custom action type.\r\n    require(\r\n      action == ActionType.Cancel ||\r\n      action == ActionType.SetUserSigningKey ||\r\n      action == ActionType.DAIWithdrawal ||\r\n      action == ActionType.USDCWithdrawal ||\r\n      action == ActionType.ETHWithdrawal ||\r\n      action == ActionType.SetEscapeHatch ||\r\n      action == ActionType.RemoveEscapeHatch ||\r\n      action == ActionType.DisableEscapeHatch,\r\n      _revertReason(29)\r\n    );\r\n\r\n    // Use action type to determine parameters to include in returned arguments.\r\n    if (\r\n      action == ActionType.Cancel ||\r\n      action == ActionType.RemoveEscapeHatch ||\r\n      action == ActionType.DisableEscapeHatch\r\n    ) {\r\n      // Ignore parameters for Cancel, RemoveEscapeHatch, or DisableEscapeHatch.\r\n      arguments = abi.encode();\r\n    } else if (\r\n      action == ActionType.SetUserSigningKey ||\r\n      action == ActionType.SetEscapeHatch\r\n    ) {\r\n      // Ignore `amount` parameter for other, non-withdrawal actions.\r\n      arguments = abi.encode(recipient);\r\n    } else {\r\n      // Use both `amount` and `recipient` parameters for withdrawals.\r\n      arguments = abi.encode(amount, recipient);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function to decode revert reasons. The revert reason\r\n   * prefix is removed and the remaining string argument is decoded.\r\n   * @param revertData bytes The raw data supplied alongside the revert.\r\n   * @return The decoded revert reason string.\r\n   */\r\n  function _decodeRevertReason(\r\n    bytes memory revertData\r\n  ) internal pure returns (string memory revertReason) {\r\n    // Solidity prefixes revert reason with 0x08c379a0 -> Error(string) selector\r\n    if (\r\n      revertData.length > 68 && // prefix (4) + position (32) + length (32)\r\n      revertData[0] == byte(0x08) &&\r\n      revertData[1] == byte(0xc3) &&\r\n      revertData[2] == byte(0x79) &&\r\n      revertData[3] == byte(0xa0)\r\n    ) {\r\n      // Get the revert reason without the prefix from the revert data.\r\n      bytes memory revertReasonBytes = new bytes(revertData.length - 4);\r\n      for (uint256 i = 4; i < revertData.length; i++) {\r\n        revertReasonBytes[i - 4] = revertData[i];\r\n      }\r\n\r\n      // Decode the resultant revert reason as a string.\r\n      revertReason = abi.decode(revertReasonBytes, (string));\r\n    } else {\r\n      // Simply return the default, with no revert reason.\r\n      revertReason = _revertReason(uint256(-1));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function call the revert reason helper contract,\r\n   * supplying a revert \"code\" and receiving back a revert reason string.\r\n   * @param code uint256 The code for the revert reason.\r\n   * @return The revert reason string.\r\n   */\r\n  function _revertReason(\r\n    uint256 code\r\n  ) internal pure returns (string memory reason) {\r\n    reason = _REVERT_REASON_HELPER.reason(code);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"daiBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usdcBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"etherBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dDaiUnderlyingDaiBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dUsdcUnderlyingUsdcBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dEtherUnderlyingEtherBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethToSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumDaiReceived\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"}],\"name\":\"getNextEthForDaiActionID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"actionID\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newUserSigningKey\",\"type\":\"address\"}],\"name\":\"recover\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct DharmaSmartWalletImplementationV1Interface.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dharmaSignature\",\"type\":\"bytes\"}],\"name\":\"executeActionWithAtomicBatchCalls\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"ok\",\"type\":\"bool[]\"},{\"internalType\":\"bytes[]\",\"name\":\"returnData\",\"type\":\"bytes[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"magicValue\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userSigningKey\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dharmaSignature\",\"type\":\"bytes\"}],\"name\":\"setUserSigningKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethToSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumDaiReceived\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"}],\"name\":\"getEthForDaiActionID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"actionID\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dharmaSignature\",\"type\":\"bytes\"}],\"name\":\"removeEscapeHatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"migrateCDaiToDDai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct DharmaSmartWalletImplementationV1Interface.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"}],\"name\":\"getNextGenericAtomicBatchActionID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"actionID\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dharmaSignature\",\"type\":\"bytes\"}],\"name\":\"withdrawUSDC\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"enum DharmaSmartWalletImplementationV7Interface.ActionType\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"}],\"name\":\"getCustomActionID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"actionID\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUserSigningKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"userSigningKey\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"}],\"name\":\"getNextGenericActionID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"actionID\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"}],\"name\":\"getGenericActionID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"actionID\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"migrateSaiToDai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dharmaSignature\",\"type\":\"bytes\"}],\"name\":\"permanentlyDisableEscapeHatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dharmaSignature\",\"type\":\"bytes\"}],\"name\":\"withdrawEther\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"_withdrawUSDCAtomic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"migrateCUSDCToDUSDC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"_withdrawDaiAtomic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethToSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumDaiReceived\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dharmaSignature\",\"type\":\"bytes\"}],\"name\":\"tradeEthForDaiAndMintDDai\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dharmaSignature\",\"type\":\"bytes\"}],\"name\":\"setEscapeHatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dharmaSignature\",\"type\":\"bytes\"}],\"name\":\"withdrawDai\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userSigningKey\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dharmaSignature\",\"type\":\"bytes\"}],\"name\":\"executeAction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"escape\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct DharmaSmartWalletImplementationV1Interface.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"}],\"name\":\"getGenericAtomicBatchActionID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"actionID\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct DharmaSmartWalletImplementationV1Interface.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"_executeActionWithAtomicBatchCallsAtomic\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"internalType\":\"struct DharmaSmartWalletImplementationV1Interface.CallReturn[]\",\"name\":\"callResults\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"repayAndDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethToSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumDaiReceived\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"_tradeEthForDaiAndMintDDaiAtomic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"enum DharmaSmartWalletImplementationV7Interface.ActionType\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"}],\"name\":\"getNextCustomActionID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"actionID\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"migrateCSaiToDDai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userSigningKey\",\"type\":\"address\"}],\"name\":\"NewUserSigningKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"revertReason\",\"type\":\"string\"}],\"name\":\"ExternalError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Escaped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cancelledNonce\",\"type\":\"uint256\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"EthWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"actionID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"rolledBack\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"name\":\"CallSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"actionID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"revertReason\",\"type\":\"string\"}],\"name\":\"CallFailure\",\"type\":\"event\"}]","ContractName":"DharmaSmartWalletImplementationV8Staging","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://c65cb84c987010c44638e29946625103713e2c41fc92646e6a6296a1268e08bc"}]}