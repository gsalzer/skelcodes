{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\ncontract Ownable\r\n{\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract TokenERC20 is Ownable {\r\n    bytes32 public standard;\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public totalSupply;\r\n    uint8 public decimals;\r\n    bool public allowTransactions;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    function transfer(address _to, uint256 _value) public;\r\n    function approve(address _spender, uint256 _value) public;\r\n    function transferFrom(address _from, address _to, uint256 _value) public;\r\n}\r\n\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using his signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes memory sig) internal pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n    \r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n}\r\n\r\ncontract StmWalletSwap is Ownable {\r\n    using ECRecovery for bytes32;\r\n    \r\n    mapping(bytes32 => bool) public swapList;\r\n    \r\n    event Swap(address _recipient, bytes32 _tradeID, address _cFrom, address _cOut, uint256 _vFrom, uint256 _vOut);\r\n    event TransferAltChain(bytes32 _tradeID, address _to, address _token, uint256 _amount);\r\n    event AddEth(uint256 _amount);\r\n    event Failed(uint code, bytes32 info, address _address);\r\n    \r\n   /**\r\n    * _tradeID   - swap ID\r\n    * _cFrom     - coin from\r\n    * _cOut      - coin out\r\n    * _vFrom     - value from\r\n    * _vOut      - value out\r\n    * _time      - max live time\r\n    * _sign      - keccak256\r\n    **/ \r\n    function swap(bytes32 _tradeID, address _cFrom, address _cOut, uint256 _vFrom, uint256 _vOut, uint256 _time, bytes calldata _sign) payable external \r\n    {\r\n        require(_cFrom != _cOut);\r\n        bytes32 _hashSwap = keccak256(abi.encodePacked(_tradeID, _cFrom, _cOut, _vFrom, _vOut, _time));\r\n        \r\n        if(now > _time) {\r\n            return;\r\n        }\r\n        \r\n        if(_hashSwap.recover(_sign) != owner) { emit Failed(1, _hashSwap, _hashSwap.recover(_sign)); } if(swapList[_tradeID]) { emit Failed(2, _hashSwap, msg.sender); return; }\r\n        \r\n        //verifySign(_hashSwap, _sign, _tradeID);\r\n        swapList[_tradeID] = true;\r\n        \r\n        if (_cFrom == address(0x0)) {\r\n            if(msg.value <= 0) { emit Failed(3, 0x0, msg.sender); return; } if(msg.value != _vFrom) { emit Failed(4, 0x0, msg.sender); return; }\r\n            //require(msg.value > 0);\r\n            //require(msg.value == _vFrom);\r\n        } else {\r\n            //bool transfer1 = TokenERC20(_cFrom).transferFrom(msg.sender, address(this), _vFrom); if(!transfer1) { emit Failed(5, 0x0, msg.sender); return;}\r\n            //require(TokenERC20(_cFrom).transferFrom(msg.sender, address(this), _vFrom));\r\n            require(safeTransferFrom(_cFrom, msg.sender, address(this), _vFrom));\r\n        }\r\n        \r\n        if (_cOut == address(0x0)) {\r\n            msg.sender.transfer(_vOut);\r\n        } else {\r\n            require(safeTransfer(_cOut, msg.sender, _vOut));\r\n        }\r\n        \r\n        emit Swap(msg.sender, _tradeID, _cFrom, _cOut, _vFrom, _vOut);\r\n    }\r\n    \r\n    function verifySign(bytes32 _hashSwap, bytes memory _sign, bytes32 _tradeID) private view {\r\n        require(_hashSwap.recover(_sign) == owner);\r\n        require(!swapList[_tradeID]);\r\n    }\r\n    \r\n    function withdraw(address payable _to, address _token, uint256 _amount) external onlyOwner {\r\n        if (_token == address(0x0)) {\r\n            _to.transfer(_amount);\r\n        } else {\r\n            TokenERC20(_token).transfer(_to, _amount);\r\n        }\r\n    }\r\n    \r\n    function transferAltChain(bytes32 _tradeID, address payable _to, address _token, uint256 _amount) external onlyOwner {\r\n        if (_token == address(0x0)) {\r\n            _to.transfer(_amount);\r\n        } else {\r\n            TokenERC20(_token).transfer(_to, _amount);\r\n        }\r\n        emit TransferAltChain(_tradeID, _to, _token, _amount);\r\n    }\r\n    \r\n    function addEth() payable external\r\n    {\r\n        emit AddEth(msg.value);\r\n    }\r\n    \r\n    function safeTransfer(address token, address to , uint value) private returns (bool result) {\r\n        TokenERC20(token).transfer(to,value);\r\n\r\n        assembly {\r\n            switch returndatasize()   \r\n                case 0 {                      // This is our BadToken\r\n                    result := not(0)          // result is true\r\n                }\r\n                case 32 {                     // This is our GoodToken\r\n                    returndatacopy(0, 0, 32) \r\n                    result := mload(0)        // result == returndata of external call\r\n                }\r\n                default {                     // This is not an ERC20 token\r\n                    revert(0, 0) \r\n                }\r\n        }\r\n        require(result);                          // revert() if result is false\r\n    }\r\n    \r\n    function safeTransferFrom(address token, address to, address _from, uint value) private returns (bool result) {\r\n        TokenERC20(token).transferFrom(_from, to, value);\r\n\r\n        assembly {\r\n            switch returndatasize()   \r\n                case 0 {                      // This is our BadToken\r\n                    result := not(0)          // result is true\r\n                }\r\n                case 32 {                     // This is our GoodToken\r\n                    returndatacopy(0, 0, 32) \r\n                    result := mload(0)        // result == returndata of external call\r\n                }\r\n                default {                     // This is not an ERC20 token\r\n                    revert(0, 0) \r\n                }\r\n        }\r\n        require(result);                          // revert() if result is false\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"AddEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"code\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"info\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"Failed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_tradeID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_cFrom\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_cOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_vFrom\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_vOut\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_tradeID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TransferAltChain\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"addEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_tradeID\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_cFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_vFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sign\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"swapList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_tradeID\",\"type\":\"bytes32\"},{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferAltChain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StmWalletSwap","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://71c0596df4050a73f323c16b3d336a05d4646f6ca1aa4dfee7afae7afa6243cf"}]}