{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nlibrary LibEIP712 {\r\n    string internal constant DOMAIN_NAME = \"Mai Protocol\";\r\n\r\n    struct OrderSignature {\r\n        bytes32 config;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n    /**\r\n     * Hash of the EIP712 Domain Separator Schema\r\n     */\r\n    bytes32 private constant EIP712_DOMAIN_TYPEHASH = keccak256(abi.encodePacked(\"EIP712Domain(string name)\"));\r\n\r\n    bytes32 private constant DOMAIN_SEPARATOR = keccak256(\r\n        abi.encodePacked(EIP712_DOMAIN_TYPEHASH, keccak256(bytes(DOMAIN_NAME)))\r\n    );\r\n\r\n    /**\r\n     * Calculates EIP712 encoding for a hash struct in this EIP712 Domain.\r\n     *\r\n     * @param eip712hash The EIP712 hash struct.\r\n     * @return EIP712 hash applied to this EIP712 Domain.\r\n     */\r\n    function hashEIP712Message(bytes32 eip712hash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, eip712hash));\r\n    }\r\n}\r\n\r\nlibrary LibSignature {\r\n    enum SignatureMethod {ETH_SIGN, EIP712}\r\n\r\n    struct OrderSignature {\r\n        bytes32 config;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n    /**\r\n     * Validate a signature given a hash calculated from the order data, the signer, and the\r\n     * signature data passed in with the order.\r\n     *\r\n     * This function will revert the transaction if the signature method is invalid.\r\n     *\r\n     * @param signature The signature data passed along with the order to validate against\r\n     * @param hash Hash bytes calculated by taking the EIP712 hash of the passed order data\r\n     * @param signerAddress The address of the signer\r\n     * @return True if the calculated signature matches the order signature data, false otherwise.\r\n     */\r\n    function isValidSignature(OrderSignature memory signature, bytes32 hash, address signerAddress)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        uint8 method = uint8(signature.config[1]);\r\n        address recovered;\r\n        uint8 v = uint8(signature.config[0]);\r\n\r\n        if (method == uint8(SignatureMethod.ETH_SIGN)) {\r\n            recovered = ecrecover(\r\n                keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)),\r\n                v,\r\n                signature.r,\r\n                signature.s\r\n            );\r\n        } else if (method == uint8(SignatureMethod.EIP712)) {\r\n            recovered = ecrecover(hash, v, signature.r, signature.s);\r\n        } else {\r\n            revert(\"invalid sign method\");\r\n        }\r\n\r\n        return signerAddress == recovered;\r\n    }\r\n}\r\n\r\nlibrary LibMathSigned {\r\n    int256 private constant _WAD = 10**18;\r\n    int256 private constant _INT256_MIN = -2**255;\r\n\r\n    function WAD() internal pure returns (int256) {\r\n        return _WAD;\r\n    }\r\n\r\n    // additive inverse\r\n    function neg(int256 a) internal pure returns (int256) {\r\n        return sub(int256(0), a);\r\n    }\r\n\r\n    /**\r\n     * @dev wmultiplies two signed integers, reverts on overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        require(!(a == -1 && b == _INT256_MIN), \"wmultiplication overflow\");\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \"wmultiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer wdivision of two signed integers truncating the quotient, reverts on wdivision by zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"wdivision by zero\");\r\n        require(!(b == -1 && a == _INT256_MIN), \"wdivision overflow\");\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two signed integers, reverts on overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"subtraction overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two signed integers, reverts on overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function wmul(int256 x, int256 y) internal pure returns (int256 z) {\r\n        z = roundHalfUp(mul(x, y), _WAD) / _WAD;\r\n    }\r\n\r\n    // solium-disable-next-line security/no-assign-params\r\n    function wdiv(int256 x, int256 y) internal pure returns (int256 z) {\r\n        if (y < 0) {\r\n            y = -y;\r\n            x = -x;\r\n        }\r\n        z = roundHalfUp(mul(x, _WAD), y) / y;\r\n    }\r\n\r\n    // solium-disable-next-line security/no-assign-params\r\n    function wfrac(int256 x, int256 y, int256 z) internal pure returns (int256 r) {\r\n        int256 t = mul(x, y);\r\n        if (z < 0) {\r\n            z = -z;\r\n            t = -t;\r\n        }\r\n        r = roundHalfUp(t, z) / z;\r\n    }\r\n\r\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    // quotient and remainder\r\n    function pwdiv(int256 x, int256 y) internal pure returns (int256 z, int256 m) {\r\n        z = wdiv(x, y);\r\n        m = sub(wmul(y, z), x);\r\n    }\r\n\r\n    function toUint256(int256 x) internal pure returns (uint256) {\r\n        require(x >= 0, \"int overflow\");\r\n        return uint256(x);\r\n    }\r\n\r\n    // x ^ n\r\n    // NOTE: n is a normal integer, do not shift 18 decimals\r\n    // solium-disable-next-line security/no-assign-params\r\n    function wpowi(int256 x, int256 n) internal pure returns (int256 z) {\r\n        z = n % 2 != 0 ? x : _WAD;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = wmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = wmul(z, x);\r\n            }\r\n        }\r\n    }\r\n\r\n    uint8 internal constant fixed_digits = 18;\r\n    int256 internal constant fixed_1 = 1000000000000000000;\r\n    int256 internal constant fixed_e = 2718281828459045235;\r\n    uint8 internal constant longer_digits = 36;\r\n    int256 internal constant longer_fixed_log_e_1_5 = 405465108108164381978013115464349137;\r\n    int256 internal constant longer_fixed_1 = 1000000000000000000000000000000000000;\r\n    int256 internal constant longer_fixed_log_e_10 = 2302585092994045684017991454684364208;\r\n\r\n    // ROUND_HALF_UP rule helper. 0.5 ≈ 1, 0.4 ≈ 0, -0.5 ≈ -1, -0.4 ≈ 0\r\n    function roundHalfUp(int256 x, int256 y) internal pure returns (int256) {\r\n        require(y > 0, \"roundHalfUp only supports y > 0\");\r\n        if (x >= 0) {\r\n            return add(x, y / 2);\r\n        }\r\n        return sub(x, y / 2);\r\n    }\r\n\r\n    // function roundFloor(int256 x, int256 y) internal pure returns (int256) {\r\n    //     require(y > 0, \"roundHalfUp only supports y > 0\");\r\n    //     if (x >= 0 || x % _WAD == 0) {\r\n    //         return x;\r\n    //     }\r\n    //     return sub(x, y);\r\n    // }\r\n\r\n    // function roundCeil(int256 x, int256 y) internal pure returns (int256) {\r\n    //     require(y > 0, \"roundHalfUp only supports y > 0\");\r\n    //     if (x <= 0 || x % _WAD == 0) {\r\n    //         return x;\r\n    //     }\r\n    //     return add(x, y);\r\n    // }\r\n\r\n    // Log(e, x)\r\n    // solium-disable-next-line security/no-assign-params\r\n    function wln(int256 x) internal pure returns (int256) {\r\n        require(x > 0, \"logE of negative number\");\r\n        require(x <= 10000000000000000000000000000000000000000, \"logE only accepts v <= 1e22 * 1e18\"); // in order to prevent using safe-math\r\n        int256 r = 0;\r\n        uint8 extra_digits = longer_digits - fixed_digits;\r\n        int256 t = int256(uint256(10)**uint256(extra_digits));\r\n\r\n        while (x <= fixed_1 / 10) {\r\n            x = x * 10;\r\n            r -= longer_fixed_log_e_10;\r\n        }\r\n        while (x >= 10 * fixed_1) {\r\n            x = x / 10;\r\n            r += longer_fixed_log_e_10;\r\n        }\r\n        while (x < fixed_1) {\r\n            x = wmul(x, fixed_e);\r\n            r -= longer_fixed_1;\r\n        }\r\n        while (x > fixed_e) {\r\n            x = wdiv(x, fixed_e);\r\n            r += longer_fixed_1;\r\n        }\r\n        if (x == fixed_1) {\r\n            return roundHalfUp(r, t) / t;\r\n        }\r\n        if (x == fixed_e) {\r\n            return fixed_1 + roundHalfUp(r, t) / t;\r\n        }\r\n        x *= t;\r\n\r\n        //               x^2   x^3   x^4\r\n        // Ln(1+x) = x - --- + --- - --- + ...\r\n        //                2     3     4\r\n        // when -1 < x < 1, O(x^n) < ε => when n = 36, 0 < x < 0.316\r\n        //\r\n        //                    2    x           2    x          2    x\r\n        // Ln(a+x) = Ln(a) + ---(------)^1  + ---(------)^3 + ---(------)^5 + ...\r\n        //                    1   2a+x         3   2a+x        5   2a+x\r\n        //\r\n        // Let x = v - a\r\n        //                  2   v-a         2   v-a        2   v-a\r\n        // Ln(v) = Ln(a) + ---(-----)^1  + ---(-----)^3 + ---(-----)^5 + ...\r\n        //                  1   v+a         3   v+a        5   v+a\r\n        // when n = 36, 1 < v < 3.423\r\n        r = r + longer_fixed_log_e_1_5;\r\n        int256 a1_5 = (3 * longer_fixed_1) / 2;\r\n        int256 m = (longer_fixed_1 * (x - a1_5)) / (x + a1_5);\r\n        r = r + 2 * m;\r\n        int256 m2 = (m * m) / longer_fixed_1;\r\n        uint8 i = 3;\r\n        while (true) {\r\n            m = (m * m2) / longer_fixed_1;\r\n            r = r + (2 * m) / int256(i);\r\n            i += 2;\r\n            if (i >= 3 + 2 * fixed_digits) {\r\n                break;\r\n            }\r\n        }\r\n        return roundHalfUp(r, t) / t;\r\n    }\r\n\r\n    // Log(b, x)\r\n    function logBase(int256 base, int256 x) internal pure returns (int256) {\r\n        return wdiv(wln(x), wln(base));\r\n    }\r\n\r\n    function ceil(int256 x, int256 m) internal pure returns (int256) {\r\n        require(x >= 0, \"ceil need x >= 0\");\r\n        require(m > 0, \"ceil need m > 0\");\r\n        return (sub(add(x, m), 1) / m) * m;\r\n    }\r\n}\r\n\r\nlibrary LibMathUnsigned {\r\n    uint256 private constant _WAD = 10**18;\r\n    uint256 private constant _UINT256_MAX = 2**255 - 1;\r\n\r\n    function WAD() internal pure returns (uint256) {\r\n        return _WAD;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"Unaddition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"Unsubtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"Unmultiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"Undivision by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, y), _WAD / 2) / _WAD;\r\n    }\r\n\r\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, _WAD), y / 2) / y;\r\n    }\r\n\r\n    function wfrac(uint256 x, uint256 y, uint256 z) internal pure returns (uint256 r) {\r\n        r = mul(x, y) / z;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    // quotient and remainder\r\n    function pwdiv(uint256 x, uint256 y) internal pure returns (uint256 z, uint256 m) {\r\n        z = wdiv(x, y);\r\n        m = sub(wmul(y, z), x);\r\n    }\r\n\r\n    function toInt256(uint256 x) internal pure returns (int256) {\r\n        require(x <= _UINT256_MAX, \"uint256 overflow\");\r\n        return int256(x);\r\n    }\r\n\r\n    function mod(uint256 x, uint256 m) internal pure returns (uint256) {\r\n        require(m != 0, \"mod by zero\");\r\n        return x % m;\r\n    }\r\n\r\n    function ceil(uint256 x, uint256 m) internal pure returns (uint256) {\r\n        require(m > 0, \"ceil need m > 0\");\r\n        return (sub(add(x, m), 1) / m) * m;\r\n    }\r\n}\r\n\r\nlibrary LibOrder {\r\n    using LibMathSigned for int256;\r\n    using LibMathUnsigned for uint256;\r\n\r\n    bytes32 public constant EIP712_ORDER_TYPE = keccak256(\r\n        abi.encodePacked(\r\n            \"Order(address trader,address broker,address perpetual,uint256 amount,uint256 price,bytes32 data)\"\r\n        )\r\n    );\r\n\r\n    int256 public constant FEE_RATE_BASE = 100000;\r\n    uint256 public constant ONE = 1e18;\r\n\r\n    struct Order {\r\n        address trader;\r\n        address broker;\r\n        address perpetual;\r\n        uint256 amount;\r\n        uint256 price;\r\n        /**\r\n         * Data contains the following values packed into 32 bytes\r\n         * ╔════════════════════╤═══════════════════════════════════════════════════════════╗\r\n         * ║                    │ length(bytes)   desc                                      ║\r\n         * ╟────────────────────┼───────────────────────────────────────────────────────────╢\r\n         * ║ version            │ 1               order version                             ║\r\n         * ║ side               │ 1               0: buy (long), 1: sell (short)            ║\r\n         * ║ isMarketOrder      │ 1               0: limitOrder, 1: marketOrder             ║\r\n         * ║ expiredAt          │ 5               order expiration time in seconds          ║\r\n         * ║ asMakerFeeRate     │ 2               maker fee rate (base 100,000)             ║\r\n         * ║ asTakerFeeRate     │ 2               taker fee rate (base 100,000)             ║\r\n         * ║ (d) makerRebateRate│ 2               rebate rate for maker (base 100)          ║\r\n         * ║ salt               │ 8               salt                                      ║\r\n         * ║ isMakerOnly        │ 1               is maker only                             ║\r\n         * ║ isInversed         │ 1               is inversed contract                      ║\r\n         * ║                    │ 8               reserved                                  ║\r\n         * ╚════════════════════╧═══════════════════════════════════════════════════════════╝\r\n         */\r\n        bytes32 data;\r\n    }\r\n\r\n    struct OrderParam {\r\n        address trader;\r\n        uint256 amount;\r\n        uint256 price;\r\n        bytes32 data;\r\n        LibSignature.OrderSignature signature;\r\n    }\r\n\r\n    function getOrderHash(OrderParam memory orderParam, address perpetual, address broker)\r\n        internal\r\n        pure\r\n        returns (bytes32 orderHash)\r\n    {\r\n        Order memory order = getOrder(orderParam, perpetual, broker);\r\n        orderHash = LibEIP712.hashEIP712Message(hashOrder(order));\r\n        return orderHash;\r\n    }\r\n\r\n    function getOrderHash(Order memory order) internal pure returns (bytes32 orderHash) {\r\n        orderHash = LibEIP712.hashEIP712Message(hashOrder(order));\r\n        return orderHash;\r\n    }\r\n\r\n    function getOrder(OrderParam memory orderParam, address perpetual, address broker)\r\n        internal\r\n        pure\r\n        returns (LibOrder.Order memory order)\r\n    {\r\n        order.trader = orderParam.trader;\r\n        order.broker = broker;\r\n        order.perpetual = perpetual;\r\n        order.amount = orderParam.amount;\r\n        order.price = orderParam.price;\r\n        order.data = orderParam.data;\r\n    }\r\n\r\n    function hashOrder(Order memory order) internal pure returns (bytes32 result) {\r\n        bytes32 orderType = EIP712_ORDER_TYPE;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let start := sub(order, 32)\r\n            let tmp := mload(start)\r\n            mstore(start, orderType)\r\n            result := keccak256(start, 224)\r\n            mstore(start, tmp)\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function getOrderVersion(OrderParam memory orderParam) internal pure returns (uint256) {\r\n        return uint256(uint8(bytes1(orderParam.data)));\r\n    }\r\n\r\n    function getExpiredAt(OrderParam memory orderParam) internal pure returns (uint256) {\r\n        return uint256(uint40(bytes5(orderParam.data << (8 * 3))));\r\n    }\r\n\r\n    function isSell(OrderParam memory orderParam) internal pure returns (bool) {\r\n        bool sell = uint8(orderParam.data[1]) == 1;\r\n        return isInversed(orderParam) ? !sell : sell;\r\n    }\r\n\r\n    function getPrice(OrderParam memory orderParam) internal pure returns (uint256) {\r\n        return isInversed(orderParam) ? ONE.wdiv(orderParam.price) : orderParam.price;\r\n    }\r\n\r\n    function isMarketOrder(OrderParam memory orderParam) internal pure returns (bool) {\r\n        return uint8(orderParam.data[2]) == 1;\r\n    }\r\n\r\n    function isMarketBuy(OrderParam memory orderParam) internal pure returns (bool) {\r\n        return !isSell(orderParam) && isMarketOrder(orderParam);\r\n    }\r\n\r\n    function isMakerOnly(OrderParam memory orderParam) internal pure returns (bool) {\r\n        return uint8(orderParam.data[22]) == 1;\r\n    }\r\n\r\n    function isInversed(OrderParam memory orderParam) internal pure returns (bool) {\r\n        return uint8(orderParam.data[23]) == 1;\r\n    }\r\n\r\n    function side(OrderParam memory orderParam) internal pure returns (LibTypes.Side) {\r\n        return isSell(orderParam) ? LibTypes.Side.SHORT : LibTypes.Side.LONG;\r\n    }\r\n\r\n    function makerFeeRate(OrderParam memory orderParam) internal pure returns (int256) {\r\n        return int256(int16(bytes2(orderParam.data << (8 * 8)))).mul(LibMathSigned.WAD()).div(FEE_RATE_BASE);\r\n    }\r\n\r\n    function takerFeeRate(OrderParam memory orderParam) internal pure returns (int256) {\r\n        return int256(int16(bytes2(orderParam.data << (8 * 10)))).mul(LibMathSigned.WAD()).div(FEE_RATE_BASE);\r\n    }\r\n}\r\n\r\nlibrary LibTypes {\r\n    enum Side {FLAT, SHORT, LONG}\r\n\r\n    enum Status {NORMAL, SETTLING, SETTLED}\r\n\r\n    function counterSide(Side side) internal pure returns (Side) {\r\n        if (side == Side.LONG) {\r\n            return Side.SHORT;\r\n        } else if (side == Side.SHORT) {\r\n            return Side.LONG;\r\n        }\r\n        return side;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////\r\n    // Perpetual\r\n    //////////////////////////////////////////////////////////////////////////\r\n    struct PerpGovernanceConfig {\r\n        uint256 initialMarginRate;\r\n        uint256 maintenanceMarginRate;\r\n        uint256 liquidationPenaltyRate;\r\n        uint256 penaltyFundRate;\r\n        int256 takerDevFeeRate;\r\n        int256 makerDevFeeRate;\r\n        uint256 lotSize;\r\n        uint256 tradingLotSize;\r\n    }\r\n\r\n    // CollateralAccount represents cash account of user\r\n    struct CollateralAccount {\r\n        // currernt deposited erc20 token amount, representing in decimals 18\r\n        int256 balance;\r\n        // the amount of withdrawal applied by user\r\n        // which allowed to withdraw in the future but not available in trading\r\n        int256 appliedBalance;\r\n        // applied balance will be appled only when the block height below is reached\r\n        uint256 appliedHeight;\r\n    }\r\n\r\n    struct PositionAccount {\r\n        LibTypes.Side side;\r\n        uint256 size;\r\n        uint256 entryValue;\r\n        int256 entrySocialLoss;\r\n        int256 entryFundingLoss;\r\n    }\r\n\r\n    struct BrokerRecord {\r\n        address broker;\r\n        uint256 appliedHeight;\r\n    }\r\n\r\n    struct Broker {\r\n        BrokerRecord previous;\r\n        BrokerRecord current;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////\r\n    // AMM\r\n    //////////////////////////////////////////////////////////////////////////\r\n    struct AMMGovernanceConfig {\r\n        uint256 poolFeeRate;\r\n        uint256 poolDevFeeRate;\r\n        int256 emaAlpha;\r\n        uint256 updatePremiumPrize;\r\n        int256 markPremiumLimit;\r\n        int256 fundingDampener;\r\n    }\r\n\r\n    struct FundingState {\r\n        uint256 lastFundingTime;\r\n        int256 lastPremium;\r\n        int256 lastEMAPremium;\r\n        uint256 lastIndexPrice;\r\n        int256 accumulatedFundingPerContract;\r\n    }\r\n}\r\n\r\ncontract Collateral {\r\n    using LibMathSigned for int256;\r\n    using LibMathUnsigned for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    uint256 private constant MAX_DECIMALS = 18;\r\n    int256 private scaler;\r\n\r\n    address public collateral;\r\n    mapping(address => LibTypes.CollateralAccount) internal cashBalances;\r\n\r\n    event Deposit(address indexed guy, int256 wadAmount, int256 balance);\r\n    event Withdraw(address indexed guy, int256 wadAmount, int256 balance, int256 appliedBalance);\r\n    event ApplyForWithdrawal(address indexed guy, int256 wadAmount, uint256 appliedHeight);\r\n    event Transfer(address indexed from, address indexed to, int256 wadAmount, int256 balanceFrom, int256 balanceTo);\r\n    event InternalUpdateBalance(address indexed guy, int256 wadAmount, int256 balance);\r\n\r\n    constructor(address _collateral, uint256 decimals) public {\r\n        require(decimals <= MAX_DECIMALS, \"decimals out of range\");\r\n        require(_collateral != address(0x0) || (_collateral == address(0x0) && decimals == 18), \"invalid decimals\");\r\n\r\n        collateral = _collateral;\r\n        scaler = (decimals == MAX_DECIMALS ? 1 : 10**(MAX_DECIMALS - decimals)).toInt256();\r\n    }\r\n\r\n    // Public functions\r\n    function getCashBalance(address guy) public view returns (LibTypes.CollateralAccount memory) {\r\n        return cashBalances[guy];\r\n    }\r\n\r\n    // Internal functions\r\n    function isTokenizedCollateral() internal view returns (bool) {\r\n        return collateral != address(0x0);\r\n    }\r\n\r\n    function deposit(address guy, uint256 rawAmount) internal {\r\n        if (rawAmount == 0) {\r\n            return;\r\n        }\r\n        if (isTokenizedCollateral()) {\r\n            IERC20(collateral).safeTransferFrom(guy, address(this), rawAmount);\r\n        }\r\n        int256 wadAmount = toWad(rawAmount);\r\n        cashBalances[guy].balance = cashBalances[guy].balance.add(wadAmount);\r\n\r\n        emit Deposit(guy, wadAmount, cashBalances[guy].balance);\r\n    }\r\n\r\n    function applyForWithdrawal(address guy, uint256 rawAmount, uint256 delay) internal {\r\n        int256 wadAmount = toWad(rawAmount);\r\n        cashBalances[guy].appliedBalance = wadAmount;\r\n        cashBalances[guy].appliedHeight = block.number.add(delay);\r\n\r\n        emit ApplyForWithdrawal(guy, wadAmount, cashBalances[guy].appliedHeight);\r\n    }\r\n\r\n    function _withdraw(address payable guy, int256 wadAmount, bool forced) private {\r\n        require(wadAmount > 0, \"negtive amount\");\r\n        require(wadAmount <= cashBalances[guy].balance, \"insufficient balance\");\r\n        if (!forced) {\r\n            require(block.number >= cashBalances[guy].appliedHeight, \"applied height not reached\");\r\n            require(wadAmount <= cashBalances[guy].appliedBalance, \"insufficient applied balance\");\r\n            cashBalances[guy].appliedBalance = cashBalances[guy].appliedBalance.sub(wadAmount);\r\n        } else {\r\n            cashBalances[guy].appliedBalance = cashBalances[guy].appliedBalance.sub(\r\n                wadAmount.min(cashBalances[guy].appliedBalance)\r\n            );\r\n        }\r\n        cashBalances[guy].balance = cashBalances[guy].balance.sub(wadAmount);\r\n        uint256 rawAmount = toCollateral(wadAmount);\r\n        if (isTokenizedCollateral()) {\r\n            IERC20(collateral).safeTransfer(guy, rawAmount);\r\n        } else {\r\n            guy.transfer(rawAmount);\r\n        }\r\n        emit Withdraw(guy, wadAmount, cashBalances[guy].balance, cashBalances[guy].appliedBalance);\r\n    }\r\n\r\n    function withdraw(address payable guy, uint256 rawAmount, bool force) internal {\r\n        if (rawAmount == 0) {\r\n            return;\r\n        }\r\n        int256 wadAmount = toWad(rawAmount);\r\n        _withdraw(guy, wadAmount, force);\r\n    }\r\n\r\n    function depositToProtocol(address guy, uint256 rawAmount) internal returns (int256) {\r\n        if (rawAmount == 0) {\r\n            return 0;\r\n        }\r\n        if (isTokenizedCollateral()) {\r\n            IERC20(collateral).safeTransferFrom(guy, address(this), rawAmount);\r\n        }\r\n        return toWad(rawAmount);\r\n    }\r\n\r\n    function withdrawFromProtocol(address payable guy, uint256 rawAmount) internal returns (int256) {\r\n        if (rawAmount == 0) {\r\n            return 0;\r\n        }\r\n        if (isTokenizedCollateral()) {\r\n            IERC20(collateral).safeTransfer(guy, rawAmount);\r\n        } else {\r\n            guy.transfer(rawAmount);\r\n        }\r\n        return toWad(rawAmount);\r\n    }\r\n\r\n    function withdrawAll(address payable guy) internal {\r\n        if (cashBalances[guy].balance == 0) {\r\n            return;\r\n        }\r\n        require(cashBalances[guy].balance > 0, \"insufficient balance\");\r\n        _withdraw(guy, cashBalances[guy].balance, true);\r\n    }\r\n\r\n    function updateBalance(address guy, int256 wadAmount) internal {\r\n        cashBalances[guy].balance = cashBalances[guy].balance.add(wadAmount);\r\n        emit InternalUpdateBalance(guy, wadAmount, cashBalances[guy].balance);\r\n    }\r\n\r\n    // ensure balance >= 0\r\n    function ensurePositiveBalance(address guy) internal returns (uint256 loss) {\r\n        if (cashBalances[guy].balance < 0) {\r\n            loss = cashBalances[guy].balance.neg().toUint256();\r\n            cashBalances[guy].balance = 0;\r\n        }\r\n    }\r\n\r\n    function transferBalance(address from, address to, int256 wadAmount) internal {\r\n        if (wadAmount == 0) {\r\n            return;\r\n        }\r\n        require(wadAmount > 0, \"bug: invalid transfer amount\");\r\n\r\n        cashBalances[from].balance = cashBalances[from].balance.sub(wadAmount); // may be negative balance\r\n        cashBalances[to].balance = cashBalances[to].balance.add(wadAmount);\r\n\r\n        emit Transfer(from, to, wadAmount, cashBalances[from].balance, cashBalances[to].balance);\r\n    }\r\n\r\n    function toWad(uint256 rawAmount) private view returns (int256) {\r\n        return rawAmount.toInt256().mul(scaler);\r\n    }\r\n\r\n    function toCollateral(int256 wadAmount) private view returns (uint256) {\r\n        return wadAmount.div(scaler).toUint256();\r\n    }\r\n}\r\n\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\ncontract WhitelistAdminRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistAdminAdded(address indexed account);\r\n    event WhitelistAdminRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelistAdmins;\r\n\r\n    constructor () internal {\r\n        _addWhitelistAdmin(msg.sender);\r\n    }\r\n\r\n    modifier onlyWhitelistAdmin() {\r\n        require(isWhitelistAdmin(msg.sender), \"WhitelistAdminRole: caller does not have the WhitelistAdmin role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelistAdmin(address account) public view returns (bool) {\r\n        return _whitelistAdmins.has(account);\r\n    }\r\n\r\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\r\n        _addWhitelistAdmin(account);\r\n    }\r\n\r\n    function renounceWhitelistAdmin() public {\r\n        _removeWhitelistAdmin(msg.sender);\r\n    }\r\n\r\n    function _addWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.add(account);\r\n        emit WhitelistAdminAdded(account);\r\n    }\r\n\r\n    function _removeWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.remove(account);\r\n        emit WhitelistAdminRemoved(account);\r\n    }\r\n}\r\n\r\ncontract WhitelistedRole is WhitelistAdminRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistedAdded(address indexed account);\r\n    event WhitelistedRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelisteds;\r\n\r\n    modifier onlyWhitelisted() {\r\n        require(isWhitelisted(msg.sender), \"WhitelistedRole: caller does not have the Whitelisted role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelisted(address account) public view returns (bool) {\r\n        return _whitelisteds.has(account);\r\n    }\r\n\r\n    function addWhitelisted(address account) public onlyWhitelistAdmin {\r\n        _addWhitelisted(account);\r\n    }\r\n\r\n    function removeWhitelisted(address account) public onlyWhitelistAdmin {\r\n        _removeWhitelisted(account);\r\n    }\r\n\r\n    function renounceWhitelisted() public {\r\n        _removeWhitelisted(msg.sender);\r\n    }\r\n\r\n    function _addWhitelisted(address account) internal {\r\n        _whitelisteds.add(account);\r\n        emit WhitelistedAdded(account);\r\n    }\r\n\r\n    function _removeWhitelisted(address account) internal {\r\n        _whitelisteds.remove(account);\r\n        emit WhitelistedRemoved(account);\r\n    }\r\n}\r\n\r\ninterface IPerpetualProxy {\r\n    // a gas-optimized version of position*\r\n    struct PoolAccount {\r\n        uint256 positionSize;\r\n        uint256 positionEntryValue;\r\n        int256 cashBalance;\r\n        int256 socialLossPerContract;\r\n        int256 positionEntrySocialLoss;\r\n        int256 positionEntryFundingLoss;\r\n    }\r\n\r\n    function self() external view returns (address);\r\n\r\n    function perpetual() external view returns (address);\r\n\r\n    function devAddress() external view returns (address);\r\n\r\n    function currentBroker(address guy) external view returns (address);\r\n\r\n    function markPrice() external returns (uint256);\r\n\r\n    function settlementPrice() external view returns (uint256);\r\n\r\n    function availableMargin(address guy) external returns (int256);\r\n\r\n    function getPoolAccount() external view returns (PoolAccount memory pool);\r\n\r\n    function cashBalance() external view returns (int256);\r\n\r\n    function positionSize() external view returns (uint256);\r\n\r\n    function positionSide() external view returns (LibTypes.Side);\r\n\r\n    function positionEntryValue() external view returns (uint256);\r\n\r\n    function positionEntrySocialLoss() external view returns (int256);\r\n\r\n    function positionEntryFundingLoss() external view returns (int256);\r\n\r\n    // function isEmergency() external view returns (bool);\r\n\r\n    // function isGlobalSettled() external view returns (bool);\r\n\r\n    function status() external view returns (LibTypes.Status);\r\n\r\n    function socialLossPerContract(LibTypes.Side side) external view returns (int256);\r\n\r\n    function transferBalanceIn(address from, uint256 amount) external;\r\n\r\n    function transferBalanceOut(address to, uint256 amount) external;\r\n\r\n    function transferBalanceTo(address from, address to, uint256 amount) external;\r\n\r\n    function trade(address guy, LibTypes.Side side, uint256 price, uint256 amount) external returns (uint256);\r\n\r\n    function setBrokerFor(address guy, address broker) external;\r\n\r\n    function depositFor(address guy, uint256 amount) external;\r\n\r\n    function depositEtherFor(address guy) external payable;\r\n\r\n    function withdrawFor(address payable guy, uint256 amount) external;\r\n\r\n    function isSafe(address guy) external returns (bool);\r\n\r\n    function isSafeWithPrice(address guy, uint256 currentMarkPrice) external returns (bool);\r\n\r\n    function isProxySafe() external returns (bool);\r\n\r\n    function isProxySafeWithPrice(uint256 currentMarkPrice) external returns (bool);\r\n\r\n    function isIMSafe(address guy) external returns (bool);\r\n\r\n    function isIMSafeWithPrice(address guy, uint256 currentMarkPrice) external returns (bool);\r\n\r\n    function lotSize() external view returns (uint256);\r\n\r\n    function tradingLotSize() external view returns (uint256);\r\n}\r\n\r\ninterface IAMM {\r\n    function shareTokenAddress() external view returns (address);\r\n\r\n    function lastFundingState() external view returns (LibTypes.FundingState memory);\r\n\r\n    function getGovernance() external view returns (LibTypes.AMMGovernanceConfig memory);\r\n\r\n    function perpetualProxy() external view returns (IPerpetualProxy);\r\n\r\n    function currentMarkPrice() external returns (uint256);\r\n\r\n    function currentAvailableMargin() external returns (uint256);\r\n\r\n    function currentFairPrice() external returns (uint256);\r\n\r\n    function positionSize() external returns (uint256);\r\n\r\n    function currentAccumulatedFundingPerContract() external returns (int256);\r\n\r\n    function settleShare(uint256 shareAmount) external;\r\n\r\n    function buy(uint256 amount, uint256 limitPrice, uint256 deadline) external returns (uint256);\r\n\r\n    function sell(uint256 amount, uint256 limitPrice, uint256 deadline) external returns (uint256);\r\n\r\n    function buyFromWhitelisted(address trader, uint256 amount, uint256 limitPrice, uint256 deadline)\r\n        external\r\n        returns (uint256);\r\n\r\n    function sellFromWhitelisted(address trader, uint256 amount, uint256 limitPrice, uint256 deadline)\r\n        external\r\n        returns (uint256);\r\n\r\n    function buyFrom(address trader, uint256 amount, uint256 limitPrice, uint256 deadline) external returns (uint256);\r\n\r\n    function sellFrom(address trader, uint256 amount, uint256 limitPrice, uint256 deadline) external returns (uint256);\r\n}\r\n\r\ninterface IGlobalConfig {\r\n    function withdrawalLockBlockCount() external view returns (uint256);\r\n\r\n    function brokerLockBlockCount() external view returns (uint256);\r\n}\r\n\r\ncontract PerpetualGovernance is WhitelistedRole {\r\n    using LibMathSigned for int256;\r\n    using LibMathUnsigned for uint256;\r\n\r\n    IGlobalConfig public globalConfig;\r\n    IAMM public amm;\r\n    address public devAddress;\r\n\r\n    LibTypes.Status public status;\r\n    uint256 public settlementPrice;\r\n    LibTypes.PerpGovernanceConfig internal governance;\r\n    int256[3] internal socialLossPerContracts;\r\n\r\n    event BeginGlobalSettlement(uint256 price);\r\n    event UpdateGovernanceParameter(bytes32 indexed key, int256 value);\r\n    event UpdateGovernanceAddress(bytes32 indexed key, address value);\r\n\r\n    modifier ammRequired() {\r\n        require(address(amm) != address(0x0), \"no automated market maker\");\r\n        _;\r\n    }\r\n\r\n    function getGovernance() public view returns (LibTypes.PerpGovernanceConfig memory) {\r\n        return governance;\r\n    }\r\n\r\n    function setGovernanceParameter(bytes32 key, int256 value) public onlyWhitelistAdmin {\r\n        if (key == \"initialMarginRate\") {\r\n            governance.initialMarginRate = value.toUint256();\r\n            require(governance.initialMarginRate > 0, \"require im > 0\");\r\n            require(governance.initialMarginRate < 10**18, \"require im < 1\");\r\n            require(governance.maintenanceMarginRate < governance.initialMarginRate, \"require mm < im\");\r\n        } else if (key == \"maintenanceMarginRate\") {\r\n            governance.maintenanceMarginRate = value.toUint256();\r\n            require(governance.maintenanceMarginRate > 0, \"require mm > 0\");\r\n            require(governance.maintenanceMarginRate < governance.initialMarginRate, \"require mm < im\");\r\n            require(governance.liquidationPenaltyRate < governance.maintenanceMarginRate, \"require lpr < mm\");\r\n            require(governance.penaltyFundRate < governance.maintenanceMarginRate, \"require pfr < mm\");\r\n        } else if (key == \"liquidationPenaltyRate\") {\r\n            governance.liquidationPenaltyRate = value.toUint256();\r\n            require(governance.liquidationPenaltyRate < governance.maintenanceMarginRate, \"require lpr < mm\");\r\n        } else if (key == \"penaltyFundRate\") {\r\n            governance.penaltyFundRate = value.toUint256();\r\n            require(governance.penaltyFundRate < governance.maintenanceMarginRate, \"require pfr < mm\");\r\n        } else if (key == \"takerDevFeeRate\") {\r\n            governance.takerDevFeeRate = value;\r\n        } else if (key == \"makerDevFeeRate\") {\r\n            governance.makerDevFeeRate = value;\r\n        } else if (key == \"lotSize\") {\r\n            require(\r\n                governance.tradingLotSize == 0 || governance.tradingLotSize.mod(value.toUint256()) == 0,\r\n                \"require tls % ls == 0\"\r\n            );\r\n            governance.lotSize = value.toUint256();\r\n        } else if (key == \"tradingLotSize\") {\r\n            require(governance.lotSize == 0 || value.toUint256().mod(governance.lotSize) == 0, \"require tls % ls == 0\");\r\n            governance.tradingLotSize = value.toUint256();\r\n        } else if (key == \"longSocialLossPerContracts\") {\r\n            require(status == LibTypes.Status.SETTLING, \"wrong perpetual status\");\r\n            socialLossPerContracts[uint256(LibTypes.Side.LONG)] = value;\r\n        } else if (key == \"shortSocialLossPerContracts\") {\r\n            require(status == LibTypes.Status.SETTLING, \"wrong perpetual status\");\r\n            socialLossPerContracts[uint256(LibTypes.Side.SHORT)] = value;\r\n        } else {\r\n            revert(\"key not exists\");\r\n        }\r\n        emit UpdateGovernanceParameter(key, value);\r\n    }\r\n\r\n    function setGovernanceAddress(bytes32 key, address value) public onlyWhitelistAdmin {\r\n        require(value != address(0x0), \"invalid address\");\r\n        if (key == \"dev\") {\r\n            devAddress = value;\r\n        } else if (key == \"amm\") {\r\n            amm = IAMM(value);\r\n        } else if (key == \"globalConfig\") {\r\n            globalConfig = IGlobalConfig(value);\r\n        } else {\r\n            revert(\"key not exists\");\r\n        }\r\n        emit UpdateGovernanceAddress(key, value);\r\n    }\r\n\r\n    function beginGlobalSettlement(uint256 price) public onlyWhitelistAdmin {\r\n        require(status != LibTypes.Status.SETTLED, \"already settled\");\r\n        settlementPrice = price;\r\n        status = LibTypes.Status.SETTLING;\r\n        emit BeginGlobalSettlement(price);\r\n    }\r\n}\r\n\r\ncontract Position is Collateral, PerpetualGovernance {\r\n    using LibMathSigned for int256;\r\n    using LibMathUnsigned for uint256;\r\n    using LibTypes for LibTypes.Side;\r\n\r\n    int256 public insuranceFundBalance;\r\n    uint256[3] internal totalSizes;\r\n    mapping(address => LibTypes.PositionAccount) internal positions;\r\n\r\n    event SocialLoss(LibTypes.Side side, int256 newVal);\r\n    event UpdatePositionAccount(\r\n        address indexed guy,\r\n        LibTypes.PositionAccount account,\r\n        uint256 perpetualTotalSize,\r\n        uint256 price\r\n    );\r\n    event UpdateInsuranceFund(int256 newVal);\r\n\r\n    constructor(address collateral, uint256 collateralDecimals) public Collateral(collateral, collateralDecimals) {}\r\n\r\n    // Public functions\r\n    function socialLossPerContract(LibTypes.Side side) public view returns (int256) {\r\n        return socialLossPerContracts[uint256(side)];\r\n    }\r\n\r\n    function totalSize(LibTypes.Side side) public view returns (uint256) {\r\n        return totalSizes[uint256(side)];\r\n    }\r\n\r\n    function getPosition(address guy) public view returns (LibTypes.PositionAccount memory) {\r\n        return positions[guy];\r\n    }\r\n\r\n    function calculateLiquidateAmount(address guy, uint256 liquidationPrice) public returns (uint256) {\r\n        if (positions[guy].size == 0) {\r\n            return 0;\r\n        }\r\n        LibTypes.PositionAccount memory account = positions[guy];\r\n        int256 liquidationAmount = cashBalances[guy].balance.add(account.entrySocialLoss);\r\n        liquidationAmount = liquidationAmount.sub(marginWithPrice(guy, liquidationPrice).toInt256()).sub(\r\n            socialLossPerContract(account.side).wmul(account.size.toInt256())\r\n        );\r\n        int256 tmp = account\r\n            .entryValue\r\n            .toInt256()\r\n            .sub(account.entryFundingLoss)\r\n            .add(amm.currentAccumulatedFundingPerContract().wmul(account.size.toInt256()))\r\n            .sub(account.size.wmul(liquidationPrice).toInt256());\r\n        if (account.side == LibTypes.Side.LONG) {\r\n            liquidationAmount = liquidationAmount.sub(tmp);\r\n        } else if (account.side == LibTypes.Side.SHORT) {\r\n            liquidationAmount = liquidationAmount.add(tmp);\r\n        } else {\r\n            return 0;\r\n        }\r\n        int256 denominator = governance\r\n            .liquidationPenaltyRate\r\n            .add(governance.penaltyFundRate)\r\n            .toInt256()\r\n            .sub(governance.initialMarginRate.toInt256())\r\n            .wmul(liquidationPrice.toInt256());\r\n        liquidationAmount = liquidationAmount.wdiv(denominator);\r\n        liquidationAmount = liquidationAmount.max(0);\r\n        liquidationAmount = liquidationAmount.min(account.size.toInt256());\r\n        return liquidationAmount.toUint256();\r\n    }\r\n\r\n    // Internal functions\r\n    function addSocialLossPerContract(LibTypes.Side side, int256 amount) internal {\r\n        require(amount >= 0, \"negtive social loss\");\r\n        int256 newVal = socialLossPerContracts[uint256(side)].add(amount);\r\n        socialLossPerContracts[uint256(side)] = newVal;\r\n        emit SocialLoss(side, newVal);\r\n    }\r\n    function marginBalanceWithPrice(address guy, uint256 markPrice) internal returns (int256) {\r\n        return cashBalances[guy].balance.add(pnlWithPrice(guy, markPrice));\r\n    }\r\n\r\n    function availableMarginWithPrice(address guy, uint256 markPrice) internal returns (int256) {\r\n        int256 p = marginBalanceWithPrice(guy, markPrice);\r\n        p = p.sub(marginWithPrice(guy, markPrice).toInt256());\r\n        p = p.sub(cashBalances[guy].appliedBalance);\r\n        return p;\r\n    }\r\n\r\n    function marginWithPrice(address guy, uint256 markPrice) internal view returns (uint256) {\r\n        return positions[guy].size.wmul(markPrice).wmul(governance.initialMarginRate);\r\n    }\r\n\r\n    function maintenanceMarginWithPrice(address guy, uint256 markPrice) internal view returns (uint256) {\r\n        return positions[guy].size.wmul(markPrice).wmul(governance.maintenanceMarginRate);\r\n    }\r\n\r\n    function drawableBalanceWithPrice(address guy, uint256 markPrice) internal returns (int256) {\r\n        return\r\n            marginBalanceWithPrice(guy, markPrice).sub(marginWithPrice(guy, markPrice).toInt256()).min(\r\n                cashBalances[guy].appliedBalance\r\n            );\r\n    }\r\n\r\n    function pnlWithPrice(address guy, uint256 markPrice) internal returns (int256) {\r\n        LibTypes.PositionAccount memory account = positions[guy];\r\n        return calculatePnl(account, markPrice, account.size);\r\n    }\r\n\r\n    // Internal functions\r\n    function increaseTotalSize(LibTypes.Side side, uint256 amount) internal {\r\n        totalSizes[uint256(side)] = totalSizes[uint256(side)].add(amount);\r\n    }\r\n\r\n    function decreaseTotalSize(LibTypes.Side side, uint256 amount) internal {\r\n        totalSizes[uint256(side)] = totalSizes[uint256(side)].sub(amount);\r\n    }\r\n\r\n    function socialLoss(LibTypes.PositionAccount memory account) internal view returns (int256) {\r\n        return socialLossWithAmount(account, account.size);\r\n    }\r\n\r\n    function socialLossWithAmount(LibTypes.PositionAccount memory account, uint256 amount)\r\n        internal\r\n        view\r\n        returns (int256)\r\n    {\r\n        int256 loss = socialLossPerContract(account.side).wmul(amount.toInt256());\r\n        if (amount == account.size) {\r\n            loss = loss.sub(account.entrySocialLoss);\r\n        } else {\r\n            // loss = loss.sub(account.entrySocialLoss.wmul(amount).wdiv(account.size));\r\n            loss = loss.sub(account.entrySocialLoss.wfrac(amount.toInt256(), account.size.toInt256()));\r\n            // prec error\r\n            if (loss != 0) {\r\n                loss = loss.add(1);\r\n            }\r\n        }\r\n        return loss;\r\n    }\r\n\r\n    function fundingLoss(LibTypes.PositionAccount memory account) internal returns (int256) {\r\n        return fundingLossWithAmount(account, account.size);\r\n    }\r\n\r\n    function fundingLossWithAmount(LibTypes.PositionAccount memory account, uint256 amount) internal returns (int256) {\r\n        int256 loss = amm.currentAccumulatedFundingPerContract().wmul(amount.toInt256());\r\n        if (amount == account.size) {\r\n            loss = loss.sub(account.entryFundingLoss);\r\n        } else {\r\n            // loss = loss.sub(account.entryFundingLoss.wmul(amount.toInt256()).wdiv(account.size.toInt256()));\r\n            loss = loss.sub(account.entryFundingLoss.wfrac(amount.toInt256(), account.size.toInt256()));\r\n        }\r\n        if (account.side == LibTypes.Side.SHORT) {\r\n            loss = loss.neg();\r\n        }\r\n        if (loss != 0 && amount != account.size) {\r\n            loss = loss.add(1);\r\n        }\r\n        return loss;\r\n    }\r\n\r\n    function remargin(address guy, uint256 markPrice) internal {\r\n        LibTypes.PositionAccount storage account = positions[guy];\r\n        if (account.size == 0) {\r\n            return;\r\n        }\r\n        int256 rpnl = calculatePnl(account, markPrice, account.size);\r\n        account.entryValue = markPrice.wmul(account.size);\r\n        account.entrySocialLoss = socialLossPerContract(account.side).wmul(account.size.toInt256());\r\n        account.entryFundingLoss = amm.currentAccumulatedFundingPerContract().wmul(account.size.toInt256());\r\n        updateBalance(guy, rpnl);\r\n        emit UpdatePositionAccount(guy, account, totalSize(LibTypes.Side.LONG), markPrice);\r\n    }\r\n\r\n    function calculatePnl(LibTypes.PositionAccount memory account, uint256 tradePrice, uint256 amount)\r\n        internal\r\n        returns (int256)\r\n    {\r\n        if (account.size == 0) {\r\n            return 0;\r\n        }\r\n        int256 p1 = tradePrice.wmul(amount).toInt256();\r\n        int256 p2;\r\n        if (amount == account.size) {\r\n            p2 = account.entryValue.toInt256();\r\n        } else {\r\n            // p2 = account.entryValue.wmul(amount).wdiv(account.size).toInt256();\r\n            p2 = account.entryValue.wfrac(amount, account.size).toInt256();\r\n        }\r\n        int256 profit = account.side == LibTypes.Side.LONG ? p1.sub(p2) : p2.sub(p1);\r\n        // prec error\r\n        if (profit != 0) {\r\n            profit = profit.sub(1);\r\n        }\r\n        int256 loss1 = socialLossWithAmount(account, amount);\r\n        int256 loss2 = fundingLossWithAmount(account, amount);\r\n        return profit.sub(loss1).sub(loss2);\r\n    }\r\n\r\n    function open(LibTypes.PositionAccount memory account, LibTypes.Side side, uint256 price, uint256 amount) internal {\r\n        require(amount > 0, \"open: invald amount\");\r\n        if (account.size == 0) {\r\n            account.side = side;\r\n        }\r\n        account.size = account.size.add(amount);\r\n        account.entryValue = account.entryValue.add(price.wmul(amount));\r\n        account.entrySocialLoss = account.entrySocialLoss.add(socialLossPerContract(side).wmul(amount.toInt256()));\r\n        account.entryFundingLoss = account.entryFundingLoss.add(\r\n            amm.currentAccumulatedFundingPerContract().wmul(amount.toInt256())\r\n        );\r\n        increaseTotalSize(side, amount);\r\n    }\r\n\r\n    function close(LibTypes.PositionAccount memory account, uint256 price, uint256 amount) internal returns (int256) {\r\n        int256 rpnl = calculatePnl(account, price, amount);\r\n        account.entrySocialLoss = account.entrySocialLoss.wmul(account.size.sub(amount).toInt256()).wdiv(\r\n            account.size.toInt256()\r\n        );\r\n        account.entryFundingLoss = account.entryFundingLoss.wmul(account.size.sub(amount).toInt256()).wdiv(\r\n            account.size.toInt256()\r\n        );\r\n        account.entryValue = account.entryValue.wmul(account.size.sub(amount)).wdiv(account.size);\r\n        account.size = account.size.sub(amount);\r\n        decreaseTotalSize(account.side, amount);\r\n        if (account.size == 0) {\r\n            account.side = LibTypes.Side.FLAT;\r\n        }\r\n        return rpnl;\r\n    }\r\n\r\n    function trade(address guy, LibTypes.Side side, uint256 price, uint256 amount) internal returns (uint256) {\r\n        int256 rpnl;\r\n        uint256 opened = amount;\r\n        uint256 closed;\r\n        LibTypes.PositionAccount memory account = positions[guy];\r\n        if (account.size > 0 && account.side != side) {\r\n            closed = account.size.min(opened);\r\n            rpnl = close(account, price, closed);\r\n            opened = opened.sub(closed);\r\n        }\r\n        if (opened > 0) {\r\n            open(account, side, price, opened);\r\n        }\r\n        updateBalance(guy, rpnl);\r\n        positions[guy] = account;\r\n        emit UpdatePositionAccount(guy, account, totalSize(LibTypes.Side.LONG), price);\r\n        return opened;\r\n    }\r\n\r\n    function handleSocialLoss(LibTypes.Side side, int256 loss) internal {\r\n        int256 newSocialLoss = loss.wdiv(totalSize(side).toInt256());\r\n        addSocialLossPerContract(side, newSocialLoss);\r\n    }\r\n\r\n    function liquidate(address liquidator, address guy, uint256 liquidationPrice, uint256 liquidationAmount)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        // liquidiated trader\r\n        LibTypes.PositionAccount memory account = positions[guy];\r\n        LibTypes.Side liquidationSide = account.side;\r\n        uint256 liquidationValue = liquidationPrice.wmul(liquidationAmount);\r\n        int256 penaltyToLiquidator = governance.liquidationPenaltyRate.wmul(liquidationValue).toInt256();\r\n        int256 penaltyToFund = governance.penaltyFundRate.wmul(liquidationValue).toInt256();\r\n        int256 rpnl = close(account, liquidationPrice, liquidationAmount);\r\n        positions[guy] = account;\r\n        emit UpdatePositionAccount(guy, account, totalSize(LibTypes.Side.LONG), liquidationPrice);\r\n\r\n        rpnl = rpnl.sub(penaltyToLiquidator).sub(penaltyToFund);\r\n        updateBalance(guy, rpnl);\r\n        int256 liquidationLoss = ensurePositiveBalance(guy).toInt256();\r\n\r\n        // liquidator, penalty + poisition\r\n        updateBalance(liquidator, penaltyToLiquidator);\r\n        uint256 opened = trade(liquidator, liquidationSide, liquidationPrice, liquidationAmount);\r\n\r\n        // fund, fund penalty - possible social loss\r\n        insuranceFundBalance = insuranceFundBalance.add(penaltyToFund);\r\n        if (insuranceFundBalance >= liquidationLoss) {\r\n            insuranceFundBalance = insuranceFundBalance.sub(liquidationLoss);\r\n        } else {\r\n            int256 newSocialLoss = liquidationLoss.sub(insuranceFundBalance);\r\n            insuranceFundBalance = 0;\r\n            handleSocialLoss(liquidationSide, newSocialLoss);\r\n        }\r\n        require(insuranceFundBalance >= 0, \"negtive insurance fund\");\r\n\r\n        emit UpdateInsuranceFund(insuranceFundBalance);\r\n        return opened;\r\n    }\r\n}\r\n\r\ncontract Brokerage {\r\n    using LibMathUnsigned for uint256;\r\n\r\n    event BrokerUpdate(address indexed account, address indexed guy, uint256 appliedHeight);\r\n\r\n    mapping(address => LibTypes.Broker) public brokers;\r\n\r\n    // delay set: set the newBroker after n blocks (including the current block)\r\n    // rules:\r\n    // 1. new user => set immediately\r\n    // 2. last broker change is waiting for delay => overwrite the delayed broker and timer\r\n    // 3. last broker change has taken effect\r\n    // 3.1 newBroker is the same => ignore\r\n    // 3.2 newBroker is changing => push the current broker, set the delayed broker and timer\r\n    //\r\n    // delay: during this n blocks (including setBroker() itself), current broker does not change\r\n    function setBroker(address trader, address newBroker, uint256 delay) internal {\r\n        require(trader != address(0), \"invalid trader\");\r\n        require(newBroker != address(0), \"invalid guy\");\r\n        LibTypes.Broker memory broker = brokers[trader];\r\n        if (broker.current.appliedHeight == 0) {\r\n            // condition 1\r\n            broker.current.broker = newBroker;\r\n            broker.current.appliedHeight = block.number;\r\n        } else {\r\n            bool isPreviousChangeApplied = block.number >= broker.current.appliedHeight;\r\n            if (isPreviousChangeApplied) {\r\n                if (broker.current.broker == newBroker) {\r\n                    // condition 3.1\r\n                    return;\r\n                } else {\r\n                    // condition 3.2\r\n                    broker.previous.broker = broker.current.broker;\r\n                    broker.previous.appliedHeight = broker.current.appliedHeight;\r\n                }\r\n            }\r\n            // condition 2, 3.2\r\n            broker.current.broker = newBroker;\r\n            broker.current.appliedHeight = block.number.add(delay);\r\n        }\r\n        // condition 1, 2, 3.2\r\n        brokers[trader] = broker;\r\n        emit BrokerUpdate(trader, newBroker, broker.current.appliedHeight);\r\n    }\r\n\r\n    // note: do NOT call this function in a non-transaction request, unless you do not care about the broker appliedHeight.\r\n    // because in a call(), block.number is the on-chain height, and it will be 1 more in a transaction\r\n    function currentBroker(address trader) public view returns (address) {\r\n        LibTypes.Broker storage broker = brokers[trader];\r\n        return block.number >= broker.current.appliedHeight ? broker.current.broker : broker.previous.broker;\r\n    }\r\n\r\n    function getBroker(address trader) public view returns (LibTypes.Broker memory) {\r\n        return brokers[trader];\r\n    }\r\n}\r\n\r\ninterface IPriceFeeder {\r\n    function price() external view returns (uint256 lastPrice, uint256 lastTimestamp);\r\n}\r\n\r\ncontract Perpetual is Brokerage, Position {\r\n    using LibMathSigned for int256;\r\n    using LibMathUnsigned for uint256;\r\n    using LibOrder for LibTypes.Side;\r\n    using SafeERC20 for IERC20;\r\n    uint256 public totalAccounts;\r\n    address[] public accountList;\r\n    mapping(address => bool) private accountCreated;\r\n\r\n    event CreatePerpetual();\r\n    event CreateAccount(uint256 indexed id, address indexed guy);\r\n    event Buy(address indexed guy, uint256 price, uint256 amount);\r\n    event Sell(address indexed guy, uint256 price, uint256 amount);\r\n    event Liquidate(address indexed keeper, address indexed guy, uint256 price, uint256 amount);\r\n    event EndGlobalSettlement();\r\n\r\n    constructor(address globalConfig, address devAddress, address collateral, uint256 collateralDecimals)\r\n        public\r\n        Position(collateral, collateralDecimals)\r\n    {\r\n        setGovernanceAddress(\"globalConfig\", globalConfig);\r\n        setGovernanceAddress(\"dev\", devAddress);\r\n        emit CreatePerpetual();\r\n    }\r\n\r\n    // Admin functions\r\n    function setCashBalance(address guy, int256 amount) public onlyWhitelistAdmin {\r\n        require(status == LibTypes.Status.SETTLING, \"wrong perpetual status\");\r\n        int256 deltaAmount = amount.sub(cashBalances[guy].balance);\r\n        cashBalances[guy].balance = amount;\r\n        emit InternalUpdateBalance(guy, deltaAmount, amount);\r\n    }\r\n\r\n    // Public functions\r\n    function() external payable {\r\n        revert(\"no payable\");\r\n    }\r\n\r\n    function markPrice() public ammRequired returns (uint256) {\r\n        return status == LibTypes.Status.NORMAL ? amm.currentMarkPrice() : settlementPrice;\r\n    }\r\n\r\n    function setBroker(address broker) public {\r\n        setBroker(msg.sender, broker, globalConfig.brokerLockBlockCount());\r\n    }\r\n\r\n    function setBrokerFor(address guy, address broker) public onlyWhitelisted {\r\n        setBroker(guy, broker, globalConfig.brokerLockBlockCount());\r\n    }\r\n\r\n    function depositToAccount(address guy, uint256 amount) private {\r\n        require(guy != address(0), \"invalid guy\");\r\n        deposit(guy, amount);\r\n\r\n        // append to the account list. make the account trackable\r\n        if (!accountCreated[guy]) {\r\n            emit CreateAccount(totalAccounts, guy);\r\n            accountList.push(guy);\r\n            totalAccounts++;\r\n            accountCreated[guy] = true;\r\n        }\r\n    }\r\n\r\n    function depositFor(address guy, uint256 amount) public onlyWhitelisted {\r\n        require(isTokenizedCollateral(), \"ether not acceptable\");\r\n\r\n        depositToAccount(guy, amount);\r\n    }\r\n\r\n    function depositEtherFor(address guy) public payable onlyWhitelisted {\r\n        require(!isTokenizedCollateral(), \"token not acceptable\");\r\n\r\n        depositToAccount(guy, msg.value);\r\n    }\r\n\r\n    function deposit(uint256 amount) public {\r\n        require(isTokenizedCollateral(), \"ether not acceptable\");\r\n\r\n        depositToAccount(msg.sender, amount);\r\n    }\r\n\r\n    function depositEther() public payable {\r\n        require(!isTokenizedCollateral(), \"token not acceptable\");\r\n\r\n        depositToAccount(msg.sender, msg.value);\r\n    }\r\n\r\n    // this is a composite function of perp.deposit + perp.setBroker\r\n    // composite functions accept amount = 0\r\n    function depositAndSetBroker(uint256 amount, address broker) public {\r\n        setBroker(broker);\r\n        if (amount > 0) {\r\n            deposit(amount);\r\n        }\r\n    }\r\n\r\n    // this is a composite function of perp.deposit + perp.setBroker\r\n    // composite functions accept amount = 0\r\n    function depositEtherAndSetBroker(address broker) public payable {\r\n        setBroker(broker);\r\n        if (msg.value > 0) {\r\n            depositEther();\r\n        }\r\n    }\r\n\r\n    function applyForWithdrawal(uint256 amount) public {\r\n        applyForWithdrawal(msg.sender, amount, globalConfig.withdrawalLockBlockCount());\r\n    }\r\n\r\n    function settleFor(address guy) private {\r\n        uint256 currentMarkPrice = markPrice();\r\n        LibTypes.PositionAccount memory account = positions[guy];\r\n        if (account.size > 0) {\r\n            int256 pnl = close(account, currentMarkPrice, account.size);\r\n            updateBalance(guy, pnl);\r\n            positions[guy] = account;\r\n        }\r\n        emit UpdatePositionAccount(guy, account, totalSize(LibTypes.Side.LONG), currentMarkPrice);\r\n    }\r\n\r\n    function settle() public {\r\n        require(status == LibTypes.Status.SETTLED, \"wrong perpetual status\");\r\n\r\n        address payable guy = msg.sender;\r\n        settleFor(guy);\r\n        withdrawAll(guy);\r\n    }\r\n\r\n    function endGlobalSettlement() public onlyWhitelistAdmin {\r\n        require(status == LibTypes.Status.SETTLING, \"wrong perpetual status\");\r\n\r\n        address guy = address(amm.perpetualProxy());\r\n        settleFor(guy);\r\n        status = LibTypes.Status.SETTLED;\r\n\r\n        emit EndGlobalSettlement();\r\n    }\r\n\r\n    function withdrawFromAccount(address payable guy, uint256 amount) private {\r\n        require(guy != address(0), \"invalid guy\");\r\n        require(status != LibTypes.Status.SETTLING, \"wrong perpetual status\");\r\n\r\n        uint256 currentMarkPrice = markPrice();\r\n        require(isSafeWithPrice(guy, currentMarkPrice), \"unsafe before withdraw\");\r\n        remargin(guy, currentMarkPrice);\r\n        address broker = currentBroker(guy);\r\n        bool forced = broker == address(amm.perpetualProxy()) || broker == address(0);\r\n        withdraw(guy, amount, forced);\r\n\r\n        require(isSafeWithPrice(guy, currentMarkPrice), \"unsafe after withdraw\");\r\n        require(availableMarginWithPrice(guy, currentMarkPrice) >= 0, \"withdraw margin\");\r\n    }\r\n\r\n    function withdrawFor(address payable guy, uint256 amount) public onlyWhitelisted {\r\n        require(status == LibTypes.Status.NORMAL, \"wrong perpetual status\");\r\n        withdrawFromAccount(guy, amount);\r\n    }\r\n\r\n    function withdraw(uint256 amount) public {\r\n        withdrawFromAccount(msg.sender, amount);\r\n    }\r\n\r\n    function depositToInsuranceFund(uint256 rawAmount) public {\r\n        require(isTokenizedCollateral(), \"ether not acceptable\");\r\n        require(rawAmount > 0, \"invalid amount\");\r\n\r\n        int256 wadAmount = depositToProtocol(msg.sender, rawAmount);\r\n        insuranceFundBalance = insuranceFundBalance.add(wadAmount);\r\n\r\n        require(insuranceFundBalance >= 0, \"negtive insurance fund\");\r\n\r\n        emit UpdateInsuranceFund(insuranceFundBalance);\r\n    }\r\n\r\n    function depositEtherToInsuranceFund() public payable {\r\n        require(!isTokenizedCollateral(), \"token not acceptable\");\r\n        require(msg.value > 0, \"invalid amount\");\r\n\r\n        int256 wadAmount = depositToProtocol(msg.sender, msg.value);\r\n        insuranceFundBalance = insuranceFundBalance.add(wadAmount);\r\n\r\n        require(insuranceFundBalance >= 0, \"negtive insurance fund\");\r\n\r\n        emit UpdateInsuranceFund(insuranceFundBalance);\r\n    }\r\n\r\n    function withdrawFromInsuranceFund(uint256 rawAmount) public onlyWhitelistAdmin {\r\n        require(rawAmount > 0, \"invalid amount\");\r\n        require(insuranceFundBalance > 0, \"insufficient funds\");\r\n        require(rawAmount.toInt256() <= insuranceFundBalance, \"insufficient funds\");\r\n\r\n        int256 wadAmount = withdrawFromProtocol(msg.sender, rawAmount);\r\n        insuranceFundBalance = insuranceFundBalance.sub(wadAmount);\r\n\r\n        require(insuranceFundBalance >= 0, \"negtive insurance fund\");\r\n\r\n        emit UpdateInsuranceFund(insuranceFundBalance);\r\n    }\r\n\r\n    function positionMargin(address guy) public returns (uint256) {\r\n        return Position.marginWithPrice(guy, markPrice());\r\n    }\r\n\r\n    function maintenanceMargin(address guy) public returns (uint256) {\r\n        return maintenanceMarginWithPrice(guy, markPrice());\r\n    }\r\n\r\n    function marginBalance(address guy) public returns (int256) {\r\n        return marginBalanceWithPrice(guy, markPrice());\r\n    }\r\n\r\n    function pnl(address guy) public returns (int256) {\r\n        return pnlWithPrice(guy, markPrice());\r\n    }\r\n\r\n    function availableMargin(address guy) public returns (int256) {\r\n        return availableMarginWithPrice(guy, markPrice());\r\n    }\r\n\r\n    function drawableBalance(address guy) public returns (int256) {\r\n        return drawableBalanceWithPrice(guy, markPrice());\r\n    }\r\n\r\n    // safe for liquidation\r\n    function isSafe(address guy) public returns (bool) {\r\n        uint256 currentMarkPrice = markPrice();\r\n        return isSafeWithPrice(guy, currentMarkPrice);\r\n    }\r\n\r\n    // safe for liquidation\r\n    function isSafeWithPrice(address guy, uint256 currentMarkPrice) public returns (bool) {\r\n        return\r\n            marginBalanceWithPrice(guy, currentMarkPrice) >=\r\n            maintenanceMarginWithPrice(guy, currentMarkPrice).toInt256();\r\n    }\r\n\r\n    function isBankrupt(address guy) public returns (bool) {\r\n        return marginBalanceWithPrice(guy, markPrice()) < 0;\r\n    }\r\n\r\n    // safe for opening positions\r\n    function isIMSafe(address guy) public returns (bool) {\r\n        uint256 currentMarkPrice = markPrice();\r\n        return isIMSafeWithPrice(guy, currentMarkPrice);\r\n    }\r\n\r\n    // safe for opening positions\r\n    function isIMSafeWithPrice(address guy, uint256 currentMarkPrice) public returns (bool) {\r\n        return availableMarginWithPrice(guy, currentMarkPrice) >= 0;\r\n    }\r\n\r\n    function liquidateFrom(address from, address guy, uint256 maxAmount) public returns (uint256, uint256) {\r\n        require(maxAmount.mod(governance.lotSize) == 0, \"invalid lot size\");\r\n        require(!isSafe(guy), \"safe account\");\r\n\r\n        uint256 liquidationPrice = markPrice();\r\n        uint256 liquidationAmount = calculateLiquidateAmount(guy, liquidationPrice);\r\n        uint256 totalPositionSize = positions[guy].size;\r\n        uint256 liquidatableAmount = totalPositionSize.sub(totalPositionSize.mod(governance.lotSize));\r\n        liquidationAmount = liquidationAmount.ceil(governance.lotSize).min(maxAmount).min(liquidatableAmount);\r\n        require(liquidationAmount > 0, \"nothing to liquidate\");\r\n\r\n        uint256 opened = liquidate(from, guy, liquidationPrice, liquidationAmount);\r\n        if (opened > 0) {\r\n            require(availableMarginWithPrice(from, liquidationPrice) >= 0, \"liquidator margin\");\r\n        } else {\r\n            require(isSafe(from), \"liquidator unsafe\");\r\n        }\r\n\r\n        emit Liquidate(from, guy, liquidationPrice, liquidationAmount);\r\n    }\r\n\r\n    function liquidate(address guy, uint256 maxAmount) public returns (uint256, uint256) {\r\n        require(status != LibTypes.Status.SETTLED, \"wrong perpetual status\");\r\n        return liquidateFrom(msg.sender, guy, maxAmount);\r\n    }\r\n\r\n    function tradePosition(address trader, LibTypes.Side side, uint256 price, uint256 amount)\r\n        public\r\n        onlyWhitelisted\r\n        returns (uint256)\r\n    {\r\n        require(status != LibTypes.Status.SETTLING, \"wrong perpetual status\");\r\n        require(side == LibTypes.Side.LONG || side == LibTypes.Side.SHORT, \"invalid side\");\r\n\r\n        uint256 opened = Position.trade(trader, side, price, amount);\r\n        if (side == LibTypes.Side.LONG) {\r\n            emit Buy(trader, price, amount);\r\n        } else if (side == LibTypes.Side.SHORT) {\r\n            emit Sell(trader, price, amount);\r\n        }\r\n        return opened;\r\n    }\r\n\r\n    function transferCashBalance(address from, address to, uint256 amount) public onlyWhitelisted {\r\n        require(status != LibTypes.Status.SETTLING, \"wrong perpetual status\");\r\n        transferBalance(from, to, amount.toInt256());\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"depositEtherToInsuranceFund\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"guy\",\"type\":\"address\"},{\"name\":\"maxAmount\",\"type\":\"uint256\"}],\"name\":\"liquidateFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"settle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"getPosition\",\"outputs\":[{\"components\":[{\"name\":\"side\",\"type\":\"uint8\"},{\"name\":\"size\",\"type\":\"uint256\"},{\"name\":\"entryValue\",\"type\":\"uint256\"},{\"name\":\"entrySocialLoss\",\"type\":\"int256\"},{\"name\":\"entryFundingLoss\",\"type\":\"int256\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setGovernanceAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"positionMargin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"getCashBalance\",\"outputs\":[{\"components\":[{\"name\":\"balance\",\"type\":\"int256\"},{\"name\":\"appliedBalance\",\"type\":\"int256\"},{\"name\":\"appliedHeight\",\"type\":\"uint256\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGovernance\",\"outputs\":[{\"components\":[{\"name\":\"initialMarginRate\",\"type\":\"uint256\"},{\"name\":\"maintenanceMarginRate\",\"type\":\"uint256\"},{\"name\":\"liquidationPenaltyRate\",\"type\":\"uint256\"},{\"name\":\"penaltyFundRate\",\"type\":\"uint256\"},{\"name\":\"takerDevFeeRate\",\"type\":\"int256\"},{\"name\":\"makerDevFeeRate\",\"type\":\"int256\"},{\"name\":\"lotSize\",\"type\":\"uint256\"},{\"name\":\"tradingLotSize\",\"type\":\"uint256\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amm\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"pnl\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"drawableBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"insuranceFundBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"markPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"trader\",\"type\":\"address\"}],\"name\":\"currentBroker\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rawAmount\",\"type\":\"uint256\"}],\"name\":\"depositToInsuranceFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"depositEtherFor\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAccounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"maintenanceMargin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"brokers\",\"outputs\":[{\"components\":[{\"name\":\"broker\",\"type\":\"address\"},{\"name\":\"appliedHeight\",\"type\":\"uint256\"}],\"name\":\"previous\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"broker\",\"type\":\"address\"},{\"name\":\"appliedHeight\",\"type\":\"uint256\"}],\"name\":\"current\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"},{\"name\":\"broker\",\"type\":\"address\"}],\"name\":\"setBrokerFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"availableMargin\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"isSafe\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endGlobalSettlement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"isBankrupt\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"},{\"name\":\"liquidationPrice\",\"type\":\"uint256\"}],\"name\":\"calculateLiquidateAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"broker\",\"type\":\"address\"}],\"name\":\"depositEtherAndSetBroker\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"applyForWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferCashBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"side\",\"type\":\"uint8\"}],\"name\":\"socialLossPerContract\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalConfig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"int256\"}],\"name\":\"setGovernanceParameter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"isIMSafe\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"side\",\"type\":\"uint8\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"tradePosition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"broker\",\"type\":\"address\"}],\"name\":\"depositAndSetBroker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromInsuranceFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelistAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"},{\"name\":\"maxAmount\",\"type\":\"uint256\"}],\"name\":\"liquidate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"broker\",\"type\":\"address\"}],\"name\":\"setBroker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"int256\"}],\"name\":\"setCashBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"trader\",\"type\":\"address\"}],\"name\":\"getBroker\",\"outputs\":[{\"components\":[{\"components\":[{\"name\":\"broker\",\"type\":\"address\"},{\"name\":\"appliedHeight\",\"type\":\"uint256\"}],\"name\":\"previous\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"broker\",\"type\":\"address\"},{\"name\":\"appliedHeight\",\"type\":\"uint256\"}],\"name\":\"current\",\"type\":\"tuple\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collateral\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"side\",\"type\":\"uint8\"}],\"name\":\"totalSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"beginGlobalSettlement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"marginBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settlementPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"},{\"name\":\"currentMarkPrice\",\"type\":\"uint256\"}],\"name\":\"isIMSafeWithPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"},{\"name\":\"currentMarkPrice\",\"type\":\"uint256\"}],\"name\":\"isSafeWithPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"globalConfig\",\"type\":\"address\"},{\"name\":\"devAddress\",\"type\":\"address\"},{\"name\":\"collateral\",\"type\":\"address\"},{\"name\":\"collateralDecimals\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CreatePerpetual\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"CreateAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Liquidate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EndGlobalSettlement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"side\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"newVal\",\"type\":\"int256\"}],\"name\":\"SocialLoss\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"},{\"components\":[{\"name\":\"side\",\"type\":\"uint8\"},{\"name\":\"size\",\"type\":\"uint256\"},{\"name\":\"entryValue\",\"type\":\"uint256\"},{\"name\":\"entrySocialLoss\",\"type\":\"int256\"},{\"name\":\"entryFundingLoss\",\"type\":\"int256\"}],\"indexed\":false,\"name\":\"account\",\"type\":\"tuple\"},{\"indexed\":false,\"name\":\"perpetualTotalSize\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"UpdatePositionAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newVal\",\"type\":\"int256\"}],\"name\":\"UpdateInsuranceFund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"BeginGlobalSettlement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"int256\"}],\"name\":\"UpdateGovernanceParameter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"address\"}],\"name\":\"UpdateGovernanceAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistedAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistedRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wadAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"int256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wadAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"appliedBalance\",\"type\":\"int256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wadAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"appliedHeight\",\"type\":\"uint256\"}],\"name\":\"ApplyForWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wadAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"balanceFrom\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"balanceTo\",\"type\":\"int256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wadAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"int256\"}],\"name\":\"InternalUpdateBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"appliedHeight\",\"type\":\"uint256\"}],\"name\":\"BrokerUpdate\",\"type\":\"event\"}]","ContractName":"Perpetual","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"00000000000000000000000077c073a91b53b35382c7c4cdf4079b7e312d552d000000000000000000000000904b5993fc92979eeedc19ccc58bed6b7216667c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012","Library":"","LicenseType":"None","SwarmSource":"bzzr://800293bd4c057ed94285a8649e0fde7117bf5f331ccc2b0d788b57721af8b409"}]}