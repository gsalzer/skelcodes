{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11;\r\n/* =========================================================================================================*/\r\n// ----------------------------------------------------------------------------\r\n// 'JOLT' token contract\r\n//\r\n// Symbol      : JOLT\r\n// Name        : JOLT\r\n// Total supply: 1500000000\r\n// Decimals    : 18\r\n// ----------------------------------------------------------------------------\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address payable public owner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    function transferOwnership(address payable _newOwner) public onlyOwner{\r\n        require(_newOwner != address(0), \"Owned: new owner is the zero address\");\r\n        owner = _newOwner;\r\n    }\r\n\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20Interface {\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address tokenOwner) public view returns (uint256 balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint256 remaining);\r\n    function transfer(address to, uint256 tokens) public returns (bool success);\r\n    function approve(address spender, uint256 tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint256 tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20 Token, with the addition of symbol, name and decimals and assisted\r\n// token transfers\r\n// ----------------------------------------------------------------------------\r\ncontract JOLT is ERC20Interface, Owned {\r\n    using SafeMath for uint;\r\n    \r\n    string public symbol = \"JOLT\";\r\n    string public  name = \"JOLT\";\r\n    uint8 public decimals = 18;\r\n    uint256 private _totalSupply = 15e8 * 10 ** uint(decimals); //1 500 000 000 \r\n    uint256 private _saleTokens = 75e7 * 10 **uint(decimals); // 750 million\r\n    uint256 private _teamReserves = 45e7 * 10 **uint(decimals); //450,000,000\r\n    uint256 private _advisorsReserves = 75e6 * 10**uint(decimals); //75,000,000\r\n    uint256 private _ecosystemReserves = 225e6 * 10**uint(decimals); //225,000,000\r\n    uint256 private _privateSaleReserves = 5e8 * 10**uint(decimals); //500,000,000\r\n    uint256 private _preSale1Reserves = 1e7 * 10**uint(decimals); //10,000,000\r\n    uint256 private _preSale2Reserves = 15e6 * 10**uint(decimals); //15,000,000\r\n    uint256 private _preSale3Reserves = 25e6 * 10**uint(decimals); //25,000,000\r\n    uint256 private _ICOReserves = 2e8 * 10**uint(decimals); //200,000,000\r\n    uint256 private _saleAllocations = 0 ;\r\n    uint256 private _teamAllocations = 0;\r\n    uint256 private _advisorsAllocations = 0;\r\n    uint private _startDate; //the date of deployment of contract\r\n    uint public stage = 0; // stage of sale (0 = private sale, 1= pre-sale1, 2= pre-sale2, 3= pre-sale3, 4= ICO, 100= none)\r\n    bool private lock = true; // all transfers are locked by default\r\n    address public ecosystemHolder;\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n    mapping (address => Allocation) allocated; // keeps record of allocations made both of tokens and bonuses for vesting\r\n    \r\n    struct Allocation{\r\n        uint256 bonus;\r\n        uint256 claimedBonus;\r\n        uint stage;\r\n        uint256 tokens;\r\n        uint256 claimedTokens;\r\n        uint category; // (1 = teams, 2 = advisors, 3 = angel investors);\r\n    }\r\n    \r\n    modifier whileOpen{\r\n        require(stage != 100, \"Sale is closed\"); // while stage is not none\r\n        _;\r\n    }\r\n    \r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    constructor(address payable _owner, address _ecosystem) public {\r\n        _startDate = now;\r\n        owner = address(_owner);\r\n        ecosystemHolder = address(_ecosystem);\r\n        balances[address(ecosystemHolder)] = _ecosystemReserves;\r\n        emit Transfer(address(0), address(ecosystemHolder), _ecosystemReserves);\r\n        balances[address(this)] = totalSupply() - _ecosystemReserves;\r\n        emit Transfer(address(0),address(this), totalSupply() - _ecosystemReserves);\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Don't accept ETHs\r\n    // ------------------------------------------------------------------------\r\n    function () external payable {\r\n        revert();\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Start pre sale 1\r\n    // - only allowed by Owner\r\n    // ------------------------------------------------------------------------\r\n    function startPreSale1() public onlyOwner{\r\n        stage = 1;\r\n        _saleAllocations = 0;\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Start pre sale 2\r\n    // - only allowed by Owner\r\n    // ------------------------------------------------------------------------\r\n    function startPreSale2() public onlyOwner{\r\n        stage = 2;\r\n        _saleAllocations = 0;\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Start pre sale 3\r\n    // - only allowed by Owner\r\n    // ------------------------------------------------------------------------\r\n    function startPreSale3() public onlyOwner{\r\n        stage = 3;\r\n        _saleAllocations = 0;\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Start ICO \r\n    // - only allowed by Owner\r\n    // ------------------------------------------------------------------------\r\n    function startICO() public onlyOwner{\r\n        stage = 4;\r\n        _saleAllocations = 0;\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Stop current sale\r\n    // - only allowed by Owner\r\n    // ------------------------------------------------------------------------\r\n    function stopSales() public onlyOwner{\r\n        stage = 100;\r\n        _saleAllocations = 0;\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Unlock tokens transfer for all \r\n    // - only allowed by Owner\r\n    // ------------------------------------------------------------------------\r\n    function unLockTokens() public onlyOwner{\r\n        lock = false;\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Lock tokens transfer for all\r\n    // - only allowed by Owner\r\n    // ------------------------------------------------------------------------\r\n    function LockTokens() public onlyOwner{\r\n        lock = true;\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Donations to be made to `_receiver` address\r\n    // - only allowed by Owner\r\n    // - input params: @ `_receiver` address\r\n    //  @ `_tokens` amount of tokens to send\r\n    //  @ `_category` category to which the _receiver belongs (1 = teams, 2 = advisors, 3 = angel investors);\r\n    // ------------------------------------------------------------------------\r\n    function donations(address _receiver, uint256 _tokens, uint _category) public onlyOwner{\r\n        require(_receiver != address(0), \"address should not be zero\");\r\n        require(_tokens != 0, \"tokens should not be zero\");\r\n        require(_category ==1 || _category == 2 || _category == 3, \"category must be 1 for teams, 2 for advisors, 3 for angel investors\");\r\n        preValidateTokens(_tokens, _category);\r\n        allocated[_receiver].tokens = allocated[_receiver].tokens.add(_tokens);\r\n        allocated[_receiver].claimedTokens = allocated[_receiver].claimedTokens;\r\n        allocated[_receiver].category = _category;\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Multi Address Allocation\r\n    // - only allowed by Owner\r\n    // -  this will allow to allocate tokens to purchasers in each sale\r\n    // - input params: @ `_addresses` list of purchaser's addresses\r\n    //  @ `_tokens` list of amount of tokens to send to each, respectively\r\n    // ------------------------------------------------------------------------\r\n    function multiTokenAllocation(address[] memory _addresses, uint256[] memory _tokens) public onlyOwner{\r\n        require(_addresses.length == _tokens.length, \"list of addresses and tokens must be same in size\");\r\n        require(_addresses.length <= 80, \"addresses list should not be greater than 80\");\r\n        for(uint i=0; i<_addresses.length; i++)\r\n            tokenAllocation(_addresses[i], _tokens[i]);\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // internal function to perform allocations on behalf of multiTokenAllocation\r\n    // ------------------------------------------------------------------------\r\n    function tokenAllocation(address _beneficiary, uint256 _tokens) public onlyOwner{\r\n        require(_beneficiary != address(0), \"address should not be zero\");\r\n        require(_tokens != 0, \"tokens should not be zero\");\r\n        uint256 _bonus = _calculateBonus(_tokens);\r\n        preValidateBonus(_tokens.add(_bonus));\r\n        _transfer(_beneficiary, _tokens);\r\n        allocated[_beneficiary].bonus = allocated[_beneficiary].bonus.add(_bonus);\r\n        allocated[_beneficiary].claimedBonus = allocated[_beneficiary].claimedBonus;\r\n        allocated[_beneficiary].stage = stage;\r\n        _saleAllocations = _saleAllocations.add(_tokens);\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // internal function to calculate bonus for each purchaser, depending on its sale stage\r\n    // ------------------------------------------------------------------------\r\n    function _calculateBonus(uint256 _tokens) internal view returns (uint256){\r\n        if(stage == 0){\r\n            return (50 * _tokens * 100) / 10000;\r\n        } else if(stage == 1){\r\n            return (20 * _tokens * 100) / 10000;\r\n        } else if(stage == 2){\r\n            return (15 * _tokens * 100) / 10000;\r\n        } else if(stage == 3){\r\n            return (10 * _tokens * 100) / 10000;\r\n        } else {return 0;}\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // internal function to validate that tokens should not be allocated \r\n    // more than the reserves of each sale\r\n    // ------------------------------------------------------------------------\r\n    function preValidateBonus(uint256 _tokens) private view{\r\n        if(stage == 0){\r\n            require (_tokens <=  _privateSaleReserves.sub(_saleAllocations), \"reduce number of tokens, exceeding private sale reserves\");\r\n        } else if(stage == 1){\r\n            require (_tokens <=  _preSale1Reserves.sub(_saleAllocations), \"reduce number of tokens, exceeding pre sale 1 reserves\");\r\n        } else if(stage == 2){\r\n            require (_tokens <=  _preSale2Reserves.sub(_saleAllocations), \"reduce number of tokens, exceeding pre sale 2 reserves\");\r\n        } else if(stage == 3){\r\n            require (_tokens <=  _preSale3Reserves.sub(_saleAllocations), \"reduce number of tokens, exceeding pre sale 3 reserves\");\r\n        } else if(stage == 4) {\r\n            require (_tokens <=  _ICOReserves.sub(_saleAllocations), \"reduce number of tokens, exceeding ICO sale reserves\");\r\n        }\r\n        else {\r\n            revert();\r\n        }\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // internal function to validate that tokens should not be allocated \r\n    // more than the reserves of each category\r\n    // ------------------------------------------------------------------------\r\n    function preValidateTokens(uint256 _tokens, uint _category) private {\r\n        if(_category == 1 || _category == 3){ //teams & angel investors\r\n            require(_tokens <= _teamReserves.sub(_teamAllocations), \"reduce number of tokens, exceeding teams reserves\");\r\n            _teamAllocations = _teamAllocations.add(_tokens);\r\n        }\r\n        else if(_category == 2){ //advisors\r\n            require(_tokens <= _advisorsReserves.sub(_advisorsAllocations), \"reduce number of tokens, exceeding advisors reserves\");\r\n            _advisorsAllocations = _advisorsAllocations.add(_tokens);\r\n        }\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // redeem pendings in vesting time period\r\n    // Purchaser's or deservers can redeem their bonuses/tokens, respectively\r\n    // depending on time period \r\n    // ------------------------------------------------------------------------\r\n    function redeem() public{\r\n        require(allocated[msg.sender].bonus > 0 || allocated[msg.sender].tokens >0, \"no claimable tokens/bonuses\");\r\n        if(allocated[msg.sender].bonus > 0)\r\n            sendBonus(msg.sender);\r\n        if(allocated[msg.sender].tokens > 0)\r\n            sendTokens(msg.sender);\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Percentage of Bonuses is released to the redeemer depending on the time period\r\n    // ------------------------------------------------------------------------\r\n    function sendBonus(address _redeemer) private{\r\n        require(allocated[_redeemer].bonus > allocated[_redeemer].claimedBonus, \"no pending bonuses\");\r\n        // private sale\r\n        if(allocated[_redeemer].stage == 0){ \r\n            if(now >= _startDate.add(12 *  30 days)){ // 12 months\r\n                _transfer(_redeemer, allocated[_redeemer].bonus.sub(allocated[_redeemer].claimedBonus));\r\n                allocated[_redeemer].claimedBonus = allocated[_redeemer].bonus;\r\n            } \r\n            else if(now >= _startDate.add(9* 30 days)){ // 9 months\r\n                uint256 bonus = (allocated[_redeemer].bonus * 75 * 100) / 10000;\r\n                _transfer(_redeemer, bonus.sub(allocated[_redeemer].claimedBonus));\r\n                allocated[_redeemer].claimedBonus = bonus;\r\n            }\r\n            else if(now >= _startDate.add(6* 30 days)){ // 6 months\r\n                uint256 bonus = (allocated[_redeemer].bonus * 50 * 100) / 10000;\r\n                _transfer(_redeemer, bonus.sub(allocated[_redeemer].claimedBonus));\r\n                allocated[_redeemer].claimedBonus = bonus;\r\n            }\r\n            else if(now >= _startDate.add(3* 30 days)){ // 3 months\r\n                uint256 bonus = (allocated[_redeemer].bonus * 25 * 100) / 10000;\r\n                _transfer(_redeemer, bonus.sub(allocated[_redeemer].claimedBonus));\r\n                allocated[_redeemer].claimedBonus = bonus;\r\n            }\r\n        }\r\n        // pre sale 1\r\n        else if(allocated[_redeemer].stage == 1){\r\n            if(now >= _startDate.add(9* 30 days)){ // 9 months\r\n                _transfer(_redeemer, allocated[_redeemer].bonus.sub(allocated[_redeemer].claimedBonus));\r\n                allocated[_redeemer].claimedBonus = allocated[_redeemer].bonus;\r\n            }\r\n            else if(now >= _startDate.add(6* 30 days)){ // 6 months\r\n                uint256 bonus = (allocated[_redeemer].bonus * 80 * 100) / 10000;\r\n                _transfer(_redeemer, bonus.sub(allocated[_redeemer].claimedBonus));\r\n                allocated[_redeemer].claimedBonus = bonus;\r\n            }\r\n            else if(now >= _startDate.add(3* 30 days)){ // 3 months\r\n                uint256 bonus = (allocated[_redeemer].bonus * 50 * 100) / 10000;\r\n                _transfer(_redeemer, bonus.sub(allocated[_redeemer].claimedBonus));\r\n                allocated[_redeemer].claimedBonus = bonus;\r\n            }\r\n            else{\r\n                revert();\r\n            }\r\n        }\r\n        // pre sale 2\r\n        else if(allocated[_redeemer].stage == 2){\r\n            if(now >= _startDate.add(6* 30 days)){ // 6 months\r\n                _transfer(_redeemer, allocated[_redeemer].bonus.sub(allocated[_redeemer].claimedBonus));\r\n                allocated[_redeemer].claimedBonus = allocated[_redeemer].bonus;\r\n            }\r\n            else if(now >= _startDate.add(3* 30 days)){ // 3 months\r\n                uint256 bonus = (allocated[_redeemer].bonus * 50 * 100) / 10000;\r\n                _transfer(_redeemer, bonus.sub(allocated[_redeemer].claimedBonus));\r\n                allocated[_redeemer].claimedBonus = bonus;\r\n            }\r\n        }\r\n        // pre sale 3\r\n        else if(allocated[_redeemer].stage == 3){\r\n            if(now >= _startDate.add(3* 30 days)){ // 3 months\r\n                _transfer(_redeemer, allocated[_redeemer].bonus.sub(allocated[_redeemer].claimedBonus));\r\n                allocated[_redeemer].claimedBonus = allocated[_redeemer].bonus;\r\n            }\r\n        }\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Percentage of tokens is released to the redeemer depending on the time period\r\n    // ------------------------------------------------------------------------\r\n    function sendTokens(address _redeemer) private{\r\n        require(allocated[_redeemer].tokens > allocated[_redeemer].claimedTokens, \"no pending tokens\");\r\n        // category = teams\r\n        if(allocated[_redeemer].category == 1){ \r\n            if(now >= _startDate.add(36 *  30 days)){ // 36 months\r\n                _transfer(_redeemer, allocated[_redeemer].tokens.sub(allocated[_redeemer].claimedTokens));\r\n                allocated[_redeemer].claimedTokens = allocated[_redeemer].tokens;\r\n            } \r\n            else if(now >= _startDate.add(24* 30 days)){ // 24 months\r\n                uint256 tokens = (allocated[_redeemer].tokens * 90 * 100) / 10000;\r\n                _transfer(_redeemer, tokens.sub(allocated[_redeemer].claimedTokens));\r\n                allocated[_redeemer].claimedTokens = tokens;\r\n            }\r\n            else if(now >= _startDate.add(18* 30 days)){ // 18 months\r\n                uint256 tokens = (allocated[_redeemer].tokens * 75 * 100) / 10000;\r\n                _transfer(_redeemer, tokens.sub(allocated[_redeemer].claimedTokens));\r\n                allocated[_redeemer].claimedTokens = tokens;\r\n            }\r\n            else if(now >= _startDate.add(12* 30 days)){ // 12 months\r\n                uint256 tokens = (allocated[_redeemer].tokens * 55 * 100) / 10000;\r\n                _transfer(_redeemer, tokens.sub(allocated[_redeemer].claimedTokens));\r\n                allocated[_redeemer].claimedTokens = tokens;\r\n            }\r\n            else if(now >= _startDate.add(6* 30 days)){ // 6 months\r\n                uint256 tokens = (allocated[_redeemer].tokens * 25 * 100) / 10000;\r\n                _transfer(_redeemer, tokens.sub(allocated[_redeemer].claimedTokens));\r\n                allocated[_redeemer].claimedTokens = tokens;\r\n            }\r\n            else if(now >= _startDate.add(3* 30 days)){ // 3 months\r\n                uint256 tokens = (allocated[_redeemer].tokens * 10 * 100) / 10000;\r\n                _transfer(_redeemer, tokens.sub(allocated[_redeemer].claimedTokens));\r\n                allocated[_redeemer].claimedTokens = tokens;\r\n            }\r\n        }\r\n        // category = advisors\r\n        else if(allocated[_redeemer].category == 2){\r\n            if(now >= _startDate.add(6* 30 days)){ // 6 months\r\n                _transfer(_redeemer, allocated[_redeemer].tokens.sub(allocated[_redeemer].claimedTokens));\r\n                allocated[_redeemer].claimedTokens = allocated[_redeemer].tokens;\r\n            }\r\n            else if(now >= _startDate.add(3* 30 days)){ // 3 months\r\n                uint256 tokens = (allocated[_redeemer].tokens * 50 * 100) / 10000;\r\n                _transfer(_redeemer, tokens.sub(allocated[_redeemer].claimedTokens));\r\n                allocated[_redeemer].claimedTokens = tokens;\r\n            }\r\n        }\r\n        // category = angel investors\r\n        else if(allocated[_redeemer].category == 3){\r\n            if(now >= _startDate.add(12* 30 days)){ // 12 months\r\n                _transfer(_redeemer, allocated[_redeemer].tokens.sub(allocated[_redeemer].claimedTokens));\r\n                allocated[_redeemer].claimedTokens = allocated[_redeemer].tokens;\r\n            }\r\n            else if(now >= _startDate.add(9* 30 days)){ // 9 months\r\n                uint256 tokens = (allocated[_redeemer].tokens * 80 * 100) / 10000;\r\n                _transfer(_redeemer, tokens.sub(allocated[_redeemer].claimedTokens));\r\n                allocated[_redeemer].claimedTokens = tokens;\r\n            }\r\n            else if(now >= _startDate.add(6* 30 days)){ // 6 months\r\n                uint256 tokens = (allocated[_redeemer].tokens * 60 * 100) / 10000;\r\n                _transfer(_redeemer, tokens.sub(allocated[_redeemer].claimedTokens));\r\n                allocated[_redeemer].claimedTokens = tokens;\r\n            }\r\n            else if(now >= _startDate.add(3* 30 days)){ // 3 months\r\n                uint256 tokens = (allocated[_redeemer].tokens * 40 * 100) / 10000;\r\n                _transfer(_redeemer, tokens.sub(allocated[_redeemer].claimedTokens));\r\n                allocated[_redeemer].claimedTokens = tokens;\r\n            }\r\n        }\r\n    }\r\n    /*=========================ERC20 implementation==================================*/\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // gives total supply of the tokens\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public view returns (uint256){\r\n       return _totalSupply;\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account `tokenOwner`\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public view returns (uint256 balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to `to` account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint256 tokens) public returns (bool success) {\r\n        require(!lock, \"transfer lock\");\r\n        // prevent transfer to 0x0, use burn instead\r\n        require(to != address(0), \"address should not zero\");\r\n        require(balances[msg.sender] >= tokens, \"not sufficient tokens\" );\r\n        require(balances[to].add(tokens) >= balances[to]);\r\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        emit Transfer(msg.sender,to,tokens);\r\n        return true;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n    // from the token owner's account\r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint256 tokens) public returns (bool success){\r\n        require(allowed[msg.sender][spender] == 0 || tokens == 0, \"double spending not allowed\");\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender,spender,tokens);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer `tokens` from the `from` account to the `to` account\r\n    // \r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the `from` account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint256 tokens) public returns (bool success){\r\n        require(!lock, \"transfer is lock\");\r\n        require(tokens <= allowed[from][msg.sender], \"not allowed to make transfer\"); //check allowance\r\n        require(balances[from] >= tokens, \"not sufficient tokens in wallet\");\r\n        balances[from] = balances[from].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n        emit Transfer(from,to,tokens);\r\n        return true;\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public view returns (uint256 remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n    \r\n    function _transfer(address to, uint256 tokens) internal returns (bool success) {\r\n        // prevent transfer to 0x0, use burn instead\r\n        require(to != address(0), \"address should not be zero\");\r\n        require(balances[address(this)] >= tokens, \"not sufficent tokens in contract\");\r\n        require(balances[to].add(tokens) >= balances[to]);\r\n        balances[address(this)] = balances[address(this)].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        emit Transfer(address(this),to,tokens);\r\n        return true;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startPreSale1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startPreSale2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unLockTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"tokenAllocation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_category\",\"type\":\"uint256\"}],\"name\":\"donations\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopSales\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokens\",\"type\":\"uint256[]\"}],\"name\":\"multiTokenAllocation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"LockTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startPreSale3\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ecosystemHolder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ecosystem\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"JOLT","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000029c88ad6ea5641d284160607b90fadcf79bbec47000000000000000000000000fc2a9625a5fd264c9753849c584e5458c7e11167","Library":"","LicenseType":"None","SwarmSource":"bzzr://d8fa061cc1c104318def5766cacac09ec4b772a85ce26f964714594841341def"}]}