{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.13;\n\n/// @title iFactory\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\ninterface iFactory {\n\n    event InstanceCreated(address indexed instance, address indexed creator, bytes callData);\n\n    function create(bytes calldata callData) external returns (address instance);\n    function createSalty(bytes calldata callData, bytes32 salt) external returns (address instance);\n    function getInitSelector() external view returns (bytes4 initSelector);\n    function getInstanceRegistry() external view returns (address instanceRegistry);\n    function getTemplate() external view returns (address template);\n    function getSaltyInstance(address creator, bytes calldata callData, bytes32 salt) external view returns (address instance, bool validity);\n    function getNextNonceInstance(address creator, bytes calldata callData) external view returns (address instance);\n\n    function getInstanceCreator(address instance) external view returns (address creator);\n    function getInstanceType() external view returns (bytes4 instanceType);\n    function getInstanceCount() external view returns (uint256 count);\n    function getInstance(uint256 index) external view returns (address instance);\n    function getInstances() external view returns (address[] memory instances);\n    function getPaginatedInstances(uint256 startIndex, uint256 endIndex) external view returns (address[] memory instances);\n}\n\n\n\n/// @title Template\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\n/// @notice This module is imported by all template contracts to implement core functionality associated with the factories.\ncontract Template {\n\n    address private _factory;\n\n    // modifiers\n\n    /// @notice Modifier which only allows to be `DELEGATECALL`ed from within a constructor on initialization of the contract.\n    modifier initializeTemplate() {\n        // set factory\n        _factory = msg.sender;\n\n        // only allow function to be `DELEGATECALL`ed from within a constructor.\n        uint32 codeSize;\n        assembly { codeSize := extcodesize(address) }\n        require(codeSize == 0, \"must be called within contract constructor\");\n        _;\n    }\n\n    // view functions\n\n    /// @notice Get the address that created this clone.\n    ///         Note, this cannot be trusted because it is possible to frontrun the create function and become the creator.\n    /// @return creator address that created this clone.\n    function getCreator() public view returns (address creator) {\n        // iFactory(...) would revert if _factory address is not actually a factory contract\n        return iFactory(_factory).getInstanceCreator(address(this));\n    }\n\n    /// @notice Validate if address matches the stored creator.\n    /// @param caller address to validate.\n    /// @return validity bool true if matching address.\n    function isCreator(address caller) internal view returns (bool validity) {\n        return (caller == getCreator());\n    }\n\n    /// @notice Get the address of the factory for this clone.\n    /// @return factory address of the factory.\n    function getFactory() public view returns (address factory) {\n        return _factory;\n    }\n\n}\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\n/// @author Stefan George - <stefan.george@consensys.net>\ncontract MultiSigWallet is Template {\n    /*\n     *  Events\n     */\n    event Confirmation(address indexed sender, uint256 indexed transactionId);\n    event Revocation(address indexed sender, uint256 indexed transactionId);\n    event Submission(uint256 indexed transactionId);\n    event Execution(uint256 indexed transactionId);\n    event ExecutionFailure(uint256 indexed transactionId);\n    event Deposit(address indexed sender, uint256 value);\n    event OwnerAddition(address indexed owner);\n    event OwnerRemoval(address indexed owner);\n    event RequirementChange(uint256 required);\n\n    /*\n     *  Constants\n     */\n    uint256 public constant MAX_OWNER_COUNT = 50;\n\n    /*\n     *  Storage\n     */\n    mapping(uint256 => Transaction) public transactions;\n    mapping(uint256 => mapping(address => bool)) public confirmations;\n    mapping(address => bool) public isOwner;\n    address[] public owners;\n    uint256 public required;\n    uint256 public transactionCount;\n\n    struct Transaction {\n        address destination;\n        uint256 value;\n        bytes data;\n        bool executed;\n    }\n\n    /*\n     *  Modifiers\n     */\n    modifier onlyWallet() {\n        require(msg.sender == address(this));\n        _;\n    }\n\n    modifier ownerDoesNotExist(address owner) {\n        require(!isOwner[owner]);\n        _;\n    }\n\n    modifier ownerExists(address owner) {\n        require(isOwner[owner]);\n        _;\n    }\n\n    modifier transactionExists(uint256 transactionId) {\n        require(transactions[transactionId].destination != address(0));\n        _;\n    }\n\n    modifier confirmed(uint256 transactionId, address owner) {\n        require(confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notConfirmed(uint256 transactionId, address owner) {\n        require(!confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notExecuted(uint256 transactionId) {\n        require(!transactions[transactionId].executed);\n        _;\n    }\n\n    modifier notNull(address _address) {\n        require(_address != address(0));\n        _;\n    }\n\n    modifier validRequirement(uint256 ownerCount, uint256 _required) {\n        require(\n            ownerCount <= MAX_OWNER_COUNT &&\n                _required <= ownerCount &&\n                _required != 0 &&\n                ownerCount != 0\n        );\n        _;\n    }\n\n    /// @dev Fallback function allows to deposit ether.\n    function() external payable {\n        if (msg.value > 0) {\n            emit Deposit(msg.sender, msg.value);\n        }\n    }\n\n    function initialize(address[] memory _owners, uint256 _required)\n        public\n        initializeTemplate()\n        validRequirement(_owners.length, _required)\n    {\n        for (uint256 i = 0; i < _owners.length; i++) {\n            require(!isOwner[_owners[i]] && _owners[i] != address(0));\n            isOwner[_owners[i]] = true;\n        }\n        owners = _owners;\n        required = _required;\n    }\n\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of new owner.\n    function addOwner(address owner)\n        public\n        onlyWallet\n        ownerDoesNotExist(owner)\n        notNull(owner)\n        validRequirement(owners.length + 1, required)\n    {\n        isOwner[owner] = true;\n        owners.push(owner);\n        emit OwnerAddition(owner);\n    }\n\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner.\n    function removeOwner(address owner) public onlyWallet ownerExists(owner) {\n        isOwner[owner] = false;\n        for (uint256 i = 0; i < owners.length - 1; i++)\n            if (owners[i] == owner) {\n                owners[i] = owners[owners.length - 1];\n                break;\n            }\n        owners.length -= 1;\n        if (required > owners.length) changeRequirement(owners.length);\n        emit OwnerRemoval(owner);\n    }\n\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner to be replaced.\n    /// @param newOwner Address of new owner.\n    function replaceOwner(address owner, address newOwner)\n        public\n        onlyWallet\n        ownerExists(owner)\n        ownerDoesNotExist(newOwner)\n    {\n        for (uint256 i = 0; i < owners.length; i++)\n            if (owners[i] == owner) {\n                owners[i] = newOwner;\n                break;\n            }\n        isOwner[owner] = false;\n        isOwner[newOwner] = true;\n        emit OwnerRemoval(owner);\n        emit OwnerAddition(newOwner);\n    }\n\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n    /// @param _required Number of required confirmations.\n    function changeRequirement(uint256 _required)\n        public\n        onlyWallet\n        validRequirement(owners.length, _required)\n    {\n        required = _required;\n        emit RequirementChange(_required);\n    }\n\n    /// @dev Allows an owner to submit and confirm a transaction.\n    /// @param destination Transaction target address.\n    /// @param value Transaction ether value.\n    /// @param data Transaction data payload.\n    /// @return Returns transaction ID.\n    function submitTransaction(\n        address destination,\n        uint256 value,\n        bytes memory data\n    ) public returns (uint256 transactionId) {\n        transactionId = addTransaction(destination, value, data);\n        confirmTransaction(transactionId);\n    }\n\n    /// @dev Allows an owner to confirm a transaction.\n    /// @param transactionId Transaction ID.\n    function confirmTransaction(uint256 transactionId)\n        public\n        ownerExists(msg.sender)\n        transactionExists(transactionId)\n        notConfirmed(transactionId, msg.sender)\n    {\n        confirmations[transactionId][msg.sender] = true;\n        emit Confirmation(msg.sender, transactionId);\n        executeTransaction(transactionId);\n    }\n\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\n    /// @param transactionId Transaction ID.\n    function revokeConfirmation(uint256 transactionId)\n        public\n        ownerExists(msg.sender)\n        confirmed(transactionId, msg.sender)\n        notExecuted(transactionId)\n    {\n        confirmations[transactionId][msg.sender] = false;\n        emit Revocation(msg.sender, transactionId);\n    }\n\n    /// @dev Allows anyone to execute a confirmed transaction.\n    /// @param transactionId Transaction ID.\n    function executeTransaction(uint256 transactionId)\n        public\n        ownerExists(msg.sender)\n        confirmed(transactionId, msg.sender)\n        notExecuted(transactionId)\n    {\n        if (isConfirmed(transactionId)) {\n            Transaction storage txn = transactions[transactionId];\n            txn.executed = true;\n            if (\n                external_call(\n                    txn.destination,\n                    txn.value,\n                    txn.data.length,\n                    txn.data\n                )\n            ) {\n                emit Execution(transactionId);\n            } else {\n                emit ExecutionFailure(transactionId);\n                txn.executed = false;\n            }\n        }\n    }\n\n    // call has been separated into its own function in order to take advantage\n    // of the Solidity's code generator to produce a loop that copies tx.data into memory.\n    function external_call(\n        address destination,\n        uint256 value,\n        uint256 dataLength,\n        bytes memory data\n    ) internal returns (bool) {\n        bool result;\n        assembly {\n            let x := mload(0x40) // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n            result := call(\n                sub(gas, 34710), // 34710 is the value that solidity is currently emitting\n                // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n                // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n                destination,\n                value,\n                d,\n                dataLength, // Size of the input (in bytes) - this is what fixes the padding problem\n                x,\n                0 // Output is ignored, therefore the output size is zero\n            )\n        }\n        return result;\n    }\n\n    /// @dev Returns the confirmation status of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Confirmation status.\n    function isConfirmed(uint256 transactionId) public view returns (bool) {\n        uint256 count = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            if (confirmations[transactionId][owners[i]]) count += 1;\n            if (count == required) return true;\n        }\n    }\n\n    /*\n     * Internal functions\n     */\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\n    /// @param destination Transaction target address.\n    /// @param value Transaction ether value.\n    /// @param data Transaction data payload.\n    /// @return Returns transaction ID.\n    function addTransaction(\n        address destination,\n        uint256 value,\n        bytes memory data\n    ) internal notNull(destination) returns (uint256 transactionId) {\n        transactionId = transactionCount;\n        transactions[transactionId] = Transaction({\n            destination: destination,\n            value: value,\n            data: data,\n            executed: false\n        });\n        transactionCount += 1;\n        emit Submission(transactionId);\n    }\n\n    /*\n     * Web3 call functions\n     */\n    /// @dev Returns number of confirmations of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Number of confirmations.\n    function getConfirmationCount(uint256 transactionId)\n        public\n        view\n        returns (uint256 count)\n    {\n        for (uint256 i = 0; i < owners.length; i++)\n            if (confirmations[transactionId][owners[i]]) count += 1;\n    }\n\n    /// @dev Returns total number of transactions after filers are applied.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return Total number of transactions after filters are applied.\n    function getTransactionCount(bool pending, bool executed)\n        public\n        view\n        returns (uint256 count)\n    {\n        for (uint256 i = 0; i < transactionCount; i++)\n            if (\n                (pending && !transactions[i].executed) ||\n                (executed && transactions[i].executed)\n            ) count += 1;\n    }\n\n    /// @dev Returns list of owners.\n    /// @return List of owner addresses.\n    function getOwners() public view returns (address[] memory) {\n        return owners;\n    }\n\n    /// @dev Returns array with owner addresses, which confirmed transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Returns array of owner addresses.\n    function getConfirmations(uint256 transactionId)\n        public\n        view\n        returns (address[] memory _confirmations)\n    {\n        address[] memory confirmationsTemp = new address[](owners.length);\n        uint256 count = 0;\n        uint256 i;\n        for (i = 0; i < owners.length; i++)\n            if (confirmations[transactionId][owners[i]]) {\n                confirmationsTemp[count] = owners[i];\n                count += 1;\n            }\n        _confirmations = new address[](count);\n        for (i = 0; i < count; i++) _confirmations[i] = confirmationsTemp[i];\n    }\n\n    /// @dev Returns list of transaction IDs in defined range.\n    /// @param from Index start position of transaction array.\n    /// @param to Index end position of transaction array.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return Returns array of transaction IDs.\n    function getTransactionIds(\n        uint256 from,\n        uint256 to,\n        bool pending,\n        bool executed\n    ) public view returns (uint256[] memory _transactionIds) {\n        uint256[] memory transactionIdsTemp = new uint256[](transactionCount);\n        uint256 count = 0;\n        uint256 i;\n        for (i = 0; i < transactionCount; i++)\n            if (\n                (pending && !transactions[i].executed) ||\n                (executed && transactions[i].executed)\n            ) {\n                transactionIdsTemp[count] = i;\n                count += 1;\n            }\n        _transactionIds = new uint256[](to - from);\n        for (i = from; i < to; i++)\n            _transactionIds[i - from] = transactionIdsTemp[i];\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an owner and a manager that can be granted exclusive access to\n * specific functions.\n */\ncontract Manageable is Ownable {\n    address private _manager;\n\n    event ManagementTransferred(address indexed previousManager, address indexed newManager);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial manager.\n     */\n    constructor () internal Ownable() {\n        _manager = _msgSender();\n        emit ManagementTransferred(address(0), _manager);\n    }\n\n    /**\n     * @return the address of the manager.\n     */\n    function manager() public view returns (address) {\n        return _manager;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner or manager.\n     */\n    modifier onlyManagerOrOwner() {\n        require(isManagerOrOwner(), \"Manageable: caller is not the manager or owner\");\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner or manager of the contract.\n     */\n    function isManagerOrOwner() public view returns (bool) {\n        return (_msgSender() == _manager || isOwner());\n    }\n\n    /**\n     * @dev Leaves the contract without manager. Owner will need to set a new manager.\n     * Can only be called by the current owner or manager.\n     */\n    function renounceManagement() public onlyManagerOrOwner {\n        emit ManagementTransferred(_manager, address(0));\n        _manager = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newManager.\n     * Can only be called by the current owner.\n     * @param newManager The address to transfer management to.\n     */\n    function transferManagement(address newManager) public onlyOwner {\n        require(newManager != address(0), \"Manageable: new manager is the zero address\");\n        emit ManagementTransferred(_manager, newManager);\n        _manager = newManager;\n    }\n}\n\n\n\n/// @title WalletManager\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\n/// @notice This module allows for managing multisig wallets.\n// prettier-ignore\ncontract WalletManager is Manageable {\n\n    address private _walletFactory;\n\n    function getWalletFactory() public view returns (address walletFactory) {\n        return _walletFactory;\n    }\n\n    constructor(address walletFactory) public {\n        _walletFactory = walletFactory;\n    }\n\n    /// @dev Allows to create a new wallet.\n    /// @return instance address of the clone that was created.\n    function create() public onlyManagerOrOwner() returns (address wallet) {\n        bytes memory init_calldata = abi.encodeWithSelector(\n            iFactory(_walletFactory).getInitSelector(),\n            [address(this)], // _owners\n            1  // _required\n        );\n        return iFactory(_walletFactory).create(init_calldata);\n    }\n\n    /// @dev Allows to create a new wallet.\n    /// @param salt bytes32 unique salt for deterministic address generation\n    /// @return instance address of the clone that was created.\n    function createSalty(bytes32 salt) public onlyManagerOrOwner() returns (address wallet) {\n        bytes memory init_calldata = abi.encodeWithSelector(\n            iFactory(_walletFactory).getInitSelector(),\n            [address(this)], // _owners\n            1  // _required\n        );\n        return iFactory(_walletFactory).createSalty(init_calldata, salt);\n    }\n\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n    /// @param wallet Address of wallet.\n    /// @param owner Address of new owner.\n    function addOwner(address payable wallet, address owner) public onlyManagerOrOwner() {\n        MultiSigWallet(wallet).addOwner(owner);\n    }\n\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n    /// @param wallet Address of wallet.\n    /// @param owner Address of owner.\n    function removeOwner(address payable wallet, address owner) public onlyManagerOrOwner() {\n        MultiSigWallet(wallet).removeOwner(owner);\n    }\n\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n    /// @param wallet Address of wallet.\n    /// @param owner Address of owner to be replaced.\n    /// @param newOwner Address of new owner.\n    function replaceOwner(address payable wallet, address owner, address newOwner) public onlyManagerOrOwner() {\n        MultiSigWallet(wallet).replaceOwner(owner, newOwner);\n    }\n\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n    /// @param wallet Address of wallet.\n    /// @param _required Number of required confirmations.\n    function changeRequirement(address payable wallet, uint256 _required) public onlyManagerOrOwner() {\n        MultiSigWallet(wallet).changeRequirement(_required);\n    }\n\n    /// @dev Allows an owner to submit and confirm a transaction.\n    /// @param wallet Address of wallet.\n    /// @param destination Transaction target address.\n    /// @param value Transaction ether value.\n    /// @param data Transaction data payload.\n    /// @return Returns transaction ID.\n    function submitTransaction(\n        address payable wallet,\n        address destination,\n        uint256 value,\n        bytes memory data\n    ) public onlyManagerOrOwner() returns (uint256 transactionId) {\n        return MultiSigWallet(wallet).submitTransaction(destination, value, data);\n    }\n\n    /// @dev Allows an owner to confirm a transaction.\n    /// @param wallet Address of wallet.\n    /// @param transactionId Transaction ID.\n    function confirmTransaction(address payable wallet, uint256 transactionId) public onlyManagerOrOwner() {\n        MultiSigWallet(wallet).confirmTransaction(transactionId);\n    }\n\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\n    /// @param wallet Address of wallet.\n    /// @param transactionId Transaction ID.\n    function revokeConfirmation(address payable wallet, uint256 transactionId) public onlyManagerOrOwner() {\n        MultiSigWallet(wallet).revokeConfirmation(transactionId);\n    }\n\n    /// @dev Allows anyone to execute a confirmed transaction.\n    /// @param wallet Address of wallet.\n    /// @param transactionId Transaction ID.\n    function executeTransaction(address payable wallet, uint256 transactionId) public onlyManagerOrOwner() {\n        MultiSigWallet(wallet).executeTransaction(transactionId);\n    }\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"walletFactory\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagementTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_required\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"confirmTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"create\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"createSalty\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWalletFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"walletFactory\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isManagerOrOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceManagement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"replaceOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"revokeConfirmation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"submitTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"transferManagement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"WalletManager","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000789e3a833fab4a64cef8864b1cc0bc1787c0dc1f","Library":"","LicenseType":"","SwarmSource":""}]}