{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.1;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function decimals() external view returns (uint256 digits);\r\n\r\n    function totalSupply() external view returns (uint256 supply);\r\n}\r\n\r\ncontract Wrapper {\r\n\r\n    IERC20 internal constant ETH_TOKEN_ADDRESS = IERC20(\r\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\n    );\r\n    \r\n    function getBalances(address reserve, IERC20[] calldata tokens) external view returns(uint[] memory) {\r\n        uint[] memory result = new uint[](tokens.length);\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            uint balance = 0;\r\n            if (tokens[i] == ETH_TOKEN_ADDRESS) {\r\n                balance = reserve.balance;\r\n            } else {\r\n                (bool success, bytes memory data) = address(tokens[i]).staticcall(\r\n                    abi.encode(\r\n                        \"balanceOf(address)\",\r\n                        reserve\r\n                    )\r\n                );\r\n                if (success) {\r\n                    balance = toUint256(data, 0);\r\n                }\r\n            }\r\n\r\n            result[i] = balance;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function toUint256(bytes memory _bytes, uint _start) internal pure returns(uint) {\r\n        require(_bytes.length >= (_start + 32), \"Read out of bounds\");\r\n        uint tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getBalances\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Wrapper","CompilerVersion":"v0.6.1+commit.e6f7d5a4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7fe2310b53cf3c09ffadd77f21678debd183a4eacb35bf0e1794fe1339d6c07a"}]}