{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    /**\r\n      * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n      * account.\r\n      */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n      * @dev Throws if called by any account other than the owner.\r\n      */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20Basic {\r\n    uint public totalSupplyNum;\r\n\r\n    function totalSupply() public constant returns (uint);\r\n\r\n    function balanceOf(address who) public constant returns (uint);\r\n\r\n    function transfer(address to, uint value) public;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public constant returns (uint);\r\n\r\n    function transferFrom(address from, address to, uint value) public;\r\n\r\n    function approve(address spender, uint value) public;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is Ownable, ERC20Basic {\r\n    using SafeMath for uint;\r\n\r\n    mapping(address => uint) public balances;\r\n\r\n    // additional variables for use if transaction fees ever became necessary\r\n    uint public basisPointsRate = 0;\r\n    uint public maximumFee = 0;\r\n\r\n    /**\r\n    * @dev Fix for the ERC20 short address attack.\r\n    */\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(!(msg.data.length < size + 4));\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {\r\n        uint fee = (_value.mul(basisPointsRate)).div(10000);\r\n        if (fee > maximumFee) {\r\n            fee = maximumFee;\r\n        }\r\n        uint sendAmount = _value.sub(fee);\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(sendAmount);\r\n        if (fee > 0) {\r\n            balances[owner] = balances[owner].add(fee);\r\n            emit Transfer(msg.sender, owner, fee);\r\n        }\r\n        emit Transfer(msg.sender, _to, sendAmount);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public constant returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based oncode by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is BasicToken, ERC20 {\r\n\r\n    mapping(address => mapping(address => uint)) public allowed;\r\n\r\n    uint public constant MAX_UINT = 2 ** 256 - 1;\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {\r\n        uint _allowance = allowed[_from][msg.sender];\r\n\r\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n        // if (_value > _allowance) throw;\r\n\r\n        uint fee = (_value.mul(basisPointsRate)).div(10000);\r\n        if (fee > maximumFee) {\r\n            fee = maximumFee;\r\n        }\r\n        if (_allowance < MAX_UINT) {\r\n            allowed[_from][msg.sender] = _allowance.sub(_value);\r\n        }\r\n        uint sendAmount = _value.sub(fee);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(sendAmount);\r\n        if (fee > 0) {\r\n            balances[owner] = balances[owner].add(fee);\r\n            emit Transfer(_from, owner, fee);\r\n        }\r\n        emit Transfer(_from, _to, sendAmount);\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n    }\r\n\r\n    /**\r\n    * @dev Function to check the amount of tokens than an owner allowed to a spender.\r\n    * @param _owner address The address which owns the funds.\r\n    * @param _spender address The address which will spend the funds.\r\n    * @return A uint specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\ncontract BlackList is Ownable, BasicToken {\r\n\r\n    /////// Getters to allow the same blacklist to be used also by other contracts (including upgraded Tether) ///////\r\n    function getBlackListStatus(address _maker) external constant returns (bool) {\r\n        return isBlackListed[_maker];\r\n    }\r\n\r\n    function getOwner() external constant returns (address) {\r\n        return owner;\r\n    }\r\n\r\n    mapping(address => bool) public isBlackListed;\r\n\r\n    function addBlackList(address _evilUser) public onlyOwner {\r\n        isBlackListed[_evilUser] = true;\r\n        emit AddedBlackList(_evilUser);\r\n    }\r\n\r\n    function removeBlackList(address _clearedUser) public onlyOwner {\r\n        isBlackListed[_clearedUser] = false;\r\n        emit RemovedBlackList(_clearedUser);\r\n    }\r\n\r\n    function destroyBlackFunds(address _blackListedUser) public onlyOwner {\r\n        require(isBlackListed[_blackListedUser]);\r\n        uint dirtyFunds = balanceOf(_blackListedUser);\r\n        balances[_blackListedUser] = 0;\r\n        totalSupplyNum -= dirtyFunds;\r\n        emit DestroyedBlackFunds(_blackListedUser, dirtyFunds);\r\n    }\r\n\r\n    event DestroyedBlackFunds(address _blackListedUser, uint _balance);\r\n\r\n    event AddedBlackList(address _user);\r\n\r\n    event RemovedBlackList(address _user);\r\n\r\n}\r\n\r\n/// @dev Models a uint -> uint mapping where it is possible to iterate over all keys.\r\ncontract IterableMapping\r\n{\r\n    struct itmap\r\n    {\r\n        mapping(address => Account) data;\r\n        KeyFlag[] keys;\r\n        uint size;\r\n    }\r\n\r\n    struct Account {\r\n        uint keyIndex;\r\n        address parentAddress;\r\n        bool active;\r\n    }\r\n\r\n    struct KeyFlag {address key; bool deleted;}\r\n\r\n    function insert(itmap storage self, address key, address parentAddress, bool active) internal returns (bool replaced)\r\n    {\r\n        uint keyIndex = self.data[key].keyIndex;\r\n        self.data[key].parentAddress = parentAddress;\r\n        self.data[key].active = active;\r\n\r\n        if (keyIndex > 0)\r\n            return true;\r\n        else\r\n        {\r\n            keyIndex = self.keys.length++;\r\n            self.data[key].keyIndex = keyIndex + 1;\r\n            self.keys[keyIndex].key = key;\r\n            self.size++;\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function remove(itmap storage self, address key) internal returns (bool success)\r\n    {\r\n        uint keyIndex = self.data[key].keyIndex;\r\n        if (keyIndex == 0)\r\n            return false;\r\n        delete self.data[key];\r\n        self.keys[keyIndex - 1].deleted = true;\r\n        self.size --;\r\n        return true;\r\n    }\r\n\r\n    function contains(itmap storage self, address key) internal view returns (bool)\r\n    {\r\n        return self.data[key].keyIndex > 0;\r\n    }\r\n\r\n    function index(itmap storage self, address key) internal view returns (uint) {\r\n        return self.data[key].keyIndex;\r\n    }\r\n\r\n    function iterate_start(itmap storage self) internal view returns (uint keyIndex)\r\n    {\r\n        return iterate_next(self, uint(- 1));\r\n    }\r\n\r\n    function iterate_valid(itmap storage self, uint keyIndex) internal view returns (bool)\r\n    {\r\n        return keyIndex < self.keys.length;\r\n    }\r\n\r\n    function iterate_next(itmap storage self, uint keyIndex) internal view returns (uint r_keyIndex)\r\n    {\r\n        keyIndex++;\r\n        while (keyIndex < self.keys.length && self.keys[keyIndex].deleted)\r\n            keyIndex++;\r\n        return keyIndex;\r\n    }\r\n\r\n    function iterate_get(itmap storage self, uint keyIndex) internal view returns (address accountAddress, address parentAddress, bool active)\r\n    {\r\n        accountAddress = self.keys[keyIndex].key;\r\n        parentAddress = self.data[accountAddress].parentAddress;\r\n        active = self.data[accountAddress].active;\r\n    }\r\n}\r\n\r\n\r\ncontract CtgToken is StandardToken, BlackList, IterableMapping {\r\n    string public name;\r\n    string public symbol;\r\n    uint public decimals;\r\n\r\n    address public pool = 0x9492D2F14d6d4D562a9DA4793b347f2AaB3B607A; //矿池地址\r\n    address public teamAddress = 0x45D1c050C458de9b18104bdFb7ddEbA510f6D9f2; //研发团队地址\r\n    address public peer = 0x87dfEFFa31950584d6211D6A7871c3AdA2157aE1; //节点分红\r\n    address public foundation0 = 0x6eDFEaB0D0B6BD3d6848A3556B2753f53b182cCd;\r\n    address public foundation1 = 0x5CD65995e25EC1D73EcDBc61D4cF32238304D1eA;\r\n    address public foundation2 = 0x7D1E3dD3c5459BAdA93C442442D4072116e21034;\r\n    address public foundation3 = 0x5001c2917B18B18853032C3e944Fe512532E0FD1;\r\n    address public foundation4 = 0x9c131257919aE78B746222661076CF781a8FF7c6;\r\n    address public candy = 0x279C18756568B8717e915FfB8eFe2784abCb89cf;\r\n    address public contractAddress = 0x81E98EfF052837f7c1Dceb8947d08a2b908E8793;\r\n    uint public recommendNum;\r\n\r\n    itmap accounts;\r\n\r\n    mapping(uint => uint) public shareRate;\r\n    mapping(address => uint8) public levels;\r\n    mapping(uint => uint) public levelProfit;\r\n\r\n    struct StaticProfit {\r\n        uint num;\r\n        uint8 day;\r\n        uint8 rate;\r\n    }\r\n\r\n    mapping(uint => StaticProfit) public profits;\r\n    mapping(address => AddressInfo) public addressInfos;\r\n\r\n    struct AddressInfo {\r\n        address[] children;\r\n        address _address;\r\n        uint[] profitsIndex;\r\n        bool activated;\r\n    }\r\n\r\n    struct ProfitLog {\r\n        address _address;\r\n        uint levelNum;\r\n        uint num;\r\n        uint8 day;\r\n        uint8 rate;\r\n        uint8 getDay;\r\n        uint updatedAt;\r\n    }\r\n\r\n    mapping(uint => ProfitLog) public profitLogs;\r\n    uint logIndex = 0;\r\n\r\n    constructor(string _name, string _symbol, uint _decimals) public {\r\n        totalSupplyNum = formatDecimals(720000000);\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n\r\n        balances[pool] = formatDecimals(540000000);\r\n        balances[teamAddress] = formatDecimals(64800000);\r\n        balances[peer] = formatDecimals(43200000);\r\n        balances[foundation0] = formatDecimals(10080000);\r\n        balances[foundation1] = formatDecimals(10080000);\r\n        balances[foundation2] = formatDecimals(10080000);\r\n        balances[foundation3] = formatDecimals(10080000);\r\n        balances[foundation4] = formatDecimals(10080000);\r\n        balances[candy] = formatDecimals(21600000);\r\n\r\n        //推广收益比例\r\n        shareRate[1] = 7;\r\n        shareRate[2] = 5;\r\n        shareRate[3] = 3;\r\n        shareRate[4] = 2;\r\n        shareRate[5] = 1;\r\n        shareRate[6] = 1;\r\n        shareRate[7] = 1;\r\n        shareRate[8] = 1;\r\n        shareRate[9] = 1;\r\n        shareRate[10] = 1;\r\n\r\n        //等级奖励\r\n        levelProfit[1] = formatDecimals(1000);\r\n        levelProfit[2] = formatDecimals(3000);\r\n        levelProfit[3] = formatDecimals(10000);\r\n        levelProfit[4] = formatDecimals(50000);\r\n        levelProfit[5] = formatDecimals(100000);\r\n\r\n        //合约收益配置\r\n        profits[formatDecimals(100)] = StaticProfit(formatDecimals(100), 30, 10);\r\n        profits[formatDecimals(1000)] = StaticProfit(formatDecimals(1000), 30, 15);\r\n        profits[formatDecimals(5000)] = StaticProfit(formatDecimals(5000), 30, 20);\r\n        profits[formatDecimals(10000)] = StaticProfit(formatDecimals(10000), 30, 25);\r\n        profits[formatDecimals(30000)] = StaticProfit(formatDecimals(30000), 30, 30);\r\n\r\n        recommendNum = formatDecimals(23).div(10);\r\n    }\r\n\r\n    function setLevelProfit(uint level, uint num) public onlyOwner {\r\n        require(levelProfit[level] > 0, \"The level config doesn't exist!\");\r\n        levelProfit[level] = formatDecimals(num);\r\n    }\r\n\r\n    function setRecommendNum(uint num) public onlyOwner {\r\n        require(recommendNum != num, \"The value is equal old value!\");\r\n        recommendNum = num;\r\n    }\r\n\r\n\r\n    function setShareRateConfig(uint level, uint rate) public onlyOwner {\r\n        require(shareRate[level] > 0, \"This level does not exist\");\r\n\r\n        uint oldRate = shareRate[level];\r\n        shareRate[level] = rate;\r\n\r\n        emit SetShareRateConfig(level, oldRate, rate);\r\n    }\r\n\r\n    function getProfitLevelNum(uint num) internal constant returns(uint) {\r\n        if (num < formatDecimals(100)) {\r\n            return 0;\r\n        }\r\n        if (num >=formatDecimals(100) && num < formatDecimals(1000)) {\r\n            return formatDecimals(100);\r\n        }\r\n        if (num >=formatDecimals(1000) && num < formatDecimals(5000)) {\r\n            return formatDecimals(1000);\r\n        }\r\n        if (num >=formatDecimals(5000) && num < formatDecimals(10000)) {\r\n            return formatDecimals(5000);\r\n        }\r\n        if (num >=formatDecimals(10000) && num < formatDecimals(30000)) {\r\n            return formatDecimals(10000);\r\n        }\r\n        if (num >=formatDecimals(30000)) {\r\n            return formatDecimals(30000);\r\n        }\r\n    }\r\n\r\n    function getAddressProfitLevel(address _address) public constant returns (uint) {\r\n        uint maxLevel = 0;\r\n        uint[] memory indexes = addressInfos[_address].profitsIndex;\r\n        for (uint i=0; i<indexes.length; i++) {\r\n            uint k = indexes[i];\r\n            if (profitLogs[k].day > 0 && (profitLogs[k].day > profitLogs[k].getDay) && (profitLogs[k].levelNum > maxLevel)) {\r\n                maxLevel = profitLogs[k].levelNum;\r\n            }\r\n        }\r\n        return maxLevel;\r\n    }\r\n\r\n    function getAddressProfitNum(address _address) public constant returns (uint) {\r\n        uint num = 0;\r\n        uint[] memory indexes = addressInfos[_address].profitsIndex;\r\n        for (uint i=0; i<indexes.length; i++) {\r\n            uint k = indexes[i];\r\n            if (profitLogs[k].day > 0 && (profitLogs[k].day > profitLogs[k].getDay)) {\r\n                num += profitLogs[k].num;\r\n            }\r\n        }\r\n\r\n        return num;\r\n    }\r\n\r\n    function getAddressActiveChildrenCount(address _address) public constant returns (uint) {\r\n        uint num  = 0;\r\n        for(uint i=0; i<addressInfos[_address].children.length; i++) {\r\n            address child = addressInfos[_address].children[i];\r\n            AddressInfo memory childInfo = addressInfos[child];\r\n            if (childInfo.activated) {\r\n                num++;\r\n            }\r\n        }\r\n\r\n        return num;\r\n    }\r\n\r\n\r\n    function setProfitConfig(uint256 num, uint8 day, uint8 rate) public onlyOwner {\r\n        require(profits[formatDecimals(num)].num>0, \"This profit config not exist\");\r\n        profits[formatDecimals(num)] = StaticProfit(formatDecimals(num), day, rate);\r\n\r\n        emit SetProfitConfig(num, day, rate);\r\n    }\r\n\r\n    function formatDecimals(uint256 _value) internal view returns (uint256) {\r\n        return _value * 10 ** decimals;\r\n    }\r\n\r\n    function parent(address _address) public view returns (address) {\r\n        return accounts.data[_address].parentAddress;\r\n    }\r\n\r\n    function checkIsCycle(address _child, address _parent) internal view returns (bool) {\r\n        address t = _parent;\r\n        while (t != address(0)) {\r\n            if (t == _child) {\r\n                return true;\r\n            }\r\n            t = parent(t);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function iterate_start() public view returns (uint keyIndex) {\r\n        return super.iterate_start(accounts);\r\n    }\r\n\r\n    function iterate_next(uint keyIndex) public view returns (uint r_keyIndex)\r\n    {\r\n        return super.iterate_next(accounts, keyIndex);\r\n    }\r\n\r\n    function iterate_valid(uint keyIndex) public view returns (bool) {\r\n        return super.iterate_valid(accounts, keyIndex);\r\n    }\r\n\r\n    function iterate_get(uint keyIndex) public view returns (address accountAddress, address parentAddress, bool active) {\r\n        (accountAddress, parentAddress, active) = super.iterate_get(accounts, keyIndex);\r\n    }\r\n\r\n    function sendBuyShare(address _address, uint _value) internal  {\r\n        address p = parent(_address);\r\n        uint level = 1;\r\n\r\n        while (p != address(0) && level <= 10) {\r\n            uint activeChildrenNum = getAddressActiveChildrenCount(p);\r\n            if (activeChildrenNum < level) {\r\n                p = parent(p);\r\n                level = level + 1;\r\n                continue;\r\n            }\r\n\r\n            AddressInfo storage info = addressInfos[p];\r\n            if (!info.activated) {\r\n                p = parent(p);\r\n                level = level + 1;\r\n                continue;\r\n            }\r\n\r\n            uint profitLevel = getAddressProfitLevel(p);\r\n\r\n\r\n            uint addValue = _value.mul(shareRate[level]).div(100);\r\n            if (_value > profitLevel) {\r\n                addValue = profitLevel.mul(shareRate[level]).div(100);\r\n            }\r\n\r\n\r\n            transferFromPool(p, addValue);\r\n            emit BuyShare(msg.sender, p, addValue);\r\n            p = parent(p);\r\n            level = level + 1;\r\n        }\r\n    }\r\n\r\n    function releaseProfit(uint index) public onlyOwner {\r\n        ProfitLog memory log = profitLogs[index];\r\n        if (log.day == 0 || log.day == log.getDay) {\r\n            return;\r\n        }\r\n        uint addValue = log.num.mul(uint(log.rate).add(100)).div(100).div(uint(log.day));\r\n\r\n        uint diffDay = 1;\r\n        if (log.updatedAt > 0) {\r\n            diffDay = now.sub(log.updatedAt).div(24*3600);\r\n        }\r\n        if (diffDay > 0) {\r\n            addValue = addValue.mul(diffDay);\r\n            transferFrom(pool, log._address, addValue);\r\n            profitLogs[index].getDay = log.getDay + uint8(diffDay);\r\n            profitLogs[index].updatedAt = now;\r\n\r\n            emit ReleaseProfit(log._address, addValue, log.getDay+1);\r\n        }\r\n\r\n    }\r\n\r\n    function releaseAllProfit() public onlyOwner {\r\n        for (uint i = 0; i<logIndex; i++) {\r\n            releaseProfit(i);\r\n        }\r\n    }\r\n\r\n\r\n    function setLevel(address _address, uint8 level, bool sendProfit) public onlyOwner {\r\n        levels[_address] = level;\r\n\r\n        emit SetLevel(_address, level);\r\n        if (sendProfit) {\r\n            uint num = levelProfit[uint(level)];\r\n            if (num > 0) {\r\n                transferFromPool(_address, num);\r\n                emit SendLevelProfit(_address, level, num);\r\n            }\r\n        }\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public {\r\n        address parentAddress = parent(msg.sender);\r\n        if (_value == recommendNum && parentAddress == address(0) && !checkIsCycle(msg.sender, _to)) {\r\n            IterableMapping.insert(accounts, msg.sender, _to, addressInfos[msg.sender].activated);\r\n            AddressInfo storage info = addressInfos[_to];\r\n            info.children.push(msg.sender);\r\n            super.transfer(_to, _value);\r\n            emit SetParent(msg.sender, _to);\r\n        } else if (_to == contractAddress) {\r\n            super.transfer(_to, _value);\r\n            // Static income\r\n            uint profitKey = getProfitLevelNum(_value);\r\n            StaticProfit storage profit = profits[profitKey];\r\n            if (profit.num > 0) {\r\n                profitLogs[logIndex] = ProfitLog({_address:msg.sender, levelNum:profit.num, num : _value, day : profit.day, rate : profit.rate, getDay : 0, updatedAt: 0});\r\n            }\r\n            //activate user\r\n            addressInfos[msg.sender].profitsIndex.push(logIndex);\r\n            logIndex++;\r\n            if (profitKey >= 1000) {\r\n                addressInfos[msg.sender].activated = true;\r\n                IterableMapping.insert(accounts, msg.sender, parentAddress, true);\r\n            }\r\n            //Dynamic  income\r\n            if (profitKey > 0 && addressInfos[msg.sender].activated) {\r\n                sendBuyShare(msg.sender, profitKey);\r\n            }\r\n\r\n        } else {\r\n            super.transfer(_to, _value);\r\n        }\r\n    }\r\n\r\n    function transferFromPool(address _to, uint _value) internal {\r\n        balances[pool] = balances[pool].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(pool, _to, _value);\r\n    }\r\n\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public onlyOwner  {\r\n        require(!isBlackListed[_from]);\r\n\r\n        //        var _allowance = allowed[_from][msg.sender];\r\n\r\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n        // if (_value > _allowance) throw;\r\n\r\n        uint fee = (_value.mul(basisPointsRate)).div(10000);\r\n        if (fee > maximumFee) {\r\n            fee = maximumFee;\r\n        }\r\n        //        if (_allowance < MAX_UINT) {\r\n        //            allowed[_from][msg.sender] = _allowance.sub(_value);\r\n        //        }\r\n        uint sendAmount = _value.sub(fee);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(sendAmount);\r\n        if (fee > 0) {\r\n            balances[owner] = balances[owner].add(fee);\r\n            emit Transfer(_from, owner, fee);\r\n        }\r\n        emit Transfer(_from, _to, sendAmount);\r\n    }\r\n\r\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\r\n    function balanceOf(address who) public constant returns (uint) {\r\n        return super.balanceOf(who);\r\n    }\r\n\r\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\r\n    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\r\n        return super.allowance(_owner, _spender);\r\n    }\r\n\r\n    // deprecate current contract if favour of a new one\r\n    function totalSupply() public constant returns (uint) {\r\n        return totalSupplyNum;\r\n    }\r\n\r\n\r\n    event SetShareRateConfig(uint level, uint oldRate, uint newRate);\r\n    event SetProfitConfig(uint num, uint8 day, uint8 rate);\r\n    event SetParent(address _childAddress, address _parentAddress);\r\n    event SetLevel(address _address, uint8 level);\r\n    event SendLevelProfit(address _address, uint8 level,uint num);\r\n    event ReleaseProfit(address _address, uint num, uint8 day);\r\n    event BuyShare(address from, address to, uint num);\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"keyIndex\",\"type\":\"uint256\"}],\"name\":\"iterate_valid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_evilUser\",\"type\":\"address\"}],\"name\":\"addBlackList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"peer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foundation3\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"level\",\"type\":\"uint8\"},{\"name\":\"sendProfit\",\"type\":\"bool\"}],\"name\":\"setLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAddressActiveChildrenCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"setRecommendNum\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"profits\",\"outputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"day\",\"type\":\"uint8\"},{\"name\":\"rate\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foundation2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"iterate_start\",\"outputs\":[{\"name\":\"keyIndex\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foundation1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"levels\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAddressProfitNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_maker\",\"type\":\"address\"}],\"name\":\"getBlackListStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"keyIndex\",\"type\":\"uint256\"}],\"name\":\"iterate_get\",\"outputs\":[{\"name\":\"accountAddress\",\"type\":\"address\"},{\"name\":\"parentAddress\",\"type\":\"address\"},{\"name\":\"active\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"day\",\"type\":\"uint8\"},{\"name\":\"rate\",\"type\":\"uint8\"}],\"name\":\"setProfitConfig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseAllProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"recommendNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"releaseProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"shareRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupplyNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foundation0\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"setLevelProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"keyIndex\",\"type\":\"uint256\"}],\"name\":\"iterate_next\",\"outputs\":[{\"name\":\"r_keyIndex\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressInfos\",\"outputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"activated\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setShareRateConfig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"basisPointsRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"profitLogs\",\"outputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"levelNum\",\"type\":\"uint256\"},{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"day\",\"type\":\"uint8\"},{\"name\":\"rate\",\"type\":\"uint8\"},{\"name\":\"getDay\",\"type\":\"uint8\"},{\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBlackListed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_clearedUser\",\"type\":\"address\"}],\"name\":\"removeBlackList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_UINT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"parent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foundation4\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_blackListedUser\",\"type\":\"address\"}],\"name\":\"destroyBlackFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"candy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAddressProfitLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"SetShareRateConfig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"num\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"day\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint8\"}],\"name\":\"SetProfitConfig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_childAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_parentAddress\",\"type\":\"address\"}],\"name\":\"SetParent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"SetLevel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"SendLevelProfit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"num\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"day\",\"type\":\"uint8\"}],\"name\":\"ReleaseProfit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"BuyShare\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_blackListedUser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"DestroyedBlackFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"AddedBlackList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"RemovedBlackList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"CtgToken","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000963746720746f6b656e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034354470000000000000000000000000000000000000000000000000000000000","Library":"","LicenseType":"None","SwarmSource":"bzzr://bbfaead02c1ba2201279c3f7e52fb55011d8438370fa86a5e23086decf0504bd"}]}