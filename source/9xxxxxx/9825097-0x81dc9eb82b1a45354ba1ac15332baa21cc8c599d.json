{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.4;\n\n\n/// @title Utils\n/// @notice Utils contract for various helpers used by the Raiden Network smart\n/// contracts.\ncontract Utils {\n    enum MessageTypeId {\n        None,\n        BalanceProof,\n        BalanceProofUpdate,\n        Withdraw,\n        CooperativeSettle,\n        IOU,\n        MSReward\n    }\n\n    /// @notice Check if a contract exists\n    /// @param contract_address The address to check whether a contract is\n    /// deployed or not\n    /// @return True if a contract exists, false otherwise\n    function contractExists(address contract_address) public view returns (bool) {\n        uint size;\n\n        assembly {\n            size := extcodesize(contract_address)\n        }\n\n        return size > 0;\n    }\n}\n\n\ninterface Token {\n\n    /// @return supply total amount of tokens\n    function totalSupply() external view returns (uint256 supply);\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return balance The balance\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    // Optionally implemented function to show the number of decimals for the token\n    function decimals() external view returns (uint8 decimals);\n}\n\ncontract ServiceRegistryConfigurableParameters {\n    address public controller;\n\n    modifier onlyController() {\n        require(msg.sender == controller, \"caller is not the controller\");\n        _;\n    }\n\n    // After a price is set to set_price at timestamp set_price_at,\n    // the price decays according to decayedPrice().\n    uint256 public set_price;\n    uint256 public set_price_at;\n\n    /// The amount of time (in seconds) till the price decreases to roughly 1/e.\n    uint256 public decay_constant = 200 days;\n\n    // Once the price is at min_price, it can't decay further.\n    uint256 public min_price = 1000;\n\n    // Whenever a deposit comes in, the price is multiplied by numerator / denominator.\n    uint256 public price_bump_numerator = 1;\n    uint256 public price_bump_denominator = 1;\n\n    // The duration of service registration/extension in seconds\n    uint256 public registration_duration = 180 days;\n\n    // If true, new deposits are no longer accepted.\n    bool public deprecated = false;\n\n    function setDeprecationSwitch() public onlyController returns (bool _success) {\n        deprecated = true;\n        return true;\n    }\n\n    function changeParameters(\n            uint256 _price_bump_numerator,\n            uint256 _price_bump_denominator,\n            uint256 _decay_constant,\n            uint256 _min_price,\n            uint256 _registration_duration\n    ) public onlyController returns (bool _success) {\n        changeParametersInternal(\n            _price_bump_numerator,\n            _price_bump_denominator,\n            _decay_constant,\n            _min_price,\n            _registration_duration\n        );\n        return true;\n    }\n\n    function changeParametersInternal(\n            uint256 _price_bump_numerator,\n            uint256 _price_bump_denominator,\n            uint256 _decay_constant,\n            uint256 _min_price,\n            uint256 _registration_duration\n    ) internal {\n        refreshPrice();\n        setPriceBumpParameters(_price_bump_numerator, _price_bump_denominator);\n        setMinPrice(_min_price);\n        setDecayConstant(_decay_constant);\n        setRegistrationDuration(_registration_duration);\n    }\n\n    // Updates set_price to be currentPrice() and set_price_at to be now\n    function refreshPrice() private {\n        set_price = currentPrice();\n        set_price_at = now;\n    }\n\n    function setPriceBumpParameters(\n            uint256 _price_bump_numerator,\n            uint256 _price_bump_denominator\n    ) private {\n        require(_price_bump_denominator > 0, \"divide by zero\");\n        require(_price_bump_numerator >= _price_bump_denominator, \"price dump instead of bump\");\n        require(_price_bump_numerator < 2 ** 40, \"price dump numerator is too big\");\n        price_bump_numerator = _price_bump_numerator;\n        price_bump_denominator = _price_bump_denominator;\n    }\n\n    function setMinPrice(uint256 _min_price) private {\n        // No checks.  Even allowing zero.\n        min_price = _min_price;\n        // No checks or modifications on set_price.\n        // Even if set_price is smaller than min_price, currentPrice() function returns min_price.\n    }\n\n    function setDecayConstant(uint256 _decay_constant) private {\n        require(_decay_constant > 0, \"attempt to set zero decay constant\");\n        require(_decay_constant < 2 ** 40, \"too big decay constant\");\n        decay_constant = _decay_constant;\n    }\n\n    function setRegistrationDuration(uint256 _registration_duration) private {\n        // No checks.  Even allowing zero (when no new registrations are possible).\n        registration_duration = _registration_duration;\n    }\n\n\n    /// @notice The amount to deposit for registration or extension\n    /// Note: the price moves quickly depending on what other addresses do.\n    /// The current price might change after you send a `deposit()` transaction\n    /// before the transaction is executed.\n    function currentPrice() public view returns (uint256) {\n        require(now >= set_price_at, \"An underflow in price computation\");\n        uint256 seconds_passed = now - set_price_at;\n\n        return decayedPrice(set_price, seconds_passed);\n    }\n\n\n    /// @notice Calculates the decreased price after a number of seconds\n    /// @param _set_price The initial price\n    /// @param _seconds_passed The number of seconds passed since the initial\n    /// price was set\n    function decayedPrice(uint256 _set_price, uint256 _seconds_passed) public\n        view returns (uint256) {\n        // We are here trying to approximate some exponential decay.\n        // exp(- X / A) where\n        //   X is the number of seconds since the last price change\n        //   A is the decay constant (A = 200 days corresponds to 0.5% decrease per day)\n\n        // exp(- X / A) ~~ P / Q where\n        //   P = 24 A^4\n        //   Q = 24 A^4 + 24 A^3X + 12 A^2X^2 + 4 AX^3 + X^4\n        // Note: swap P and Q, and then think about the Taylor expansion.\n\n        uint256 X = _seconds_passed;\n\n        if (X >= 2 ** 40) { // The computation below overflows.\n            return min_price;\n        }\n\n        uint256 A = decay_constant;\n\n        uint256 P = 24 * (A ** 4);\n        uint256 Q = P + 24*(A**3)*X + 12*(A**2)*(X**2) + 4*A*(X**3) + X**4;\n\n        // The multiplication below is not supposed to overflow because\n        // _set_price should be at most 2 ** 90 and\n        // P should be at most 24 * (2 ** 40).\n        uint256 price = _set_price * P / Q;\n\n        // Not allowing a price smaller than min_price.\n        // Once it's too low it's too low forever.\n        if (price < min_price) {\n            price = min_price;\n        }\n        return price;\n    }\n}\n\n\ncontract Deposit {\n    // This contract holds ERC20 tokens as deposit until a predetemined point of time.\n\n    // The ERC20 token contract that the deposit is about.\n    Token public token;\n\n    // The address of ServiceRegistry contract that this deposit is associated with.\n    // If the address has no code, service_registry.deprecated() call will fail.\n    ServiceRegistryConfigurableParameters service_registry;\n\n    // The address that can withdraw the deposit after the release time.\n    address public withdrawer;\n\n    // The timestamp after which the withdrawer can withdraw the deposit.\n    uint256 public release_at;\n\n    /// @param _token The address of the ERC20 token contract where the deposit is accounted\n    /// @param _release_at The timestap after which the withdrawer can withdraw the deposit\n    /// @param _withdrawer The address that can withdraw the deposit after the release time\n    /// @param _service_registry The address of ServiceRegistry whose deprecation enables immediate withdrawals\n    constructor(address _token, uint256 _release_at, address _withdrawer, address _service_registry) public {\n        token = Token(_token);\n        // Don't care even if it's in the past.\n        release_at = _release_at;\n        withdrawer = _withdrawer;\n        service_registry = ServiceRegistryConfigurableParameters(_service_registry);\n    }\n\n    // In order to make a deposit, transfer the ERC20 token into this contract.\n    // If you transfer a wrong kind of ERC20 token or ETH into this contract,\n    // these tokens will be lost forever.\n\n    /// @notice Withdraws the tokens that have been deposited\n    /// Only `withdrawer` can call this.\n    /// @param _to The address where the withdrawn tokens should go\n    function withdraw(address payable _to) external {\n        uint256 balance = token.balanceOf(address(this));\n        require(msg.sender == withdrawer, \"the caller is not the withdrawer\");\n        require(now >= release_at || service_registry.deprecated(), \"deposit not released yet\");\n        require(balance > 0, \"nothing to withdraw\");\n        require(token.transfer(_to, balance), \"token didn't transfer\");\n        selfdestruct(_to); // The contract can disappear.\n    }\n}\n\n\ncontract ServiceRegistry is Utils, ServiceRegistryConfigurableParameters {\n    Token public token;\n\n    mapping(address => uint256) public service_valid_till;\n    mapping(address => string) public urls;  // URLs of services for HTTP access\n\n    // An append-only list of addresses that have ever made a deposit.\n    // Starting from this list, all alive registrations can be figured out.\n    address[] public ever_made_deposits;\n\n    // @param service The address of the registered service provider\n    // @param valid_till The timestamp of the moment when the registration expires\n    // @param deposit_amount The amount of deposit transferred\n    // @param deposit The address of Deposit instance where the deposit is stored\n    event RegisteredService(address indexed service, uint256 valid_till, uint256 deposit_amount, Deposit deposit_contract);\n\n    // @param _token_for_registration The address of the ERC20 token contract that services use for registration fees\n    // @param _controller The address that can change parameters and deprecate the ServiceRegistry\n    // @param _initial_price The amount of tokens needed initially for a slot\n    // @param _price_bump_numerator The ratio of price bump after deposit is made (numerator)\n    // @param _price_bump_denominator The ratio of price bump after deposit is made (denominator)\n    // @param _decay_constant The number of seconds after which the price becomes roughly 1/e\n    // @param _min_price The minimum amount of tokens needed for a slot\n    // @param _registration_duration The number of seconds (roughly, barring block time & miners'\n    // timestamp errors) of a slot gained for a successful deposit\n    constructor(\n            address _token_for_registration,\n            address _controller,\n            uint256 _initial_price,\n            uint256 _price_bump_numerator,\n            uint256 _price_bump_denominator,\n            uint256 _decay_constant,\n            uint256 _min_price,\n            uint256 _registration_duration\n    ) public {\n        require(_token_for_registration != address(0x0), \"token at address zero\");\n        require(contractExists(_token_for_registration), \"token has no code\");\n        require(_initial_price >= min_price, \"initial price too low\");\n        require(_initial_price <= 2 ** 90, \"intiial price too high\");\n\n        token = Token(_token_for_registration);\n        // Check if the contract is indeed a token contract\n        require(token.totalSupply() > 0, \"total supply zero\");\n        controller = _controller;\n\n        // Set up the price and the set price timestamp\n        set_price = _initial_price;\n        set_price_at = now;\n\n        // Set the parameters\n        changeParametersInternal(_price_bump_numerator, _price_bump_denominator, _decay_constant, _min_price, _registration_duration);\n    }\n\n    // @notice Locks tokens and registers a service or extends the registration\n    // @param _limit_amount The biggest amount of tokens that the caller is willing to deposit\n    // The call fails if the current price is higher (this is always possible\n    // when other parties have just called `deposit()`)\n    function deposit(uint _limit_amount) public returns (bool _success) {\n        require(! deprecated, \"this contract was deprecated\");\n\n        uint256 amount = currentPrice();\n        require(_limit_amount >= amount, \"not enough limit\");\n\n        // Extend the service position.\n        uint256 valid_till = service_valid_till[msg.sender];\n        if (valid_till == 0) { // a first time joiner\n            ever_made_deposits.push(msg.sender);\n        }\n        if (valid_till < now) { // a first time joiner or an expired service.\n            valid_till = now;\n        }\n        // Check against overflow.\n        require(valid_till < valid_till + registration_duration, \"overflow during extending the registration\");\n        valid_till = valid_till + registration_duration;\n        assert(valid_till > service_valid_till[msg.sender]);\n        service_valid_till[msg.sender] = valid_till;\n\n        // Record the price\n        set_price = amount * price_bump_numerator / price_bump_denominator;\n        if (set_price > 2 ** 90) {\n            set_price = 2 ** 90; // Preventing overflows.\n        }\n        set_price_at = now;\n\n        // Move the deposit in a new Deposit contract.\n        assert(now < valid_till);\n        Deposit depo = new Deposit(address(token), valid_till, msg.sender, address(this));\n        require(token.transferFrom(msg.sender, address(depo), amount), \"Token transfer for deposit failed\");\n\n        // Fire event\n        emit RegisteredService(msg.sender, valid_till, amount, depo);\n\n        return true;\n    }\n\n    /// @notice Sets the URL used to access a service via HTTP\n    /// Only a currently registered service can call this successfully\n    /// @param new_url The new URL string to be stored\n    function setURL(string memory new_url) public returns (bool _success) {\n        require(hasValidRegistration(msg.sender), \"registration expired\");\n        require(bytes(new_url).length != 0, \"new url is empty string\");\n        urls[msg.sender] = new_url;\n        return true;\n    }\n\n    /// A getter function for seeing the length of ever_made_deposits array\n    function everMadeDepositsLen() public view returns (uint256 _len) {\n        return ever_made_deposits.length;\n    }\n\n    function hasValidRegistration(address _address) public view returns (bool _has_registration) {\n        return now < service_valid_till[_address];\n    }\n}\n\n\n// MIT License\n\n// Copyright (c) 2018\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n\ncontract UserDeposit is Utils {\n    uint constant public withdraw_delay = 100;  // time before withdraw is allowed in blocks\n\n    // Token to be used for the deposit\n    Token public token;\n\n    // Trusted contracts (can execute `transfer`)\n    address public msc_address;\n    address public one_to_n_address;\n\n    // Total amount of tokens that have been deposited. This is monotonous and\n    // doing a transfer or withdrawing tokens will not decrease total_deposit!\n    mapping(address => uint256) public total_deposit;\n    // Current user's balance, ignoring planned withdraws\n    mapping(address => uint256) public balances;\n    mapping(address => WithdrawPlan) public withdraw_plans;\n\n    // The sum of all balances\n    uint256 public whole_balance = 0;\n    // Deposit limit for this whole contract\n    uint256 public whole_balance_limit;\n\n    /*\n     *  Structs\n     */\n    struct WithdrawPlan {\n        uint256 amount;\n        uint256 withdraw_block;  // earliest block at which withdraw is allowed\n    }\n\n    /*\n     *  Events\n     */\n\n    event BalanceReduced(address indexed owner, uint newBalance);\n    event WithdrawPlanned(address indexed withdrawer, uint plannedBalance);\n\n    /*\n     *  Modifiers\n     */\n\n    modifier canTransfer() {\n        require(msg.sender == msc_address || msg.sender == one_to_n_address, \"unknown caller\");\n        _;\n    }\n\n    /*\n     *  Constructor\n     */\n\n    /// @notice Set the default values for the smart contract\n    /// @param _token_address The address of the token to use for rewards\n    constructor(address _token_address, uint256 _whole_balance_limit)\n        public\n    {\n        // check token contract\n        require(_token_address != address(0x0), \"token at address zero\");\n        require(contractExists(_token_address), \"token has no code\");\n        token = Token(_token_address);\n        require(token.totalSupply() > 0, \"token has no total supply\"); // Check if the contract is indeed a token contract\n        // check and set the whole balance limit\n        require(_whole_balance_limit > 0, \"whole balance limit is zero\");\n        whole_balance_limit = _whole_balance_limit;\n    }\n\n    /// @notice Specify trusted contracts. This has to be done outside of the\n    /// constructor to avoid cyclic dependencies.\n    /// @param _msc_address Address of the MonitoringService contract\n    /// @param _one_to_n_address Address of the OneToN contract\n    function init(address _msc_address, address _one_to_n_address)\n        external\n    {\n        // prevent changes of trusted contracts after initialization\n        require(msc_address == address(0x0) && one_to_n_address == address(0x0), \"already initialized\");\n\n        // check monitoring service contract\n        require(_msc_address != address(0x0), \"MS contract at address zero\");\n        require(contractExists(_msc_address), \"MS contract has no code\");\n        msc_address = _msc_address;\n\n        // check one to n contract\n        require(_one_to_n_address != address(0x0), \"OneToN at address zero\");\n        require(contractExists(_one_to_n_address), \"OneToN has no code\");\n        one_to_n_address = _one_to_n_address;\n    }\n\n    /// @notice Deposit tokens. The amount of transferred tokens will be\n    /// `new_total_deposit - total_deposit[beneficiary]`. This makes the\n    /// function behavior predictable and idempotent. Can be called several\n    /// times and on behalf of other accounts.\n    /// @param beneficiary The account benefiting from the deposit\n    /// @param new_total_deposit The total sum of tokens that have been\n    /// deposited by the user by calling this function.\n    function deposit(address beneficiary, uint256 new_total_deposit)\n        external\n    {\n        require(new_total_deposit > total_deposit[beneficiary], \"deposit not increasing\");\n\n        // Calculate the actual amount of tokens that will be transferred\n        uint256 added_deposit = new_total_deposit - total_deposit[beneficiary];\n\n        balances[beneficiary] += added_deposit;\n        total_deposit[beneficiary] += added_deposit;\n\n        // Update whole_balance, but take care against overflows.\n        require(whole_balance + added_deposit >= whole_balance, \"overflowing deposit\");\n        whole_balance += added_deposit;\n\n        // Decline deposit if the whole balance is bigger than the limit.\n        require(whole_balance <= whole_balance_limit, \"too much deposit\");\n\n        // Actual transfer.\n        require(token.transferFrom(msg.sender, address(this), added_deposit), \"tokens didn't transfer\");\n    }\n\n    /// @notice Internally transfer deposits between two addresses.\n    /// Sender and receiver must be different or the transaction will fail.\n    /// @param sender Account from which the amount will be deducted\n    /// @param receiver Account to which the amount will be credited\n    /// @param amount Amount of tokens to be transferred\n    /// @return success true if transfer has been done successfully, otherwise false\n    function transfer(\n        address sender,\n        address receiver,\n        uint256 amount\n    )\n        canTransfer()\n        external\n        returns (bool success)\n    {\n        require(sender != receiver, \"sender == receiver\");\n        if (balances[sender] >= amount && amount > 0) {\n            balances[sender] -= amount;\n            balances[receiver] += amount;\n            emit BalanceReduced(sender, balances[sender]);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /// @notice Announce intention to withdraw tokens.\n    /// Sets the planned withdraw amount and resets the withdraw_block.\n    /// There is only one planned withdrawal at a time, the old one gets overwritten.\n    /// @param amount Maximum amount of tokens to be withdrawn\n    function planWithdraw(uint256 amount)\n        external\n    {\n        require(amount > 0, \"withdrawing zero\");\n        require(balances[msg.sender] >= amount, \"withdrawing too much\");\n\n        withdraw_plans[msg.sender] = WithdrawPlan({\n            amount: amount,\n            withdraw_block: block.number + withdraw_delay\n        });\n        emit WithdrawPlanned(msg.sender, balances[msg.sender] - amount);\n    }\n\n    /// @notice Execute a planned withdrawal\n    /// Will only work after the withdraw_delay has expired.\n    /// An amount lower or equal to the planned amount may be withdrawn.\n    /// Removes the withdraw plan even if not the full amount has been\n    /// withdrawn.\n    /// @param amount Amount of tokens to be withdrawn\n    function withdraw(uint256 amount)\n        external\n    {\n        WithdrawPlan storage withdraw_plan = withdraw_plans[msg.sender];\n        require(amount <= withdraw_plan.amount, \"withdrawing more than planned\");\n        require(withdraw_plan.withdraw_block <= block.number, \"withdrawing too early\");\n        uint256 withdrawable = min(amount, balances[msg.sender]);\n        balances[msg.sender] -= withdrawable;\n\n        // Update whole_balance, but take care against underflows.\n        require(whole_balance - withdrawable <= whole_balance, \"underflow in whole_balance\");\n        whole_balance -= withdrawable;\n\n        emit BalanceReduced(msg.sender, balances[msg.sender]);\n        delete withdraw_plans[msg.sender];\n\n        require(token.transfer(msg.sender, withdrawable), \"tokens didn't transfer\");\n    }\n\n    /// @notice The owner's balance with planned withdrawals deducted\n    /// @param owner Address for which the balance should be returned\n    /// @return remaining_balance The remaining balance after planned withdrawals\n    function effectiveBalance(address owner)\n        external\n        view\n        returns (uint256 remaining_balance)\n    {\n        WithdrawPlan storage withdraw_plan = withdraw_plans[owner];\n        if (withdraw_plan.amount > balances[owner]) {\n            return 0;\n        }\n        return balances[owner] - withdraw_plan.amount;\n    }\n\n    function min(uint256 a, uint256 b) pure internal returns (uint256)\n    {\n        return a > b ? b : a;\n    }\n}\n\n\n// MIT License\n\n// Copyright (c) 2018\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nlibrary ECVerify {\n\n    function ecverify(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address signature_address)\n    {\n        require(signature.length == 65);\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        assembly {\n            r := mload(add(signature, 32))\n            s := mload(add(signature, 64))\n\n            // Here we are loading the last 32 bytes, including 31 bytes following the signature.\n            v := byte(0, mload(add(signature, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible\n        if (v < 27) {\n            v += 27;\n        }\n\n        require(v == 27 || v == 28);\n\n        signature_address = ecrecover(hash, v, r, s);\n\n        // ecrecover returns zero on error\n        require(signature_address != address(0x0));\n\n        return signature_address;\n    }\n}\n\ncontract OneToN is Utils {\n    UserDeposit public deposit_contract;\n    ServiceRegistry public service_registry_contract;\n\n    // The signature given to claim() has to be computed with\n    // this chain_id.  Otherwise the call fails.\n    uint256 public chain_id;\n\n    // Indicates which sessions have already been settled by storing\n    // keccak256(receiver, sender, expiration_block) => expiration_block.\n    mapping (bytes32 => uint256) public settled_sessions;\n\n    /*\n     *  Events\n     */\n\n    // The session has been settled and can't be claimed again. The receiver is\n    // indexed to allow services to know when claims have been successfully\n    // processed.\n    // When users want to get notified about low balances, they should listen\n    // for UserDeposit.BalanceReduced, instead.\n    // The first three values identify the session, `transferred` is the amount\n    // of tokens that has actually been transferred during the claim.\n    event Claimed(\n        address sender,\n        address indexed receiver,\n        uint256 expiration_block,\n        uint256 transferred\n    );\n\n    /*\n     *  Constructor\n     */\n\n    /// @param _deposit_contract Address of UserDeposit contract\n    /// @param _service_registry_contract Address of ServiceRegistry contract\n    constructor(\n        address _deposit_contract,\n        uint256 _chain_id,\n        address _service_registry_contract\n    )\n        public\n    {\n        deposit_contract = UserDeposit(_deposit_contract);\n        chain_id = _chain_id;\n        service_registry_contract = ServiceRegistry(_service_registry_contract);\n    }\n\n    /// @notice Submit an IOU to claim the owed amount.\n    /// If the deposit is smaller than the claim, the remaining deposit is\n    /// claimed. If no tokens are claimed, `claim` may be retried, later.\n    /// @param sender Address from which the amount is transferred\n    /// @param receiver Address to which the amount is transferred\n    /// @param amount Owed amount of tokens\n    /// @param expiration_block Tokens can only be claimed before this time\n    /// @param one_to_n_address Address of this contract\n    /// @param signature Sender's signature over keccak256(sender, receiver, amount, expiration_block)\n    /// @return Amount of transferred tokens\n    function claim(\n        address sender,\n        address receiver,\n        uint256 amount,\n        uint256 expiration_block,\n        address one_to_n_address,\n        bytes memory signature\n    )\n        public\n        returns (uint)\n    {\n        require(service_registry_contract.hasValidRegistration(receiver), \"receiver not registered\");\n        require(block.number <= expiration_block, \"IOU expired\");\n\n        // validate signature\n        address addressFromSignature = recoverAddressFromSignature(\n            sender,\n            receiver,\n            amount,\n            expiration_block,\n            chain_id,\n            signature\n        );\n        require(addressFromSignature == sender, \"Signature mismatch\");\n\n        // must not be claimed before\n        bytes32 _key = keccak256(abi.encodePacked(receiver, sender, expiration_block));\n        require(settled_sessions[_key] == 0, \"Already settled session\");\n\n        // claim as much as possible\n        uint256 transferable = min(amount, deposit_contract.balances(sender));\n        if (transferable > 0) {\n            // register to avoid double claiming\n            settled_sessions[_key] = expiration_block;\n            assert(expiration_block > 0);\n            emit Claimed(sender, receiver, expiration_block, transferable);\n\n            require(deposit_contract.transfer(sender, receiver, transferable), \"deposit did not transfer\");\n        }\n        return transferable;\n    }\n\n    /// @notice Submit multiple IOUs to claim the owed amount.\n    /// This is the same as calling `claim` multiple times, except for the reduced gas cost.\n    /// @param senders Addresses from which the amounts are transferred\n    /// @param receivers Addresses to which the amounts are transferred\n    /// @param amounts Owed amounts of tokens\n    /// @param expiration_blocks Tokens can only be claimed before this time\n    /// @param one_to_n_address Address of this contract\n    /// @param signatures Sender's signatures concatenated into a single bytes array\n    /// @return Amount of transferred tokens\n    function bulkClaim(\n        address[] calldata senders,\n        address[] calldata receivers,\n        uint256[] calldata amounts,\n        uint256[] calldata expiration_blocks,\n        address one_to_n_address,\n        bytes calldata signatures\n    )\n        external\n        returns (uint)\n    {\n        uint256 transferable = 0;\n        require(\n            senders.length == receivers.length &&\n            senders.length == amounts.length &&\n            senders.length == expiration_blocks.length,\n            \"Same number of elements required for all input parameters\"\n        );\n        require(\n            signatures.length == senders.length * 65,\n            \"`signatures` should contain 65 bytes per IOU\"\n        );\n        for (uint256 i = 0; i < senders.length; i++) {\n            transferable += claim(\n                senders[i],\n                receivers[i],\n                amounts[i],\n                expiration_blocks[i],\n                one_to_n_address,\n                getSingleSignature(signatures, i)\n            );\n        }\n        return transferable;\n    }\n\n    /*\n     *  Internal Functions\n     */\n\n    /// @notice Get a single signature out of a byte array that contains concatenated signatures.\n    /// @param signatures Multiple signatures concatenated into a single byte array\n    /// @param i Index of the requested signature (zero based; the caller must check ranges)\n    function getSingleSignature(\n        bytes memory signatures,\n        uint256 i\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        assert(i < signatures.length);\n        uint256 offset = i * 65;\n        // We need only 65, but we can access only whole words, so the next usable size is 3 * 32.\n        bytes memory signature = new bytes(96);\n        assembly { // solium-disable-line security/no-inline-assembly\n            // Copy the 96 bytes, using `offset` to start at the beginning\n            // of the requested signature.\n            mstore(add(signature, 32), mload(add(add(signatures, 32), offset)))\n            mstore(add(signature, 64), mload(add(add(signatures, 64), offset)))\n            mstore(add(signature, 96), mload(add(add(signatures, 96), offset)))\n\n            // The first 32 bytes store the length of the dynamic array.\n            // Since a signature is 65 bytes, we set the length to 65, so\n            // that only the signature is returned.\n            mstore(signature, 65)\n        }\n        return signature;\n    }\n\n    function recoverAddressFromSignature(\n        address sender,\n        address receiver,\n        uint256 amount,\n        uint256 expiration_block,\n        uint256 chain_id,\n        bytes memory signature\n    )\n        internal\n        view\n        returns (address signature_address)\n    {\n        bytes32 message_hash = keccak256(abi.encodePacked(\n            \"\\x19Ethereum Signed Message:\\n188\",\n            address(this),\n            chain_id,\n            uint256(MessageTypeId.IOU),\n            sender,\n            receiver,\n            amount,\n            expiration_block\n        ));\n        return ECVerify.ecverify(message_hash, signature);\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256)\n    {\n        return a > b ? b : a;\n    }\n\n}\n\n\n// MIT License\n\n// Copyright (c) 2018\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_deposit_contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_chain_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_service_registry_contract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiration_block\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transferred\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"senders\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"receivers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"expiration_blocks\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"one_to_n_address\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"bulkClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chain_id\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration_block\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"one_to_n_address\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contract_address\",\"type\":\"address\"}],\"name\":\"contractExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit_contract\",\"outputs\":[{\"internalType\":\"contract UserDeposit\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"service_registry_contract\",\"outputs\":[{\"internalType\":\"contract ServiceRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"settled_sessions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"OneToN","CompilerVersion":"v0.6.4+commit.1dca32f3","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000015ac371ade21c4f31da36a4cf9a0ef35afde7a9f00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000fedbc2ef6c33030be69208c22bc107af37a8afc","Library":"","LicenseType":"","SwarmSource":""}]}