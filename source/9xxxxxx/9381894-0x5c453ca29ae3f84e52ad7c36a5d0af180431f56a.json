{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * @title Decentralized Autonomous Trust\r\n * This contract is the reference implementation provided by Fairmint for a\r\n * Decentralized Autonomous Trust as described in the continuous\r\n * organization whitepaper (https://github.com/c-org/whitepaper) and\r\n * specified here: https://github.com/fairmint/c-org/wiki. Use at your own\r\n * risk. If you have question or if you're looking for a ready-to-use\r\n * solution using this contract, you might be interested in Fairmint's\r\n * offering. Do not hesitate to get in touch with us: https://fairmint.co\r\n */\r\n\r\n\r\n// File: contracts\\interfaces\\IWhitelist.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n/**\r\n * Source: https://raw.githubusercontent.com/simple-restricted-token/reference-implementation/master/contracts/token/ERC1404/ERC1404.sol\r\n * With ERC-20 APIs removed (will be implemented as a separate contract).\r\n * And adding authorizeTransfer.\r\n */\r\ninterface IWhitelist\r\n{\r\n  /**\r\n   * @notice Detects if a transfer will be reverted and if so returns an appropriate reference code\r\n   * @param from Sending address\r\n   * @param to Receiving address\r\n   * @param value Amount of tokens being transferred\r\n   * @return Code by which to reference message for rejection reasoning\r\n   * @dev Overwrite with your custom transfer restriction logic\r\n   */\r\n  function detectTransferRestriction(\r\n    address from,\r\n    address to,\r\n    uint value\r\n  ) external view\r\n    returns (uint8);\r\n\r\n  /**\r\n   * @notice Returns a human-readable message for a given restriction code\r\n   * @param restrictionCode Identifier for looking up a message\r\n   * @return Text showing the restriction's reasoning\r\n   * @dev Overwrite with your custom message and restrictionCode handling\r\n   */\r\n  function messageForTransferRestriction(\r\n    uint8 restrictionCode\r\n  ) external pure\r\n    returns (string memory);\r\n\r\n  /**\r\n   * @notice Called by the DAT contract before a transfer occurs.\r\n   * @dev This call will revert when the transfer is not authorized.\r\n   * This is a mutable call to allow additional data to be recorded,\r\n   * such as when the user aquired their tokens.\r\n   */\r\n  function authorizeTransfer(\r\n    address _from,\r\n    address _to,\r\n    uint _value,\r\n    bool _isSell\r\n  ) external;\r\n}\r\n\r\n// File: @openzeppelin\\contracts-ethereum-package\\contracts\\math\\SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts\\math\\BigDiv.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title Reduces the size of terms before multiplication, to avoid an overflow, and then\r\n * restores the proper size after division.\r\n * @notice This effectively allows us to overflow values in the numerator and/or denominator\r\n * of a fraction, so long as the end result does not overflow as well.\r\n * @dev Results may be off by 1 + 0.000001% for 2x1 calls and 2 + 0.00001% for 2x2 calls.\r\n * Do not use if your contract expects very small result values to be accurate.\r\n */\r\nlibrary BigDiv\r\n{\r\n  using SafeMath for uint256;\r\n\r\n  /// @notice The max possible value\r\n  uint256 private constant MAX_UINT = 2**256 - 1;\r\n\r\n  /// @notice When multiplying 2 terms <= this value the result won't overflow\r\n  uint256 private constant MAX_BEFORE_SQUARE = 2**128 - 1;\r\n\r\n  /// @notice The max error target is off by 1 plus up to 0.000001% error\r\n  /// for bigDiv2x1 and that `* 2` for bigDiv2x2\r\n  uint256 private constant MAX_ERROR = 100000000;\r\n\r\n  /// @notice A larger error threshold to use when multiple rounding errors may apply\r\n  uint256 private constant MAX_ERROR_BEFORE_DIV = MAX_ERROR * 2;\r\n\r\n  /**\r\n   * @notice Returns the approx result of `a * b / d` so long as the result is <= MAX_UINT\r\n   * @param _numA the first numerator term\r\n   * @param _numB the second numerator term\r\n   * @param _den the denominator\r\n   * @return the approx result with up to off by 1 + MAX_ERROR, rounding down if needed\r\n   */\r\n  function bigDiv2x1(\r\n    uint256 _numA,\r\n    uint256 _numB,\r\n    uint256 _den\r\n  ) internal pure\r\n    returns(uint256)\r\n  {\r\n    if(_numA == 0 || _numB == 0)\r\n    {\r\n      // would div by 0 or underflow if we don't special case 0\r\n      return 0;\r\n    }\r\n\r\n    uint256 value;\r\n\r\n    if(MAX_UINT / _numA >= _numB)\r\n    {\r\n      // a*b does not overflow, return exact math\r\n      value = _numA * _numB;\r\n      value /= _den;\r\n      return value;\r\n    }\r\n\r\n    // Sort numerators\r\n    uint256 numMax = _numB;\r\n    uint256 numMin = _numA;\r\n    if(_numA > _numB)\r\n    {\r\n      numMax = _numA;\r\n      numMin = _numB;\r\n    }\r\n\r\n    value = numMax / _den;\r\n    if(value > MAX_ERROR)\r\n    {\r\n      // _den is small enough to be MAX_ERROR or better w/o a factor\r\n      value = value.mul(numMin);\r\n      return value;\r\n    }\r\n\r\n    // formula = ((a / f) * b) / (d / f)\r\n    // factor >= a / sqrt(MAX) * (b / sqrt(MAX))\r\n    uint256 factor = numMin - 1;\r\n    factor /= MAX_BEFORE_SQUARE;\r\n    factor += 1;\r\n    uint256 temp = numMax - 1;\r\n    temp /= MAX_BEFORE_SQUARE;\r\n    temp += 1;\r\n    if(MAX_UINT / factor >= temp)\r\n    {\r\n      factor *= temp;\r\n      value = numMax / factor;\r\n      if(value > MAX_ERROR_BEFORE_DIV)\r\n      {\r\n        value = value.mul(numMin);\r\n        temp = _den - 1;\r\n        temp /= factor;\r\n        temp = temp.add(1);\r\n        value /= temp;\r\n        return value;\r\n      }\r\n    }\r\n\r\n    // formula: (a / (d / f)) * (b / f)\r\n    // factor: b / sqrt(MAX)\r\n    factor = numMin - 1;\r\n    factor /= MAX_BEFORE_SQUARE;\r\n    factor += 1;\r\n    value = numMin / factor;\r\n    temp = _den - 1;\r\n    temp /= factor;\r\n    temp += 1;\r\n    temp = numMax / temp;\r\n    value = value.mul(temp);\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the approx result of `a * b / d` so long as the result is <= MAX_UINT\r\n   * @param _numA the first numerator term\r\n   * @param _numB the second numerator term\r\n   * @param _den the denominator\r\n   * @return the approx result with up to off by 1 + MAX_ERROR, rounding down if needed\r\n   * @dev roundUp is implemented by first rounding down and then adding the max error to the result\r\n   */\r\n  function bigDiv2x1RoundUp(\r\n    uint256 _numA,\r\n    uint256 _numB,\r\n    uint256 _den\r\n  ) internal pure\r\n    returns(uint256)\r\n  {\r\n    // first get the rounded down result\r\n    uint256 value = bigDiv2x1(_numA, _numB, _den);\r\n\r\n    if(value == 0)\r\n    {\r\n      // when the value rounds down to 0, assume up to an off by 1 error\r\n      return 1;\r\n    }\r\n\r\n    // round down has a max error of MAX_ERROR, add that to the result\r\n    // for a round up error of <= MAX_ERROR\r\n    uint256 temp = value - 1;\r\n    temp /= MAX_ERROR;\r\n    temp += 1;\r\n    if(MAX_UINT - value < temp)\r\n    {\r\n      // value + error would overflow, return MAX\r\n      return MAX_UINT;\r\n    }\r\n\r\n    value += temp;\r\n\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the approx result of `a * b / (c * d)` so long as the result is <= MAX_UINT\r\n   * @param _numA the first numerator term\r\n   * @param _numB the second numerator term\r\n   * @param _denA the first denominator term\r\n   * @param _denB the second denominator term\r\n   * @return the approx result with up to off by 2 + MAX_ERROR*10 error, rounding down if needed\r\n   * @dev this uses bigDiv2x1 and adds additional rounding error so the max error of this\r\n   * formula is larger\r\n   */\r\n  function bigDiv2x2(\r\n    uint256 _numA,\r\n    uint256 _numB,\r\n    uint256 _denA,\r\n    uint256 _denB\r\n  ) internal pure\r\n    returns (uint256)\r\n  {\r\n    if(MAX_UINT / _denA >= _denB)\r\n    {\r\n      // denA*denB does not overflow, use bigDiv2x1 instead\r\n      return bigDiv2x1(_numA, _numB, _denA * _denB);\r\n    }\r\n\r\n    if(_numA == 0 || _numB == 0)\r\n    {\r\n      // would div by 0 or underflow if we don't special case 0\r\n      return 0;\r\n    }\r\n\r\n    // Sort denominators\r\n    uint256 denMax = _denB;\r\n    uint256 denMin = _denA;\r\n    if(_denA > _denB)\r\n    {\r\n      denMax = _denA;\r\n      denMin = _denB;\r\n    }\r\n\r\n    uint256 value;\r\n\r\n    if(MAX_UINT / _numA >= _numB)\r\n    {\r\n      // a*b does not overflow, use `a / d / c`\r\n      value = _numA * _numB;\r\n      value /= denMin;\r\n      value /= denMax;\r\n      return value;\r\n    }\r\n\r\n    // `ab / cd` where both `ab` and `cd` would overflow\r\n\r\n    // Sort numerators\r\n    uint256 numMax = _numB;\r\n    uint256 numMin = _numA;\r\n    if(_numA > _numB)\r\n    {\r\n      numMax = _numA;\r\n      numMin = _numB;\r\n    }\r\n\r\n    // formula = (a/d) * b / c\r\n    uint256 temp = numMax / denMin;\r\n    if(temp > MAX_ERROR_BEFORE_DIV)\r\n    {\r\n      return bigDiv2x1(temp, numMin, denMax);\r\n    }\r\n\r\n    // formula: ((a/f) * b) / d then either * f / c or / c * f\r\n    // factor >= a / sqrt(MAX) * (b / sqrt(MAX))\r\n    uint256 factor = numMin - 1;\r\n    factor /= MAX_BEFORE_SQUARE;\r\n    factor += 1;\r\n    temp = numMax - 1;\r\n    temp /= MAX_BEFORE_SQUARE;\r\n    temp += 1;\r\n    if(MAX_UINT / factor >= temp)\r\n    {\r\n      factor *= temp;\r\n\r\n      value = numMax / factor;\r\n      if(value > MAX_ERROR_BEFORE_DIV)\r\n      {\r\n        value = value.mul(numMin);\r\n        value /= denMin;\r\n        if(value > 0 && MAX_UINT / value >= factor)\r\n        {\r\n          value *= factor;\r\n          value /= denMax;\r\n          return value;\r\n        }\r\n      }\r\n    }\r\n\r\n    // formula: (a/f) * b / ((c*d)/f)\r\n    // factor >= c / sqrt(MAX) * (d / sqrt(MAX))\r\n    factor = denMin;\r\n    factor /= MAX_BEFORE_SQUARE;\r\n    temp = denMax;\r\n    // + 1 here prevents overflow of factor*temp\r\n    temp /= MAX_BEFORE_SQUARE + 1;\r\n    factor *= temp;\r\n    return bigDiv2x1(numMax / factor, numMin, MAX_UINT);\r\n  }\r\n}\r\n\r\n// File: contracts\\math\\Sqrt.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title Calculates the square root of a given value.\r\n * @dev Results may be off by 1.\r\n */\r\nlibrary Sqrt\r\n{\r\n  /// @notice The max possible value\r\n  uint256 private constant MAX_UINT = 2**256 - 1;\r\n\r\n  // Source: https://github.com/ethereum/dapp-bin/pull/50\r\n  function sqrt(\r\n    uint x\r\n  ) internal pure\r\n    returns (uint y)\r\n  {\r\n    if (x == 0)\r\n    {\r\n      return 0;\r\n    }\r\n    else if (x <= 3)\r\n    {\r\n      return 1;\r\n    }\r\n    else if (x == MAX_UINT)\r\n    {\r\n      // Without this we fail on x + 1 below\r\n      return 2**128 - 1;\r\n    }\r\n\r\n    uint z = (x + 1) / 2;\r\n    y = x;\r\n    while (z < y)\r\n    {\r\n      y = z;\r\n      z = (x / z + z) / 2;\r\n    }\r\n  }\r\n}\r\n\r\n// File: @openzeppelin\\contracts-ethereum-package\\contracts\\token\\ERC20\\IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: node_modules\\@openzeppelin\\contracts-ethereum-package\\contracts\\utils\\Address.sol\r\n\r\npragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\contracts-ethereum-package\\contracts\\token\\ERC20\\SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\upgrades\\contracts\\Initializable.sol\r\n\r\npragma solidity >=0.4.24 <0.6.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: node_modules\\@openzeppelin\\contracts-ethereum-package\\contracts\\GSN\\Context.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context is Initializable {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\contracts-ethereum-package\\contracts\\token\\ERC20\\ERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20Mintable}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Initializable, Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: @openzeppelin\\contracts-ethereum-package\\contracts\\token\\ERC20\\ERC20Detailed.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Optional functions from the ERC20 standard.\r\n */\r\ncontract ERC20Detailed is Initializable, IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\r\n     * these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts\\DecentralizedAutonomousTrust.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Decentralized Autonomous Trust\r\n * This contract is the reference implementation provided by Fairmint for a\r\n * Decentralized Autonomous Trust as described in the continuous\r\n * organization whitepaper (https://github.com/c-org/whitepaper) and\r\n * specified here: https://github.com/fairmint/c-org/wiki. Use at your own\r\n * risk. If you have question or if you're looking for a ready-to-use\r\n * solution using this contract, you might be interested in Fairmint's\r\n * offering. Do not hesitate to get in touch with us: https://fairmint.co\r\n */\r\ncontract DecentralizedAutonomousTrust\r\n  is ERC20, ERC20Detailed\r\n{\r\n  using SafeMath for uint;\r\n  using Sqrt for uint;\r\n  using SafeERC20 for IERC20;\r\n\r\n  /**\r\n   * Events\r\n   */\r\n\r\n  event Buy(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint _currencyValue,\r\n    uint _fairValue\r\n  );\r\n  event Sell(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint _currencyValue,\r\n    uint _fairValue\r\n  );\r\n  event Burn(\r\n    address indexed _from,\r\n    uint _fairValue\r\n  );\r\n  event Pay(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint _currencyValue,\r\n    uint _fairValue\r\n  );\r\n  event Close(\r\n    uint _exitFee\r\n  );\r\n  event StateChange(\r\n    uint _previousState,\r\n    uint _newState\r\n  );\r\n  event UpdateConfig(\r\n    address _whitelistAddress,\r\n    address indexed _beneficiary,\r\n    address indexed _control,\r\n    address indexed _feeCollector,\r\n    bool _autoBurn,\r\n    uint _revenueCommitmentBasisPoints,\r\n    uint _feeBasisPoints,\r\n    uint _minInvestment,\r\n    uint _openUntilAtLeast\r\n  );\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  /// @notice The default state\r\n  uint private constant STATE_INIT = 0;\r\n\r\n  /// @notice The state after initGoal has been reached\r\n  uint private constant STATE_RUN = 1;\r\n\r\n  /// @notice The state after closed by the `beneficiary` account from STATE_RUN\r\n  uint private constant STATE_CLOSE = 2;\r\n\r\n  /// @notice The state after closed by the `beneficiary` account from STATE_INIT\r\n  uint private constant STATE_CANCEL = 3;\r\n\r\n  /// @notice When multiplying 2 terms, the max value is 2^128-1\r\n  uint private constant MAX_BEFORE_SQUARE = 2**128 - 1;\r\n\r\n  /// @notice The denominator component for values specified in basis points.\r\n  uint private constant BASIS_POINTS_DEN = 10000;\r\n\r\n  /// @notice The max `totalSupply() + burnedSupply`\r\n  /// @dev This limit ensures that the DAT's formulas do not overflow (<MAX_BEFORE_SQUARE/2)\r\n  uint private constant MAX_SUPPLY = 10 ** 38;\r\n\r\n  /**\r\n   * Data specific to our token business logic\r\n   */\r\n\r\n  /// @notice The contract for transfer authorizations, if any.\r\n  IWhitelist public whitelist;\r\n\r\n  /// @notice The total number of burned FAIR tokens, excluding tokens burned from a `Sell` action in the DAT.\r\n  uint public burnedSupply;\r\n\r\n  /**\r\n   * Data for DAT business logic\r\n   */\r\n\r\n  /// @notice Set if the FAIRs minted by the organization when it commits its revenues are\r\n  /// automatically burnt (`true`) or not (`false`). Defaults to `false` meaning that there\r\n  /// is no automatic burn.\r\n  bool public autoBurn;\r\n\r\n  /// @notice The address of the beneficiary organization which receives the investments.\r\n  /// Points to the wallet of the organization.\r\n  address payable public beneficiary;\r\n\r\n  /// @notice The buy slope of the bonding curve.\r\n  /// Does not affect the financial model, only the granularity of FAIR.\r\n  /// @dev This is the numerator component of the fractional value.\r\n  uint public buySlopeNum;\r\n\r\n  /// @notice The buy slope of the bonding curve.\r\n  /// Does not affect the financial model, only the granularity of FAIR.\r\n  /// @dev This is the denominator component of the fractional value.\r\n  uint public buySlopeDen;\r\n\r\n  /// @notice The address from which the updatable variables can be updated\r\n  address public control;\r\n\r\n  /// @notice The address of the token used as reserve in the bonding curve\r\n  /// (e.g. the DAI contract). Use ETH if 0.\r\n  IERC20 public currency;\r\n\r\n  /// @notice The address where fees are sent.\r\n  address payable public feeCollector;\r\n\r\n  /// @notice The percent fee collected each time new FAIR are issued expressed in basis points.\r\n  uint public feeBasisPoints;\r\n\r\n  /// @notice The initial fundraising goal (expressed in FAIR) to start the c-org.\r\n  /// `0` means that there is no initial fundraising and the c-org immediately moves to run state.\r\n  uint public initGoal;\r\n\r\n  /// @notice A map with all investors in init state using address as a key and amount as value.\r\n  /// @dev This structure's purpose is to make sure that only investors can withdraw their money if init_goal is not reached.\r\n  mapping(address => uint) public initInvestors;\r\n\r\n  /// @notice The initial number of FAIR created at initialization for the beneficiary.\r\n  /// Technically however, this variable is not a constant as we must always have\r\n  ///`init_reserve>=total_supply+burnt_supply` which means that `init_reserve` will be automatically\r\n  /// decreased to equal `total_supply+burnt_supply` in case `init_reserve>total_supply+burnt_supply`\r\n  /// after an investor sells his FAIRs.\r\n  /// @dev Organizations may move these tokens into vesting contract(s)\r\n  uint public initReserve;\r\n\r\n  /// @notice The investment reserve of the c-org. Defines the percentage of the value invested that is\r\n  /// automatically funneled and held into the buyback_reserve expressed in basis points.\r\n  uint public investmentReserveBasisPoints;\r\n\r\n  /// @notice The earliest date/time (in seconds) that the DAT may enter the `CLOSE` state, ensuring\r\n  /// that if the DAT reaches the `RUN` state it will remain running for at least this period of time.\r\n  /// @dev This value may be increased anytime by the control account\r\n  uint public openUntilAtLeast;\r\n\r\n  /// @notice The minimum amount of `currency` investment accepted.\r\n  uint public minInvestment;\r\n\r\n  /// @notice The revenue commitment of the organization. Defines the percentage of the value paid through the contract\r\n  /// that is automatically funneled and held into the buyback_reserve expressed in basis points.\r\n  uint public revenueCommitmentBasisPoints;\r\n\r\n  /// @notice The current state of the contract.\r\n  /// @dev See the constants above for possible state values.\r\n  uint public state;\r\n\r\n  string public constant version = \"2\";\r\n  // --- EIP712 niceties ---\r\n  // Original source: https://etherscan.io/address/0x6b175474e89094c44da98b954eedeac495271d0f#code\r\n  mapping (address => uint) public nonces;\r\n  bytes32 public DOMAIN_SEPARATOR;\r\n  // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\");\r\n  bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\r\n\r\n  modifier authorizeTransfer(\r\n    address _from,\r\n    address _to,\r\n    uint _value,\r\n    bool _isSell\r\n  )\r\n  {\r\n    if(address(whitelist) != address(0))\r\n    {\r\n      // This is not set for the minting of initialReserve\r\n      whitelist.authorizeTransfer(_from, _to, _value, _isSell);\r\n    }\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Buyback reserve\r\n   */\r\n\r\n  /// @notice The total amount of currency value currently locked in the contract and available to sellers.\r\n  function buybackReserve() public view returns (uint)\r\n  {\r\n    uint reserve = address(this).balance;\r\n    if(address(currency) != address(0))\r\n    {\r\n      reserve = currency.balanceOf(address(this));\r\n    }\r\n\r\n    if(reserve > MAX_BEFORE_SQUARE)\r\n    {\r\n      /// Math: If the reserve becomes excessive, cap the value to prevent overflowing in other formulas\r\n      return MAX_BEFORE_SQUARE;\r\n    }\r\n\r\n    return reserve;\r\n  }\r\n\r\n  /**\r\n   * Functions required for the whitelist\r\n   */\r\n\r\n  function _detectTransferRestriction(\r\n    address _from,\r\n    address _to,\r\n    uint _value\r\n  ) private view\r\n    returns (uint)\r\n  {\r\n    if(address(whitelist) != address(0))\r\n    {\r\n      // This is not set for the minting of initialReserve\r\n      return whitelist.detectTransferRestriction(_from, _to, _value);\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Functions required by the ERC-20 token standard\r\n   */\r\n\r\n  /// @dev Moves tokens from one account to another if authorized.\r\n  function _transfer(\r\n    address _from,\r\n    address _to,\r\n    uint _amount\r\n  ) internal\r\n    authorizeTransfer(_from, _to, _amount, false)\r\n  {\r\n    require(state != STATE_INIT || _from == beneficiary, \"ONLY_BENEFICIARY_DURING_INIT\");\r\n    super._transfer(_from, _to, _amount);\r\n  }\r\n\r\n  /// @dev Removes tokens from the circulating supply.\r\n  function _burn(\r\n    address _from,\r\n    uint _amount,\r\n    bool _isSell\r\n  ) internal\r\n    authorizeTransfer(_from, address(0), _amount, _isSell)\r\n  {\r\n    super._burn(_from, _amount);\r\n\r\n    if(!_isSell)\r\n    {\r\n      // This is a burn\r\n      require(state == STATE_RUN, \"ONLY_DURING_RUN\");\r\n      // SafeMath not required as we cap how high this value may get during mint\r\n      burnedSupply += _amount;\r\n      emit Burn(_from, _amount);\r\n    }\r\n  }\r\n\r\n  /// @notice Called to mint tokens on `buy`.\r\n  function _mint(\r\n    address _to,\r\n    uint _quantity\r\n  ) internal\r\n    authorizeTransfer(address(0), _to, _quantity, false)\r\n  {\r\n    super._mint(_to, _quantity);\r\n\r\n    // Math: If this value got too large, the DAT may overflow on sell\r\n    require(totalSupply().add(burnedSupply) <= MAX_SUPPLY, \"EXCESSIVE_SUPPLY\");\r\n  }\r\n\r\n  /**\r\n   * Transaction Helpers\r\n   */\r\n\r\n  /// @notice Confirms the transfer of `_quantityToInvest` currency to the contract.\r\n  function _collectInvestment(\r\n    uint _quantityToInvest,\r\n    uint _msgValue,\r\n    bool _refundRemainder\r\n  ) private\r\n  {\r\n    if(address(currency) == address(0))\r\n    {\r\n      // currency is ETH\r\n      if(_refundRemainder)\r\n      {\r\n        // Math: if _msgValue was not sufficient then revert\r\n        uint refund = _msgValue.sub(_quantityToInvest);\r\n        if(refund > 0)\r\n        {\r\n          Address.sendValue(msg.sender, refund);\r\n        }\r\n      }\r\n      else\r\n      {\r\n        require(_quantityToInvest == _msgValue, \"INCORRECT_MSG_VALUE\");\r\n      }\r\n    }\r\n    else\r\n    {\r\n      // currency is ERC20\r\n      require(_msgValue == 0, \"DO_NOT_SEND_ETH\");\r\n\r\n      currency.safeTransferFrom(msg.sender, address(this), _quantityToInvest);\r\n    }\r\n  }\r\n\r\n  /// @dev Send `_amount` currency from the contract to the `_to` account.\r\n  function _transferCurrency(\r\n    address payable _to,\r\n    uint _amount\r\n  ) private\r\n  {\r\n    if(_amount > 0)\r\n    {\r\n      if(address(currency) == address(0))\r\n      {\r\n        Address.sendValue(_to, _amount);\r\n      }\r\n      else\r\n      {\r\n        currency.safeTransfer(_to, _amount);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Config / Control\r\n   */\r\n\r\n  /// @notice Called once after deploy to set the initial configuration.\r\n  /// None of the values provided here may change once initially set.\r\n  /// @dev using the init pattern in order to support zos upgrades\r\n  function initialize(\r\n    uint _initReserve,\r\n    address _currencyAddress,\r\n    uint _initGoal,\r\n    uint _buySlopeNum,\r\n    uint _buySlopeDen,\r\n    uint _investmentReserveBasisPoints,\r\n    string memory _name,\r\n    string memory _symbol\r\n  ) public\r\n  {\r\n    require(control == address(0), \"ALREADY_INITIALIZED\");\r\n\r\n    ERC20Detailed.initialize(_name, _symbol, 18);\r\n\r\n    // Set initGoal, which in turn defines the initial state\r\n    if(_initGoal == 0)\r\n    {\r\n      emit StateChange(state, STATE_RUN);\r\n      state = STATE_RUN;\r\n    }\r\n    else\r\n    {\r\n      // Math: If this value got too large, the DAT would overflow on sell\r\n      require(_initGoal < MAX_SUPPLY, \"EXCESSIVE_GOAL\");\r\n      initGoal = _initGoal;\r\n    }\r\n\r\n    require(_buySlopeNum > 0, \"INVALID_SLOPE_NUM\");\r\n    require(_buySlopeDen > 0, \"INVALID_SLOPE_DEN\");\r\n    require(_buySlopeNum < MAX_BEFORE_SQUARE, \"EXCESSIVE_SLOPE_NUM\");\r\n    require(_buySlopeDen < MAX_BEFORE_SQUARE, \"EXCESSIVE_SLOPE_DEN\");\r\n    buySlopeNum = _buySlopeNum;\r\n    buySlopeDen = _buySlopeDen;\r\n    // 100% or less\r\n    require(_investmentReserveBasisPoints <= BASIS_POINTS_DEN, \"INVALID_RESERVE\");\r\n    investmentReserveBasisPoints = _investmentReserveBasisPoints;\r\n\r\n    // Set default values (which may be updated using `updateConfig`)\r\n    minInvestment = 100 ether;\r\n    beneficiary = msg.sender;\r\n    control = msg.sender;\r\n    feeCollector = msg.sender;\r\n\r\n    // Save currency\r\n    currency = IERC20(_currencyAddress);\r\n\r\n    // Mint the initial reserve\r\n    if(_initReserve > 0)\r\n    {\r\n      initReserve = _initReserve;\r\n      _mint(beneficiary, initReserve);\r\n    }\r\n  }\r\n  function getChainId(\r\n  ) private pure\r\n    returns (uint id)\r\n  {\r\n    // solium-disable-next-line\r\n    assembly\r\n    {\r\n      id := chainid()\r\n    }\r\n  }\r\n\r\n  function initializePermit(\r\n  ) public\r\n  {\r\n    DOMAIN_SEPARATOR = keccak256(\r\n      abi.encode(\r\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n        keccak256(bytes(name())),\r\n        keccak256(bytes(version)),\r\n        getChainId(),\r\n        address(this)\r\n      )\r\n    );\r\n  }\r\n\r\n  function updateConfig(\r\n    address _whitelistAddress,\r\n    address payable _beneficiary,\r\n    address _control,\r\n    address payable _feeCollector,\r\n    uint _feeBasisPoints,\r\n    bool _autoBurn,\r\n    uint _revenueCommitmentBasisPoints,\r\n    uint _minInvestment,\r\n    uint _openUntilAtLeast\r\n  ) public\r\n  {\r\n    // This require(also confirms that initialize has been called.\r\n    require(msg.sender == control, \"CONTROL_ONLY\");\r\n\r\n    // address(0) is okay\r\n    whitelist = IWhitelist(_whitelistAddress);\r\n\r\n    require(_control != address(0), \"INVALID_ADDRESS\");\r\n    control = _control;\r\n\r\n    require(_feeCollector != address(0), \"INVALID_ADDRESS\");\r\n    feeCollector = _feeCollector;\r\n\r\n    autoBurn = _autoBurn;\r\n\r\n    require(_revenueCommitmentBasisPoints <= BASIS_POINTS_DEN, \"INVALID_COMMITMENT\");\r\n    require(_revenueCommitmentBasisPoints >= revenueCommitmentBasisPoints, \"COMMITMENT_MAY_NOT_BE_REDUCED\");\r\n    revenueCommitmentBasisPoints = _revenueCommitmentBasisPoints;\r\n\r\n    require(_feeBasisPoints <= BASIS_POINTS_DEN, \"INVALID_FEE\");\r\n    feeBasisPoints = _feeBasisPoints;\r\n\r\n    require(_minInvestment > 0, \"INVALID_MIN_INVESTMENT\");\r\n    minInvestment = _minInvestment;\r\n\r\n    require(_openUntilAtLeast >= openUntilAtLeast, \"OPEN_UNTIL_MAY_NOT_BE_REDUCED\");\r\n    openUntilAtLeast = _openUntilAtLeast;\r\n\r\n    if(beneficiary != _beneficiary)\r\n    {\r\n      require(_beneficiary != address(0), \"INVALID_ADDRESS\");\r\n      uint tokens = balanceOf(beneficiary);\r\n      initInvestors[_beneficiary] = initInvestors[_beneficiary].add(initInvestors[beneficiary]);\r\n      initInvestors[beneficiary] = 0;\r\n      if(tokens > 0)\r\n      {\r\n        _transfer(beneficiary, _beneficiary, tokens);\r\n      }\r\n      beneficiary = _beneficiary;\r\n    }\r\n\r\n    emit UpdateConfig(\r\n      _whitelistAddress,\r\n      _beneficiary,\r\n      _control,\r\n      _feeCollector,\r\n      _autoBurn,\r\n      _revenueCommitmentBasisPoints,\r\n      _feeBasisPoints,\r\n      _minInvestment,\r\n      _openUntilAtLeast\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Functions for our business logic\r\n   */\r\n\r\n  /// @notice Burn the amount of tokens from the address msg.sender if authorized.\r\n  /// @dev Note that this is not the same as a `sell` via the DAT.\r\n  function burn(\r\n    uint _amount\r\n  ) public\r\n  {\r\n    _burn(msg.sender, _amount, false);\r\n  }\r\n\r\n  // Buy\r\n\r\n  /// @dev Distributes _value currency between the buybackReserve, beneficiary, and feeCollector.\r\n  function _distributeInvestment(\r\n    uint _value\r\n  ) private\r\n  {\r\n    // Rounding favors buybackReserve, then beneficiary, and feeCollector is last priority.\r\n\r\n    // Math: if investment value is < (2^256 - 1) / 10000 this will never overflow.\r\n    // Except maybe with a huge single investment, but they can try again with multiple smaller investments.\r\n    uint reserve = investmentReserveBasisPoints.mul(_value);\r\n    reserve /= BASIS_POINTS_DEN;\r\n    reserve = _value.sub(reserve);\r\n    uint fee = reserve.mul(feeBasisPoints);\r\n    fee /= BASIS_POINTS_DEN;\r\n\r\n    // Math: since feeBasisPoints is <= BASIS_POINTS_DEN, this will never underflow.\r\n    _transferCurrency(beneficiary, reserve - fee);\r\n    _transferCurrency(feeCollector, fee);\r\n  }\r\n\r\n  /// @notice Calculate how many FAIR tokens you would buy with the given amount of currency if `buy` was called now.\r\n  /// @param _currencyValue How much currency to spend in order to buy FAIR.\r\n  function estimateBuyValue(\r\n    uint _currencyValue\r\n  ) public view\r\n    returns (uint)\r\n  {\r\n    if(_currencyValue < minInvestment)\r\n    {\r\n      return 0;\r\n    }\r\n\r\n    /// Calculate the tokenValue for this investment\r\n    uint tokenValue;\r\n    if(state == STATE_INIT)\r\n    {\r\n      uint currencyValue = _currencyValue;\r\n      uint _totalSupply = totalSupply();\r\n      // (buy_slope*init_goal)*(init_goal+init_reserve-total_supply)/2\r\n      // n/d: buy_slope (MAX_BEFORE_SQUARE / MAX_BEFORE_SQUARE)\r\n      // g: init_goal (MAX_BEFORE_SQUARE/2)\r\n      // t: total_supply (MAX_BEFORE_SQUARE/2)\r\n      // r: init_reserve (MAX_BEFORE_SQUARE/2)\r\n      // source: ((n/d)*g)*(g+r-t)/2\r\n      // impl: (g n (g + r - t))/(2 d)\r\n      uint max = BigDiv.bigDiv2x1(\r\n        initGoal * buySlopeNum,\r\n        initGoal + initReserve - _totalSupply,\r\n        2 * buySlopeDen\r\n      );\r\n      if(currencyValue > max)\r\n      {\r\n        currencyValue = max;\r\n      }\r\n      // Math: worst case\r\n      // MAX * 2 * MAX_BEFORE_SQUARE\r\n      // / MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE\r\n      tokenValue = BigDiv.bigDiv2x1(\r\n        currencyValue,\r\n        2 * buySlopeDen,\r\n        initGoal * buySlopeNum\r\n      );\r\n\r\n      if(currencyValue != _currencyValue)\r\n      {\r\n        currencyValue = _currencyValue - max;\r\n        // ((2*next_amount/buy_slope)+init_goal^2)^(1/2)-init_goal\r\n        // a: next_amount | currencyValue\r\n        // n/d: buy_slope (MAX_BEFORE_SQUARE / MAX_BEFORE_SQUARE)\r\n        // g: init_goal (MAX_BEFORE_SQUARE/2)\r\n        // r: init_reserve (MAX_BEFORE_SQUARE/2)\r\n        // sqrt(((2*a/(n/d))+g^2)-g\r\n        // sqrt((2 d a + n g^2)/n) - g\r\n\r\n        // currencyValue == 2 d a\r\n        uint temp = 2 * buySlopeDen;\r\n        currencyValue = temp.mul(currencyValue);\r\n\r\n        // temp == g^2\r\n        temp = initGoal;\r\n        temp *= temp;\r\n\r\n        // temp == n g^2\r\n        temp = temp.mul(buySlopeNum);\r\n\r\n        // temp == (2 d a) + n g^2\r\n        temp = currencyValue.add(temp);\r\n\r\n        // temp == (2 d a + n g^2)/n\r\n        temp /= buySlopeNum;\r\n\r\n        // temp == sqrt((2 d a + n g^2)/n)\r\n        temp = temp.sqrt();\r\n\r\n        // temp == sqrt((2 d a + n g^2)/n) - g\r\n        temp -= initGoal;\r\n\r\n        tokenValue = tokenValue.add(temp);\r\n      }\r\n    }\r\n    else if(state == STATE_RUN)\r\n    {\r\n      // initReserve is reduced on sell as necessary to ensure that this line will not overflow\r\n      uint supply = totalSupply() + burnedSupply - initReserve;\r\n      // Math: worst case\r\n      // MAX * 2 * MAX_BEFORE_SQUARE\r\n      // / MAX_BEFORE_SQUARE\r\n      tokenValue = BigDiv.bigDiv2x1(\r\n        _currencyValue,\r\n        2 * buySlopeDen,\r\n        buySlopeNum\r\n      );\r\n\r\n      // Math: worst case MAX + (MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE)\r\n      tokenValue = tokenValue.add(supply * supply);\r\n      tokenValue = tokenValue.sqrt();\r\n\r\n      // Math: small chance of underflow due to possible rounding in sqrt\r\n      tokenValue = tokenValue.sub(supply);\r\n    }\r\n    else\r\n    {\r\n      // invalid state\r\n      return 0;\r\n    }\r\n\r\n    return tokenValue;\r\n  }\r\n\r\n  /// @notice Purchase FAIR tokens with the given amount of currency.\r\n  /// @param _to The account to receive the FAIR tokens from this purchase.\r\n  /// @param _currencyValue How much currency to spend in order to buy FAIR.\r\n  /// @param _minTokensBought Buy at least this many FAIR tokens or the transaction reverts.\r\n  /// @dev _minTokensBought is necessary as the price will change if some elses transaction mines after\r\n  /// yours was submitted.\r\n  function buy(\r\n    address _to,\r\n    uint _currencyValue,\r\n    uint _minTokensBought\r\n  ) public payable\r\n  {\r\n    require(_to != address(0), \"INVALID_ADDRESS\");\r\n    require(_minTokensBought > 0, \"MUST_BUY_AT_LEAST_1\");\r\n\r\n    // Calculate the tokenValue for this investment\r\n    uint tokenValue = estimateBuyValue(_currencyValue);\r\n    require(tokenValue >= _minTokensBought, \"PRICE_SLIPPAGE\");\r\n\r\n    emit Buy(msg.sender, _to, _currencyValue, tokenValue);\r\n\r\n    _collectInvestment(_currencyValue, msg.value, false);\r\n\r\n    // Update state, initInvestors, and distribute the investment when appropriate\r\n    if(state == STATE_INIT)\r\n    {\r\n      // Math worst case: MAX_BEFORE_SQUARE\r\n      initInvestors[_to] += tokenValue;\r\n      // Math worst case:\r\n      // MAX_BEFORE_SQUARE + MAX_BEFORE_SQUARE\r\n      if(totalSupply() + tokenValue - initReserve >= initGoal)\r\n      {\r\n        emit StateChange(state, STATE_RUN);\r\n        state = STATE_RUN;\r\n        // Math worst case:\r\n        // MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE/2\r\n        // / MAX_BEFORE_SQUARE * 2\r\n        uint beneficiaryContribution = BigDiv.bigDiv2x1(\r\n          initInvestors[beneficiary],\r\n          buySlopeNum * initGoal,\r\n          buySlopeDen * 2\r\n        );\r\n        _distributeInvestment(buybackReserve().sub(beneficiaryContribution));\r\n      }\r\n    }\r\n    else // implied: if(state == STATE_RUN)\r\n    {\r\n      if(_to != beneficiary)\r\n      {\r\n        _distributeInvestment(_currencyValue);\r\n      }\r\n    }\r\n\r\n    _mint(_to, tokenValue);\r\n\r\n    if(state == STATE_RUN && msg.sender == beneficiary && _to == beneficiary && autoBurn)\r\n    {\r\n      // must mint before this call\r\n      _burn(beneficiary, tokenValue, false);\r\n    }\r\n  }\r\n\r\n  /// Sell\r\n\r\n  function estimateSellValue(\r\n    uint _quantityToSell\r\n  ) public view\r\n    returns(uint)\r\n  {\r\n    uint reserve = buybackReserve();\r\n\r\n    // Calculate currencyValue for this sale\r\n    uint currencyValue;\r\n    if(state == STATE_RUN)\r\n    {\r\n      uint supply = totalSupply() + burnedSupply;\r\n\r\n      // buyback_reserve = r\r\n      // total_supply = t\r\n      // burnt_supply = b\r\n      // amount = a\r\n      // source: (t+b)*a*(2*r)/((t+b)^2)-(((2*r)/((t+b)^2)*a^2)/2)+((2*r)/((t+b)^2)*a*b^2)/(2*(t))\r\n      // imp: (a b^2 r)/(t (b + t)^2) + (2 a r)/(b + t) - (a^2 r)/(b + t)^2\r\n\r\n      // Math: burnedSupply is capped in FAIR such that the square will never overflow\r\n      // Math worst case:\r\n      // MAX * MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE/2 * MAX_BEFORE_SQUARE/2\r\n      // / MAX_BEFORE_SQUARE/2 * MAX_BEFORE_SQUARE/2 * MAX_BEFORE_SQUARE/2\r\n      currencyValue = BigDiv.bigDiv2x2(\r\n        _quantityToSell.mul(reserve),\r\n        burnedSupply * burnedSupply,\r\n        totalSupply(), supply * supply\r\n      );\r\n      // Math: worst case currencyValue is MAX_BEFORE_SQUARE (max reserve, 1 supply)\r\n\r\n      // Math worst case:\r\n      // MAX * 2 * MAX_BEFORE_SQUARE\r\n      uint temp = _quantityToSell.mul(2 * reserve);\r\n      temp /= supply;\r\n      // Math: worst-case temp is MAX_BEFORE_SQUARE (max reserve, 1 supply)\r\n\r\n      // Math: considering the worst-case for currencyValue and temp, this can never overflow\r\n      currencyValue += temp;\r\n\r\n      // Math: worst case\r\n      // MAX * MAX * MAX_BEFORE_SQUARE\r\n      // / MAX_BEFORE_SQUARE/2 * MAX_BEFORE_SQUARE/2\r\n      currencyValue -= BigDiv.bigDiv2x1RoundUp(\r\n        _quantityToSell.mul(_quantityToSell),\r\n        reserve,\r\n        supply * supply\r\n      );\r\n    }\r\n    else if(state == STATE_CLOSE)\r\n    {\r\n      // Math worst case\r\n      // MAX * MAX_BEFORE_SQUARE\r\n      currencyValue = _quantityToSell.mul(reserve);\r\n      currencyValue /= totalSupply();\r\n    }\r\n    else\r\n    {\r\n      // STATE_INIT or STATE_CANCEL\r\n      // Math worst case:\r\n      // MAX * MAX_BEFORE_SQUARE\r\n      currencyValue = _quantityToSell.mul(reserve);\r\n      // Math: FAIR blocks initReserve from being burned unless we reach the RUN state which prevents an underflow\r\n      currencyValue /= totalSupply() - initReserve;\r\n    }\r\n\r\n    return currencyValue;\r\n  }\r\n\r\n  /// @notice Sell FAIR tokens for at least the given amount of currency.\r\n  /// @param _to The account to receive the currency from this sale.\r\n  /// @param _quantityToSell How many FAIR tokens to sell for currency value.\r\n  /// @param _minCurrencyReturned Get at least this many currency tokens or the transaction reverts.\r\n  /// @dev _minCurrencyReturned is necessary as the price will change if some elses transaction mines after\r\n  /// yours was submitted.\r\n  function sell(\r\n    address payable _to,\r\n    uint _quantityToSell,\r\n    uint _minCurrencyReturned\r\n  ) public\r\n  {\r\n    require(msg.sender != beneficiary || state >= STATE_CLOSE, \"BENEFICIARY_ONLY_SELL_IN_CLOSE_OR_CANCEL\");\r\n    require(_minCurrencyReturned > 0, \"MUST_SELL_AT_LEAST_1\");\r\n\r\n    uint currencyValue = estimateSellValue(_quantityToSell);\r\n    require(currencyValue >= _minCurrencyReturned, \"PRICE_SLIPPAGE\");\r\n\r\n    if(state == STATE_INIT || state == STATE_CANCEL)\r\n    {\r\n      initInvestors[msg.sender] = initInvestors[msg.sender].sub(_quantityToSell);\r\n    }\r\n\r\n    _burn(msg.sender, _quantityToSell, true);\r\n    uint supply = totalSupply() + burnedSupply;\r\n    if(supply < initReserve)\r\n    {\r\n      initReserve = supply;\r\n    }\r\n\r\n    _transferCurrency(_to, currencyValue);\r\n    emit Sell(msg.sender, _to, currencyValue, _quantityToSell);\r\n  }\r\n\r\n  /// Pay\r\n\r\n  function estimatePayValue(\r\n    uint _currencyValue\r\n  ) public view\r\n    returns (uint)\r\n  {\r\n    // buy_slope = n/d\r\n    // revenue_commitment = c/g\r\n    // sqrt(\r\n    //  (2 a c d)\r\n    //  /\r\n    //  (g n)\r\n    //  + s^2\r\n    // ) - s\r\n\r\n    uint supply = totalSupply() + burnedSupply;\r\n\r\n    // Math: worst case\r\n    // MAX * 2 * 10000 * MAX_BEFORE_SQUARE\r\n    // / 10000 * MAX_BEFORE_SQUARE\r\n    uint tokenValue = BigDiv.bigDiv2x1(\r\n      _currencyValue.mul(2 * revenueCommitmentBasisPoints),\r\n      buySlopeDen,\r\n      BASIS_POINTS_DEN * buySlopeNum\r\n    );\r\n\r\n    tokenValue = tokenValue.add(supply * supply);\r\n    tokenValue = tokenValue.sqrt();\r\n\r\n    if(tokenValue > supply)\r\n    {\r\n      tokenValue -= supply;\r\n    }\r\n    else\r\n    {\r\n      tokenValue = 0;\r\n    }\r\n\r\n    return tokenValue;\r\n  }\r\n\r\n  /// @dev Pay the organization on-chain.\r\n  /// @param _to The account which receives tokens for the contribution.\r\n  /// @param _currencyValue How much currency which was paid.\r\n  function _pay(\r\n    address _to,\r\n    uint _currencyValue\r\n  ) private\r\n  {\r\n    require(_currencyValue > 0, \"MISSING_CURRENCY\");\r\n    require(state == STATE_RUN, \"INVALID_STATE\");\r\n\r\n    // Send a portion of the funds to the beneficiary, the rest is added to the buybackReserve\r\n    // Math: if _currencyValue is < (2^256 - 1) / 10000 this will not overflow\r\n    uint reserve = _currencyValue.mul(investmentReserveBasisPoints);\r\n    reserve /= BASIS_POINTS_DEN;\r\n\r\n    uint tokenValue = estimatePayValue(_currencyValue);\r\n\r\n    // Update the to address to the beneficiary if the currency value would fail\r\n    address to = _to;\r\n    if(to == address(0))\r\n    {\r\n      to = beneficiary;\r\n    }\r\n    else if(_detectTransferRestriction(address(0), _to, tokenValue) != 0)\r\n    {\r\n      to = beneficiary;\r\n    }\r\n\r\n    // Math: this will never underflow since investmentReserveBasisPoints is capped to BASIS_POINTS_DEN\r\n    _transferCurrency(beneficiary, _currencyValue - reserve);\r\n\r\n    // Distribute tokens\r\n    if(tokenValue > 0)\r\n    {\r\n      _mint(to, tokenValue);\r\n      if(to == beneficiary && autoBurn)\r\n      {\r\n        // must mint before this call\r\n        _burn(beneficiary, tokenValue, false);\r\n      }\r\n    }\r\n\r\n    emit Pay(msg.sender, _to, _currencyValue, tokenValue);\r\n  }\r\n\r\n  /// @dev Pay the organization on-chain.\r\n  /// @param _to The account which receives tokens for the contribution. If this address\r\n  /// is not authorized to receive tokens then they will be sent to the beneficiary account instead.\r\n  /// @param _currencyValue How much currency which was paid.\r\n  function pay(\r\n    address _to,\r\n    uint _currencyValue\r\n  ) public payable\r\n  {\r\n    _collectInvestment(_currencyValue, msg.value, false);\r\n    _pay(_to, _currencyValue);\r\n  }\r\n\r\n  /// Close\r\n\r\n  function estimateExitFee(\r\n    uint _msgValue\r\n  ) public view\r\n    returns(uint)\r\n  {\r\n    uint exitFee;\r\n\r\n    if(state == STATE_RUN)\r\n    {\r\n      uint reserve = buybackReserve();\r\n      reserve = reserve.sub(_msgValue);\r\n\r\n      // Source: t*(t+b)*(n/d)-r\r\n      // Implementation: (b n t)/d + (n t^2)/d - r\r\n\r\n      uint _totalSupply = totalSupply();\r\n\r\n      // Math worst case:\r\n      // MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE/2 * MAX_BEFORE_SQUARE\r\n      exitFee = BigDiv.bigDiv2x1(\r\n        _totalSupply,\r\n        burnedSupply * buySlopeNum,\r\n        buySlopeDen\r\n      );\r\n      // Math worst case:\r\n      // MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE\r\n      exitFee += BigDiv.bigDiv2x1(\r\n        _totalSupply,\r\n        buySlopeNum * _totalSupply,\r\n        buySlopeDen\r\n      );\r\n      // Math: this if condition avoids a potential overflow\r\n      if(exitFee <= reserve)\r\n      {\r\n        exitFee = 0;\r\n      }\r\n      else\r\n      {\r\n        exitFee -= reserve;\r\n      }\r\n    }\r\n\r\n    return exitFee;\r\n  }\r\n\r\n  /// @notice Called by the beneficiary account to STATE_CLOSE or STATE_CANCEL the c-org,\r\n  /// preventing any more tokens from being minted.\r\n  /// @dev Requires an `exitFee` to be paid.  If the currency is ETH, include a little more than\r\n  /// what appears to be required and any remainder will be returned to your account.  This is\r\n  /// because another user may have a transaction mined which changes the exitFee required.\r\n  /// For other `currency` types, the beneficiary account will be billed the exact amount required.\r\n  function close() public payable\r\n  {\r\n    require(msg.sender == beneficiary, \"BENEFICIARY_ONLY\");\r\n\r\n    uint exitFee = 0;\r\n\r\n    if(state == STATE_INIT)\r\n    {\r\n      // Allow the org to cancel anytime if the initGoal was not reached.\r\n      emit StateChange(state, STATE_CANCEL);\r\n      state = STATE_CANCEL;\r\n    }\r\n    else if(state == STATE_RUN)\r\n    {\r\n      // Collect the exitFee and close the c-org.\r\n      require(openUntilAtLeast <= block.timestamp, \"TOO_EARLY\");\r\n\r\n      exitFee = estimateExitFee(msg.value);\r\n\r\n      emit StateChange(state, STATE_CLOSE);\r\n      state = STATE_CLOSE;\r\n\r\n      _collectInvestment(exitFee, msg.value, true);\r\n    }\r\n    else\r\n    {\r\n      revert(\"INVALID_STATE\");\r\n    }\r\n\r\n    emit Close(exitFee);\r\n  }\r\n\r\n  // --- Approve by signature ---\r\n  // Original source: https://etherscan.io/address/0x6b175474e89094c44da98b954eedeac495271d0f#code\r\n  function permit(\r\n    address holder,\r\n    address spender,\r\n    uint256 nonce,\r\n    uint256 expiry,\r\n    bool allowed,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external\r\n  {\r\n    bytes32 digest = keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        keccak256(\r\n          abi.encode(PERMIT_TYPEHASH,\r\n                    holder,\r\n                    spender,\r\n                    nonce,\r\n                    expiry,\r\n                    allowed\r\n          )\r\n        )\r\n      )\r\n    );\r\n\r\n    require(holder != address(0), \"DAT/invalid-address-0\");\r\n    require(holder == ecrecover(digest, v, r, s), \"DAT/invalid-permit\");\r\n    require(expiry == 0 || now <= expiry, \"DAT/permit-expired\");\r\n    require(nonce == nonces[holder]++, \"DAT/invalid-nonce\");\r\n    uint wad = allowed ? uint(-1) : 0;\r\n    _approve(holder, spender, wad);\r\n  }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fairValue\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_currencyValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fairValue\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_exitFee\",\"type\":\"uint256\"}],\"name\":\"Close\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_currencyValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fairValue\",\"type\":\"uint256\"}],\"name\":\"Pay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_currencyValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fairValue\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_previousState\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newState\",\"type\":\"uint256\"}],\"name\":\"StateChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_whitelistAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_control\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_feeCollector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_autoBurn\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_revenueCommitmentBasisPoints\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_feeBasisPoints\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_minInvestment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_openUntilAtLeast\",\"type\":\"uint256\"}],\"name\":\"UpdateConfig\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"autoBurn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_currencyValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minTokensBought\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buySlopeDen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buySlopeNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buybackReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"control\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currency\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_currencyValue\",\"type\":\"uint256\"}],\"name\":\"estimateBuyValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_msgValue\",\"type\":\"uint256\"}],\"name\":\"estimateExitFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_currencyValue\",\"type\":\"uint256\"}],\"name\":\"estimatePayValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_quantityToSell\",\"type\":\"uint256\"}],\"name\":\"estimateSellValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initGoal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"initInvestors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initReserve\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_currencyAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_initGoal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buySlopeNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buySlopeDen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_investmentReserveBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initializePermit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investmentReserveBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openUntilAtLeast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_currencyValue\",\"type\":\"uint256\"}],\"name\":\"pay\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"revenueCommitmentBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_quantityToSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minCurrencyReturned\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_whitelistAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_control\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_feeCollector\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_autoBurn\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_revenueCommitmentBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_openUntilAtLeast\",\"type\":\"uint256\"}],\"name\":\"updateConfig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"contract IWhitelist\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DecentralizedAutonomousTrust","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://96e89ad6c10af7ea5f9258c0313e02c26c67d2bd7a5af1d613ce0d0d9ab5b5a3"}]}