{"status":"1","message":"OK","result":[{"SourceCode":"{\"budget.sol\":{\"content\":\"// Copyright (C) 2019 lucasvo\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.5.12;\\nimport \\u0027./lib.sol\\u0027;\\n\\ncontract Budget {\\n    // --- Auth ---\\n    mapping (address =\\u003e uint) public wards;\\n    function rely(address usr) public auth { wards[usr] = 1; }\\n    function deny(address usr) public auth { wards[usr] = 0; }\\n    modifier auth { require(wards[msg.sender] == 1); _; }\\n\\n    // --- Data ---\\n    MintLike                  public roof;\\n\\n    mapping (address =\\u003e uint) public budgets;\\n\\n    event BudgetSet(address indexed sender, address indexed usr, uint wad);\\n\\n    constructor(address roof_) public {\\n        wards[msg.sender] = 1;\\n        roof = MintLike(roof_);\\n    }\\n\\n    // --- Budget ---\\n    function mint(address usr, uint wad) public {\\n        roof.mint(usr, wad);\\n        require(budgets[msg.sender] \\u003e= wad);\\n        budgets[msg.sender] -= wad;\\n    }\\n\\n    function budget(address usr, uint wad) public auth {\\n        budgets[usr] = wad;\\n        emit BudgetSet(msg.sender, usr, wad);\\n    }\\n}\\n\"},\"ceiling.sol\":{\"content\":\"// Copyright (C) 2019 lucasvo\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.5.12;\\n\\nimport \\\"./lib.sol\\\";\\n\\n// Ceiling\\n// Implements a ward that only allows minting of tokens if the `roof` has not\\n// been reached. The roof is set at deployment and can not be changed after.\\n// This is an effective way of implementing a fixed supply token without\\n// requiring to mint all tokens at once.\\n//\\ncontract Ceiling {\\n    // --- Auth ---\\n    mapping (address =\\u003e uint) public wards;\\n    function rely(address usr) public auth { wards[usr] = 1; }\\n    function deny(address usr) public auth { wards[usr] = 0; }\\n    modifier auth { require(wards[msg.sender] == 1); _; }\\n\\n    // --- Data ---\\n    MintLike public tkn;\\n    uint public     roof;\\n\\n    constructor(address tkn_, uint roof_) public {\\n        wards[msg.sender] = 1;\\n        tkn = MintLike(tkn_);\\n        roof = roof_;\\n    }\\n\\n    // --- Math ---\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) \\u003e= x);\\n    }\\n\\n    // --- Ceiling ---\\n    function mint(address usr, uint wad) public auth {\\n        require(add(tkn.totalSupply(), wad) \\u003c= roof, \\\"cent/reached-roof\\\");\\n        tkn.mint(usr, wad);\\n    }\\n}\\n\"},\"deploy.sol\":{\"content\":\"// Copyright (C) 2019 lucasvo\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity \\u003e=0.4.24;\\n\\nimport \\u0027./lib.sol\\u0027;\\nimport \\u0027./radial.sol\\u0027;\\nimport \\u0027./ceiling.sol\\u0027;\\nimport \\u0027./budget.sol\\u0027;\\n\\n// RadialFab deploys the Radial ERC20 token, an instance of Ceiling and Budget\\n// removing the deployer address from the wards of the Radial and Ceiling\\n// contracts.\\n//\\n// By doing the entire deploy in one transaction, we can simplify auditing of\\n// the deploy and ensure that no ward was added to any of the Radial and\\n// Ceiling contract other than the Budget ward.\\n//\\ncontract RadialFab {\\n    Radial  public    tkn;\\n    Ceiling public    ceil;\\n    Budget  public    bags;\\n\\n    constructor (uint roof, address ward, uint chainid) public {\\n        address self = address(this);\\n        tkn = new Radial(chainid);\\n        ceil = new Ceiling(address(tkn), roof);\\n        bags = new Budget(address(ceil));\\n\\n        tkn.rely(address(ceil));\\n        tkn.deny(self);\\n        ceil.rely(address(bags));\\n        ceil.deny(self);\\n        bags.rely(ward);\\n        bags.deny(self);\\n    }\\n}\\n\\n\"},\"lib.sol\":{\"content\":\"// Copyright (C) 2019 lucasvo\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity \\u003e=0.4.24;\\n\\ncontract MintLike {\\n    uint public totalSupply;\\n    function mint(address,uint) public;\\n}\\n\\n\\n\"},\"radial.sol\":{\"content\":\"// Copyright (C) 2017, 2018, 2019 dbrock, rain, mrchico\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.5.12;\\n\\ncontract Radial {\\n    // --- Auth ---\\n    mapping (address =\\u003e uint) public wards;\\n    function rely(address usr) public auth { wards[usr] = 1; }\\n    function deny(address usr) public auth { wards[usr] = 0; }\\n    modifier auth { require(wards[msg.sender] == 1); _; }\\n\\n    // --- ERC20 Data ---\\n    string  public constant name     = \\\"Radial\\\";\\n    string  public constant symbol   = \\\"RAD\\\";\\n    string  public constant version  = \\\"1\\\";\\n    uint8   public constant decimals = 18;\\n    uint256 public totalSupply;\\n\\n    mapping (address =\\u003e uint)                      public balanceOf;\\n    mapping (address =\\u003e mapping (address =\\u003e uint)) public allowance;\\n    mapping (address =\\u003e uint)                      public nonces;\\n\\n    event Approval(address indexed src, address indexed usr, uint wad);\\n    event Transfer(address indexed src, address indexed dst, uint wad);\\n\\n    // --- Math ---\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) \\u003e= x);\\n    }\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) \\u003c= x);\\n    }\\n\\n    // --- EIP712 niceties ---\\n    bytes32 public DOMAIN_SEPARATOR;\\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\\\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\\n    constructor(uint256 chainId_) public {\\n        wards[msg.sender] = 1;\\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\\n            keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n            keccak256(bytes(name)),\\n            keccak256(bytes(version)),\\n            chainId_,\\n            address(this)\\n        ));\\n    }\\n\\n    // --- Radial Token ---\\n    function transfer(address dst, uint wad) external returns (bool) {\\n        return transferFrom(msg.sender, dst, wad);\\n    }\\n    function transferFrom(address src, address dst, uint wad)\\n        public returns (bool)\\n    {\\n        require(balanceOf[src] \\u003e= wad, \\\"cent/insufficient-balance\\\");\\n        if (src != msg.sender \\u0026\\u0026 allowance[src][msg.sender] != uint(-1)) {\\n            require(allowance[src][msg.sender] \\u003e= wad, \\\"cent/insufficient-allowance\\\");\\n            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\\n        }\\n        balanceOf[src] = sub(balanceOf[src], wad);\\n        balanceOf[dst] = add(balanceOf[dst], wad);\\n        emit Transfer(src, dst, wad);\\n        return true;\\n    }\\n    function mint(address usr, uint wad) external auth {\\n        balanceOf[usr] = add(balanceOf[usr], wad);\\n        totalSupply    = add(totalSupply, wad);\\n        emit Transfer(address(0), usr, wad);\\n    }\\n    function burn(address usr, uint wad) external {\\n        require(balanceOf[usr] \\u003e= wad, \\\"cent/insufficient-balance\\\");\\n        if (usr != msg.sender \\u0026\\u0026 allowance[usr][msg.sender] != uint(-1)) {\\n            require(allowance[usr][msg.sender] \\u003e= wad, \\\"cent/insufficient-allowance\\\");\\n            allowance[usr][msg.sender] = sub(allowance[usr][msg.sender], wad);\\n        }\\n        balanceOf[usr] = sub(balanceOf[usr], wad);\\n        totalSupply    = sub(totalSupply, wad);\\n        emit Transfer(usr, address(0), wad);\\n    }\\n    function approve(address usr, uint wad) external returns (bool) {\\n        allowance[msg.sender][usr] = wad;\\n        emit Approval(msg.sender, usr, wad);\\n        return true;\\n    }\\n    // --- Alias ---\\n    function push(address usr, uint wad) external {\\n        transferFrom(msg.sender, usr, wad);\\n    }\\n    function pull(address usr, uint wad) external {\\n        transferFrom(usr, msg.sender, wad);\\n    }\\n    function move(address src, address dst, uint wad) external {\\n        transferFrom(src, dst, wad);\\n    }\\n\\n    // --- Approve by signature ---\\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry,\\n                    bool allowed, uint8 v, bytes32 r, bytes32 s) public\\n    {\\n        bytes32 digest =\\n            keccak256(abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(abi.encode(PERMIT_TYPEHASH,\\n                                     holder,\\n                                     spender,\\n                                     nonce,\\n                                     expiry,\\n                                     allowed))\\n        ));\\n        require(holder != address(0), \\\"cent/invalid-address-0\\\");\\n        require(holder == ecrecover(digest, v, r, s), \\\"cent/invalid-permit\\\");\\n        require(expiry == 0 || now \\u003c= expiry, \\\"cent/permit-expired\\\");\\n        require(nonce == nonces[holder]++, \\\"cent/invalid-nonce\\\");\\n        uint wad = allowed ? uint(-1) : 0;\\n        allowance[holder][spender] = wad;\\n        emit Approval(holder, spender, wad);\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roof\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ward\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainid\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[],\"name\":\"bags\",\"outputs\":[{\"internalType\":\"contract Budget\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceil\",\"outputs\":[{\"internalType\":\"contract Ceiling\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tkn\",\"outputs\":[{\"internalType\":\"contract Radial\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"RadialFab","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000014adf4b7320334b90000000000000000000000000000000af34bd5bc8bc293661bac46ebfb673d227c85acf0000000000000000000000000000000000000000000000000000000000000001","Library":"","LicenseType":"None","SwarmSource":"bzzr://13df3fa670aad252b790ff642ce0f63165299746ff31cadcd27bccee3569a585"}]}