{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// We should reference that this was inspired by Melon Protocol Engine\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\ncontract BurnableToken {\r\n    function burnAndRetrieve(uint256 _tokensToBurn) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n}\r\n\r\n/// @notice NEC Auction Engine\r\ncontract Engine {\r\n    using SafeMath for uint256;\r\n\r\n    event Thaw(uint amount);\r\n    event Burn(uint amount, uint price, address burner);\r\n    event FeesPaid(uint amount);\r\n    event AuctionClose(uint indexed auctionNumber, uint ethPurchased, uint necBurned);\r\n\r\n    uint public constant NEC_DECIMALS = 18;\r\n    address public necAddress;\r\n\r\n    uint public frozenEther;\r\n    uint public liquidEther;\r\n    uint public lastThaw;\r\n    uint public thawingDelay;\r\n    uint public totalEtherConsumed;\r\n    uint public totalNecBurned;\r\n    uint public thisAuctionTotalEther;\r\n\r\n    uint private necPerEth; // Price at which the previous auction ended\r\n    uint private lastSuccessfulSale;\r\n\r\n    uint public auctionCounter;\r\n\r\n    // Params for auction price multiplier - TODO: can make customizable with an admin function\r\n    uint private startingPercentage = 200;\r\n    uint private numberSteps = 35;\r\n\r\n    constructor(uint _delay, address _token) public {\r\n        lastThaw = 0;\r\n        thawingDelay = _delay;\r\n        necAddress = _token;\r\n        necPerEth = uint(20000).mul(10 ** uint(NEC_DECIMALS));\r\n    }\r\n\r\n    function payFeesInEther() external payable {\r\n        totalEtherConsumed = totalEtherConsumed.add(msg.value);\r\n        frozenEther = frozenEther.add(msg.value);\r\n        emit FeesPaid(msg.value);\r\n    }\r\n\r\n    /// @notice Move frozen ether to liquid pool after delay\r\n    /// @dev Delay only restarts when this function is called\r\n    function thaw() public {\r\n        require(\r\n            block.timestamp >= lastThaw.add(thawingDelay),\r\n            \"Thawing delay has not passed\"\r\n        );\r\n        require(frozenEther > 0, \"No frozen ether to thaw\");\r\n        lastThaw = block.timestamp;\r\n        if (lastSuccessfulSale > 0) {\r\n          necPerEth = lastSuccessfulSale;\r\n        } else {\r\n          necPerEth = necPerEth.div(4);\r\n        }\r\n        liquidEther = liquidEther.add(frozenEther);\r\n        thisAuctionTotalEther = liquidEther;\r\n        emit Thaw(frozenEther);\r\n        frozenEther = 0;\r\n        lastSuccessfulSale = 0;\r\n\r\n        emit AuctionClose(auctionCounter, totalEtherConsumed, totalNecBurned);\r\n        auctionCounter++;\r\n    }\r\n\r\n    function getPriceWindow() public view returns (uint window) {\r\n      window = (now.sub(lastThaw)).mul(numberSteps).div(thawingDelay);\r\n    }\r\n\r\n    function percentageMultiplier() public view returns (uint) {\r\n        return (startingPercentage.sub(getPriceWindow().mul(5)));\r\n    }\r\n\r\n    /// @return NEC per ETH including premium\r\n    function enginePrice() public view returns (uint) {\r\n        return necPerEth.mul(percentageMultiplier()).div(100);\r\n    }\r\n\r\n    function ethPayoutForNecAmount(uint necAmount) public view returns (uint) {\r\n        return necAmount.mul(10 ** uint(NEC_DECIMALS)).div(enginePrice());\r\n    }\r\n\r\n    /// @notice NEC must be approved first\r\n    function sellAndBurnNec(uint necAmount) external {\r\n        if (block.timestamp >= lastThaw.add(thawingDelay)) {\r\n          thaw();\r\n          return;\r\n        }\r\n        require(\r\n            necToken().transferFrom(msg.sender, address(this), necAmount),\r\n            \"NEC transferFrom failed\"\r\n        );\r\n        uint ethToSend = ethPayoutForNecAmount(necAmount);\r\n        require(ethToSend > 0, \"No ether to pay out\");\r\n        require(liquidEther >= ethToSend, \"Not enough liquid ether to send\");\r\n        if (liquidEther > 0.1 ether) {\r\n            lastSuccessfulSale = enginePrice();\r\n        }\r\n        liquidEther = liquidEther.sub(ethToSend);\r\n        totalNecBurned = totalNecBurned.add(necAmount);\r\n        msg.sender.transfer(ethToSend);\r\n        necToken().burnAndRetrieve(necAmount);\r\n        emit Burn(necAmount, lastSuccessfulSale, msg.sender);\r\n    }\r\n\r\n    /// @dev Get NEC token\r\n    function necToken()\r\n        public\r\n        view\r\n        returns (BurnableToken)\r\n    {\r\n        return BurnableToken(necAddress);\r\n    }\r\n\r\n\r\n/// Useful read functions for UI\r\n\r\n    function getNextPriceChange() public view returns (\r\n        uint newPriceMultiplier,\r\n        uint nextChangeTimeSeconds )\r\n    {\r\n        uint nextWindow = getPriceWindow() + 1;\r\n        nextChangeTimeSeconds = lastThaw + thawingDelay.mul(nextWindow).div(numberSteps);\r\n        newPriceMultiplier = (startingPercentage.sub(nextWindow.mul(5)));\r\n    }\r\n\r\n    function getNextAuction() public view returns (\r\n        uint nextStartTimeSeconds,\r\n        uint predictedEthAvailable,\r\n        uint predictedStartingPrice\r\n        ) {\r\n        nextStartTimeSeconds = lastThaw + thawingDelay;\r\n        predictedEthAvailable = frozenEther;\r\n        if (lastSuccessfulSale > 0) {\r\n          predictedStartingPrice = lastSuccessfulSale * 2;\r\n        } else {\r\n          predictedStartingPrice = necPerEth.div(4);\r\n        }\r\n    }\r\n\r\n    function getCurrentAuction() public view returns (\r\n        uint auctionNumber,\r\n        uint startTimeSeconds,\r\n        uint nextPriceChangeSeconds,\r\n        uint currentPrice,\r\n        uint nextPrice,\r\n        uint initialEthAvailable,\r\n        uint remainingEthAvailable\r\n        ) {\r\n        auctionNumber = auctionCounter;\r\n        startTimeSeconds = lastThaw;\r\n        currentPrice = enginePrice();\r\n        uint nextPriceMultiplier;\r\n        (nextPriceMultiplier, nextPriceChangeSeconds) = getNextPriceChange();\r\n        nextPrice = currentPrice.mul(nextPriceMultiplier).div(percentageMultiplier());\r\n        initialEthAvailable = thisAuctionTotalEther;\r\n        remainingEthAvailable = liquidEther;\r\n    }\r\n\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_delay\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethPurchased\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"necBurned\",\"type\":\"uint256\"}],\"name\":\"AuctionClose\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"burner\",\"type\":\"address\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeesPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Thaw\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"NEC_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"enginePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"necAmount\",\"type\":\"uint256\"}],\"name\":\"ethPayoutForNecAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"frozenEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentAuction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTimeSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextPriceChangeSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialEthAvailable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingEthAvailable\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextAuction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nextStartTimeSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"predictedEthAvailable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"predictedStartingPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextPriceChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newPriceMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextChangeTimeSeconds\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPriceWindow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"window\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastThaw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"necAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"necToken\",\"outputs\":[{\"internalType\":\"contract BurnableToken\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payFeesInEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percentageMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"necAmount\",\"type\":\"uint256\"}],\"name\":\"sellAndBurnNec\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"thaw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thawingDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thisAuctionTotalEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEtherConsumed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalNecBurned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Engine","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000093a80000000000000000000000000cc80c051057b774cd75067dc48f8987c4eb97a5e","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://f629d297428a3f99c9e3d355d10ff2e16ff8bfcb74ea88993d6c045fd45de7b2"}]}