{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ncontract EIP712 {\r\n    string internal constant DOMAIN_NAME = \"Mai Protocol\";\r\n\r\n    \r\n    bytes32 public constant EIP712_DOMAIN_TYPEHASH = keccak256(\r\n        abi.encodePacked(\"EIP712Domain(string name)\")\r\n    );\r\n\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n\r\n    constructor () public {\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encodePacked(\r\n                EIP712_DOMAIN_TYPEHASH,\r\n                keccak256(bytes(DOMAIN_NAME))\r\n            )\r\n        );\r\n    }\r\n\r\n    \r\n    function hashEIP712Message(bytes32 eip712hash) internal view returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, eip712hash));\r\n    }\r\n}\r\n\r\ncontract LibSignature {\r\n\r\n    enum SignatureMethod {\r\n        EthSign,\r\n        EIP712\r\n    }\r\n\r\n    \r\n    struct OrderSignature {\r\n        \r\n        bytes32 config;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n    \r\n    function isValidSignature(bytes32 hash, address signerAddress, OrderSignature memory signature)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        uint8 method = uint8(signature.config[1]);\r\n        address recovered;\r\n        uint8 v = uint8(signature.config[0]);\r\n\r\n        if (method == uint8(SignatureMethod.EthSign)) {\r\n            recovered = ecrecover(\r\n                keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)),\r\n                v,\r\n                signature.r,\r\n                signature.s\r\n            );\r\n        } else if (method == uint8(SignatureMethod.EIP712)) {\r\n            recovered = ecrecover(hash, v, signature.r, signature.s);\r\n        } else {\r\n            revert(\"INVALID_SIGN_METHOD\");\r\n        }\r\n\r\n        return signerAddress == recovered;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        \r\n        \r\n        \r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        \r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        \r\n\r\n        return c;\r\n    }\r\n\r\n    \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract LibMath {\r\n    using SafeMath for uint256;\r\n\r\n    \r\n    function isRoundingError(uint256 numerator, uint256 denominator, uint256 multiple)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return numerator.mul(multiple).mod(denominator).mul(1000) >= numerator.mul(multiple);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function getPartialAmountFloor(uint256 numerator, uint256 denominator, uint256 multiple)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(!isRoundingError(numerator, denominator, multiple), \"ROUNDING_ERROR\");\r\n        return numerator.mul(multiple).div(denominator);\r\n    }\r\n\r\n    \r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\ncontract LibOrder is EIP712, LibSignature, LibMath {\r\n\r\n    uint256 public constant REBATE_RATE_BASE = 100;\r\n\r\n    struct Order {\r\n        address trader;\r\n        address relayer;\r\n        address marketContractAddress;\r\n        uint256 amount;\r\n        uint256 price;\r\n        uint256 gasTokenAmount;\r\n\r\n        \r\n        bytes32 data;\r\n    }\r\n\r\n    enum OrderStatus {\r\n        EXPIRED,\r\n        CANCELLED,\r\n        FILLABLE,\r\n        FULLY_FILLED\r\n    }\r\n\r\n    enum FillAction {\r\n        INVALID,\r\n        BUY,\r\n        SELL,\r\n        MINT,\r\n        REDEEM\r\n    }\r\n\r\n    bytes32 public constant EIP712_ORDER_TYPE = keccak256(\r\n        abi.encodePacked(\r\n            \"Order(address trader,address relayer,address marketContractAddress,uint256 amount,uint256 price,uint256 gasTokenAmount,bytes32 data)\"\r\n        )\r\n    );\r\n\r\n    \r\n    function getOrderHash(Order memory order) internal view returns (bytes32 orderHash) {\r\n        orderHash = hashEIP712Message(hashOrder(order));\r\n        return orderHash;\r\n    }\r\n\r\n    \r\n    function hashOrder(Order memory order) internal pure returns (bytes32 result) {\r\n        \r\n        bytes32 orderType = EIP712_ORDER_TYPE;\r\n\r\n        assembly {\r\n            let start := sub(order, 32)\r\n            let tmp := mload(start)\r\n\r\n            \r\n            \r\n            \r\n            \r\n            mstore(start, orderType)\r\n            result := keccak256(start, 256)\r\n\r\n            mstore(start, tmp)\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    \r\n\r\n    function getOrderVersion(bytes32 data) internal pure returns (uint256) {\r\n        return uint256(uint8(byte(data)));\r\n    }\r\n\r\n    function getExpiredAtFromOrderData(bytes32 data) internal pure returns (uint256) {\r\n        return uint256(uint40(bytes5(data << (8*3))));\r\n    }\r\n\r\n    function isSell(bytes32 data) internal pure returns (bool) {\r\n        return uint8(data[1]) == 1;\r\n    }\r\n\r\n    function isMarketOrder(bytes32 data) internal pure returns (bool) {\r\n        return uint8(data[2]) == 1;\r\n    }\r\n\r\n    function isMakerOnly(bytes32 data) internal pure returns (bool) {\r\n        return uint8(data[22]) == 1;\r\n    }\r\n\r\n    function isMarketBuy(bytes32 data) internal pure returns (bool) {\r\n        return !isSell(data) && isMarketOrder(data);\r\n    }\r\n\r\n    function getAsMakerFeeRateFromOrderData(bytes32 data) internal pure returns (uint256) {\r\n        return uint256(uint16(bytes2(data << (8*8))));\r\n    }\r\n\r\n    function getAsTakerFeeRateFromOrderData(bytes32 data) internal pure returns (uint256) {\r\n        return uint256(uint16(bytes2(data << (8*10))));\r\n    }\r\n\r\n    function getMakerRebateRateFromOrderData(bytes32 data) internal pure returns (uint256) {\r\n        uint256 makerRebate = uint256(uint16(bytes2(data << (8*12))));\r\n\r\n        \r\n        return min(makerRebate, REBATE_RATE_BASE);\r\n    }\r\n}\r\n\r\ncontract LibOwnable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    \r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    \r\n    function owner() public view returns(address) {\r\n        return _owner;\r\n    }\r\n\r\n    \r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    \r\n    function isOwner() public view returns(bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    \r\n    \r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"INVALID_OWNER\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract LibRelayer {\r\n\r\n    \r\n    mapping (address => mapping (address => bool)) public relayerDelegates;\r\n\r\n    \r\n    mapping (address => bool) hasExited;\r\n\r\n    event RelayerApproveDelegate(address indexed relayer, address indexed delegate);\r\n    event RelayerRevokeDelegate(address indexed relayer, address indexed delegate);\r\n\r\n    event RelayerExit(address indexed relayer);\r\n    event RelayerJoin(address indexed relayer);\r\n\r\n    \r\n    function approveDelegate(address delegate) external {\r\n        relayerDelegates[msg.sender][delegate] = true;\r\n        emit RelayerApproveDelegate(msg.sender, delegate);\r\n    }\r\n\r\n    \r\n    function revokeDelegate(address delegate) external {\r\n        relayerDelegates[msg.sender][delegate] = false;\r\n        emit RelayerRevokeDelegate(msg.sender, delegate);\r\n    }\r\n\r\n    \r\n    function canMatchMarketContractOrdersFrom(address relayer) public view returns(bool) {\r\n        return msg.sender == relayer || relayerDelegates[relayer][msg.sender] == true;\r\n    }\r\n\r\n    \r\n    function joinIncentiveSystem() external {\r\n        delete hasExited[msg.sender];\r\n        emit RelayerJoin(msg.sender);\r\n    }\r\n\r\n    \r\n    function exitIncentiveSystem() external {\r\n        hasExited[msg.sender] = true;\r\n        emit RelayerExit(msg.sender);\r\n    }\r\n\r\n    \r\n    function isParticipant(address relayer) public view returns(bool) {\r\n        return !hasExited[relayer];\r\n    }\r\n}\r\n\r\ncontract LibExchangeErrors {\r\n    string constant INVALID_TRADER = \"INVALID_TRADER\";\r\n    string constant INVALID_SENDER = \"INVALID_SENDER\";\r\n    \r\n    string constant INVALID_MATCH = \"INVALID_MATCH\";\r\n    string constant REDEEM_PRICE_NOT_MET = \"REDEEM_PRICE_NOT_MET\";\r\n    string constant MINT_PRICE_NOT_MET = \"MINT_PRICE_NOT_MET\";\r\n    string constant INVALID_SIDE = \"INVALID_SIDE\";\r\n    \r\n    string constant INVALID_ORDER_SIGNATURE = \"INVALID_ORDER_SIGNATURE\";\r\n    \r\n    string constant ORDER_IS_NOT_FILLABLE = \"ORDER_IS_NOT_FILLABLE\";\r\n    string constant MAKER_ORDER_CAN_NOT_BE_MARKET_ORDER = \"MAKER_ORDER_CAN_NOT_BE_MARKET_ORDER\";\r\n    string constant TRANSFER_FROM_FAILED = \"TRANSFER_FROM_FAILED\";\r\n    string constant MAKER_ORDER_OVER_MATCH = \"MAKER_ORDER_OVER_MATCH\";\r\n    string constant TAKER_ORDER_OVER_MATCH = \"TAKER_ORDER_OVER_MATCH\";\r\n    string constant ORDER_VERSION_NOT_SUPPORTED = \"ORDER_VERSION_NOT_SUPPORTED\";\r\n    string constant MAKER_ONLY_ORDER_CANNOT_BE_TAKER = \"MAKER_ONLY_ORDER_CANNOT_BE_TAKER\";\r\n    string constant TRANSFER_FAILED = \"TRANSFER_FAILED\";\r\n    string constant MINT_POSITION_TOKENS_FAILED = \"MINT_FAILED\";\r\n    string constant REDEEM_POSITION_TOKENS_FAILED = \"REDEEM_FAILED\";\r\n    string constant UNEXPECTED_MATCH = \"UNEXPECTED_MATCH\";\r\n    string constant INSUFFICIENT_FEE = \"INSUFFICIENT_FEE\";\r\n    string constant INVALID_MARKET_CONTRACT = \"INVALID_MARKET_CONTRACT\";\r\n    string constant UNMATCHED_FILL = \"UNMATCHED_FILL\";\r\n    string constant LOW_MARGIN = \"LOW_MARGIN\";\r\n    string constant MAKER_CAN_NOT_BE_SAME_WITH_TAKER = \"MAKER_CANNOT_BE_TAKER\";\r\n}\r\n\r\ncontract IMarketContractPool {\r\n    function mintPositionTokens(\r\n        address marketContractAddress,\r\n        uint qtyToMint,\r\n        bool isAttemptToPayInMKT\r\n    ) external;\r\n    function redeemPositionTokens(\r\n        address marketContractAddress,\r\n        uint qtyToRedeem\r\n    ) external;\r\n    function mktToken() external view returns (address);\r\n}\r\n\r\ninterface IMarketContract {\r\n    \r\n    function CONTRACT_NAME()\r\n        external\r\n        view\r\n        returns (string memory);\r\n    function COLLATERAL_TOKEN_ADDRESS()\r\n        external\r\n        view\r\n        returns (address);\r\n    function COLLATERAL_POOL_ADDRESS()\r\n        external\r\n        view\r\n        returns (address);\r\n    function PRICE_CAP()\r\n        external\r\n        view\r\n        returns (uint);\r\n    function PRICE_FLOOR()\r\n        external\r\n        view\r\n        returns (uint);\r\n    function PRICE_DECIMAL_PLACES()\r\n        external\r\n        view\r\n        returns (uint);\r\n    function QTY_MULTIPLIER()\r\n        external\r\n        view\r\n        returns (uint);\r\n    function COLLATERAL_PER_UNIT()\r\n        external\r\n        view\r\n        returns (uint);\r\n    function COLLATERAL_TOKEN_FEE_PER_UNIT()\r\n        external\r\n        view\r\n        returns (uint);\r\n    function MKT_TOKEN_FEE_PER_UNIT()\r\n        external\r\n        view\r\n        returns (uint);\r\n    function EXPIRATION()\r\n        external\r\n        view\r\n        returns (uint);\r\n    function SETTLEMENT_DELAY()\r\n        external\r\n        view\r\n        returns (uint);\r\n    function LONG_POSITION_TOKEN()\r\n        external\r\n        view\r\n        returns (address);\r\n    function SHORT_POSITION_TOKEN()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    \r\n    function lastPrice()\r\n        external\r\n        view\r\n        returns (uint);\r\n    function settlementPrice()\r\n        external\r\n        view\r\n        returns (uint);\r\n    function settlementTimeStamp()\r\n        external\r\n        view\r\n        returns (uint);\r\n    function isSettled()\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    \r\n    function isPostSettlementDelay()\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\ncontract IMarketContractRegistry {\r\n    function addAddressToWhiteList(address contractAddress) external;\r\n    function isAddressWhiteListed(address contractAddress) external view returns (bool);\r\n}\r\n\r\ninterface IERC20 {\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n\r\n    \r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    \r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    \r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    \r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    \r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract MaiProtocol is LibMath, LibOrder, LibRelayer, LibExchangeErrors, LibOwnable {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public constant MAX_MATCHES = 3;\r\n    uint256 public constant LONG = 0;\r\n    uint256 public constant SHORT = 1;\r\n    uint256 public constant FEE_RATE_BASE = 100000;\r\n\r\n    \r\n    uint256 public constant SUPPORTED_ORDER_VERSION = 1;\r\n\r\n    \r\n    address public proxyAddress;\r\n\r\n    \r\n    address public marketRegistryAddress;\r\n\r\n    \r\n    mapping (bytes32 => uint256) public filled;\r\n\r\n    \r\n    mapping (bytes32 => bool) public cancelled;\r\n\r\n    event Cancel(bytes32 indexed orderHash);\r\n\r\n    \r\n    struct OrderParam {\r\n        address trader;\r\n        uint256 amount;\r\n        uint256 price;\r\n        uint256 gasTokenAmount;\r\n        bytes32 data;\r\n        OrderSignature signature;\r\n    }\r\n\r\n    \r\n    struct OrderInfo {\r\n        bytes32 orderHash;\r\n        uint256 filledAmount;\r\n        uint256[2] margins;     \r\n        uint256[2] balances;    \r\n    }\r\n\r\n    struct OrderAddressSet {\r\n        address marketContractAddress;\r\n        address relayer;\r\n    }\r\n\r\n    struct OrderContext {\r\n        IMarketContract marketContract;         \r\n        IMarketContractPool marketContractPool; \r\n        address ctkAddress;                     \r\n        address[2] posAddresses;                \r\n        uint256 takerSide;                      \r\n    }\r\n\r\n    struct MatchResult {\r\n        address maker;\r\n        address taker;\r\n        uint256 makerFee;                   \r\n        uint256 takerFee;                   \r\n        uint256 makerGasFee;\r\n        uint256 takerGasFee;\r\n        uint256 posFilledAmount;            \r\n        uint256 ctkFilledAmount;            \r\n        FillAction fillAction;\r\n    }\r\n\r\n    event Match(\r\n        OrderAddressSet addressSet,\r\n        MatchResult result\r\n    );\r\n\r\n    constructor(address _proxyAddress) public {\r\n        proxyAddress = _proxyAddress;\r\n    }\r\n\r\n    \r\n    function setMarketRegistryAddress(address _marketRegistryAddress)\r\n        external\r\n        onlyOwner\r\n    {\r\n        marketRegistryAddress = _marketRegistryAddress;\r\n    }\r\n\r\n    \r\n    function matchMarketContractOrders(\r\n        OrderParam memory takerOrderParam,\r\n        OrderParam[] memory makerOrderParams,\r\n        uint256[] memory posFilledAmounts,\r\n        OrderAddressSet memory orderAddressSet\r\n    )\r\n        public\r\n    {\r\n        require(canMatchMarketContractOrdersFrom(orderAddressSet.relayer), INVALID_SENDER);\r\n        require(!isMakerOnly(takerOrderParam.data), MAKER_ONLY_ORDER_CANNOT_BE_TAKER);\r\n\r\n        validateMarketContract(orderAddressSet.marketContractAddress);\r\n\r\n        OrderContext memory orderContext = getOrderContext(orderAddressSet, takerOrderParam);\r\n        MatchResult[] memory results = getMatchPlan(\r\n            takerOrderParam,\r\n            makerOrderParams,\r\n            posFilledAmounts,\r\n            orderAddressSet,\r\n            orderContext\r\n        );\r\n        settleResults(results, takerOrderParam, orderAddressSet, orderContext);\r\n    }\r\n\r\n    \r\n    function getOrderContext(\r\n        OrderAddressSet memory orderAddressSet,\r\n        OrderParam memory takerOrderParam\r\n    )\r\n        internal\r\n        view\r\n        returns (OrderContext memory orderContext)\r\n    {\r\n        orderContext.marketContract = IMarketContract(orderAddressSet.marketContractAddress);\r\n        orderContext.marketContractPool = IMarketContractPool(\r\n            orderContext.marketContract.COLLATERAL_POOL_ADDRESS()\r\n        );\r\n        orderContext.ctkAddress = orderContext.marketContract.COLLATERAL_TOKEN_ADDRESS();\r\n        orderContext.posAddresses[LONG] = orderContext.marketContract.LONG_POSITION_TOKEN();\r\n        orderContext.posAddresses[SHORT] = orderContext.marketContract.SHORT_POSITION_TOKEN();\r\n        orderContext.takerSide = isSell(takerOrderParam.data) ? SHORT : LONG;\r\n\r\n        return orderContext;\r\n    }\r\n\r\n    \r\n    function getMatchPlan(\r\n        OrderParam memory takerOrderParam,\r\n        OrderParam[] memory makerOrderParams,\r\n        uint256[] memory posFilledAmounts,\r\n        OrderAddressSet memory orderAddressSet,\r\n        OrderContext memory orderContext\r\n    )\r\n        internal\r\n        returns (MatchResult[] memory results)\r\n    {\r\n        OrderInfo memory takerOrderInfo = getOrderInfo(\r\n            takerOrderParam,\r\n            orderAddressSet,\r\n            orderContext\r\n        );\r\n\r\n        uint256 resultIndex;\r\n        \r\n        \r\n        results = new MatchResult[](makerOrderParams.length * MAX_MATCHES);\r\n        for (uint256 i = 0; i < makerOrderParams.length; i++) {\r\n            require(!isMarketOrder(makerOrderParams[i].data), MAKER_ORDER_CAN_NOT_BE_MARKET_ORDER);\r\n            require(isSell(takerOrderParam.data) != isSell(makerOrderParams[i].data), INVALID_SIDE);\r\n            require(\r\n                takerOrderParam.trader != makerOrderParams[i].trader,\r\n                MAKER_CAN_NOT_BE_SAME_WITH_TAKER\r\n            );\r\n            OrderInfo memory makerOrderInfo = getOrderInfo(\r\n                makerOrderParams[i],\r\n                orderAddressSet,\r\n                orderContext\r\n            );\r\n            validatePrice(\r\n                takerOrderParam,\r\n                makerOrderParams[i],\r\n                orderContext\r\n            );\r\n            uint256 toFillAmount = posFilledAmounts[i];\r\n            for (uint256 j = 0; j < MAX_MATCHES && toFillAmount > 0; j++) {\r\n                MatchResult memory result;\r\n                uint256 filledAmount;\r\n                (result, filledAmount) = getMatchResult(\r\n                    takerOrderParam,\r\n                    takerOrderInfo,\r\n                    makerOrderParams[i],\r\n                    makerOrderInfo,\r\n                    orderContext,\r\n                    toFillAmount\r\n                );\r\n                toFillAmount = toFillAmount.sub(filledAmount);\r\n                results[resultIndex] = result;\r\n                resultIndex++;\r\n            }\r\n            \r\n            \r\n            require(toFillAmount == 0, UNMATCHED_FILL);\r\n            filled[makerOrderInfo.orderHash] = makerOrderInfo.filledAmount;\r\n        }\r\n        filled[takerOrderInfo.orderHash] = takerOrderInfo.filledAmount;\r\n\r\n        return results;\r\n    }\r\n\r\n    \r\n    function validateMarketContract(address marketContractAddress) internal view {\r\n        if (marketRegistryAddress == address(0x0)) {\r\n            return;\r\n        }\r\n        IMarketContractRegistry registry = IMarketContractRegistry(marketRegistryAddress);\r\n        require(\r\n            registry.isAddressWhiteListed(marketContractAddress),\r\n            INVALID_MARKET_CONTRACT\r\n        );\r\n    }\r\n\r\n    \r\n    function calculateMiddleCollateralPerUnit(OrderContext memory orderContext)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return orderContext.marketContract.PRICE_CAP()\r\n            .add(orderContext.marketContract.PRICE_FLOOR())\r\n            .mul(orderContext.marketContract.QTY_MULTIPLIER())\r\n            .div(2);\r\n    }\r\n\r\n    \r\n    function calculateLongMargin(OrderContext memory orderContext, OrderParam memory orderParam)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return orderParam.price\r\n            .sub(orderContext.marketContract.PRICE_FLOOR())\r\n            .mul(orderContext.marketContract.QTY_MULTIPLIER());\r\n    }\r\n\r\n    \r\n    function calculateShortMargin(OrderContext memory orderContext, OrderParam memory orderParam)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return orderContext.marketContract.PRICE_CAP()\r\n            .sub(orderParam.price)\r\n            .mul(orderContext.marketContract.QTY_MULTIPLIER());\r\n    }\r\n\r\n    \r\n    function validatePrice(\r\n        OrderParam memory takerOrderParam,\r\n        OrderParam memory makerOrderParam,\r\n        OrderContext memory orderContext\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (isMarketOrder(takerOrderParam.data)) {\r\n            return;\r\n        }\r\n        if (isSell(takerOrderParam.data)) {\r\n            require(takerOrderParam.price <= makerOrderParam.price, INVALID_MATCH);\r\n        } else {\r\n            require(takerOrderParam.price >= makerOrderParam.price, INVALID_MATCH);\r\n        }\r\n    }\r\n\r\n    \r\n    function getMatchResult(\r\n        OrderParam memory takerOrderParam,\r\n        OrderInfo memory takerOrderInfo,\r\n        OrderParam memory makerOrderParam,\r\n        OrderInfo memory makerOrderInfo,\r\n        OrderContext memory orderContext,\r\n        uint256 posFilledAmount\r\n    )\r\n        internal\r\n        view\r\n        returns (MatchResult memory result, uint256 filledAmount)\r\n    {\r\n        require(makerOrderInfo.filledAmount <= makerOrderParam.amount, MAKER_ORDER_OVER_MATCH);\r\n        require(takerOrderInfo.filledAmount <= takerOrderParam.amount, TAKER_ORDER_OVER_MATCH);\r\n\r\n        \r\n        if (takerOrderInfo.filledAmount == 0) {\r\n            result.takerGasFee = takerOrderParam.gasTokenAmount;\r\n        }\r\n        if (makerOrderInfo.filledAmount == 0) {\r\n            result.makerGasFee = makerOrderParam.gasTokenAmount;\r\n        }\r\n\r\n        \r\n        filledAmount = fillMatchResult(\r\n            result,\r\n            takerOrderParam,\r\n            takerOrderInfo,\r\n            makerOrderParam,\r\n            makerOrderInfo,\r\n            orderContext,\r\n            posFilledAmount\r\n        );\r\n        result.posFilledAmount = filledAmount;\r\n\r\n        \r\n        result.makerFee = filledAmount.mul(getMakerFeeBase(orderContext, makerOrderParam));\r\n        result.takerFee = filledAmount.mul(getTakerFeeBase(orderContext, takerOrderParam));\r\n        result.taker = takerOrderParam.trader;\r\n        result.maker = makerOrderParam.trader;\r\n\r\n        return (result, filledAmount);\r\n    }\r\n\r\n    \r\n    function getMakerFeeBase(\r\n        OrderContext memory orderContext,\r\n        OrderParam memory orderParam\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 middleCollateralPerUnit = calculateMiddleCollateralPerUnit(orderContext);\r\n        return middleCollateralPerUnit\r\n            .mul(getAsMakerFeeRateFromOrderData(orderParam.data))\r\n            .div(FEE_RATE_BASE);\r\n    }\r\n\r\n    \r\n    function getTakerFeeBase(\r\n        OrderContext memory orderContext,\r\n        OrderParam memory orderParam\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 middleCollateralPerUnit = calculateMiddleCollateralPerUnit(orderContext);\r\n        return middleCollateralPerUnit\r\n            .mul(getAsTakerFeeRateFromOrderData(orderParam.data))\r\n            .div(FEE_RATE_BASE);\r\n    }\r\n\r\n    \r\n    function fillMatchResult(\r\n        MatchResult memory result,\r\n        OrderParam memory takerOrderParam,\r\n        OrderInfo memory takerOrderInfo,\r\n        OrderParam memory makerOrderParam,\r\n        OrderInfo memory makerOrderInfo,\r\n        OrderContext memory orderContext,\r\n        uint256 posFilledAmount\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256 filledAmount)\r\n    {\r\n        uint256 side = orderContext.takerSide;\r\n        uint256 opposite = oppositeSide(side);\r\n\r\n        if (takerOrderInfo.balances[opposite] > 0 && makerOrderInfo.balances[side] > 0) {\r\n            \r\n            filledAmount = min(\r\n                min(takerOrderInfo.balances[opposite], posFilledAmount),\r\n                makerOrderInfo.balances[side]\r\n            );\r\n            \r\n            takerOrderInfo.balances[opposite] = takerOrderInfo.balances[opposite]\r\n                .sub(filledAmount);\r\n            makerOrderInfo.balances[side] = makerOrderInfo.balances[side].sub(filledAmount);\r\n\r\n            result.fillAction = FillAction.REDEEM;\r\n            result.ctkFilledAmount = makerOrderInfo.margins[side].mul(filledAmount);\r\n\r\n       } else if (takerOrderInfo.balances[opposite] > 0 && makerOrderInfo.balances[side] == 0) {\r\n            \r\n            filledAmount = min(takerOrderInfo.balances[opposite], posFilledAmount);\r\n            takerOrderInfo.balances[opposite] = takerOrderInfo.balances[opposite]\r\n                .sub(filledAmount);\r\n            makerOrderInfo.balances[opposite] = makerOrderInfo.balances[opposite]\r\n                .add(filledAmount);\r\n\r\n            result.fillAction = FillAction.SELL;\r\n            result.ctkFilledAmount = makerOrderInfo.margins[opposite].mul(filledAmount);\r\n\r\n       } else if (takerOrderInfo.balances[opposite] == 0 && makerOrderInfo.balances[side] > 0) {\r\n            \r\n            filledAmount = min(makerOrderInfo.balances[side], posFilledAmount);\r\n            takerOrderInfo.balances[side] = takerOrderInfo.balances[side].add(filledAmount);\r\n            makerOrderInfo.balances[side] = makerOrderInfo.balances[side].sub(filledAmount);\r\n\r\n            result.fillAction = FillAction.BUY;\r\n            result.ctkFilledAmount = makerOrderInfo.margins[side].mul(filledAmount);\r\n\r\n       } else if (takerOrderInfo.balances[opposite] == 0 && makerOrderInfo.balances[side] == 0) {\r\n            \r\n            filledAmount = posFilledAmount;\r\n            \r\n            takerOrderInfo.balances[side] = takerOrderInfo.balances[side].add(filledAmount);\r\n            makerOrderInfo.balances[opposite] = makerOrderInfo.balances[opposite].add(filledAmount);\r\n\r\n            result.fillAction = FillAction.MINT;\r\n            result.ctkFilledAmount = makerOrderInfo.margins[opposite].mul(filledAmount);\r\n\r\n        } else {\r\n           revert(UNEXPECTED_MATCH);\r\n        }\r\n\r\n        \r\n        takerOrderInfo.filledAmount = takerOrderInfo.filledAmount.add(filledAmount);\r\n        makerOrderInfo.filledAmount = makerOrderInfo.filledAmount.add(filledAmount);\r\n\r\n        require(takerOrderInfo.filledAmount <= takerOrderParam.amount, TAKER_ORDER_OVER_MATCH);\r\n        require(makerOrderInfo.filledAmount <= makerOrderParam.amount, MAKER_ORDER_OVER_MATCH);\r\n\r\n        result.posFilledAmount = filledAmount;\r\n\r\n        return filledAmount;\r\n    }\r\n\r\n    \r\n    function cancelOrder(Order memory order) public {\r\n        \r\n        require(msg.sender == order.relayer, INVALID_TRADER);\r\n\r\n        bytes32 orderHash = getOrderHash(order);\r\n        cancelled[orderHash] = true;\r\n\r\n        emit Cancel(orderHash);\r\n    }\r\n\r\n    \r\n    function getOrderInfo(\r\n        OrderParam memory orderParam,\r\n        OrderAddressSet memory orderAddressSet,\r\n        OrderContext memory orderContext\r\n    )\r\n        internal\r\n        view\r\n        returns (OrderInfo memory orderInfo)\r\n    {\r\n        require(\r\n            getOrderVersion(orderParam.data) == SUPPORTED_ORDER_VERSION,\r\n            ORDER_VERSION_NOT_SUPPORTED\r\n        );\r\n\r\n        Order memory order = getOrderFromOrderParam(orderParam, orderAddressSet);\r\n        orderInfo.orderHash = getOrderHash(order);\r\n        orderInfo.filledAmount = filled[orderInfo.orderHash];\r\n        uint8 status = uint8(OrderStatus.FILLABLE);\r\n\r\n        if (orderInfo.filledAmount >= order.amount) {\r\n            status = uint8(OrderStatus.FULLY_FILLED);\r\n        } else if (block.timestamp >= getExpiredAtFromOrderData(order.data)) {\r\n            status = uint8(OrderStatus.EXPIRED);\r\n        } else if (cancelled[orderInfo.orderHash]) {\r\n            status = uint8(OrderStatus.CANCELLED);\r\n        }\r\n\r\n        require(status == uint8(OrderStatus.FILLABLE), ORDER_IS_NOT_FILLABLE);\r\n        require(\r\n            isValidSignature(orderInfo.orderHash, orderParam.trader, orderParam.signature),\r\n            INVALID_ORDER_SIGNATURE\r\n        );\r\n\r\n        if (!isMarketOrder(orderParam.data)) {\r\n            orderInfo.margins[0] = calculateLongMargin(orderContext, orderParam);\r\n            orderInfo.margins[1] = calculateShortMargin(orderContext, orderParam);\r\n        }\r\n        orderInfo.balances[0] = getERC20Balance(orderContext.posAddresses[0], orderParam.trader);\r\n        orderInfo.balances[1] = getERC20Balance(orderContext.posAddresses[1], orderParam.trader);\r\n\r\n        return orderInfo;\r\n    }\r\n\r\n    \r\n    function getERC20Balance(address tokenAddress, address account)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return IERC20(tokenAddress).balanceOf(account);\r\n    }\r\n\r\n    \r\n    function getOrderFromOrderParam(\r\n        OrderParam memory orderParam,\r\n        OrderAddressSet memory orderAddressSet\r\n    )\r\n        internal\r\n        pure\r\n        returns (Order memory order)\r\n    {\r\n        order.trader = orderParam.trader;\r\n        order.relayer = orderAddressSet.relayer;\r\n        order.marketContractAddress = orderAddressSet.marketContractAddress;\r\n        order.amount = orderParam.amount;\r\n        order.price = orderParam.price;\r\n        order.gasTokenAmount = orderParam.gasTokenAmount;\r\n        order.data = orderParam.data;\r\n    }\r\n\r\n    \r\n    function calculateTotalFee(MatchResult memory result)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return result.takerFee\r\n            .add(result.takerGasFee)\r\n            .add(result.makerFee)\r\n            .add(result.makerGasFee);\r\n    }\r\n\r\n    \r\n    function settleResults(\r\n        MatchResult[] memory results,\r\n        OrderParam memory takerOrderParam,\r\n        OrderAddressSet memory orderAddressSet,\r\n        OrderContext memory orderContext\r\n    )\r\n        internal\r\n    {\r\n        uint256 ctkFromProxyToTaker;\r\n        uint256 ctkFromProxyToRelayer;\r\n        uint256 ctkFromRelayerToTaker;\r\n        uint256 ctkFromTakerToRelayer;\r\n\r\n        for (uint256 i = 0; i < results.length; i++) {\r\n            if (results[i].fillAction == FillAction.REDEEM) {\r\n                \r\n                ctkFromProxyToTaker = ctkFromProxyToTaker\r\n                    .add(doRedeem(results[i], orderAddressSet, orderContext));\r\n                ctkFromProxyToRelayer = ctkFromProxyToRelayer\r\n                    .add(calculateTotalFee(results[i]));\r\n            } else if (results[i].fillAction == FillAction.SELL) {\r\n                \r\n                ctkFromRelayerToTaker = ctkFromRelayerToTaker\r\n                    .add(doSell(results[i], orderAddressSet, orderContext));\r\n            } else if (results[i].fillAction == FillAction.BUY) {\r\n                \r\n                ctkFromTakerToRelayer = ctkFromTakerToRelayer\r\n                    .add(doBuy(results[i], orderAddressSet, orderContext));\r\n            } else if (results[i].fillAction == FillAction.MINT) {\r\n                \r\n                ctkFromProxyToRelayer = ctkFromProxyToRelayer\r\n                    .add(doMint(results[i], orderAddressSet, orderContext));\r\n            } else {\r\n                break;\r\n            }\r\n\r\n            emit Match(orderAddressSet, results[i]);\r\n        }\r\n\r\n        if (ctkFromProxyToTaker > 0) {\r\n            transfer(\r\n                orderContext.ctkAddress,\r\n                takerOrderParam.trader,\r\n                ctkFromProxyToTaker\r\n            );\r\n        }\r\n        if (ctkFromProxyToRelayer > 0) {\r\n            transfer(\r\n                orderContext.ctkAddress,\r\n                orderAddressSet.relayer,\r\n                ctkFromProxyToRelayer\r\n            );\r\n        }\r\n        if (ctkFromRelayerToTaker > ctkFromTakerToRelayer) {\r\n            transferFrom(\r\n                orderContext.ctkAddress,\r\n                orderAddressSet.relayer,\r\n                takerOrderParam.trader,\r\n                ctkFromRelayerToTaker.sub(ctkFromTakerToRelayer)\r\n            );\r\n        } else if (ctkFromRelayerToTaker < ctkFromTakerToRelayer) {\r\n            transferFrom(\r\n                orderContext.ctkAddress,\r\n                takerOrderParam.trader,\r\n                orderAddressSet.relayer,\r\n                ctkFromTakerToRelayer.sub(ctkFromRelayerToTaker)\r\n            );\r\n        }\r\n    }\r\n\r\n    function doSell(\r\n        MatchResult memory result,\r\n        OrderAddressSet memory orderAddressSet,\r\n        OrderContext memory orderContext\r\n    )\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        \r\n        transferFrom(\r\n            orderContext.posAddresses[oppositeSide(orderContext.takerSide)],\r\n            result.taker,\r\n            result.maker,\r\n            result.posFilledAmount\r\n        );\r\n        \r\n        transferFrom(\r\n            orderContext.ctkAddress,\r\n            result.maker,\r\n            orderAddressSet.relayer,\r\n            result.ctkFilledAmount\r\n                .add(result.makerFee)\r\n                .add(result.makerGasFee)\r\n        );\r\n        require(result.ctkFilledAmount >= result.takerFee.add(result.takerGasFee), LOW_MARGIN);\r\n        \r\n        return result.ctkFilledAmount\r\n            .sub(result.takerFee)\r\n            .sub(result.takerGasFee);\r\n    }\r\n\r\n    function oppositeSide(uint256 side) internal pure returns (uint256) {\r\n        return side == LONG ? SHORT : LONG;\r\n    }\r\n\r\n    \r\n    function doRedeem(\r\n        MatchResult memory result,\r\n        OrderAddressSet memory orderAddressSet,\r\n        OrderContext memory orderContext\r\n    )\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        \r\n        transferFrom(\r\n            orderContext.posAddresses[oppositeSide(orderContext.takerSide)],\r\n            result.taker,\r\n            proxyAddress,\r\n            result.posFilledAmount\r\n        );\r\n        \r\n        transferFrom(\r\n            orderContext.posAddresses[orderContext.takerSide],\r\n            result.maker,\r\n            proxyAddress,\r\n            result.posFilledAmount\r\n        );\r\n        \r\n        redeemPositionTokens(orderAddressSet.marketContractAddress, result.posFilledAmount);\r\n        \r\n        transfer(\r\n            orderContext.ctkAddress,\r\n            result.maker,\r\n            result.ctkFilledAmount\r\n                .sub(result.makerFee)\r\n                .sub(result.makerGasFee)\r\n        );\r\n        uint256 collateralToReturn = result.posFilledAmount\r\n            .mul(orderContext.marketContract.COLLATERAL_PER_UNIT());\r\n        \r\n        return collateralToReturn\r\n            .sub(result.ctkFilledAmount)\r\n            .sub(result.takerFee)\r\n            .sub(result.takerGasFee);\r\n    }\r\n\r\n    \r\n    function doBuy(\r\n        MatchResult memory result,\r\n        OrderAddressSet memory,\r\n        OrderContext memory orderContext\r\n    )\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        \r\n        transferFrom(\r\n            orderContext.posAddresses[orderContext.takerSide],\r\n            result.maker,\r\n            result.taker,\r\n            result.posFilledAmount\r\n        );\r\n        require(result.ctkFilledAmount >= result.makerFee.add(result.makerGasFee), LOW_MARGIN);\r\n        \r\n        transferFrom(\r\n            orderContext.ctkAddress,\r\n            result.taker,\r\n            result.maker,\r\n            result.ctkFilledAmount\r\n                .sub(result.makerFee)\r\n                .sub(result.makerGasFee)\r\n        );\r\n        \r\n        return result.takerFee\r\n            .add(result.takerGasFee)\r\n            .add(result.makerFee)\r\n            .add(result.makerGasFee);\r\n    }\r\n\r\n    \r\n    function doMint(\r\n        MatchResult memory result,\r\n        OrderAddressSet memory orderAddressSet,\r\n        OrderContext memory orderContext\r\n    )\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        \r\n        uint256 neededCollateral = result.posFilledAmount\r\n            .mul(orderContext.marketContract.COLLATERAL_PER_UNIT());\r\n        uint256 neededCollateralTokenFee = result.posFilledAmount\r\n            .mul(orderContext.marketContract.COLLATERAL_TOKEN_FEE_PER_UNIT());\r\n        uint256 totalFee = result.takerFee.add(result.makerFee);\r\n\r\n        if (neededCollateralTokenFee > totalFee) {\r\n            transferFrom(\r\n                orderContext.ctkAddress,\r\n                orderAddressSet.relayer,\r\n                proxyAddress,\r\n                neededCollateralTokenFee.sub(totalFee)\r\n            );\r\n        }\r\n        \r\n        transferFrom(\r\n            orderContext.ctkAddress,\r\n            result.maker,\r\n            proxyAddress,\r\n            result.ctkFilledAmount\r\n                .add(result.makerFee)\r\n                .add(result.makerGasFee)\r\n        );\r\n        \r\n        transferFrom(\r\n            orderContext.ctkAddress,\r\n            result.taker,\r\n            proxyAddress,\r\n            neededCollateral\r\n                .sub(result.ctkFilledAmount)\r\n                .add(result.takerFee)\r\n                .add(result.takerGasFee)\r\n        );\r\n        \r\n        mintPositionTokens(orderAddressSet.marketContractAddress, result.posFilledAmount);\r\n        \r\n        transfer(\r\n            orderContext.posAddresses[orderContext.takerSide],\r\n            result.taker,\r\n            result.posFilledAmount\r\n        );\r\n        \r\n        transfer(\r\n            orderContext.posAddresses[oppositeSide(orderContext.takerSide)],\r\n            result.maker,\r\n            result.posFilledAmount\r\n        );\r\n        if (neededCollateralTokenFee > totalFee) {\r\n            return result.takerGasFee.add(result.makerGasFee);\r\n        }\r\n        \r\n        return result.makerFee\r\n            .add(result.takerFee)\r\n            .add(result.takerGasFee)\r\n            .add(result.makerGasFee)\r\n            .sub(neededCollateralTokenFee);\r\n    }\r\n\r\n    \r\n    function transfer(address token, address to, uint256 value) internal {\r\n        if (value == 0) {\r\n            return;\r\n        }\r\n\r\n        address proxy = proxyAddress;\r\n        uint256 result;\r\n\r\n        \r\n        \r\n        assembly {\r\n            \r\n            let tmp1 := mload(0)\r\n            let tmp2 := mload(4)\r\n            let tmp3 := mload(36)\r\n            let tmp4 := mload(68)\r\n\r\n            \r\n            mstore(0, 0xbeabacc800000000000000000000000000000000000000000000000000000000)\r\n            mstore(4, token)\r\n            mstore(36, to)\r\n            mstore(68, value)\r\n\r\n            \r\n            result := call(\r\n                gas,   \r\n                proxy, \r\n                0,     \r\n                0,     \r\n                100,   \r\n                0,     \r\n                0      \r\n            )\r\n\r\n            \r\n            mstore(0, tmp1)\r\n            mstore(4, tmp2)\r\n            mstore(36, tmp3)\r\n            mstore(68, tmp4)\r\n        }\r\n\r\n        if (result == 0) {\r\n            revert(TRANSFER_FAILED);\r\n        }\r\n    }\r\n\r\n    \r\n    function transferFrom(address token, address from, address to, uint256 value) internal {\r\n        if (value == 0) {\r\n            return;\r\n        }\r\n\r\n        address proxy = proxyAddress;\r\n        uint256 result;\r\n\r\n        \r\n        \r\n        assembly {\r\n            \r\n            let tmp1 := mload(0)\r\n            let tmp2 := mload(4)\r\n            let tmp3 := mload(36)\r\n            let tmp4 := mload(68)\r\n            let tmp5 := mload(100)\r\n\r\n            \r\n            mstore(0, 0x15dacbea00000000000000000000000000000000000000000000000000000000)\r\n            mstore(4, token)\r\n            mstore(36, from)\r\n            mstore(68, to)\r\n            mstore(100, value)\r\n\r\n            \r\n            result := call(\r\n                gas,   \r\n                proxy, \r\n                0,     \r\n                0,     \r\n                132,   \r\n                0,     \r\n                0      \r\n            )\r\n\r\n            \r\n            mstore(0, tmp1)\r\n            mstore(4, tmp2)\r\n            mstore(36, tmp3)\r\n            mstore(68, tmp4)\r\n            mstore(100, tmp5)\r\n        }\r\n\r\n        if (result == 0) {\r\n            revert(TRANSFER_FROM_FAILED);\r\n        }\r\n    }\r\n\r\n    function mintPositionTokens(address contractAddress, uint256 value) internal {\r\n        if (value == 0) {\r\n            return;\r\n        }\r\n\r\n        address proxy = proxyAddress;\r\n        uint256 result;\r\n\r\n        \r\n        \r\n        assembly {\r\n            \r\n            let tmp1 := mload(0)\r\n            let tmp2 := mload(4)\r\n            let tmp3 := mload(36)\r\n\r\n            \r\n            mstore(0, 0x2bb0d30f00000000000000000000000000000000000000000000000000000000)\r\n            mstore(4, contractAddress)\r\n            mstore(36, value)\r\n\r\n            \r\n            result := call(\r\n                gas,   \r\n                proxy, \r\n                0,     \r\n                0,     \r\n                68,   \r\n                0,     \r\n                0      \r\n            )\r\n\r\n            \r\n            mstore(0, tmp1)\r\n            mstore(4, tmp2)\r\n            mstore(36, tmp3)\r\n        }\r\n\r\n        if (result == 0) {\r\n            revert(MINT_POSITION_TOKENS_FAILED);\r\n        }\r\n    }\r\n\r\n    function redeemPositionTokens(address contractAddress, uint256 value) internal {\r\n        if (value == 0) {\r\n            return;\r\n        }\r\n\r\n        address proxy = proxyAddress;\r\n        uint256 result;\r\n\r\n        \r\n        \r\n        assembly {\r\n            \r\n            let tmp1 := mload(0)\r\n            let tmp2 := mload(4)\r\n            let tmp3 := mload(36)\r\n\r\n            \r\n            mstore(0, 0xc1b2141100000000000000000000000000000000000000000000000000000000)\r\n            mstore(4, contractAddress)\r\n            mstore(36, value)\r\n\r\n            \r\n            result := call(\r\n                gas,   \r\n                proxy, \r\n                0,     \r\n                0,     \r\n                68,   \r\n                0,     \r\n                0      \r\n            )\r\n\r\n            \r\n            mstore(0, tmp1)\r\n            mstore(4, tmp2)\r\n            mstore(36, tmp3)\r\n        }\r\n\r\n        if (result == 0) {\r\n            revert(REDEEM_POSITION_TOKENS_FAILED);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"approveDelegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_MATCHES\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"canMatchMarketContractOrdersFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"filled\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"cancelled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"relayerDelegates\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exitIncentiveSystem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EIP712_ORDER_TYPE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LONG\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"relayer\",\"type\":\"address\"},{\"name\":\"marketContractAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"gasTokenAmount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes32\"}],\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEE_RATE_BASE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REBATE_RATE_BASE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"gasTokenAmount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"config\",\"type\":\"bytes32\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"takerOrderParam\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"gasTokenAmount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"config\",\"type\":\"bytes32\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"makerOrderParams\",\"type\":\"tuple[]\"},{\"name\":\"posFilledAmounts\",\"type\":\"uint256[]\"},{\"components\":[{\"name\":\"marketContractAddress\",\"type\":\"address\"},{\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"orderAddressSet\",\"type\":\"tuple\"}],\"name\":\"matchMarketContractOrders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"isParticipant\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SHORT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_marketRegistryAddress\",\"type\":\"address\"}],\"name\":\"setMarketRegistryAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"joinIncentiveSystem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SUPPORTED_ORDER_VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EIP712_DOMAIN_TYPEHASH\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketRegistryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"revokeDelegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_proxyAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"name\":\"marketContractAddress\",\"type\":\"address\"},{\"name\":\"relayer\",\"type\":\"address\"}],\"indexed\":false,\"name\":\"addressSet\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"taker\",\"type\":\"address\"},{\"name\":\"makerFee\",\"type\":\"uint256\"},{\"name\":\"takerFee\",\"type\":\"uint256\"},{\"name\":\"makerGasFee\",\"type\":\"uint256\"},{\"name\":\"takerGasFee\",\"type\":\"uint256\"},{\"name\":\"posFilledAmount\",\"type\":\"uint256\"},{\"name\":\"ctkFilledAmount\",\"type\":\"uint256\"},{\"name\":\"fillAction\",\"type\":\"uint8\"}],\"indexed\":false,\"name\":\"result\",\"type\":\"tuple\"}],\"name\":\"Match\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"RelayerApproveDelegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"RelayerRevokeDelegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"RelayerExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"RelayerJoin\",\"type\":\"event\"}]","ContractName":"MaiProtocol","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000373552f6d1eaaeadf54dd3b4147275804f2fd34d","Library":"","LicenseType":"Apache-2.0","SwarmSource":"bzzr://09e6b4a42b6c0f336dd2d9ec0969d61476c39e90204f87da08325ad7c0982aea"}]}