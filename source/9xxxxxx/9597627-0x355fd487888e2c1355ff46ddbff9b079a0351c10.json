{"status":"1","message":"OK","result":[{"SourceCode":"{\"MKDSToken.sol\":{\"content\":\"/**\\r\\n * MKDS Token Smart Contract.\\r\\n * Copyright (c) 2020 by owner.\\r\\n */\\r\\npragma solidity ^0.4.20;\\r\\n\\r\\nimport \\\"SafeMath.sol\\\";\\r\\nimport \\\"Token.sol\\\";\\r\\n\\r\\n/**\\r\\n * MKDS Token Smart Contract: EIP-20 compatible token smart contract that\\r\\n * manages MKDS tokens.\\r\\n */\\r\\ncontract MKDSToken is SafeMath {\\r\\n  string constant public contact = \\\"cryp10grapher@protonmail.com\\\";\\r\\n  string constant public name = \\\"MKDS Token - Стабилизиран со Македонски Денар\\\";\\r\\n  string constant public symbol = \\\"MKDS\\\";\\r\\n  uint8 constant public decimals = 3;\\r\\n  Token constant targetToken = Token(address(0xdB25f211AB05b1c97D595516F45794528a807ad8));\\r\\n  address public owner;\\r\\n  address public beneficiary;\\r\\n  uint256 constant conversionRateNumerator = 6160000 * 10; // MKDS/EURS; * 10 because MKDS is 3 decimals and EURS is 2\\r\\n  uint256 constant denominator = 100000;\\r\\n  uint256 transferFeeMin = 1000; // transfer fee minimum in 1/100\\u0027s of a MKDS, since MKDS token has 3 decimals\\r\\n  uint256 transferFeeMax = 1000; // transfer fee maximum in 1/100\\u0027s of a MKDS, since MKDS token has 3 decimals\\r\\n  uint256 transferFeeFactorNumerator = 100; // transfer fee factor; (initialized for 0.1%); actual factor is obtained by dividing this by denominator\\r\\n\\r\\n  mapping(address =\\u003e uint256) private balances;\\r\\n  mapping(address =\\u003e mapping (address =\\u003e uint256)) private allowances;\\r\\n\\r\\n  /**\\r\\n   * Create MKDS Token smart contract with message sender as an owner.\\r\\n   */\\r\\n  function MKDSToken() public {\\r\\n    owner = msg.sender;\\r\\n    beneficiary = owner;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Make sure the modified function can be executed only by the owner.\\r\\n   */\\r\\n   modifier onlyOwner() {\\r\\n    require(0 != owner);\\r\\n    require(msg.sender == owner);\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Transfer ownership of this smart contract to a new address.\\r\\n   *\\r\\n   * @param _owner address of the new owner. If set to 0, the owner loses control of the contract.\\r\\n   */\\r\\n  function setOwner(address _owner) external onlyOwner() {\\r\\n    owner = _owner; // If set to 0, owner loses control of the contract\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Set new beneficiary.\\r\\n   *\\r\\n   * @param _beneficiary address of the new beneficiary.\\r\\n   */\\r\\n  function setBeneficiary(address _beneficiary) external onlyOwner() {\\r\\n    beneficiary = _beneficiary; // If set to 0, there is no oracle\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Destroy the smart contract and return all EURS and ETH to the owner.\\r\\n   */\\r\\n  function destroy() external onlyOwner() { // Only for alpha version - refund of holders would have to be done manually\\r\\n    // if (!targetToken.transfer.value(0)(msg.sender, targetToken.balanceOf(this))) return; // does not work due to Solidity issue thus the next line\\r\\n    if (!address(targetToken).call.value(0)(abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", msg.sender, targetToken.balanceOf(this)))) return;\\r\\n    else selfdestruct(msg.sender);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Convert from EURS to MKDS.\\r\\n   *\\r\\n   * @param value amount of EURS\\r\\n   * @return countervalue in MKDS\\r\\n   */\\r\\n  function toMKDS(uint256 value) public pure returns(uint256) {\\r\\n    return safeMul(value, conversionRateNumerator) / denominator; // there should be no rounding as 0.01 EURS = 0.616 MKDS or internally 1 EURS would be 616 MKDS\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Convert from MKDS to EURS.\\r\\n   *\\r\\n   * @param value amount of MKDS\\r\\n   * @return countervalue in EURS\\r\\n   */\\r\\n  function toEURS(uint256 value) public pure returns(uint256) {\\r\\n    return safeMul(value, denominator) / conversionRateNumerator;\\r\\n    // uint256 v = safeMul(value, denominator);\\r\\n    // uint256 r = v/conversionRateNumerator; // round down\\r\\n    // if (v%conversionRateNumerator \\u003e uint256(0)) return safeAdd(r, uint256(1)); else return r; // round up to cover the value in EURS\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Set new transfer fee parameters.\\r\\n   *\\r\\n   * @param _transferFeeMin // new transfer fee minimum in 1/100\\u0027s of a MKDS, since MKDS token has 2 decimals\\r\\n   * @param _transferFeeMax // new transfer fee maximum in 1/100\\u0027s of a MKDS, since MKDS token has 2 decimals\\r\\n   * @param _transferFeeFactorNumerator // new transfer fee factor numerator - actual factor is derived by dividing this by denominator\\r\\n   */\\r\\n  function setTranactionFeeParameters(\\r\\n    uint256 _transferFeeMin,\\r\\n    uint256 _transferFeeMax,\\r\\n    uint256 _transferFeeFactorNumerator) external onlyOwner() { // In this version onlyOwner() but in the future set governance by voting\\r\\n    transferFeeMin = _transferFeeMin;\\r\\n    transferFeeMax = _transferFeeMax;\\r\\n    transferFeeFactorNumerator = _transferFeeFactorNumerator;\\r\\n  }\\r\\n\\r\\n  /** Calculates the transaction fee for transfers.\\r\\n   *\\r\\n   * @param value the transfer amount\\r\\n   * @return fee in MKDS\\r\\n   */\\r\\n  function transferFee(uint256 value) public view returns(uint256) {\\r\\n    uint256 fee = safeMul(value, transferFeeFactorNumerator) / denominator; // round down\\r\\n    if (fee \\u003c transferFeeMin) return transferFeeMin;\\r\\n    else if (fee \\u003e transferFeeMax) return transferFeeMax;\\r\\n    else return fee;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Make deposit.\\r\\n   * Depositor must first call approve(\\u003caddress ofMKDSToken\\u003e,\\u003camount in EURS\\u003e),\\r\\n   * and then call this function to complete the deposit.\\r\\n   */\\r\\n  function deposit() public payable {\\r\\n    // depositor sets allowance by calling EURS.approve(MKDS, value)\\r\\n    uint256 _value = targetToken.allowance(msg.sender, address(this));\\r\\n    if (targetToken.transferFrom.value(0)(msg.sender, address(this), _value)) {\\r\\n      balances[msg.sender] += toMKDS(_value);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Make sure cannot receive ETH.\\r\\n   */\\r\\n  function () public {\\r\\n    revert();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Withdraw.\\r\\n   */\\r\\n  function withdraw() public {\\r\\n    uint256 amount = toEURS(balances[msg.sender]);\\r\\n    balances[msg.sender] = safeSub(balances[msg.sender], toMKDS(amount)); // May leave small reminder\\r\\n    // require(targetToken.transfer.value()(msg.sender, amount)); does not work because of Solidity issue, thus next line\\r\\n    require(address(targetToken).call.value(0)(abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", msg.sender, amount)));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Get total number of tokens in circulation.\\r\\n   *\\r\\n   * @return total number of tokens in circulation\\r\\n   */\\r\\n  function totalSupply() public view returns (uint256) {\\r\\n    return toMKDS(address(this).balance);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Get number of tokens currently belonging to given owner.\\r\\n   *\\r\\n   * @param _owner address to get number of tokens currently belonging to the\\r\\n   *        owner of\\r\\n   * @return number of tokens currently belonging to the owner of given address\\r\\n   */\\r\\n   function balanceOf(address _owner) public view returns (uint256 balance) {\\r\\n    return balances[_owner];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Transfer given number of tokens from message sender to given recipient.\\r\\n   *\\r\\n   * @param _to address to transfer tokens to the owner of\\r\\n   * @param _value number of tokens to transfer to the owner of given address excluding fees\\r\\n   * @return true if tokens were transferred successfully, false otherwise\\r\\n   */\\r\\n  function transfer(address _to, uint256 _value)\\r\\n  public returns (bool) {\\r\\n    uint256 fee = transferFee(_value);\\r\\n    uint256 out = safeAdd(_value, fee);\\r\\n    if (balances[msg.sender] \\u003c out) return false;\\r\\n    balances[msg.sender] -= out;\\r\\n    balances[_to] += _value;\\r\\n    balances[beneficiary] += fee;\\r\\n    emit Transfer(msg.sender, _to, _value);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Transfer given number of tokens from given owner to given recipient.\\r\\n   * @dev Permissioning is delegated to the targetToken.\\r\\n   *\\r\\n   * @param _from address to transfer tokens from the owner of\\r\\n   * @param _to address to transfer tokens to the owner of\\r\\n   * @param _value number of tokens to transfer from given owner to given\\r\\n   *        recipient\\r\\n   * @return true if tokens were transferred successfully, false otherwise\\r\\n   */\\r\\n  function transferFrom(address _from, address _to, uint256 _value)\\r\\n  public returns (bool) {\\r\\n    if (0 == _value) return false; // To avoid draining through fees\\r\\n    if (allowances[_from][msg.sender] \\u003c _value) return false;\\r\\n    allowances[_from][msg.sender] -= _value;\\r\\n\\r\\n    uint256 fee = transferFee(_value);\\r\\n    uint256 out = safeAdd(_value, fee);\\r\\n    if (balances[_from] \\u003c safeAdd(_value, fee)) return false;\\r\\n    balances[_from] -= out;\\r\\n    balances[_to] += _value;\\r\\n    balances[beneficiary] += fee;\\r\\n    emit Transfer(_from, _to, _value);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Allow given spender to transfer given number of tokens from message sender.\\r\\n   * @dev Permissioning is delegated to the targetToken.\\r\\n   *\\r\\n   * @param _spender address to allow the owner of to transfer tokens from\\r\\n   *        message sender\\r\\n   * @param _value number of tokens to allow to transfer\\r\\n   * @return true if token transfer was successfully approved, false otherwise\\r\\n   */\\r\\n  function approve (address _spender, uint256 _value)\\r\\n  public returns (bool success) {\\r\\n    allowances[msg.sender][_spender] = _value;\\r\\n    emit Approval(msg.sender, _spender, _value);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Tell how many tokens given spender is currently allowed to transfer from\\r\\n   * given owner.\\r\\n   *\\r\\n   * @param _owner address to get number of tokens allowed to be transferred\\r\\n   *        from the owner of\\r\\n   * @param _spender address to get number of tokens allowed to be transferred\\r\\n   *        by the owner of\\r\\n   * @return number of tokens given spender is currently allowed to transfer\\r\\n   *         from given owner\\r\\n   */\\r\\n  function allowance (address _owner, address _spender)\\r\\n  public view returns (uint256 remaining) {\\r\\n      return allowances[_owner][_spender];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Logged when tokens were transferred from one owner to another.\\r\\n   *\\r\\n   * @param _from address of the owner, tokens were transferred from\\r\\n   * @param _to address of the owner, tokens were transferred to\\r\\n   * @param _value number of tokens transferred\\r\\n   */\\r\\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\\r\\n\\r\\n  /**\\r\\n   * Logged when owner approved his tokens to be transferred by some spender.\\r\\n   *\\r\\n   * @param _owner owner who approved his tokens to be transferred\\r\\n   * @param _spender spender who were allowed to transfer the tokens belonging\\r\\n   *        to the owner\\r\\n   * @param _value number of tokens belonging to the owner, approved to be\\r\\n   *        transferred by the spender\\r\\n   */\\r\\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"/*\\n * Safe Math Smart Contract.  Copyright © 2016–2017 by ABDK Consulting.\\n * Copyright (c) 2018 by STSS (Malta) Limited.\\n * Contact: \\u003ctech@stasis.net\\u003e\\n */\\npragma solidity ^0.4.20;\\n\\n/**\\n * Provides methods to safely add, subtract and multiply uint256 numbers.\\n */\\ncontract SafeMath {\\n  uint256 constant private MAX_UINT256 =\\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n  /**\\n   * Add two uint256 values, throw in case of overflow.\\n   *\\n   * @param x first value to add\\n   * @param y second value to add\\n   * @return x + y\\n   */\\n  function safeAdd (uint256 x, uint256 y)\\n  pure internal\\n  returns (uint256 z) {\\n    assert (x \\u003c= MAX_UINT256 - y);\\n    return x + y;\\n  }\\n\\n  /**\\n   * Subtract one uint256 value from another, throw in case of underflow.\\n   *\\n   * @param x value to subtract from\\n   * @param y value to subtract\\n   * @return x - y\\n   */\\n  function safeSub (uint256 x, uint256 y)\\n  pure internal\\n  returns (uint256 z) {\\n    assert (x \\u003e= y);\\n    return x - y;\\n  }\\n\\n  /**\\n   * Multiply two uint256 values, throw in case of overflow.\\n   *\\n   * @param x first value to multiply\\n   * @param y second value to multiply\\n   * @return x * y\\n   */\\n  function safeMul (uint256 x, uint256 y)\\n  pure internal\\n  returns (uint256 z) {\\n    if (y == 0) return 0; // Prevent division by zero at the next line\\n    assert (x \\u003c= MAX_UINT256 / y);\\n    return x * y;\\n  }\\n}\\n\"},\"Token.sol\":{\"content\":\"/*\\n * EIP-20 Standard Token Smart Contract Interface.\\n * Copyright (c) 2018 by STSS (Malta) Limited.\\n * Contact: \\u003ctech@stasis.net\\u003e\\n */\\npragma solidity ^0.4.20;\\n\\n/**\\n * ERC-20 standard token interface, as defined\\n * \\u003ca href=\\\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\\"\\u003ehere\\u003c/a\\u003e.\\n */\\ncontract Token {\\n  /**\\n   * Get total number of tokens in circulation.\\n   *\\n   * @return total number of tokens in circulation\\n   */\\n  function totalSupply () public view returns (uint256 supply);\\n\\n  /**\\n   * Get number of tokens currently belonging to given owner.\\n   *\\n   * @param _owner address to get number of tokens currently belonging to the\\n   *        owner of\\n   * @return number of tokens currently belonging to the owner of given address\\n   */\\n  function balanceOf (address _owner) public view returns (uint256 balance);\\n\\n  /**\\n   * Transfer given number of tokens from message sender to given recipient.\\n   *\\n   * @param _to address to transfer tokens to the owner of\\n   * @param _value number of tokens to transfer to the owner of given address\\n   * @return true if tokens were transferred successfully, false otherwise\\n   */\\n  function transfer (address _to, uint256 _value)\\n  public payable returns (bool success);\\n\\n  /**\\n   * Transfer given number of tokens from given owner to given recipient.\\n   *\\n   * @param _from address to transfer tokens from the owner of\\n   * @param _to address to transfer tokens to the owner of\\n   * @param _value number of tokens to transfer from given owner to given\\n   *        recipient\\n   * @return true if tokens were transferred successfully, false otherwise\\n   */\\n  function transferFrom (address _from, address _to, uint256 _value)\\n  public payable returns (bool success);\\n\\n  /**\\n   * Allow given spender to transfer given number of tokens from message sender.\\n   *\\n   * @param _spender address to allow the owner of to transfer tokens from\\n   *        message sender\\n   * @param _value number of tokens to allow to transfer\\n   * @return true if token transfer was successfully approved, false otherwise\\n   */\\n  function approve (address _spender, uint256 _value)\\n  public payable returns (bool success);\\n\\n  /**\\n   * Tell how many tokens given spender is currently allowed to transfer from\\n   * given owner.\\n   *\\n   * @param _owner address to get number of tokens allowed to be transferred\\n   *        from the owner of\\n   * @param _spender address to get number of tokens allowed to be transferred\\n   *        by the owner of\\n   * @return number of tokens given spender is currently allowed to transfer\\n   *         from given owner\\n   */\\n  function allowance (address _owner, address _spender)\\n  public view returns (uint256 remaining);\\n\\n  /**\\n   * Logged when tokens were transferred from one owner to another.\\n   *\\n   * @param _from address of the owner, tokens were transferred from\\n   * @param _to address of the owner, tokens were transferred to\\n   * @param _value number of tokens transferred\\n   */\\n  event Transfer (address indexed _from, address indexed _to, uint256 _value);\\n\\n  /**\\n   * Logged when owner approved his tokens to be transferred by some spender.\\n   *\\n   * @param _owner owner who approved his tokens to be transferred\\n   * @param _spender spender who were allowed to transfer the tokens belonging\\n   *        to the owner\\n   * @param _value number of tokens belonging to the owner, approved to be\\n   *        transferred by the spender\\n   */\\n  event Approval (\\n    address indexed _owner, address indexed _spender, uint256 _value);\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contact\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"toMKDS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"toEURS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transferFeeMin\",\"type\":\"uint256\"},{\"name\":\"_transferFeeMax\",\"type\":\"uint256\"},{\"name\":\"_transferFeeFactorNumerator\",\"type\":\"uint256\"}],\"name\":\"setTranactionFeeParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"MKDSToken","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://c90370952b04bd81cafb65eae63d3059677f927c8d08fe2e79c6d584add2d435"}]}