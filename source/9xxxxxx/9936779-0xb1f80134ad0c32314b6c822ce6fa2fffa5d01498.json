{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-04-22\r\n*/\r\n\r\npragma solidity ^0.5.0;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n    function mint(address account, uint256 amount) public returns (bool);\r\n    function burn(uint256 amount) public returns (bool);\r\n}\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\ncontract MultiCoinVault is Ownable {\r\n    address private daricDXAUAddress;\r\n    address public messenger;\r\n    uint public fees;\r\n    address payable public feesAddress;\r\n    struct Pair{\r\n        uint price;\r\n        string tokenName;\r\n        string tokenSymbol;\r\n        string market;\r\n        address tokenContract;\r\n        uint decimal;\r\n        uint liquidity;\r\n    }\r\n    mapping(bytes => Pair) pairs;\r\n    using SafeMath for uint256;\r\n\r\n    constructor(\r\n        address _daricDXAUAddress,\r\n        uint _fees,\r\n        address payable  _feesAddress\r\n    ) public {\r\n        daricDXAUAddress = _daricDXAUAddress;\r\n        fees = _fees;\r\n        feesAddress = _feesAddress;\r\n    }\r\n\r\n    event generated(\r\n        address _generator,\r\n        uint256 _amount,\r\n        uint256 _amountGenerated,\r\n        uint256 _fees,\r\n        uint256 _price,\r\n        string ticker,\r\n        string _market\r\n    );\r\n \r\n    event pairAdded(string market, string tokenName, string tokenSymbol, address tokenContract,  uint price, uint decimal, uint liquidity);\r\n    event pairDeleted(string _market);\r\n    event priceChanged(address initiator, uint256 _from, uint256 _to , string market); \r\n    event liquidityChanged(address initiator, uint256 _from, uint256 _to, string market);\r\n    event contractChanged(address initiator, address _from, address _to, string _market);\r\n    event messengerChanged(address _from, address _to);\r\n    modifier onlyMessenger() {\r\n        require(msg.sender == messenger, \"caller is not a messenger\");\r\n        _;\r\n    }\r\n\r\n    function addPair(string memory _market, string memory _tokenName, \r\n    string memory _tokenSymbol, address  _tokenContract, uint _price, uint _decimal, uint _liquidity) onlyOwner public returns (bool) {\r\n        bytes memory key = bytes(_market);\r\n         if (pairs[key].tokenContract != address(0)) {\r\n             // Don't overwrite previous mappings and return false\r\n             return false;\r\n         }\r\n        Pair storage pair = pairs[key];\r\n        pair.market = _market;\r\n        pair.tokenName = _tokenName;\r\n        pair.tokenSymbol = _tokenSymbol;\r\n        pair.tokenContract = _tokenContract;\r\n        pair.price = _price;\r\n        pair.decimal = _decimal;\r\n        pair.liquidity = _liquidity;\r\n        emit pairAdded(_market, _tokenName, _tokenSymbol, _tokenContract, _price, _decimal, _liquidity);\r\n        return true;\r\n    }\r\n    \r\n    function deletePair(string memory _market) onlyOwner public returns(bool){\r\n       bytes memory key = bytes(_market);\r\n        require(pairs[key].tokenContract != address(0), \"No token found\");\r\n        \r\n        delete pairs[key];\r\n        emit pairDeleted(_market);\r\n        return true;\r\n    }\r\n\r\n    function getPairInfo(string memory _market) public view returns (address _tokenContract, string memory _tokenName, string memory _tokenSymbol, uint _price, string memory market, uint _decimal, uint _liquidity) {\r\n        bytes memory convertedMarket = bytes(_market);\r\n        Pair memory pair = pairs[convertedMarket];\r\n        return (pair.tokenContract, pair.tokenName, pair.tokenSymbol, pair.price, pair.market, pair.decimal, pair.liquidity);\r\n    }\r\n    \r\n    function generate(string memory _market, uint _tokenvalueInWei) public returns(bool){\r\n        require(_tokenvalueInWei > 0, \"Amount should be greater than zero\");\r\n        bytes memory convertedMarket = bytes(_market);\r\n        Pair storage pair = pairs[convertedMarket];\r\n        require(pair.tokenContract != address(0), \"Invalid market\");\r\n        IERC20 daricDXAU = IERC20(daricDXAUAddress);\r\n        IERC20 genericCoin = IERC20(pair.tokenContract);\r\n        uint _generate = pair.price.mul(_tokenvalueInWei);\r\n        uint fee = uint(int256(_generate) / int256(10000) * int256(fees));\r\n        uint finalGen = _generate.sub(fee).div(10 ** pair.decimal);\r\n        uint finalFees = fee.div(10 ** pair.decimal);\r\n        require(finalGen.add(finalFees) <= pair.liquidity, \"Non-sufficient liquidity\");\r\n        pair.liquidity = pair.liquidity.sub(finalGen.add(finalFees));\r\n        require(genericCoin.allowance(msg.sender, address(this)) >= _tokenvalueInWei, \"Non-sufficient funds\");\r\n        require(genericCoin.transferFrom(msg.sender, address(this), _tokenvalueInWei), \"Fail to tranfer fund\");\r\n        require(daricDXAU.mint(msg.sender, finalGen), \"Fail to generate fund\");\r\n        require(daricDXAU.mint(feesAddress, finalFees), \"Fail to send fees\");\r\n        emit generated(msg.sender, _tokenvalueInWei, finalGen, finalFees, pair.price, pair.tokenSymbol, pair.market);\r\n        return true;\r\n    }\r\n    \r\n    function generateETH(string memory _market) payable public returns(bool){\r\n        uint _tokenvalueInWei = msg.value;\r\n        require(_tokenvalueInWei > 0, \"Amount should be greater than zero\");\r\n        bytes memory convertedMarket = bytes(_market);\r\n        Pair storage pair = pairs[convertedMarket];\r\n        require(pair.tokenContract != address(0), \"Invalid market\");\r\n        IERC20 daricDXAU = IERC20(daricDXAUAddress);\r\n        uint _generate = pair.price.mul(_tokenvalueInWei);\r\n        uint fee = uint(int256(_generate) / int256(10000) * int256(fees));\r\n        uint finalGen = _generate.sub(fee).div(10 ** pair.decimal);\r\n        uint finalFees = fee.div(10 ** pair.decimal);\r\n        require(finalGen.add(finalFees) <= pair.liquidity, \"Non-sufficient liquidity\");\r\n        pair.liquidity = pair.liquidity.sub(finalGen.add(finalFees));\r\n        require(daricDXAU.mint(msg.sender, finalGen), \"Fail to generate fund\");\r\n        require(daricDXAU.mint(feesAddress, finalFees), \"Fail to send fees\");\r\n        emit generated(msg.sender, _tokenvalueInWei, finalGen, finalFees, pair.price, pair.tokenSymbol, pair.market);\r\n        return true;\r\n    }\r\n    \r\n    function redeem(string memory _market, uint _tokenvalueInWei) public returns(bool){\r\n        require(_tokenvalueInWei > 0, \"Amount should be greater than zero\");\r\n        bytes memory convertedMarket = bytes(_market);\r\n        Pair memory pair = pairs[convertedMarket];\r\n        require(pair.tokenContract != address(0), \"Invalid market\");\r\n        IERC20 daricDXAU = IERC20(daricDXAUAddress);\r\n        IERC20 genericCoin = IERC20(pair.tokenContract);\r\n        uint _redeem = (_tokenvalueInWei * 10**18).div(pair.price);\r\n        uint fee = uint(int256(_redeem) / int256(10000) * int256(fees));\r\n        uint finalRed = _redeem.sub(fee);\r\n        require(daricDXAU.allowance(msg.sender, address(this)) >= _tokenvalueInWei, \"Please create allowance\");\r\n        require(genericCoin.balanceOf(address(this)) >= _redeem, \"Insufficient vault balance\");\r\n        require(genericCoin.transfer(msg.sender, finalRed), \"Fail to generate fund\");\r\n        require(genericCoin.transfer(feesAddress, fee), \"Fail to generate fund\");\r\n        require(daricDXAU.transferFrom(msg.sender, address(this), _tokenvalueInWei), \"Fail to send fund\");\r\n        emit generated(msg.sender, _tokenvalueInWei, finalRed, fee, pair.price, \"DXAU\", _market);\r\n        return true;\r\n        \r\n    }\r\n    \r\n    function redeemETH(string memory _market, uint _tokenvalueInWei) public returns(bool){\r\n        require(_tokenvalueInWei > 0, \"Amount should be greater than zero\");\r\n        bytes memory convertedMarket = bytes(_market);\r\n        Pair memory pair = pairs[convertedMarket];\r\n        require(pair.tokenContract != address(0), \"Invalid market\");\r\n        IERC20 daricDXAU = IERC20(daricDXAUAddress);\r\n        uint _redeem = (_tokenvalueInWei * 10**18).div(pair.price);\r\n        uint fee = uint(int256(_redeem) / int256(10000) * int256(fees));\r\n        uint finalRed = _redeem.sub(fee);\r\n        require(daricDXAU.allowance(msg.sender, address(this)) >= _tokenvalueInWei, \"Please create allowance\");\r\n        require(address(this).balance >= _redeem, \"Insufficient vault balance\");\r\n        msg.sender.transfer(finalRed);\r\n        feesAddress.transfer(fee);\r\n        require(daricDXAU.transferFrom(msg.sender, address(this), _tokenvalueInWei), \"Fail to send fund\");\r\n        emit generated(msg.sender, _tokenvalueInWei, finalRed, fee, pair.price, \"DXAU\", _market);\r\n        return true;\r\n        \r\n    }\r\n    \r\n      function setMessenger(address _messenger) public onlyOwner {\r\n        address currentMessenger = messenger;\r\n        messenger = _messenger;\r\n        emit messengerChanged(currentMessenger, _messenger);\r\n    }\r\n    \r\n    function getPrice(string memory _market) public view returns (uint256 _price) {\r\n     bytes memory convertedMarket = bytes(_market);\r\n     Pair memory pair = pairs[convertedMarket];\r\n     return pair.price;\r\n    }\r\n\r\n    function getLiquity(string memory _market) public view returns (uint256 _liquidity) {\r\n     bytes memory convertedMarket = bytes(_market);\r\n     Pair memory pair = pairs[convertedMarket];\r\n     return pair.liquidity;\r\n    }\r\n    \r\n    \r\n    function setdaricDXAU(address _daricDXAUAddress) public onlyOwner{\r\n     daricDXAUAddress = _daricDXAUAddress;\r\n    }\r\n    \r\n     function setfess(uint _fee) public onlyOwner{\r\n     fees = _fee;\r\n    }\r\n    \r\n    function setFeesAddress(address payable  _feesAddress) public onlyOwner{\r\n     feesAddress = _feesAddress;\r\n    }\r\n    \r\n    \r\n     function getCoinAddresses() public view returns (address _daricDXAUAddress) {\r\n        return(daricDXAUAddress);\r\n    }\r\n\r\n\r\nfunction updatePrice(string memory _market, uint256 _price) public onlyMessenger{\r\n    bytes memory convertedMarket = bytes(_market);\r\n    Pair storage pair = pairs[convertedMarket];\r\n    require(pair.tokenContract != address(0), \"Invalid market\");\r\n    uint256 currentprice = pair.price;\r\n    pair.price = _price;\r\n    emit priceChanged(msg.sender, currentprice, _price, _market);\r\n}\r\n\r\nfunction updateLiquidity(string memory _market, uint256 _amount) public onlyOwner{\r\n    bytes memory convertedMarket = bytes(_market);\r\n    Pair storage pair = pairs[convertedMarket];\r\n    require(pair.tokenContract != address(0), \"Invalid market\");\r\n    uint256 currentLiquidity = pair.liquidity;\r\n    pair.liquidity = _amount;\r\n    emit liquidityChanged(msg.sender, currentLiquidity, _amount, _market);\r\n}\r\n\r\nfunction updateContract(string memory _market, address _contract) public onlyMessenger{\r\n    bytes memory convertedMarket = bytes(_market);\r\n    Pair storage pair = pairs[convertedMarket];\r\n    require(pair.tokenContract != address(0), \"Invalid market\");\r\n    address currentContract = pair.tokenContract;\r\n    pair.tokenContract = _contract;\r\n    emit contractChanged(msg.sender, currentContract, _contract, _market);\r\n}\r\n\r\nfunction burn() public onlyOwner{\r\n    IERC20 daricDXAU = IERC20(daricDXAUAddress);\r\n    require(daricDXAU.burn(daricDXAU.balanceOf(address(this))), \"Fail to empty vault\");\r\n}\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_market\",\"type\":\"string\"},{\"name\":\"_tokenName\",\"type\":\"string\"},{\"name\":\"_tokenSymbol\",\"type\":\"string\"},{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_decimal\",\"type\":\"uint256\"},{\"name\":\"_liquidity\",\"type\":\"uint256\"}],\"name\":\"addPair\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_market\",\"type\":\"string\"},{\"name\":\"_tokenvalueInWei\",\"type\":\"uint256\"}],\"name\":\"generate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"messenger\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_market\",\"type\":\"string\"},{\"name\":\"_tokenvalueInWei\",\"type\":\"uint256\"}],\"name\":\"redeemETH\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_market\",\"type\":\"string\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"updatePrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_market\",\"type\":\"string\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"updateLiquidity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_market\",\"type\":\"string\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_market\",\"type\":\"string\"}],\"name\":\"deletePair\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_messenger\",\"type\":\"address\"}],\"name\":\"setMessenger\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_market\",\"type\":\"string\"},{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"updateContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feesAddress\",\"type\":\"address\"}],\"name\":\"setFeesAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feesAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCoinAddresses\",\"outputs\":[{\"name\":\"_daricDXAUAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_market\",\"type\":\"string\"}],\"name\":\"getPairInfo\",\"outputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_tokenName\",\"type\":\"string\"},{\"name\":\"_tokenSymbol\",\"type\":\"string\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"market\",\"type\":\"string\"},{\"name\":\"_decimal\",\"type\":\"uint256\"},{\"name\":\"_liquidity\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_market\",\"type\":\"string\"}],\"name\":\"generateETH\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_market\",\"type\":\"string\"},{\"name\":\"_tokenvalueInWei\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setfess\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_market\",\"type\":\"string\"}],\"name\":\"getLiquity\",\"outputs\":[{\"name\":\"_liquidity\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_daricDXAUAddress\",\"type\":\"address\"}],\"name\":\"setdaricDXAU\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_daricDXAUAddress\",\"type\":\"address\"},{\"name\":\"_fees\",\"type\":\"uint256\"},{\"name\":\"_feesAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_generator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amountGenerated\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_fees\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ticker\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_market\",\"type\":\"string\"}],\"name\":\"generated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"market\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"tokenName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"decimal\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"pairAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_market\",\"type\":\"string\"}],\"name\":\"pairDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"market\",\"type\":\"string\"}],\"name\":\"priceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"market\",\"type\":\"string\"}],\"name\":\"liquidityChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_market\",\"type\":\"string\"}],\"name\":\"contractChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"messengerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"MultiCoinVault","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000358b7cfc4bb1dd8a2d472700493832e9c54ccc30000000000000000000000000000000000000000000000000000000000000006400000000000000000000000081c5952a1c4cbfb5c386128de6f4d7f9d69e9e75","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://556ec098fa149b6467ca41a7402344f52a5a913e57407034fb6549bb5c29a7db"}]}