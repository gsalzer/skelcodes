{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n\r\n  Source code of Opium Protocol\r\n  Web https://opium.network\r\n  Telegram https://t.me/opium_network\r\n  Twitter https://twitter.com/opium_network\r\n\r\n */\r\n\r\n// File: LICENSE\r\n\r\n/**\r\n\r\nThe software and documentation available in this repository (the \"Software\") is protected by copyright law and accessible pursuant to the license set forth below. Copyright © 2020 Blockeys BV. All rights reserved.\r\n\r\nPermission is hereby granted, free of charge, to any person or organization obtaining the Software (the “Licensee”) to privately study, review, and analyze the Software. Licensee shall not use the Software for any other purpose. Licensee shall not modify, transfer, assign, share, or sub-license the Software or any derivative works of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n\r\n\r\n// File: openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard {\r\n    // counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/Errors/OracleAggregatorErrors.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ncontract OracleAggregatorErrors {\r\n    string constant internal ERROR_ORACLE_AGGREGATOR_NOT_ENOUGH_ETHER = \"ORACLE_AGGREGATOR:NOT_ENOUGH_ETHER\";\r\n\r\n    string constant internal ERROR_ORACLE_AGGREGATOR_QUERY_WAS_ALREADY_MADE = \"ORACLE_AGGREGATOR:QUERY_WAS_ALREADY_MADE\";\r\n\r\n    string constant internal ERROR_ORACLE_AGGREGATOR_DATA_DOESNT_EXIST = \"ORACLE_AGGREGATOR:DATA_DOESNT_EXIST\";\r\n\r\n    string constant internal ERROR_ORACLE_AGGREGATOR_DATA_ALREADY_EXIST = \"ORACLE_AGGREGATOR:DATA_ALREADY_EXIST\";\r\n}\r\n\r\n// File: contracts/Interface/IOracleId.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n/// @title Opium.Interface.IOracleId contract is an interface that every oracleId should implement\r\ninterface IOracleId {\r\n    /// @notice Requests data from `oracleId` one time\r\n    /// @param timestamp uint256 Timestamp at which data are needed\r\n    function fetchData(uint256 timestamp) external payable;\r\n\r\n    /// @notice Requests data from `oracleId` multiple times\r\n    /// @param timestamp uint256 Timestamp at which data are needed for the first time\r\n    /// @param period uint256 Period in seconds between multiple timestamps\r\n    /// @param times uint256 How many timestamps are requested\r\n    function recursivelyFetchData(uint256 timestamp, uint256 period, uint256 times) external payable;\r\n\r\n    /// @notice Requests and returns price in ETH for one request. This function could be called as `view` function. Oraclize API for price calculations restricts making this function as view.\r\n    /// @return fetchPrice uint256 Price of one data request in ETH\r\n    function calculateFetchPrice() external returns (uint256 fetchPrice);\r\n\r\n    // Event with oracleId metadata JSON string (for DIB.ONE derivative explorer)\r\n    event MetadataSet(string metadata);\r\n}\r\n\r\n// File: contracts/OracleAggregator.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n/// @title Opium.OracleAggregator contract requests and caches the data from `oracleId`s and provides them to the Core for positions execution\r\ncontract OracleAggregator is OracleAggregatorErrors, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    // Storage for the `oracleId` results\r\n    // dataCache[oracleId][timestamp] => data\r\n    mapping (address => mapping(uint256 => uint256)) public dataCache;\r\n\r\n    // Flags whether data were provided\r\n    // dataExist[oracleId][timestamp] => bool\r\n    mapping (address => mapping(uint256 => bool)) public dataExist;\r\n\r\n    // Flags whether data were requested\r\n    // dataRequested[oracleId][timestamp] => bool\r\n    mapping (address => mapping(uint256 => bool)) public dataRequested;\r\n\r\n    // MODIFIERS\r\n\r\n    /// @notice Checks whether enough ETH were provided withing data request to proceed\r\n    /// @param oracleId address Address of the `oracleId` smart contract\r\n    /// @param times uint256 How many times the `oracleId` is being requested\r\n    modifier enoughEtherProvided(address oracleId, uint256 times) {\r\n        // Calling Opium.IOracleId function to get the data fetch price per one request\r\n        uint256 oneTimePrice = calculateFetchPrice(oracleId);\r\n\r\n        // Checking if enough ether was provided for `times` amount of requests\r\n        require(msg.value >= oneTimePrice.mul(times), ERROR_ORACLE_AGGREGATOR_NOT_ENOUGH_ETHER);\r\n        _;\r\n    }\r\n\r\n    // PUBLIC FUNCTIONS\r\n\r\n    /// @notice Requests data from `oracleId` one time\r\n    /// @param oracleId address Address of the `oracleId` smart contract\r\n    /// @param timestamp uint256 Timestamp at which data are needed\r\n    function fetchData(address oracleId, uint256 timestamp) public payable nonReentrant enoughEtherProvided(oracleId, 1) {\r\n        // Check if was not requested before and mark as requested\r\n        _registerQuery(oracleId, timestamp);\r\n\r\n        // Call the `oracleId` contract and transfer ETH\r\n        IOracleId(oracleId).fetchData.value(msg.value)(timestamp);\r\n    }\r\n\r\n    /// @notice Requests data from `oracleId` multiple times\r\n    /// @param oracleId address Address of the `oracleId` smart contract\r\n    /// @param timestamp uint256 Timestamp at which data are needed for the first time\r\n    /// @param period uint256 Period in seconds between multiple timestamps\r\n    /// @param times uint256 How many timestamps are requested\r\n    function recursivelyFetchData(address oracleId, uint256 timestamp, uint256 period, uint256 times) public payable nonReentrant enoughEtherProvided(oracleId, times) {\r\n        // Check if was not requested before and mark as requested in loop for each timestamp\r\n        for (uint256 i = 0; i < times; i++) {\r\n            _registerQuery(oracleId, timestamp + period * i);\r\n        }\r\n\r\n        // Call the `oracleId` contract and transfer ETH\r\n        IOracleId(oracleId).recursivelyFetchData.value(msg.value)(timestamp, period, times);\r\n    }\r\n\r\n    /// @notice Receives and caches data from `msg.sender`\r\n    /// @param timestamp uint256 Timestamp of data\r\n    /// @param data uint256 Data itself\r\n    function __callback(uint256 timestamp, uint256 data) public {\r\n        // Don't allow to push data twice\r\n        require(!dataExist[msg.sender][timestamp], ERROR_ORACLE_AGGREGATOR_DATA_ALREADY_EXIST);\r\n\r\n        // Saving data\r\n        dataCache[msg.sender][timestamp] = data;\r\n\r\n        // Flagging that data were received\r\n        dataExist[msg.sender][timestamp] = true;\r\n    }\r\n\r\n    /// @notice Requests and returns price in ETH for one request. This function could be called as `view` function. Oraclize API for price calculations restricts making this function as view.\r\n    /// @param oracleId address Address of the `oracleId` smart contract\r\n    /// @return fetchPrice uint256 Price of one data request in ETH\r\n    function calculateFetchPrice(address oracleId) public returns(uint256 fetchPrice) {\r\n        fetchPrice = IOracleId(oracleId).calculateFetchPrice();\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @notice Checks if data was not requested and provided before and marks as requested\r\n    /// @param oracleId address Address of the `oracleId` smart contract\r\n    /// @param timestamp uint256 Timestamp at which data are requested\r\n    function _registerQuery(address oracleId, uint256 timestamp) private {\r\n        // Check if data was not requested and provided yet\r\n        require(!dataRequested[oracleId][timestamp] && !dataExist[oracleId][timestamp], ERROR_ORACLE_AGGREGATOR_QUERY_WAS_ALREADY_MADE);\r\n\r\n        // Mark as requested\r\n        dataRequested[oracleId][timestamp] = true;\r\n    }\r\n\r\n    // VIEW FUNCTIONS\r\n\r\n    /// @notice Returns cached data if they exist, or reverts with an error\r\n    /// @param oracleId address Address of the `oracleId` smart contract\r\n    /// @param timestamp uint256 Timestamp at which data were requested\r\n    /// @return dataResult uint256 Cached data provided by `oracleId`\r\n    function getData(address oracleId, uint256 timestamp) public view returns(uint256 dataResult) {\r\n        // Check if Opium.OracleAggregator has data\r\n        require(hasData(oracleId, timestamp), ERROR_ORACLE_AGGREGATOR_DATA_DOESNT_EXIST);\r\n\r\n        // Return cached data\r\n        dataResult = dataCache[oracleId][timestamp];\r\n    }\r\n\r\n    /// @notice Getter for dataExist mapping\r\n    /// @param oracleId address Address of the `oracleId` smart contract\r\n    /// @param timestamp uint256 Timestamp at which data were requested\r\n    /// @param result bool Returns whether data were provided already\r\n    function hasData(address oracleId, uint256 timestamp) public view returns(bool result) {\r\n        return dataExist[oracleId][timestamp];\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleId\",\"type\":\"address\"}],\"name\":\"calculateFetchPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fetchPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dataCache\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dataExist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dataRequested\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"fetchData\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dataResult\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"hasData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"times\",\"type\":\"uint256\"}],\"name\":\"recursivelyFetchData\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"OracleAggregator","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://ff34c49241f57a46abd291d066d4a40409c85b181fda838489c2dd703883c608"}]}