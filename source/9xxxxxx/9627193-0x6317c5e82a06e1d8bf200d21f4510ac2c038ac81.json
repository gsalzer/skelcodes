{"status":"1","message":"OK","result":[{"SourceCode":"// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity 0.5.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ncontract PoolInterface {\r\n    function swapExactAmountIn(address, uint, address, uint, uint) external returns (uint, uint);\r\n    function swapExactAmountOut(address, uint, address, uint, uint) external returns (uint, uint);\r\n}\r\n\r\ncontract TokenInterface {\r\n    function balanceOf(address) public returns (uint);\r\n    function allowance(address, address) public returns (uint);\r\n    function approve(address, uint) public returns (bool);\r\n    function transfer(address, uint) public returns (bool);\r\n    function transferFrom(address, address, uint) public returns (bool);\r\n    function deposit() public payable;\r\n    function withdraw(uint) public;\r\n}\r\n\r\ncontract ExchangeProxy {\r\n\r\n    struct Swap {\r\n        address pool;\r\n        uint    tokenInParam; // tokenInAmount / maxAmountIn / limitAmountIn\r\n        uint    tokenOutParam; // minAmountOut / tokenAmountOut / limitAmountOut\r\n        uint    maxPrice;\r\n    }\r\n\r\n    event LOG_CALL(\r\n        bytes4  indexed sig,\r\n        address indexed caller,\r\n        bytes           data\r\n    ) anonymous;\r\n\r\n    modifier _logs_() {\r\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\r\n        _;\r\n    }\r\n\r\n    modifier _lock_() {\r\n        require(!_mutex, \"ERR_REENTRY\");\r\n        _mutex = true;\r\n        _;\r\n        _mutex = false;\r\n    }\r\n\r\n    bool private _mutex;\r\n    TokenInterface weth;\r\n\r\n    constructor(address _weth) public {\r\n        weth = TokenInterface(_weth);\r\n    }\r\n\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function batchSwapExactIn(\r\n        Swap[] memory swaps,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint totalAmountIn,\r\n        uint minTotalAmountOut\r\n    )   \r\n        public\r\n        _logs_\r\n        _lock_\r\n        returns (uint totalAmountOut)\r\n    {\r\n        TokenInterface TI = TokenInterface(tokenIn);\r\n        TokenInterface TO = TokenInterface(tokenOut);\r\n        require(TI.transferFrom(msg.sender, address(this), totalAmountIn), \"ERR_TRANSFER_FAILED\");\r\n        for (uint i = 0; i < swaps.length; i++) {\r\n            Swap memory swap = swaps[i];\r\n            \r\n            PoolInterface pool = PoolInterface(swap.pool);\r\n            if (TI.allowance(address(this), swap.pool) < totalAmountIn) {\r\n                TI.approve(swap.pool, uint(-1));\r\n            }\r\n            (uint tokenAmountOut,) = pool.swapExactAmountIn(\r\n                                        tokenIn,\r\n                                        swap.tokenInParam,\r\n                                        tokenOut,\r\n                                        swap.tokenOutParam,\r\n                                        swap.maxPrice\r\n                                    );\r\n            totalAmountOut = add(tokenAmountOut, totalAmountOut);\r\n        }\r\n        require(totalAmountOut >= minTotalAmountOut, \"ERR_LIMIT_OUT\");\r\n        require(TO.transfer(msg.sender, TO.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\r\n        require(TI.transfer(msg.sender, TI.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\r\n        return totalAmountOut;\r\n    }\r\n\r\n    function batchSwapExactOut(\r\n        Swap[] memory swaps,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint maxTotalAmountIn\r\n    )\r\n        public\r\n        _logs_\r\n        _lock_\r\n        returns (uint totalAmountIn)\r\n    {\r\n        TokenInterface TI = TokenInterface(tokenIn);\r\n        TokenInterface TO = TokenInterface(tokenOut);\r\n        require(TI.transferFrom(msg.sender, address(this), maxTotalAmountIn), \"ERR_TRANSFER_FAILED\");\r\n        for (uint i = 0; i < swaps.length; i++) {\r\n            Swap memory swap = swaps[i];\r\n            PoolInterface pool = PoolInterface(swap.pool);\r\n            if (TI.allowance(address(this), swap.pool) < maxTotalAmountIn) {\r\n                TI.approve(swap.pool, uint(-1));\r\n            }\r\n            (uint tokenAmountIn,) = pool.swapExactAmountOut(\r\n                                        tokenIn,\r\n                                        swap.tokenInParam,\r\n                                        tokenOut,\r\n                                        swap.tokenOutParam,\r\n                                        swap.maxPrice\r\n                                    );\r\n            totalAmountIn = add(tokenAmountIn, totalAmountIn);\r\n        }\r\n        require(totalAmountIn <= maxTotalAmountIn, \"ERR_LIMIT_IN\");\r\n        require(TO.transfer(msg.sender, TO.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\r\n        require(TI.transfer(msg.sender, TI.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\r\n        return totalAmountIn;\r\n    }\r\n\r\n    function batchEthInSwapExactIn(\r\n        Swap[] memory swaps,\r\n        address tokenOut,\r\n        uint minTotalAmountOut\r\n    )\r\n        public payable\r\n        _logs_\r\n        _lock_\r\n        returns (uint totalAmountOut)\r\n    {\r\n        TokenInterface TO = TokenInterface(tokenOut);\r\n        weth.deposit.value(msg.value)();\r\n        for (uint i = 0; i < swaps.length; i++) {\r\n            Swap memory swap = swaps[i];\r\n            PoolInterface pool = PoolInterface(swap.pool);\r\n            if (weth.allowance(address(this), swap.pool) < msg.value) {\r\n                weth.approve(swap.pool, uint(-1));\r\n            }\r\n            (uint tokenAmountOut,) = pool.swapExactAmountIn(\r\n                                        address(weth),\r\n                                        swap.tokenInParam,\r\n                                        tokenOut,\r\n                                        swap.tokenOutParam,\r\n                                        swap.maxPrice\r\n                                    );\r\n            totalAmountOut = add(tokenAmountOut, totalAmountOut);\r\n        }\r\n        require(totalAmountOut >= minTotalAmountOut, \"ERR_LIMIT_OUT\");\r\n        require(TO.transfer(msg.sender, TO.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\r\n        uint wethBalance = weth.balanceOf(address(this));\r\n        if (wethBalance > 0) {\r\n            weth.withdraw(wethBalance);\r\n            (bool xfer,) = msg.sender.call.value(wethBalance)(\"\");\r\n            require(xfer, \"ERR_ETH_FAILED\");\r\n        }\r\n        return totalAmountOut;\r\n    }\r\n\r\n    function batchEthOutSwapExactIn(\r\n        Swap[] memory swaps,\r\n        address tokenIn,\r\n        uint totalAmountIn,\r\n        uint minTotalAmountOut\r\n    )\r\n        public\r\n        _logs_\r\n        _lock_\r\n        returns (uint totalAmountOut)\r\n    {\r\n        TokenInterface TI = TokenInterface(tokenIn);\r\n        require(TI.transferFrom(msg.sender, address(this), totalAmountIn), \"ERR_TRANSFER_FAILED\");\r\n        for (uint i = 0; i < swaps.length; i++) {\r\n            Swap memory swap = swaps[i];\r\n            PoolInterface pool = PoolInterface(swap.pool);\r\n            if (TI.allowance(address(this), swap.pool) < totalAmountIn) {\r\n                TI.approve(swap.pool, uint(-1));\r\n            }\r\n            (uint tokenAmountOut,) = pool.swapExactAmountIn(\r\n                                        tokenIn,\r\n                                        swap.tokenInParam,\r\n                                        address(weth),\r\n                                        swap.tokenOutParam,\r\n                                        swap.maxPrice\r\n                                    );\r\n\r\n            totalAmountOut = add(tokenAmountOut, totalAmountOut);\r\n        }\r\n        require(totalAmountOut >= minTotalAmountOut, \"ERR_LIMIT_OUT\");\r\n        uint wethBalance = weth.balanceOf(address(this));\r\n        weth.withdraw(wethBalance);\r\n        (bool xfer,) = msg.sender.call.value(wethBalance)(\"\");\r\n        require(xfer, \"ERR_ETH_FAILED\");\r\n        require(TI.transfer(msg.sender, TI.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\r\n        return totalAmountOut;\r\n    }\r\n\r\n    function batchEthInSwapExactOut(\r\n        Swap[] memory swaps,\r\n        address tokenOut\r\n    )\r\n        public payable\r\n        _logs_\r\n        _lock_\r\n        returns (uint totalAmountIn)\r\n    {\r\n        TokenInterface TO = TokenInterface(tokenOut);\r\n        weth.deposit.value(msg.value)();\r\n        for (uint i = 0; i < swaps.length; i++) {\r\n            Swap memory swap = swaps[i];\r\n            PoolInterface pool = PoolInterface(swap.pool);\r\n            if (weth.allowance(address(this), swap.pool) < msg.value) {\r\n                weth.approve(swap.pool, uint(-1));\r\n            }\r\n            (uint tokenAmountIn,) = pool.swapExactAmountOut(\r\n                                        address(weth),\r\n                                        swap.tokenInParam,\r\n                                        tokenOut,\r\n                                        swap.tokenOutParam,\r\n                                        swap.maxPrice\r\n                                    );\r\n\r\n            totalAmountIn = add(tokenAmountIn, totalAmountIn);\r\n        }\r\n        require(TO.transfer(msg.sender, TO.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\r\n        uint wethBalance = weth.balanceOf(address(this));\r\n        if (wethBalance > 0) {\r\n            weth.withdraw(wethBalance);\r\n            (bool xfer,) = msg.sender.call.value(wethBalance)(\"\");\r\n            require(xfer, \"ERR_ETH_FAILED\");\r\n        }\r\n        return totalAmountIn;\r\n    }\r\n\r\n    function batchEthOutSwapExactOut(\r\n        Swap[] memory swaps,\r\n        address tokenIn,\r\n        uint maxTotalAmountIn\r\n    )\r\n        public\r\n        _logs_\r\n        _lock_\r\n        returns (uint totalAmountIn)\r\n    {\r\n        TokenInterface TI = TokenInterface(tokenIn);\r\n        require(TI.transferFrom(msg.sender, address(this), maxTotalAmountIn), \"ERR_TRANSFER_FAILED\");\r\n        for (uint i = 0; i < swaps.length; i++) {\r\n            Swap memory swap = swaps[i];\r\n            PoolInterface pool = PoolInterface(swap.pool);\r\n            if (TI.allowance(address(this), swap.pool) < maxTotalAmountIn) {\r\n                TI.approve(swap.pool, uint(-1));\r\n            }\r\n            (uint tokenAmountIn,) = pool.swapExactAmountOut(\r\n                                        tokenIn,\r\n                                        swap.tokenInParam,\r\n                                        address(weth),\r\n                                        swap.tokenOutParam,\r\n                                        swap.maxPrice\r\n                                    );\r\n\r\n            totalAmountIn = add(tokenAmountIn, totalAmountIn);\r\n        }\r\n        require(totalAmountIn <= maxTotalAmountIn, \"ERR_LIMIT_IN\");\r\n        require(TI.transfer(msg.sender, TI.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\r\n        uint wethBalance = weth.balanceOf(address(this));\r\n        weth.withdraw(wethBalance);\r\n        (bool xfer,) = msg.sender.call.value(wethBalance)(\"\");\r\n        require(xfer, \"ERR_ETH_FAILED\");\r\n        return totalAmountIn;\r\n    }\r\n\r\n    function() external payable {}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"LOG_CALL\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenInParam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenOutParam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct ExchangeProxy.Swap[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minTotalAmountOut\",\"type\":\"uint256\"}],\"name\":\"batchEthInSwapExactIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmountOut\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenInParam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenOutParam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct ExchangeProxy.Swap[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"batchEthInSwapExactOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmountIn\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenInParam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenOutParam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct ExchangeProxy.Swap[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTotalAmountOut\",\"type\":\"uint256\"}],\"name\":\"batchEthOutSwapExactIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmountOut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenInParam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenOutParam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct ExchangeProxy.Swap[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalAmountIn\",\"type\":\"uint256\"}],\"name\":\"batchEthOutSwapExactOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmountIn\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenInParam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenOutParam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct ExchangeProxy.Swap[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTotalAmountOut\",\"type\":\"uint256\"}],\"name\":\"batchSwapExactIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmountOut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenInParam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenOutParam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct ExchangeProxy.Swap[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalAmountIn\",\"type\":\"uint256\"}],\"name\":\"batchSwapExactOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmountIn\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ExchangeProxy","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://471280876563df20ca7990d2981be9f009b50122d769e6f0c5e0f881f314f5d9"}]}