{"status":"1","message":"OK","result":[{"SourceCode":"/**\n* Commit sha: c7bf36f004a2b0e11d7e14234cea7853fd3a523a\n* GitHub repository: https://github.com/aragon/aragon-court\n* Tool used for the deploy: https://github.com/aragon/aragon-network-deploy\n**/\n\n// File: ../../aragon-court/contracts/lib/os/ERC20.sol\n\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/token/ERC20.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity ^0.5.8;\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 {\n    function totalSupply() public view returns (uint256);\n\n    function balanceOf(address _who) public view returns (uint256);\n\n    function allowance(address _owner, address _spender) public view returns (uint256);\n\n    function transfer(address _to, uint256 _value) public returns (bool);\n\n    function approve(address _spender, uint256 _value) public returns (bool);\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n// File: ../../aragon-court/contracts/lib/os/SafeMath.sol\n\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/math/SafeMath.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    string private constant ERROR_ADD_OVERFLOW = \"MATH_ADD_OVERFLOW\";\n    string private constant ERROR_SUB_UNDERFLOW = \"MATH_SUB_UNDERFLOW\";\n    string private constant ERROR_MUL_OVERFLOW = \"MATH_MUL_OVERFLOW\";\n    string private constant ERROR_DIV_ZERO = \"MATH_DIV_ZERO\";\n\n    /**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n\n        uint256 c = _a * _b;\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\n        uint256 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\n        uint256 c = _a - _b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two numbers, reverts on overflow.\n    */\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        uint256 c = _a + _b;\n        require(c >= _a, ERROR_ADD_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, ERROR_DIV_ZERO);\n        return a % b;\n    }\n}\n\n// File: ../../aragon-court/contracts/lib/os/SafeERC20.sol\n\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/SafeERC20.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity ^0.5.8;\n\n\n\nlibrary SafeERC20 {\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\n    // https://github.com/ethereum/solidity/issues/3544\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferCallData = abi.encodeWithSelector(\n            TRANSFER_SELECTOR,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(address(_token), transferCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferFromCallData = abi.encodeWithSelector(\n            _token.transferFrom.selector,\n            _from,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(address(_token), transferFromCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\n        bytes memory approveCallData = abi.encodeWithSelector(\n            _token.approve.selector,\n            _spender,\n            _amount\n        );\n        return invokeAndCheckSuccess(address(_token), approveCallData);\n    }\n\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata) private returns (bool) {\n        bool ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            let success := call(\n                gas,                  // forward all gas\n                _addr,                // address\n                0,                    // no value\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n            // Check number of bytes returned from last function call\n                switch returndatasize\n\n                // No bytes returned: assume success\n                case 0 {\n                    ret := 1\n                }\n\n                // 32 bytes returned: check if non-zero\n                case 0x20 {\n                // Only return success if returned data was true\n                // Already have output in ptr\n                    ret := eq(mload(ptr), 1)\n                }\n\n                // Not sure what was returned: don't mark as success\n                default { }\n            }\n        }\n        return ret;\n    }\n}\n\n// File: ../../aragon-court/contracts/treasury/ITreasury.sol\n\npragma solidity ^0.5.8;\n\n\n\ninterface ITreasury {\n    /**\n    * @dev Assign a certain amount of tokens to an account\n    * @param _token ERC20 token to be assigned\n    * @param _to Address of the recipient that will be assigned the tokens to\n    * @param _amount Amount of tokens to be assigned to the recipient\n    */\n    function assign(ERC20 _token, address _to, uint256 _amount) external;\n\n    /**\n    * @dev Withdraw a certain amount of tokens\n    * @param _token ERC20 token to be withdrawn\n    * @param _to Address of the recipient that will receive the tokens\n    * @param _amount Amount of tokens to be withdrawn from the sender\n    */\n    function withdraw(ERC20 _token, address _to, uint256 _amount) external;\n}\n\n// File: ../../aragon-court/contracts/lib/os/IsContract.sol\n\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/IsContract.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity ^0.5.8;\n\n\ncontract IsContract {\n    /*\n    * NOTE: this should NEVER be used for authentication\n    * (see pitfalls: https://github.com/fergarrui/ethereum-security/tree/master/contracts/extcodesize).\n    *\n    * This is only intended to be used as a sanity check that an address is actually a contract,\n    * RATHER THAN an address not being a contract.\n    */\n    function isContract(address _target) internal view returns (bool) {\n        if (_target == address(0)) {\n            return false;\n        }\n\n        uint256 size;\n        assembly { size := extcodesize(_target) }\n        return size > 0;\n    }\n}\n\n// File: ../../aragon-court/contracts/lib/os/SafeMath64.sol\n\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/math/SafeMath64.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity ^0.5.8;\n\n\n/**\n * @title SafeMath64\n * @dev Math operations for uint64 with safety checks that revert on error\n */\nlibrary SafeMath64 {\n    string private constant ERROR_ADD_OVERFLOW = \"MATH64_ADD_OVERFLOW\";\n    string private constant ERROR_SUB_UNDERFLOW = \"MATH64_SUB_UNDERFLOW\";\n    string private constant ERROR_MUL_OVERFLOW = \"MATH64_MUL_OVERFLOW\";\n    string private constant ERROR_DIV_ZERO = \"MATH64_DIV_ZERO\";\n\n    /**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\n    function mul(uint64 _a, uint64 _b) internal pure returns (uint64) {\n        uint256 c = uint256(_a) * uint256(_b);\n        require(c < 0x010000000000000000, ERROR_MUL_OVERFLOW); // 2**64 (less gas this way)\n\n        return uint64(c);\n    }\n\n    /**\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint64 _a, uint64 _b) internal pure returns (uint64) {\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\n        uint64 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint64 _a, uint64 _b) internal pure returns (uint64) {\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\n        uint64 c = _a - _b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two numbers, reverts on overflow.\n    */\n    function add(uint64 _a, uint64 _b) internal pure returns (uint64) {\n        uint64 c = _a + _b;\n        require(c >= _a, ERROR_ADD_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\n        require(b != 0, ERROR_DIV_ZERO);\n        return a % b;\n    }\n}\n\n// File: ../../aragon-court/contracts/lib/os/Uint256Helpers.sol\n\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/Uint256Helpers.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity ^0.5.8;\n\n\nlibrary Uint256Helpers {\n    uint256 private constant MAX_UINT8 = uint8(-1);\n    uint256 private constant MAX_UINT64 = uint64(-1);\n\n    string private constant ERROR_UINT8_NUMBER_TOO_BIG = \"UINT8_NUMBER_TOO_BIG\";\n    string private constant ERROR_UINT64_NUMBER_TOO_BIG = \"UINT64_NUMBER_TOO_BIG\";\n\n    function toUint8(uint256 a) internal pure returns (uint8) {\n        require(a <= MAX_UINT8, ERROR_UINT8_NUMBER_TOO_BIG);\n        return uint8(a);\n    }\n\n    function toUint64(uint256 a) internal pure returns (uint64) {\n        require(a <= MAX_UINT64, ERROR_UINT64_NUMBER_TOO_BIG);\n        return uint64(a);\n    }\n}\n\n// File: ../../aragon-court/contracts/lib/os/TimeHelpers.sol\n\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/TimeHelpers.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity ^0.5.8;\n\n\n\ncontract TimeHelpers {\n    using Uint256Helpers for uint256;\n\n    /**\n    * @dev Returns the current block number.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n    * @dev Returns the current block number, converted to uint64.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber64() internal view returns (uint64) {\n        return getBlockNumber().toUint64();\n    }\n\n    /**\n    * @dev Returns the current timestamp.\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n    *      tests.\n    */\n    function getTimestamp() internal view returns (uint256) {\n        return block.timestamp; // solium-disable-line security/no-block-members\n    }\n\n    /**\n    * @dev Returns the current timestamp, converted to uint64.\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n    *      tests.\n    */\n    function getTimestamp64() internal view returns (uint64) {\n        return getTimestamp().toUint64();\n    }\n}\n\n// File: ../../aragon-court/contracts/court/clock/IClock.sol\n\npragma solidity ^0.5.8;\n\n\ninterface IClock {\n    /**\n    * @dev Ensure that the current term of the clock is up-to-date\n    * @return Identification number of the current term\n    */\n    function ensureCurrentTerm() external returns (uint64);\n\n    /**\n    * @dev Transition up to a certain number of terms to leave the clock up-to-date\n    * @param _maxRequestedTransitions Max number of term transitions allowed by the sender\n    * @return Identification number of the term ID after executing the heartbeat transitions\n    */\n    function heartbeat(uint64 _maxRequestedTransitions) external returns (uint64);\n\n    /**\n    * @dev Ensure that a certain term has its randomness set\n    * @return Randomness of the current term\n    */\n    function ensureCurrentTermRandomness() external returns (bytes32);\n\n    /**\n    * @dev Tell the last ensured term identification number\n    * @return Identification number of the last ensured term\n    */\n    function getLastEnsuredTermId() external view returns (uint64);\n\n    /**\n    * @dev Tell the current term identification number. Note that there may be pending term transitions.\n    * @return Identification number of the current term\n    */\n    function getCurrentTermId() external view returns (uint64);\n\n    /**\n    * @dev Tell the number of terms the clock should transition to be up-to-date\n    * @return Number of terms the clock should transition to be up-to-date\n    */\n    function getNeededTermTransitions() external view returns (uint64);\n\n    /**\n    * @dev Tell the information related to a term based on its ID\n    * @param _termId ID of the term being queried\n    * @return startTime Term start time\n    * @return randomnessBN Block number used for randomness in the requested term\n    * @return randomness Randomness computed for the requested term\n    */\n    function getTerm(uint64 _termId) external view returns (uint64 startTime, uint64 randomnessBN, bytes32 randomness);\n\n    /**\n    * @dev Tell the randomness of a term even if it wasn't computed yet\n    * @param _termId Identification number of the term being queried\n    * @return Randomness of the requested term\n    */\n    function getTermRandomness(uint64 _termId) external view returns (bytes32);\n}\n\n// File: ../../aragon-court/contracts/court/clock/CourtClock.sol\n\npragma solidity ^0.5.8;\n\n\n\n\n\ncontract CourtClock is IClock, TimeHelpers {\n    using SafeMath64 for uint64;\n\n    string private constant ERROR_TERM_DOES_NOT_EXIST = \"CLK_TERM_DOES_NOT_EXIST\";\n    string private constant ERROR_TERM_DURATION_TOO_LONG = \"CLK_TERM_DURATION_TOO_LONG\";\n    string private constant ERROR_TERM_RANDOMNESS_NOT_YET = \"CLK_TERM_RANDOMNESS_NOT_YET\";\n    string private constant ERROR_TERM_RANDOMNESS_UNAVAILABLE = \"CLK_TERM_RANDOMNESS_UNAVAILABLE\";\n    string private constant ERROR_BAD_FIRST_TERM_START_TIME = \"CLK_BAD_FIRST_TERM_START_TIME\";\n    string private constant ERROR_TOO_MANY_TRANSITIONS = \"CLK_TOO_MANY_TRANSITIONS\";\n    string private constant ERROR_INVALID_TRANSITION_TERMS = \"CLK_INVALID_TRANSITION_TERMS\";\n    string private constant ERROR_CANNOT_DELAY_STARTED_COURT = \"CLK_CANNOT_DELAY_STARTED_COURT\";\n    string private constant ERROR_CANNOT_DELAY_PAST_START_TIME = \"CLK_CANNOT_DELAY_PAST_START_TIME\";\n\n    // Maximum number of term transitions a callee may have to assume in order to call certain functions that require the Court being up-to-date\n    uint64 internal constant MAX_AUTO_TERM_TRANSITIONS_ALLOWED = 1;\n\n    // Max duration in seconds that a term can last\n    uint64 internal constant MAX_TERM_DURATION = 365 days;\n\n    // Max time until first term starts since contract is deployed\n    uint64 internal constant MAX_FIRST_TERM_DELAY_PERIOD = 2 * MAX_TERM_DURATION;\n\n    struct Term {\n        uint64 startTime;              // Timestamp when the term started\n        uint64 randomnessBN;           // Block number for entropy\n        bytes32 randomness;            // Entropy from randomnessBN block hash\n    }\n\n    // Duration in seconds for each term of the Court\n    uint64 private termDuration;\n\n    // Last ensured term id\n    uint64 private termId;\n\n    // List of Court terms indexed by id\n    mapping (uint64 => Term) private terms;\n\n    event Heartbeat(uint64 previousTermId, uint64 currentTermId);\n    event StartTimeDelayed(uint64 previousStartTime, uint64 currentStartTime);\n\n    /**\n    * @dev Ensure a certain term has already been processed\n    * @param _termId Identification number of the term to be checked\n    */\n    modifier termExists(uint64 _termId) {\n        require(_termId <= termId, ERROR_TERM_DOES_NOT_EXIST);\n        _;\n    }\n\n    /**\n    * @dev Constructor function\n    * @param _termParams Array containing:\n    *        0. _termDuration Duration in seconds per term\n    *        1. _firstTermStartTime Timestamp in seconds when the court will open (to give time for juror on-boarding)\n    */\n    constructor(uint64[2] memory _termParams) public {\n        uint64 _termDuration = _termParams[0];\n        uint64 _firstTermStartTime = _termParams[1];\n\n        require(_termDuration < MAX_TERM_DURATION, ERROR_TERM_DURATION_TOO_LONG);\n        require(_firstTermStartTime >= getTimestamp64() + _termDuration, ERROR_BAD_FIRST_TERM_START_TIME);\n        require(_firstTermStartTime <= getTimestamp64() + MAX_FIRST_TERM_DELAY_PERIOD, ERROR_BAD_FIRST_TERM_START_TIME);\n\n        termDuration = _termDuration;\n\n        // No need for SafeMath: we already checked values above\n        terms[0].startTime = _firstTermStartTime - _termDuration;\n    }\n\n    /**\n    * @notice Ensure that the current term of the Court is up-to-date. If the Court is outdated by more than `MAX_AUTO_TERM_TRANSITIONS_ALLOWED`\n    *         terms, the heartbeat function must be called manually instead.\n    * @return Identification number of the current term\n    */\n    function ensureCurrentTerm() external returns (uint64) {\n        return _ensureCurrentTerm();\n    }\n\n    /**\n    * @notice Transition up to `_maxRequestedTransitions` terms\n    * @param _maxRequestedTransitions Max number of term transitions allowed by the sender\n    * @return Identification number of the term ID after executing the heartbeat transitions\n    */\n    function heartbeat(uint64 _maxRequestedTransitions) external returns (uint64) {\n        return _heartbeat(_maxRequestedTransitions);\n    }\n\n    /**\n    * @notice Ensure that a certain term has its randomness set. As we allow to draft disputes requested for previous terms, if there\n    *      were mined more than 256 blocks for the current term, the blockhash of its randomness BN is no longer available, given\n    *      round will be able to be drafted in the following term.\n    * @return Randomness of the current term\n    */\n    function ensureCurrentTermRandomness() external returns (bytes32) {\n        // If the randomness for the given term was already computed, return\n        uint64 currentTermId = termId;\n        Term storage term = terms[currentTermId];\n        bytes32 termRandomness = term.randomness;\n        if (termRandomness != bytes32(0)) {\n            return termRandomness;\n        }\n\n        // Compute term randomness\n        bytes32 newRandomness = _computeTermRandomness(currentTermId);\n        require(newRandomness != bytes32(0), ERROR_TERM_RANDOMNESS_UNAVAILABLE);\n        term.randomness = newRandomness;\n        return newRandomness;\n    }\n\n    /**\n    * @dev Tell the term duration of the Court\n    * @return Duration in seconds of the Court term\n    */\n    function getTermDuration() external view returns (uint64) {\n        return termDuration;\n    }\n\n    /**\n    * @dev Tell the last ensured term identification number\n    * @return Identification number of the last ensured term\n    */\n    function getLastEnsuredTermId() external view returns (uint64) {\n        return _lastEnsuredTermId();\n    }\n\n    /**\n    * @dev Tell the current term identification number. Note that there may be pending term transitions.\n    * @return Identification number of the current term\n    */\n    function getCurrentTermId() external view returns (uint64) {\n        return _currentTermId();\n    }\n\n    /**\n    * @dev Tell the number of terms the Court should transition to be up-to-date\n    * @return Number of terms the Court should transition to be up-to-date\n    */\n    function getNeededTermTransitions() external view returns (uint64) {\n        return _neededTermTransitions();\n    }\n\n    /**\n    * @dev Tell the information related to a term based on its ID. Note that if the term has not been reached, the\n    *      information returned won't be computed yet. This function allows querying future terms that were not computed yet.\n    * @param _termId ID of the term being queried\n    * @return startTime Term start time\n    * @return randomnessBN Block number used for randomness in the requested term\n    * @return randomness Randomness computed for the requested term\n    */\n    function getTerm(uint64 _termId) external view returns (uint64 startTime, uint64 randomnessBN, bytes32 randomness) {\n        Term storage term = terms[_termId];\n        return (term.startTime, term.randomnessBN, term.randomness);\n    }\n\n    /**\n    * @dev Tell the randomness of a term even if it wasn't computed yet\n    * @param _termId Identification number of the term being queried\n    * @return Randomness of the requested term\n    */\n    function getTermRandomness(uint64 _termId) external view termExists(_termId) returns (bytes32) {\n        return _computeTermRandomness(_termId);\n    }\n\n    /**\n    * @dev Internal function to ensure that the current term of the Court is up-to-date. If the Court is outdated by more than\n    *      `MAX_AUTO_TERM_TRANSITIONS_ALLOWED` terms, the heartbeat function must be called manually.\n    * @return Identification number of the resultant term ID after executing the corresponding transitions\n    */\n    function _ensureCurrentTerm() internal returns (uint64) {\n        // Check the required number of transitions does not exceeds the max allowed number to be processed automatically\n        uint64 requiredTransitions = _neededTermTransitions();\n        require(requiredTransitions <= MAX_AUTO_TERM_TRANSITIONS_ALLOWED, ERROR_TOO_MANY_TRANSITIONS);\n\n        // If there are no transitions pending, return the last ensured term id\n        if (uint256(requiredTransitions) == 0) {\n            return termId;\n        }\n\n        // Process transition if there is at least one pending\n        return _heartbeat(requiredTransitions);\n    }\n\n    /**\n    * @dev Internal function to transition the Court terms up to a requested number of terms\n    * @param _maxRequestedTransitions Max number of term transitions allowed by the sender\n    * @return Identification number of the resultant term ID after executing the requested transitions\n    */\n    function _heartbeat(uint64 _maxRequestedTransitions) internal returns (uint64) {\n        // Transition the minimum number of terms between the amount requested and the amount actually needed\n        uint64 neededTransitions = _neededTermTransitions();\n        uint256 transitions = uint256(_maxRequestedTransitions < neededTransitions ? _maxRequestedTransitions : neededTransitions);\n        require(transitions > 0, ERROR_INVALID_TRANSITION_TERMS);\n\n        uint64 blockNumber = getBlockNumber64();\n        uint64 previousTermId = termId;\n        uint64 currentTermId = previousTermId;\n        for (uint256 transition = 1; transition <= transitions; transition++) {\n            // Term IDs are incremented by one based on the number of time periods since the Court started. Since time is represented in uint64,\n            // even if we chose the minimum duration possible for a term (1 second), we can ensure terms will never reach 2^64 since time is\n            // already assumed to fit in uint64.\n            Term storage previousTerm = terms[currentTermId++];\n            Term storage currentTerm = terms[currentTermId];\n            _onTermTransitioned(currentTermId);\n\n            // Set the start time of the new term. Note that we are using a constant term duration value to guarantee\n            // equally long terms, regardless of heartbeats.\n            currentTerm.startTime = previousTerm.startTime.add(termDuration);\n\n            // In order to draft a random number of jurors in a term, we use a randomness factor for each term based on a\n            // block number that is set once the term has started. Note that this information could not be known beforehand.\n            currentTerm.randomnessBN = blockNumber + 1;\n        }\n\n        termId = currentTermId;\n        emit Heartbeat(previousTermId, currentTermId);\n        return currentTermId;\n    }\n\n    /**\n    * @dev Internal function to delay the first term start time only if it wasn't reached yet\n    * @param _newFirstTermStartTime New timestamp in seconds when the court will open\n    */\n    function _delayStartTime(uint64 _newFirstTermStartTime) internal {\n        require(_currentTermId() == 0, ERROR_CANNOT_DELAY_STARTED_COURT);\n\n        Term storage term = terms[0];\n        uint64 currentFirstTermStartTime = term.startTime.add(termDuration);\n        require(_newFirstTermStartTime > currentFirstTermStartTime, ERROR_CANNOT_DELAY_PAST_START_TIME);\n\n        // No need for SafeMath: we already checked above that `_newFirstTermStartTime` > `currentFirstTermStartTime` >= `termDuration`\n        term.startTime = _newFirstTermStartTime - termDuration;\n        emit StartTimeDelayed(currentFirstTermStartTime, _newFirstTermStartTime);\n    }\n\n    /**\n    * @dev Internal function to notify when a term has been transitioned. This function must be overridden to provide custom behavior.\n    * @param _termId Identification number of the new current term that has been transitioned\n    */\n    function _onTermTransitioned(uint64 _termId) internal;\n\n    /**\n    * @dev Internal function to tell the last ensured term identification number\n    * @return Identification number of the last ensured term\n    */\n    function _lastEnsuredTermId() internal view returns (uint64) {\n        return termId;\n    }\n\n    /**\n    * @dev Internal function to tell the current term identification number. Note that there may be pending term transitions.\n    * @return Identification number of the current term\n    */\n    function _currentTermId() internal view returns (uint64) {\n        return termId.add(_neededTermTransitions());\n    }\n\n    /**\n    * @dev Internal function to tell the number of terms the Court should transition to be up-to-date\n    * @return Number of terms the Court should transition to be up-to-date\n    */\n    function _neededTermTransitions() internal view returns (uint64) {\n        // Note that the Court is always initialized providing a start time for the first-term in the future. If that's the case,\n        // no term transitions are required.\n        uint64 currentTermStartTime = terms[termId].startTime;\n        if (getTimestamp64() < currentTermStartTime) {\n            return uint64(0);\n        }\n\n        // No need for SafeMath: we already know that the start time of the current term is in the past\n        return (getTimestamp64() - currentTermStartTime) / termDuration;\n    }\n\n    /**\n    * @dev Internal function to compute the randomness that will be used to draft jurors for the given term. This\n    *      function assumes the given term exists. To determine the randomness factor for a term we use the hash of a\n    *      block number that is set once the term has started to ensure it cannot be known beforehand. Note that the\n    *      hash function being used only works for the 256 most recent block numbers.\n    * @param _termId Identification number of the term being queried\n    * @return Randomness computed for the given term\n    */\n    function _computeTermRandomness(uint64 _termId) internal view returns (bytes32) {\n        Term storage term = terms[_termId];\n        require(getBlockNumber64() > term.randomnessBN, ERROR_TERM_RANDOMNESS_NOT_YET);\n        return blockhash(term.randomnessBN);\n    }\n}\n\n// File: ../../aragon-court/contracts/court/config/IConfig.sol\n\npragma solidity ^0.5.8;\n\n\n\ninterface IConfig {\n\n    /**\n    * @dev Tell the full Court configuration parameters at a certain term\n    * @param _termId Identification number of the term querying the Court config of\n    * @return token Address of the token used to pay for fees\n    * @return fees Array containing:\n    *         0. jurorFee Amount of fee tokens that is paid per juror per dispute\n    *         1. draftFee Amount of fee tokens per juror to cover the drafting cost\n    *         2. settleFee Amount of fee tokens per juror to cover round settlement cost\n    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n    *         0. evidenceTerms Max submitting evidence period duration in terms\n    *         1. commitTerms Commit period duration in terms\n    *         2. revealTerms Reveal period duration in terms\n    *         3. appealTerms Appeal period duration in terms\n    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\n    * @return pcts Array containing:\n    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\n    * @return roundParams Array containing params for rounds:\n    *         0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\n    *         1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\n    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n    * @return appealCollateralParams Array containing params for appeal collateral:\n    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\n    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\n    * @return minActiveBalance Minimum amount of tokens jurors have to activate to participate in the Court\n    */\n    function getConfig(uint64 _termId) external view\n        returns (\n            ERC20 feeToken,\n            uint256[3] memory fees,\n            uint64[5] memory roundStateDurations,\n            uint16[2] memory pcts,\n            uint64[4] memory roundParams,\n            uint256[2] memory appealCollateralParams,\n            uint256 minActiveBalance\n        );\n\n    /**\n    * @dev Tell the draft config at a certain term\n    * @param _termId Identification number of the term querying the draft config of\n    * @return feeToken Address of the token used to pay for fees\n    * @return draftFee Amount of fee tokens per juror to cover the drafting cost\n    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n    */\n    function getDraftConfig(uint64 _termId) external view returns (ERC20 feeToken, uint256 draftFee, uint16 penaltyPct);\n\n    /**\n    * @dev Tell the min active balance config at a certain term\n    * @param _termId Term querying the min active balance config of\n    * @return Minimum amount of tokens jurors have to activate to participate in the Court\n    */\n    function getMinActiveBalance(uint64 _termId) external view returns (uint256);\n\n    /**\n    * @dev Tell whether a certain holder accepts automatic withdrawals of tokens or not\n    * @return True if the given holder accepts automatic withdrawals of their tokens, false otherwise\n    */\n    function areWithdrawalsAllowedFor(address _holder) external view returns (bool);\n}\n\n// File: ../../aragon-court/contracts/court/config/CourtConfigData.sol\n\npragma solidity ^0.5.8;\n\n\n\ncontract CourtConfigData {\n    struct Config {\n        FeesConfig fees;                        // Full fees-related config\n        DisputesConfig disputes;                // Full disputes-related config\n        uint256 minActiveBalance;               // Minimum amount of tokens jurors have to activate to participate in the Court\n    }\n\n    struct FeesConfig {\n        ERC20 token;                            // ERC20 token to be used for the fees of the Court\n        uint16 finalRoundReduction;             // Permyriad of fees reduction applied for final appeal round (‱ - 1/10,000)\n        uint256 jurorFee;                       // Amount of tokens paid to draft a juror to adjudicate a dispute\n        uint256 draftFee;                       // Amount of tokens paid per round to cover the costs of drafting jurors\n        uint256 settleFee;                      // Amount of tokens paid per round to cover the costs of slashing jurors\n    }\n\n    struct DisputesConfig {\n        uint64 evidenceTerms;                   // Max submitting evidence period duration in terms\n        uint64 commitTerms;                     // Committing period duration in terms\n        uint64 revealTerms;                     // Revealing period duration in terms\n        uint64 appealTerms;                     // Appealing period duration in terms\n        uint64 appealConfirmTerms;              // Confirmation appeal period duration in terms\n        uint16 penaltyPct;                      // Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n        uint64 firstRoundJurorsNumber;          // Number of jurors drafted on first round\n        uint64 appealStepFactor;                // Factor in which the jurors number is increased on each appeal\n        uint64 finalRoundLockTerms;             // Period a coherent juror in the final round will remain locked\n        uint256 maxRegularAppealRounds;         // Before the final appeal\n        uint256 appealCollateralFactor;         // Permyriad multiple of dispute fees required to appeal a preliminary ruling (‱ - 1/10,000)\n        uint256 appealConfirmCollateralFactor;  // Permyriad multiple of dispute fees required to confirm appeal (‱ - 1/10,000)\n    }\n\n    struct DraftConfig {\n        ERC20 feeToken;                         // ERC20 token to be used for the fees of the Court\n        uint16 penaltyPct;                      // Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n        uint256 draftFee;                       // Amount of tokens paid per round to cover the costs of drafting jurors\n    }\n}\n\n// File: ../../aragon-court/contracts/lib/PctHelpers.sol\n\npragma solidity ^0.5.8;\n\n\n\nlibrary PctHelpers {\n    using SafeMath for uint256;\n\n    uint256 internal constant PCT_BASE = 10000; // ‱ (1 / 10,000)\n\n    function isValid(uint16 _pct) internal pure returns (bool) {\n        return _pct <= PCT_BASE;\n    }\n\n    function pct(uint256 self, uint16 _pct) internal pure returns (uint256) {\n        return self.mul(uint256(_pct)) / PCT_BASE;\n    }\n\n    function pct256(uint256 self, uint256 _pct) internal pure returns (uint256) {\n        return self.mul(_pct) / PCT_BASE;\n    }\n\n    function pctIncrease(uint256 self, uint16 _pct) internal pure returns (uint256) {\n        // No need for SafeMath: for addition note that `PCT_BASE` is lower than (2^256 - 2^16)\n        return self.mul(PCT_BASE + uint256(_pct)) / PCT_BASE;\n    }\n}\n\n// File: ../../aragon-court/contracts/court/config/CourtConfig.sol\n\npragma solidity ^0.5.8;\n\n\n\n\n\n\n\ncontract CourtConfig is IConfig, CourtConfigData {\n    using SafeMath64 for uint64;\n    using PctHelpers for uint256;\n\n    string private constant ERROR_TOO_OLD_TERM = \"CONF_TOO_OLD_TERM\";\n    string private constant ERROR_INVALID_PENALTY_PCT = \"CONF_INVALID_PENALTY_PCT\";\n    string private constant ERROR_INVALID_FINAL_ROUND_REDUCTION_PCT = \"CONF_INVALID_FINAL_ROUND_RED_PCT\";\n    string private constant ERROR_INVALID_MAX_APPEAL_ROUNDS = \"CONF_INVALID_MAX_APPEAL_ROUNDS\";\n    string private constant ERROR_LARGE_ROUND_PHASE_DURATION = \"CONF_LARGE_ROUND_PHASE_DURATION\";\n    string private constant ERROR_BAD_INITIAL_JURORS_NUMBER = \"CONF_BAD_INITIAL_JURORS_NUMBER\";\n    string private constant ERROR_BAD_APPEAL_STEP_FACTOR = \"CONF_BAD_APPEAL_STEP_FACTOR\";\n    string private constant ERROR_ZERO_COLLATERAL_FACTOR = \"CONF_ZERO_COLLATERAL_FACTOR\";\n    string private constant ERROR_ZERO_MIN_ACTIVE_BALANCE = \"CONF_ZERO_MIN_ACTIVE_BALANCE\";\n\n    // Max number of terms that each of the different adjudication states can last (if lasted 1h, this would be a year)\n    uint64 internal constant MAX_ADJ_STATE_DURATION = 8670;\n\n    // Cap the max number of regular appeal rounds\n    uint256 internal constant MAX_REGULAR_APPEAL_ROUNDS_LIMIT = 10;\n\n    // Future term ID in which a config change has been scheduled\n    uint64 private configChangeTermId;\n\n    // List of all the configs used in the Court\n    Config[] private configs;\n\n    // List of configs indexed by id\n    mapping (uint64 => uint256) private configIdByTerm;\n\n    // Holders opt-in config for automatic withdrawals\n    mapping (address => bool) private withdrawalsAllowed;\n\n    event NewConfig(uint64 fromTermId, uint64 courtConfigId);\n    event AutomaticWithdrawalsAllowedChanged(address indexed holder, bool allowed);\n\n    /**\n    * @dev Constructor function\n    * @param _feeToken Address of the token contract that is used to pay for fees\n    * @param _fees Array containing:\n    *        0. jurorFee Amount of fee tokens that is paid per juror per dispute\n    *        1. draftFee Amount of fee tokens per juror to cover the drafting cost\n    *        2. settleFee Amount of fee tokens per juror to cover round settlement cost\n    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n    *        0. evidenceTerms Max submitting evidence period duration in terms\n    *        1. commitTerms Commit period duration in terms\n    *        2. revealTerms Reveal period duration in terms\n    *        3. appealTerms Appeal period duration in terms\n    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\n    * @param _pcts Array containing:\n    *        0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\n    * @param _roundParams Array containing params for rounds:\n    *        0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\n    *        1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\n    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n    *        3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\n    * @param _appealCollateralParams Array containing params for appeal collateral:\n    *        0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\n    *        1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\n    * @param _minActiveBalance Minimum amount of juror tokens that can be activated\n    */\n    constructor(\n        ERC20 _feeToken,\n        uint256[3] memory _fees,\n        uint64[5] memory _roundStateDurations,\n        uint16[2] memory _pcts,\n        uint64[4] memory _roundParams,\n        uint256[2] memory _appealCollateralParams,\n        uint256 _minActiveBalance\n    )\n        public\n    {\n        // Leave config at index 0 empty for non-scheduled config changes\n        configs.length = 1;\n        _setConfig(\n            0,\n            0,\n            _feeToken,\n            _fees,\n            _roundStateDurations,\n            _pcts,\n            _roundParams,\n            _appealCollateralParams,\n            _minActiveBalance\n        );\n    }\n\n    /**\n    * @notice Set the automatic withdrawals config for the sender to `_allowed`\n    * @param _allowed Whether or not the automatic withdrawals are allowed by the sender\n    */\n    function setAutomaticWithdrawals(bool _allowed) external {\n        withdrawalsAllowed[msg.sender] = _allowed;\n        emit AutomaticWithdrawalsAllowedChanged(msg.sender, _allowed);\n    }\n\n    /**\n    * @dev Tell the full Court configuration parameters at a certain term\n    * @param _termId Identification number of the term querying the Court config of\n    * @return token Address of the token used to pay for fees\n    * @return fees Array containing:\n    *         0. jurorFee Amount of fee tokens that is paid per juror per dispute\n    *         1. draftFee Amount of fee tokens per juror to cover the drafting cost\n    *         2. settleFee Amount of fee tokens per juror to cover round settlement cost\n    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n    *         0. evidenceTerms Max submitting evidence period duration in terms\n    *         1. commitTerms Commit period duration in terms\n    *         2. revealTerms Reveal period duration in terms\n    *         3. appealTerms Appeal period duration in terms\n    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\n    * @return pcts Array containing:\n    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\n    * @return roundParams Array containing params for rounds:\n    *         0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\n    *         1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\n    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n    * @return appealCollateralParams Array containing params for appeal collateral:\n    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\n    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\n    * @return minActiveBalance Minimum amount of tokens jurors have to activate to participate in the Court\n    */\n    function getConfig(uint64 _termId) external view\n        returns (\n            ERC20 feeToken,\n            uint256[3] memory fees,\n            uint64[5] memory roundStateDurations,\n            uint16[2] memory pcts,\n            uint64[4] memory roundParams,\n            uint256[2] memory appealCollateralParams,\n            uint256 minActiveBalance\n        );\n\n    /**\n    * @dev Tell the draft config at a certain term\n    * @param _termId Identification number of the term querying the draft config of\n    * @return feeToken Address of the token used to pay for fees\n    * @return draftFee Amount of fee tokens per juror to cover the drafting cost\n    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n    */\n    function getDraftConfig(uint64 _termId) external view returns (ERC20 feeToken, uint256 draftFee, uint16 penaltyPct);\n\n    /**\n    * @dev Tell the min active balance config at a certain term\n    * @param _termId Term querying the min active balance config of\n    * @return Minimum amount of tokens jurors have to activate to participate in the Court\n    */\n    function getMinActiveBalance(uint64 _termId) external view returns (uint256);\n\n    /**\n    * @dev Tell whether a certain holder accepts automatic withdrawals of tokens or not\n    * @param _holder Address of the token holder querying if withdrawals are allowed for\n    * @return True if the given holder accepts automatic withdrawals of their tokens, false otherwise\n    */\n    function areWithdrawalsAllowedFor(address _holder) external view returns (bool) {\n        return withdrawalsAllowed[_holder];\n    }\n\n    /**\n    * @dev Tell the term identification number of the next scheduled config change\n    * @return Term identification number of the next scheduled config change\n    */\n    function getConfigChangeTermId() external view returns (uint64) {\n        return configChangeTermId;\n    }\n\n    /**\n    * @dev Internal to make sure to set a config for the new term, it will copy the previous term config if none\n    * @param _termId Identification number of the new current term that has been transitioned\n    */\n    function _ensureTermConfig(uint64 _termId) internal {\n        // If the term being transitioned had no config change scheduled, keep the previous one\n        uint256 currentConfigId = configIdByTerm[_termId];\n        if (currentConfigId == 0) {\n            uint256 previousConfigId = configIdByTerm[_termId.sub(1)];\n            configIdByTerm[_termId] = previousConfigId;\n        }\n    }\n\n    /**\n    * @dev Assumes that sender it's allowed (either it's from governor or it's on init)\n    * @param _termId Identification number of the current Court term\n    * @param _fromTermId Identification number of the term in which the config will be effective at\n    * @param _feeToken Address of the token contract that is used to pay for fees.\n    * @param _fees Array containing:\n    *        0. jurorFee Amount of fee tokens that is paid per juror per dispute\n    *        1. draftFee Amount of fee tokens per juror to cover the drafting cost\n    *        2. settleFee Amount of fee tokens per juror to cover round settlement cost\n    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n    *        0. evidenceTerms Max submitting evidence period duration in terms\n    *        1. commitTerms Commit period duration in terms\n    *        2. revealTerms Reveal period duration in terms\n    *        3. appealTerms Appeal period duration in terms\n    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\n    * @param _pcts Array containing:\n    *        0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\n    * @param _roundParams Array containing params for rounds:\n    *        0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\n    *        1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\n    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n    *        3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\n    * @param _appealCollateralParams Array containing params for appeal collateral:\n    *        0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\n    *        1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\n    * @param _minActiveBalance Minimum amount of juror tokens that can be activated\n    */\n    function _setConfig(\n        uint64 _termId,\n        uint64 _fromTermId,\n        ERC20 _feeToken,\n        uint256[3] memory _fees,\n        uint64[5] memory _roundStateDurations,\n        uint16[2] memory _pcts,\n        uint64[4] memory _roundParams,\n        uint256[2] memory _appealCollateralParams,\n        uint256 _minActiveBalance\n    )\n        internal\n    {\n        // If the current term is not zero, changes must be scheduled at least after the current period.\n        // No need to ensure delays for on-going disputes since these already use their creation term for that.\n        require(_termId == 0 || _fromTermId > _termId, ERROR_TOO_OLD_TERM);\n\n        // Make sure appeal collateral factors are greater than zero\n        require(_appealCollateralParams[0] > 0 && _appealCollateralParams[1] > 0, ERROR_ZERO_COLLATERAL_FACTOR);\n\n        // Make sure the given penalty and final round reduction pcts are not greater than 100%\n        require(PctHelpers.isValid(_pcts[0]), ERROR_INVALID_PENALTY_PCT);\n        require(PctHelpers.isValid(_pcts[1]), ERROR_INVALID_FINAL_ROUND_REDUCTION_PCT);\n\n        // Disputes must request at least one juror to be drafted initially\n        require(_roundParams[0] > 0, ERROR_BAD_INITIAL_JURORS_NUMBER);\n\n        // Prevent that further rounds have zero jurors\n        require(_roundParams[1] > 0, ERROR_BAD_APPEAL_STEP_FACTOR);\n\n        // Make sure the max number of appeals allowed does not reach the limit\n        uint256 _maxRegularAppealRounds = _roundParams[2];\n        bool isMaxAppealRoundsValid = _maxRegularAppealRounds > 0 && _maxRegularAppealRounds <= MAX_REGULAR_APPEAL_ROUNDS_LIMIT;\n        require(isMaxAppealRoundsValid, ERROR_INVALID_MAX_APPEAL_ROUNDS);\n\n        // Make sure each adjudication round phase duration is valid\n        for (uint i = 0; i < _roundStateDurations.length; i++) {\n            require(_roundStateDurations[i] > 0 && _roundStateDurations[i] < MAX_ADJ_STATE_DURATION, ERROR_LARGE_ROUND_PHASE_DURATION);\n        }\n\n        // Make sure min active balance is not zero\n        require(_minActiveBalance > 0, ERROR_ZERO_MIN_ACTIVE_BALANCE);\n\n        // If there was a config change already scheduled, reset it (in that case we will overwrite last array item).\n        // Otherwise, schedule a new config.\n        if (configChangeTermId > _termId) {\n            configIdByTerm[configChangeTermId] = 0;\n        } else {\n            configs.length++;\n        }\n\n        uint64 courtConfigId = uint64(configs.length - 1);\n        Config storage config = configs[courtConfigId];\n\n        config.fees = FeesConfig({\n            token: _feeToken,\n            jurorFee: _fees[0],\n            draftFee: _fees[1],\n            settleFee: _fees[2],\n            finalRoundReduction: _pcts[1]\n        });\n\n        config.disputes = DisputesConfig({\n            evidenceTerms: _roundStateDurations[0],\n            commitTerms: _roundStateDurations[1],\n            revealTerms: _roundStateDurations[2],\n            appealTerms: _roundStateDurations[3],\n            appealConfirmTerms: _roundStateDurations[4],\n            penaltyPct: _pcts[0],\n            firstRoundJurorsNumber: _roundParams[0],\n            appealStepFactor: _roundParams[1],\n            maxRegularAppealRounds: _maxRegularAppealRounds,\n            finalRoundLockTerms: _roundParams[3],\n            appealCollateralFactor: _appealCollateralParams[0],\n            appealConfirmCollateralFactor: _appealCollateralParams[1]\n        });\n\n        config.minActiveBalance = _minActiveBalance;\n\n        configIdByTerm[_fromTermId] = courtConfigId;\n        configChangeTermId = _fromTermId;\n\n        emit NewConfig(_fromTermId, courtConfigId);\n    }\n\n    /**\n    * @dev Internal function to get the Court config for a given term\n    * @param _termId Identification number of the term querying the Court config of\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\n    * @return token Address of the token used to pay for fees\n    * @return fees Array containing:\n    *         0. jurorFee Amount of fee tokens that is paid per juror per dispute\n    *         1. draftFee Amount of fee tokens per juror to cover the drafting cost\n    *         2. settleFee Amount of fee tokens per juror to cover round settlement cost\n    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n    *         0. evidenceTerms Max submitting evidence period duration in terms\n    *         1. commitTerms Commit period duration in terms\n    *         2. revealTerms Reveal period duration in terms\n    *         3. appealTerms Appeal period duration in terms\n    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\n    * @return pcts Array containing:\n    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\n    * @return roundParams Array containing params for rounds:\n    *         0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\n    *         1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\n    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n    *         3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\n    * @return appealCollateralParams Array containing params for appeal collateral:\n    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\n    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\n    * @return minActiveBalance Minimum amount of juror tokens that can be activated\n    */\n    function _getConfigAt(uint64 _termId, uint64 _lastEnsuredTermId) internal view\n        returns (\n            ERC20 feeToken,\n            uint256[3] memory fees,\n            uint64[5] memory roundStateDurations,\n            uint16[2] memory pcts,\n            uint64[4] memory roundParams,\n            uint256[2] memory appealCollateralParams,\n            uint256 minActiveBalance\n        )\n    {\n        Config storage config = _getConfigFor(_termId, _lastEnsuredTermId);\n\n        FeesConfig storage feesConfig = config.fees;\n        feeToken = feesConfig.token;\n        fees = [feesConfig.jurorFee, feesConfig.draftFee, feesConfig.settleFee];\n\n        DisputesConfig storage disputesConfig = config.disputes;\n        roundStateDurations = [\n            disputesConfig.evidenceTerms,\n            disputesConfig.commitTerms,\n            disputesConfig.revealTerms,\n            disputesConfig.appealTerms,\n            disputesConfig.appealConfirmTerms\n        ];\n        pcts = [disputesConfig.penaltyPct, feesConfig.finalRoundReduction];\n        roundParams = [\n            disputesConfig.firstRoundJurorsNumber,\n            disputesConfig.appealStepFactor,\n            uint64(disputesConfig.maxRegularAppealRounds),\n            disputesConfig.finalRoundLockTerms\n        ];\n        appealCollateralParams = [disputesConfig.appealCollateralFactor, disputesConfig.appealConfirmCollateralFactor];\n\n        minActiveBalance = config.minActiveBalance;\n    }\n\n    /**\n    * @dev Tell the draft config at a certain term\n    * @param _termId Identification number of the term querying the draft config of\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\n    * @return feeToken Address of the token used to pay for fees\n    * @return draftFee Amount of fee tokens per juror to cover the drafting cost\n    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n    */\n    function _getDraftConfig(uint64 _termId,  uint64 _lastEnsuredTermId) internal view\n        returns (ERC20 feeToken, uint256 draftFee, uint16 penaltyPct)\n    {\n        Config storage config = _getConfigFor(_termId, _lastEnsuredTermId);\n        return (config.fees.token, config.fees.draftFee, config.disputes.penaltyPct);\n    }\n\n    /**\n    * @dev Internal function to get the min active balance config for a given term\n    * @param _termId Identification number of the term querying the min active balance config of\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\n    * @return Minimum amount of juror tokens that can be activated at the given term\n    */\n    function _getMinActiveBalance(uint64 _termId, uint64 _lastEnsuredTermId) internal view returns (uint256) {\n        Config storage config = _getConfigFor(_termId, _lastEnsuredTermId);\n        return config.minActiveBalance;\n    }\n\n    /**\n    * @dev Internal function to get the Court config for a given term\n    * @param _termId Identification number of the term querying the min active balance config of\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\n    * @return Court config for the given term\n    */\n    function _getConfigFor(uint64 _termId, uint64 _lastEnsuredTermId) internal view returns (Config storage) {\n        uint256 id = _getConfigIdFor(_termId, _lastEnsuredTermId);\n        return configs[id];\n    }\n\n    /**\n    * @dev Internal function to get the Court config ID for a given term\n    * @param _termId Identification number of the term querying the Court config of\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\n    * @return Identification number of the config for the given terms\n    */\n    function _getConfigIdFor(uint64 _termId, uint64 _lastEnsuredTermId) internal view returns (uint256) {\n        // If the given term is lower or equal to the last ensured Court term, it is safe to use a past Court config\n        if (_termId <= _lastEnsuredTermId) {\n            return configIdByTerm[_termId];\n        }\n\n        // If the given term is in the future but there is a config change scheduled before it, use the incoming config\n        uint64 scheduledChangeTermId = configChangeTermId;\n        if (scheduledChangeTermId <= _termId) {\n            return configIdByTerm[scheduledChangeTermId];\n        }\n\n        // If no changes are scheduled, use the Court config of the last ensured term\n        return configIdByTerm[_lastEnsuredTermId];\n    }\n}\n\n// File: ../../aragon-court/contracts/court/controller/Controller.sol\n\npragma solidity ^0.5.8;\n\n\n\n\n\ncontract Controller is IsContract, CourtClock, CourtConfig {\n    string private constant ERROR_SENDER_NOT_GOVERNOR = \"CTR_SENDER_NOT_GOVERNOR\";\n    string private constant ERROR_INVALID_GOVERNOR_ADDRESS = \"CTR_INVALID_GOVERNOR_ADDRESS\";\n    string private constant ERROR_IMPLEMENTATION_NOT_CONTRACT = \"CTR_IMPLEMENTATION_NOT_CONTRACT\";\n    string private constant ERROR_INVALID_IMPLS_INPUT_LENGTH = \"CTR_INVALID_IMPLS_INPUT_LENGTH\";\n\n    address private constant ZERO_ADDRESS = address(0);\n\n    // DisputeManager module ID - keccak256(abi.encodePacked(\"DISPUTE_MANAGER\"))\n    bytes32 internal constant DISPUTE_MANAGER = 0x14a6c70f0f6d449c014c7bbc9e68e31e79e8474fb03b7194df83109a2d888ae6;\n\n    // Treasury module ID - keccak256(abi.encodePacked(\"TREASURY\"))\n    bytes32 internal constant TREASURY = 0x06aa03964db1f7257357ef09714a5f0ca3633723df419e97015e0c7a3e83edb7;\n\n    // Voting module ID - keccak256(abi.encodePacked(\"VOTING\"))\n    bytes32 internal constant VOTING = 0x7cbb12e82a6d63ff16fe43977f43e3e2b247ecd4e62c0e340da8800a48c67346;\n\n    // JurorsRegistry module ID - keccak256(abi.encodePacked(\"JURORS_REGISTRY\"))\n    bytes32 internal constant JURORS_REGISTRY = 0x3b21d36b36308c830e6c4053fb40a3b6d79dde78947fbf6b0accd30720ab5370;\n\n    // Subscriptions module ID - keccak256(abi.encodePacked(\"SUBSCRIPTIONS\"))\n    bytes32 internal constant SUBSCRIPTIONS = 0x2bfa3327fe52344390da94c32a346eeb1b65a8b583e4335a419b9471e88c1365;\n\n    /**\n    * @dev Governor of the whole system. Set of three addresses to recover funds, change configuration settings and setup modules\n    */\n    struct Governor {\n        address funds;      // This address can be unset at any time. It is allowed to recover funds from the ControlledRecoverable modules\n        address config;     // This address is meant not to be unset. It is allowed to change the different configurations of the whole system\n        address modules;    // This address can be unset at any time. It is allowed to plug/unplug modules from the system\n    }\n\n    // Governor addresses of the system\n    Governor private governor;\n\n    // List of modules registered for the system indexed by ID\n    mapping (bytes32 => address) internal modules;\n\n    event ModuleSet(bytes32 id, address addr);\n    event FundsGovernorChanged(address previousGovernor, address currentGovernor);\n    event ConfigGovernorChanged(address previousGovernor, address currentGovernor);\n    event ModulesGovernorChanged(address previousGovernor, address currentGovernor);\n\n    /**\n    * @dev Ensure the msg.sender is the funds governor\n    */\n    modifier onlyFundsGovernor {\n        require(msg.sender == governor.funds, ERROR_SENDER_NOT_GOVERNOR);\n        _;\n    }\n\n    /**\n    * @dev Ensure the msg.sender is the modules governor\n    */\n    modifier onlyConfigGovernor {\n        require(msg.sender == governor.config, ERROR_SENDER_NOT_GOVERNOR);\n        _;\n    }\n\n    /**\n    * @dev Ensure the msg.sender is the modules governor\n    */\n    modifier onlyModulesGovernor {\n        require(msg.sender == governor.modules, ERROR_SENDER_NOT_GOVERNOR);\n        _;\n    }\n\n    /**\n    * @dev Constructor function\n    * @param _termParams Array containing:\n    *        0. _termDuration Duration in seconds per term\n    *        1. _firstTermStartTime Timestamp in seconds when the court will open (to give time for juror on-boarding)\n    * @param _governors Array containing:\n    *        0. _fundsGovernor Address of the funds governor\n    *        1. _configGovernor Address of the config governor\n    *        2. _modulesGovernor Address of the modules governor\n    * @param _feeToken Address of the token contract that is used to pay for fees\n    * @param _fees Array containing:\n    *        0. jurorFee Amount of fee tokens that is paid per juror per dispute\n    *        1. draftFee Amount of fee tokens per juror to cover the drafting cost\n    *        2. settleFee Amount of fee tokens per juror to cover round settlement cost\n    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n    *        0. evidenceTerms Max submitting evidence period duration in terms\n    *        1. commitTerms Commit period duration in terms\n    *        2. revealTerms Reveal period duration in terms\n    *        3. appealTerms Appeal period duration in terms\n    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\n    * @param _pcts Array containing:\n    *        0. penaltyPct Permyriad of min active tokens balance to be locked to each drafted jurors (‱ - 1/10,000)\n    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\n    * @param _roundParams Array containing params for rounds:\n    *        0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\n    *        1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\n    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n    *        3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\n    * @param _appealCollateralParams Array containing params for appeal collateral:\n    *        1. appealCollateralFactor Permyriad multiple of dispute fees required to appeal a preliminary ruling\n    *        2. appealConfirmCollateralFactor Permyriad multiple of dispute fees required to confirm appeal\n    * @param _minActiveBalance Minimum amount of juror tokens that can be activated\n    */\n    constructor(\n        uint64[2] memory _termParams,\n        address[3] memory _governors,\n        ERC20 _feeToken,\n        uint256[3] memory _fees,\n        uint64[5] memory _roundStateDurations,\n        uint16[2] memory _pcts,\n        uint64[4] memory _roundParams,\n        uint256[2] memory _appealCollateralParams,\n        uint256 _minActiveBalance\n    )\n        public\n        CourtClock(_termParams)\n        CourtConfig(_feeToken, _fees, _roundStateDurations, _pcts, _roundParams, _appealCollateralParams, _minActiveBalance)\n    {\n        _setFundsGovernor(_governors[0]);\n        _setConfigGovernor(_governors[1]);\n        _setModulesGovernor(_governors[2]);\n    }\n\n    /**\n    * @notice Change Court configuration params\n    * @param _fromTermId Identification number of the term in which the config will be effective at\n    * @param _feeToken Address of the token contract that is used to pay for fees\n    * @param _fees Array containing:\n    *        0. jurorFee Amount of fee tokens that is paid per juror per dispute\n    *        1. draftFee Amount of fee tokens per juror to cover the drafting cost\n    *        2. settleFee Amount of fee tokens per juror to cover round settlement cost\n    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n    *        0. evidenceTerms Max submitting evidence period duration in terms\n    *        1. commitTerms Commit period duration in terms\n    *        2. revealTerms Reveal period duration in terms\n    *        3. appealTerms Appeal period duration in terms\n    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\n    * @param _pcts Array containing:\n    *        0. penaltyPct Permyriad of min active tokens balance to be locked to each drafted jurors (‱ - 1/10,000)\n    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\n    * @param _roundParams Array containing params for rounds:\n    *        0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\n    *        1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\n    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n    *        3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\n    * @param _appealCollateralParams Array containing params for appeal collateral:\n    *        1. appealCollateralFactor Permyriad multiple of dispute fees required to appeal a preliminary ruling\n    *        2. appealConfirmCollateralFactor Permyriad multiple of dispute fees required to confirm appeal\n    * @param _minActiveBalance Minimum amount of juror tokens that can be activated\n    */\n    function setConfig(\n        uint64 _fromTermId,\n        ERC20 _feeToken,\n        uint256[3] calldata _fees,\n        uint64[5] calldata _roundStateDurations,\n        uint16[2] calldata _pcts,\n        uint64[4] calldata _roundParams,\n        uint256[2] calldata _appealCollateralParams,\n        uint256 _minActiveBalance\n    )\n        external\n        onlyConfigGovernor\n    {\n        uint64 currentTermId = _ensureCurrentTerm();\n        _setConfig(\n            currentTermId,\n            _fromTermId,\n            _feeToken,\n            _fees,\n            _roundStateDurations,\n            _pcts,\n            _roundParams,\n            _appealCollateralParams,\n            _minActiveBalance\n        );\n    }\n\n    /**\n    * @notice Delay the Court start time to `_newFirstTermStartTime`\n    * @param _newFirstTermStartTime New timestamp in seconds when the court will open\n    */\n    function delayStartTime(uint64 _newFirstTermStartTime) external onlyConfigGovernor {\n        _delayStartTime(_newFirstTermStartTime);\n    }\n\n    /**\n    * @notice Change funds governor address to `_newFundsGovernor`\n    * @param _newFundsGovernor Address of the new funds governor to be set\n    */\n    function changeFundsGovernor(address _newFundsGovernor) external onlyFundsGovernor {\n        require(_newFundsGovernor != ZERO_ADDRESS, ERROR_INVALID_GOVERNOR_ADDRESS);\n        _setFundsGovernor(_newFundsGovernor);\n    }\n\n    /**\n    * @notice Change config governor address to `_newConfigGovernor`\n    * @param _newConfigGovernor Address of the new config governor to be set\n    */\n    function changeConfigGovernor(address _newConfigGovernor) external onlyConfigGovernor {\n        require(_newConfigGovernor != ZERO_ADDRESS, ERROR_INVALID_GOVERNOR_ADDRESS);\n        _setConfigGovernor(_newConfigGovernor);\n    }\n\n    /**\n    * @notice Change modules governor address to `_newModulesGovernor`\n    * @param _newModulesGovernor Address of the new governor to be set\n    */\n    function changeModulesGovernor(address _newModulesGovernor) external onlyModulesGovernor {\n        require(_newModulesGovernor != ZERO_ADDRESS, ERROR_INVALID_GOVERNOR_ADDRESS);\n        _setModulesGovernor(_newModulesGovernor);\n    }\n\n    /**\n    * @notice Remove the funds governor. Set the funds governor to the zero address.\n    * @dev This action cannot be rolled back, once the funds governor has been unset, funds cannot be recovered from recoverable modules anymore\n    */\n    function ejectFundsGovernor() external onlyFundsGovernor {\n        _setFundsGovernor(ZERO_ADDRESS);\n    }\n\n    /**\n    * @notice Remove the modules governor. Set the modules governor to the zero address.\n    * @dev This action cannot be rolled back, once the modules governor has been unset, system modules cannot be changed anymore\n    */\n    function ejectModulesGovernor() external onlyModulesGovernor {\n        _setModulesGovernor(ZERO_ADDRESS);\n    }\n\n    /**\n    * @notice Set module `_id` to `_addr`\n    * @param _id ID of the module to be set\n    * @param _addr Address of the module to be set\n    */\n    function setModule(bytes32 _id, address _addr) external onlyModulesGovernor {\n        _setModule(_id, _addr);\n    }\n\n    /**\n    * @notice Set many modules at once\n    * @param _ids List of ids of each module to be set\n    * @param _addresses List of addressed of each the module to be set\n    */\n    function setModules(bytes32[] calldata _ids, address[] calldata _addresses) external onlyModulesGovernor {\n        require(_ids.length == _addresses.length, ERROR_INVALID_IMPLS_INPUT_LENGTH);\n\n        for (uint256 i = 0; i < _ids.length; i++) {\n            _setModule(_ids[i], _addresses[i]);\n        }\n    }\n\n    /**\n    * @dev Tell the full Court configuration parameters at a certain term\n    * @param _termId Identification number of the term querying the Court config of\n    * @return token Address of the token used to pay for fees\n    * @return fees Array containing:\n    *         0. jurorFee Amount of fee tokens that is paid per juror per dispute\n    *         1. draftFee Amount of fee tokens per juror to cover the drafting cost\n    *         2. settleFee Amount of fee tokens per juror to cover round settlement cost\n    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n    *         0. evidenceTerms Max submitting evidence period duration in terms\n    *         1. commitTerms Commit period duration in terms\n    *         2. revealTerms Reveal period duration in terms\n    *         3. appealTerms Appeal period duration in terms\n    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\n    * @return pcts Array containing:\n    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\n    * @return roundParams Array containing params for rounds:\n    *         0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\n    *         1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\n    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n    *         3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\n    * @return appealCollateralParams Array containing params for appeal collateral:\n    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\n    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\n    */\n    function getConfig(uint64 _termId) external view\n        returns (\n            ERC20 feeToken,\n            uint256[3] memory fees,\n            uint64[5] memory roundStateDurations,\n            uint16[2] memory pcts,\n            uint64[4] memory roundParams,\n            uint256[2] memory appealCollateralParams,\n            uint256 minActiveBalance\n        )\n    {\n        uint64 lastEnsuredTermId = _lastEnsuredTermId();\n        return _getConfigAt(_termId, lastEnsuredTermId);\n    }\n\n    /**\n    * @dev Tell the draft config at a certain term\n    * @param _termId Identification number of the term querying the draft config of\n    * @return feeToken Address of the token used to pay for fees\n    * @return draftFee Amount of fee tokens per juror to cover the drafting cost\n    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n    */\n    function getDraftConfig(uint64 _termId) external view returns (ERC20 feeToken, uint256 draftFee, uint16 penaltyPct) {\n        uint64 lastEnsuredTermId = _lastEnsuredTermId();\n        return _getDraftConfig(_termId, lastEnsuredTermId);\n    }\n\n    /**\n    * @dev Tell the min active balance config at a certain term\n    * @param _termId Identification number of the term querying the min active balance config of\n    * @return Minimum amount of tokens jurors have to activate to participate in the Court\n    */\n    function getMinActiveBalance(uint64 _termId) external view returns (uint256) {\n        uint64 lastEnsuredTermId = _lastEnsuredTermId();\n        return _getMinActiveBalance(_termId, lastEnsuredTermId);\n    }\n\n    /**\n    * @dev Tell the address of the funds governor\n    * @return Address of the funds governor\n    */\n    function getFundsGovernor() external view returns (address) {\n        return governor.funds;\n    }\n\n    /**\n    * @dev Tell the address of the config governor\n    * @return Address of the config governor\n    */\n    function getConfigGovernor() external view returns (address) {\n        return governor.config;\n    }\n\n    /**\n    * @dev Tell the address of the modules governor\n    * @return Address of the modules governor\n    */\n    function getModulesGovernor() external view returns (address) {\n        return governor.modules;\n    }\n\n    /**\n    * @dev Tell address of a module based on a given ID\n    * @param _id ID of the module being queried\n    * @return Address of the requested module\n    */\n    function getModule(bytes32 _id) external view returns (address) {\n        return _getModule(_id);\n    }\n\n    /**\n    * @dev Tell the address of the DisputeManager module\n    * @return Address of the DisputeManager module\n    */\n    function getDisputeManager() external view returns (address) {\n        return _getDisputeManager();\n    }\n\n    /**\n    * @dev Tell the address of the Treasury module\n    * @return Address of the Treasury module\n    */\n    function getTreasury() external view returns (address) {\n        return _getModule(TREASURY);\n    }\n\n    /**\n    * @dev Tell the address of the Voting module\n    * @return Address of the Voting module\n    */\n    function getVoting() external view returns (address) {\n        return _getModule(VOTING);\n    }\n\n    /**\n    * @dev Tell the address of the JurorsRegistry module\n    * @return Address of the JurorsRegistry module\n    */\n    function getJurorsRegistry() external view returns (address) {\n        return _getModule(JURORS_REGISTRY);\n    }\n\n    /**\n    * @dev Tell the address of the Subscriptions module\n    * @return Address of the Subscriptions module\n    */\n    function getSubscriptions() external view returns (address) {\n        return _getSubscriptions();\n    }\n\n    /**\n    * @dev Internal function to set the address of the funds governor\n    * @param _newFundsGovernor Address of the new config governor to be set\n    */\n    function _setFundsGovernor(address _newFundsGovernor) internal {\n        emit FundsGovernorChanged(governor.funds, _newFundsGovernor);\n        governor.funds = _newFundsGovernor;\n    }\n\n    /**\n    * @dev Internal function to set the address of the config governor\n    * @param _newConfigGovernor Address of the new config governor to be set\n    */\n    function _setConfigGovernor(address _newConfigGovernor) internal {\n        emit ConfigGovernorChanged(governor.config, _newConfigGovernor);\n        governor.config = _newConfigGovernor;\n    }\n\n    /**\n    * @dev Internal function to set the address of the modules governor\n    * @param _newModulesGovernor Address of the new modules governor to be set\n    */\n    function _setModulesGovernor(address _newModulesGovernor) internal {\n        emit ModulesGovernorChanged(governor.modules, _newModulesGovernor);\n        governor.modules = _newModulesGovernor;\n    }\n\n    /**\n    * @dev Internal function to set a module\n    * @param _id Id of the module to be set\n    * @param _addr Address of the module to be set\n    */\n    function _setModule(bytes32 _id, address _addr) internal {\n        require(isContract(_addr), ERROR_IMPLEMENTATION_NOT_CONTRACT);\n        modules[_id] = _addr;\n        emit ModuleSet(_id, _addr);\n    }\n\n    /**\n    * @dev Internal function to notify when a term has been transitioned\n    * @param _termId Identification number of the new current term that has been transitioned\n    */\n    function _onTermTransitioned(uint64 _termId) internal {\n        _ensureTermConfig(_termId);\n    }\n\n    /**\n    * @dev Internal function to tell the address of the DisputeManager module\n    * @return Address of the DisputeManager module\n    */\n    function _getDisputeManager() internal view returns (address) {\n        return _getModule(DISPUTE_MANAGER);\n    }\n\n    /**\n    * @dev Internal function to tell the address of the Subscriptions module\n    * @return Address of the Subscriptions module\n    */\n    function _getSubscriptions() internal view returns (address) {\n        return _getModule(SUBSCRIPTIONS);\n    }\n\n    /**\n    * @dev Internal function to tell address of a module based on a given ID\n    * @param _id ID of the module being queried\n    * @return Address of the requested module\n    */\n    function _getModule(bytes32 _id) internal view returns (address) {\n        return modules[_id];\n    }\n}\n\n// File: ../../aragon-court/contracts/court/config/ConfigConsumer.sol\n\npragma solidity ^0.5.8;\n\n\n\n\n\ncontract ConfigConsumer is CourtConfigData {\n    /**\n    * @dev Internal function to fetch the address of the Config module from the controller\n    * @return Address of the Config module\n    */\n    function _courtConfig() internal view returns (IConfig);\n\n    /**\n    * @dev Internal function to get the Court config for a certain term\n    * @param _termId Identification number of the term querying the Court config of\n    * @return Court config for the given term\n    */\n    function _getConfigAt(uint64 _termId) internal view returns (Config memory) {\n        (ERC20 _feeToken,\n        uint256[3] memory _fees,\n        uint64[5] memory _roundStateDurations,\n        uint16[2] memory _pcts,\n        uint64[4] memory _roundParams,\n        uint256[2] memory _appealCollateralParams,\n        uint256 _minActiveBalance) = _courtConfig().getConfig(_termId);\n\n        Config memory config;\n\n        config.fees = FeesConfig({\n            token: _feeToken,\n            jurorFee: _fees[0],\n            draftFee: _fees[1],\n            settleFee: _fees[2],\n            finalRoundReduction: _pcts[1]\n        });\n\n        config.disputes = DisputesConfig({\n            evidenceTerms: _roundStateDurations[0],\n            commitTerms: _roundStateDurations[1],\n            revealTerms: _roundStateDurations[2],\n            appealTerms: _roundStateDurations[3],\n            appealConfirmTerms: _roundStateDurations[4],\n            penaltyPct: _pcts[0],\n            firstRoundJurorsNumber: _roundParams[0],\n            appealStepFactor: _roundParams[1],\n            maxRegularAppealRounds: _roundParams[2],\n            finalRoundLockTerms: _roundParams[3],\n            appealCollateralFactor: _appealCollateralParams[0],\n            appealConfirmCollateralFactor: _appealCollateralParams[1]\n        });\n\n        config.minActiveBalance = _minActiveBalance;\n\n        return config;\n    }\n\n    /**\n    * @dev Internal function to get the draft config for a given term\n    * @param _termId Identification number of the term querying the draft config of\n    * @return Draft config for the given term\n    */\n    function _getDraftConfig(uint64 _termId) internal view returns (DraftConfig memory) {\n        (ERC20 feeToken, uint256 draftFee, uint16 penaltyPct) = _courtConfig().getDraftConfig(_termId);\n        return DraftConfig({ feeToken: feeToken, draftFee: draftFee, penaltyPct: penaltyPct });\n    }\n\n    /**\n    * @dev Internal function to get the min active balance config for a given term\n    * @param _termId Identification number of the term querying the min active balance config of\n    * @return Minimum amount of juror tokens that can be activated\n    */\n    function _getMinActiveBalance(uint64 _termId) internal view returns (uint256) {\n        return _courtConfig().getMinActiveBalance(_termId);\n    }\n}\n\n// File: ../../aragon-court/contracts/voting/ICRVotingOwner.sol\n\npragma solidity ^0.5.8;\n\n\ninterface ICRVotingOwner {\n    /**\n    * @dev Ensure votes can be committed for a vote instance, revert otherwise\n    * @param _voteId ID of the vote instance to request the weight of a voter for\n    */\n    function ensureCanCommit(uint256 _voteId) external;\n\n    /**\n    * @dev Ensure a certain voter can commit votes for a vote instance, revert otherwise\n    * @param _voteId ID of the vote instance to request the weight of a voter for\n    * @param _voter Address of the voter querying the weight of\n    */\n    function ensureCanCommit(uint256 _voteId, address _voter) external;\n\n    /**\n    * @dev Ensure a certain voter can reveal votes for vote instance, revert otherwise\n    * @param _voteId ID of the vote instance to request the weight of a voter for\n    * @param _voter Address of the voter querying the weight of\n    * @return Weight of the requested juror for the requested vote instance\n    */\n    function ensureCanReveal(uint256 _voteId, address _voter) external returns (uint64);\n}\n\n// File: ../../aragon-court/contracts/voting/ICRVoting.sol\n\npragma solidity ^0.5.8;\n\n\n\ninterface ICRVoting {\n    /**\n    * @dev Create a new vote instance\n    * @dev This function can only be called by the CRVoting owner\n    * @param _voteId ID of the new vote instance to be created\n    * @param _possibleOutcomes Number of possible outcomes for the new vote instance to be created\n    */\n    function create(uint256 _voteId, uint8 _possibleOutcomes) external;\n\n    /**\n    * @dev Get the winning outcome of a vote instance\n    * @param _voteId ID of the vote instance querying the winning outcome of\n    * @return Winning outcome of the given vote instance or refused in case it's missing\n    */\n    function getWinningOutcome(uint256 _voteId) external view returns (uint8);\n\n    /**\n    * @dev Get the tally of an outcome for a certain vote instance\n    * @param _voteId ID of the vote instance querying the tally of\n    * @param _outcome Outcome querying the tally of\n    * @return Tally of the outcome being queried for the given vote instance\n    */\n    function getOutcomeTally(uint256 _voteId, uint8 _outcome) external view returns (uint256);\n\n    /**\n    * @dev Tell whether an outcome is valid for a given vote instance or not\n    * @param _voteId ID of the vote instance to check the outcome of\n    * @param _outcome Outcome to check if valid or not\n    * @return True if the given outcome is valid for the requested vote instance, false otherwise\n    */\n    function isValidOutcome(uint256 _voteId, uint8 _outcome) external view returns (bool);\n\n    /**\n    * @dev Get the outcome voted by a voter for a certain vote instance\n    * @param _voteId ID of the vote instance querying the outcome of\n    * @param _voter Address of the voter querying the outcome of\n    * @return Outcome of the voter for the given vote instance\n    */\n    function getVoterOutcome(uint256 _voteId, address _voter) external view returns (uint8);\n\n    /**\n    * @dev Tell whether a voter voted in favor of a certain outcome in a vote instance or not\n    * @param _voteId ID of the vote instance to query if a voter voted in favor of a certain outcome\n    * @param _outcome Outcome to query if the given voter voted in favor of\n    * @param _voter Address of the voter to query if voted in favor of the given outcome\n    * @return True if the given voter voted in favor of the given outcome, false otherwise\n    */\n    function hasVotedInFavorOf(uint256 _voteId, uint8 _outcome, address _voter) external view returns (bool);\n\n    /**\n    * @dev Filter a list of voters based on whether they voted in favor of a certain outcome in a vote instance or not\n    * @param _voteId ID of the vote instance to be checked\n    * @param _outcome Outcome to filter the list of voters of\n    * @param _voters List of addresses of the voters to be filtered\n    * @return List of results to tell whether a voter voted in favor of the given outcome or not\n    */\n    function getVotersInFavorOf(uint256 _voteId, uint8 _outcome, address[] calldata _voters) external view returns (bool[] memory);\n}\n\n// File: ../../aragon-court/contracts/registry/IJurorsRegistry.sol\n\npragma solidity ^0.5.8;\n\n\n\ninterface IJurorsRegistry {\n\n    /**\n    * @dev Assign a requested amount of juror tokens to a juror\n    * @param _juror Juror to add an amount of tokens to\n    * @param _amount Amount of tokens to be added to the available balance of a juror\n    */\n    function assignTokens(address _juror, uint256 _amount) external;\n\n    /**\n    * @dev Burn a requested amount of juror tokens\n    * @param _amount Amount of tokens to be burned\n    */\n    function burnTokens(uint256 _amount) external;\n\n    /**\n    * @dev Draft a set of jurors based on given requirements for a term id\n    * @param _params Array containing draft requirements:\n    *        0. bytes32 Term randomness\n    *        1. uint256 Dispute id\n    *        2. uint64  Current term id\n    *        3. uint256 Number of seats already filled\n    *        4. uint256 Number of seats left to be filled\n    *        5. uint64  Number of jurors required for the draft\n    *        6. uint16  Permyriad of the minimum active balance to be locked for the draft\n    *\n    * @return jurors List of jurors selected for the draft\n    * @return length Size of the list of the draft result\n    */\n    function draft(uint256[7] calldata _params) external returns (address[] memory jurors, uint256 length);\n\n    /**\n    * @dev Slash a set of jurors based on their votes compared to the winning ruling\n    * @param _termId Current term id\n    * @param _jurors List of juror addresses to be slashed\n    * @param _lockedAmounts List of amounts locked for each corresponding juror that will be either slashed or returned\n    * @param _rewardedJurors List of booleans to tell whether a juror's active balance has to be slashed or not\n    * @return Total amount of slashed tokens\n    */\n    function slashOrUnlock(uint64 _termId, address[] calldata _jurors, uint256[] calldata _lockedAmounts, bool[] calldata _rewardedJurors)\n        external\n        returns (uint256 collectedTokens);\n\n    /**\n    * @dev Try to collect a certain amount of tokens from a juror for the next term\n    * @param _juror Juror to collect the tokens from\n    * @param _amount Amount of tokens to be collected from the given juror and for the requested term id\n    * @param _termId Current term id\n    * @return True if the juror has enough unlocked tokens to be collected for the requested term, false otherwise\n    */\n    function collectTokens(address _juror, uint256 _amount, uint64 _termId) external returns (bool);\n\n    /**\n    * @dev Lock a juror's withdrawals until a certain term ID\n    * @param _juror Address of the juror to be locked\n    * @param _termId Term ID until which the juror's withdrawals will be locked\n    */\n    function lockWithdrawals(address _juror, uint64 _termId) external;\n\n    /**\n    * @dev Tell the active balance of a juror for a given term id\n    * @param _juror Address of the juror querying the active balance of\n    * @param _termId Term ID querying the active balance for\n    * @return Amount of active tokens for juror in the requested past term id\n    */\n    function activeBalanceOfAt(address _juror, uint64 _termId) external view returns (uint256);\n\n    /**\n    * @dev Tell the total amount of active juror tokens at the given term id\n    * @param _termId Term ID querying the total active balance for\n    * @return Total amount of active juror tokens at the given term id\n    */\n    function totalActiveBalanceAt(uint64 _termId) external view returns (uint256);\n}\n\n// File: ../../aragon-court/contracts/arbitration/IArbitrator.sol\n\npragma solidity ^0.5.8;\n\n\n\ninterface IArbitrator {\n    /**\n    * @dev Create a dispute over the Arbitrable sender with a number of possible rulings\n    * @param _possibleRulings Number of possible rulings allowed for the dispute\n    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\n    * @return Dispute identification number\n    */\n    function createDispute(uint256 _possibleRulings, bytes calldata _metadata) external returns (uint256);\n\n    /**\n    * @dev Close the evidence period of a dispute\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\n    */\n    function closeEvidencePeriod(uint256 _disputeId) external;\n\n    /**\n    * @dev Execute the Arbitrable associated to a dispute based on its final ruling\n    * @param _disputeId Identification number of the dispute to be executed\n    */\n    function executeRuling(uint256 _disputeId) external;\n\n    /**\n    * @dev Tell the dispute fees information to create a dispute\n    * @return recipient Address where the corresponding dispute fees must be transferred to\n    * @return feeToken ERC20 token used for the fees\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\n    */\n    function getDisputeFees() external view returns (address recipient, ERC20 feeToken, uint256 feeAmount);\n\n    /**\n    * @dev Tell the subscription fees information for a subscriber to be up-to-date\n    * @param _subscriber Address of the account paying the subscription fees for\n    * @return recipient Address where the corresponding subscriptions fees must be transferred to\n    * @return feeToken ERC20 token used for the subscription fees\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\n    */\n    function getSubscriptionFees(address _subscriber) external view returns (address recipient, ERC20 feeToken, uint256 feeAmount);\n}\n\n// File: ../../aragon-court/contracts/standards/ERC165.sol\n\npragma solidity ^0.5.8;\n\n\ninterface ERC165 {\n    /**\n    * @dev Query if a contract implements a certain interface\n    * @param _interfaceId The interface identifier being queried, as specified in ERC-165\n    * @return True if the contract implements the requested interface and if its not 0xffffffff, false otherwise\n    */\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool);\n}\n\n// File: ../../aragon-court/contracts/arbitration/IArbitrable.sol\n\npragma solidity ^0.5.8;\n\n\n\n\ncontract IArbitrable is ERC165 {\n    bytes4 internal constant ERC165_INTERFACE_ID = bytes4(0x01ffc9a7);\n    bytes4 internal constant ARBITRABLE_INTERFACE_ID = bytes4(0x88f3ee69);\n\n    /**\n    * @dev Emitted when an IArbitrable instance's dispute is ruled by an IArbitrator\n    * @param arbitrator IArbitrator instance ruling the dispute\n    * @param disputeId Identification number of the dispute being ruled by the arbitrator\n    * @param ruling Ruling given by the arbitrator\n    */\n    event Ruled(IArbitrator indexed arbitrator, uint256 indexed disputeId, uint256 ruling);\n\n    /**\n    * @dev Emitted when new evidence is submitted for the IArbitrable instance's dispute\n    * @param disputeId Identification number of the dispute receiving new evidence\n    * @param submitter Address of the account submitting the evidence\n    * @param evidence Data submitted for the evidence of the dispute\n    * @param finished Whether or not the submitter has finished submitting evidence\n    */\n    event EvidenceSubmitted(uint256 indexed disputeId, address indexed submitter, bytes evidence, bool finished);\n\n    /**\n    * @dev Submit evidence for a dispute\n    * @param _disputeId Id of the dispute in the Court\n    * @param _evidence Data submitted for the evidence related to the dispute\n    * @param _finished Whether or not the submitter has finished submitting evidence\n    */\n    function submitEvidence(uint256 _disputeId, bytes calldata _evidence, bool _finished) external;\n\n    /**\n    * @dev Give a ruling for a certain dispute, the account calling it must have rights to rule on the contract\n    * @param _disputeId Identification number of the dispute to be ruled\n    * @param _ruling Ruling given by the arbitrator, where 0 is reserved for \"refused to make a decision\"\n    */\n    function rule(uint256 _disputeId, uint256 _ruling) external;\n\n    /**\n    * @dev ERC165 - Query if a contract implements a certain interface\n    * @param _interfaceId The interface identifier being queried, as specified in ERC-165\n    * @return True if this contract supports the given interface, false otherwise\n    */\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool) {\n        return _interfaceId == ARBITRABLE_INTERFACE_ID || _interfaceId == ERC165_INTERFACE_ID;\n    }\n}\n\n// File: ../../aragon-court/contracts/disputes/IDisputeManager.sol\n\npragma solidity ^0.5.8;\n\n\n\n\ninterface IDisputeManager {\n    enum DisputeState {\n        PreDraft,\n        Adjudicating,\n        Ruled\n    }\n\n    enum AdjudicationState {\n        Invalid,\n        Committing,\n        Revealing,\n        Appealing,\n        ConfirmingAppeal,\n        Ended\n    }\n\n    /**\n    * @dev Create a dispute to be drafted in a future term\n    * @param _subject Arbitrable instance creating the dispute\n    * @param _possibleRulings Number of possible rulings allowed for the drafted jurors to vote on the dispute\n    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\n    * @return Dispute identification number\n    */\n    function createDispute(IArbitrable _subject, uint8 _possibleRulings, bytes calldata _metadata) external returns (uint256);\n\n    /**\n    * @dev Close the evidence period of a dispute\n    * @param _subject IArbitrable instance requesting to close the evidence submission period\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\n    */\n    function closeEvidencePeriod(IArbitrable _subject, uint256 _disputeId) external;\n\n    /**\n    * @dev Draft jurors for the next round of a dispute\n    * @param _disputeId Identification number of the dispute to be drafted\n    */\n    function draft(uint256 _disputeId) external;\n\n    /**\n    * @dev Appeal round of a dispute in favor of a certain ruling\n    * @param _disputeId Identification number of the dispute being appealed\n    * @param _roundId Identification number of the dispute round being appealed\n    * @param _ruling Ruling appealing a dispute round in favor of\n    */\n    function createAppeal(uint256 _disputeId, uint256 _roundId, uint8 _ruling) external;\n\n    /**\n    * @dev Confirm appeal for a round of a dispute in favor of a ruling\n    * @param _disputeId Identification number of the dispute confirming an appeal of\n    * @param _roundId Identification number of the dispute round confirming an appeal of\n    * @param _ruling Ruling being confirmed against a dispute round appeal\n    */\n    function confirmAppeal(uint256 _disputeId, uint256 _roundId, uint8 _ruling) external;\n\n    /**\n    * @dev Compute the final ruling for a dispute\n    * @param _disputeId Identification number of the dispute to compute its final ruling\n    * @return subject Arbitrable instance associated to the dispute\n    * @return finalRuling Final ruling decided for the given dispute\n    */\n    function computeRuling(uint256 _disputeId) external returns (IArbitrable subject, uint8 finalRuling);\n\n    /**\n    * @dev Settle penalties for a round of a dispute\n    * @param _disputeId Identification number of the dispute to settle penalties for\n    * @param _roundId Identification number of the dispute round to settle penalties for\n    * @param _jurorsToSettle Maximum number of jurors to be slashed in this call\n    */\n    function settlePenalties(uint256 _disputeId, uint256 _roundId, uint256 _jurorsToSettle) external;\n\n    /**\n    * @dev Claim rewards for a round of a dispute for juror\n    * @dev For regular rounds, it will only reward winning jurors\n    * @param _disputeId Identification number of the dispute to settle rewards for\n    * @param _roundId Identification number of the dispute round to settle rewards for\n    * @param _juror Address of the juror to settle their rewards\n    */\n    function settleReward(uint256 _disputeId, uint256 _roundId, address _juror) external;\n\n    /**\n    * @dev Settle appeal deposits for a round of a dispute\n    * @param _disputeId Identification number of the dispute to settle appeal deposits for\n    * @param _roundId Identification number of the dispute round to settle appeal deposits for\n    */\n    function settleAppealDeposit(uint256 _disputeId, uint256 _roundId) external;\n\n    /**\n    * @dev Tell the amount of token fees required to create a dispute\n    * @return feeToken ERC20 token used for the fees\n    * @return feeAmount Total amount of fees to be paid for a dispute at the given term\n    */\n    function getDisputeFees() external view returns (ERC20 feeToken, uint256 feeAmount);\n\n    /**\n    * @dev Tell information of a certain dispute\n    * @param _disputeId Identification number of the dispute being queried\n    * @return subject Arbitrable subject being disputed\n    * @return possibleRulings Number of possible rulings allowed for the drafted jurors to vote on the dispute\n    * @return state Current state of the dispute being queried: pre-draft, adjudicating, or ruled\n    * @return finalRuling The winning ruling in case the dispute is finished\n    * @return lastRoundId Identification number of the last round created for the dispute\n    * @return createTermId Identification number of the term when the dispute was created\n    */\n    function getDispute(uint256 _disputeId) external view\n        returns (IArbitrable subject, uint8 possibleRulings, DisputeState state, uint8 finalRuling, uint256 lastRoundId, uint64 createTermId);\n\n    /**\n    * @dev Tell information of a certain adjudication round\n    * @param _disputeId Identification number of the dispute being queried\n    * @param _roundId Identification number of the round being queried\n    * @return draftTerm Term from which the requested round can be drafted\n    * @return delayedTerms Number of terms the given round was delayed based on its requested draft term id\n    * @return jurorsNumber Number of jurors requested for the round\n    * @return selectedJurors Number of jurors already selected for the requested round\n    * @return settledPenalties Whether or not penalties have been settled for the requested round\n    * @return collectedTokens Amount of juror tokens that were collected from slashed jurors for the requested round\n    * @return coherentJurors Number of jurors that voted in favor of the final ruling in the requested round\n    * @return state Adjudication state of the requested round\n    */\n    function getRound(uint256 _disputeId, uint256 _roundId) external view\n        returns (\n            uint64 draftTerm,\n            uint64 delayedTerms,\n            uint64 jurorsNumber,\n            uint64 selectedJurors,\n            uint256 jurorFees,\n            bool settledPenalties,\n            uint256 collectedTokens,\n            uint64 coherentJurors,\n            AdjudicationState state\n        );\n\n    /**\n    * @dev Tell appeal-related information of a certain adjudication round\n    * @param _disputeId Identification number of the dispute being queried\n    * @param _roundId Identification number of the round being queried\n    * @return maker Address of the account appealing the given round\n    * @return appealedRuling Ruling confirmed by the appealer of the given round\n    * @return taker Address of the account confirming the appeal of the given round\n    * @return opposedRuling Ruling confirmed by the appeal taker of the given round\n    */\n    function getAppeal(uint256 _disputeId, uint256 _roundId) external view\n        returns (address maker, uint64 appealedRuling, address taker, uint64 opposedRuling);\n\n    /**\n    * @dev Tell information related to the next round due to an appeal of a certain round given.\n    * @param _disputeId Identification number of the dispute being queried\n    * @param _roundId Identification number of the round requesting the appeal details of\n    * @return nextRoundStartTerm Term ID from which the next round will start\n    * @return nextRoundJurorsNumber Jurors number for the next round\n    * @return newDisputeState New state for the dispute associated to the given round after the appeal\n    * @return feeToken ERC20 token used for the next round fees\n    * @return jurorFees Total amount of fees to be distributed between the winning jurors of the next round\n    * @return totalFees Total amount of fees for a regular round at the given term\n    * @return appealDeposit Amount to be deposit of fees for a regular round at the given term\n    * @return confirmAppealDeposit Total amount of fees for a regular round at the given term\n    */\n    function getNextRoundDetails(uint256 _disputeId, uint256 _roundId) external view\n        returns (\n            uint64 nextRoundStartTerm,\n            uint64 nextRoundJurorsNumber,\n            DisputeState newDisputeState,\n            ERC20 feeToken,\n            uint256 totalFees,\n            uint256 jurorFees,\n            uint256 appealDeposit,\n            uint256 confirmAppealDeposit\n        );\n\n    /**\n    * @dev Tell juror-related information of a certain adjudication round\n    * @param _disputeId Identification number of the dispute being queried\n    * @param _roundId Identification number of the round being queried\n    * @param _juror Address of the juror being queried\n    * @return weight Juror weight drafted for the requested round\n    * @return rewarded Whether or not the given juror was rewarded based on the requested round\n    */\n    function getJuror(uint256 _disputeId, uint256 _roundId, address _juror) external view returns (uint64 weight, bool rewarded);\n}\n\n// File: ../../aragon-court/contracts/subscriptions/ISubscriptions.sol\n\npragma solidity ^0.5.8;\n\n\n\ninterface ISubscriptions {\n    /**\n    * @dev Tell whether a certain subscriber has paid all the fees up to current period or not\n    * @param _subscriber Address of subscriber being checked\n    * @return True if subscriber has paid all the fees up to current period, false otherwise\n    */\n    function isUpToDate(address _subscriber) external view returns (bool);\n\n    /**\n    * @dev Tell the minimum amount of fees to pay and resulting last paid period for a given subscriber in order to be up-to-date\n    * @param _subscriber Address of the subscriber willing to pay\n    * @return feeToken ERC20 token used for the subscription fees\n    * @return amountToPay Amount of subscription fee tokens to be paid\n    * @return newLastPeriodId Identification number of the resulting last paid period\n    */\n    function getOwedFeesDetails(address _subscriber) external view returns (ERC20, uint256, uint256);\n}\n\n// File: ../../aragon-court/contracts/court/controller/Controlled.sol\n\npragma solidity ^0.5.8;\n\n\n\n\n\n\n\n\n\n\n\ncontract Controlled is IsContract, ConfigConsumer {\n    string private constant ERROR_CONTROLLER_NOT_CONTRACT = \"CTD_CONTROLLER_NOT_CONTRACT\";\n    string private constant ERROR_SENDER_NOT_CONTROLLER = \"CTD_SENDER_NOT_CONTROLLER\";\n    string private constant ERROR_SENDER_NOT_CONFIG_GOVERNOR = \"CTD_SENDER_NOT_CONFIG_GOVERNOR\";\n    string private constant ERROR_SENDER_NOT_DISPUTES_MODULE = \"CTD_SENDER_NOT_DISPUTES_MODULE\";\n\n    // Address of the controller\n    Controller internal controller;\n\n    /**\n    * @dev Ensure the msg.sender is the controller's config governor\n    */\n    modifier onlyConfigGovernor {\n        require(msg.sender == _configGovernor(), ERROR_SENDER_NOT_CONFIG_GOVERNOR);\n        _;\n    }\n\n    /**\n    * @dev Ensure the msg.sender is the controller\n    */\n    modifier onlyController() {\n        require(msg.sender == address(controller), ERROR_SENDER_NOT_CONTROLLER);\n        _;\n    }\n\n    /**\n    * @dev Ensure the msg.sender is the DisputeManager module\n    */\n    modifier onlyDisputeManager() {\n        require(msg.sender == address(_disputeManager()), ERROR_SENDER_NOT_DISPUTES_MODULE);\n        _;\n    }\n\n    /**\n    * @dev Constructor function\n    * @param _controller Address of the controller\n    */\n    constructor(Controller _controller) public {\n        require(isContract(address(_controller)), ERROR_CONTROLLER_NOT_CONTRACT);\n        controller = _controller;\n    }\n\n    /**\n    * @dev Tell the address of the controller\n    * @return Address of the controller\n    */\n    function getController() external view returns (Controller) {\n        return controller;\n    }\n\n    /**\n    * @dev Internal function to ensure the Court term is up-to-date, it will try to update it if not\n    * @return Identification number of the current Court term\n    */\n    function _ensureCurrentTerm() internal returns (uint64) {\n        return _clock().ensureCurrentTerm();\n    }\n\n    /**\n    * @dev Internal function to fetch the last ensured term ID of the Court\n    * @return Identification number of the last ensured term\n    */\n    function _getLastEnsuredTermId() internal view returns (uint64) {\n        return _clock().getLastEnsuredTermId();\n    }\n\n    /**\n    * @dev Internal function to tell the current term identification number\n    * @return Identification number of the current term\n    */\n    function _getCurrentTermId() internal view returns (uint64) {\n        return _clock().getCurrentTermId();\n    }\n\n    /**\n    * @dev Internal function to fetch the controller's config governor\n    * @return Address of the controller's governor\n    */\n    function _configGovernor() internal view returns (address) {\n        return controller.getConfigGovernor();\n    }\n\n    /**\n    * @dev Internal function to fetch the address of the DisputeManager module from the controller\n    * @return Address of the DisputeManager module\n    */\n    function _disputeManager() internal view returns (IDisputeManager) {\n        return IDisputeManager(controller.getDisputeManager());\n    }\n\n    /**\n    * @dev Internal function to fetch the address of the Treasury module implementation from the controller\n    * @return Address of the Treasury module implementation\n    */\n    function _treasury() internal view returns (ITreasury) {\n        return ITreasury(controller.getTreasury());\n    }\n\n    /**\n    * @dev Internal function to fetch the address of the Voting module implementation from the controller\n    * @return Address of the Voting module implementation\n    */\n    function _voting() internal view returns (ICRVoting) {\n        return ICRVoting(controller.getVoting());\n    }\n\n    /**\n    * @dev Internal function to fetch the address of the Voting module owner from the controller\n    * @return Address of the Voting module owner\n    */\n    function _votingOwner() internal view returns (ICRVotingOwner) {\n        return ICRVotingOwner(address(_disputeManager()));\n    }\n\n    /**\n    * @dev Internal function to fetch the address of the JurorRegistry module implementation from the controller\n    * @return Address of the JurorRegistry module implementation\n    */\n    function _jurorsRegistry() internal view returns (IJurorsRegistry) {\n        return IJurorsRegistry(controller.getJurorsRegistry());\n    }\n\n    /**\n    * @dev Internal function to fetch the address of the Subscriptions module implementation from the controller\n    * @return Address of the Subscriptions module implementation\n    */\n    function _subscriptions() internal view returns (ISubscriptions) {\n        return ISubscriptions(controller.getSubscriptions());\n    }\n\n    /**\n    * @dev Internal function to fetch the address of the Clock module from the controller\n    * @return Address of the Clock module\n    */\n    function _clock() internal view returns (IClock) {\n        return IClock(controller);\n    }\n\n    /**\n    * @dev Internal function to fetch the address of the Config module from the controller\n    * @return Address of the Config module\n    */\n    function _courtConfig() internal view returns (IConfig) {\n        return IConfig(controller);\n    }\n}\n\n// File: ../../aragon-court/contracts/court/controller/ControlledRecoverable.sol\n\npragma solidity ^0.5.8;\n\n\n\n\n\ncontract ControlledRecoverable is Controlled {\n    using SafeERC20 for ERC20;\n\n    string private constant ERROR_SENDER_NOT_FUNDS_GOVERNOR = \"CTD_SENDER_NOT_FUNDS_GOVERNOR\";\n    string private constant ERROR_INSUFFICIENT_RECOVER_FUNDS = \"CTD_INSUFFICIENT_RECOVER_FUNDS\";\n    string private constant ERROR_RECOVER_TOKEN_FUNDS_FAILED = \"CTD_RECOVER_TOKEN_FUNDS_FAILED\";\n\n    event RecoverFunds(ERC20 token, address recipient, uint256 balance);\n\n    /**\n    * @dev Ensure the msg.sender is the controller's funds governor\n    */\n    modifier onlyFundsGovernor {\n        require(msg.sender == controller.getFundsGovernor(), ERROR_SENDER_NOT_FUNDS_GOVERNOR);\n        _;\n    }\n\n    /**\n    * @dev Constructor function\n    * @param _controller Address of the controller\n    */\n    constructor(Controller _controller) Controlled(_controller) public {\n        // solium-disable-previous-line no-empty-blocks\n    }\n\n    /**\n    * @notice Transfer all `_token` tokens to `_to`\n    * @param _token ERC20 token to be recovered\n    * @param _to Address of the recipient that will be receive all the funds of the requested token\n    */\n    function recoverFunds(ERC20 _token, address _to) external onlyFundsGovernor {\n        uint256 balance = _token.balanceOf(address(this));\n        require(balance > 0, ERROR_INSUFFICIENT_RECOVER_FUNDS);\n        require(_token.safeTransfer(_to, balance), ERROR_RECOVER_TOKEN_FUNDS_FAILED);\n        emit RecoverFunds(_token, _to, balance);\n    }\n}\n\n// File: ../../aragon-court/contracts/treasury/CourtTreasury.sol\n\npragma solidity ^0.5.8;\n\n\n\n\n\n\n\n\ncontract CourtTreasury is ControlledRecoverable, ITreasury {\n    using SafeERC20 for ERC20;\n    using SafeMath for uint256;\n\n    string private constant ERROR_DEPOSIT_AMOUNT_ZERO = \"TREASURY_DEPOSIT_AMOUNT_ZERO\";\n    string private constant ERROR_WITHDRAW_FAILED = \"TREASURY_WITHDRAW_FAILED\";\n    string private constant ERROR_WITHDRAW_AMOUNT_ZERO = \"TREASURY_WITHDRAW_AMOUNT_ZERO\";\n    string private constant ERROR_WITHDRAW_INVALID_AMOUNT = \"TREASURY_WITHDRAW_INVALID_AMOUNT\";\n    string private constant ERROR_WITHDRAWS_DISALLOWED = \"TREASURY_WITHDRAWALS_DISALLOWED\";\n\n    // List of balances indexed by token and holder address\n    mapping (address => mapping (address => uint256)) internal balances;\n\n    event Assign(ERC20 indexed token, address indexed from, address indexed to, uint256 amount);\n    event Withdraw(ERC20 indexed token, address indexed from, address indexed to, uint256 amount);\n\n    /**\n    * @dev Constructor function\n    * @param _controller Address of the controller\n    */\n    constructor(Controller _controller) ControlledRecoverable(_controller) public {\n        // solium-disable-previous-line no-empty-blocks\n        // No need to explicitly call `Controlled` constructor since `ControlledRecoverable` is already doing it\n    }\n\n    /**\n    * @notice Assign `@tokenAmount(_token, _amount)` to `_to`\n    * @param _token ERC20 token to be assigned\n    * @param _to Address of the recipient that will be assigned the tokens to\n    * @param _amount Amount of tokens to be assigned to the recipient\n    */\n    function assign(ERC20 _token, address _to, uint256 _amount) external onlyDisputeManager {\n        require(_amount > 0, ERROR_DEPOSIT_AMOUNT_ZERO);\n\n        address tokenAddress = address(_token);\n        balances[tokenAddress][_to] = balances[tokenAddress][_to].add(_amount);\n        emit Assign(_token, msg.sender, _to, _amount);\n    }\n\n    /**\n    * @notice Withdraw `@tokenAmount(_token, _amount)` from sender to `_to`\n    * @param _token ERC20 token to be withdrawn\n    * @param _to Address of the recipient that will receive the tokens\n    * @param _amount Amount of tokens to be withdrawn from the sender\n    */\n    function withdraw(ERC20 _token, address _to, uint256 _amount) external {\n        _withdraw(_token, msg.sender, _to, _amount);\n    }\n\n    /**\n    * @notice Withdraw all the tokens from `_to` to themself\n    * @param _token ERC20 token to be withdrawn\n    * @param _to Address of the recipient that will receive their tokens\n    */\n    function withdrawAll(ERC20 _token, address _to) external {\n        IConfig config = _courtConfig();\n        require(config.areWithdrawalsAllowedFor(_to), ERROR_WITHDRAWS_DISALLOWED);\n\n        uint256 amount = _balanceOf(_token, _to);\n        _withdraw(_token, _to, _to, amount);\n    }\n\n    /**\n    * @dev Tell the token balance of a certain holder\n    * @param _token ERC20 token balance being queried\n    * @param _holder Address of the holder querying the balance of\n    * @return Amount of tokens the holder owns\n    */\n    function balanceOf(ERC20 _token, address _holder) external view returns (uint256) {\n        return _balanceOf(_token, _holder);\n    }\n\n    /**\n    * @dev Internal function to withdraw tokens from an account\n    * @param _token ERC20 token to be withdrawn\n    * @param _from Address where the tokens will be removed from\n    * @param _to Address of the recipient that will receive the corresponding tokens\n    * @param _amount Amount of tokens to be withdrawn from the sender\n    */\n    function _withdraw(ERC20 _token, address _from, address _to, uint256 _amount) internal {\n        require(_amount > 0, ERROR_WITHDRAW_AMOUNT_ZERO);\n        uint256 balance = _balanceOf(_token, _from);\n        require(balance >= _amount, ERROR_WITHDRAW_INVALID_AMOUNT);\n\n        address tokenAddress = address(_token);\n        // No need for SafeMath: checked above\n        balances[tokenAddress][_from] = balance - _amount;\n        emit Withdraw(_token, _from, _to, _amount);\n\n        require(_token.safeTransfer(_to, _amount), ERROR_WITHDRAW_FAILED);\n    }\n\n    /**\n    * @dev Internal function to tell the token balance of a certain holder\n    * @param _token ERC20 token balance being queried\n    * @param _holder Address of the holder querying the balance of\n    * @return Amount of tokens the holder owns\n    */\n    function _balanceOf(ERC20 _token, address _holder) internal view returns (uint256) {\n        return balances[address(_token)][_holder];\n    }\n}\n","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"recoverFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getController\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"assign\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_controller\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Assign\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"RecoverFunds\",\"type\":\"event\"}]","ContractName":"CourtTreasury","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"5000","ConstructorArguments":"000000000000000000000000ee4650cbe7a2b23701d416f58b41d8b76b617797","Library":"","LicenseType":"","SwarmSource":"bzzr://2638199213bafcd5790f60605d9e97d18f3dda1f72f0cd1e1bdc89f5356ae051"}]}