{"status":"1","message":"OK","result":[{"SourceCode":"{\"BasicToken.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\nimport \\\"./ERC20Basic.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\n/**\\n * @title Basic token\\n * @dev Basic version of StandardToken, with no allowances.\\n */\\ncontract BasicToken is ERC20Basic {\\n  using SafeMath for uint256;\\n\\n  mapping(address =\\u003e uint256) balances; // Storage slot 0\\n\\n  uint256 totalSupply_; // Storage slot 1\\n\\n  /**\\n  * @dev Total number of tokens in existence\\n  */\\n  function totalSupply() public view returns (uint256) {\\n    return totalSupply_;\\n  }\\n\\n  /**\\n  * @dev Transfer token for a specified address\\n  * @param _to The address to transfer to.\\n  * @param _value The amount to be transferred.\\n  */\\n  function transfer(address _to, uint256 _value) public returns (bool) {\\n    require(_to != address(0));\\n    require(_value \\u003c= balances[msg.sender]);\\n\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\n    balances[_to] = balances[_to].add(_value);\\n    emit Transfer(msg.sender, _to, _value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param _owner The address to query the the balance of.\\n  * @return An uint256 representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address _owner) public view returns (uint256) {\\n    return balances[_owner];\\n  }\\n\\n}\\n\"},\"BasicTokenMintable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\nimport \\\"./BasicToken.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\n/**\\n * @title Basic token\\n * @dev Basic version of StandardToken, with no allowances.\\n */\\ncontract BasicTokenMintable is BasicToken {\\n  using SafeMath for uint256;\\n\\n  function mint(address account, uint256 amount) internal {\\n    require(account != address(0));\\n    totalSupply_ = totalSupply_.add(amount);\\n    balances[account] = balances[account].add(amount);\\n    emit Transfer(address(0), account, amount);\\n  }\\n}\\n\"},\"CTokenInterface.sol\":{\"content\":\"pragma solidity ^0.4.25;\\n\\n\\ninterface CERC20 {\\n    function mint(uint mintAmount) returns (uint);\\n    function redeem(uint redeemTokens) returns (uint);\\n    function supplyRatePerBlock() returns (uint);\\n    function exchangeRateCurrent() returns (uint);\\n    function balanceOf(address _owner) public view returns (uint balance);\\n    function balanceOfUnderlying(address account) returns (uint);\\n}\\n\\ninterface CEther {\\n    function mint() payable;\\n    function redeem(uint redeemTokens) returns (uint);\\n    function supplyRatePerBlock() returns (uint);\\n    function balanceOf(address _owner) public view returns (uint balance);\\n    function balanceOfUnderlying(address account) returns (uint);\\n}\"},\"cTokenStub.sol\":{\"content\":\"pragma solidity ^0.4.24;\\nimport \\\"./SafeMath.sol\\\";\\n\\ninterface ERC20 {\\n    function balanceOf(address who) external view returns (uint256);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function approve(address spender, uint256 value) external returns (bool);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\\ncontract cTokenStub {\\n    using SafeMath for uint256;\\n\\n    uint256 public exchangeRateCurrent = 210074678802943;\\n    ERC20 public theToken;\\n    mapping(address =\\u003e uint256) public balanceOf;\\n\\n    constructor(address _theToken) {\\n        theToken = ERC20(_theToken);\\n    }\\n\\n    function balanceOfUnderlying(address owner) public returns(uint256) {\\n        return balanceOf[owner].mul(exchangeRateCurrent).div(10**18);\\n    }\\n\\n    function mint(uint256 theTokenAmount) public payable returns(uint256) {\\n        require(theToken.transferFrom(msg.sender, address(this), theTokenAmount));\\n        balanceOf[msg.sender] = theTokenAmount.mul(10**18).div(exchangeRateCurrent);\\n        return 0;\\n    }\\n\\n    function redeem(uint256 cTokenAmount) public returns(uint256) {\\n        uint256 theTokenAmount = cTokenAmount.mul(exchangeRateCurrent).div(10**18);\\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(cTokenAmount);\\n        require(theToken.transfer(msg.sender, theTokenAmount));\\n        return 0;\\n    }\\n}\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./ERC20Basic.sol\\\";\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ncontract ERC20 is ERC20Basic {\\n  function allowance(address owner, address spender)\\n    public view returns (uint256);\\n\\n  function transferFrom(address from, address to, uint256 value)\\n    public returns (bool);\\n\\n  function approve(address spender, uint256 value) public returns (bool);\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\"},\"ERC20Basic.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title ERC20Basic\\n * @dev Simpler version of ERC20 interface\\n * See https://github.com/ethereum/EIPs/issues/179\\n */\\ncontract ERC20Basic {\\n  function totalSupply() public view returns (uint256);\\n  function balanceOf(address who) public view returns (uint256);\\n  function transfer(address to, uint256 value) public returns (bool);\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\"},\"ETFUSDCAndCompound.sol\":{\"content\":\"pragma solidity ^0.4.24;\\nimport \\\"./BasicTokenMintable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./SimpleOracleAccruedRatioUSDC.sol\\\";\\nimport \\\"./CTokenInterface.sol\\\";\\n\\ninterface ERC20 {\\n    function balanceOf(address who) external view returns (uint256);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function approve(address spender, uint256 value) external returns (bool);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\\ncontract ETFUSDCAndCompound is BasicTokenMintable{\\n    using SafeMath for uint256;\\n\\n    uint256 public baseRatio = 1000000;\\n    string public constant symbol = \\\"STUSDC\\\";\\n    uint8 public decimals = 6;\\n\\n    // USDC token contract\\n    ERC20 public StableToken;\\n    SimpleOracleAccruedRatioUSDC public oracle;\\n    // Defi contract\\n    CERC20 public cToken;\\n\\n    // Roles\\n    address public bincentiveHot; // i.e., Platform Owner\\n    address public bincentiveCold;\\n    address[] public investors; // implicitly first investor is the lead investor\\n    address public trader;\\n\\n    struct WithdrawRequest {\\n        address investor;\\n        uint256 tokenAmount;\\n    }\\n    uint256 public numRequestedWithdraw;\\n    uint256 public numProcessedWithdrawRequest;\\n    mapping(uint256 =\\u003e WithdrawRequest) public withdrawRequest;\\n    uint256 public numAUMDistributedInvestors; // i.e., number of investors that already received AUM\\n\\n    // Contract(Fund) Status\\n    // 0: not initialized\\n    // 1: initialized\\n    // 2: not enough fund came in in time\\n    // 3: fundStarted\\n    // 4: running\\n    // 5: stoppped\\n    // 6: closed\\n    uint256 public fundStatus;\\n\\n    // Money\\n    uint256 public currentInvestedAmount;\\n    uint256 public totalMintedTokenAmount;\\n\\n    // Fund Parameters\\n    uint256 public investPaymentDueTime;\\n    uint256 public percentageOffchainFund;\\n\\n    // Events\\n    event Deposit(address indexed investor, uint256 investAmount, uint256 mintedAmount);\\n    event StartFund(uint256 num_investors, uint256 totalInvestedAmount, uint256 totalMintedTokenAmount);\\n    event Withdraw(address indexed investor, uint256 tokenAmount, uint256 USDCAmount);\\n    event MidwayQuit(address indexed investor, uint256 tokenAmount, uint256 USDCAmount);\\n    event ReturnAUM(uint256 StableTokenAmount);\\n    event DistributeAUM(address indexed to, uint256 tokenAmount, uint256 StableTokenAmount);\\n    // Defi Events\\n    event MintcUSDC(uint USDCAmount);\\n    event RedeemcUSDC(uint RedeemcUSDCAmount);\\n\\n    // Modifiers\\n    modifier initialized() {\\n        require(fundStatus == 1);\\n        _;\\n    }\\n\\n    // modifier fundStarted() {\\n    //     require(fundStatus == 3);\\n    //     _;\\n    // }\\n\\n    modifier running() {\\n        require(fundStatus == 4);\\n        _;\\n    }\\n\\n    modifier stopped() {\\n        require(fundStatus == 5);\\n        _;\\n    }\\n\\n    modifier afterStartedBeforeStopped() {\\n        require((fundStatus \\u003e= 3) \\u0026\\u0026 (fundStatus \\u003c 5));\\n        _;\\n    }\\n\\n    modifier afterStartedBeforeClosed() {\\n        require((fundStatus \\u003e= 3) \\u0026\\u0026 (fundStatus \\u003c 6));\\n        _;\\n    }\\n\\n    modifier closedOrAborted() {\\n        require((fundStatus == 6) || (fundStatus == 2));\\n        _;\\n    }\\n\\n    modifier isBincentive() {\\n        require(\\n            (msg.sender == bincentiveHot) || (msg.sender == bincentiveCold)\\n        );\\n        _;\\n    }\\n\\n    modifier isBincentiveCold() {\\n        require(msg.sender == bincentiveCold);\\n        _;\\n    }\\n\\n    modifier isInvestor() {\\n        // bincentive is not investor\\n        require(msg.sender != bincentiveHot);\\n        require(msg.sender != bincentiveCold);\\n        require(balances[msg.sender] \\u003e 0);\\n        _;\\n    }\\n\\n    // Getter Functions\\n    function getBalanceValue(address investor) public view returns(uint256) {\\n        uint256 accruedRatioUSDC = oracle.query();\\n        return balances[investor].mul(accruedRatioUSDC).div(baseRatio);\\n    }\\n\\n    // Defi Functions\\n    function querycUSDCAmount() internal returns(uint256) {\\n        return cToken.balanceOf(address(this));\\n    }\\n\\n    function querycExgRate() internal returns(uint256) {\\n        return cToken.exchangeRateCurrent();\\n    }\\n\\n    function mintcUSDC(uint USDCAmount) public isBincentive {\\n\\n        StableToken.approve(address(cToken), USDCAmount); // approve the transfer\\n        assert(cToken.mint(USDCAmount) == 0);\\n\\n        emit MintcUSDC(USDCAmount);\\n    }\\n\\n    function redeemcUSDC(uint RedeemcUSDCAmount) public isBincentive {\\n\\n        require(cToken.redeem(RedeemcUSDCAmount) == 0, \\\"something went wrong\\\");\\n\\n        emit RedeemcUSDC(RedeemcUSDCAmount);\\n    }\\n\\n\\n    // Investor Deposit\\n    function deposit(address investor, uint256 depositUSDCAmount) initialized public {\\n        require(now \\u003c investPaymentDueTime);\\n        require((investor != bincentiveHot) \\u0026\\u0026 (investor != bincentiveCold));\\n\\n        // Transfer Stable Token to this contract\\n        // If deposit from bincentive, transferFrom `bincentiveCold`\\n        // Else transferFrom msg.sender\\n        if((msg.sender == bincentiveHot) || (msg.sender == bincentiveCold)) {\\n            require(StableToken.transferFrom(bincentiveCold, address(this), depositUSDCAmount));\\n        }\\n        else{\\n            require(StableToken.transferFrom(msg.sender, address(this), depositUSDCAmount));\\n        }\\n\\n        if(balances[investor] == 0) {\\n            investors.push(investor);\\n        }\\n        currentInvestedAmount = currentInvestedAmount.add(depositUSDCAmount);\\n\\n        // Query Oracle for current BTC / Stable Token pair\\n        uint256 accruedRatioUSDC = oracle.query();\\n        // Mint and distribute tokens to investors\\n        uint256 mintedTokenAmount;\\n        mintedTokenAmount = depositUSDCAmount.mul(baseRatio).div(accruedRatioUSDC);\\n        mint(investor, mintedTokenAmount);\\n        totalMintedTokenAmount = totalMintedTokenAmount.add(mintedTokenAmount);\\n\\n        emit Deposit(investor, depositUSDCAmount, mintedTokenAmount);\\n    }\\n\\n    // Start Investing\\n    function start() initialized isBincentive public {\\n        // Send 50% USDC offline\\n        uint256 amountSentOffline = currentInvestedAmount.mul(percentageOffchainFund).div(100);\\n        require(StableToken.transfer(trader, amountSentOffline));\\n\\n        // Start the contract\\n        fundStatus = 4;\\n        emit StartFund(investors.length, currentInvestedAmount, totalMintedTokenAmount);\\n    }\\n\\n    // Investor request to withdraw\\n    function requestWithdraw(uint256 tokenAmount) afterStartedBeforeStopped isInvestor public {\\n        require(tokenAmount \\u003e 0);\\n        require(balances[msg.sender] \\u003e= tokenAmount);\\n\\n        balances[msg.sender] = balances[msg.sender].sub(tokenAmount);\\n        withdrawRequest[numRequestedWithdraw] = WithdrawRequest(\\n            msg.sender,\\n            tokenAmount\\n        );\\n        numRequestedWithdraw = numRequestedWithdraw.add(1);\\n    }\\n\\n    function processWithdraw() afterStartedBeforeClosed isBincentive public {\\n        if(numRequestedWithdraw == numProcessedWithdrawRequest) return;\\n        // Query Oracle for current BTC / Stable Token pair\\n        uint256 accruedRatioUSDC = oracle.query();\\n        address investor;\\n        uint256 investor_amount;\\n        uint256 amountUSDCForInvestor;\\n        for(uint i = numProcessedWithdrawRequest; i \\u003c numRequestedWithdraw; i++) {\\n            investor = withdrawRequest[i].investor;\\n            investor_amount = withdrawRequest[i].tokenAmount;\\n            delete withdrawRequest[i];\\n            amountUSDCForInvestor = investor_amount.mul(accruedRatioUSDC).div(baseRatio);\\n            require(StableToken.transfer(investor, amountUSDCForInvestor));\\n            totalMintedTokenAmount = totalMintedTokenAmount.sub(investor_amount);\\n            numProcessedWithdrawRequest = numProcessedWithdrawRequest.add(1);\\n            emit Withdraw(investor, investor_amount, amountUSDCForInvestor);\\n        }\\n\\n        // Close the contract if every investor has withdrawn\\n        if(totalMintedTokenAmount == 0) {\\n            fundStatus = 6;\\n        }\\n    }\\n\\n    // Return AUM\\n    function returnAUM(uint256 stableTokenAmount) running isBincentiveCold public {\\n        // Option 1: contract transfer AUM directly from trader\\n        require(StableToken.transferFrom(trader, address(this), stableTokenAmount));\\n        // Option 2: trader transfer AUM to bincentiveCold and the contract transfer AUM from bincentiveCold\\n        // require(StableToken.transferFrom(bincentiveCold, address(this), stableTokenAmount));\\n\\n        emit ReturnAUM(stableTokenAmount);\\n\\n        fundStatus = 5;\\n    }\\n\\n    // Distribute AUM\\n    function distributeAUM(uint256 numInvestorsToDistribute) stopped isBincentive public {\\n        require(numAUMDistributedInvestors.add(numInvestorsToDistribute) \\u003c= investors.length, \\\"Distributing to more than total number of investors\\\");\\n\\n        // Query Oracle for current BTC / Stable Token pair\\n        uint256 accruedRatioUSDC = oracle.query();\\n\\n        uint256 stableTokenDistributeAmount;\\n        address investor;\\n        uint256 investor_amount;\\n        // Distribute Stable Token to investors\\n        for(uint i = numAUMDistributedInvestors; i \\u003c (numAUMDistributedInvestors.add(numInvestorsToDistribute)); i++) {\\n            investor = investors[i];\\n            investor_amount = balances[investor];\\n            if(investor_amount == 0) continue;\\n            balances[investor] = 0;\\n            emit Transfer(investor, address(0), investor_amount);\\n\\n            stableTokenDistributeAmount = investor_amount.mul(accruedRatioUSDC).div(baseRatio);\\n            require(StableToken.transfer(investor, stableTokenDistributeAmount));\\n\\n            emit DistributeAUM(investor, investor_amount, stableTokenDistributeAmount);\\n        }\\n\\n        numAUMDistributedInvestors = numAUMDistributedInvestors.add(numInvestorsToDistribute);\\n        // If all investors have received AUM, then close the fund.\\n        if(numAUMDistributedInvestors \\u003e= investors.length) {\\n            currentInvestedAmount = 0;\\n            fundStatus = 6;\\n        }\\n    }\\n\\n    function claimWronglyTransferredFund() closedOrAborted isBincentive public {\\n        // withdraw leftover funds from Defi\\n        uint256 totalcUSDCAmount;\\n        totalcUSDCAmount = querycUSDCAmount();\\n        redeemcUSDC(totalcUSDCAmount);\\n\\n        uint256 leftOverAmount = StableToken.balanceOf(address(this));\\n        if(leftOverAmount \\u003e 0) {\\n            require(StableToken.transfer(bincentiveCold, leftOverAmount));\\n        }\\n    }\\n\\n\\n    // Constructor\\n    constructor(\\n        address _oracle,\\n        address _StableToken,\\n        address _cToken,\\n        address _bincentiveHot,\\n        address _bincentiveCold,\\n        address _trader,\\n        uint256 _investPaymentPeriod,\\n        uint256 _percentageOffchainFund) public {\\n\\n        oracle = SimpleOracleAccruedRatioUSDC(_oracle);\\n        bincentiveHot = _bincentiveHot;\\n        bincentiveCold = _bincentiveCold;\\n        StableToken = ERC20(_StableToken);\\n        cToken = CERC20(_cToken);\\n\\n        trader = _trader;\\n\\n        // Set parameters\\n        investPaymentDueTime = now.add(_investPaymentPeriod);\\n        percentageOffchainFund = _percentageOffchainFund;\\n\\n        // Initialized the contract\\n        fundStatus = 1;\\n    }\\n}\\n\"},\"SafeERC20.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./ERC20Basic.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\\n    require(token.transfer(to, value));\\n  }\\n\\n  function safeTransferFrom(\\n    ERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n    internal\\n  {\\n    require(token.transferFrom(from, to, value));\\n  }\\n\\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\\n    require(token.approve(spender, value));\\n  }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    // Gas optimization: this is cheaper than asserting \\u0027a\\u0027 not being zero, but the\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    // uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return a / b;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n}\\n\"},\"SimpleOracleAccruedRatioUSDC.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\ncontract SimpleOracleAccruedRatioUSDC {\\n    address public owner;\\n    uint256 public accruedRatioUSDC;\\n\\n    // event QueryEvent(bytes32 id, string query);\\n\\n    constructor(uint256 _accruedRatioUSDC) {\\n        owner = msg.sender;\\n        accruedRatioUSDC = _accruedRatioUSDC;\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    function set(uint256 _accruedRatioUSDC) onlyOwner {\\n        accruedRatioUSDC = _accruedRatioUSDC;\\n    }\\n\\n    function query() returns(uint256) {\\n        // QueryEvent(msg.sender, block.number);\\n        return accruedRatioUSDC;\\n    }\\n}\\n\"},\"StandardToken.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./BasicToken.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\n\\n/**\\n* @title Standard ERC20 token\\n*\\n* @dev Implementation of the basic standard token.\\n* https://github.com/ethereum/EIPs/issues/20\\n* Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n*/\\ncontract StandardToken is ERC20, BasicToken {\\n    using SafeMath for uint256;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) internal allowed; // Storage slot 2\\n\\n    /**\\n    * @dev Transfer tokens from one address to another\\n    * @param _from address The address which you want to send tokens from\\n    * @param _to address The address which you want to transfer to\\n    * @param _value uint256 the amount of tokens to be transferred\\n    */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        public\\n        returns (bool)\\n    {\\n        require(_to != address(0));\\n        require(_value \\u003c= balances[_from]);\\n        require(_value \\u003c= allowed[_from][msg.sender]);\\n\\n        balances[_from] = balances[_from].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n    * race condition is to first reduce the spender\\u0027s allowance to 0 and set the desired value afterwards:\\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    * @param _spender The address which will spend the funds.\\n    * @param _value The amount of tokens to be spent.\\n    */\\n    function approve(address _spender, uint256 _value) public returns (bool) {\\n        allowed[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n    * @param _owner address The address which owns the funds.\\n    * @param _spender address The address which will spend the funds.\\n    * @return A uint256 specifying the amount of tokens still available for the spender.\\n    */\\n    function allowance(\\n        address _owner,\\n        address _spender\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return allowed[_owner][_spender];\\n    }\\n\\n    /**\\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\\n    * approve should be called when allowed[_spender] == 0. To increment\\n    * allowed value is better to use this function to avoid 2 calls (and wait until\\n    * the first transaction is mined)\\n    * From MonolithDAO Token.sol\\n    * @param _spender The address which will spend the funds.\\n    * @param _addedValue The amount of tokens to increase the allowance by.\\n    */\\n    function increaseApproval(\\n        address _spender,\\n        uint256 _addedValue\\n    )\\n        public\\n        returns (bool)\\n    {\\n        allowed[msg.sender][_spender] = (\\n        allowed[msg.sender][_spender].add(_addedValue));\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n    * approve should be called when allowed[_spender] == 0. To decrement\\n    * allowed value is better to use this function to avoid 2 calls (and wait until\\n    * the first transaction is mined)\\n    * From MonolithDAO Token.sol\\n    * @param _spender The address which will spend the funds.\\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\\n    */\\n    function decreaseApproval(\\n        address _spender,\\n        uint256 _subtractedValue\\n    )\\n        public\\n        returns (bool)\\n    {\\n        uint256 oldValue = allowed[msg.sender][_spender];\\n        if (_subtractedValue \\u003e oldValue) {\\n        allowed[msg.sender][_spender] = 0;\\n        } else {\\n        allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n        }\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n}\\n\"},\"USDTToken.sol\":{\"content\":\"pragma solidity ^0.4.24;\\nimport \\\"./StandardToken.sol\\\";\\n\\ncontract USDTToken is StandardToken {\\n    using SafeMath for uint256;\\n\\n    string public name = \\\"FAKE USDT\\\";\\n    string public symbol = \\\"USDT\\\";\\n    uint8 public decimals = 18;\\n\\n    constructor(address _owner, uint256 _totalSupply) public{\\n      totalSupply_ = _totalSupply;\\n      balances[_owner] = _totalSupply;\\n      emit Transfer(address(0), _owner, _totalSupply);\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"processWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bincentiveHot\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trader\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percentageOffchainFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"RedeemcUSDCAmount\",\"type\":\"uint256\"}],\"name\":\"redeemcUSDC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"USDCAmount\",\"type\":\"uint256\"}],\"name\":\"mintcUSDC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"depositUSDCAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numProcessedWithdrawRequest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"StableToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"getBalanceValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalMintedTokenAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"requestWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawRequest\",\"outputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"numInvestorsToDistribute\",\"type\":\"uint256\"}],\"name\":\"distributeAUM\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investPaymentDueTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"stableTokenAmount\",\"type\":\"uint256\"}],\"name\":\"returnAUM\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numRequestedWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimWronglyTransferredFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bincentiveCold\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numAUMDistributedInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentInvestedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_oracle\",\"type\":\"address\"},{\"name\":\"_StableToken\",\"type\":\"address\"},{\"name\":\"_cToken\",\"type\":\"address\"},{\"name\":\"_bincentiveHot\",\"type\":\"address\"},{\"name\":\"_bincentiveCold\",\"type\":\"address\"},{\"name\":\"_trader\",\"type\":\"address\"},{\"name\":\"_investPaymentPeriod\",\"type\":\"uint256\"},{\"name\":\"_percentageOffchainFund\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"investAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mintedAmount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"num_investors\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalInvestedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalMintedTokenAmount\",\"type\":\"uint256\"}],\"name\":\"StartFund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"USDCAmount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"USDCAmount\",\"type\":\"uint256\"}],\"name\":\"MidwayQuit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"StableTokenAmount\",\"type\":\"uint256\"}],\"name\":\"ReturnAUM\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"StableTokenAmount\",\"type\":\"uint256\"}],\"name\":\"DistributeAUM\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"USDCAmount\",\"type\":\"uint256\"}],\"name\":\"MintcUSDC\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"RedeemcUSDCAmount\",\"type\":\"uint256\"}],\"name\":\"RedeemcUSDC\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"ETFUSDCAndCompound","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000039aa39c021dfbae8fac545936693ac917d5e7563000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000039aa39c021dfbae8fac545936693ac917d5e7563000000000000000000000000bf7ddeb00de22d24795c48367e89af1d2b5a70ff000000000000000000000000803f267276f708e4166b403a0808a4e84dcec217000000000000000000000000803f267276f708e4166b403a0808a4e84dcec21700000000000000000000000000000000000000000000000000000000000f42400000000000000000000000000000000000000000000000000000000000000028","Library":"","LicenseType":"None","SwarmSource":"bzzr://baa51fa31f4112d8d43dec378578785289b5d65a349edc7181fd377d1e6a86f9"}]}