{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ninterface TokenInterface {\r\n    function decimals() external view returns (uint);\r\n    function allowance(address, address) external view returns (uint);\r\n    function balanceOf(address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n    function deposit() external payable;\r\n    function withdraw(uint) external;\r\n}\r\n\r\ncontract ETHUSD {\r\n    function read() external view returns (bytes32);\r\n}\r\n\r\ncontract BetEthPrice {\r\n    using SafeMath for uint256;\r\n\r\n    struct Bet {\r\n        uint256 betCoef;\r\n        uint256 amountUsd;\r\n    }\r\n\r\n    mapping(address => Bet) public betsHighPrice;\r\n    mapping(address => Bet) public betsLowPrice;\r\n\r\n    bool public isExistsBetsHighPrice;\r\n    bool public isExistsBetsLowPrice;\r\n\r\n    ETHUSD public oracleUsd;\r\n    TokenInterface public usdToken;\r\n\r\n    uint256 public targetPrice;\r\n    uint256 public endTime;\r\n\r\n    bool public isFinalized;\r\n    bool public isCanceled;\r\n\r\n    bool public isHighPriceWin;\r\n\r\n    uint256 public totalHighPriceCoef;\r\n    uint256 public totalLowPriceCoef;\r\n\r\n    uint256 public finalBalance;\r\n\r\n    // TODO: params\r\n    constructor() public {\r\n        oracleUsd = ETHUSD(0x729D19f657BD0614b4985Cf1D82531c67569197B);  // MainNet Medianizer MakerDao (pip): 0x729D19f657BD0614b4985Cf1D82531c67569197B\r\n        usdToken = TokenInterface(0xdAC17F958D2ee523a2206206994597C13D831ec7);  // MainNet USDT: 0xdAC17F958D2ee523a2206206994597C13D831ec7\r\n\r\n        targetPrice = 70 * 1e18;  // equals 80.000 eth (1e18) – price should multiple of 10\r\n        endTime = 1588291200;  // 01.05.2020 @ 12:00am (UTC)\r\n    }\r\n\r\n\r\n    function betOnHighPrice(uint256 amount) public {\r\n        _bet(msg.sender, amount, true);\r\n    }\r\n\r\n    function betOnHighPrice(address beneficiary, uint256 amount) public {\r\n        _bet(beneficiary, amount, true);\r\n    }\r\n\r\n\r\n    function betOnLowPrice(uint256 amount) public {\r\n        _bet(msg.sender, amount, false);\r\n    }\r\n\r\n    function betOnLowPrice(address beneficiary, uint256 amount) public {\r\n        _bet(beneficiary, amount, false);\r\n    }\r\n\r\n    // finalize Betting (time is over or price is lower than targetPrice)\r\n    function finalize() public {\r\n        require(!isFinalized, \"Have already finilized\");\r\n\r\n        bool isLowWin = (getCurPriceUsd() <= targetPrice);\r\n        bool isHighWin = (!isLowWin && (now >= endTime));\r\n        require(isLowWin || isHighWin, \"Betting is active\");\r\n\r\n        // set win bets\r\n        isHighPriceWin = isHighWin;\r\n\r\n        // if no winners – cancel betting\r\n        if ((isHighWin && !isExistsBetsHighPrice)\r\n         || (!isHighWin && !isExistsBetsLowPrice)) {\r\n            isCanceled = true;\r\n            return;\r\n        }\r\n\r\n        finalBalance = usdToken.balanceOf(address(this));\r\n        isFinalized = true;\r\n    }\r\n\r\n    function withdrawPrize() public  {\r\n        require(isFinalized, \"Betting is active or cancel\");\r\n\r\n        uint256 amount = 0;\r\n        if (isHighPriceWin) {\r\n            amount = finalBalance.mul(betsHighPrice[msg.sender].betCoef).div(totalHighPriceCoef);\r\n\r\n            // set user's betCoef state as 0\r\n            betsHighPrice[msg.sender].betCoef = 0;\r\n        } else {\r\n            amount = finalBalance.mul(betsLowPrice[msg.sender].betCoef).div(totalLowPriceCoef);\r\n\r\n            // set user's betCoef state as 0\r\n            betsLowPrice[msg.sender].betCoef = 0;\r\n        }\r\n\r\n        // transfer prize to user\r\n        usdToken.transfer(msg.sender, amount);\r\n    }\r\n\r\n    function withdrawCanceled() public {\r\n        require(isCanceled, \"Betting is not canceled\");\r\n\r\n        // transfer user's bet to user\r\n        usdToken.transfer(msg.sender, betsLowPrice[msg.sender].amountUsd.add(betsHighPrice[msg.sender].amountUsd));\r\n    }\r\n\r\n\r\n    // **VIEW functions**\r\n\r\n    // function getUsdtBalance() public view returns(uint256 usdtBalance) {\r\n    //     usdtBalance = usdToken.balanceOf(address(this));\r\n    // }\r\n\r\n    function getCurPriceUsd() public view returns(uint256) {\r\n        return uint256(oracleUsd.read());  // USD price call to MakerDao Oracles – Medianizer contract\r\n    }\r\n\r\n    function getTimeLeft() public view returns(uint256) {\r\n        uint256 curEndTime = endTime;\r\n        if (curEndTime > now) {\r\n            return curEndTime - now;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n\r\n    // **INTERNAL functions**\r\n\r\n    function _bet(address beneficiary, uint256 amount, bool isHighPrice) internal {\r\n        require(now < endTime, \"Betting time is over\");\r\n        require(amount > 0, \"USD should be more than 0\");\r\n\r\n        // transfer USD from msg.sender to this contract\r\n        usdToken.transferFrom(msg.sender, address(this), amount);\r\n\r\n        uint256 priceUsd = getCurPriceUsd();\r\n        uint256 timeLeft = getTimeLeft();\r\n        uint256 curBetCoef = 0;\r\n\r\n        if (isHighPrice) {\r\n            curBetCoef = amount.mul(timeLeft).mul(1e21).div(priceUsd);  // amount * timeLeft / priceUsd\r\n\r\n            // set states\r\n            betsHighPrice[beneficiary].betCoef = betsHighPrice[beneficiary].betCoef.add(curBetCoef);\r\n            totalHighPriceCoef = totalHighPriceCoef.add(curBetCoef);\r\n\r\n            betsHighPrice[beneficiary].amountUsd = betsHighPrice[beneficiary].amountUsd.add(amount);\r\n        } else {\r\n            curBetCoef = amount.mul(timeLeft).mul(priceUsd).div(1e18);  // amount * timeLeft * priceUsd\r\n\r\n            // set states\r\n            betsLowPrice[beneficiary].betCoef = betsLowPrice[beneficiary].betCoef.add(curBetCoef);\r\n            totalLowPriceCoef = totalLowPriceCoef.add(curBetCoef);\r\n\r\n            betsLowPrice[beneficiary].amountUsd = betsLowPrice[beneficiary].amountUsd.add(amount);\r\n        }\r\n\r\n        // if no betters\r\n        if (!isExistsBetsHighPrice && isHighPrice) {\r\n            isExistsBetsHighPrice = true;\r\n        } else if (!isExistsBetsLowPrice && !isHighPrice) {\r\n            isExistsBetsLowPrice = true;\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"betOnHighPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"betOnHighPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"betOnLowPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"betOnLowPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"betsHighPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"betCoef\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUsd\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"betsLowPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"betCoef\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUsd\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurPriceUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isCanceled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isExistsBetsHighPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isExistsBetsLowPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isHighPriceWin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracleUsd\",\"outputs\":[{\"internalType\":\"contract ETHUSD\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"targetPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalHighPriceCoef\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalLowPriceCoef\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usdToken\",\"outputs\":[{\"internalType\":\"contract TokenInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawCanceled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPrize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BetEthPrice","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://c6a9de3da7dfea2d01ff5680caf90b6a2fbd1f2ddeee5e7267cb2c5ac929d93c"}]}