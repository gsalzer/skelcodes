{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.10 <0.6.0;\npragma experimental ABIEncoderV2;\n\n\ncontract Proxiable {\n    // Code position in storage is keccak256(\"PROXIABLE\") = \"0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7\"\n\n    function updateCodeAddress(address newAddress) internal {\n        require(\n            bytes32(\n                    0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7\n                ) ==\n                Proxiable(newAddress).proxiableUUID(),\n            \"Not compatible\"\n        );\n        assembly {\n            // solium-disable-line\n            sstore(\n                0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7,\n                newAddress\n            )\n        }\n    }\n    function proxiableUUID() public pure returns (bytes32) {\n        return\n            0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7;\n    }\n}\n\ncontract RTokenStructs {\n\n    /**\n     * @notice Global stats\n     */\n    struct GlobalStats {\n        /// @notice Total redeemable tokens supply\n        uint256 totalSupply;\n        /// @notice Total saving assets in redeemable amount\n        uint256 totalSavingsAmount;\n    }\n\n    /**\n     * @notice Account stats stored\n     */\n    struct AccountStatsView {\n        /// @notice Current hat ID\n        uint256 hatID;\n        /// @notice Current redeemable amount\n        uint256 rAmount;\n        /// @notice Interest portion of the rAmount\n        uint256 rInterest;\n        /// @notice Current loaned debt amount\n        uint256 lDebt;\n        /// @notice Current internal savings amount\n        uint256 sInternalAmount;\n        /// @notice Interest payable\n        uint256 rInterestPayable;\n        /// @notice Cumulative interest generated for the account\n        uint256 cumulativeInterest;\n        /// @notice Loans lent to the recipients\n        uint256 lRecipientsSum;\n    }\n\n    /**\n     * @notice Account stats stored\n     */\n    struct AccountStatsStored {\n        /// @notice Cumulative interest generated for the account\n        uint256 cumulativeInterest;\n    }\n\n    /**\n     * @notice Hat stats view\n     */\n    struct HatStatsView {\n        /// @notice Number of addresses has the hat\n        uint256 useCount;\n        /// @notice Total net loans distributed through the hat\n        uint256 totalLoans;\n        /// @notice Total net savings distributed through the hat\n        uint256 totalSavings;\n    }\n\n    /**\n     * @notice Hat stats stored\n     */\n    struct HatStatsStored {\n        /// @notice Number of addresses has the hat\n        uint256 useCount;\n        /// @notice Total net loans distributed through the hat\n        uint256 totalLoans;\n        /// @notice Total net savings distributed through the hat\n        uint256 totalInternalSavings;\n    }\n\n    /**\n     * @notice Hat structure describes who are the recipients of the interest\n     *\n     * To be a valid hat structure:\n     *   - at least one recipient\n     *   - recipients.length == proportions.length\n     *   - each value in proportions should be greater than 0\n     */\n    struct Hat {\n        address[] recipients;\n        uint32[] proportions;\n    }\n\n    /// @dev Account structure\n    struct Account {\n        /// @notice Current selected hat ID of the account\n        uint256 hatID;\n        /// @notice Current balance of the account (non realtime)\n        uint256 rAmount;\n        /// @notice Interest rate portion of the rAmount\n        uint256 rInterest;\n        /// @notice Debt in redeemable amount lent to recipients\n        //          In case of self-hat, external debt is optimized to not to\n        //          be stored in lRecipients\n        mapping(address => uint256) lRecipients;\n        /// @notice Received loan.\n        ///         Debt in redeemable amount owed to the lenders distributed\n        ///         through one or more hats.\n        uint256 lDebt;\n        /// @notice Savings internal accounting amount.\n        ///         Debt is sold to buy savings\n        uint256 sInternalAmount;\n    }\n\n    /**\n     * Additional Definitions:\n     *\n     *   - rGross = sInternalToR(sInternalAmount)\n     *   - lRecipientsSum = sum(lRecipients)\n     *   - interestPayable = rGross - lDebt - rInterest\n     *   - realtimeBalance = rAmount + interestPayable\n     *\n     *   - rAmount aka. tokenBalance\n     *   - rGross aka. receivedSavings\n     *   - lDebt aka. receivedLoan\n     *\n     * Account Invariants:\n     *\n     *   - rAmount = lRecipientsSum + rInterest [with rounding errors]\n     *\n     * Global Invariants:\n     *\n     * - globalStats.totalSupply = sum(account.tokenBalance)\n     * - globalStats.totalSavingsAmount = sum(account.receivedSavings) [with rounding errors]\n     * - sum(hatStats.totalLoans) = sum(account.receivedLoan)\n     * - sum(hatStats.totalSavings) = sum(account.receivedSavings + cumulativeInterest - rInterest) [with rounding errors]\n     *\n     */\n}\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IAllocationStrategy {\n\n    /**\n     * @notice Underlying asset for the strategy\n     * @return address Underlying asset address\n     */\n    function underlying() external view returns (address);\n\n    /**\n     * @notice Calculates the exchange rate from underlying to saving assets\n     * @return uint256 Calculated exchange rate scaled by 1e18\n     *\n     * NOTE:\n     *\n     *   underlying = savingAssets Ã— exchangeRate\n     */\n    function exchangeRateStored() external view returns (uint256);\n\n    /**\n      * @notice Applies accrued interest to all savings\n      * @dev This should calculates interest accrued from the last checkpointed\n      *      block up to the current block and writes new checkpoint to storage.\n      * @return bool success(true) or failure(false)\n      */\n    function accrueInterest() external returns (bool);\n\n    /**\n     * @notice Sender supplies underlying assets into the market and receives saving assets in exchange\n     * @dev Interst shall be accrued\n     * @param investAmount The amount of the underlying asset to supply\n     * @return uint256 Amount of saving assets created\n     */\n    function investUnderlying(uint256 investAmount) external returns (uint256);\n\n    /**\n     * @notice Sender redeems saving assets in exchange for a specified amount of underlying asset\n     * @dev Interst shall be accrued\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint256 Amount of saving assets burned\n     */\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    /**\n     * @notice Owner redeems all saving assets\n     * @dev Interst shall be accrued\n     * @return uint256 savingsAmount Amount of savings redeemed\n     * @return uint256 underlyingAmount Amount of underlying redeemed\n     */\n    function redeemAll() external returns (uint256 savingsAmount, uint256 underlyingAmount);\n\n}\n\ncontract RTokenStorage is RTokenStructs, IERC20 {\n    /* WARNING: NEVER RE-ORDER VARIABLES! Always double-check that new variables are added APPEND-ONLY. Re-ordering variables can permanently BREAK the deployed proxy contract.*/\n    address public _owner;\n    bool public initialized;\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 public _guardCounter;\n    /**\n     * @notice EIP-20 token name for this token\n     */\n    string public name;\n    /**\n     * @notice EIP-20 token symbol for this token\n     */\n    string public symbol;\n    /**\n     * @notice EIP-20 token decimals for this token\n     */\n    uint256 public decimals;\n    /**\n     * @notice Total number of tokens in circulation\n     */\n    uint256 public totalSupply;\n    /// @dev Current saving strategy\n    IAllocationStrategy public ias;\n    /// @dev Underlying token\n    IERC20 public token;\n    /// @dev Saving assets original amount\n    /// This amount is in the same unit used in allocation strategy\n    uint256 public savingAssetOrignalAmount;\n    /// @dev Saving asset original to internal amount conversion rate.\n    ///      - It has 18 decimals\n    ///      - It starts with value 1.\n    ///      - Each strategy switching results a new conversion rate\n    ///\n    /// NOTE:\n    ///\n    /// 1. The reason there is an exchange rate is that, each time the\n    ///    allocation strategy is switched, the unit of the original amount gets\n    ///    changed, it is impossible to change all the internal savings\n    ///    accounting entries for all accounts, hence instead a conversaion rate\n    ///    is used to simplify the process.\n    /// 2. internalSavings == originalSavings * savingAssetConversionRate\n    uint256 public savingAssetConversionRate;\n    /// @dev Approved token transfer amounts on behalf of others\n    mapping(address => mapping(address => uint256)) public transferAllowances;\n    /// @dev Hat list\n    Hat[] internal hats;\n    /// @dev Account mapping\n    mapping(address => Account) public accounts;\n    /// @dev AccountStats mapping\n    mapping(address => AccountStatsStored) public accountStats;\n    /// @dev HatStats mapping\n    mapping(uint256 => HatStatsStored) public hatStats;\n}\n\ncontract Ownable is RTokenStorage {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract LibraryLock is RTokenStorage {\n    // Ensures no one can manipulate the Logic Contract once it is deployed.\n    // PARITY WALLET HACK PREVENTION\n\n    modifier delegatedOnly() {\n        require(\n            initialized == true,\n            \"The library is locked. No direct 'call' is allowed.\"\n        );\n        _;\n    }\n    function initialize() internal {\n        initialized = true;\n    }\n}\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ncontract ReentrancyGuard is RTokenStorage {\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(\n            localCounter == _guardCounter,\n            \"ReentrancyGuard: reentrant call\"\n        );\n    }\n}\n\ncontract IRToken is RTokenStructs, IERC20 {\n    ////////////////////////////////////////////////////////////////////////////\n    // For external transactions\n    ////////////////////////////////////////////////////////////////////////////\n    /**\n     * @notice Sender supplies assets into the market and receives rTokens in exchange\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return bool true=success, otherwise a failure\n     */\n    function mint(uint256 mintAmount) external returns (bool);\n\n    /**\n     * @notice Sender supplies assets into the market and receives rTokens in exchange\n     *         Also setting the a selected hat for the account.\n     * @param hatID The id of the selected Hat\n     * @return bool true=success, otherwise a failure\n     */\n    function mintWithSelectedHat(uint256 mintAmount, uint256 hatID)\n        external\n        returns (bool);\n\n    /**\n     * @notice Sender supplies assets into the market and receives rTokens in exchange\n     *         Also setting the a new hat for the account.\n     * @param mintAmount The amount of the underlying asset to supply\n     * @param proportions Relative proportions of benefits received by the recipients\n     * @return bool true=success, otherwise a failure\n     */\n    function mintWithNewHat(\n        uint256 mintAmount,\n        address[] calldata recipients,\n        uint32[] calldata proportions\n    ) external returns (bool);\n\n    /**\n     * @notice Moves all tokens from the caller's account to `dst`.\n     * @param dst The destination address.\n     * @return bool true=success, otherwise a failure\n     */\n    function transferAll(address dst) external returns (bool);\n\n    /**\n     * @notice Moves all tokens from `src` account to `dst`.\n     * @param src The source address which approved the msg.sender to spend\n     * @param dst The destination address.\n     * @return bool true=success, otherwise a failure\n     */\n    function transferAllFrom(address src, address dst) external returns (bool);\n\n    /**\n     * @notice Sender redeems rTokens in exchange for the underlying asset\n     * @param redeemTokens The number of rTokens to redeem into underlying\n     * @return bool true=success, otherwise a failure\n     */\n    function redeem(uint256 redeemTokens) external returns (bool);\n\n    /**\n     * @notice Sender redeems all rTokens in exchange for the underlying asset\n     * @return bool true=success, otherwise a failure\n     */\n    function redeemAll() external returns (bool);\n\n    /**\n     * @notice Sender redeems rTokens in exchange for the underlying asset then immediately transfer them to a differen user\n     * @param redeemTo Destination address to send the redeemed tokens to\n     * @param redeemTokens The number of rTokens to redeem into underlying\n     * @return bool true=success, otherwise a failure\n     */\n    function redeemAndTransfer(address redeemTo, uint256 redeemTokens)\n        external\n        returns (bool);\n\n    /**\n     * @notice Sender redeems all rTokens in exchange for the underlying asset then immediately transfer them to a differen user\n     * @param redeemTo Destination address to send the redeemed tokens to\n     * @return bool true=success, otherwise a failure\n     */\n    function redeemAndTransferAll(address redeemTo) external returns (bool);\n\n    /**\n     * @notice Create a new Hat\n     * @param recipients List of beneficial recipients\n     * @param proportions Relative proportions of benefits received by the recipients\n     * @param doChangeHat Should the hat of the `msg.sender` be switched to the new one\n     * @return uint256 ID of the newly creatd Hat.\n     */\n    function createHat(\n        address[] calldata recipients,\n        uint32[] calldata proportions,\n        bool doChangeHat\n    ) external returns (uint256 hatID);\n\n    /**\n     * @notice Change the hat for `msg.sender`\n     * @param hatID The id of the Hat\n     * @return bool true=success, otherwise a failure\n     */\n    function changeHat(uint256 hatID) external returns (bool);\n\n    /**\n     * @notice pay interest to the owner\n     * @param owner Account owner address\n     * @return bool true=success, otherwise a failure\n     *\n     * Anyone can trigger the interest distribution on behalf of the recipient,\n     * due to the fact that the recipient can be a contract code that has not\n     * implemented the interaction with the rToken contract internally`.\n     *\n     * A interest lock-up period may apply, in order to mitigate the \"hat\n     * inheritance scam\".\n     */\n    function payInterest(address owner) external returns (bool);\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Essential info views\n    ////////////////////////////////////////////////////////////////////////////\n    /**\n     * @notice Get the maximum hatID in the system\n     */\n    function getMaximumHatID() external view returns (uint256 hatID);\n\n    /**\n     * @notice Get the hatID of the owner and the hat structure\n     * @param owner Account owner address\n     * @return hatID Hat ID\n     * @return recipients Hat recipients\n     * @return proportions Hat recipient's relative proportions\n     */\n    function getHatByAddress(address owner)\n        external\n        view\n        returns (\n            uint256 hatID,\n            address[] memory recipients,\n            uint32[] memory proportions\n        );\n\n    /**\n     * @notice Get the hat structure\n     * @param hatID Hat ID\n     * @return recipients Hat recipients\n     * @return proportions Hat recipient's relative proportions\n     */\n    function getHatByID(uint256 hatID)\n        external\n        view\n        returns (address[] memory recipients, uint32[] memory proportions);\n\n    /**\n     * @notice Amount of saving assets given to the recipient along with the\n     *         loans.\n     * @param owner Account owner address\n     */\n    function receivedSavingsOf(address owner)\n        external\n        view\n        returns (uint256 amount);\n\n    /**\n     * @notice Amount of token loaned to the recipient along with the savings\n     *         assets.\n     * @param owner Account owner address\n     * @return amount\n     */\n    function receivedLoanOf(address owner)\n        external\n        view\n        returns (uint256 amount);\n\n    /**\n     * @notice Get the current interest balance of the owner.\n               It is equivalent of: receivedSavings - receivedLoan - freeBalance\n     * @param owner Account owner address\n     * @return amount\n     */\n    function interestPayableOf(address owner)\n        external\n        view\n        returns (uint256 amount);\n\n    ////////////////////////////////////////////////////////////////////////////\n    // statistics views\n    ////////////////////////////////////////////////////////////////////////////\n    /**\n     * @notice Get the current saving strategy contract\n     * @return Saving strategy address\n     */\n    function getCurrentSavingStrategy() external view returns (address);\n\n    /**\n    * @notice Get saving asset balance for specific saving strategy\n    * @return rAmount Balance in redeemable amount\n    * @return sOriginalAmount Balance in native amount of the strategy\n    */\n    function getSavingAssetBalance()\n        external\n        view\n        returns (uint256 rAmount, uint256 sOriginalAmount);\n\n    /**\n    * @notice Get global stats\n    * @return global stats\n    */\n    function getGlobalStats() external view returns (GlobalStats memory);\n\n    /**\n    * @notice Get account stats\n    * @param owner Account owner address\n    * @return account stats\n    */\n    function getAccountStats(address owner)\n        external\n        view\n        returns (AccountStatsView memory);\n\n    /**\n    * @notice Get hat stats\n    * @param hatID Hat ID\n    * @return hat stats\n    */\n    function getHatStats(uint256 hatID)\n        external\n        view\n        returns (HatStatsView memory);\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Events\n    ////////////////////////////////////////////////////////////////////////////\n    /**\n     * @notice Event emitted when loans get transferred\n     */\n    event LoansTransferred(\n        address indexed owner,\n        address indexed recipient,\n        uint256 indexed hatId,\n        bool isDistribution,\n        uint256 redeemableAmount,\n        uint256 internalSavingsAmount);\n\n    /**\n     * @notice Event emitted when interest paid\n     */\n    event InterestPaid(address indexed recipient, uint256 amount);\n\n    /**\n     * @notice A new hat is created\n     */\n    event HatCreated(uint256 indexed hatID);\n\n    /**\n     * @notice Hat is changed for the account\n     */\n    event HatChanged(address indexed account, uint256 indexed oldHatID, uint256 indexed newHatID);\n}\n\ninterface IRTokenAdmin {\n\n    /**\n     * @notice Get current owner\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\n     *\n     * To be implemented by Ownable\n     */\n    function transferOwnership(address newOwner) external;\n\n    /**\n    * @notice Get the current allocation strategy\n    */\n    function getCurrentAllocationStrategy()\n        external view returns (address allocationStrategy);\n\n    /**\n    * @notice Change allocation strategy for the contract instance\n    * @param allocationStrategy Allocation strategy instance\n    */\n    function changeAllocationStrategy(address allocationStrategy)\n        external;\n\n    /**\n     * @notice Change hat for the contract address\n     * @param contractAddress contract address\n     * @param hatID Hat ID\n     */\n    function changeHatFor(address contractAddress, uint256 hatID)\n        external;\n\n    /**\n     * @notice Update the rToken logic contract code\n     */\n    function updateCode(address newCode) external;\n\n    /**\n     * @notice Code updated event\n     */\n    event CodeUpdated(address newCode);\n\n    /**\n     * @notice Allocation strategy changed event\n     * @param strategy New strategy address\n     * @param conversionRate New saving asset conversion rate\n     */\n    event AllocationStrategyChanged(address strategy, uint256 conversionRate);\n}\n\ncontract RToken is\n    RTokenStorage,\n    IRToken,\n    IRTokenAdmin,\n    Ownable,\n    Proxiable,\n    LibraryLock,\n    ReentrancyGuard {\n    using SafeMath for uint256;\n\n\n    uint256 public constant ALLOCATION_STRATEGY_EXCHANGE_RATE_SCALE = 1e18;\n    uint256 public constant INITIAL_SAVING_ASSET_CONVERSION_RATE = 1e18;\n    uint256 public constant MAX_UINT256 = uint256(int256(-1));\n    uint256 public constant SELF_HAT_ID = MAX_UINT256;\n    uint32 public constant PROPORTION_BASE = 0xFFFFFFFF;\n    uint256 public constant MAX_NUM_HAT_RECIPIENTS = 50;\n\n    /**\n     * @notice Create rToken linked with cToken at `cToken_`\n     */\n    function initialize(\n        IAllocationStrategy allocationStrategy,\n        string memory name_,\n        string memory symbol_,\n        uint256 decimals_) public {\n        require(!initialized, \"The library has already been initialized.\");\n        LibraryLock.initialize();\n        _owner = msg.sender;\n        _guardCounter = 1;\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n        savingAssetConversionRate = INITIAL_SAVING_ASSET_CONVERSION_RATE;\n        ias = allocationStrategy;\n        token = IERC20(ias.underlying());\n\n        // special hat aka. zero hat : hatID = 0\n        hats.push(Hat(new address[](0), new uint32[](0)));\n\n        // everyone is using it by default!\n        hatStats[0].useCount = MAX_UINT256;\n\n        emit AllocationStrategyChanged(address(ias), savingAssetConversionRate);\n    }\n\n    //\n    // ERC20 Interface\n    //\n\n    /**\n     * @notice Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address owner) external view returns (uint256) {\n        return accounts[owner].rAmount;\n    }\n\n    /**\n     * @notice Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256)\n    {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `amount` tokens from the caller's account to `dst`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * May also emit `InterestPaid` event.\n     */\n    function transfer(address dst, uint256 amount)\n        external\n        nonReentrant\n        returns (bool)\n    {\n        address src = msg.sender;\n        payInterestInternal(src);\n        transferInternal(src, src, dst, amount);\n        payInterestInternal(dst);\n        return true;\n    }\n\n    /// @dev IRToken.transferAll implementation\n    function transferAll(address dst) external nonReentrant returns (bool) {\n        address src = msg.sender;\n        payInterestInternal(src);\n        transferInternal(src, src, dst, accounts[src].rAmount);\n        payInterestInternal(dst);\n        return true;\n    }\n\n    /// @dev IRToken.transferAllFrom implementation\n    function transferAllFrom(address src, address dst)\n        external\n        nonReentrant\n        returns (bool)\n    {\n        payInterestInternal(src);\n        transferInternal(msg.sender, src, dst, accounts[src].rAmount);\n        payInterestInternal(dst);\n        return true;\n    }\n\n    /**\n     * @notice Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address src, address dst, uint256 amount)\n        external\n        nonReentrant\n        returns (bool)\n    {\n        payInterestInternal(src);\n        transferInternal(msg.sender, src, dst, amount);\n        payInterestInternal(dst);\n        return true;\n    }\n\n    //\n    // rToken interface\n    //\n\n    /// @dev IRToken.mint implementation\n    function mint(uint256 mintAmount) external nonReentrant returns (bool) {\n        mintInternal(mintAmount);\n        payInterestInternal(msg.sender);\n        return true;\n    }\n\n    /// @dev IRToken.mintWithSelectedHat implementation\n    function mintWithSelectedHat(uint256 mintAmount, uint256 hatID)\n        external\n        nonReentrant\n        returns (bool)\n    {\n        changeHatInternal(msg.sender, hatID);\n        mintInternal(mintAmount);\n        payInterestInternal(msg.sender);\n        return true;\n    }\n\n    /**\n     * @dev IRToken.mintWithNewHat implementation\n     */\n    function mintWithNewHat(\n        uint256 mintAmount,\n        address[] calldata recipients,\n        uint32[] calldata proportions\n    ) external nonReentrant returns (bool) {\n        uint256 hatID = createHatInternal(recipients, proportions);\n        changeHatInternal(msg.sender, hatID);\n        mintInternal(mintAmount);\n        payInterestInternal(msg.sender);\n        return true;\n    }\n\n    /**\n     * @dev IRToken.redeem implementation\n     *      It withdraws equal amount of initially supplied underlying assets\n     */\n    function redeem(uint256 redeemTokens) external nonReentrant returns (bool) {\n        address src = msg.sender;\n        payInterestInternal(src);\n        redeemInternal(src, redeemTokens);\n        return true;\n    }\n\n    /// @dev IRToken.redeemAll implementation\n    function redeemAll() external nonReentrant returns (bool) {\n        address src = msg.sender;\n        payInterestInternal(src);\n        redeemInternal(src, accounts[src].rAmount);\n        return true;\n    }\n\n    /// @dev IRToken.redeemAndTransfer implementation\n    function redeemAndTransfer(address redeemTo, uint256 redeemTokens)\n        external\n        nonReentrant\n        returns (bool)\n    {\n        address src = msg.sender;\n        payInterestInternal(src);\n        redeemInternal(redeemTo, redeemTokens);\n        return true;\n    }\n\n    /// @dev IRToken.redeemAndTransferAll implementation\n    function redeemAndTransferAll(address redeemTo)\n        external\n        nonReentrant\n        returns (bool)\n    {\n        address src = msg.sender;\n        payInterestInternal(src);\n        redeemInternal(redeemTo, accounts[src].rAmount);\n        return true;\n    }\n\n    /// @dev IRToken.createHat implementation\n    function createHat(\n        address[] calldata recipients,\n        uint32[] calldata proportions,\n        bool doChangeHat\n    ) external nonReentrant returns (uint256 hatID) {\n        hatID = createHatInternal(recipients, proportions);\n        if (doChangeHat) {\n            changeHatInternal(msg.sender, hatID);\n        }\n    }\n\n    /// @dev IRToken.changeHat implementation\n    function changeHat(uint256 hatID) external nonReentrant returns (bool) {\n        changeHatInternal(msg.sender, hatID);\n        payInterestInternal(msg.sender);\n        return true;\n    }\n\n    /// @dev IRToken.getMaximumHatID implementation\n    function getMaximumHatID() external view returns (uint256 hatID) {\n        return hats.length - 1;\n    }\n\n    /// @dev IRToken.getHatByAddress implementation\n    function getHatByAddress(address owner)\n        external\n        view\n        returns (\n            uint256 hatID,\n            address[] memory recipients,\n            uint32[] memory proportions\n        )\n    {\n        hatID = accounts[owner].hatID;\n        (recipients, proportions) = _getHatByID(hatID);\n    }\n\n    /// @dev IRToken.getHatByID implementation\n    function getHatByID(uint256 hatID)\n        external\n        view\n        returns (address[] memory recipients, uint32[] memory proportions) {\n        (recipients, proportions) = _getHatByID(hatID);\n    }\n\n    function _getHatByID(uint256 hatID)\n        private\n        view\n        returns (address[] memory recipients, uint32[] memory proportions) {\n        if (hatID != 0 && hatID != SELF_HAT_ID) {\n            Hat memory hat = hats[hatID];\n            recipients = hat.recipients;\n            proportions = hat.proportions;\n        } else {\n            recipients = new address[](0);\n            proportions = new uint32[](0);\n        }\n    }\n\n    /// @dev IRToken.receivedSavingsOf implementation\n    function receivedSavingsOf(address owner)\n        external\n        view\n        returns (uint256 amount)\n    {\n        Account storage account = accounts[owner];\n        uint256 rGross = sInternalToR(account.sInternalAmount);\n        return rGross;\n    }\n\n    /// @dev IRToken.receivedLoanOf implementation\n    function receivedLoanOf(address owner)\n        external\n        view\n        returns (uint256 amount)\n    {\n        Account storage account = accounts[owner];\n        return account.lDebt;\n    }\n\n    /// @dev IRToken.interestPayableOf implementation\n    function interestPayableOf(address owner)\n        external\n        view\n        returns (uint256 amount)\n    {\n        Account storage account = accounts[owner];\n        return getInterestPayableOf(account);\n    }\n\n    /// @dev IRToken.payInterest implementation\n    function payInterest(address owner) external nonReentrant returns (bool) {\n        payInterestInternal(owner);\n        return true;\n    }\n\n    /// @dev IRToken.getAccountStats implementation!1\n    function getGlobalStats() external view returns (GlobalStats memory) {\n        uint256 totalSavingsAmount;\n        totalSavingsAmount += sOriginalToR(savingAssetOrignalAmount);\n        return\n            GlobalStats({\n                totalSupply: totalSupply,\n                totalSavingsAmount: totalSavingsAmount\n            });\n    }\n\n    /// @dev IRToken.getAccountStats implementation\n    function getAccountStats(address owner)\n        external\n        view\n        returns (AccountStatsView memory stats)\n    {\n        Account storage account = accounts[owner];\n        stats.hatID = account.hatID;\n        stats.rAmount = account.rAmount;\n        stats.rInterest = account.rInterest;\n        stats.lDebt = account.lDebt;\n        stats.sInternalAmount = account.sInternalAmount;\n\n        stats.rInterestPayable = getInterestPayableOf(account);\n\n        AccountStatsStored storage statsStored = accountStats[owner];\n        stats.cumulativeInterest = statsStored.cumulativeInterest;\n\n        Hat storage hat = hats[account.hatID == SELF_HAT_ID\n            ? 0\n            : account.hatID];\n        if (account.hatID == 0 || account.hatID == SELF_HAT_ID) {\n            // Self-hat has storage optimization for lRecipients.\n            // We use the account invariant to calculate lRecipientsSum instead,\n            // so it does look like a tautology indeed.\n            // Check RTokenStructs documentation for more info.\n            stats.lRecipientsSum = gentleSub(stats.rAmount, stats.rInterest);\n        } else {\n            for (uint256 i = 0; i < hat.proportions.length; ++i) {\n                stats.lRecipientsSum += account.lRecipients[hat.recipients[i]];\n            }\n        }\n\n        return stats;\n    }\n\n    /// @dev IRToken.getHatStats implementation\n    function getHatStats(uint256 hatID)\n        external\n        view\n        returns (HatStatsView memory stats) {\n        HatStatsStored storage statsStored = hatStats[hatID];\n        stats.useCount = statsStored.useCount;\n        stats.totalLoans = statsStored.totalLoans;\n\n        stats.totalSavings = sInternalToR(statsStored.totalInternalSavings);\n        return stats;\n    }\n\n    /// @dev IRToken.getCurrentSavingStrategy implementation\n    function getCurrentSavingStrategy() external view returns (address) {\n        return address(ias);\n    }\n\n    /// @dev IRToken.getSavingAssetBalance implementation\n    function getSavingAssetBalance()\n        external\n        view\n        returns (uint256 rAmount, uint256 sOriginalAmount)\n    {\n        sOriginalAmount = savingAssetOrignalAmount;\n        rAmount = sOriginalToR(sOriginalAmount);\n    }\n\n    /// @dev IRToken.changeAllocationStrategy implementation\n    function changeAllocationStrategy(address allocationStrategy_)\n        external\n        nonReentrant\n        onlyOwner\n    {\n        IAllocationStrategy allocationStrategy = IAllocationStrategy(allocationStrategy_);\n        require(\n            allocationStrategy.underlying() == address(token),\n            \"New strategy should have the same underlying asset\"\n        );\n        IAllocationStrategy oldIas = ias;\n        ias = allocationStrategy;\n        // redeem everything from the old strategy\n        (uint256 sOriginalBurned, ) = oldIas.redeemAll();\n        uint256 totalAmount = token.balanceOf(address(this));\n        // invest everything into the new strategy\n        require(token.approve(address(ias), totalAmount), \"token approve failed\");\n        uint256 sOriginalCreated = ias.investUnderlying(totalAmount);\n\n        // give back the ownership of the old allocation strategy to the admin\n        // unless we are simply switching to the same allocaiton Strategy\n        //\n        //  - But why would we switch to the same allocation strategy?\n        //  - This is a special case where one could pick up the unsoliciated\n        //    savings from the allocation srategy contract as extra \"interest\"\n        //    for all rToken holders.\n        if (address(ias) != address(oldIas)) {\n            Ownable(address(oldIas)).transferOwnership(address(owner()));\n        }\n\n        // calculate new saving asset conversion rate\n        //\n        // NOTE:\n        //   - savingAssetConversionRate should be scaled by 1e18\n        //   - to keep internalSavings constant:\n        //     internalSavings == sOriginalBurned * savingAssetConversionRateOld\n        //     internalSavings == sOriginalCreated * savingAssetConversionRateNew\n        //     =>\n        //     savingAssetConversionRateNew = sOriginalBurned\n        //          * savingAssetConversionRateOld\n        //          / sOriginalCreated\n        //\n\n        uint256 sInternalAmount = sOriginalToSInternal(savingAssetOrignalAmount);\n        uint256 savingAssetConversionRateOld = savingAssetConversionRate;\n        savingAssetConversionRate = sOriginalBurned\n            .mul(savingAssetConversionRateOld)\n            .div(sOriginalCreated);\n        savingAssetOrignalAmount = sInternalToSOriginal(sInternalAmount);\n\n        emit AllocationStrategyChanged(allocationStrategy_, savingAssetConversionRate);\n    }\n\n    /// @dev IRToken.changeHatFor implementation\n    function getCurrentAllocationStrategy()\n        external view returns (address allocationStrategy) {\n        return address(ias);\n    }\n\n    /// @dev IRToken.changeHatFor implementation\n    function changeHatFor(address contractAddress, uint256 hatID) external onlyOwner {\n        require(_isContract(contractAddress), \"Admin can only change hat for contract address\");\n        changeHatInternal(contractAddress, hatID);\n    }\n\n    /// @dev Update the rToken logic contract code\n    function updateCode(address newCode) external onlyOwner delegatedOnly {\n        updateCodeAddress(newCode);\n        emit CodeUpdated(newCode);\n    }\n\n    /**\n     * @dev Transfer `tokens` tokens from `src` to `dst` by `spender`\n            Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferInternal(\n        address spender,\n        address src,\n        address dst,\n        uint256 tokens\n    ) internal {\n        require(src != dst, \"src should not equal dst\");\n\n        require(\n            accounts[src].rAmount >= tokens,\n            \"Not enough balance to transfer\"\n        );\n\n        /* Get the allowance, infinite for the account owner */\n        uint256 startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = MAX_UINT256;\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n        require(\n            startingAllowance >= tokens,\n            \"Not enough allowance for transfer\"\n        );\n\n        /* Do the calculations, checking for {under,over}flow */\n        uint256 allowanceNew = startingAllowance.sub(tokens);\n        uint256 srcTokensNew = accounts[src].rAmount.sub(tokens);\n        uint256 dstTokensNew = accounts[dst].rAmount.add(tokens);\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != MAX_UINT256) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        // lRecipients adjustments\n        uint256 sInternalEstimated = estimateAndRecollectLoans(src, tokens);\n        distributeLoans(dst, tokens, sInternalEstimated);\n\n        // update token balances\n        accounts[src].rAmount = srcTokensNew;\n        accounts[dst].rAmount = dstTokensNew;\n\n        // apply hat inheritance rule\n        if ((accounts[src].hatID != 0 &&\n            accounts[dst].hatID == 0 &&\n            accounts[src].hatID != SELF_HAT_ID)) {\n            changeHatInternal(dst, accounts[src].hatID);\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n    }\n\n    /**\n     * @dev Sender supplies assets into the market and receives rTokens in exchange\n     * @dev Invest into underlying assets immediately\n     * @param mintAmount The amount of the underlying asset to supply\n     */\n    function mintInternal(uint256 mintAmount) internal {\n        require(\n            token.allowance(msg.sender, address(this)) >= mintAmount,\n            \"Not enough allowance\"\n        );\n\n        Account storage account = accounts[msg.sender];\n\n        // create saving assets\n        require(token.transferFrom(msg.sender, address(this), mintAmount), \"token transfer failed\");\n        require(token.approve(address(ias), mintAmount), \"token approve failed\");\n        uint256 sOriginalCreated = ias.investUnderlying(mintAmount);\n\n        // update global and account r balances\n        totalSupply = totalSupply.add(mintAmount);\n        account.rAmount = account.rAmount.add(mintAmount);\n\n        // update global stats\n        savingAssetOrignalAmount = savingAssetOrignalAmount.add(sOriginalCreated);\n\n        // distribute saving assets as loans to recipients\n        uint256 sInternalCreated = sOriginalToSInternal(sOriginalCreated);\n        distributeLoans(msg.sender, mintAmount, sInternalCreated);\n\n        emit Transfer(address(0), msg.sender, mintAmount);\n    }\n\n    /**\n     * @notice Sender redeems rTokens in exchange for the underlying asset\n     * @dev Withdraw equal amount of initially supplied underlying assets\n     * @param redeemTo Destination address to send the redeemed tokens to\n     * @param redeemAmount The number of rTokens to redeem into underlying\n     */\n    function redeemInternal(address redeemTo, uint256 redeemAmount) internal {\n        Account storage account = accounts[msg.sender];\n        require(redeemAmount > 0, \"Redeem amount cannot be zero\");\n        require(\n            redeemAmount <= account.rAmount,\n            \"Not enough balance to redeem\"\n        );\n\n        redeemAndRecollectLoans(msg.sender, redeemAmount);\n\n        // update Account r balances and global statistics\n        account.rAmount = account.rAmount.sub(redeemAmount);\n        totalSupply = totalSupply.sub(redeemAmount);\n\n        // transfer the token back\n        require(token.transfer(redeemTo, redeemAmount), \"token transfer failed\");\n\n        emit Transfer(msg.sender, address(0), redeemAmount);\n    }\n\n    /**\n     * @dev Create a new Hat\n     * @param recipients List of beneficial recipients\n*    * @param proportions Relative proportions of benefits received by the recipients\n     */\n    function createHatInternal(\n        address[] memory recipients,\n        uint32[] memory proportions\n    ) internal returns (uint256 hatID) {\n        uint256 i;\n\n        require(recipients.length > 0, \"Invalid hat: at least one recipient\");\n        require(recipients.length <= MAX_NUM_HAT_RECIPIENTS, \"Invalild hat: maximum number of recipients reached\");\n        require(\n            recipients.length == proportions.length,\n            \"Invalid hat: length not matching\"\n        );\n\n        // normalize the proportions\n        // safemath is not used here, because:\n        // proportions are uint32, there is no overflow concern\n        uint256 totalProportions = 0;\n        for (i = 0; i < recipients.length; ++i) {\n            require(\n                proportions[i] > 0,\n                \"Invalid hat: proportion should be larger than 0\"\n            );\n            require(recipients[i] != address(0), \"Invalid hat: recipient should not be 0x0\");\n            // don't panic, no safemath, look above comment\n            totalProportions += uint256(proportions[i]);\n        }\n        for (i = 0; i < proportions.length; ++i) {\n            proportions[i] = uint32(\n                // don't panic, no safemath, look above comment\n                (uint256(proportions[i]) * uint256(PROPORTION_BASE)) /\n                    totalProportions\n            );\n        }\n\n        hatID = hats.push(Hat(recipients, proportions)) - 1;\n        emit HatCreated(hatID);\n    }\n\n    /**\n     * @dev Change the hat for `owner`\n     * @param owner Account owner\n     * @param hatID The id of the Hat\n     */\n    function changeHatInternal(address owner, uint256 hatID) internal {\n        require(hatID == SELF_HAT_ID || hatID < hats.length, \"Invalid hat ID\");\n        Account storage account = accounts[owner];\n        uint256 oldHatID = account.hatID;\n        HatStatsStored storage oldHatStats = hatStats[oldHatID];\n        HatStatsStored storage newHatStats = hatStats[hatID];\n        if (account.rAmount > 0) {\n            uint256 sInternalEstimated = estimateAndRecollectLoans(owner, account.rAmount);\n            account.hatID = hatID;\n            distributeLoans(owner, account.rAmount, sInternalEstimated);\n        } else {\n            account.hatID = hatID;\n        }\n        oldHatStats.useCount -= 1;\n        newHatStats.useCount += 1;\n        emit HatChanged(owner, oldHatID, hatID);\n    }\n\n    /**\n     * @dev Get interest payable of the account\n     */\n    function getInterestPayableOf(Account storage account)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 rGross = sInternalToR(account.sInternalAmount);\n        if (rGross > (account.lDebt.add(account.rInterest))) {\n            // don't panic, the condition guarantees that safemath is not needed\n            return rGross - account.lDebt - account.rInterest;\n        } else {\n            // no interest accumulated yet or even negative interest rate!?\n            return 0;\n        }\n    }\n\n    /**\n     * @dev Distribute the incoming tokens to the recipients as loans.\n     *      The tokens are immediately invested into the saving strategy and\n     *      add to the sAmount of the recipient account.\n     *      Recipient also inherits the owner's hat if it does already have one.\n     * @param owner Owner account address\n     * @param rAmount rToken amount being loaned to the recipients\n     * @param sInternalAmount Amount of saving assets (internal amount) being given to the recipients\n     */\n    function distributeLoans(\n        address owner,\n        uint256 rAmount,\n        uint256 sInternalAmount\n    ) internal {\n        Account storage account = accounts[owner];\n        Hat storage hat = hats[account.hatID == SELF_HAT_ID\n            ? 0\n            : account.hatID];\n        uint256 i;\n        if (hat.recipients.length > 0) {\n            uint256 rLeft = rAmount;\n            uint256 sInternalLeft = sInternalAmount;\n            for (i = 0; i < hat.proportions.length; ++i) {\n                Account storage recipientAccount = accounts[hat.recipients[i]];\n                bool isLastRecipient = i == (hat.proportions.length - 1);\n\n                // calculate the loan amount of the recipient\n                uint256 lDebtRecipient = isLastRecipient\n                    ? rLeft\n                    : (rAmount.mul(hat.proportions[i])) / PROPORTION_BASE;\n                // distribute the loan to the recipient\n                account.lRecipients[hat.recipients[i]] = account.lRecipients[hat.recipients[i]]\n                    .add(lDebtRecipient);\n                recipientAccount.lDebt = recipientAccount.lDebt\n                    .add(lDebtRecipient);\n                // remaining value adjustments\n                rLeft = gentleSub(rLeft, lDebtRecipient);\n\n                // calculate the savings holdings of the recipient\n                uint256 sInternalAmountRecipient = isLastRecipient\n                    ? sInternalLeft\n                    : (sInternalAmount.mul(hat.proportions[i])) / PROPORTION_BASE;\n                recipientAccount.sInternalAmount = recipientAccount.sInternalAmount\n                    .add(sInternalAmountRecipient);\n                // remaining value adjustments\n                sInternalLeft = gentleSub(sInternalLeft, sInternalAmountRecipient);\n\n                _updateLoanStats(owner, hat.recipients[i], account.hatID, true, lDebtRecipient, sInternalAmountRecipient);\n            }\n        } else {\n            // Account uses the zero/self hat, give all interest to the owner\n            account.lDebt = account.lDebt.add(rAmount);\n            account.sInternalAmount = account.sInternalAmount\n                .add(sInternalAmount);\n\n            _updateLoanStats(owner, owner, account.hatID, true, rAmount, sInternalAmount);\n        }\n    }\n\n    /**\n     * @dev Recollect loans from the recipients for further distribution\n     *      without actually redeeming the saving assets\n     * @param owner Owner account address\n     * @param rAmount rToken amount neeeds to be recollected from the recipients\n     *                by giving back estimated amount of saving assets\n     * @return Estimated amount of saving assets (internal) needs to recollected\n     */\n    function estimateAndRecollectLoans(address owner, uint256 rAmount)\n        internal returns (uint256 sInternalEstimated)\n    {\n        // accrue interest so estimate is up to date\n        require(ias.accrueInterest(), \"accrueInterest failed\");\n        sInternalEstimated = rToSInternal(rAmount);\n        recollectLoans(owner, rAmount);\n    }\n\n    /**\n     * @dev Recollect loans from the recipients for further distribution\n     *      by redeeming the saving assets in `rAmount`\n     * @param owner Owner account address\n     * @param rAmount rToken amount neeeds to be recollected from the recipients\n     *                by redeeming equivalent value of the saving assets\n     * @return Amount of saving assets redeemed for rAmount of tokens.\n     */\n    function redeemAndRecollectLoans(address owner, uint256 rAmount)\n        internal\n    {\n        uint256 sOriginalBurned = ias.redeemUnderlying(rAmount);\n        sOriginalToSInternal(sOriginalBurned);\n        recollectLoans(owner, rAmount);\n\n        // update global stats\n        if (savingAssetOrignalAmount > sOriginalBurned) {\n            savingAssetOrignalAmount -= sOriginalBurned;\n        } else {\n            savingAssetOrignalAmount = 0;\n        }\n    }\n\n    /**\n     * @dev Recollect loan from the recipients\n     * @param owner   Owner address\n     * @param rAmount rToken amount of debt to be collected from the recipients\n     */\n    function recollectLoans(\n        address owner,\n        uint256 rAmount\n    ) internal {\n        Account storage account = accounts[owner];\n        Hat storage hat = hats[account.hatID == SELF_HAT_ID\n            ? 0\n            : account.hatID];\n        // interest part of the balance is not debt\n        // hence maximum amount debt to be collected is:\n        uint256 debtToCollect = gentleSub(account.rAmount, account.rInterest);\n        // only a portion of debt needs to be collected\n        if (debtToCollect > rAmount) {\n            debtToCollect = rAmount;\n        }\n        uint256 sInternalToCollect = rToSInternal(debtToCollect);\n        if (hat.recipients.length > 0) {\n            uint256 rLeft = 0;\n            uint256 sInternalLeft = 0;\n            uint256 i;\n            // adjust recipients' debt and savings\n            rLeft = debtToCollect;\n            sInternalLeft = sInternalToCollect;\n            for (i = 0; i < hat.proportions.length; ++i) {\n                Account storage recipientAccount = accounts[hat.recipients[i]];\n                bool isLastRecipient = i == (hat.proportions.length - 1);\n\n                // calulate loans to be collected from the recipient\n                uint256 lDebtRecipient = isLastRecipient\n                    ? rLeft\n                    : (debtToCollect.mul(hat.proportions[i])) / PROPORTION_BASE;\n                recipientAccount.lDebt = gentleSub(\n                    recipientAccount.lDebt,\n                    lDebtRecipient);\n                account.lRecipients[hat.recipients[i]] = gentleSub(\n                    account.lRecipients[hat.recipients[i]],\n                    lDebtRecipient);\n                // loans leftover adjustments\n                rLeft = gentleSub(rLeft, lDebtRecipient);\n\n                // calculate savings to be collected from the recipient\n                uint256 sInternalAmountRecipient = isLastRecipient\n                    ? sInternalLeft\n                    : (sInternalToCollect.mul(hat.proportions[i])) / PROPORTION_BASE;\n                recipientAccount.sInternalAmount = gentleSub(\n                    recipientAccount.sInternalAmount,\n                    sInternalAmountRecipient);\n                // savings leftover adjustments\n                sInternalLeft = gentleSub(sInternalLeft, sInternalAmountRecipient);\n\n                adjustRInterest(recipientAccount);\n\n                _updateLoanStats(owner, hat.recipients[i], account.hatID, false, lDebtRecipient, sInternalAmountRecipient);\n            }\n        } else {\n            // Account uses the zero hat, recollect interests from the owner\n\n            // collect debt from self hat\n            account.lDebt = gentleSub(account.lDebt, debtToCollect);\n\n            // collect savings\n            account.sInternalAmount = gentleSub(account.sInternalAmount, sInternalToCollect);\n\n            adjustRInterest(account);\n\n            _updateLoanStats(owner, owner, account.hatID, false, debtToCollect, sInternalToCollect);\n        }\n\n        // debt-free portion of internal savings needs to be collected too\n        if (rAmount > debtToCollect) {\n            sInternalToCollect = rToSInternal(rAmount - debtToCollect);\n            account.sInternalAmount = gentleSub(account.sInternalAmount, sInternalToCollect);\n            adjustRInterest(account);\n        }\n    }\n\n    /**\n     * @dev pay interest to the owner\n     * @param owner Account owner address\n     */\n    function payInterestInternal(address owner) internal {\n        Account storage account = accounts[owner];\n        AccountStatsStored storage stats = accountStats[owner];\n\n        require(ias.accrueInterest(), \"accrueInterest failed\");\n        uint256 interestAmount = getInterestPayableOf(account);\n\n        if (interestAmount > 0) {\n            stats.cumulativeInterest = stats\n                .cumulativeInterest\n                .add(interestAmount);\n            account.rInterest = account.rInterest.add(interestAmount);\n            account.rAmount = account.rAmount.add(interestAmount);\n            totalSupply = totalSupply.add(interestAmount);\n            emit InterestPaid(owner, interestAmount);\n            emit Transfer(address(0), owner, interestAmount);\n        }\n    }\n\n    function _updateLoanStats(\n        address owner,\n        address recipient,\n        uint256 hatID,\n        bool isDistribution,\n        uint256 redeemableAmount,\n        uint256 sInternalAmount) private {\n        HatStatsStored storage hatStats = hatStats[hatID];\n\n        emit LoansTransferred(owner, recipient, hatID,\n            isDistribution,\n            redeemableAmount,\n            sInternalAmount);\n\n        if (isDistribution) {\n            hatStats.totalLoans = hatStats.totalLoans.add(redeemableAmount);\n            hatStats.totalInternalSavings = hatStats.totalInternalSavings\n                .add(sInternalAmount);\n        } else {\n            hatStats.totalLoans = gentleSub(hatStats.totalLoans, redeemableAmount);\n            hatStats.totalInternalSavings = gentleSub(\n                hatStats.totalInternalSavings,\n                sInternalAmount);\n        }\n    }\n\n    function _isContract(address addr) private view returns (bool) {\n      uint size;\n      assembly { size := extcodesize(addr) }\n      return size > 0;\n    }\n\n    /**\n     * @dev Gently subtract b from a without revert\n     *\n     * Due to the use of integer arithmatic, imprecision may cause a tiny\n     * amount to be off when substracting the otherwise precise proportions.\n     */\n    function gentleSub(uint256 a, uint256 b) private pure returns (uint256) {\n        if (a < b) return 0;\n        else return a - b;\n    }\n\n    /// @dev convert internal savings amount to redeemable amount\n    function sInternalToR(uint256 sInternalAmount)\n        private view\n        returns (uint256 rAmount) {\n        // - rGross is in underlying(redeemable) asset unit\n        // - Both ias.exchangeRateStored and savingAssetConversionRate are scaled by 1e18\n        //   they should cancel out\n        // - Formula:\n        //   savingsOriginalAmount = sInternalAmount / savingAssetConversionRate\n        //   rGross = savingAssetOrignalAmount * ias.exchangeRateStored\n        //   =>\n        return sInternalAmount\n            .mul(ias.exchangeRateStored())\n            .div(savingAssetConversionRate);\n    }\n\n    /// @dev convert redeemable amount to internal savings amount\n    function rToSInternal(uint256 rAmount)\n        private view\n        returns (uint256 sInternalAmount) {\n        return rAmount\n            .mul(savingAssetConversionRate)\n            .div(ias.exchangeRateStored());\n    }\n\n    /// @dev convert original savings amount to redeemable amount\n    function sOriginalToR(uint sOriginalAmount)\n        private view\n        returns (uint256 sInternalAmount) {\n        return sOriginalAmount\n            .mul(ias.exchangeRateStored())\n            .div(ALLOCATION_STRATEGY_EXCHANGE_RATE_SCALE);\n    }\n\n    // @dev convert from original savings amount to internal savings amount\n    function sOriginalToSInternal(uint sOriginalAmount)\n        private view\n        returns (uint256 sInternalAmount) {\n        // savingAssetConversionRate is scaled by 1e18\n        return sOriginalAmount\n            .mul(savingAssetConversionRate)\n            .div(ALLOCATION_STRATEGY_EXCHANGE_RATE_SCALE);\n    }\n\n    // @dev convert from internal savings amount to original savings amount\n    function sInternalToSOriginal(uint sInternalAmount)\n        private view\n        returns (uint256 sOriginalAmount) {\n        // savingAssetConversionRate is scaled by 1e18\n        return sInternalAmount\n            .mul(ALLOCATION_STRATEGY_EXCHANGE_RATE_SCALE)\n            .div(savingAssetConversionRate);\n    }\n\n    // @dev adjust rInterest value\n    //      if savings are transferred, rInterest should be also adjusted\n    function adjustRInterest(Account storage account) private {\n        uint256 rGross = sInternalToR(account.sInternalAmount);\n        if (account.rInterest > rGross - account.lDebt) {\n            account.rInterest = rGross - account.lDebt;\n        }\n    }\n}\n\ncontract rDAI is RToken {\n\n    function initialize (\n        IAllocationStrategy allocationStrategy) external {\n        RToken.initialize(allocationStrategy,\n            \"Redeemable DAI\",\n            \"rDAI\",\n            18);\n    }\n\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"conversionRate\",\"type\":\"uint256\"}],\"name\":\"AllocationStrategyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newCode\",\"type\":\"address\"}],\"name\":\"CodeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldHatID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newHatID\",\"type\":\"uint256\"}],\"name\":\"HatChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"HatCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InterestPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"hatId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isDistribution\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemableAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"internalSavingsAmount\",\"type\":\"uint256\"}],\"name\":\"LoansTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"ALLOCATION_STRATEGY_EXCHANGE_RATE_SCALE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_SAVING_ASSET_CONVERSION_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_NUM_HAT_RECIPIENTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_UINT256\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROPORTION_BASE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SELF_HAT_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_guardCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cumulativeInterest\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sInternalAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"allocationStrategy_\",\"type\":\"address\"}],\"name\":\"changeAllocationStrategy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"changeHat\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"changeHatFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"proportions\",\"type\":\"uint32[]\"},{\"internalType\":\"bool\",\"name\":\"doChangeHat\",\"type\":\"bool\"}],\"name\":\"createHat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getAccountStats\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sInternalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rInterestPayable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cumulativeInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lRecipientsSum\",\"type\":\"uint256\"}],\"internalType\":\"struct RTokenStructs.AccountStatsView\",\"name\":\"stats\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentAllocationStrategy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"allocationStrategy\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentSavingStrategy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGlobalStats\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSavingsAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct RTokenStructs.GlobalStats\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getHatByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"proportions\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"getHatByID\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"proportions\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"getHatStats\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"useCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLoans\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSavings\",\"type\":\"uint256\"}],\"internalType\":\"struct RTokenStructs.HatStatsView\",\"name\":\"stats\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMaximumHatID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSavingAssetBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sOriginalAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hatStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"useCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLoans\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInternalSavings\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ias\",\"outputs\":[{\"internalType\":\"contract IAllocationStrategy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IAllocationStrategy\",\"name\":\"allocationStrategy\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals_\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IAllocationStrategy\",\"name\":\"allocationStrategy\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"interestPayableOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"proportions\",\"type\":\"uint32[]\"}],\"name\":\"mintWithNewHat\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"mintWithSelectedHat\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"payInterest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"receivedLoanOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"receivedSavingsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"redeemAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"redeemTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"redeemAndTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"redeemTo\",\"type\":\"address\"}],\"name\":\"redeemAndTransferAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"savingAssetConversionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"savingAssetOrignalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"transferAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"transferAllFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"transferAllowances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCode\",\"type\":\"address\"}],\"name\":\"updateCode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"rDAI","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://877c4a06e107fe5dcfc1a18de2a68ee7083e7a6d06cd64a94fb7a222886f43ec"}]}