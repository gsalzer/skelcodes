{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n\t// Empty internal constructor, to prevent people from mistakenly deploying\r\n\t// an instance of this contract, which should be used via inheritance.\r\n\tconstructor () internal { }\r\n\r\n\tfunction _msgSender() internal view virtual returns (address payable) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\r\n\tfunction _msgData() internal view virtual returns (bytes memory) {\r\n\t\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n\t\treturn msg.data;\r\n\t}\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n\taddress private _owner;\r\n\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\t/**\r\n\t * @dev Initializes the contract setting the deployer as the initial owner.\r\n\t */\r\n\tconstructor () internal {\r\n\t\taddress msgSender = _msgSender();\r\n\t\t_owner = msgSender;\r\n\t\temit OwnershipTransferred(address(0), msgSender);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the address of the current owner.\r\n\t */\r\n\tfunction owner() public view returns (address) {\r\n\t\treturn _owner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Leaves the contract without owner. It will not be possible to call\r\n\t * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n\t *\r\n\t * NOTE: Renouncing ownership will leave the contract without an owner,\r\n\t * thereby removing any functionality that is only available to the owner.\r\n\t */\r\n\tfunction renounceOwnership() public virtual onlyOwner {\r\n\t\temit OwnershipTransferred(_owner, address(0));\r\n\t\t_owner = address(0);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\t * Can only be called by the current owner.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\n\t\t_transferOwnership(newOwner);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\t */\r\n\tfunction _transferOwnership(address newOwner) internal virtual {\r\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n\t\temit OwnershipTransferred(_owner, newOwner);\r\n\t\t_owner = newOwner;\r\n\t}\r\n}\r\n\r\n\r\nlibrary LibSet_bytes4 {\r\n\tstruct set\r\n\t{\r\n\t\tbytes4[] values;\r\n\t\tmapping(bytes4 => uint256) indexes;\r\n\t}\r\n\r\n\tfunction length(set storage _set)\r\n\tinternal view returns (uint256)\r\n\t{\r\n\t\treturn _set.values.length;\r\n\t}\r\n\r\n\tfunction at(set storage _set, uint256 _index)\r\n\tinternal view returns (bytes4 )\r\n\t{\r\n\t\treturn _set.values[_index - 1];\r\n\t}\r\n\r\n\tfunction indexOf(set storage _set, bytes4  _value)\r\n\tinternal view returns (uint256)\r\n\t{\r\n\t\treturn _set.indexes[_value];\r\n\t}\r\n\r\n\tfunction contains(set storage _set, bytes4  _value)\r\n\tinternal view returns (bool)\r\n\t{\r\n\t\treturn indexOf(_set, _value) != 0;\r\n\t}\r\n\r\n\tfunction content(set storage _set)\r\n\tinternal view returns (bytes4[] memory)\r\n\t{\r\n\t\treturn _set.values;\r\n\t}\r\n\r\n\tfunction add(set storage _set, bytes4  _value)\r\n\tinternal returns (bool)\r\n\t{\r\n\t\tif (contains(_set, _value))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t_set.values.push(_value);\r\n\t\t_set.indexes[_value] = _set.values.length;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction remove(set storage _set, bytes4  _value)\r\n\tinternal returns (bool)\r\n\t{\r\n\t\tif (!contains(_set, _value))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tuint256 i    = indexOf(_set, _value);\r\n\t\tuint256 last = length(_set);\r\n\r\n\t\tif (i != last)\r\n\t\t{\r\n\t\t\tbytes4  swapValue = _set.values[last - 1];\r\n\t\t\t_set.values[i - 1] = swapValue;\r\n\t\t\t_set.indexes[swapValue] = i;\r\n\t\t}\r\n\r\n\t\tdelete _set.indexes[_value];\r\n\t\t_set.values.pop();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction clear(set storage _set)\r\n\tinternal returns (bool)\r\n\t{\r\n\t\tfor (uint256 i = _set.values.length; i > 0; --i)\r\n\t\t{\r\n\t\t\tdelete _set.indexes[_set.values[i-1]];\r\n\t\t}\r\n\t\t_set.values = new bytes4[](0);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\nlibrary LibMap2_bytes4_address_bytes {\r\n\tusing LibSet_bytes4 for LibSet_bytes4.set;\r\n\r\n\tstruct map\r\n\t{\r\n\t\tLibSet_bytes4.set keyset;\r\n\t\tmapping(bytes4 => address) values1;\r\n\t\tmapping(bytes4 => bytes) values2;\r\n\t}\r\n\r\n\tfunction length(map storage _map)\r\n\tinternal view returns (uint256)\r\n\t{\r\n\t\treturn _map.keyset.length();\r\n\t}\r\n\r\n\tfunction value1(map storage _map, bytes4  _key)\r\n\tinternal view returns (address )\r\n\t{\r\n\t\treturn _map.values1[_key];\r\n\t}\r\n\r\n\tfunction value2(map storage _map, bytes4  _key)\r\n\tinternal view returns (bytes memory)\r\n\t{\r\n\t\treturn _map.values2[_key];\r\n\t}\r\n\r\n\tfunction keyAt(map storage _map, uint256 _index)\r\n\tinternal view returns (bytes4 )\r\n\t{\r\n\t\treturn _map.keyset.at(_index);\r\n\t}\r\n\r\n\tfunction at(map storage _map, uint256 _index)\r\n\tinternal view returns (bytes4 , address , bytes memory)\r\n\t{\r\n\t\tbytes4  key = keyAt(_map, _index);\r\n\t\treturn (key, value1(_map, key), value2(_map, key));\r\n\t}\r\n\r\n\tfunction indexOf(map storage _map, bytes4  _key)\r\n\tinternal view returns (uint256)\r\n\t{\r\n\t\treturn _map.keyset.indexOf(_key);\r\n\t}\r\n\r\n\tfunction contains(map storage _map, bytes4  _key)\r\n\tinternal view returns (bool)\r\n\t{\r\n\t\treturn _map.keyset.contains(_key);\r\n\t}\r\n\r\n\tfunction keys(map storage _map)\r\n\tinternal view returns (bytes4[] memory)\r\n\t{\r\n\t\treturn _map.keyset.content();\r\n\t}\r\n\r\n\tfunction set(\r\n\t\tmap storage _map,\r\n\t\tbytes4  _key,\r\n\t\taddress  _value1,\r\n\t\tbytes memory _value2)\r\n\tinternal returns (bool)\r\n\t{\r\n\t\t_map.keyset.add(_key);\r\n\t\t_map.values1[_key] = _value1;\r\n\t\t_map.values2[_key] = _value2;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction del(map storage _map, bytes4  _key)\r\n\tinternal returns (bool)\r\n\t{\r\n\t\t_map.keyset.remove(_key);\r\n\t\tdelete _map.values1[_key];\r\n\t\tdelete _map.values2[_key];\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction clear(map storage _map)\r\n\tinternal returns (bool)\r\n\t{\r\n\t\tfor (uint256 i = _map.keyset.length(); i > 0; --i)\r\n\t\t{\r\n\t\t\tbytes4  key = keyAt(_map, i);\r\n\t\t\tdelete _map.values1[key];\r\n\t\t\tdelete _map.values2[key];\r\n\t\t}\r\n\t\t_map.keyset.clear();\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\ninterface IERC1538 {\r\n\tevent CommitMessage(string message);\r\n\tevent FunctionUpdate(bytes4 indexed functionId, address indexed oldDelegate, address indexed newDelegate, string functionSignature);\r\n}\r\n\r\ncontract ERC1538Store is Ownable\r\n{\r\n\tusing LibMap2_bytes4_address_bytes for LibMap2_bytes4_address_bytes.map;\r\n\r\n\tLibMap2_bytes4_address_bytes.map internal m_funcs;\r\n}\r\n\r\ncontract ERC1538Core is IERC1538, ERC1538Store\r\n{\r\n\tbytes4 constant internal RECEIVE  = 0xd217fcc6; // bytes4(keccak256(\"receive\"));\r\n\tbytes4 constant internal FALLBACK = 0xb32cdf4d; // bytes4(keccak256(\"fallback\"));\r\n\r\n\tevent CommitMessage(string message);\r\n\tevent FunctionUpdate(bytes4 indexed functionId, address indexed oldDelegate, address indexed newDelegate, string functionSignature);\r\n\r\n\tfunction _setFunc(string memory funcSignature, address funcDelegate)\r\n\tinternal\r\n\t{\r\n\t\tbytes4 funcId = bytes4(keccak256(bytes(funcSignature)));\r\n\t\tif (funcId == RECEIVE ) { funcId = bytes4(0x00000000); }\r\n\t\tif (funcId == FALLBACK) { funcId = bytes4(0xFFFFFFFF); }\r\n\r\n\t\taddress oldDelegate = m_funcs.value1(funcId);\r\n\r\n\t\tif (funcDelegate == oldDelegate) // No change â†’ skip\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\telse if (funcDelegate == address(0)) // Delete\r\n\t\t{\r\n\t\t\tm_funcs.del(funcId);\r\n\t\t}\r\n\t\telse // Set / Update\r\n\t\t{\r\n\t\t\tm_funcs.set(funcId, funcDelegate, bytes(funcSignature));\r\n\t\t}\r\n\r\n\t\temit FunctionUpdate(funcId, oldDelegate, funcDelegate, funcSignature);\r\n\t}\r\n}\r\n\r\ncontract ERC1538Module is ERC1538Store\r\n{\r\n\tconstructor()\r\n\tpublic\r\n\t{\r\n\t\trenounceOwnership();\r\n\t}\r\n}\r\n\r\ninterface ERC1538Update\r\n{\r\n\tfunction updateContract(address _delegate, string calldata _functionSignatures, string calldata commitMessage) external;\r\n}\r\n\r\ncontract ERC1538UpdateDelegate is ERC1538Update, ERC1538Core, ERC1538Module\r\n{\r\n\tfunction updateContract(\r\n\t\taddress         _delegate,\r\n\t\tstring calldata _functionSignatures,\r\n\t\tstring calldata _commitMessage\r\n\t)\r\n\texternal override onlyOwner\r\n\t{\r\n\t\tbytes memory signatures = bytes(_functionSignatures);\r\n\t\tuint256 start;\r\n\t\tuint256 end;\r\n\t\tuint256 size;\r\n\r\n\t\tif (_delegate != address(0))\r\n\t\t{\r\n\t\t\tassembly { size := extcodesize(_delegate) }\r\n\t\t\trequire(size > 0, \"[ERC1538] _delegate address is not a contract and is not address(0)\");\r\n\t\t}\r\n\t\tassembly\r\n\t\t{\r\n\t\t\tstart := add(signatures, 32)\r\n\t\t\tend   := add(start, mload(signatures))\r\n\t\t}\r\n\t\tfor (uint256 pos = start; pos < end; ++pos)\r\n\t\t{\r\n\t\t\tuint256 char;\r\n\t\t\tassembly { char := byte(0, mload(pos)) }\r\n\t\t\tif (char == 0x3B) // 0x3B = ';'\r\n\t\t\t{\r\n\t\t\t\tuint256 length = (pos - start);\r\n\t\t\t\tassembly { mstore(signatures, length) }\r\n\r\n\t\t\t\t_setFunc(string(signatures), _delegate);\r\n\r\n\t\t\t\tassembly { signatures := add(signatures, add(length, 1)) }\r\n\t\t\t\tstart = pos+1;\r\n\t\t\t}\r\n\t\t}\r\n\t\temit CommitMessage(_commitMessage);\r\n\t}\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"CommitMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"functionId\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldDelegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDelegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"functionSignature\",\"type\":\"string\"}],\"name\":\"FunctionUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_delegate\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_functionSignatures\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_commitMessage\",\"type\":\"string\"}],\"name\":\"updateContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ERC1538UpdateDelegate","CompilerVersion":"v0.6.4+commit.1dca32f3","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ad7328f46f719b895046b880aef2dd7e0af9f6c04510d21a00e3c8bd99411035"}]}