{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\ncontract IGetRatioForBancorAssets {\r\n  function getRatio(address _from, address _to, uint256 _amount)\r\n  public\r\n  view\r\n  returns(uint256 result);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n\r\ncontract KyberNetworkInterface {\r\n  function trade(\r\n    ERC20 src,\r\n    uint srcAmount,\r\n    ERC20 dest,\r\n    address destAddress,\r\n    uint maxDestAmount,\r\n    uint minConversionRate,\r\n    address walletId\r\n  )\r\n    public\r\n    payable\r\n    returns(uint);\r\n\r\n  function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) public view\r\n    returns (uint expectedRate, uint slippageRate);\r\n}\r\ncontract PathFinderInterface {\r\n  function generatePath(address _sourceToken, address _targetToken)\r\n  public\r\n  view\r\n  returns (address[] memory);\r\n}\r\n\r\n\r\n\r\n\r\ncontract BancorNetworkInterface {\r\n   function getReturnByPath(ERC20[] _path, uint256 _amount) public view returns (uint256, uint256);\r\n\r\n    function convert(\r\n        ERC20[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn\r\n    ) public payable returns (uint256);\r\n\r\n    function claimAndConvert(\r\n        ERC20[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn\r\n    ) public returns (uint256);\r\n\r\n    function convertFor(\r\n        ERC20[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for\r\n    ) public payable returns (uint256);\r\n\r\n    function claimAndConvertFor(\r\n        ERC20[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for\r\n    ) public returns (uint256);\r\n\r\n}\r\ncontract IGetBancorAddressFromRegistry{\r\n  function getBancorContractAddresByName(string _name) public view returns (address result);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ConvertPortal {\r\n  address public BancorEtherToken;\r\n  IGetBancorAddressFromRegistry public bancorRegistry;\r\n  KyberNetworkInterface public kyber;\r\n  IGetRatioForBancorAssets public bancorRatio;\r\n  address public cotToken;\r\n  address constant private ETH_TOKEN_ADDRESS = address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n\r\n  /**\r\n  * @dev contructor\r\n  *\r\n  * @param _bancorRegistryWrapper  address of CoTrader Bancor Registry Wrapper contract \r\n  * @param _BancorEtherToken       address of Bancor ETH wrapper contract\r\n  * @param _kyber                  address of KyberNetworkProxy contract\r\n  * @param _cotToken               address of CoTrader erc20 contract\r\n  * @param _bancorRatio            address of CoTrader Bancor ratio contract\r\n  */\r\n  constructor(\r\n    address _bancorRegistryWrapper,\r\n    address _BancorEtherToken,\r\n    address _kyber,\r\n    address _cotToken,\r\n    address _bancorRatio\r\n    )\r\n    public\r\n  {\r\n    bancorRegistry = IGetBancorAddressFromRegistry(_bancorRegistryWrapper);\r\n    BancorEtherToken = _BancorEtherToken;\r\n    kyber = KyberNetworkInterface(_kyber);\r\n    cotToken = _cotToken;\r\n    bancorRatio = IGetRatioForBancorAssets(_bancorRatio);\r\n  }\r\n\r\n  // check if token can be converted to COT in Bancor Network\r\n  function isConvertibleToCOT(address _token, uint256 _amount)\r\n  public\r\n  view\r\n  returns(uint256)\r\n  {\r\n    // wrap Bancor ETH token\r\n    address fromToken = _token == ETH_TOKEN_ADDRESS ? BancorEtherToken : _token;\r\n    // check if can get ratio\r\n    (bool success) = address(bancorRatio).call(\r\n    abi.encodeWithSelector(bancorRatio.getRatio.selector, fromToken, cotToken, _amount));\r\n    // get ratio from Bancor DEX with COT\r\n    if(success){\r\n      return bancorRatio.getRatio(fromToken, cotToken, _amount);\r\n    }else{\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  // check if token can be converted to ETH in Kyber Network\r\n  // can be added more DEX\r\n  function isConvertibleToETH(address _token, uint256 _amount)\r\n  public\r\n  view\r\n  returns(uint256)\r\n  {\r\n    // check if can get ratio\r\n    (bool success) = address(kyber).call(\r\n    abi.encodeWithSelector(\r\n      kyber.getExpectedRate.selector,\r\n      ERC20(_token),\r\n      ERC20(ETH_TOKEN_ADDRESS),\r\n       _amount));\r\n\r\n    // get ratio\r\n    if(success){\r\n     (uint256 expectedRate, ) = kyber.getExpectedRate(\r\n      ERC20(_token),\r\n      ERC20(ETH_TOKEN_ADDRESS),\r\n      _amount);\r\n      return expectedRate;\r\n    }else{\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  // convert ERC to COT via Bancor network\r\n  // return COT amount\r\n  function convertTokentoCOT(address _token, uint256 _amount)\r\n  public\r\n  payable\r\n  returns (uint256 cotAmount)\r\n  {\r\n    if(_token == ETH_TOKEN_ADDRESS)\r\n      require(msg.value == _amount, \"require ETH\");\r\n\r\n    // get COT\r\n    cotAmount = _tradeBancor(\r\n        _token,\r\n        cotToken,\r\n        _amount\r\n    );\r\n\r\n    // send COT back to sender\r\n    ERC20(cotToken).transfer(msg.sender, cotAmount);\r\n\r\n    // After the trade, any amount of input token will be sent back to msg.sender\r\n    uint256 endAmount = (_token == ETH_TOKEN_ADDRESS)\r\n    ? address(this).balance\r\n    : ERC20(_token).balanceOf(address(this));\r\n\r\n    // Check if we hold a positive amount of _source\r\n    if (endAmount > 0) {\r\n      if (_token == ETH_TOKEN_ADDRESS) {\r\n        (msg.sender).transfer(endAmount);\r\n      } else {\r\n        ERC20(_token).transfer(msg.sender, endAmount);\r\n      }\r\n    }\r\n  }\r\n\r\n  // convert ERC to ETH and then ETH to COT\r\n  // for case if input token not in Bancor network\r\n  // return COT amount\r\n  function convertTokentoCOTviaETH(address _token, uint256 _amount)\r\n  public\r\n  returns (uint256 cotAmount)\r\n  {\r\n    // convert token to ETH via kyber\r\n    uint256 receivedETH = _tradeKyber(\r\n        ERC20(_token),\r\n        _amount,\r\n        ERC20(ETH_TOKEN_ADDRESS)\r\n    );\r\n\r\n    // convert ETH to COT via bancor\r\n    cotAmount = _tradeBancor(\r\n        ETH_TOKEN_ADDRESS,\r\n        cotToken,\r\n        receivedETH\r\n    );\r\n\r\n    // send COT back to sender\r\n    ERC20(cotToken).transfer(msg.sender, cotAmount);\r\n\r\n    // check if there are remains some amount of token and eth, then send back to sender\r\n    uint256 endAmountOfETH = address(this).balance;\r\n    uint256 endAmountOfERC = ERC20(_token).balanceOf(address(this));\r\n\r\n    if(endAmountOfETH > 0)\r\n      (msg.sender).transfer(endAmountOfETH);\r\n    if(endAmountOfERC > 0)\r\n      ERC20(_token).transfer(msg.sender, endAmountOfERC);\r\n  }\r\n\r\n\r\n // Facilitates trade with Bancor\r\n function _tradeKyber(\r\n   ERC20 _source,\r\n   uint256 _sourceAmount,\r\n   ERC20 _destination\r\n )\r\n   private\r\n   returns (uint256)\r\n {\r\n   uint256 destinationReceived;\r\n   uint256 _maxDestinationAmount = 2**256-1;\r\n   uint256 _minConversionRate = 1;\r\n   address _walletId = address(0x0000000000000000000000000000000000000000);\r\n\r\n   if (_source == ETH_TOKEN_ADDRESS) {\r\n     destinationReceived = kyber.trade.value(_sourceAmount)(\r\n       _source,\r\n       _sourceAmount,\r\n       _destination,\r\n       this,\r\n       _maxDestinationAmount,\r\n       _minConversionRate,\r\n       _walletId\r\n     );\r\n   } else {\r\n     _transferFromSenderAndApproveTo(_source, _sourceAmount, kyber);\r\n     destinationReceived = kyber.trade(\r\n       _source,\r\n       _sourceAmount,\r\n       _destination,\r\n       this,\r\n       _maxDestinationAmount,\r\n       _minConversionRate,\r\n       _walletId\r\n     );\r\n   }\r\n\r\n   return destinationReceived;\r\n }\r\n\r\n // Facilitates trade with Bancor\r\n function _tradeBancor(\r\n   address sourceToken,\r\n   address destinationToken,\r\n   uint256 sourceAmount\r\n   )\r\n   private\r\n   returns(uint256 returnAmount)\r\n {\r\n    // get latest bancor contracts\r\n    BancorNetworkInterface bancorNetwork = BancorNetworkInterface(\r\n      bancorRegistry.getBancorContractAddresByName(\"BancorNetwork\")\r\n    );\r\n\r\n    PathFinderInterface pathFinder = PathFinderInterface(\r\n      bancorRegistry.getBancorContractAddresByName(\"BancorNetworkPathFinder\")\r\n    );\r\n\r\n    // Change source and destination to Bancor ETH wrapper\r\n    address source = ERC20(sourceToken) == ETH_TOKEN_ADDRESS ? BancorEtherToken : sourceToken;\r\n    address destination = ERC20(destinationToken) == ETH_TOKEN_ADDRESS ? BancorEtherToken : destinationToken;\r\n\r\n    // Get Bancor tokens path\r\n    address[] memory path = pathFinder.generatePath(source, destination);\r\n\r\n    // Convert addresses to ERC20\r\n    ERC20[] memory pathInERC20 = new ERC20[](path.length);\r\n    for(uint i=0; i<path.length; i++){\r\n        pathInERC20[i] = ERC20(path[i]);\r\n    }\r\n\r\n    // trade\r\n    if (ERC20(sourceToken) == ETH_TOKEN_ADDRESS) {\r\n      returnAmount = bancorNetwork.convert.value(sourceAmount)(pathInERC20, sourceAmount, 1);\r\n    }\r\n    else {\r\n      _transferFromSenderAndApproveTo(ERC20(sourceToken), sourceAmount, address(bancorNetwork));\r\n      returnAmount = bancorNetwork.claimAndConvert(pathInERC20, sourceAmount, 1);\r\n    }\r\n }\r\n\r\n /**\r\n  * @dev Transfers tokens to this contract and approves them to another address\r\n  *\r\n  * @param _source          Token to transfer and approve\r\n  * @param _sourceAmount    The amount to transfer and approve (in _source token)\r\n  * @param _to              Address to approve to\r\n  */\r\n  function _transferFromSenderAndApproveTo(ERC20 _source, uint256 _sourceAmount, address _to) private {\r\n    require(_source.transferFrom(msg.sender, address(this), _sourceAmount));\r\n\r\n    _source.approve(_to, _sourceAmount);\r\n  }\r\n\r\n  // fallback payable function to receive ether from other contract addresses\r\n  function() public payable {}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"bancorRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"convertTokentoCOTviaETH\",\"outputs\":[{\"name\":\"cotAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bancorRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"isConvertibleToCOT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"isConvertibleToETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"convertTokentoCOT\",\"outputs\":[{\"name\":\"cotAmount\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kyber\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BancorEtherToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cotToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_bancorRegistryWrapper\",\"type\":\"address\"},{\"name\":\"_BancorEtherToken\",\"type\":\"address\"},{\"name\":\"_kyber\",\"type\":\"address\"},{\"name\":\"_cotToken\",\"type\":\"address\"},{\"name\":\"_bancorRatio\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"ConvertPortal","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000178c68aefdcae5c9818e43addf6a2b66df534ed5000000000000000000000000c0829421c1d260bd3cb3e0f06cfe2d52db2ce315000000000000000000000000818e6fecd516ecc3849daf6845e3ec868087b7550000000000000000000000005c872500c00565505f3624ab435c222e558e9ff80000000000000000000000003079a42efbd0027318baa0dd81d002c0929b502c","Library":"","LicenseType":"None","SwarmSource":"bzzr://6d6920a0e21b846b31fa877cff7f52fb81717d49204be1510b78f59a0784af03"}]}