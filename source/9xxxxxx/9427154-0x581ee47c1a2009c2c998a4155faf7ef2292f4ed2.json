{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ncontract ERC20 {\\n  function totalSupply() public view returns (uint256);\\n\\n  function balanceOf(address _who) public view returns (uint256);\\n\\n  function allowance(address _owner, address _spender)\\n    public view returns (uint256);\\n\\n  function transfer(address _to, uint256 _value) public returns (bool);\\n\\n  function approve(address _spender, uint256 _value)\\n    public returns (bool);\\n\\n  function transferFrom(address _from, address _to, uint256 _value)\\n    public returns (bool);\\n\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\"},\"ReapChain.sol\":{\"content\":\"pragma solidity ^0.4.24;\\nimport \\\"./StandardToken.sol\\\";\\n\\ncontract ReapChain is StandardToken { // CHANGE THIS. Update the contract name.\\n    \\n    struct Presales {\\n        uint presalesTime; // 1:1st, 2:2nd, 3:3rd..\\n        uint256 presalesAmount;\\n        uint256 presalesETH;\\n        uint256 presalesBTC;\\n        uint256 presalesCASH;\\n        string reason;\\n    }\\n    \\n    uint public totalHolderCount;\\n    uint public totalPresaleHolderCount;\\n    mapping (uint =\\u003e uint) public totalRoundPresaleHolderCount;\\n    mapping (uint =\\u003e address) public holderList;\\n    mapping (uint =\\u003e address) public presaleHolderList;\\n    mapping (uint =\\u003e mapping (uint =\\u003e address)) public roundPresaleHolderList;\\n    mapping (address =\\u003e bool) public isHolders;\\n    mapping (address =\\u003e bool) public isLockHolders;\\n    mapping (address =\\u003e uint) public presaleJoinCount;\\n    mapping (address =\\u003e mapping (uint =\\u003e Presales)) public holderPresaleInfo;\\n    mapping (uint =\\u003e uint256) public presalesAmount;\\n    \\n    mapping (uint =\\u003e uint256) public totalEthInWei;\\n    mapping (uint =\\u003e uint256) public totalBtcInWei;\\n    mapping (uint =\\u003e uint256) public totalCash;\\n    mapping (address =\\u003e bool) public subOwner;\\n    \\n    bool public locked;\\n    \\n    mapping (address =\\u003e uint256) public holderLockBalance;\\n    \\n    /* Public variables of the token */\\n\\n    /*\\n    NOTE:\\n    The following variables are OPTIONAL vanities. One does not have to include them.\\n    They allow one to customise the token contract \\u0026 in no way influences the core functionality.\\n    Some wallets/interfaces might not even bother to look at this information.\\n    */\\n    string public constant name = \\\"ReapChain\\\";                   // Token Name\\n    uint8 public constant decimals = 18;                // How many decimals to show. To be standard complicant keep it 18\\n    string public constant symbol = \\\"REAP\\\";                 // An identifier: eg SBX, XPR etc..\\n    address public fundsWallet;           // Where should the raised ETH go?\\n    \\n    \\n    // This is a constructor function \\n    // which means the following function name has to match the contract name declared above\\n    constructor() public {\\n        balances[msg.sender] = 4900000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)\\n        totalSupply_ = 4900000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)\\n        fundsWallet = msg.sender;                                    // The owner of the contract gets ETH\\n        locked = true;\\n        \\n    }\\n    function lockStart() public {\\n        require(fundsWallet == msg.sender);\\n        locked = true;\\n    }\\n    function lockStop() public {\\n        require(fundsWallet == msg.sender);\\n        locked = false;\\n    }\\n    function presaleHolderLock(uint _presales) public {\\n        require(fundsWallet == msg.sender);\\n        for(uint i=0 ; i \\u003c totalRoundPresaleHolderCount[_presales] ; i++) {\\n            isLockHolders[roundPresaleHolderList[_presales][i]] = true;\\n        }\\n    }\\n    function presaleHolderRelease(uint _presales) public {\\n        require(fundsWallet == msg.sender);\\n        for(uint i=0 ; i \\u003c totalRoundPresaleHolderCount[_presales] ; i++) {\\n            isLockHolders[roundPresaleHolderList[_presales][i]] = false;\\n        }\\n    }\\n    function lockAddress(address _address) public {\\n        require(fundsWallet == msg.sender);\\n        isLockHolders[_address] = true;\\n    }\\n    function releaseAddress(address _address) public {\\n        require(fundsWallet == msg.sender);\\n        isLockHolders[_address] = false;\\n    }\\n    function setHolderLockBalance(address _address, uint _lockAmount) public {\\n        require(fundsWallet == msg.sender);\\n        holderLockBalance[_address] = _lockAmount;\\n    }\\n    function addSubOwner(address _address) public {\\n        require(fundsWallet == msg.sender);\\n        subOwner[_address] = true;\\n    }\\n    function removeSubOwner(address _address) public {\\n        require(fundsWallet == msg.sender);\\n        subOwner[_address] = false;\\n    }\\n    function manualPresales(uint _presales, address _to, uint256 _amount, uint256 _presalesETH, uint256 _presalesBTH, uint256 _presalesCASH, string _reason) public {\\n        require(fundsWallet == msg.sender || subOwner[msg.sender] == true);\\n        require(balances[msg.sender] \\u003e= _amount);\\n        \\n        if (msg.sender != _to \\u0026\\u0026 isHolders[_to] != true) {\\n            isHolders[_to] = true;\\n            holderList[totalHolderCount] = _to;\\n            totalHolderCount = totalHolderCount + 1;\\n        }\\n        presalesAmount[_presales] = presalesAmount[_presales] + _amount;\\n        \\n        totalEthInWei[_presales] = totalEthInWei[_presales] + _presalesETH;\\n        totalBtcInWei[_presales] = totalBtcInWei[_presales] + _presalesBTH;\\n        totalCash[_presales] = totalCash[_presales] + _presalesCASH;\\n        \\n        holderPresaleInfo[_to][presaleJoinCount[_to]].presalesTime = _presales;\\n        holderPresaleInfo[_to][presaleJoinCount[_to]].presalesAmount = _amount;\\n        holderPresaleInfo[_to][presaleJoinCount[_to]].presalesETH = _presalesETH;\\n        holderPresaleInfo[_to][presaleJoinCount[_to]].presalesBTC = _presalesBTH;\\n        holderPresaleInfo[_to][presaleJoinCount[_to]].presalesCASH = _presalesCASH;\\n        holderPresaleInfo[_to][presaleJoinCount[_to]].reason = _reason;\\n        \\n        if (presaleJoinCount[_to] == 0) {\\n            presaleHolderList[totalPresaleHolderCount] = _to;\\n            totalPresaleHolderCount = totalPresaleHolderCount + 1;\\n            \\n            roundPresaleHolderList[_presales][totalRoundPresaleHolderCount[_presales]] = _to;\\n            totalRoundPresaleHolderCount[_presales] = totalRoundPresaleHolderCount[_presales] + 1;\\n        } else {\\n            bool isPresaleHolder = false;\\n            for (uint i=0;i\\u003ctotalRoundPresaleHolderCount[_presales];i++) {\\n                if (roundPresaleHolderList[_presales][i] == _to) {\\n                    isPresaleHolder = true;\\n                    break;\\n                }\\n            }\\n            if (!isPresaleHolder) {\\n                roundPresaleHolderList[_presales][totalRoundPresaleHolderCount[_presales]] = _to;\\n                totalRoundPresaleHolderCount[_presales] = totalRoundPresaleHolderCount[_presales] + 1;\\n            }\\n        }\\n        presaleJoinCount[_to] = presaleJoinCount[_to] + 1;\\n        \\n        if (_presales == 1 || _presales == 2) {\\n            isLockHolders[_to] = true;\\n        }\\n        \\n        balances[msg.sender] = balances[msg.sender] - _amount;\\n        balances[_to] = balances[_to] + _amount;\\n        \\n        \\n        emit Transfer(msg.sender, _to, _amount);\\n    }\\n    function transfer(address _to, uint256 _value) public returns (bool) {\\n        require(balances[msg.sender] \\u003e= holderLockBalance[msg.sender]);\\n        require(_value \\u003c= balances[msg.sender] - holderLockBalance[msg.sender]);\\n        require(_to != address(0));\\n        require(locked == false || msg.sender == fundsWallet);\\n        require(isLockHolders[msg.sender] == false);\\n        \\n        if (fundsWallet != _to \\u0026\\u0026 isHolders[_to] != true) {\\n            isHolders[_to] = true;\\n            holderList[totalHolderCount] = _to;\\n            totalHolderCount = totalHolderCount + 1;\\n        }\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _value\\n    )\\n    public\\n    returns (bool)\\n    {\\n        require(balances[_from] \\u003e= holderLockBalance[_from]);\\n        require(_value \\u003c= balances[_from] - holderLockBalance[_from]);\\n        require(_value \\u003c= allowed[_from][msg.sender]);\\n        require(_to != address(0));\\n        require(locked == false || _from == fundsWallet);\\n        require(isLockHolders[_from] == false);\\n        \\n        if (fundsWallet != _to \\u0026\\u0026 isHolders[_to] != true) {\\n            isHolders[_to] = true;\\n            holderList[totalHolderCount] = _to;\\n            totalHolderCount = totalHolderCount + 1;\\n        }\\n        balances[_from] = balances[_from].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n    \\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, reverts on overflow.\\n  */\\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (_a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = _a * _b;\\n    require(c / _a == _b);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n  */\\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    require(_b \\u003e 0); // Solidity only automatically asserts when dividing by 0\\n    uint256 c = _a / _b;\\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn\\u0027t hold\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    require(_b \\u003c= _a);\\n    uint256 c = _a - _b;\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, reverts on overflow.\\n  */\\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    uint256 c = _a + _b;\\n    require(c \\u003e= _a);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n  * reverts when dividing by zero.\\n  */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0);\\n    return a % b;\\n  }\\n}\"},\"StandardToken.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n */\\ncontract StandardToken is ERC20 {\\n  using SafeMath for uint256;\\n\\n  mapping (address =\\u003e uint256) internal balances;\\n\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) internal allowed;\\n\\n  uint256 internal totalSupply_;\\n\\n  /**\\n  * @dev Total number of tokens in existence\\n  */\\n  function totalSupply() public view returns (uint256) {\\n    return totalSupply_;\\n  }\\n\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param _owner The address to query the the balance of.\\n  * @return An uint256 representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address _owner) public view returns (uint256) {\\n    return balances[_owner];\\n  }\\n\\n  /**\\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n   * @param _owner address The address which owns the funds.\\n   * @param _spender address The address which will spend the funds.\\n   * @return A uint256 specifying the amount of tokens still available for the spender.\\n   */\\n  function allowance(\\n    address _owner,\\n    address _spender\\n   )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    return allowed[_owner][_spender];\\n  }\\n\\n  \\n\\n  /**\\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n   * race condition is to first reduce the spender\\u0027s allowance to 0 and set the desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   * @param _spender The address which will spend the funds.\\n   * @param _value The amount of tokens to be spent.\\n   */\\n  function approve(address _spender, uint256 _value) public returns (bool) {\\n    allowed[msg.sender][_spender] = _value;\\n    emit Approval(msg.sender, _spender, _value);\\n    return true;\\n  }\\n\\n  \\n\\n  /**\\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\\n   * approve should be called when allowed[_spender] == 0. To increment\\n   * allowed value is better to use this function to avoid 2 calls (and wait until\\n   * the first transaction is mined)\\n   * From MonolithDAO Token.sol\\n   * @param _spender The address which will spend the funds.\\n   * @param _addedValue The amount of tokens to increase the allowance by.\\n   */\\n  function increaseApproval(\\n    address _spender,\\n    uint256 _addedValue\\n  )\\n    public\\n    returns (bool)\\n  {\\n    allowed[msg.sender][_spender] = (\\n      allowed[msg.sender][_spender].add(_addedValue));\\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n   * approve should be called when allowed[_spender] == 0. To decrement\\n   * allowed value is better to use this function to avoid 2 calls (and wait until\\n   * the first transaction is mined)\\n   * From MonolithDAO Token.sol\\n   * @param _spender The address which will spend the funds.\\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\\n   */\\n  function decreaseApproval(\\n    address _spender,\\n    uint256 _subtractedValue\\n  )\\n    public\\n    returns (bool)\\n  {\\n    uint256 oldValue = allowed[msg.sender][_spender];\\n    if (_subtractedValue \\u003e= oldValue) {\\n      allowed[msg.sender][_spender] = 0;\\n    } else {\\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n    }\\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Internal function that mints an amount of the token and assigns it to\\n   * an account. This encapsulates the modification of balances such that the\\n   * proper events are emitted.\\n   * @param _account The account that will receive the created tokens.\\n   * @param _amount The amount that will be created.\\n   */\\n  function _mint(address _account, uint256 _amount) internal {\\n    require(_account != 0);\\n    totalSupply_ = totalSupply_.add(_amount);\\n    balances[_account] = balances[_account].add(_amount);\\n    emit Transfer(address(0), _account, _amount);\\n  }\\n\\n  /**\\n   * @dev Internal function that burns an amount of the token of a given\\n   * account.\\n   * @param _account The account whose tokens will be burnt.\\n   * @param _amount The amount that will be burnt.\\n   */\\n  function _burn(address _account, uint256 _amount) internal {\\n    require(_account != 0);\\n    require(_amount \\u003c= balances[_account]);\\n\\n    totalSupply_ = totalSupply_.sub(_amount);\\n    balances[_account] = balances[_account].sub(_amount);\\n    emit Transfer(_account, address(0), _amount);\\n  }\\n\\n  /**\\n   * @dev Internal function that burns an amount of the token of a given\\n   * account, deducting from the sender\\u0027s allowance for said account. Uses the\\n   * internal _burn function.\\n   * @param _account The account whose tokens will be burnt.\\n   * @param _amount The amount that will be burnt.\\n   */\\n  function _burnFrom(address _account, uint256 _amount) internal {\\n    require(_amount \\u003c= allowed[_account][msg.sender]);\\n\\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\\n    // this function needs to emit an event with the updated approval.\\n    allowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount);\\n    _burn(_account, _amount);\\n  }\\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"holderLockBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundPresaleHolderList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"subOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"presaleHolderList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holderList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isHolders\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalEthInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundsWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"lockAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_presales\",\"type\":\"uint256\"}],\"name\":\"presaleHolderRelease\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPresaleHolderCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"presaleJoinCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalHolderCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_presales\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_presalesETH\",\"type\":\"uint256\"},{\"name\":\"_presalesBTH\",\"type\":\"uint256\"},{\"name\":\"_presalesCASH\",\"type\":\"uint256\"},{\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"manualPresales\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lockStart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isLockHolders\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_presales\",\"type\":\"uint256\"}],\"name\":\"presaleHolderLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lockStop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalCash\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalRoundPresaleHolderCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"releaseAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"presalesAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_lockAmount\",\"type\":\"uint256\"}],\"name\":\"setHolderLockBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holderPresaleInfo\",\"outputs\":[{\"name\":\"presalesTime\",\"type\":\"uint256\"},{\"name\":\"presalesAmount\",\"type\":\"uint256\"},{\"name\":\"presalesETH\",\"type\":\"uint256\"},{\"name\":\"presalesBTC\",\"type\":\"uint256\"},{\"name\":\"presalesCASH\",\"type\":\"uint256\"},{\"name\":\"reason\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addSubOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalBtcInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeSubOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ReapChain","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://79f77caa05d12cdaaae99e71d2d2ad57772b2fc77f5aa49f2672cc44b7871c29"}]}