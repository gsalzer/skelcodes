{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.4;\r\n\r\n\r\ncontract Account {\r\n\r\n    // The implementation of the proxy\r\n    address public implementation;\r\n\r\n    // Logic manager\r\n    address public manager;\r\n    \r\n    // The enabled static calls\r\n    mapping (bytes4 => address) public enabled;\r\n\r\n    event EnabledStaticCall(address indexed module, bytes4 indexed method);\r\n    event Invoked(address indexed module, address indexed target, uint indexed value, bytes data);\r\n    event Received(uint indexed value, address indexed sender, bytes data);\r\n\r\n    event AccountInit(address indexed account);\r\n    event ManagerChanged(address indexed mgr);\r\n\r\n    modifier allowAuthorizedLogicContractsCallsOnly {\r\n        require(LogicManager(manager).isAuthorized(msg.sender), \"not an authorized logic\");\r\n        _;\r\n    }\r\n\r\n    function init(address _manager, address _accountStorage, address[] calldata _logics, address[] calldata _keys, address[] calldata _backups)\r\n        external\r\n    {\r\n        require(manager == address(0), \"Account: account already initialized\");\r\n        require(_manager != address(0) && _accountStorage != address(0), \"Account: address is null\");\r\n        manager = _manager;\r\n\r\n        for (uint i = 0; i < _logics.length; i++) {\r\n            address logic = _logics[i];\r\n            require(LogicManager(manager).isAuthorized(logic), \"must be authorized logic\");\r\n\r\n            BaseLogic(logic).initAccount(this);\r\n        }\r\n\r\n        AccountStorage(_accountStorage).initAccount(this, _keys, _backups);\r\n\r\n        emit AccountInit(address(this));\r\n    }\r\n\r\n    function invoke(address _target, uint _value, bytes calldata _data)\r\n        external\r\n        allowAuthorizedLogicContractsCallsOnly\r\n        returns (bytes memory _res)\r\n    {\r\n        bool success;\r\n        // solium-disable-next-line security/no-call-value\r\n        (success, _res) = _target.call.value(_value)(_data);\r\n        require(success, \"call to target failed\");\r\n        emit Invoked(msg.sender, _target, _value, _data);\r\n    }\r\n\r\n    /**\r\n    * @dev Enables a static method by specifying the target module to which the call must be delegated.\r\n    * @param _module The target module.\r\n    * @param _method The static method signature.\r\n    */\r\n    function enableStaticCall(address _module, bytes4 _method) external allowAuthorizedLogicContractsCallsOnly {\r\n        enabled[_method] = _module;\r\n        emit EnabledStaticCall(_module, _method);\r\n    }\r\n\r\n    function changeManager(address _newMgr) external allowAuthorizedLogicContractsCallsOnly {\r\n        require(_newMgr != address(0), \"address cannot be null\");\r\n        require(_newMgr != manager, \"already changed\");\r\n        manager = _newMgr;\r\n        emit ManagerChanged(_newMgr);\r\n    }\r\n\r\n     /**\r\n     * @dev This method makes it possible for the wallet to comply to interfaces expecting the wallet to\r\n     * implement specific static methods. It delegates the static call to a target contract if the data corresponds\r\n     * to an enabled method, or logs the call otherwise.\r\n     */\r\n    function() external payable {\r\n        if(msg.data.length > 0) {\r\n            address logic = enabled[msg.sig];\r\n            if(logic == address(0)) {\r\n                emit Received(msg.value, msg.sender, msg.data);\r\n            }\r\n            else {\r\n                require(LogicManager(manager).isAuthorized(logic), \"must be an authorized logic for static call\");\r\n                // solium-disable-next-line security/no-inline-assembly\r\n                assembly {\r\n                    calldatacopy(0, 0, calldatasize())\r\n                    let result := staticcall(gas, logic, 0, calldatasize(), 0, 0)\r\n                    returndatacopy(0, 0, returndatasize())\r\n                    switch result\r\n                    case 0 {revert(0, returndatasize())}\r\n                    default {return (0, returndatasize())}\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract Owned {\r\n\r\n    // The owner\r\n    address public owner;\r\n\r\n    event OwnerChanged(address indexed _newOwner);\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Must be owner\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Lets the owner transfer ownership of the contract to a new owner.\r\n     * @param _newOwner The new owner.\r\n     */\r\n    function changeOwner(address _newOwner) external onlyOwner {\r\n        require(_newOwner != address(0), \"Address must not be null\");\r\n        owner = _newOwner;\r\n        emit OwnerChanged(_newOwner);\r\n    }\r\n}\r\n\r\ncontract LogicManager is Owned {\r\n\r\n    event UpdateLogicSubmitted(address indexed logic, bool value);\r\n    event UpdateLogicCancelled(address indexed logic);\r\n    event UpdateLogicDone(address indexed logic, bool value);\r\n\r\n    struct pending {\r\n        bool value;\r\n        uint dueTime;\r\n    }\r\n\r\n    // The authorized logic modules\r\n    mapping (address => bool) public authorized;\r\n\r\n    /*\r\n    array\r\n    index 0: AccountLogic address\r\n          1: TransferLogic address\r\n          2: DualsigsLogic address\r\n          3: DappLogic address\r\n          4: ...\r\n     */\r\n    address[] public authorizedLogics;\r\n\r\n    // updated logics and their due time of becoming effective\r\n    mapping (address => pending) public pendingLogics;\r\n\r\n    // pending time before updated logics take effect\r\n    struct pendingTime {\r\n        uint curPendingTime;\r\n        uint nextPendingTime;\r\n        uint dueTime;\r\n    }\r\n\r\n    pendingTime public pt;\r\n\r\n    // how many authorized logics\r\n    uint public logicCount;\r\n\r\n    constructor(address[] memory _initialLogics, uint256 _pendingTime) public\r\n    {\r\n        for (uint i = 0; i < _initialLogics.length; i++) {\r\n            address logic = _initialLogics[i];\r\n            authorized[logic] = true;\r\n            logicCount += 1;\r\n        }\r\n        authorizedLogics = _initialLogics;\r\n\r\n        pt.curPendingTime = _pendingTime;\r\n        pt.nextPendingTime = _pendingTime;\r\n        pt.dueTime = now;\r\n    }\r\n\r\n    function submitUpdatePendingTime(uint _pendingTime) external onlyOwner {\r\n        pt.nextPendingTime = _pendingTime;\r\n        pt.dueTime = pt.curPendingTime + now;\r\n    }\r\n\r\n    function triggerUpdatePendingTime() external {\r\n        require(pt.dueTime <= now, \"too early to trigger updatePendingTime\");\r\n        pt.curPendingTime = pt.nextPendingTime;\r\n    }\r\n\r\n    function isAuthorized(address _logic) external view returns (bool) {\r\n        return authorized[_logic];\r\n    }\r\n\r\n    function getAuthorizedLogics() external view returns (address[] memory) {\r\n        return authorizedLogics;\r\n    }\r\n\r\n    function submitUpdate(address _logic, bool _value) external onlyOwner {\r\n        pending storage p = pendingLogics[_logic];\r\n        p.value = _value;\r\n        p.dueTime = now + pt.curPendingTime;\r\n        emit UpdateLogicSubmitted(_logic, _value);\r\n    }\r\n\r\n    function cancelUpdate(address _logic) external onlyOwner {\r\n        delete pendingLogics[_logic];\r\n        emit UpdateLogicCancelled(_logic);\r\n    }\r\n\r\n    function triggerUpdateLogic(address _logic) external {\r\n        pending memory p = pendingLogics[_logic];\r\n        require(p.dueTime > 0, \"pending logic not found\");\r\n        require(p.dueTime <= now, \"too early to trigger updateLogic\");\r\n        updateLogic(_logic, p.value);\r\n        delete pendingLogics[_logic];\r\n    }\r\n\r\n    function updateLogic(address _logic, bool _value) internal {\r\n        if (authorized[_logic] != _value) {\r\n            if(_value) {\r\n                logicCount += 1;\r\n                authorized[_logic] = true;\r\n                authorizedLogics.push(_logic);\r\n            }\r\n            else {\r\n                logicCount -= 1;\r\n                require(logicCount > 0, \"must have at least one logic module\");\r\n                delete authorized[_logic];\r\n                removeLogic(_logic);\r\n            }\r\n            emit UpdateLogicDone(_logic, _value);\r\n        }\r\n    }\r\n\r\n    function removeLogic(address _logic) internal {\r\n        uint len = authorizedLogics.length;\r\n        address lastLogic = authorizedLogics[len - 1];\r\n        if (_logic != lastLogic) {\r\n            for (uint i = 0; i < len; i++) {\r\n                 if (_logic == authorizedLogics[i]) {\r\n                     authorizedLogics[i] = lastLogic;\r\n                     break;\r\n                 }\r\n            }\r\n        }\r\n        authorizedLogics.length--;\r\n    }\r\n}\r\n\r\ncontract AccountStorage {\r\n\r\n    modifier allowAccountCallsOnly(Account _account) {\r\n        require(msg.sender == address(_account), \"caller must be account\");\r\n        _;\r\n    }\r\n\r\n    modifier allowAuthorizedLogicContractsCallsOnly(address payable _account) {\r\n        require(LogicManager(Account(_account).manager()).isAuthorized(msg.sender), \"not an authorized logic\");\r\n        _;\r\n    }\r\n\r\n    struct KeyItem {\r\n        address pubKey;\r\n        uint256 status;\r\n    }\r\n\r\n    struct BackupAccount {\r\n        address backup;\r\n        uint256 effectiveDate;//means not effective until this timestamp\r\n        uint256 expiryDate;//means effective until this timestamp\r\n    }\r\n\r\n    struct DelayItem {\r\n        bytes32 hash;\r\n        uint256 dueTime;\r\n    }\r\n\r\n    struct Proposal {\r\n        bytes32 hash;\r\n        address[] approval;\r\n    }\r\n\r\n    // account => quantity of operation keys (index >= 1)\r\n    mapping (address => uint256) operationKeyCount;\r\n\r\n    // account => index => KeyItem\r\n    mapping (address => mapping(uint256 => KeyItem)) keyData;\r\n\r\n    // account => index => backup account\r\n    mapping (address => mapping(uint256 => BackupAccount)) backupData;\r\n\r\n    /* account => actionId => DelayItem\r\n\r\n       delayData applies to these 4 actions:\r\n       changeAdminKey, changeAllOperationKeys, unfreeze, changeAdminKeyByBackup\r\n    */\r\n    mapping (address => mapping(bytes4 => DelayItem)) delayData;\r\n\r\n    // client account => proposer account => proposed actionId => Proposal\r\n    mapping (address => mapping(address => mapping(bytes4 => Proposal))) proposalData;\r\n\r\n    // *************** keyCount ********************** //\r\n\r\n    function getOperationKeyCount(address _account) external view returns(uint256) {\r\n        return operationKeyCount[_account];\r\n    }\r\n\r\n    function increaseKeyCount(address payable _account) external allowAuthorizedLogicContractsCallsOnly(_account) {\r\n        operationKeyCount[_account] = operationKeyCount[_account] + 1;\r\n    }\r\n\r\n    // *************** keyData ********************** //\r\n\r\n    function getKeyData(address _account, uint256 _index) public view returns(address) {\r\n        KeyItem memory item = keyData[_account][_index];\r\n        return item.pubKey;\r\n    }\r\n\r\n    function setKeyData(address payable _account, uint256 _index, address _key) external allowAuthorizedLogicContractsCallsOnly(_account) {\r\n        require(_key != address(0), \"invalid _key value\");\r\n        KeyItem storage item = keyData[_account][_index];\r\n        item.pubKey = _key;\r\n    }\r\n\r\n    // *************** keyStatus ********************** //\r\n\r\n    function getKeyStatus(address _account, uint256 _index) external view returns(uint256) {\r\n        KeyItem memory item = keyData[_account][_index];\r\n        return item.status;\r\n    }\r\n\r\n    function setKeyStatus(address payable _account, uint256 _index, uint256 _status) external allowAuthorizedLogicContractsCallsOnly(_account) {\r\n        KeyItem storage item = keyData[_account][_index];\r\n        item.status = _status;\r\n    }\r\n\r\n    // *************** backupData ********************** //\r\n\r\n    function getBackupAddress(address _account, uint256 _index) external view returns(address) {\r\n        BackupAccount memory b = backupData[_account][_index];\r\n        return b.backup;\r\n    }\r\n\r\n    function getBackupEffectiveDate(address _account, uint256 _index) external view returns(uint256) {\r\n        BackupAccount memory b = backupData[_account][_index];\r\n        return b.effectiveDate;\r\n    }\r\n\r\n    function getBackupExpiryDate(address _account, uint256 _index) external view returns(uint256) {\r\n        BackupAccount memory b = backupData[_account][_index];\r\n        return b.expiryDate;\r\n    }\r\n\r\n    function setBackup(address payable _account, uint256 _index, address _backup, uint256 _effective, uint256 _expiry)\r\n        external\r\n        allowAuthorizedLogicContractsCallsOnly(_account)\r\n    {\r\n        BackupAccount storage b = backupData[_account][_index];\r\n        b.backup = _backup;\r\n        b.effectiveDate = _effective;\r\n        b.expiryDate = _expiry;\r\n    }\r\n\r\n    function setBackupExpiryDate(address payable _account, uint256 _index, uint256 _expiry)\r\n        external\r\n        allowAuthorizedLogicContractsCallsOnly(_account)\r\n    {\r\n        BackupAccount storage b = backupData[_account][_index];\r\n        b.expiryDate = _expiry;\r\n    }\r\n\r\n    function clearBackupData(address payable _account, uint256 _index) external allowAuthorizedLogicContractsCallsOnly(_account) {\r\n        delete backupData[_account][_index];\r\n    }\r\n\r\n    // *************** delayData ********************** //\r\n\r\n    function getDelayDataHash(address payable _account, bytes4 _actionId) external view returns(bytes32) {\r\n        DelayItem memory item = delayData[_account][_actionId];\r\n        return item.hash;\r\n    }\r\n\r\n    function getDelayDataDueTime(address payable _account, bytes4 _actionId) external view returns(uint256) {\r\n        DelayItem memory item = delayData[_account][_actionId];\r\n        return item.dueTime;\r\n    }\r\n\r\n    function setDelayData(address payable _account, bytes4 _actionId, bytes32 _hash, uint256 _dueTime) external allowAuthorizedLogicContractsCallsOnly(_account) {\r\n        DelayItem storage item = delayData[_account][_actionId];\r\n        item.hash = _hash;\r\n        item.dueTime = _dueTime;\r\n    }\r\n\r\n    function clearDelayData(address payable _account, bytes4 _actionId) external allowAuthorizedLogicContractsCallsOnly(_account) {\r\n        delete delayData[_account][_actionId];\r\n    }\r\n\r\n    // *************** proposalData ********************** //\r\n\r\n    function getProposalDataHash(address _client, address _proposer, bytes4 _actionId) external view returns(bytes32) {\r\n        Proposal memory p = proposalData[_client][_proposer][_actionId];\r\n        return p.hash;\r\n    }\r\n\r\n    function getProposalDataApproval(address _client, address _proposer, bytes4 _actionId) external view returns(address[] memory) {\r\n        Proposal memory p = proposalData[_client][_proposer][_actionId];\r\n        return p.approval;\r\n    }\r\n\r\n    function setProposalData(address payable _client, address _proposer, bytes4 _actionId, bytes32 _hash, address _approvedBackup)\r\n        external\r\n        allowAuthorizedLogicContractsCallsOnly(_client)\r\n    {\r\n        Proposal storage p = proposalData[_client][_proposer][_actionId];\r\n        if (p.hash > 0) {\r\n            if (p.hash == _hash) {\r\n                for (uint256 i = 0; i < p.approval.length; i++) {\r\n                    require(p.approval[i] != _approvedBackup, \"backup already exists\");\r\n                }\r\n                p.approval.push(_approvedBackup);\r\n            } else {\r\n                p.hash = _hash;\r\n                p.approval.length = 0;\r\n            }\r\n        } else {\r\n            p.hash = _hash;\r\n            p.approval.push(_approvedBackup);\r\n        }\r\n    }\r\n\r\n    function clearProposalData(address payable _client, address _proposer, bytes4 _actionId) external allowAuthorizedLogicContractsCallsOnly(_client) {\r\n        delete proposalData[_client][_proposer][_actionId];\r\n    }\r\n\r\n\r\n    // *************** init ********************** //\r\n    function initAccount(Account _account, address[] calldata _keys, address[] calldata _backups)\r\n        external\r\n        allowAccountCallsOnly(_account)\r\n    {\r\n        require(getKeyData(address(_account), 0) == address(0), \"AccountStorage: account already initialized!\");\r\n        require(_keys.length > 0, \"empty keys array\");\r\n\r\n        operationKeyCount[address(_account)] = _keys.length - 1;\r\n\r\n        for (uint256 index = 0; index < _keys.length; index++) {\r\n            address _key = _keys[index];\r\n            require(_key != address(0), \"_key cannot be 0x0\");\r\n            KeyItem storage item = keyData[address(_account)][index];\r\n            item.pubKey = _key;\r\n            item.status = 0;\r\n        }\r\n\r\n        // avoid backup duplication if _backups.length > 1\r\n        // normally won't check duplication, in most cases only one initial backup when initialization\r\n        if (_backups.length > 1) {\r\n            address[] memory bkps = _backups;\r\n            for (uint256 i = 0; i < _backups.length; i++) {\r\n                for (uint256 j = 0; j < i; j++) {\r\n                    require(bkps[j] != _backups[i], \"duplicate backup\");\r\n                }\r\n            }\r\n        }\r\n\r\n        for (uint256 index = 0; index < _backups.length; index++) {\r\n            address _backup = _backups[index];\r\n            require(_backup != address(0), \"backup cannot be 0x0\");\r\n            require(_backup != address(_account), \"cannot be backup of oneself\");\r\n\r\n            backupData[address(_account)][index] = BackupAccount(_backup, now, uint256(-1));\r\n        }\r\n    }\r\n}\r\n\r\n/* The MIT License (MIT)\r\n\r\nCopyright (c) 2016 Smart Contract Solutions, Inc.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included\r\nin all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns ceil(a / b).\r\n    */\r\n    function ceil(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        if(a % b == 0) {\r\n            return c;\r\n        }\r\n        else {\r\n            return c + 1;\r\n        }\r\n    }\r\n}\r\n\r\ncontract BaseLogic {\r\n\r\n    bytes constant internal SIGN_HASH_PREFIX = \"\\x19Ethereum Signed Message:\\n32\";\r\n\r\n    mapping (address => uint256) keyNonce;\r\n    AccountStorage public accountStorage;\r\n\r\n    modifier allowSelfCallsOnly() {\r\n        require (msg.sender == address(this), \"only internal call is allowed\");\r\n        _;\r\n    }\r\n\r\n    modifier allowAccountCallsOnly(Account _account) {\r\n        require(msg.sender == address(_account), \"caller must be account\");\r\n        _;\r\n    }\r\n\r\n    event LogicInitialised(address wallet);\r\n\r\n    // *************** Constructor ********************** //\r\n\r\n    constructor(AccountStorage _accountStorage) public {\r\n        accountStorage = _accountStorage;\r\n    }\r\n\r\n    // *************** Initialization ********************* //\r\n\r\n    function initAccount(Account _account) external allowAccountCallsOnly(_account){\r\n        emit LogicInitialised(address(_account));\r\n    }\r\n\r\n    // *************** Getter ********************** //\r\n\r\n    function getKeyNonce(address _key) external view returns(uint256) {\r\n        return keyNonce[_key];\r\n    }\r\n\r\n    // *************** Signature ********************** //\r\n\r\n    function getSignHash(bytes memory _data, uint256 _nonce) internal view returns(bytes32) {\r\n        // use EIP 191\r\n        // 0x1900 + this logic address + data + nonce of signing key\r\n        bytes32 msgHash = keccak256(abi.encodePacked(byte(0x19), byte(0), address(this), _data, _nonce));\r\n        bytes32 prefixedHash = keccak256(abi.encodePacked(SIGN_HASH_PREFIX, msgHash));\r\n        return prefixedHash;\r\n    }\r\n\r\n    function verifySig(address _signingKey, bytes memory _signature, bytes32 _signHash) internal pure {\r\n        require(_signingKey != address(0), \"invalid signing key\");\r\n        address recoveredAddr = recover(_signHash, _signature);\r\n        require(recoveredAddr == _signingKey, \"signature verification failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * NOTE: This call _does not revert_ if the signature is invalid, or\r\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\r\n     * the zero address is returned.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise)\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            return address(0);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    /* get signer address from data\r\n    * @dev Gets an address encoded as the first argument in transaction data\r\n    * @param b The byte array that should have an address as first argument\r\n    * @returns a The address retrieved from the array\r\n    */\r\n    function getSignerAddress(bytes memory _b) internal pure returns (address _a) {\r\n        require(_b.length >= 36, \"invalid bytes\");\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let mask := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\r\n            _a := and(mask, mload(add(_b, 36)))\r\n            // b = {length:32}{method sig:4}{address:32}{...}\r\n            // 36 is the offset of the first parameter of the data, if encoded properly.\r\n            // 32 bytes for the length of the bytes array, and the first 4 bytes for the function signature.\r\n            // 32 bytes is the length of the bytes array!!!!\r\n        }\r\n    }\r\n\r\n    // get method id, first 4 bytes of data\r\n    function getMethodId(bytes memory _b) internal pure returns (bytes4 _a) {\r\n        require(_b.length >= 4, \"invalid data\");\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            // 32 bytes is the length of the bytes array\r\n            _a := mload(add(_b, 32))\r\n        }\r\n    }\r\n\r\n    function checkKeyStatus(address _account, uint256 _index) internal view {\r\n        // check operation key status\r\n        if (_index > 0) {\r\n            require(accountStorage.getKeyStatus(_account, _index) != 1, \"frozen key\");\r\n        }\r\n    }\r\n\r\n    // _nonce is timestamp in microsecond(1/1000000 second)\r\n    function checkAndUpdateNonce(address _key, uint256 _nonce) internal {\r\n        require(_nonce > keyNonce[_key], \"nonce too small\");\r\n        require(SafeMath.div(_nonce, 1000000) <= now + 86400, \"nonce too big\"); // 86400=24*3600 seconds\r\n\r\n        keyNonce[_key] = _nonce;\r\n    }\r\n}\r\n\r\ncontract AccountBaseLogic is BaseLogic {\r\n\r\n    uint256 constant internal DELAY_CHANGE_ADMIN_KEY = 21 days;\r\n    uint256 constant internal DELAY_CHANGE_OPERATION_KEY = 7 days;\r\n    uint256 constant internal DELAY_UNFREEZE_KEY = 7 days;\r\n    uint256 constant internal DELAY_CHANGE_BACKUP = 21 days;\r\n    uint256 constant internal DELAY_CHANGE_ADMIN_KEY_BY_BACKUP = 30 days;\r\n\r\n    uint256 constant internal MAX_DEFINED_BACKUP_INDEX = 5;\r\n\r\n\t// Equals to bytes4(keccak256(\"changeAdminKey(address,address)\"))\r\n\tbytes4 internal constant CHANGE_ADMIN_KEY = 0xd595d935;\r\n\t// Equals to bytes4(keccak256(\"changeAdminKeyByBackup(address,address)\"))\r\n\tbytes4 internal constant CHANGE_ADMIN_KEY_BY_BACKUP = 0xfdd54ba1;\r\n\t// Equals to bytes4(keccak256(\"changeAdminKeyWithoutDelay(address,address)\"))\r\n\tbytes4 internal constant CHANGE_ADMIN_KEY_WITHOUT_DELAY = 0x441d2e50;\r\n\t// Equals to bytes4(keccak256(\"changeAllOperationKeys(address,address[])\"))\r\n\tbytes4 internal constant CHANGE_ALL_OPERATION_KEYS = 0xd3b9d4d6;\r\n\t// Equals to bytes4(keccak256(\"unfreeze(address)\"))\r\n\tbytes4 internal constant UNFREEZE = 0x45c8b1a6;\r\n\r\n    event ProposalExecuted(address indexed client, address indexed proposer, bytes functionData);\r\n\r\n    // *************** Constructor ********************** //\r\n\r\n\tconstructor(AccountStorage _accountStorage)\r\n\t\tBaseLogic(_accountStorage)\r\n\t\tpublic\r\n\t{\r\n\t}\r\n\r\n    // *************** Proposal ********************** //\r\n\r\n    /* ‘executeProposal’ is shared by AccountLogic and DualsigsLogic,\r\n       proposed actions called from 'executeProposal':\r\n         AccountLogic: changeAdminKeyByBackup\r\n         DualsigsLogic: changeAdminKeyWithoutDelay, changeAllOperationKeysWithoutDelay, unfreezeWithoutDelay\r\n    */\r\n    function executeProposal(address payable _client, address _proposer, bytes calldata _functionData) external {\r\n        bytes4 proposedActionId = getMethodId(_functionData);\r\n        bytes32 functionHash = keccak256(_functionData);\r\n\r\n        checkApproval(_client, _proposer, proposedActionId, functionHash);\r\n\r\n        // call functions with/without delay\r\n        // solium-disable-next-line security/no-low-level-calls\r\n        (bool success,) = address(this).call(_functionData);\r\n        require(success, \"executeProposal failed\");\r\n\r\n        accountStorage.clearProposalData(_client, _proposer, proposedActionId);\r\n        emit ProposalExecuted(_client, _proposer, _functionData);\r\n    }\r\n\r\n    function checkApproval(address _client, address _proposer, bytes4 _proposedActionId, bytes32 _functionHash) internal view {\r\n        bytes32 hash = accountStorage.getProposalDataHash(_client, _proposer, _proposedActionId);\r\n        require(hash == _functionHash, \"proposal hash unmatch\");\r\n\r\n        uint256 backupCount;\r\n        uint256 approvedCount;\r\n        address[] memory approved = accountStorage.getProposalDataApproval(_client, _proposer, _proposedActionId);\r\n        require(approved.length > 0, \"no approval\");\r\n\r\n        // iterate backup list\r\n        for (uint256 i = 0; i <= MAX_DEFINED_BACKUP_INDEX; i++) {\r\n            address backup = accountStorage.getBackupAddress(_client, i);\r\n            uint256 effectiveDate = accountStorage.getBackupEffectiveDate(_client, i);\r\n            uint256 expiryDate = accountStorage.getBackupExpiryDate(_client, i);\r\n            if (backup != address(0) && isEffectiveBackup(effectiveDate, expiryDate)) {\r\n                // count how many backups in backup list\r\n                backupCount += 1;\r\n                // iterate approved array\r\n                for (uint256 k = 0; k < approved.length; k++) {\r\n                    if (backup == approved[k]) {\r\n                       // count how many approved backups still exist in backup list\r\n                       approvedCount += 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        require(backupCount > 0, \"no backup in list\");\r\n        uint256 threshold = SafeMath.ceil(backupCount*6, 10);\r\n        require(approvedCount >= threshold, \"must have 60% approval at least\");\r\n    }\r\n\r\n    function checkRelation(address _client, address _backup) internal view {\r\n        require(_backup != address(0), \"backup cannot be 0x0\");\r\n        require(_client != address(0), \"client cannot be 0x0\");\r\n        bool isBackup;\r\n        for (uint256 i = 0; i <= MAX_DEFINED_BACKUP_INDEX; i++) {\r\n            address backup = accountStorage.getBackupAddress(_client, i);\r\n            uint256 effectiveDate = accountStorage.getBackupEffectiveDate(_client, i);\r\n            uint256 expiryDate = accountStorage.getBackupExpiryDate(_client, i);\r\n            // backup match and effective and not expired\r\n            if (_backup == backup && isEffectiveBackup(effectiveDate, expiryDate)) {\r\n                isBackup = true;\r\n                break;\r\n            }\r\n        }\r\n        require(isBackup, \"backup does not exist in list\");\r\n    }\r\n\r\n    function isEffectiveBackup(uint256 _effectiveDate, uint256 _expiryDate) internal view returns(bool) {\r\n        return (_effectiveDate <= now) && (_expiryDate > now);\r\n    }\r\n\r\n    function clearRelatedProposalAfterAdminKeyChanged(address payable _client) internal {\r\n        //clear any existing proposal proposed by both, proposer is _client\r\n        accountStorage.clearProposalData(_client, _client, CHANGE_ADMIN_KEY_WITHOUT_DELAY);\r\n\r\n        //clear any existing proposal proposed by backup, proposer is one of the backups\r\n        for (uint256 i = 0; i <= MAX_DEFINED_BACKUP_INDEX; i++) {\r\n            address backup = accountStorage.getBackupAddress(_client, i);\r\n            uint256 effectiveDate = accountStorage.getBackupEffectiveDate(_client, i);\r\n            uint256 expiryDate = accountStorage.getBackupExpiryDate(_client, i);\r\n            if (backup != address(0) && isEffectiveBackup(effectiveDate, expiryDate)) {\r\n                accountStorage.clearProposalData(_client, backup, CHANGE_ADMIN_KEY_BY_BACKUP);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/**\r\n* @title AccountLogic\r\n*/\r\ncontract AccountLogic is AccountBaseLogic {\r\n\r\n    /*\r\n    index 0: admin key\r\n          1: asset(transfer)\r\n          2: adding\r\n          3: reserved(dapp)\r\n          4: assist\r\n     */\r\n    uint constant internal DAPP_KEY_INDEX = 3;\r\n\r\n\t// Equals to bytes4(keccak256(\"addOperationKey(address,address)\"))\r\n\tbytes4 private constant ADD_OPERATION_KEY = 0x9a7f6101;\r\n\t// Equals to bytes4(keccak256(\"proposeAsBackup(address,address,bytes)\"))\r\n\tbytes4 private constant PROPOSE_AS_BACKUP = 0xd470470f;\r\n\t// Equals to bytes4(keccak256(\"approveProposal(address,address,address,bytes)\"))\r\n\tbytes4 private constant APPROVE_PROPOSAL = 0x3713f742;\r\n\r\n    //0x20c13b0b\r\n    bytes4 private constant ERC1271_ISVALIDSIGNATURE_BYTES = bytes4(keccak256(\"isValidSignature(bytes,bytes)\"));\r\n\t//0x1626ba7e\r\n    bytes4 private constant ERC1271_ISVALIDSIGNATURE_BYTES32 = bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"));\r\n\r\n    event AccountLogicEntered(bytes data, uint256 indexed nonce);\r\n\tevent AccountLogicInitialised(address indexed account);\r\n\tevent ChangeAdminKeyTriggered(address indexed account, address pkNew);\r\n\tevent ChangeAdminKeyByBackupTriggered(address indexed account, address pkNew);\r\n\tevent ChangeAllOperationKeysTriggered(address indexed account, address[] pks);\r\n\tevent UnfreezeTriggered(address indexed account);\r\n\r\n\tevent ChangeAdminKey(address indexed account, address indexed pkNew);\r\n\tevent ChangeAdminKeyByBackup(address indexed account, address indexed pkNew);\r\n\tevent AddOperationKey(address indexed account, address indexed pkNew);\r\n\tevent ChangeAllOperationKeys(address indexed account, address[] pks);\r\n\tevent Freeze(address indexed account);\r\n\tevent Unfreeze(address indexed account);\r\n\tevent RemoveBackup(address indexed account, address indexed backup);\r\n\tevent CancelDelay(address indexed account, bytes4 actionId);\r\n\tevent CancelAddBackup(address indexed account, address indexed backup);\r\n\tevent CancelRemoveBackup(address indexed account, address indexed backup);\r\n\tevent ProposeAsBackup(address indexed backup, address indexed client, bytes data);\r\n\tevent ApproveProposal(address indexed backup, address indexed client, address indexed proposer, bytes data);\r\n\tevent CancelProposal(address indexed client, address indexed proposer, bytes4 proposedActionId);\r\n\r\n\t// *************** Constructor ********************** //\r\n\r\n\tconstructor(AccountStorage _accountStorage)\r\n\t\tAccountBaseLogic(_accountStorage)\r\n\t\tpublic\r\n\t{\r\n\t}\r\n\r\n    // *************** Initialization ********************* //\r\n\r\n\tfunction initAccount(Account _account) external allowAccountCallsOnly(_account){\r\n\t\t_account.enableStaticCall(address(this), ERC1271_ISVALIDSIGNATURE_BYTES);\r\n\t\t_account.enableStaticCall(address(this), ERC1271_ISVALIDSIGNATURE_BYTES32);\r\n        emit AccountLogicInitialised(address(_account));\r\n    }\r\n\r\n\t// *************** action entry ********************** //\r\n\r\n    /* AccountLogic has 12 actions called from 'enter':\r\n        changeAdminKey, addOperationKey, changeAllOperationKeys, freeze, unfreeze,\r\n\t\tremoveBackup, cancelDelay, cancelAddBackup, cancelRemoveBackup,\r\n\t\tproposeAsBackup, approveProposal, cancelProposal\r\n\t*/\r\n\tfunction enter(bytes calldata _data, bytes calldata _signature, uint256 _nonce) external {\r\n\t\trequire(getMethodId(_data) != CHANGE_ADMIN_KEY_BY_BACKUP, \"invalid data\");\r\n\t\taddress account = getSignerAddress(_data);\r\n\t\tuint256 keyIndex = getKeyIndex(_data);\r\n\t\tcheckKeyStatus(account, keyIndex);\r\n\t\taddress signingKey = accountStorage.getKeyData(account, keyIndex);\r\n\t\tcheckAndUpdateNonce(signingKey, _nonce);\r\n\t\tbytes32 signHash = getSignHash(_data, _nonce);\r\n\t\tverifySig(signingKey, _signature, signHash);\r\n\r\n\t\t// solium-disable-next-line security/no-low-level-calls\r\n\t\t(bool success,) = address(this).call(_data);\r\n\t\trequire(success, \"calling self failed\");\r\n\t\temit AccountLogicEntered(_data, _nonce);\r\n\t}\r\n\r\n\t// *************** change admin key ********************** //\r\n\r\n    // called from 'enter'\r\n\tfunction changeAdminKey(address payable _account, address _pkNew) external allowSelfCallsOnly {\r\n\t\trequire(_pkNew != address(0), \"0x0 is invalid\");\r\n\t\taddress pk = accountStorage.getKeyData(_account, 0);\r\n\t\trequire(pk != _pkNew, \"identical admin key exists\");\r\n\t\trequire(accountStorage.getDelayDataHash(_account, CHANGE_ADMIN_KEY) == 0, \"delay data already exists\");\r\n\t\tbytes32 hash = keccak256(abi.encodePacked('changeAdminKey', _account, _pkNew));\r\n\t\taccountStorage.setDelayData(_account, CHANGE_ADMIN_KEY, hash, now + DELAY_CHANGE_ADMIN_KEY);\r\n\t\temit ChangeAdminKey(_account, _pkNew);\r\n\t}\r\n\r\n    // called from external\r\n\tfunction triggerChangeAdminKey(address payable _account, address _pkNew) external {\r\n\t\tbytes32 hash = keccak256(abi.encodePacked('changeAdminKey', _account, _pkNew));\r\n\t\trequire(hash == accountStorage.getDelayDataHash(_account, CHANGE_ADMIN_KEY), \"delay hash unmatch\");\r\n\r\n\t\tuint256 due = accountStorage.getDelayDataDueTime(_account, CHANGE_ADMIN_KEY);\r\n\t\trequire(due > 0, \"delay data not found\");\r\n\t\trequire(due <= now, \"too early to trigger changeAdminKey\");\r\n\t\taccountStorage.setKeyData(_account, 0, _pkNew);\r\n\t\t//clear any existing related delay data and proposal\r\n\t\taccountStorage.clearDelayData(_account, CHANGE_ADMIN_KEY);\r\n\t\taccountStorage.clearDelayData(_account, CHANGE_ADMIN_KEY_BY_BACKUP);\r\n\t\tclearRelatedProposalAfterAdminKeyChanged(_account);\r\n\t\temit ChangeAdminKeyTriggered(_account, _pkNew);\r\n\t}\r\n\r\n\t// *************** change admin key by backup proposal ********************** //\r\n\r\n    // called from 'executeProposal'\r\n\tfunction changeAdminKeyByBackup(address payable _account, address _pkNew) external allowSelfCallsOnly {\r\n\t\trequire(_pkNew != address(0), \"0x0 is invalid\");\r\n\t\taddress pk = accountStorage.getKeyData(_account, 0);\r\n\t\trequire(pk != _pkNew, \"identical admin key exists\");\r\n\t\trequire(accountStorage.getDelayDataHash(_account, CHANGE_ADMIN_KEY_BY_BACKUP) == 0, \"delay data already exists\");\r\n\t\tbytes32 hash = keccak256(abi.encodePacked('changeAdminKeyByBackup', _account, _pkNew));\r\n\t\taccountStorage.setDelayData(_account, CHANGE_ADMIN_KEY_BY_BACKUP, hash, now + DELAY_CHANGE_ADMIN_KEY_BY_BACKUP);\r\n\t\temit ChangeAdminKeyByBackup(_account, _pkNew);\r\n\t}\r\n\r\n    // called from external\r\n\tfunction triggerChangeAdminKeyByBackup(address payable _account, address _pkNew) external {\r\n\t\tbytes32 hash = keccak256(abi.encodePacked('changeAdminKeyByBackup', _account, _pkNew));\r\n\t\trequire(hash == accountStorage.getDelayDataHash(_account, CHANGE_ADMIN_KEY_BY_BACKUP), \"delay hash unmatch\");\r\n\r\n\t\tuint256 due = accountStorage.getDelayDataDueTime(_account, CHANGE_ADMIN_KEY_BY_BACKUP);\r\n\t\trequire(due > 0, \"delay data not found\");\r\n\t\trequire(due <= now, \"too early to trigger changeAdminKeyByBackup\");\r\n\t\taccountStorage.setKeyData(_account, 0, _pkNew);\r\n\t\t//clear any existing related delay data and proposal\r\n\t\taccountStorage.clearDelayData(_account, CHANGE_ADMIN_KEY_BY_BACKUP);\r\n\t\taccountStorage.clearDelayData(_account, CHANGE_ADMIN_KEY);\r\n\t\tclearRelatedProposalAfterAdminKeyChanged(_account);\r\n\t\temit ChangeAdminKeyByBackupTriggered(_account, _pkNew);\r\n\t}\r\n\r\n\t// *************** add operation key ********************** //\r\n\r\n    // called from 'enter'\r\n\tfunction addOperationKey(address payable _account, address _pkNew) external allowSelfCallsOnly {\r\n\t\tuint256 index = accountStorage.getOperationKeyCount(_account) + 1;\r\n\t\trequire(index > 0, \"invalid operation key index\");\r\n\t\t// set a limit to prevent unnecessary trouble\r\n\t\trequire(index < 20, \"index exceeds limit\");\r\n\t\trequire(_pkNew != address(0), \"0x0 is invalid\");\r\n\t\taddress pk = accountStorage.getKeyData(_account, index);\r\n\t\trequire(pk == address(0), \"operation key already exists\");\r\n\t\taccountStorage.setKeyData(_account, index, _pkNew);\r\n\t\taccountStorage.increaseKeyCount(_account);\r\n\t\temit AddOperationKey(_account, _pkNew);\r\n\t}\r\n\r\n\t// *************** change all operation keys ********************** //\r\n\r\n    // called from 'enter'\r\n\tfunction changeAllOperationKeys(address payable _account, address[] calldata _pks) external allowSelfCallsOnly {\r\n\t\tuint256 keyCount = accountStorage.getOperationKeyCount(_account);\r\n\t\trequire(_pks.length == keyCount, \"invalid number of keys\");\r\n\t\trequire(accountStorage.getDelayDataHash(_account, CHANGE_ALL_OPERATION_KEYS) == 0, \"delay data already exists\");\r\n\t\taddress pk;\r\n\t\tfor (uint256 i = 0; i < keyCount; i++) {\r\n\t\t\tpk = _pks[i];\r\n\t\t\trequire(pk != address(0), \"0x0 is invalid\");\r\n\t\t}\r\n\t\tbytes32 hash = keccak256(abi.encodePacked('changeAllOperationKeys', _account, _pks));\r\n\t\taccountStorage.setDelayData(_account, CHANGE_ALL_OPERATION_KEYS, hash, now + DELAY_CHANGE_OPERATION_KEY);\r\n\t\temit ChangeAllOperationKeys(_account, _pks);\r\n\t}\r\n\r\n    // called from external\r\n\tfunction triggerChangeAllOperationKeys(address payable _account, address[] calldata _pks) external {\r\n\t\tbytes32 hash = keccak256(abi.encodePacked('changeAllOperationKeys', _account, _pks));\r\n\t\trequire(hash == accountStorage.getDelayDataHash(_account, CHANGE_ALL_OPERATION_KEYS), \"delay hash unmatch\");\r\n\r\n\t\tuint256 due = accountStorage.getDelayDataDueTime(_account, CHANGE_ALL_OPERATION_KEYS);\r\n\t\trequire(due > 0, \"delay data not found\");\r\n\t\trequire(due <= now, \"too early to trigger changeAllOperationKeys\");\r\n\t\taddress pk;\r\n\t\tfor (uint256 i = 0; i < accountStorage.getOperationKeyCount(_account); i++) {\r\n\t\t\tpk = _pks[i];\r\n\t\t\taccountStorage.setKeyData(_account, i+1, pk);\r\n\t\t\taccountStorage.setKeyStatus(_account, i+1, 0);\r\n\t\t}\r\n\t\taccountStorage.clearDelayData(_account, CHANGE_ALL_OPERATION_KEYS);\r\n\t\temit ChangeAllOperationKeysTriggered(_account, _pks);\r\n\t}\r\n\r\n\t// *************** freeze/unfreeze all operation keys ********************** //\r\n\r\n    // called from 'enter'\r\n\tfunction freeze(address payable _account) external allowSelfCallsOnly {\r\n\t\tfor (uint256 i = 1; i <= accountStorage.getOperationKeyCount(_account); i++) {\r\n\t\t\tif (accountStorage.getKeyStatus(_account, i) == 0) {\r\n\t\t\t\taccountStorage.setKeyStatus(_account, i, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\temit Freeze(_account);\r\n\t}\r\n\r\n    // called from 'enter'\r\n\tfunction unfreeze(address payable _account) external allowSelfCallsOnly {\r\n\t\trequire(accountStorage.getDelayDataHash(_account, UNFREEZE) == 0, \"delay data already exists\");\r\n\t\tbytes32 hash = keccak256(abi.encodePacked('unfreeze', _account));\r\n\t\taccountStorage.setDelayData(_account, UNFREEZE, hash, now + DELAY_UNFREEZE_KEY);\r\n\t\temit Unfreeze(_account);\r\n\t}\r\n\r\n    // called from external\r\n\tfunction triggerUnfreeze(address payable _account) external {\r\n\t\tbytes32 hash = keccak256(abi.encodePacked('unfreeze', _account));\r\n\t\trequire(hash == accountStorage.getDelayDataHash(_account, UNFREEZE), \"delay hash unmatch\");\r\n\r\n\t\tuint256 due = accountStorage.getDelayDataDueTime(_account, UNFREEZE);\r\n\t\trequire(due > 0, \"delay data not found\");\r\n\t\trequire(due <= now, \"too early to trigger unfreeze\");\r\n\r\n\t\tfor (uint256 i = 1; i <= accountStorage.getOperationKeyCount(_account); i++) {\r\n\t\t\tif (accountStorage.getKeyStatus(_account, i) == 1) {\r\n\t\t\t\taccountStorage.setKeyStatus(_account, i, 0);\r\n\t\t\t}\r\n\t\t}\r\n\t\taccountStorage.clearDelayData(_account, UNFREEZE);\r\n\t\temit UnfreezeTriggered(_account);\r\n\t}\r\n\r\n\t// *************** remove backup ********************** //\r\n\r\n    // called from 'enter'\r\n\tfunction removeBackup(address payable _account, address _backup) external allowSelfCallsOnly {\r\n\t\tuint256 index = findBackup(_account, _backup);\r\n\t\trequire(index <= MAX_DEFINED_BACKUP_INDEX, \"backup invalid or not exist\");\r\n\r\n\t\taccountStorage.setBackupExpiryDate(_account, index, now + DELAY_CHANGE_BACKUP);\r\n\t\temit RemoveBackup(_account, _backup);\r\n\t}\r\n\r\n    // return backupData index(0~5), 6 means not found\r\n    // do make sure _backup is not 0x0\r\n\tfunction findBackup(address _account, address _backup) public view returns(uint) {\r\n\t\tuint index = MAX_DEFINED_BACKUP_INDEX + 1;\r\n\t\tif (_backup == address(0)) {\r\n\t\t\treturn index;\r\n\t\t}\r\n\t\taddress b;\r\n\t\tfor (uint256 i = 0; i <= MAX_DEFINED_BACKUP_INDEX; i++) {\r\n\t\t\tb = accountStorage.getBackupAddress(_account, i);\r\n\t\t\tif (b == _backup) {\r\n\t\t\t\tindex = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn index;\r\n\t}\r\n\r\n\t// *************** cancel delay action ********************** //\r\n\r\n    // called from 'enter'\r\n\tfunction cancelDelay(address payable _account, bytes4 _actionId) external allowSelfCallsOnly {\r\n\t\taccountStorage.clearDelayData(_account, _actionId);\r\n\t\temit CancelDelay(_account, _actionId);\r\n\t}\r\n\r\n    // called from 'enter'\r\n\tfunction cancelAddBackup(address payable _account, address _backup) external allowSelfCallsOnly {\r\n\t\tuint256 index = findBackup(_account, _backup);\r\n\t\trequire(index <= MAX_DEFINED_BACKUP_INDEX, \"backup invalid or not exist\");\r\n\t\tuint256 effectiveDate = accountStorage.getBackupEffectiveDate(_account, index);\r\n\t\trequire(effectiveDate > now, \"already effective\");\r\n\t\taccountStorage.clearBackupData(_account, index);\r\n\t\temit CancelAddBackup(_account, _backup);\r\n\t}\r\n\r\n    // called from 'enter'\r\n\tfunction cancelRemoveBackup(address payable _account, address _backup) external allowSelfCallsOnly {\r\n\t\tuint256 index = findBackup(_account, _backup);\r\n\t\trequire(index <= MAX_DEFINED_BACKUP_INDEX, \"backup invalid or not exist\");\r\n\t\tuint256 expiryDate = accountStorage.getBackupExpiryDate(_account, index);\r\n\t\trequire(expiryDate > now, \"already expired\");\r\n\t\taccountStorage.setBackupExpiryDate(_account, index, uint256(-1));\r\n\t\temit CancelRemoveBackup(_account, _backup);\r\n\t}\r\n\r\n\t// *************** propose, approve and cancel proposal ********************** //\r\n\r\n    // called from 'enter'\r\n\t// proposer is backup in the case of 'proposeAsBackup'\r\n\tfunction proposeAsBackup(address _backup, address payable _client, bytes calldata _functionData) external allowSelfCallsOnly {\r\n\t\tbytes4 proposedActionId = getMethodId(_functionData);\r\n\t\trequire(proposedActionId == CHANGE_ADMIN_KEY_BY_BACKUP, \"invalid proposal by backup\");\r\n\t\tcheckRelation(_client, _backup);\r\n\t\tbytes32 functionHash = keccak256(_functionData);\r\n\t\taccountStorage.setProposalData(_client, _backup, proposedActionId, functionHash, _backup);\r\n\t\temit ProposeAsBackup(_backup, _client, _functionData);\r\n\t}\r\n\r\n    // called from 'enter'\r\n\tfunction approveProposal(address _backup, address payable _client, address _proposer, bytes calldata _functionData) external allowSelfCallsOnly {\r\n\t\tbytes32 functionHash = keccak256(_functionData);\r\n\t\trequire(functionHash != 0, \"invalid hash\");\r\n\t\tcheckRelation(_client, _backup);\r\n\t\tbytes4 proposedActionId = getMethodId(_functionData);\r\n\t\tbytes32 hash = accountStorage.getProposalDataHash(_client, _proposer, proposedActionId);\r\n\t\trequire(hash == functionHash, \"proposal unmatch\");\r\n\t\taccountStorage.setProposalData(_client, _proposer, proposedActionId, functionHash, _backup);\r\n\t\temit ApproveProposal(_backup, _client, _proposer, _functionData);\r\n\t}\r\n\r\n    // called from 'enter'\r\n\tfunction cancelProposal(address payable _client, address _proposer, bytes4 _proposedActionId) external allowSelfCallsOnly {\r\n\t\trequire(_client != _proposer, \"cannot cancel dual signed proposal\");\r\n\t\taccountStorage.clearProposalData(_client, _proposer, _proposedActionId);\r\n\t\temit CancelProposal(_client, _proposer, _proposedActionId);\r\n\t}\r\n\r\n\t// *************** Implementation of EIP1271 ********************** //\r\n\r\n    /**\r\n    * @dev Should return whether the signature provided is valid for the provided data.\r\n    * @param _data Arbitrary length data signed on the behalf of address(this)\r\n    * @param _signature Signature byte array associated with _data\r\n    */\r\n    function isValidSignature(bytes calldata _data, bytes calldata _signature) external view returns (bytes4) {\r\n        bytes32 msgHash = keccak256(abi.encodePacked(_data));\r\n        isValidSignature(msgHash, _signature);\r\n        return ERC1271_ISVALIDSIGNATURE_BYTES;\r\n    }\r\n\r\n    function isValidSignature(bytes32 _msgHash, bytes memory _signature) public view returns (bytes4) {\r\n        require(_signature.length == 65, \"invalid signature length\");\r\n\t\tcheckKeyStatus(msg.sender, DAPP_KEY_INDEX);\r\n\t\taddress signingKey = accountStorage.getKeyData(msg.sender, DAPP_KEY_INDEX);\r\n\t\tbytes32 prefixedHash = keccak256(abi.encodePacked(SIGN_HASH_PREFIX, _msgHash));\r\n\t\tverifySig(signingKey, _signature, prefixedHash);\r\n        return ERC1271_ISVALIDSIGNATURE_BYTES32;\r\n    }\r\n\r\n\t// *************** internal functions ********************** //\r\n\r\n    /*\r\n    index 0: admin key\r\n          1: asset(transfer)\r\n          2: adding\r\n          3: reserved(dapp)\r\n          4: assist\r\n     */\r\n\tfunction getKeyIndex(bytes memory _data) internal pure returns (uint256) {\r\n\t\tuint256 index; //index default value is 0, admin key\r\n\t\tbytes4 methodId = getMethodId(_data);\r\n\t\tif (methodId == ADD_OPERATION_KEY) {\r\n  \t\t\tindex = 2; //adding key\r\n\t\t} else if (methodId == PROPOSE_AS_BACKUP || methodId == APPROVE_PROPOSAL) {\r\n  \t\t\tindex = 4; //assist key\r\n\t\t}\r\n\t\treturn index;\r\n\t}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"address\"}],\"name\":\"getKeyNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_pks\",\"type\":\"address[]\"}],\"name\":\"triggerChangeAllOperationKeys\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_msgHash\",\"type\":\"bytes32\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_actionId\",\"type\":\"bytes4\"}],\"name\":\"cancelDelay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_backup\",\"type\":\"address\"},{\"name\":\"_client\",\"type\":\"address\"},{\"name\":\"_proposer\",\"type\":\"address\"},{\"name\":\"_functionData\",\"type\":\"bytes\"}],\"name\":\"approveProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"unfreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"triggerUnfreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"initAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_backup\",\"type\":\"address\"}],\"name\":\"findBackup\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_backup\",\"type\":\"address\"}],\"name\":\"removeBackup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_pkNew\",\"type\":\"address\"}],\"name\":\"addOperationKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_backup\",\"type\":\"address\"}],\"name\":\"cancelRemoveBackup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_pkNew\",\"type\":\"address\"}],\"name\":\"triggerChangeAdminKeyByBackup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accountStorage\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_client\",\"type\":\"address\"},{\"name\":\"_proposer\",\"type\":\"address\"},{\"name\":\"_functionData\",\"type\":\"bytes\"}],\"name\":\"executeProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_backup\",\"type\":\"address\"}],\"name\":\"cancelAddBackup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_pks\",\"type\":\"address[]\"}],\"name\":\"changeAllOperationKeys\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_backup\",\"type\":\"address\"},{\"name\":\"_client\",\"type\":\"address\"},{\"name\":\"_functionData\",\"type\":\"bytes\"}],\"name\":\"proposeAsBackup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_pkNew\",\"type\":\"address\"}],\"name\":\"changeAdminKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_signature\",\"type\":\"bytes\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"enter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_pkNew\",\"type\":\"address\"}],\"name\":\"triggerChangeAdminKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_pkNew\",\"type\":\"address\"}],\"name\":\"changeAdminKeyByBackup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_client\",\"type\":\"address\"},{\"name\":\"_proposer\",\"type\":\"address\"},{\"name\":\"_proposedActionId\",\"type\":\"bytes4\"}],\"name\":\"cancelProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_accountStorage\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":true,\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"AccountLogicEntered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AccountLogicInitialised\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pkNew\",\"type\":\"address\"}],\"name\":\"ChangeAdminKeyTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pkNew\",\"type\":\"address\"}],\"name\":\"ChangeAdminKeyByBackupTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pks\",\"type\":\"address[]\"}],\"name\":\"ChangeAllOperationKeysTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"UnfreezeTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"pkNew\",\"type\":\"address\"}],\"name\":\"ChangeAdminKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"pkNew\",\"type\":\"address\"}],\"name\":\"ChangeAdminKeyByBackup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"pkNew\",\"type\":\"address\"}],\"name\":\"AddOperationKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pks\",\"type\":\"address[]\"}],\"name\":\"ChangeAllOperationKeys\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Freeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unfreeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"backup\",\"type\":\"address\"}],\"name\":\"RemoveBackup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"actionId\",\"type\":\"bytes4\"}],\"name\":\"CancelDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"backup\",\"type\":\"address\"}],\"name\":\"CancelAddBackup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"backup\",\"type\":\"address\"}],\"name\":\"CancelRemoveBackup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"backup\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ProposeAsBackup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"backup\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"client\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ApproveProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"client\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"proposedActionId\",\"type\":\"bytes4\"}],\"name\":\"CancelProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"client\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"functionData\",\"type\":\"bytes\"}],\"name\":\"ProposalExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"LogicInitialised\",\"type\":\"event\"}]","ContractName":"AccountLogic","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000adc92d1fd878580579716d944ef3460e241604b7","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://0ffb235dc8f8512fc1fef222e8439448178d7dec8d32c9d42fef5c343b59a9c3"}]}