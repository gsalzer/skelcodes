{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.8;\r\n\r\n/// @title A contract that remembers its creator (owner). Part of the\r\n///        Nordic Energy Smart Contract.\r\n///\r\n/// @author Nordic Energy.Co., Ltd / PowerChain\r\n///         https://nordicenergy.co\r\n///\r\n/// @dev License: Attribution-NonCommercial-ShareAlike 2.0 Generic (CC\r\n///              BY-NC-SA 2.0), see\r\n///              https://creativecommons.org/licenses/by-nc-sa/2.0/\r\ncontract owned {\r\n  constructor() public { owner = msg.sender; }\r\n  address owner;\r\n\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n}\r\n\r\n/// @title A contract that allows consumer addresses to be\r\n///        registered. Part of the Nordic Energy Smart Contract.\r\n///\r\n/// @author Nordic Energy.Co., Ltd / PowerChain\r\n///         https://nordicenergy.co\r\n///\r\n/// @dev License: Attribution-NonCommercial-ShareAlike 2.0 Generic (CC\r\n///              BY-NC-SA 2.0), see\r\n///              https://creativecommons.org/licenses/by-nc-sa/2.0/\r\ncontract consumerRegistry is owned {\r\n  event consumerRegistered(address indexed consumer);\r\n  event consumerDeregistered(address indexed consumer);\r\n\r\n  // map address to userID\r\n  mapping(address => uint32) public consumers;\r\n\r\n  modifier onlyRegisteredConsumers {\r\n    require(consumers[msg.sender] > 0);\r\n    _;\r\n  }\r\n\r\n  /// @notice Allow the owner of the address `aconsumer.address()`\r\n  ///         to make transactions on behalf of user id `auserID`.\r\n  ///\r\n  /// @dev Register address aconsumer to belong to userID\r\n  ///      auserID. Addresses can be delisted (\"unregistered\") by\r\n  ///      setting the userID auserID to zero.\r\n  function registerConsumer(address aconsumer, uint32 auserID) onlyOwner external {\r\n    if (auserID != 0) {\r\n      emit consumerRegistered(aconsumer);\r\n    } else {\r\n      emit consumerDeregistered(aconsumer);\r\n    }\r\n    consumers[aconsumer] = auserID;\r\n  }\r\n}\r\n\r\n/// @title A contract that allows producer addresses to be registered.\r\n///\r\n/// @author Nordic Energy.Co., Ltd / PowerChain\r\n///         https://nordicenergy.co\r\n///\r\n/// @dev License: Attribution-NonCommercial-ShareAlike 2.0 Generic (CC\r\n///              BY-NC-SA 2.0), see\r\n///              https://creativecommons.org/licenses/by-nc-sa/2.0/\r\ncontract producerRegistry is owned {\r\n  event producerRegistered(address indexed producer);\r\n  event producerDeregistered(address indexed producer);\r\n\r\n  // map address to bool \"is a registered producer\"\r\n  mapping(address => bool) public producers;\r\n\r\n  modifier onlyRegisteredProducers {\r\n    require(producers[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  /// @notice Allow the owner of address `aproducer.address()` to\r\n  ///         act as a producer (by offering energy).\r\n  function registerProducer(address aproducer) onlyOwner external {\r\n    emit producerRegistered(aproducer);\r\n    producers[aproducer] = true;\r\n  }\r\n\r\n  /// @notice Cease allowing the owner of address\r\n  ///         `aproducer.address()` to act as a producer (by\r\n  ///         offering energy).\r\n  function deregisterProducer(address aproducer) onlyOwner external {\r\n    emit producerDeregistered(aproducer);\r\n    producers[aproducer] = false;\r\n  }\r\n}\r\n\r\n/// @title The Nordic Energy Smart Contract, initial development version.\r\n///\r\n/// @author Nordic Energy.Co., Ltd / PowerChain\r\n///         https://nordicenergy.co\r\n///\r\n/// @dev License: Attribution-NonCommercial-ShareAlike 2.0 Generic (CC\r\n///              BY-NC-SA 2.0), see\r\n///              https://creativecommons.org/licenses/by-nc-sa/2.0/\r\ncontract EnergyStore is owned, consumerRegistry, producerRegistry {\r\n\r\n  event BidMade(address indexed producer, uint32 indexed day, uint32 indexed price, uint64 energy);\r\n  event BidRevoked(address indexed producer, uint32 indexed day, uint32 indexed price, uint64 energy);\r\n  event Deal(address indexed producer, uint32 indexed day, uint32 price, uint64 energy, uint32 indexed userID);\r\n  event DealRevoked(address indexed producer, uint32 indexed day, uint32 price, uint64 energy, uint32 indexed userID);\r\n\r\n  uint64 constant mWh = 1;\r\n  uint64 constant  Wh = 1000 * mWh;\r\n  uint64 constant kWh = 1000 * Wh;\r\n  uint64 constant MWh = 1000 * kWh;\r\n  uint64 constant GWh = 1000 * MWh;\r\n  uint64 constant TWh = 1000 * GWh;\r\n  uint64 constant maxEnergy = 18446 * GWh;\r\n\r\n  struct Bid {\r\n    // producer's public key\r\n    address producer;\r\n\r\n    // day for which the offer is valid\r\n    uint32 day;\r\n\r\n    // price vs market price\r\n    uint32 price;\r\n\r\n    // energy to sell\r\n    uint64 energy;\r\n\r\n    // timestamp for when the offer was submitted\r\n    uint64 timestamp;\r\n  }\r\n\r\n  struct Ask {\r\n    address producer;\r\n    uint32 day;\r\n    uint32 price;\r\n    uint64 energy;\r\n    uint32 userID;\r\n    uint64 timestamp;\r\n  }\r\n\r\n  // bids (for energy: offering energy for sale)\r\n  Bid[] public bids;\r\n\r\n  // asks (for energy: demanding energy to buy)\r\n  Ask[] public asks;\r\n\r\n  // map (address, day) to index into bids\r\n  mapping(address => mapping(uint32 => uint)) public bidsIndex;\r\n\r\n  // map (userid) to index into asks [last take written]\r\n  mapping(uint32 => uint) public asksIndex;\r\n\r\n  /// @notice Offer `(aenergy / 1.0e6).toFixed(6)` kWh of energy for\r\n  ///         day `aday` at a price `(aprice / 1.0e3).toFixed(3) + '\r\n  ///         ct/kWh'` above market price for a date given as day\r\n  ///         `aday` whilst asserting that the current date and time\r\n  ///         in nanoseconds since 1970 is `atimestamp`.\r\n  ///\r\n  /// @param aday Day for which the offer is valid.\r\n  /// @param aprice Price surcharge in millicent/kWh above market\r\n  ///        price\r\n  /// @param aenergy Energy to be offered in mWh\r\n  /// @param atimestamp UNIX time (seconds since 1970) in\r\n  ///        nanoseconds\r\n  function offer_energy(uint32 aday, uint32 aprice, uint64 aenergy, uint64 atimestamp) onlyRegisteredProducers external {\r\n    // require a minimum offer of 1 kWh\r\n    require(aenergy >= kWh);\r\n\r\n    uint idx = bidsIndex[msg.sender][aday];\r\n\r\n    // idx is either 0 or such that bids[idx] has the right producer and day (or both 0 and ...)\r\n    if ((bids.length > idx) && (bids[idx].producer == msg.sender) && (bids[idx].day == aday)) {\r\n      // we will only let newer timestamps affect the stored data\r\n      require(atimestamp > bids[idx].timestamp);\r\n\r\n      // NOTE: Should we sanity-check timestamps here (ensure that\r\n      //       they are either in the past or not in the too-distant\r\n      //       future compared to the last block's timestamp)?\r\n\r\n      emit BidRevoked(bids[idx].producer, bids[idx].day, bids[idx].price, bids[idx].energy);\r\n    }\r\n\r\n    // create entry with new index idx for (msg.sender, aday)\r\n    idx = bids.length;\r\n    bidsIndex[msg.sender][aday] = idx;\r\n    bids.push(Bid({\r\n      producer: msg.sender,\r\n      day: aday,\r\n      price: aprice,\r\n      energy: aenergy,\r\n      timestamp: atimestamp\r\n      }));\r\n    emit BidMade(bids[idx].producer, bids[idx].day, bids[idx].price, bids[idx].energy);\r\n  }\r\n\r\n  function getBidsCount() external view returns(uint count) {\r\n    return bids.length;\r\n  }\r\n\r\n  function getBidByProducerAndDay(address producer, uint32 day) external view returns(uint32 price, uint64 energy) {\r\n    uint idx = bidsIndex[producer][day];\r\n    require(bids.length > idx);\r\n    require(bids[idx].producer == producer);\r\n    require(bids[idx].day == day);\r\n    return (bids[idx].price, bids[idx].energy);\r\n  }\r\n\r\n  /// @notice Buy `(aenergy / 1.0e6).toFixed(6)` kWh of energy on\r\n  ///         behalf of user id `auserID` (possibly de-anonymized by\r\n  ///         randomization) for day `aday` at a surcharge `(aprice\r\n  ///         / 1.0e3).toFixed(3)` ct/kWh from the energy producer\r\n  ///         using the address `aproducer.address()` whilst\r\n  ///         asserting that the current time in seconds since 1970\r\n  ///         is `(atimestamp / 1.0e9)` seconds.\r\n  ///\r\n  /// @param aproducer Address of the producer offering the energy\r\n  ///        to be bought.\r\n  /// @param aday Day for which the offer is valid.\r\n  /// @param aprice Price surcharge in millicent/kWh above market\r\n  ///        price\r\n  /// @param aenergy Energy to be offered in mWh\r\n  /// @param atimestamp UNIX time (seconds since 1970) in\r\n  ///        nanoseconds\r\n  ///\r\n  /// @dev This function is meant to be called by Nordic Energy on behalf\r\n  ///      of customers.\r\n  function buy_energy(address aproducer, uint32 aday, uint32 aprice, uint64 aenergy, uint32 auserID, uint64 atimestamp) onlyOwner external {\r\n    buy_energy_core(aproducer, aday, aprice, aenergy, auserID, atimestamp);\r\n  }\r\n\r\n  /// @notice Buy `(aenergy / 1.0e6).toFixed(6)` kWh of energy on\r\n  ///          for day `aday` at a surcharge `(aprice /\r\n  ///          1.0e3).toFixed(3)` ct/kWh from the energy producer\r\n  ///          using the address `aproducer.address()`.\r\n  ///\r\n  /// @param aproducer Address of the producer offering the energy\r\n  ///        to be bought.\r\n  /// @param aday Day for which the offer is valid.\r\n  /// @param aprice Price surcharge in millicent/kWh above market\r\n  ///        price\r\n  /// @param aenergy Energy to be offered in mWh\r\n  ///\r\n  /// @dev This function is meant to be called by a Nordic Energy customer\r\n  ///      who has chosen to be registered for this ability and to\r\n  ///      decline anonymization by randomization of user ID.\r\n  function buy_energy(address aproducer, uint32 aday, uint32 aprice, uint64 aenergy) onlyRegisteredConsumers external {\r\n    buy_energy_core(aproducer, aday, aprice, aenergy, consumers[msg.sender], 0);\r\n  }\r\n\r\n  function buy_energy_core(address aproducer, uint32 aday, uint32 aprice, uint64 aenergy, uint32 auserID, uint64 atimestamp) internal {\r\n    // find offer by producer (aproducer) for day (aday), or zero\r\n    uint idx = bidsIndex[aproducer][aday];\r\n\r\n    // if the offer exists...\r\n    if ((bids.length > idx) && (bids[idx].producer == aproducer) && (bids[idx].day == aday)) {\r\n      // ...and has the right price...\r\n      require(bids[idx].price == aprice);\r\n\r\n      // todo: prevent overwriting a later choice...\r\n\r\n      // ...then record the customer's choice\r\n      asksIndex[auserID] = asks.length;\r\n      asks.push(Ask({\r\n        producer: aproducer,\r\n        day: aday,\r\n        price: aprice,\r\n        energy: aenergy,\r\n        userID: auserID,\r\n        timestamp: atimestamp\r\n        }));\r\n      emit Deal(aproducer, aday, aprice, aenergy, auserID);\r\n    } else {\r\n      // the offer does not exist\r\n      revert();\r\n    }\r\n  }\r\n\r\n  function getAsksCount() external view returns(uint count) {\r\n    return asks.length;\r\n  }\r\n\r\n  function getAskByUserID(uint32 userID) external view returns(address producer, uint32 day, uint32 price, uint64 energy) {\r\n    uint idx = asksIndex[userID];\r\n    require(asks[idx].userID == userID);\r\n    return (asks[idx].producer, asks[idx].day, asks[idx].price, asks[idx].energy);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"consumers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"aconsumer\",\"type\":\"address\"},{\"name\":\"auserID\",\"type\":\"uint32\"}],\"name\":\"registerConsumer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"consumer\",\"type\":\"address\"}],\"name\":\"consumerRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"consumer\",\"type\":\"address\"}],\"name\":\"consumerDeregistered\",\"type\":\"event\"}]","ContractName":"consumerRegistry","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"OSL-3.0","SwarmSource":"bzzr://8c8dacae4b85f50da328c5da6857f2c556e303a328466558b0616112eb482f1f"}]}