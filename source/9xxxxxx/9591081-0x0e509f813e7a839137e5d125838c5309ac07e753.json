{"status":"1","message":"OK","result":[{"SourceCode":"{\"MKDSToken.sol\":{\"content\":\"/*\\r\\n * MKDS Token Smart Contract.\\r\\n * Copyright (c) 2020 by owner.\\r\\n */\\r\\npragma solidity ^0.4.20;\\r\\n\\r\\n//import \\\"../STASIS-EURS-token-smart-contract/src/sol/EURSToken.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Token.sol\\\";\\r\\n\\r\\n/**\\r\\n * MKDS Token Smart Contract: EIP-20 compatible token smart contract that\\r\\n * manages MKDS tokens.\\r\\n */\\r\\ncontract MKDSToken is Token, SafeMath {\\r\\n  string constant public contact = \\\"cryp10grapher@protonmail.com\\\";\\r\\n  Token constant targetToken = Token(address(0xdB25f211AB05b1c97D595516F45794528a807ad8));\\r\\n  address public owner;\\r\\n  address public oracle;\\r\\n  address public beneficiary;\\r\\n  uint256 conversionRateNumerator = 6160000; // MKDS/EURS\\r\\n  uint256 constant denominator = 100000;\\r\\n  uint256 transferFeeMin = 100; // transfer fee minimum in 1/100\\u0027s of a MKDS, since MKDS token has 2 decimals\\r\\n  uint256 transferFeeMax = 100; // transfer fee maximum in 1/100\\u0027s of a MKDS, since MKDS token has 2 decimals\\r\\n  uint256 transferFeeFactorNumerator = 100; // transfer fee factor; (initialized for 0.1%); actual factor is obtained by dividing this by denominator\\r\\n\\r\\n  /**\\r\\n   * Create MKDS Token smart contract with message sender as an owner. \\r\\n   */\\r\\n  function MKDSToken() public {\\r\\n    owner = msg.sender;\\r\\n    oracle = owner;\\r\\n    beneficiary = owner;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Make sure the modified function can be executed only by the owner.\\r\\n   */\\r\\n   modifier onlyOwner() {\\r\\n    require(0 != owner);\\r\\n    require(msg.sender == owner);\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Make sure the modified function can be executed only by the oracle.\\r\\n   */\\r\\n   modifier onlyOracle() {\\r\\n    require(0 != oracle);\\r\\n    require(msg.sender == oracle);\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Transfer ownership of this smart contract to a new address.\\r\\n   *\\r\\n   * @param _owner address of the new owner. If set to 0, the owner loses control of the contract.\\r\\n   */\\r\\n  function setOwner(address _owner) external onlyOwner() {\\r\\n    owner = _owner; // If set to 0, owner loses control of the contract\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Set new oracle.\\r\\n   *\\r\\n   * @param _oracle address of the new oracle. If set to 0, there can be no oracle.\\r\\n   */\\r\\n  function setOracle(address _oracle) external onlyOwner() {\\r\\n    oracle = _oracle; // If set to 0, there is no oracle\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Set new beneficiary.\\r\\n   *\\r\\n   * @param _beneficiary address of the new beneficiary.\\r\\n   */\\r\\n  function setBeneficiary(address _beneficiary) external onlyOwner() {\\r\\n    beneficiary = _beneficiary; // If set to 0, there is no oracle\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Set a new conversion rate for MKDS/EURS. \\r\\n   *\\r\\n   * @param _conversionRateNumerator the new conversion rate multiplied by the denominator.\\r\\n   */\\r\\n  function setConversionRateNumerator(uint256 _conversionRateNumerator) external onlyOracle() {\\r\\n    conversionRateNumerator = _conversionRateNumerator;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Convert from EURS to MKDS.\\r\\n   *\\r\\n   * @param value amount of EURS\\r\\n   * @return countervalue in MKDS\\r\\n   */\\r\\n  function toMKDS(uint256 value) public view returns(uint256) {\\r\\n    return safeMul(value, conversionRateNumerator) / denominator; // round down to make sure it\\u0027s spendable\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Convert from MKDS to EURS.\\r\\n   *\\r\\n   * @param value amount of MKDS\\r\\n   * @return countervalue in EURS\\r\\n   */\\r\\n  function toEURS(uint256 value) public view returns(uint256) {\\r\\n    uint256 v = safeMul(value, denominator);\\r\\n    uint256 r = v/conversionRateNumerator;\\r\\n    if (v%conversionRateNumerator \\u003e uint256(0)) return safeAdd(r, uint256(1)); // round up to cover the value in EURS\\r\\n    else return r;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Set new transfer fee parameters.\\r\\n   * \\r\\n   * @param _transferFeeMin // new transfer fee minimum in 1/100\\u0027s of a MKDS, since MKDS token has 2 decimals\\r\\n   * @param _transferFeeMax // new transfer fee maximum in 1/100\\u0027s of a MKDS, since MKDS token has 2 decimals\\r\\n   * @param _transferFeeFactorNumerator // new transfer fee factor numerator - actual factor is derived by dividing this by denominator\\r\\n   */\\r\\n  function setTranactionFeeParameters(\\r\\n    uint256 _transferFeeMin, \\r\\n    uint256 _transferFeeMax, \\r\\n    uint256 _transferFeeFactorNumerator) external onlyOwner() {\\r\\n    transferFeeMin = _transferFeeMin;\\r\\n    transferFeeMax = _transferFeeMax;\\r\\n    transferFeeFactorNumerator = _transferFeeFactorNumerator;\\r\\n  }\\r\\n\\r\\n  /** Calculates the transaction fee for transfers.\\r\\n   *\\r\\n   * @param value the transfer amount\\r\\n   * @return fee in MKDS\\r\\n   */\\r\\n  function transferFee(uint256 value) public view returns(uint256) {\\r\\n    uint256 fee = safeMul(value, transferFeeFactorNumerator) / denominator; // round down\\r\\n    if (fee \\u003c transferFeeMin) return transferFeeMin;\\r\\n    else if (fee \\u003e transferFeeMax) return transferFeeMax;\\r\\n    else return fee;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Delegate unrecognized functions.\\r\\n   */\\r\\n  function() public payable {\\r\\n    // address(targetToken).transfer(msg.value); // assuming that the fallback function has no other functionality in EURS but to receive ETH\\r\\n    address(targetToken).call.value(msg.value)(msg.data);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Get name of the token.\\r\\n   *\\r\\n   * @return name of the token\\r\\n   */\\r\\n  function name() public pure returns (string) {\\r\\n    return \\\"MKDS Token - Стабилизиран Со Македонски Денар\\\";\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Get symbol of the token.\\r\\n   *\\r\\n   * @return symbol of the token\\r\\n   */\\r\\n  function symbol() public pure returns (string) {\\r\\n    return \\\"MKDS\\\";\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Get number of decimals for the token.\\r\\n   *\\r\\n   * @return number of decimals for the token\\r\\n   */\\r\\n  function decimals() public pure returns (uint8) {\\r\\n    return 2;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Get total number of tokens in circulation.\\r\\n   *\\r\\n   * @return total number of tokens in circulation\\r\\n   */\\r\\n  function totalSupply() public view returns (uint256) {\\r\\n    return toMKDS(targetToken.totalSupply());\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Get number of tokens currently belonging to given owner.\\r\\n   *\\r\\n   * @param _owner address to get number of tokens currently belonging to the\\r\\n   *        owner of\\r\\n   * @return number of tokens currently belonging to the owner of given address\\r\\n   */\\r\\n  function balanceOf(address _owner)\\r\\n    public view returns (uint256 balance) {\\r\\n    return toMKDS(targetToken.balanceOf(_owner));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Transfer given number of tokens from message sender to given recipient.\\r\\n   * @dev Permissioning is delegated to the targetToken.\\r\\n   *\\r\\n   * @param _to address to transfer tokens to the owner of\\r\\n   * @param _value number of tokens to transfer to the owner of given address\\r\\n   * @return true if tokens were transferred successfully, false otherwise\\r\\n   */\\r\\n  function transfer(address _to, uint256 _value)\\r\\n  public payable returns (bool) {\\r\\n    uint256 fee = transferFee(_value);\\r\\n    // return targetToken.transfer.value(msg.value)(_to, toEURS(safeSub(_value, fee)); // does not work - Solidity issue. Thus following line\\r\\n    // With ETH: require(address(targetToken).call.value(msg.value)(abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", _to, toEURS(safeSub(_value, fee)))));\\r\\n    require(targetToken.transfer(_to, toEURS(safeSub(_value, fee))));\\r\\n    require(targetToken.transfer(beneficiary, toEURS(fee))); // Fee charged in EURS only @todo improve to allow ETH fee payments\\r\\n    //emit Transfer(msg.sender, _to, _value);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Transfer given number of tokens from given owner to given recipient.\\r\\n   * @dev Permissioning is delegated to the targetToken.\\r\\n   *\\r\\n   * @param _from address to transfer tokens from the owner of\\r\\n   * @param _to address to transfer tokens to the owner of\\r\\n   * @param _value number of tokens to transfer from given owner to given\\r\\n   *        recipient\\r\\n   * @return true if tokens were transferred successfully, false otherwise\\r\\n   */\\r\\n  function transferFrom(address _from, address _to, uint256 _value)\\r\\n  public payable returns (bool) {\\r\\n    uint256 fee = transferFee(_value);\\r\\n    require(targetToken.transferFrom.value(msg.value)(_from, _to, toEURS(safeSub(_value, fee))));\\r\\n    require(targetToken.transferFrom(_from, beneficiary, toEURS(fee))); // Fee charged in EURS only @todo improve to allow ETH fee payments\\r\\n    //emit Transfer(_from, _to, _value);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Allow given spender to transfer given number of tokens from message sender.\\r\\n   * @dev Permissioning is delegated to the targetToken.\\r\\n   *\\r\\n   * @param _spender address to allow the owner of to transfer tokens from\\r\\n   *        message sender\\r\\n   * @param _value number of tokens to allow to transfer\\r\\n   * @return true if token transfer was successfully approved, false otherwise\\r\\n   */\\r\\n  function approve (address _spender, uint256 _value)\\r\\n  public payable returns (bool success) {\\r\\n    if (targetToken.approve.value(msg.value)(_spender, toEURS(_value))) {\\r\\n      //emit Approval(msg.sender, _spender, _value);\\r\\n      return true;\\r\\n    } else return false;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Tell how many tokens given spender is currently allowed to transfer from\\r\\n   * given owner.\\r\\n   *\\r\\n   * @param _owner address to get number of tokens allowed to be transferred\\r\\n   *        from the owner of\\r\\n   * @param _spender address to get number of tokens allowed to be transferred\\r\\n   *        by the owner of\\r\\n   * @return number of tokens given spender is currently allowed to transfer\\r\\n   *         from given owner\\r\\n   */\\r\\n  function allowance (address _owner, address _spender)\\r\\n  public view returns (uint256 remaining) {\\r\\n    return toMKDS(targetToken.allowance(_owner, _spender));\\r\\n  }\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"/*\\n * Safe Math Smart Contract.  Copyright © 2016–2017 by ABDK Consulting.\\n * Copyright (c) 2018 by STSS (Malta) Limited.\\n * Contact: \\u003ctech@stasis.net\\u003e\\n */\\npragma solidity ^0.4.20;\\n\\n/**\\n * Provides methods to safely add, subtract and multiply uint256 numbers.\\n */\\ncontract SafeMath {\\n  uint256 constant private MAX_UINT256 =\\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n  /**\\n   * Add two uint256 values, throw in case of overflow.\\n   *\\n   * @param x first value to add\\n   * @param y second value to add\\n   * @return x + y\\n   */\\n  function safeAdd (uint256 x, uint256 y)\\n  pure internal\\n  returns (uint256 z) {\\n    assert (x \\u003c= MAX_UINT256 - y);\\n    return x + y;\\n  }\\n\\n  /**\\n   * Subtract one uint256 value from another, throw in case of underflow.\\n   *\\n   * @param x value to subtract from\\n   * @param y value to subtract\\n   * @return x - y\\n   */\\n  function safeSub (uint256 x, uint256 y)\\n  pure internal\\n  returns (uint256 z) {\\n    assert (x \\u003e= y);\\n    return x - y;\\n  }\\n\\n  /**\\n   * Multiply two uint256 values, throw in case of overflow.\\n   *\\n   * @param x first value to multiply\\n   * @param y second value to multiply\\n   * @return x * y\\n   */\\n  function safeMul (uint256 x, uint256 y)\\n  pure internal\\n  returns (uint256 z) {\\n    if (y == 0) return 0; // Prevent division by zero at the next line\\n    assert (x \\u003c= MAX_UINT256 / y);\\n    return x * y;\\n  }\\n}\\n\"},\"Token.sol\":{\"content\":\"/*\\n * EIP-20 Standard Token Smart Contract Interface.\\n * Copyright (c) 2018 by STSS (Malta) Limited.\\n * Contact: \\u003ctech@stasis.net\\u003e\\n */\\npragma solidity ^0.4.20;\\n\\n/**\\n * ERC-20 standard token interface, as defined\\n * \\u003ca href=\\\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\\"\\u003ehere\\u003c/a\\u003e.\\n */\\ncontract Token {\\n  /**\\n   * Get total number of tokens in circulation.\\n   *\\n   * @return total number of tokens in circulation\\n   */\\n  function totalSupply () public view returns (uint256 supply);\\n\\n  /**\\n   * Get number of tokens currently belonging to given owner.\\n   *\\n   * @param _owner address to get number of tokens currently belonging to the\\n   *        owner of\\n   * @return number of tokens currently belonging to the owner of given address\\n   */\\n  function balanceOf (address _owner) public view returns (uint256 balance);\\n\\n  /**\\n   * Transfer given number of tokens from message sender to given recipient.\\n   *\\n   * @param _to address to transfer tokens to the owner of\\n   * @param _value number of tokens to transfer to the owner of given address\\n   * @return true if tokens were transferred successfully, false otherwise\\n   */\\n  function transfer (address _to, uint256 _value)\\n  public payable returns (bool success);\\n\\n  /**\\n   * Transfer given number of tokens from given owner to given recipient.\\n   *\\n   * @param _from address to transfer tokens from the owner of\\n   * @param _to address to transfer tokens to the owner of\\n   * @param _value number of tokens to transfer from given owner to given\\n   *        recipient\\n   * @return true if tokens were transferred successfully, false otherwise\\n   */\\n  function transferFrom (address _from, address _to, uint256 _value)\\n  public payable returns (bool success);\\n\\n  /**\\n   * Allow given spender to transfer given number of tokens from message sender.\\n   *\\n   * @param _spender address to allow the owner of to transfer tokens from\\n   *        message sender\\n   * @param _value number of tokens to allow to transfer\\n   * @return true if token transfer was successfully approved, false otherwise\\n   */\\n  function approve (address _spender, uint256 _value)\\n  public payable returns (bool success);\\n\\n  /**\\n   * Tell how many tokens given spender is currently allowed to transfer from\\n   * given owner.\\n   *\\n   * @param _owner address to get number of tokens allowed to be transferred\\n   *        from the owner of\\n   * @param _spender address to get number of tokens allowed to be transferred\\n   *        by the owner of\\n   * @return number of tokens given spender is currently allowed to transfer\\n   *         from given owner\\n   */\\n  function allowance (address _owner, address _spender)\\n  public view returns (uint256 remaining);\\n\\n  /**\\n   * Logged when tokens were transferred from one owner to another.\\n   *\\n   * @param _from address of the owner, tokens were transferred from\\n   * @param _to address of the owner, tokens were transferred to\\n   * @param _value number of tokens transferred\\n   */\\n  event Transfer (address indexed _from, address indexed _to, uint256 _value);\\n\\n  /**\\n   * Logged when owner approved his tokens to be transferred by some spender.\\n   *\\n   * @param _owner owner who approved his tokens to be transferred\\n   * @param _spender spender who were allowed to transfer the tokens belonging\\n   *        to the owner\\n   * @param _value number of tokens belonging to the owner, approved to be\\n   *        transferred by the spender\\n   */\\n  event Approval (\\n    address indexed _owner, address indexed _spender, uint256 _value);\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contact\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"toMKDS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_conversionRateNumerator\",\"type\":\"uint256\"}],\"name\":\"setConversionRateNumerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"toEURS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transferFeeMin\",\"type\":\"uint256\"},{\"name\":\"_transferFeeMax\",\"type\":\"uint256\"},{\"name\":\"_transferFeeFactorNumerator\",\"type\":\"uint256\"}],\"name\":\"setTranactionFeeParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"MKDSToken","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://650096488dde2df791e9f8be062927958420d6a955dc82b4be57085694933f76"}]}