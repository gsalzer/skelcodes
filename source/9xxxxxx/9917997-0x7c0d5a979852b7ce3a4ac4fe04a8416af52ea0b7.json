{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\nCopyright 2020 PoolTogether Inc.\r\n\r\nThis file is part of PoolTogether.\r\n\r\nPoolTogether is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation under version 3 of the License.\r\n\r\nPoolTogether is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\r\n*/\r\n\r\npragma solidity 0.5.12;\r\n\r\ncontract GemLike {\r\n    function allowance(address, address) public returns (uint);\r\n    function approve(address, uint) public;\r\n    function transfer(address, uint) public returns (bool);\r\n    function transferFrom(address, address, uint) public returns (bool);\r\n}\r\n\r\ncontract ValueLike {\r\n    function peek() public returns (uint, bool);\r\n}\r\n\r\ncontract SaiTubLike {\r\n    function skr() public view returns (GemLike);\r\n    function gem() public view returns (GemLike);\r\n    function gov() public view returns (GemLike);\r\n    function sai() public view returns (GemLike);\r\n    function pep() public view returns (ValueLike);\r\n    function vox() public view returns (VoxLike);\r\n    function bid(uint) public view returns (uint);\r\n    function ink(bytes32) public view returns (uint);\r\n    function tag() public view returns (uint);\r\n    function tab(bytes32) public returns (uint);\r\n    function rap(bytes32) public returns (uint);\r\n    function draw(bytes32, uint) public;\r\n    function shut(bytes32) public;\r\n    function exit(uint) public;\r\n    function give(bytes32, address) public;\r\n}\r\n\r\ncontract VoxLike {\r\n    function par() public returns (uint);\r\n}\r\n\r\ncontract JoinLike {\r\n    function ilk() public returns (bytes32);\r\n    function gem() public returns (GemLike);\r\n    function dai() public returns (GemLike);\r\n    function join(address, uint) public;\r\n    function exit(address, uint) public;\r\n}\r\ncontract VatLike {\r\n    function ilks(bytes32) public view returns (uint, uint, uint, uint, uint);\r\n    function hope(address) public;\r\n    function frob(bytes32, address, address, address, int, int) public;\r\n}\r\n\r\ncontract ManagerLike {\r\n    function vat() public view returns (address);\r\n    function urns(uint) public view returns (address);\r\n    function open(bytes32, address) public returns (uint);\r\n    function frob(uint, int, int) public;\r\n    function give(uint, address) public;\r\n    function move(uint, address, uint) public;\r\n}\r\n\r\ncontract OtcLike {\r\n    function getPayAmount(address, address, uint) public view returns (uint);\r\n    function buyAllAmount(address, uint, address, uint) public;\r\n}\r\n/**\r\nCopyright 2020 PoolTogether Inc.\r\n\r\nThis file is part of PoolTogether.\r\n\r\nPoolTogether is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation under version 3 of the License.\r\n\r\nPoolTogether is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n/**\r\nCopyright 2020 PoolTogether Inc.\r\n\r\nThis file is part of PoolTogether.\r\n\r\nPoolTogether is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation under version 3 of the License.\r\n\r\nPoolTogether is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the global ERC1820 Registry, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\r\n * implementers for interfaces in this registry, as well as query support.\r\n *\r\n * Implementers may be shared by multiple accounts, and can also implement more\r\n * than a single interface for each account. Contracts can implement interfaces\r\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\r\n * contract.\r\n *\r\n * {IERC165} interfaces can also be queried via the registry.\r\n *\r\n * For an in-depth explanation and source code analysis, see the EIP text.\r\n */\r\ninterface IERC1820Registry {\r\n    /**\r\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\r\n     * account is able to set interface implementers for it.\r\n     *\r\n     * By default, each account is its own manager. Passing a value of `0x0` in\r\n     * `newManager` will reset the manager to this initial state.\r\n     *\r\n     * Emits a {ManagerChanged} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `account`.\r\n     */\r\n    function setManager(address account, address newManager) external;\r\n\r\n    /**\r\n     * @dev Returns the manager for `account`.\r\n     *\r\n     * See {setManager}.\r\n     */\r\n    function getManager(address account) external view returns (address);\r\n\r\n    /**\r\n     * @dev Sets the `implementer` contract as `account`'s implementer for\r\n     * `interfaceHash`.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     * The zero address can also be used in `implementer` to remove an old one.\r\n     *\r\n     * See {interfaceHash} to learn how these are created.\r\n     *\r\n     * Emits an {InterfaceImplementerSet} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `account`.\r\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\r\n     * end in 28 zeroes).\r\n     * - `implementer` must implement {IERC1820Implementer} and return true when\r\n     * queried for support, unless `implementer` is the caller. See\r\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\r\n     */\r\n    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\r\n\r\n    /**\r\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\r\n     * implementer is registered, returns the zero address.\r\n     *\r\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\r\n     * zeroes), `account` will be queried for support of it.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     */\r\n    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\r\n     * corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\r\n     */\r\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\r\n\r\n    /**\r\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\r\n     *  @param account Address of the contract for which to update the cache.\r\n     *  @param interfaceId ERC165 interface for which to update the cache.\r\n     */\r\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\r\n\r\n    /**\r\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\r\n     *  If the result is not cached a direct lookup on the contract address is performed.\r\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\r\n     *  {updateERC165Cache} with the contract address.\r\n     *  @param account Address of the contract to check.\r\n     *  @param interfaceId ERC165 interface to check.\r\n     *  @return True if `account` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    /**\r\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\r\n     *  @param account Address of the contract to check.\r\n     *  @param interfaceId ERC165 interface to check.\r\n     *  @return True if `account` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\r\n\r\n    event ManagerChanged(address indexed account, address indexed newManager);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard is Initializable {\r\n    // counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    function initialize() public initializer {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n/**\r\nCopyright 2020 PoolTogether Inc.\r\n\r\nThis file is part of PoolTogether.\r\n\r\nPoolTogether is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation under version 3 of the License.\r\n\r\nPoolTogether is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\ncontract ICErc20 {\r\n    address public underlying;\r\n    function mint(uint256 mintAmount) external returns (uint);\r\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint);\r\n    function balanceOfUnderlying(address owner) external returns (uint);\r\n    function getCash() external view returns (uint);\r\n    function supplyRatePerBlock() external view returns (uint);\r\n}\r\n\r\n/**\r\nCopyright 2020 PoolTogether Inc.\r\n\r\nThis file is part of PoolTogether.\r\n\r\nPoolTogether is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation under version 3 of the License.\r\n\r\nPoolTogether is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n/**\r\nCopyright 2020 PoolTogether Inc.\r\n\r\nThis file is part of PoolTogether.\r\n\r\nPoolTogether is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation under version 3 of the License.\r\n\r\nPoolTogether is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n/**\r\n * @author Brendan Asselstine\r\n * @notice A library that uses entropy to select a random number within a bound.  Compensates for modulo bias.\r\n * @dev Thanks to https://medium.com/hownetworks/dont-waste-cycles-with-modulo-bias-35b6fdafcf94\r\n */\r\nlibrary UniformRandomNumber {\r\n  /// @notice Select a random number without modulo bias using a random seed and upper bound\r\n  /// @param _entropy The seed for randomness\r\n  /// @param _upperBound The upper bound of the desired number\r\n  /// @return A random number less than the _upperBound\r\n  function uniform(uint256 _entropy, uint256 _upperBound) internal pure returns (uint256) {\r\n    require(_upperBound > 0, \"UniformRand/min-bound\");\r\n    uint256 min = -_upperBound % _upperBound;\r\n    uint256 random = _entropy;\r\n    while (true) {\r\n      if (random >= min) {\r\n        break;\r\n      }\r\n      random = uint256(keccak256(abi.encodePacked(random)));\r\n    }\r\n    return random % _upperBound;\r\n  }\r\n}\r\n/**\r\n *  @reviewers: [@clesaege, @unknownunknown1, @ferittuncer]\r\n *  @auditors: []\r\n *  @bounties: [<14 days 10 ETH max payout>]\r\n *  @deployments: []\r\n */\r\n\r\n\r\n\r\n/**\r\n *  @title SortitionSumTreeFactory\r\n *  @author Enrique Piqueras - <epiquerass@gmail.com>\r\n *  @dev A factory of trees that keep track of staked values for sortition.\r\n */\r\nlibrary SortitionSumTreeFactory {\r\n    /* Structs */\r\n\r\n    struct SortitionSumTree {\r\n        uint K; // The maximum number of childs per node.\r\n        // We use this to keep track of vacant positions in the tree after removing a leaf. This is for keeping the tree as balanced as possible without spending gas on moving nodes around.\r\n        uint[] stack;\r\n        uint[] nodes;\r\n        // Two-way mapping of IDs to node indexes. Note that node index 0 is reserved for the root node, and means the ID does not have a node.\r\n        mapping(bytes32 => uint) IDsToNodeIndexes;\r\n        mapping(uint => bytes32) nodeIndexesToIDs;\r\n    }\r\n\r\n    /* Storage */\r\n\r\n    struct SortitionSumTrees {\r\n        mapping(bytes32 => SortitionSumTree) sortitionSumTrees;\r\n    }\r\n\r\n    /* internal */\r\n\r\n    /**\r\n     *  @dev Create a sortition sum tree at the specified key.\r\n     *  @param _key The key of the new tree.\r\n     *  @param _K The number of children each node in the tree should have.\r\n     */\r\n    function createTree(SortitionSumTrees storage self, bytes32 _key, uint _K) internal {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n        require(tree.K == 0, \"Tree already exists.\");\r\n        require(_K > 1, \"K must be greater than one.\");\r\n        tree.K = _K;\r\n        tree.stack.length = 0;\r\n        tree.nodes.length = 0;\r\n        tree.nodes.push(0);\r\n    }\r\n\r\n    /**\r\n     *  @dev Set a value of a tree.\r\n     *  @param _key The key of the tree.\r\n     *  @param _value The new value.\r\n     *  @param _ID The ID of the value.\r\n     *  `O(log_k(n))` where\r\n     *  `k` is the maximum number of childs per node in the tree,\r\n     *   and `n` is the maximum number of nodes ever appended.\r\n     */\r\n    function set(SortitionSumTrees storage self, bytes32 _key, uint _value, bytes32 _ID) internal {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n        uint treeIndex = tree.IDsToNodeIndexes[_ID];\r\n\r\n        if (treeIndex == 0) { // No existing node.\r\n            if (_value != 0) { // Non zero value.\r\n                // Append.\r\n                // Add node.\r\n                if (tree.stack.length == 0) { // No vacant spots.\r\n                    // Get the index and append the value.\r\n                    treeIndex = tree.nodes.length;\r\n                    tree.nodes.push(_value);\r\n\r\n                    // Potentially append a new node and make the parent a sum node.\r\n                    if (treeIndex != 1 && (treeIndex - 1) % tree.K == 0) { // Is first child.\r\n                        uint parentIndex = treeIndex / tree.K;\r\n                        bytes32 parentID = tree.nodeIndexesToIDs[parentIndex];\r\n                        uint newIndex = treeIndex + 1;\r\n                        tree.nodes.push(tree.nodes[parentIndex]);\r\n                        delete tree.nodeIndexesToIDs[parentIndex];\r\n                        tree.IDsToNodeIndexes[parentID] = newIndex;\r\n                        tree.nodeIndexesToIDs[newIndex] = parentID;\r\n                    }\r\n                } else { // Some vacant spot.\r\n                    // Pop the stack and append the value.\r\n                    treeIndex = tree.stack[tree.stack.length - 1];\r\n                    tree.stack.length--;\r\n                    tree.nodes[treeIndex] = _value;\r\n                }\r\n\r\n                // Add label.\r\n                tree.IDsToNodeIndexes[_ID] = treeIndex;\r\n                tree.nodeIndexesToIDs[treeIndex] = _ID;\r\n\r\n                updateParents(self, _key, treeIndex, true, _value);\r\n            }\r\n        } else { // Existing node.\r\n            if (_value == 0) { // Zero value.\r\n                // Remove.\r\n                // Remember value and set to 0.\r\n                uint value = tree.nodes[treeIndex];\r\n                tree.nodes[treeIndex] = 0;\r\n\r\n                // Push to stack.\r\n                tree.stack.push(treeIndex);\r\n\r\n                // Clear label.\r\n                delete tree.IDsToNodeIndexes[_ID];\r\n                delete tree.nodeIndexesToIDs[treeIndex];\r\n\r\n                updateParents(self, _key, treeIndex, false, value);\r\n            } else if (_value != tree.nodes[treeIndex]) { // New, non zero value.\r\n                // Set.\r\n                bool plusOrMinus = tree.nodes[treeIndex] <= _value;\r\n                uint plusOrMinusValue = plusOrMinus ? _value - tree.nodes[treeIndex] : tree.nodes[treeIndex] - _value;\r\n                tree.nodes[treeIndex] = _value;\r\n\r\n                updateParents(self, _key, treeIndex, plusOrMinus, plusOrMinusValue);\r\n            }\r\n        }\r\n    }\r\n\r\n    /* internal Views */\r\n\r\n    /**\r\n     *  @dev Query the leaves of a tree. Note that if `startIndex == 0`, the tree is empty and the root node will be returned.\r\n     *  @param _key The key of the tree to get the leaves from.\r\n     *  @param _cursor The pagination cursor.\r\n     *  @param _count The number of items to return.\r\n     *  @return The index at which leaves start, the values of the returned leaves, and whether there are more for pagination.\r\n     *  `O(n)` where\r\n     *  `n` is the maximum number of nodes ever appended.\r\n     */\r\n    function queryLeafs(\r\n        SortitionSumTrees storage self,\r\n        bytes32 _key,\r\n        uint _cursor,\r\n        uint _count\r\n    ) internal view returns(uint startIndex, uint[] memory values, bool hasMore) {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n\r\n        // Find the start index.\r\n        for (uint i = 0; i < tree.nodes.length; i++) {\r\n            if ((tree.K * i) + 1 >= tree.nodes.length) {\r\n                startIndex = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Get the values.\r\n        uint loopStartIndex = startIndex + _cursor;\r\n        values = new uint[](loopStartIndex + _count > tree.nodes.length ? tree.nodes.length - loopStartIndex : _count);\r\n        uint valuesIndex = 0;\r\n        for (uint j = loopStartIndex; j < tree.nodes.length; j++) {\r\n            if (valuesIndex < _count) {\r\n                values[valuesIndex] = tree.nodes[j];\r\n                valuesIndex++;\r\n            } else {\r\n                hasMore = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  @dev Draw an ID from a tree using a number. Note that this function reverts if the sum of all values in the tree is 0.\r\n     *  @param _key The key of the tree.\r\n     *  @param _drawnNumber The drawn number.\r\n     *  @return The drawn ID.\r\n     *  `O(k * log_k(n))` where\r\n     *  `k` is the maximum number of childs per node in the tree,\r\n     *   and `n` is the maximum number of nodes ever appended.\r\n     */\r\n    function draw(SortitionSumTrees storage self, bytes32 _key, uint _drawnNumber) internal view returns(bytes32 ID) {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n        uint treeIndex = 0;\r\n        uint currentDrawnNumber = _drawnNumber % tree.nodes[0];\r\n\r\n        while ((tree.K * treeIndex) + 1 < tree.nodes.length)  // While it still has children.\r\n            for (uint i = 1; i <= tree.K; i++) { // Loop over children.\r\n                uint nodeIndex = (tree.K * treeIndex) + i;\r\n                uint nodeValue = tree.nodes[nodeIndex];\r\n\r\n                if (currentDrawnNumber >= nodeValue) currentDrawnNumber -= nodeValue; // Go to the next child.\r\n                else { // Pick this child.\r\n                    treeIndex = nodeIndex;\r\n                    break;\r\n                }\r\n            }\r\n        \r\n        ID = tree.nodeIndexesToIDs[treeIndex];\r\n    }\r\n\r\n    /** @dev Gets a specified ID's associated value.\r\n     *  @param _key The key of the tree.\r\n     *  @param _ID The ID of the value.\r\n     *  @return The associated value.\r\n     */\r\n    function stakeOf(SortitionSumTrees storage self, bytes32 _key, bytes32 _ID) internal view returns(uint value) {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n        uint treeIndex = tree.IDsToNodeIndexes[_ID];\r\n\r\n        if (treeIndex == 0) value = 0;\r\n        else value = tree.nodes[treeIndex];\r\n    }\r\n\r\n   function total(SortitionSumTrees storage self, bytes32 _key) internal view returns (uint) {\r\n       SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n       if (tree.nodes.length == 0) {\r\n           return 0;\r\n       } else {\r\n           return tree.nodes[0];\r\n       }\r\n   }\r\n\r\n    /* Private */\r\n\r\n    /**\r\n     *  @dev Update all the parents of a node.\r\n     *  @param _key The key of the tree to update.\r\n     *  @param _treeIndex The index of the node to start from.\r\n     *  @param _plusOrMinus Wether to add (true) or substract (false).\r\n     *  @param _value The value to add or substract.\r\n     *  `O(log_k(n))` where\r\n     *  `k` is the maximum number of childs per node in the tree,\r\n     *   and `n` is the maximum number of nodes ever appended.\r\n     */\r\n    function updateParents(SortitionSumTrees storage self, bytes32 _key, uint _treeIndex, bool _plusOrMinus, uint _value) private {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n\r\n        uint parentIndex = _treeIndex;\r\n        while (parentIndex != 0) {\r\n            parentIndex = (parentIndex - 1) / tree.K;\r\n            tree.nodes[parentIndex] = _plusOrMinus ? tree.nodes[parentIndex] + _value : tree.nodes[parentIndex] - _value;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @author Brendan Asselstine\r\n * @notice Tracks committed and open balances for addresses.  Affords selection of an address by indexing all committed balances.\r\n *\r\n * Balances are tracked in Draws.  There is always one open Draw.  Deposits are always added to the open Draw.\r\n * When a new draw is opened, the previous opened draw is committed.\r\n *\r\n * The committed balance for an address is the total of their balances for committed Draws.\r\n * An address's open balance is their balance in the open Draw.\r\n */\r\nlibrary DrawManager {\r\n    using SortitionSumTreeFactory for SortitionSumTreeFactory.SortitionSumTrees;\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * The ID to use for the selection tree.\r\n     */\r\n    bytes32 public constant TREE_OF_DRAWS = \"TreeOfDraws\";\r\n\r\n    uint8 public constant MAX_BRANCHES_PER_NODE = 10;\r\n\r\n    /**\r\n     * Stores information for all draws.\r\n     */\r\n    struct State {\r\n        /**\r\n         * Each Draw stores it's address balances in a sortitionSumTree.  Draw trees are indexed using the Draw index.\r\n         * There is one root sortitionSumTree that stores all of the draw totals.  The root tree is indexed using the constant TREE_OF_DRAWS.\r\n         */\r\n        SortitionSumTreeFactory.SortitionSumTrees sortitionSumTrees;\r\n\r\n        /**\r\n         * Stores the consolidated draw index that an address deposited to.\r\n         */\r\n        mapping(address => uint256) consolidatedDrawIndices;\r\n\r\n        /**\r\n         * Stores the last Draw index that an address deposited to.\r\n         */\r\n        mapping(address => uint256) latestDrawIndices;\r\n\r\n        /**\r\n         * Stores a mapping of Draw index => Draw total\r\n         */\r\n        mapping(uint256 => uint256) __deprecated__drawTotals;\r\n\r\n        /**\r\n         * The current open Draw index\r\n         */\r\n        uint256 openDrawIndex;\r\n\r\n        /**\r\n         * The total of committed balances\r\n         */\r\n        uint256 __deprecated__committedSupply;\r\n    }\r\n\r\n    /**\r\n     * @notice Opens the next Draw and commits the previous open Draw (if any).\r\n     * @param self The drawState this library is attached to\r\n     * @return The index of the new open Draw\r\n     */\r\n    function openNextDraw(State storage self) public returns (uint256) {\r\n        if (self.openDrawIndex == 0) {\r\n            // If there is no previous draw, we must initialize\r\n            self.sortitionSumTrees.createTree(TREE_OF_DRAWS, MAX_BRANCHES_PER_NODE);\r\n        } else {\r\n            // else add current draw to sortition sum trees\r\n            bytes32 drawId = bytes32(self.openDrawIndex);\r\n            uint256 drawTotal = openSupply(self);\r\n            self.sortitionSumTrees.set(TREE_OF_DRAWS, drawTotal, drawId);\r\n        }\r\n        // now create a new draw\r\n        uint256 drawIndex = self.openDrawIndex.add(1);\r\n        self.sortitionSumTrees.createTree(bytes32(drawIndex), MAX_BRANCHES_PER_NODE);\r\n        self.openDrawIndex = drawIndex;\r\n\r\n        return drawIndex;\r\n    }\r\n\r\n    /**\r\n     * @notice Deposits the given amount into the current open draw by the given user.\r\n     * @param self The DrawManager state\r\n     * @param _addr The address to deposit for\r\n     * @param _amount The amount to deposit\r\n     */\r\n    function deposit(State storage self, address _addr, uint256 _amount) public requireOpenDraw(self) onlyNonZero(_addr) {\r\n        bytes32 userId = bytes32(uint256(_addr));\r\n        uint256 openDrawIndex = self.openDrawIndex;\r\n\r\n        // update the current draw\r\n        uint256 currentAmount = self.sortitionSumTrees.stakeOf(bytes32(openDrawIndex), userId);\r\n        currentAmount = currentAmount.add(_amount);\r\n        drawSet(self, openDrawIndex, currentAmount, _addr);\r\n\r\n        uint256 consolidatedDrawIndex = self.consolidatedDrawIndices[_addr];\r\n        uint256 latestDrawIndex = self.latestDrawIndices[_addr];\r\n\r\n        // if this is the user's first draw, set it\r\n        if (consolidatedDrawIndex == 0) {\r\n            self.consolidatedDrawIndices[_addr] = openDrawIndex;\r\n        // otherwise, if the consolidated draw is not this draw\r\n        } else if (consolidatedDrawIndex != openDrawIndex) {\r\n            // if a second draw does not exist\r\n            if (latestDrawIndex == 0) {\r\n                // set the second draw to the current draw\r\n                self.latestDrawIndices[_addr] = openDrawIndex;\r\n            // otherwise if a second draw exists but is not the current one\r\n            } else if (latestDrawIndex != openDrawIndex) {\r\n                // merge it into the first draw, and update the second draw index to this one\r\n                uint256 consolidatedAmount = self.sortitionSumTrees.stakeOf(bytes32(consolidatedDrawIndex), userId);\r\n                uint256 latestAmount = self.sortitionSumTrees.stakeOf(bytes32(latestDrawIndex), userId);\r\n                drawSet(self, consolidatedDrawIndex, consolidatedAmount.add(latestAmount), _addr);\r\n                drawSet(self, latestDrawIndex, 0, _addr);\r\n                self.latestDrawIndices[_addr] = openDrawIndex;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Deposits into a user's committed balance, thereby bypassing the open draw.\r\n     * @param self The DrawManager state\r\n     * @param _addr The address of the user for whom to deposit\r\n     * @param _amount The amount to deposit\r\n     */\r\n    function depositCommitted(State storage self, address _addr, uint256 _amount) public requireCommittedDraw(self) onlyNonZero(_addr) {\r\n        bytes32 userId = bytes32(uint256(_addr));\r\n        uint256 consolidatedDrawIndex = self.consolidatedDrawIndices[_addr];\r\n\r\n        // if they have a committed balance\r\n        if (consolidatedDrawIndex != 0 && consolidatedDrawIndex != self.openDrawIndex) {\r\n            uint256 consolidatedAmount = self.sortitionSumTrees.stakeOf(bytes32(consolidatedDrawIndex), userId);\r\n            drawSet(self, consolidatedDrawIndex, consolidatedAmount.add(_amount), _addr);\r\n        } else { // they must not have any committed balance\r\n            self.latestDrawIndices[_addr] = consolidatedDrawIndex;\r\n            self.consolidatedDrawIndices[_addr] = self.openDrawIndex.sub(1);\r\n            drawSet(self, self.consolidatedDrawIndices[_addr], _amount, _addr);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraws a user's committed and open draws.\r\n     * @param self The DrawManager state\r\n     * @param _addr The address whose balance to withdraw\r\n     */\r\n    function withdraw(State storage self, address _addr) public requireOpenDraw(self) onlyNonZero(_addr) {\r\n        uint256 consolidatedDrawIndex = self.consolidatedDrawIndices[_addr];\r\n        uint256 latestDrawIndex = self.latestDrawIndices[_addr];\r\n\r\n        if (consolidatedDrawIndex != 0) {\r\n            drawSet(self, consolidatedDrawIndex, 0, _addr);\r\n            delete self.consolidatedDrawIndices[_addr];\r\n        }\r\n\r\n        if (latestDrawIndex != 0) {\r\n            drawSet(self, latestDrawIndex, 0, _addr);\r\n            delete self.latestDrawIndices[_addr];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw's from a user's open balance\r\n     * @param self The DrawManager state\r\n     * @param _addr The user to withdrawn from\r\n     * @param _amount The amount to withdraw\r\n     */\r\n    function withdrawOpen(State storage self, address _addr, uint256 _amount) public requireOpenDraw(self) onlyNonZero(_addr) {\r\n        bytes32 userId = bytes32(uint256(_addr));\r\n        uint256 openTotal = self.sortitionSumTrees.stakeOf(bytes32(self.openDrawIndex), userId);\r\n\r\n        require(_amount <= openTotal, \"DrawMan/exceeds-open\");\r\n\r\n        uint256 remaining = openTotal.sub(_amount);\r\n\r\n        drawSet(self, self.openDrawIndex, remaining, _addr);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw's from a user's committed balance.  Fails if the user attempts to take more than available.\r\n     * @param self The DrawManager state\r\n     * @param _addr The user to withdraw from\r\n     * @param _amount The amount to withdraw.\r\n     */\r\n    function withdrawCommitted(State storage self, address _addr, uint256 _amount) public requireCommittedDraw(self) onlyNonZero(_addr) {\r\n        bytes32 userId = bytes32(uint256(_addr));\r\n        uint256 consolidatedDrawIndex = self.consolidatedDrawIndices[_addr];\r\n        uint256 latestDrawIndex = self.latestDrawIndices[_addr];\r\n\r\n        uint256 consolidatedAmount = 0;\r\n        uint256 latestAmount = 0;\r\n        uint256 total = 0;\r\n\r\n        if (latestDrawIndex != 0 && latestDrawIndex != self.openDrawIndex) {\r\n            latestAmount = self.sortitionSumTrees.stakeOf(bytes32(latestDrawIndex), userId);\r\n            total = total.add(latestAmount);\r\n        }\r\n\r\n        if (consolidatedDrawIndex != 0 && consolidatedDrawIndex != self.openDrawIndex) {\r\n            consolidatedAmount = self.sortitionSumTrees.stakeOf(bytes32(consolidatedDrawIndex), userId);\r\n            total = total.add(consolidatedAmount);\r\n        }\r\n\r\n        // If the total is greater than zero, then consolidated *must* have the committed balance\r\n        // However, if the total is zero then the consolidated balance may be the open balance\r\n        if (total == 0) {\r\n            return;\r\n        }\r\n\r\n        require(_amount <= total, \"Pool/exceed\");\r\n\r\n        uint256 remaining = total.sub(_amount);\r\n\r\n        // if there was a second amount that needs to be updated\r\n        if (remaining > consolidatedAmount) {\r\n            uint256 secondRemaining = remaining.sub(consolidatedAmount);\r\n            drawSet(self, latestDrawIndex, secondRemaining, _addr);\r\n        } else if (latestAmount > 0) { // else delete the second amount if it exists\r\n            delete self.latestDrawIndices[_addr];\r\n            drawSet(self, latestDrawIndex, 0, _addr);\r\n        }\r\n\r\n        // if the consolidated amount needs to be destroyed\r\n        if (remaining == 0) {\r\n            delete self.consolidatedDrawIndices[_addr];\r\n            drawSet(self, consolidatedDrawIndex, 0, _addr);\r\n        } else if (remaining < consolidatedAmount) {\r\n            drawSet(self, consolidatedDrawIndex, remaining, _addr);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the total balance for an address, including committed balances and the open balance.\r\n     */\r\n    function balanceOf(State storage drawState, address _addr) public view returns (uint256) {\r\n        return committedBalanceOf(drawState, _addr).add(openBalanceOf(drawState, _addr));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the total committed balance for an address.\r\n     * @param self The DrawManager state\r\n     * @param _addr The address whose committed balance should be returned\r\n     * @return The total committed balance\r\n     */\r\n    function committedBalanceOf(State storage self, address _addr) public view returns (uint256) {\r\n        uint256 balance = 0;\r\n\r\n        uint256 consolidatedDrawIndex = self.consolidatedDrawIndices[_addr];\r\n        uint256 latestDrawIndex = self.latestDrawIndices[_addr];\r\n\r\n        if (consolidatedDrawIndex != 0 && consolidatedDrawIndex != self.openDrawIndex) {\r\n            balance = self.sortitionSumTrees.stakeOf(bytes32(consolidatedDrawIndex), bytes32(uint256(_addr)));\r\n        }\r\n\r\n        if (latestDrawIndex != 0 && latestDrawIndex != self.openDrawIndex) {\r\n            balance = balance.add(self.sortitionSumTrees.stakeOf(bytes32(latestDrawIndex), bytes32(uint256(_addr))));\r\n        }\r\n\r\n        return balance;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the open balance for an address\r\n     * @param self The DrawManager state\r\n     * @param _addr The address whose open balance should be returned\r\n     * @return The open balance\r\n     */\r\n    function openBalanceOf(State storage self, address _addr) public view returns (uint256) {\r\n        if (self.openDrawIndex == 0) {\r\n            return 0;\r\n        } else {\r\n            return self.sortitionSumTrees.stakeOf(bytes32(self.openDrawIndex), bytes32(uint256(_addr)));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the open Draw balance for the DrawManager\r\n     * @param self The DrawManager state\r\n     * @return The open draw total balance\r\n     */\r\n    function openSupply(State storage self) public view returns (uint256) {\r\n        return self.sortitionSumTrees.total(bytes32(self.openDrawIndex));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the committed balance for the DrawManager\r\n     * @param self The DrawManager state\r\n     * @return The total committed balance\r\n     */\r\n    function committedSupply(State storage self) public view returns (uint256) {\r\n        return self.sortitionSumTrees.total(TREE_OF_DRAWS);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the Draw balance for an address.\r\n     * @param self The DrawManager state\r\n     * @param _drawIndex The Draw index\r\n     * @param _amount The new balance\r\n     * @param _addr The address whose balance should be updated\r\n     */\r\n    function drawSet(State storage self, uint256 _drawIndex, uint256 _amount, address _addr) internal {\r\n        bytes32 drawId = bytes32(_drawIndex);\r\n        bytes32 userId = bytes32(uint256(_addr));\r\n        uint256 oldAmount = self.sortitionSumTrees.stakeOf(drawId, userId);\r\n\r\n        if (oldAmount != _amount) {\r\n            // If the amount has changed\r\n\r\n            // Update the Draw's balance for that address\r\n            self.sortitionSumTrees.set(drawId, _amount, userId);\r\n\r\n            // if the draw is committed\r\n            if (_drawIndex != self.openDrawIndex) {\r\n                // Get the new draw total\r\n                uint256 newDrawTotal = self.sortitionSumTrees.total(drawId);\r\n\r\n                // update the draw in the committed tree\r\n                self.sortitionSumTrees.set(TREE_OF_DRAWS, newDrawTotal, drawId);\r\n            }\r\n        }\r\n    }\r\n\r\n   /**\r\n     * @notice Selects an address by indexing into the committed tokens using the passed token.\r\n     * If there is no committed supply, the zero address is returned.\r\n     * @param self The DrawManager state\r\n     * @param _token The token index to select\r\n     * @return The selected address\r\n     */\r\n    function draw(State storage self, uint256 _token) public view returns (address) {\r\n        // If there is no one to select, just return the zero address\r\n        if (committedSupply(self) == 0) {\r\n            return address(0);\r\n        }\r\n        require(_token < committedSupply(self), \"Pool/ineligible\");\r\n        bytes32 drawIndex = self.sortitionSumTrees.draw(TREE_OF_DRAWS, _token);\r\n        uint256 drawSupply = self.sortitionSumTrees.total(drawIndex);\r\n        uint256 drawToken = _token % drawSupply;\r\n        return address(uint256(self.sortitionSumTrees.draw(drawIndex, drawToken)));\r\n    }\r\n\r\n    /**\r\n     * @notice Selects an address using the entropy as an index into the committed tokens\r\n     * The entropy is passed into the UniformRandomNumber library to remove modulo bias.\r\n     * @param self The DrawManager state\r\n     * @param _entropy The random entropy to use\r\n     * @return The selected address\r\n     */\r\n    function drawWithEntropy(State storage self, bytes32 _entropy) public view returns (address) {\r\n        uint256 bound = committedSupply(self);\r\n        address selected;\r\n        if (bound == 0) {\r\n            selected = address(0);\r\n        } else {\r\n            selected = draw(self, UniformRandomNumber.uniform(uint256(_entropy), bound));\r\n        }\r\n        return selected;\r\n    }\r\n\r\n    modifier requireOpenDraw(State storage self) {\r\n        require(self.openDrawIndex > 0, \"Pool/no-open\");\r\n        _;\r\n    }\r\n\r\n    modifier requireCommittedDraw(State storage self) {\r\n        require(self.openDrawIndex > 1, \"Pool/no-commit\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyNonZero(address _addr) {\r\n        require(_addr != address(0), \"Pool/not-zero\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title FixidityLib\r\n * @author Gadi Guy, Alberto Cuesta Canada\r\n * @notice This library provides fixed point arithmetic with protection against\r\n * overflow. \r\n * All operations are done with int256 and the operands must have been created \r\n * with any of the newFrom* functions, which shift the comma digits() to the \r\n * right and check for limits.\r\n * When using this library be sure of using maxNewFixed() as the upper limit for\r\n * creation of fixed point numbers. Use maxFixedMul(), maxFixedDiv() and\r\n * maxFixedAdd() if you want to be certain that those operations don't \r\n * overflow.\r\n */\r\nlibrary FixidityLib {\r\n\r\n    /**\r\n     * @notice Number of positions that the comma is shifted to the right.\r\n     */\r\n    function digits() public pure returns(uint8) {\r\n        return 24;\r\n    }\r\n    \r\n    /**\r\n     * @notice This is 1 in the fixed point units used in this library.\r\n     * @dev Test fixed1() equals 10^digits()\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function fixed1() public pure returns(int256) {\r\n        return 1000000000000000000000000;\r\n    }\r\n\r\n    /**\r\n     * @notice The amount of decimals lost on each multiplication operand.\r\n     * @dev Test mulPrecision() equals sqrt(fixed1)\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function mulPrecision() public pure returns(int256) {\r\n        return 1000000000000;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be represented in an int256\r\n     * @dev Test maxInt256() equals 2^255 -1\r\n     */\r\n    function maxInt256() public pure returns(int256) {\r\n        return 57896044618658097711785492504343953926634992332820282019728792003956564819967;\r\n    }\r\n\r\n    /**\r\n     * @notice Minimum value that can be represented in an int256\r\n     * @dev Test minInt256 equals (2^255) * (-1)\r\n     */\r\n    function minInt256() public pure returns(int256) {\r\n        return -57896044618658097711785492504343953926634992332820282019728792003956564819968;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be converted to fixed point. Optimize for\r\n     * @dev deployment. \r\n     * Test maxNewFixed() equals maxInt256() / fixed1()\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function maxNewFixed() public pure returns(int256) {\r\n        return 57896044618658097711785492504343953926634992332820282;\r\n    }\r\n\r\n    /**\r\n     * @notice Minimum value that can be converted to fixed point. Optimize for\r\n     * deployment. \r\n     * @dev Test minNewFixed() equals -(maxInt256()) / fixed1()\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function minNewFixed() public pure returns(int256) {\r\n        return -57896044618658097711785492504343953926634992332820282;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be safely used as an addition operator.\r\n     * @dev Test maxFixedAdd() equals maxInt256()-1 / 2\r\n     * Test add(maxFixedAdd(),maxFixedAdd()) equals maxFixedAdd() + maxFixedAdd()\r\n     * Test add(maxFixedAdd()+1,maxFixedAdd()) throws \r\n     * Test add(-maxFixedAdd(),-maxFixedAdd()) equals -maxFixedAdd() - maxFixedAdd()\r\n     * Test add(-maxFixedAdd(),-maxFixedAdd()-1) throws \r\n     */\r\n    function maxFixedAdd() public pure returns(int256) {\r\n        return 28948022309329048855892746252171976963317496166410141009864396001978282409983;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum negative value that can be safely in a subtraction.\r\n     * @dev Test maxFixedSub() equals minInt256() / 2\r\n     */\r\n    function maxFixedSub() public pure returns(int256) {\r\n        return -28948022309329048855892746252171976963317496166410141009864396001978282409984;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be safely used as a multiplication operator.\r\n     * @dev Calculated as sqrt(maxInt256()*fixed1()). \r\n     * Be careful with your sqrt() implementation. I couldn't find a calculator\r\n     * that would give the exact square root of maxInt256*fixed1 so this number\r\n     * is below the real number by no more than 3*10**28. It is safe to use as\r\n     * a limit for your multiplications, although powers of two of numbers over\r\n     * this value might still work.\r\n     * Test multiply(maxFixedMul(),maxFixedMul()) equals maxFixedMul() * maxFixedMul()\r\n     * Test multiply(maxFixedMul(),maxFixedMul()+1) throws \r\n     * Test multiply(-maxFixedMul(),maxFixedMul()) equals -maxFixedMul() * maxFixedMul()\r\n     * Test multiply(-maxFixedMul(),maxFixedMul()+1) throws \r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function maxFixedMul() public pure returns(int256) {\r\n        return 240615969168004498257251713877715648331380787511296;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be safely used as a dividend.\r\n     * @dev divide(maxFixedDiv,newFixedFraction(1,fixed1())) = maxInt256().\r\n     * Test maxFixedDiv() equals maxInt256()/fixed1()\r\n     * Test divide(maxFixedDiv(),multiply(mulPrecision(),mulPrecision())) = maxFixedDiv()*(10^digits())\r\n     * Test divide(maxFixedDiv()+1,multiply(mulPrecision(),mulPrecision())) throws\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function maxFixedDiv() public pure returns(int256) {\r\n        return 57896044618658097711785492504343953926634992332820282;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be safely used as a divisor.\r\n     * @dev Test maxFixedDivisor() equals fixed1()*fixed1() - Or 10**(digits()*2)\r\n     * Test divide(10**(digits()*2 + 1),10**(digits()*2)) = returns 10*fixed1()\r\n     * Test divide(10**(digits()*2 + 1),10**(digits()*2 + 1)) = throws\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function maxFixedDivisor() public pure returns(int256) {\r\n        return 1000000000000000000000000000000000000000000000000;\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 to fixed point units, equivalent to multiplying\r\n     * by 10^digits().\r\n     * @dev Test newFixed(0) returns 0\r\n     * Test newFixed(1) returns fixed1()\r\n     * Test newFixed(maxNewFixed()) returns maxNewFixed() * fixed1()\r\n     * Test newFixed(maxNewFixed()+1) fails\r\n     */\r\n    function newFixed(int256 x)\r\n        public\r\n        pure\r\n        returns (int256)\r\n    {\r\n        require(x <= maxNewFixed());\r\n        require(x >= minNewFixed());\r\n        return x * fixed1();\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 in the fixed point representation of this \r\n     * library to a non decimal. All decimal digits will be truncated.\r\n     */\r\n    function fromFixed(int256 x)\r\n        public\r\n        pure\r\n        returns (int256)\r\n    {\r\n        return x / fixed1();\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 which is already in some fixed point \r\n     * representation to a different fixed precision representation.\r\n     * Both the origin and destination precisions must be 38 or less digits.\r\n     * Origin values with a precision higher than the destination precision\r\n     * will be truncated accordingly.\r\n     * @dev \r\n     * Test convertFixed(1,0,0) returns 1;\r\n     * Test convertFixed(1,1,1) returns 1;\r\n     * Test convertFixed(1,1,0) returns 0;\r\n     * Test convertFixed(1,0,1) returns 10;\r\n     * Test convertFixed(10,1,0) returns 1;\r\n     * Test convertFixed(10,0,1) returns 100;\r\n     * Test convertFixed(100,1,0) returns 10;\r\n     * Test convertFixed(100,0,1) returns 1000;\r\n     * Test convertFixed(1000,2,0) returns 10;\r\n     * Test convertFixed(1000,0,2) returns 100000;\r\n     * Test convertFixed(1000,2,1) returns 100;\r\n     * Test convertFixed(1000,1,2) returns 10000;\r\n     * Test convertFixed(maxInt256,1,0) returns maxInt256/10;\r\n     * Test convertFixed(maxInt256,0,1) throws\r\n     * Test convertFixed(maxInt256,38,0) returns maxInt256/(10**38);\r\n     * Test convertFixed(1,0,38) returns 10**38;\r\n     * Test convertFixed(maxInt256,39,0) throws\r\n     * Test convertFixed(1,0,39) throws\r\n     */\r\n    function convertFixed(int256 x, uint8 _originDigits, uint8 _destinationDigits)\r\n        public\r\n        pure\r\n        returns (int256)\r\n    {\r\n        require(_originDigits <= 38 && _destinationDigits <= 38);\r\n        \r\n        uint8 decimalDifference;\r\n        if ( _originDigits > _destinationDigits ){\r\n            decimalDifference = _originDigits - _destinationDigits;\r\n            return x/(uint128(10)**uint128(decimalDifference));\r\n        }\r\n        else if ( _originDigits < _destinationDigits ){\r\n            decimalDifference = _destinationDigits - _originDigits;\r\n            // Cast uint8 -> uint128 is safe\r\n            // Exponentiation is safe:\r\n            //     _originDigits and _destinationDigits limited to 38 or less\r\n            //     decimalDifference = abs(_destinationDigits - _originDigits)\r\n            //     decimalDifference < 38\r\n            //     10**38 < 2**128-1\r\n            require(x <= maxInt256()/uint128(10)**uint128(decimalDifference));\r\n            require(x >= minInt256()/uint128(10)**uint128(decimalDifference));\r\n            return x*(uint128(10)**uint128(decimalDifference));\r\n        }\r\n        // _originDigits == digits()) \r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 which is already in some fixed point \r\n     * representation to that of this library. The _originDigits parameter is the\r\n     * precision of x. Values with a precision higher than FixidityLib.digits()\r\n     * will be truncated accordingly.\r\n     */\r\n    function newFixed(int256 x, uint8 _originDigits)\r\n        public\r\n        pure\r\n        returns (int256)\r\n    {\r\n        return convertFixed(x, _originDigits, digits());\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 in the fixed point representation of this \r\n     * library to a different representation. The _destinationDigits parameter is the\r\n     * precision of the output x. Values with a precision below than \r\n     * FixidityLib.digits() will be truncated accordingly.\r\n     */\r\n    function fromFixed(int256 x, uint8 _destinationDigits)\r\n        public\r\n        pure\r\n        returns (int256)\r\n    {\r\n        return convertFixed(x, digits(), _destinationDigits);\r\n    }\r\n\r\n    /**\r\n     * @notice Converts two int256 representing a fraction to fixed point units,\r\n     * equivalent to multiplying dividend and divisor by 10^digits().\r\n     * @dev \r\n     * Test newFixedFraction(maxFixedDiv()+1,1) fails\r\n     * Test newFixedFraction(1,maxFixedDiv()+1) fails\r\n     * Test newFixedFraction(1,0) fails     \r\n     * Test newFixedFraction(0,1) returns 0\r\n     * Test newFixedFraction(1,1) returns fixed1()\r\n     * Test newFixedFraction(maxFixedDiv(),1) returns maxFixedDiv()*fixed1()\r\n     * Test newFixedFraction(1,fixed1()) returns 1\r\n     * Test newFixedFraction(1,fixed1()-1) returns 0\r\n     */\r\n    function newFixedFraction(\r\n        int256 numerator, \r\n        int256 denominator\r\n        )\r\n        public\r\n        pure\r\n        returns (int256)\r\n    {\r\n        require(numerator <= maxNewFixed());\r\n        require(denominator <= maxNewFixed());\r\n        require(denominator != 0);\r\n        int256 convertedNumerator = newFixed(numerator);\r\n        int256 convertedDenominator = newFixed(denominator);\r\n        return divide(convertedNumerator, convertedDenominator);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the integer part of a fixed point number.\r\n     * @dev \r\n     * Test integer(0) returns 0\r\n     * Test integer(fixed1()) returns fixed1()\r\n     * Test integer(newFixed(maxNewFixed())) returns maxNewFixed()*fixed1()\r\n     * Test integer(-fixed1()) returns -fixed1()\r\n     * Test integer(newFixed(-maxNewFixed())) returns -maxNewFixed()*fixed1()\r\n     */\r\n    function integer(int256 x) public pure returns (int256) {\r\n        return (x / fixed1()) * fixed1(); // Can't overflow\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the fractional part of a fixed point number. \r\n     * In the case of a negative number the fractional is also negative.\r\n     * @dev \r\n     * Test fractional(0) returns 0\r\n     * Test fractional(fixed1()) returns 0\r\n     * Test fractional(fixed1()-1) returns 10^24-1\r\n     * Test fractional(-fixed1()) returns 0\r\n     * Test fractional(-fixed1()+1) returns -10^24-1\r\n     */\r\n    function fractional(int256 x) public pure returns (int256) {\r\n        return x - (x / fixed1()) * fixed1(); // Can't overflow\r\n    }\r\n\r\n    /**\r\n     * @notice Converts to positive if negative.\r\n     * Due to int256 having one more negative number than positive numbers \r\n     * abs(minInt256) reverts.\r\n     * @dev \r\n     * Test abs(0) returns 0\r\n     * Test abs(fixed1()) returns -fixed1()\r\n     * Test abs(-fixed1()) returns fixed1()\r\n     * Test abs(newFixed(maxNewFixed())) returns maxNewFixed()*fixed1()\r\n     * Test abs(newFixed(minNewFixed())) returns -minNewFixed()*fixed1()\r\n     */\r\n    function abs(int256 x) public pure returns (int256) {\r\n        if (x >= 0) {\r\n            return x;\r\n        } else {\r\n            int256 result = -x;\r\n            assert (result > 0);\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice x+y. If any operator is higher than maxFixedAdd() it \r\n     * might overflow.\r\n     * In solidity maxInt256 + 1 = minInt256 and viceversa.\r\n     * @dev \r\n     * Test add(maxFixedAdd(),maxFixedAdd()) returns maxInt256()-1\r\n     * Test add(maxFixedAdd()+1,maxFixedAdd()+1) fails\r\n     * Test add(-maxFixedSub(),-maxFixedSub()) returns minInt256()\r\n     * Test add(-maxFixedSub()-1,-maxFixedSub()-1) fails\r\n     * Test add(maxInt256(),maxInt256()) fails\r\n     * Test add(minInt256(),minInt256()) fails\r\n     */\r\n    function add(int256 x, int256 y) public pure returns (int256) {\r\n        int256 z = x + y;\r\n        if (x > 0 && y > 0) assert(z > x && z > y);\r\n        if (x < 0 && y < 0) assert(z < x && z < y);\r\n        return z;\r\n    }\r\n\r\n    /**\r\n     * @notice x-y. You can use add(x,-y) instead. \r\n     * @dev Tests covered by add(x,y)\r\n     */\r\n    function subtract(int256 x, int256 y) public pure returns (int256) {\r\n        return add(x,-y);\r\n    }\r\n\r\n    /**\r\n     * @notice x*y. If any of the operators is higher than maxFixedMul() it \r\n     * might overflow.\r\n     * @dev \r\n     * Test multiply(0,0) returns 0\r\n     * Test multiply(maxFixedMul(),0) returns 0\r\n     * Test multiply(0,maxFixedMul()) returns 0\r\n     * Test multiply(maxFixedMul(),fixed1()) returns maxFixedMul()\r\n     * Test multiply(fixed1(),maxFixedMul()) returns maxFixedMul()\r\n     * Test all combinations of (2,-2), (2, 2.5), (2, -2.5) and (0.5, -0.5)\r\n     * Test multiply(fixed1()/mulPrecision(),fixed1()*mulPrecision())\r\n     * Test multiply(maxFixedMul()-1,maxFixedMul()) equals multiply(maxFixedMul(),maxFixedMul()-1)\r\n     * Test multiply(maxFixedMul(),maxFixedMul()) returns maxInt256() // Probably not to the last digits\r\n     * Test multiply(maxFixedMul()+1,maxFixedMul()) fails\r\n     * Test multiply(maxFixedMul(),maxFixedMul()+1) fails\r\n     */\r\n    function multiply(int256 x, int256 y) public pure returns (int256) {\r\n        if (x == 0 || y == 0) return 0;\r\n        if (y == fixed1()) return x;\r\n        if (x == fixed1()) return y;\r\n\r\n        // Separate into integer and fractional parts\r\n        // x = x1 + x2, y = y1 + y2\r\n        int256 x1 = integer(x) / fixed1();\r\n        int256 x2 = fractional(x);\r\n        int256 y1 = integer(y) / fixed1();\r\n        int256 y2 = fractional(y);\r\n        \r\n        // (x1 + x2) * (y1 + y2) = (x1 * y1) + (x1 * y2) + (x2 * y1) + (x2 * y2)\r\n        int256 x1y1 = x1 * y1;\r\n        if (x1 != 0) assert(x1y1 / x1 == y1); // Overflow x1y1\r\n        \r\n        // x1y1 needs to be multiplied back by fixed1\r\n        // solium-disable-next-line mixedcase\r\n        int256 fixed_x1y1 = x1y1 * fixed1();\r\n        if (x1y1 != 0) assert(fixed_x1y1 / x1y1 == fixed1()); // Overflow x1y1 * fixed1\r\n        x1y1 = fixed_x1y1;\r\n\r\n        int256 x2y1 = x2 * y1;\r\n        if (x2 != 0) assert(x2y1 / x2 == y1); // Overflow x2y1\r\n\r\n        int256 x1y2 = x1 * y2;\r\n        if (x1 != 0) assert(x1y2 / x1 == y2); // Overflow x1y2\r\n\r\n        x2 = x2 / mulPrecision();\r\n        y2 = y2 / mulPrecision();\r\n        int256 x2y2 = x2 * y2;\r\n        if (x2 != 0) assert(x2y2 / x2 == y2); // Overflow x2y2\r\n\r\n        // result = fixed1() * x1 * y1 + x1 * y2 + x2 * y1 + x2 * y2 / fixed1();\r\n        int256 result = x1y1;\r\n        result = add(result, x2y1); // Add checks for overflow\r\n        result = add(result, x1y2); // Add checks for overflow\r\n        result = add(result, x2y2); // Add checks for overflow\r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * @notice 1/x\r\n     * @dev \r\n     * Test reciprocal(0) fails\r\n     * Test reciprocal(fixed1()) returns fixed1()\r\n     * Test reciprocal(fixed1()*fixed1()) returns 1 // Testing how the fractional is truncated\r\n     * Test reciprocal(2*fixed1()*fixed1()) returns 0 // Testing how the fractional is truncated\r\n     */\r\n    function reciprocal(int256 x) public pure returns (int256) {\r\n        require(x != 0);\r\n        return (fixed1()*fixed1()) / x; // Can't overflow\r\n    }\r\n\r\n    /**\r\n     * @notice x/y. If the dividend is higher than maxFixedDiv() it \r\n     * might overflow. You can use multiply(x,reciprocal(y)) instead.\r\n     * There is a loss of precision on division for the lower mulPrecision() decimals.\r\n     * @dev \r\n     * Test divide(fixed1(),0) fails\r\n     * Test divide(maxFixedDiv(),1) = maxFixedDiv()*(10^digits())\r\n     * Test divide(maxFixedDiv()+1,1) throws\r\n     * Test divide(maxFixedDiv(),maxFixedDiv()) returns fixed1()\r\n     */\r\n    function divide(int256 x, int256 y) public pure returns (int256) {\r\n        if (y == fixed1()) return x;\r\n        require(y != 0);\r\n        require(y <= maxFixedDivisor());\r\n        return multiply(x, reciprocal(y));\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Blocklock\r\n * @author Brendan Asselstine\r\n * @notice A time lock with a cooldown period.  When locked, the contract will remain locked until it is unlocked manually\r\n * or the lock duration expires.  After the contract is unlocked, it cannot be locked until the cooldown duration expires.\r\n */\r\nlibrary Blocklock {\r\n  using SafeMath for uint256;\r\n\r\n  struct State {\r\n    uint256 lockedAt;\r\n    uint256 unlockedAt;\r\n    uint256 lockDuration;\r\n    uint256 cooldownDuration;\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the duration of the lock.  This how long the lock lasts before it expires and automatically unlocks.\r\n   * @param self The Blocklock state\r\n   * @param lockDuration The duration, in blocks, that the lock should last.\r\n   */\r\n  function setLockDuration(State storage self, uint256 lockDuration) public {\r\n    require(lockDuration > 0, \"Blocklock/lock-min\");\r\n    self.lockDuration = lockDuration;\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the cooldown duration in blocks.  This is the number of blocks that must pass before being able to\r\n   * lock again.  The cooldown duration begins when the lock duration expires, or when it is unlocked manually.\r\n   * @param self The Blocklock state\r\n   * @param cooldownDuration The duration of the cooldown, in blocks.\r\n   */\r\n  function setCooldownDuration(State storage self, uint256 cooldownDuration) public {\r\n    require(cooldownDuration > 0, \"Blocklock/cool-min\");\r\n    self.cooldownDuration = cooldownDuration;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns whether the state is locked at the given block number.\r\n   * @param self The Blocklock state\r\n   * @param blockNumber The current block number.\r\n   */\r\n  function isLocked(State storage self, uint256 blockNumber) public view returns (bool) {\r\n    uint256 endAt = lockEndAt(self);\r\n    return (\r\n      self.lockedAt != 0 &&\r\n      blockNumber >= self.lockedAt &&\r\n      blockNumber < endAt\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Locks the state at the given block number.\r\n   * @param self The Blocklock state\r\n   * @param blockNumber The block number to use as the lock start time\r\n   */\r\n  function lock(State storage self, uint256 blockNumber) public {\r\n    require(canLock(self, blockNumber), \"Blocklock/no-lock\");\r\n    self.lockedAt = blockNumber;\r\n  }\r\n\r\n  /**\r\n   * @notice Manually unlocks the lock.\r\n   * @param self The Blocklock state\r\n   * @param blockNumber The block number at which the lock is being unlocked.\r\n   */\r\n  function unlock(State storage self, uint256 blockNumber) public {\r\n    self.unlockedAt = blockNumber;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns whether the Blocklock can be locked at the given block number\r\n   * @param self The Blocklock state\r\n   * @param blockNumber The block number to check against\r\n   * @return True if we can lock at the given block number, false otherwise.\r\n   */\r\n  function canLock(State storage self, uint256 blockNumber) public view returns (bool) {\r\n    uint256 endAt = lockEndAt(self);\r\n    return (\r\n      self.lockedAt == 0 ||\r\n      blockNumber >= endAt.add(self.cooldownDuration)\r\n    );\r\n  }\r\n\r\n  function cooldownEndAt(State storage self) internal view returns (uint256) {\r\n    return lockEndAt(self).add(self.cooldownDuration);\r\n  }\r\n\r\n  function lockEndAt(State storage self) internal view returns (uint256) {\r\n    uint256 endAt = self.lockedAt.add(self.lockDuration);\r\n    // if we unlocked early\r\n    if (self.unlockedAt >= self.lockedAt && self.unlockedAt < endAt) {\r\n      endAt = self.unlockedAt;\r\n    }\r\n    return endAt;\r\n  }\r\n}\r\n\r\n/**\r\nCopyright 2020 PoolTogether Inc.\r\n\r\nThis file is part of PoolTogether.\r\n\r\nPoolTogether is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation under version 3 of the License.\r\n\r\nPoolTogether is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC777Token standard as defined in the EIP.\r\n *\r\n * This contract uses the\r\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\r\n * token holders and recipients react to token movements by using setting implementers\r\n * for the associated interfaces in said registry. See {IERC1820Registry} and\r\n * {ERC1820Implementer}.\r\n */\r\ninterface IERC777 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the smallest part of the token that is not divisible. This\r\n     * means all token operations (creation, movement and destruction) must have\r\n     * amounts that are a multiple of this number.\r\n     *\r\n     * For most token contracts, this value will equal 1.\r\n     */\r\n    function granularity() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by an account (`owner`).\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * If send or receive hooks are registered for the caller and `recipient`,\r\n     * the corresponding functions will be called with `data` and empty\r\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\r\n     *\r\n     * Emits a {Sent} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - the caller must have at least `amount` tokens.\r\n     * - `recipient` cannot be the zero address.\r\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\r\n     * interface.\r\n     */\r\n    function send(address recipient, uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\r\n     * total supply.\r\n     *\r\n     * If a send hook is registered for the caller, the corresponding function\r\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\r\n     *\r\n     * Emits a {Burned} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - the caller must have at least `amount` tokens.\r\n     */\r\n    function burn(uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev Returns true if an account is an operator of `tokenHolder`.\r\n     * Operators can send and burn tokens on behalf of their owners. All\r\n     * accounts are their own operator.\r\n     *\r\n     * See {operatorSend} and {operatorBurn}.\r\n     */\r\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Make an account an operator of the caller.\r\n     *\r\n     * See {isOperatorFor}.\r\n     *\r\n     * Emits an {AuthorizedOperator} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `operator` cannot be calling address.\r\n     */\r\n    function authorizeOperator(address operator) external;\r\n\r\n    /**\r\n     * @dev Make an account an operator of the caller.\r\n     *\r\n     * See {isOperatorFor} and {defaultOperators}.\r\n     *\r\n     * Emits a {RevokedOperator} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `operator` cannot be calling address.\r\n     */\r\n    function revokeOperator(address operator) external;\r\n\r\n    /**\r\n     * @dev Returns the list of default operators. These accounts are operators\r\n     * for all token holders, even if {authorizeOperator} was never called on\r\n     * them.\r\n     *\r\n     * This list is immutable, but individual holders may revoke these via\r\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\r\n     */\r\n    function defaultOperators() external view returns (address[] memory);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\r\n     * be an operator of `sender`.\r\n     *\r\n     * If send or receive hooks are registered for `sender` and `recipient`,\r\n     * the corresponding functions will be called with `data` and\r\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\r\n     *\r\n     * Emits a {Sent} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `sender` must have at least `amount` tokens.\r\n     * - the caller must be an operator for `sender`.\r\n     * - `recipient` cannot be the zero address.\r\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\r\n     * interface.\r\n     */\r\n    function operatorSend(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Destoys `amount` tokens from `account`, reducing the total supply.\r\n     * The caller must be an operator of `account`.\r\n     *\r\n     * If a send hook is registered for `account`, the corresponding function\r\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\r\n     *\r\n     * Emits a {Burned} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     * - the caller must be an operator for `account`.\r\n     */\r\n    function operatorBurn(\r\n        address account,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    event Sent(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount,\r\n        bytes data,\r\n        bytes operatorData\r\n    );\r\n\r\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\r\n\r\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\r\n\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\r\n *\r\n * {IERC777} Token holders can be notified of operations performed on their\r\n * tokens by having a contract implement this interface (contract holders can be\r\n *  their own implementer) and registering it on the\r\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\r\n *\r\n * See {IERC1820Registry} and {ERC1820Implementer}.\r\n */\r\ninterface IERC777Sender {\r\n    /**\r\n     * @dev Called by an {IERC777} token contract whenever a registered holder's\r\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\r\n     * is conveyed by `to` being the zero address or not.\r\n     *\r\n     * This call occurs _before_ the token contract's state is updated, so\r\n     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\r\n     *\r\n     * This function may revert to prevent the operation from being executed.\r\n     */\r\n    function tokensToSend(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC777} interface.\r\n *\r\n * Largely taken from the OpenZeppelin ERC777 contract.\r\n *\r\n * Support for ERC20 is included in this contract, as specified by the EIP: both\r\n * the ERC777 and ERC20 interfaces can be safely used when interacting with it.\r\n * Both {IERC777-Sent} and {IERC20-Transfer} events are emitted on token\r\n * movements.\r\n *\r\n * Additionally, the {IERC777-granularity} value is hard-coded to `1`, meaning that there\r\n * are no special restrictions in the amount of tokens that created, moved, or\r\n * destroyed. This makes integration with ERC20 applications seamless.\r\n *\r\n * It is important to note that no Mint events are emitted.  Tokens are minted in batches\r\n * by a state change in a tree data structure, so emitting a Mint event for each user\r\n * is not possible.\r\n *\r\n */\r\ncontract PoolToken is Initializable, IERC20, IERC777 {\r\n  using SafeMath for uint256;\r\n  using Address for address;\r\n\r\n  /**\r\n   * Event emitted when a user or operator redeems tokens\r\n   */\r\n  event Redeemed(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\r\n\r\n  IERC1820Registry constant internal ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\r\n  // We inline the result of the following hashes because Solidity doesn't resolve them at compile time.\r\n  // See https://github.com/ethereum/solidity/issues/4024.\r\n\r\n  // keccak256(\"ERC777TokensSender\")\r\n  bytes32 constant internal TOKENS_SENDER_INTERFACE_HASH =\r\n      0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;\r\n\r\n  // keccak256(\"ERC777TokensRecipient\")\r\n  bytes32 constant internal TOKENS_RECIPIENT_INTERFACE_HASH =\r\n      0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\r\n\r\n  // keccak256(\"ERC777Token\")\r\n  bytes32 constant internal TOKENS_INTERFACE_HASH =\r\n      0xac7fbab5f54a3ca8194167523c6753bfeb96a445279294b6125b68cce2177054;\r\n\r\n  // keccak256(\"ERC20Token\")\r\n  bytes32 constant internal ERC20_TOKENS_INTERFACE_HASH =\r\n      0xaea199e31a596269b42cdafd93407f14436db6e4cad65417994c2eb37381e05a;\r\n\r\n  string internal _name;\r\n  string internal _symbol;\r\n\r\n  // This isn't ever read from - it's only used to respond to the defaultOperators query.\r\n  address[] internal _defaultOperatorsArray;\r\n\r\n  // Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\r\n  mapping(address => bool) internal _defaultOperators;\r\n\r\n  // For each account, a mapping of its operators and revoked default operators.\r\n  mapping(address => mapping(address => bool)) internal _operators;\r\n  mapping(address => mapping(address => bool)) internal _revokedDefaultOperators;\r\n\r\n  // ERC20-allowances\r\n  mapping (address => mapping (address => uint256)) internal _allowances;\r\n\r\n  // The Pool that is bound to this token\r\n  BasePool internal _pool;\r\n\r\n  /**\r\n   * @notice Initializes the PoolToken.\r\n   * @param name The name of the token\r\n   * @param symbol The token symbol\r\n   * @param defaultOperators The default operators who are allowed to move tokens\r\n   */\r\n  function init (\r\n    string memory name,\r\n    string memory symbol,\r\n    address[] memory defaultOperators,\r\n    BasePool pool\r\n  ) public initializer {\r\n      require(bytes(name).length != 0, \"PoolToken/name\");\r\n      require(bytes(symbol).length != 0, \"PoolToken/symbol\");\r\n      require(address(pool) != address(0), \"PoolToken/pool-zero\");\r\n\r\n      _name = name;\r\n      _symbol = symbol;\r\n      _pool = pool;\r\n\r\n      _defaultOperatorsArray = defaultOperators;\r\n      for (uint256 i = 0; i < _defaultOperatorsArray.length; i++) {\r\n          _defaultOperators[_defaultOperatorsArray[i]] = true;\r\n      }\r\n\r\n      // register interfaces\r\n      ERC1820_REGISTRY.setInterfaceImplementer(address(this), TOKENS_INTERFACE_HASH, address(this));\r\n      ERC1820_REGISTRY.setInterfaceImplementer(address(this), ERC20_TOKENS_INTERFACE_HASH, address(this));\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the address of the Pool contract\r\n   * @return The address of the pool contract\r\n   */\r\n  function pool() public view returns (BasePool) {\r\n      return _pool;\r\n  }\r\n\r\n  /**\r\n   * @notice Calls the ERC777 transfer hook, and emits Redeemed and Transfer.  Can only be called by the Pool contract.\r\n   * @param from The address from which to redeem tokens\r\n   * @param amount The amount of tokens to redeem\r\n   */\r\n  function poolRedeem(address from, uint256 amount) external onlyPool {\r\n      _callTokensToSend(from, from, address(0), amount, '', '');\r\n\r\n      emit Redeemed(from, from, amount, '', '');\r\n      emit Transfer(from, address(0), amount);\r\n  }\r\n\r\n  /**\r\n    * @dev See {IERC777-name}.\r\n    */\r\n  function name() public view returns (string memory) {\r\n      return _name;\r\n  }\r\n\r\n  /**\r\n    * @dev See {IERC777-symbol}.\r\n    */\r\n  function symbol() public view returns (string memory) {\r\n      return _symbol;\r\n  }\r\n\r\n  /**\r\n    * @dev See {ERC20Detailed-decimals}.\r\n    *\r\n    * Always returns 18, as per the\r\n    * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\r\n    */\r\n  function decimals() public view returns (uint8) {\r\n      return 18;\r\n  }\r\n\r\n  /**\r\n    * @dev See {IERC777-granularity}.\r\n    *\r\n    * This implementation always returns `1`.\r\n    */\r\n  function granularity() public view returns (uint256) {\r\n      return 1;\r\n  }\r\n\r\n  /**\r\n    * @dev See {IERC777-totalSupply}.\r\n    */\r\n  function totalSupply() public view returns (uint256) {\r\n      return _pool.committedSupply();\r\n  }\r\n\r\n  /**\r\n    * @dev See {IERC20-balanceOf}.\r\n    */\r\n  function balanceOf(address _addr) external view returns (uint256) {\r\n      return _pool.committedBalanceOf(_addr);\r\n  }\r\n\r\n  /**\r\n    * @dev See {IERC777-send}.\r\n    *\r\n    * Also emits a {Transfer} event for ERC20 compatibility.\r\n    */\r\n  function send(address recipient, uint256 amount, bytes calldata data) external {\r\n      _send(msg.sender, msg.sender, recipient, amount, data, \"\");\r\n  }\r\n\r\n  /**\r\n    * @dev See {IERC20-transfer}.\r\n    *\r\n    * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\r\n    * interface if it is a contract.\r\n    *\r\n    * Also emits a {Sent} event.\r\n    */\r\n  function transfer(address recipient, uint256 amount) external returns (bool) {\r\n      require(recipient != address(0), \"PoolToken/transfer-zero\");\r\n\r\n      address from = msg.sender;\r\n\r\n      _callTokensToSend(from, from, recipient, amount, \"\", \"\");\r\n\r\n      _move(from, from, recipient, amount, \"\", \"\");\r\n\r\n      _callTokensReceived(from, from, recipient, amount, \"\", \"\", false);\r\n\r\n      return true;\r\n  }\r\n\r\n  /**\r\n    * @dev Allows a user to withdraw their tokens as the underlying asset.\r\n    *\r\n    * Also emits a {Transfer} event for ERC20 compatibility.\r\n    */\r\n  function redeem(uint256 amount, bytes calldata data) external {\r\n      _redeem(msg.sender, msg.sender, amount, data, \"\");\r\n  }\r\n\r\n  /**\r\n    * @dev See {IERC777-burn}.  Not currently implemented.\r\n    *\r\n    * Also emits a {Transfer} event for ERC20 compatibility.\r\n    */\r\n  function burn(uint256, bytes calldata) external {\r\n      revert(\"PoolToken/no-support\");\r\n  }\r\n\r\n  /**\r\n    * @dev See {IERC777-isOperatorFor}.\r\n    */\r\n  function isOperatorFor(\r\n      address operator,\r\n      address tokenHolder\r\n  ) public view returns (bool) {\r\n      return operator == tokenHolder ||\r\n          (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||\r\n          _operators[tokenHolder][operator];\r\n  }\r\n\r\n  /**\r\n    * @dev See {IERC777-authorizeOperator}.\r\n    */\r\n  function authorizeOperator(address operator) external {\r\n      require(msg.sender != operator, \"PoolToken/auth-self\");\r\n\r\n      if (_defaultOperators[operator]) {\r\n          delete _revokedDefaultOperators[msg.sender][operator];\r\n      } else {\r\n          _operators[msg.sender][operator] = true;\r\n      }\r\n\r\n      emit AuthorizedOperator(operator, msg.sender);\r\n  }\r\n\r\n  /**\r\n    * @dev See {IERC777-revokeOperator}.\r\n    */\r\n  function revokeOperator(address operator) external {\r\n      require(operator != msg.sender, \"PoolToken/revoke-self\");\r\n\r\n      if (_defaultOperators[operator]) {\r\n          _revokedDefaultOperators[msg.sender][operator] = true;\r\n      } else {\r\n          delete _operators[msg.sender][operator];\r\n      }\r\n\r\n      emit RevokedOperator(operator, msg.sender);\r\n  }\r\n\r\n  /**\r\n    * @dev See {IERC777-defaultOperators}.\r\n    */\r\n  function defaultOperators() public view returns (address[] memory) {\r\n      return _defaultOperatorsArray;\r\n  }\r\n\r\n  /**\r\n    * @dev See {IERC777-operatorSend}.\r\n    *\r\n    * Emits {Sent} and {Transfer} events.\r\n    */\r\n  function operatorSend(\r\n      address sender,\r\n      address recipient,\r\n      uint256 amount,\r\n      bytes calldata data,\r\n      bytes calldata operatorData\r\n  )\r\n  external\r\n  {\r\n      require(isOperatorFor(msg.sender, sender), \"PoolToken/not-operator\");\r\n      _send(msg.sender, sender, recipient, amount, data, operatorData);\r\n  }\r\n\r\n  /**\r\n    * @dev See {IERC777-operatorBurn}.\r\n    *\r\n    * Currently not supported\r\n    */\r\n  function operatorBurn(address, uint256, bytes calldata, bytes calldata) external {\r\n      revert(\"PoolToken/no-support\");\r\n  }\r\n\r\n  /**\r\n    * @dev Allows an operator to redeem tokens for the underlying asset on behalf of a user.\r\n    *\r\n    * Emits {Redeemed} and {Transfer} events.\r\n    */\r\n  function operatorRedeem(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external {\r\n      require(isOperatorFor(msg.sender, account), \"PoolToken/not-operator\");\r\n      _redeem(msg.sender, account, amount, data, operatorData);\r\n  }\r\n\r\n  /**\r\n    * @dev See {IERC20-allowance}.\r\n    *\r\n    * Note that operator and allowance concepts are orthogonal: operators may\r\n    * not have allowance, and accounts with allowance may not be operators\r\n    * themselves.\r\n    */\r\n  function allowance(address holder, address spender) public view returns (uint256) {\r\n      return _allowances[holder][spender];\r\n  }\r\n\r\n  /**\r\n    * @dev See {IERC20-approve}.\r\n    *\r\n    * Note that accounts cannot have allowance issued by their operators.\r\n    */\r\n  function approve(address spender, uint256 value) external returns (bool) {\r\n      address holder = msg.sender;\r\n      _approve(holder, spender, value);\r\n      return true;\r\n  }\r\n\r\n  /**\r\n    * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n    *\r\n    * This is an alternative to {approve} that can be used as a mitigation for\r\n    * problems described in {IERC20-approve}.\r\n    *\r\n    * Emits an {Approval} event indicating the updated allowance.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `spender` cannot be the zero address.\r\n    */\r\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n      _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n      return true;\r\n  }\r\n\r\n  /**\r\n    * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n    *\r\n    * This is an alternative to {approve} that can be used as a mitigation for\r\n    * problems described in {IERC20-approve}.\r\n    *\r\n    * Emits an {Approval} event indicating the updated allowance.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `spender` cannot be the zero address.\r\n    * - `spender` must have allowance for the caller of at least\r\n    * `subtractedValue`.\r\n    */\r\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n      _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"PoolToken/negative\"));\r\n      return true;\r\n  }\r\n\r\n  /**\r\n  * @dev See {IERC20-transferFrom}.\r\n  *\r\n  * Note that operator and allowance concepts are orthogonal: operators cannot\r\n  * call `transferFrom` (unless they have allowance), and accounts with\r\n  * allowance cannot call `operatorSend` (unless they are operators).\r\n  *\r\n  * Emits {Sent}, {Transfer} and {Approval} events.\r\n  */\r\n  function transferFrom(address holder, address recipient, uint256 amount) external returns (bool) {\r\n      require(recipient != address(0), \"PoolToken/to-zero\");\r\n      require(holder != address(0), \"PoolToken/from-zero\");\r\n\r\n      address spender = msg.sender;\r\n\r\n      _callTokensToSend(spender, holder, recipient, amount, \"\", \"\");\r\n\r\n      _move(spender, holder, recipient, amount, \"\", \"\");\r\n      _approve(holder, spender, _allowances[holder][spender].sub(amount, \"PoolToken/exceed-allow\"));\r\n\r\n      _callTokensReceived(spender, holder, recipient, amount, \"\", \"\", false);\r\n\r\n      return true;\r\n  }\r\n\r\n  /**\r\n   * Called by the associated Pool to emit `Mint` events.\r\n   * @param amount The amount that was minted\r\n   */\r\n  function poolMint(uint256 amount) external onlyPool {\r\n    _mintEvents(address(_pool), address(_pool), amount, '', '');\r\n  }\r\n\r\n  /**\r\n    * Emits {Minted} and {IERC20-Transfer} events.\r\n    */\r\n  function _mintEvents(\r\n      address operator,\r\n      address account,\r\n      uint256 amount,\r\n      bytes memory userData,\r\n      bytes memory operatorData\r\n  )\r\n  internal\r\n  {\r\n      emit Minted(operator, account, amount, userData, operatorData);\r\n      emit Transfer(address(0), account, amount);\r\n  }\r\n\r\n  /**\r\n    * @dev Send tokens\r\n    * @param operator address operator requesting the transfer\r\n    * @param from address token holder address\r\n    * @param to address recipient address\r\n    * @param amount uint256 amount of tokens to transfer\r\n    * @param userData bytes extra information provided by the token holder (if any)\r\n    * @param operatorData bytes extra information provided by the operator (if any)\r\n    */\r\n  function _send(\r\n      address operator,\r\n      address from,\r\n      address to,\r\n      uint256 amount,\r\n      bytes memory userData,\r\n      bytes memory operatorData\r\n  )\r\n      private\r\n  {\r\n      require(from != address(0), \"PoolToken/from-zero\");\r\n      require(to != address(0), \"PoolToken/to-zero\");\r\n\r\n      _callTokensToSend(operator, from, to, amount, userData, operatorData);\r\n\r\n      _move(operator, from, to, amount, userData, operatorData);\r\n\r\n      _callTokensReceived(operator, from, to, amount, userData, operatorData, false);\r\n  }\r\n\r\n  /**\r\n    * @dev Redeems tokens for the underlying asset.\r\n    * @param operator address operator requesting the operation\r\n    * @param from address token holder address\r\n    * @param amount uint256 amount of tokens to redeem\r\n    * @param data bytes extra information provided by the token holder\r\n    * @param operatorData bytes extra information provided by the operator (if any)\r\n    */\r\n  function _redeem(\r\n      address operator,\r\n      address from,\r\n      uint256 amount,\r\n      bytes memory data,\r\n      bytes memory operatorData\r\n  )\r\n      private\r\n  {\r\n      require(from != address(0), \"PoolToken/from-zero\");\r\n\r\n      _callTokensToSend(operator, from, address(0), amount, data, operatorData);\r\n\r\n      _pool.withdrawCommittedDepositFrom(from, amount);\r\n\r\n      emit Redeemed(operator, from, amount, data, operatorData);\r\n      emit Transfer(from, address(0), amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Moves tokens from one user to another.  Emits Sent and Transfer events.\r\n   */\r\n  function _move(\r\n      address operator,\r\n      address from,\r\n      address to,\r\n      uint256 amount,\r\n      bytes memory userData,\r\n      bytes memory operatorData\r\n  )\r\n      private\r\n  {\r\n      _pool.moveCommitted(from, to, amount);\r\n\r\n      emit Sent(operator, from, to, amount, userData, operatorData);\r\n      emit Transfer(from, to, amount);\r\n  }\r\n\r\n  /**\r\n   * Approves of a token spend by a spender for a holder.\r\n   * @param holder The address from which the tokens are spent\r\n   * @param spender The address that is spending the tokens\r\n   * @param value The amount of tokens to spend\r\n   */\r\n  function _approve(address holder, address spender, uint256 value) private {\r\n      require(spender != address(0), \"PoolToken/from-zero\");\r\n\r\n      _allowances[holder][spender] = value;\r\n      emit Approval(holder, spender, value);\r\n  }\r\n\r\n  /**\r\n    * @dev Call from.tokensToSend() if the interface is registered\r\n    * @param operator address operator requesting the transfer\r\n    * @param from address token holder address\r\n    * @param to address recipient address\r\n    * @param amount uint256 amount of tokens to transfer\r\n    * @param userData bytes extra information provided by the token holder (if any)\r\n    * @param operatorData bytes extra information provided by the operator (if any)\r\n    */\r\n  function _callTokensToSend(\r\n      address operator,\r\n      address from,\r\n      address to,\r\n      uint256 amount,\r\n      bytes memory userData,\r\n      bytes memory operatorData\r\n  )\r\n      internal notLocked\r\n  {\r\n      address implementer = ERC1820_REGISTRY.getInterfaceImplementer(from, TOKENS_SENDER_INTERFACE_HASH);\r\n      if (implementer != address(0)) {\r\n          IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\r\n      }\r\n  }\r\n\r\n  /**\r\n    * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\r\n    * tokensReceived() was not registered for the recipient\r\n    * @param operator address operator requesting the transfer\r\n    * @param from address token holder address\r\n    * @param to address recipient address\r\n    * @param amount uint256 amount of tokens to transfer\r\n    * @param userData bytes extra information provided by the token holder (if any)\r\n    * @param operatorData bytes extra information provided by the operator (if any)\r\n    * @param requireReceptionAck whether to require that, if the recipient is a contract, it has registered a IERC777Recipient\r\n    */\r\n  function _callTokensReceived(\r\n      address operator,\r\n      address from,\r\n      address to,\r\n      uint256 amount,\r\n      bytes memory userData,\r\n      bytes memory operatorData,\r\n      bool requireReceptionAck\r\n  )\r\n      private\r\n  {\r\n      address implementer = ERC1820_REGISTRY.getInterfaceImplementer(to, TOKENS_RECIPIENT_INTERFACE_HASH);\r\n      if (implementer != address(0)) {\r\n          IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\r\n      } else if (requireReceptionAck) {\r\n          require(!to.isContract(), \"PoolToken/no-recip-inter\");\r\n      }\r\n  }\r\n\r\n  /**\r\n   * @notice Requires the sender to be the pool contract\r\n   */\r\n  modifier onlyPool() {\r\n    require(msg.sender == address(_pool), \"PoolToken/only-pool\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Requires the contract to be unlocked\r\n   */\r\n  modifier notLocked() {\r\n    require(!_pool.isLocked(), \"PoolToken/is-locked\");\r\n    _;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title The Pool contract\r\n * @author Brendan Asselstine\r\n * @notice This contract allows users to pool deposits into Compound and win the accrued interest in periodic draws.\r\n * Funds are immediately deposited and withdrawn from the Compound cToken contract.\r\n * Draws go through three stages: open, committed and rewarded in that order.\r\n * Only one draw is ever in the open stage.  Users deposits are always added to the open draw.  Funds in the open Draw are that user's open balance.\r\n * When a Draw is committed, the funds in it are moved to a user's committed total and the total committed balance of all users is updated.\r\n * When a Draw is rewarded, the gross winnings are the accrued interest since the last reward (if any).  A winner is selected with their chances being\r\n * proportional to their committed balance vs the total committed balance of all users.\r\n *\r\n *\r\n * With the above in mind, there is always an open draw and possibly a committed draw.  The progression is:\r\n *\r\n * Step 1: Draw 1 Open\r\n * Step 2: Draw 2 Open | Draw 1 Committed\r\n * Step 3: Draw 3 Open | Draw 2 Committed | Draw 1 Rewarded\r\n * Step 4: Draw 4 Open | Draw 3 Committed | Draw 2 Rewarded\r\n * Step 5: Draw 5 Open | Draw 4 Committed | Draw 3 Rewarded\r\n * Step X: ...\r\n */\r\ncontract BasePool is Initializable, ReentrancyGuard {\r\n  using DrawManager for DrawManager.State;\r\n  using SafeMath for uint256;\r\n  using Roles for Roles.Role;\r\n  using Blocklock for Blocklock.State;\r\n\r\n  bytes32 internal constant ROLLED_OVER_ENTROPY_MAGIC_NUMBER = bytes32(uint256(1));\r\n\r\n  IERC1820Registry constant internal ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\r\n  // We inline the result of the following hashes because Solidity doesn't resolve them at compile time.\r\n  // See https://github.com/ethereum/solidity/issues/4024.\r\n\r\n  // keccak256(\"PoolTogetherRewardListener\")\r\n  bytes32 constant internal REWARD_LISTENER_INTERFACE_HASH =\r\n      0x68f03b0b1a978ee238a70b362091d993343460bc1a2830ab3f708936d9f564a4;\r\n\r\n  /**\r\n   * Emitted when a user deposits into the Pool.\r\n   * @param sender The purchaser of the tickets\r\n   * @param amount The size of the deposit\r\n   */\r\n  event Deposited(address indexed sender, uint256 amount);\r\n\r\n  /**\r\n   * Emitted when a user deposits into the Pool and the deposit is immediately committed\r\n   * @param sender The purchaser of the tickets\r\n   * @param amount The size of the deposit\r\n   */\r\n  event DepositedAndCommitted(address indexed sender, uint256 amount);\r\n\r\n  /**\r\n   * Emitted when Sponsors have deposited into the Pool\r\n   * @param sender The purchaser of the tickets\r\n   * @param amount The size of the deposit\r\n   */\r\n  event SponsorshipDeposited(address indexed sender, uint256 amount);\r\n\r\n  /**\r\n   * Emitted when an admin has been added to the Pool.\r\n   * @param admin The admin that was added\r\n   */\r\n  event AdminAdded(address indexed admin);\r\n\r\n  /**\r\n   * Emitted when an admin has been removed from the Pool.\r\n   * @param admin The admin that was removed\r\n   */\r\n  event AdminRemoved(address indexed admin);\r\n\r\n  /**\r\n   * Emitted when a user withdraws from the pool.\r\n   * @param sender The user that is withdrawing from the pool\r\n   * @param amount The amount that the user withdrew\r\n   */\r\n  event Withdrawn(address indexed sender, uint256 amount);\r\n\r\n  /**\r\n   * Emitted when a user withdraws their sponsorship and fees from the pool.\r\n   * @param sender The user that is withdrawing\r\n   * @param amount The amount they are withdrawing\r\n   */\r\n  event SponsorshipAndFeesWithdrawn(address indexed sender, uint256 amount);\r\n\r\n  /**\r\n   * Emitted when a user withdraws from their open deposit.\r\n   * @param sender The user that is withdrawing\r\n   * @param amount The amount they are withdrawing\r\n   */\r\n  event OpenDepositWithdrawn(address indexed sender, uint256 amount);\r\n\r\n  /**\r\n   * Emitted when a user withdraws from their committed deposit.\r\n   * @param sender The user that is withdrawing\r\n   * @param amount The amount they are withdrawing\r\n   */\r\n  event CommittedDepositWithdrawn(address indexed sender, uint256 amount);\r\n\r\n  /**\r\n   * Emitted when an address collects a fee\r\n   * @param sender The address collecting the fee\r\n   * @param amount The fee amount\r\n   * @param drawId The draw from which the fee was awarded\r\n   */\r\n  event FeeCollected(address indexed sender, uint256 amount, uint256 drawId);\r\n\r\n  /**\r\n   * Emitted when a new draw is opened for deposit.\r\n   * @param drawId The draw id\r\n   * @param feeBeneficiary The fee beneficiary for this draw\r\n   * @param secretHash The committed secret hash\r\n   * @param feeFraction The fee fraction of the winnings to be given to the beneficiary\r\n   */\r\n  event Opened(\r\n    uint256 indexed drawId,\r\n    address indexed feeBeneficiary,\r\n    bytes32 secretHash,\r\n    uint256 feeFraction\r\n  );\r\n\r\n  /**\r\n   * Emitted when a draw is committed.\r\n   * @param drawId The draw id\r\n   */\r\n  event Committed(\r\n    uint256 indexed drawId\r\n  );\r\n\r\n  /**\r\n   * Emitted when a draw is rewarded.\r\n   * @param drawId The draw id\r\n   * @param winner The address of the winner\r\n   * @param entropy The entropy used to select the winner\r\n   * @param winnings The net winnings given to the winner\r\n   * @param fee The fee being given to the draw beneficiary\r\n   */\r\n  event Rewarded(\r\n    uint256 indexed drawId,\r\n    address indexed winner,\r\n    bytes32 entropy,\r\n    uint256 winnings,\r\n    uint256 fee\r\n  );\r\n\r\n  /**\r\n   * Emitted when a RewardListener call fails\r\n   * @param drawId The draw id\r\n   * @param winner The address that one the draw\r\n   * @param impl The implementation address of the RewardListener\r\n   */\r\n  event RewardListenerFailed(\r\n    uint256 indexed drawId,\r\n    address indexed winner,\r\n    address indexed impl\r\n  );\r\n\r\n  /**\r\n   * Emitted when the fee fraction is changed.  Takes effect on the next draw.\r\n   * @param feeFraction The next fee fraction encoded as a fixed point 18 decimal\r\n   */\r\n  event NextFeeFractionChanged(uint256 feeFraction);\r\n\r\n  /**\r\n   * Emitted when the next fee beneficiary changes.  Takes effect on the next draw.\r\n   * @param feeBeneficiary The next fee beneficiary\r\n   */\r\n  event NextFeeBeneficiaryChanged(address indexed feeBeneficiary);\r\n\r\n  /**\r\n   * Emitted when an admin pauses the contract\r\n   */\r\n  event DepositsPaused(address indexed sender);\r\n\r\n  /**\r\n   * Emitted when an admin unpauses the contract\r\n   */\r\n  event DepositsUnpaused(address indexed sender);\r\n\r\n  /**\r\n   * Emitted when the draw is rolled over in the event that the secret is forgotten.\r\n   */\r\n  event RolledOver(uint256 indexed drawId);\r\n\r\n  struct Draw {\r\n    uint256 feeFraction; //fixed point 18\r\n    address feeBeneficiary;\r\n    uint256 openedBlock;\r\n    bytes32 secretHash;\r\n    bytes32 entropy;\r\n    address winner;\r\n    uint256 netWinnings;\r\n    uint256 fee;\r\n  }\r\n\r\n  /**\r\n   * The Compound cToken that this Pool is bound to.\r\n   */\r\n  ICErc20 public cToken;\r\n\r\n  /**\r\n   * The fee beneficiary to use for subsequent Draws.\r\n   */\r\n  address public nextFeeBeneficiary;\r\n\r\n  /**\r\n   * The fee fraction to use for subsequent Draws.\r\n   */\r\n  uint256 public nextFeeFraction;\r\n\r\n  /**\r\n   * The total of all balances\r\n   */\r\n  uint256 public accountedBalance;\r\n\r\n  /**\r\n   * The total deposits and winnings for each user.\r\n   */\r\n  mapping (address => uint256) internal balances;\r\n\r\n  /**\r\n   * A mapping of draw ids to Draw structures\r\n   */\r\n  mapping(uint256 => Draw) internal draws;\r\n\r\n  /**\r\n   * A structure that is used to manage the user's odds of winning.\r\n   */\r\n  DrawManager.State internal drawState;\r\n\r\n  /**\r\n   * A structure containing the administrators\r\n   */\r\n  Roles.Role internal admins;\r\n\r\n  /**\r\n   * Whether the contract is paused\r\n   */\r\n  bool public paused;\r\n\r\n  Blocklock.State internal blocklock;\r\n\r\n  PoolToken public poolToken;\r\n\r\n  /**\r\n   * @notice Initializes a new Pool contract.\r\n   * @param _owner The owner of the Pool.  They are able to change settings and are set as the owner of new lotteries.\r\n   * @param _cToken The Compound Finance MoneyMarket contract to supply and withdraw tokens.\r\n   * @param _feeFraction The fraction of the gross winnings that should be transferred to the owner as the fee.  Is a fixed point 18 number.\r\n   * @param _feeBeneficiary The address that will receive the fee fraction\r\n   */\r\n  function init (\r\n    address _owner,\r\n    address _cToken,\r\n    uint256 _feeFraction,\r\n    address _feeBeneficiary,\r\n    uint256 _lockDuration,\r\n    uint256 _cooldownDuration\r\n  ) public initializer {\r\n    require(_owner != address(0), \"Pool/owner-zero\");\r\n    require(_cToken != address(0), \"Pool/ctoken-zero\");\r\n    cToken = ICErc20(_cToken);\r\n    _addAdmin(_owner);\r\n    _setNextFeeFraction(_feeFraction);\r\n    _setNextFeeBeneficiary(_feeBeneficiary);\r\n    initBlocklock(_lockDuration, _cooldownDuration);\r\n  }\r\n\r\n  function setPoolToken(PoolToken _poolToken) external onlyAdmin {\r\n    require(address(poolToken) == address(0), \"Pool/token-was-set\");\r\n    require(address(_poolToken.pool()) == address(this), \"Pool/token-mismatch\");\r\n    poolToken = _poolToken;\r\n  }\r\n\r\n  function initBlocklock(uint256 _lockDuration, uint256 _cooldownDuration) internal {\r\n    blocklock.setLockDuration(_lockDuration);\r\n    blocklock.setCooldownDuration(_cooldownDuration);\r\n  }\r\n\r\n  /**\r\n   * @notice Opens a new Draw.\r\n   * @param _secretHash The secret hash to commit to the Draw.\r\n   */\r\n  function open(bytes32 _secretHash) internal {\r\n    drawState.openNextDraw();\r\n    draws[drawState.openDrawIndex] = Draw(\r\n      nextFeeFraction,\r\n      nextFeeBeneficiary,\r\n      block.number,\r\n      _secretHash,\r\n      bytes32(0),\r\n      address(0),\r\n      uint256(0),\r\n      uint256(0)\r\n    );\r\n    emit Opened(\r\n      drawState.openDrawIndex,\r\n      nextFeeBeneficiary,\r\n      _secretHash,\r\n      nextFeeFraction\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Emits the Committed event for the current open draw.\r\n   */\r\n  function emitCommitted() internal {\r\n    uint256 drawId = currentOpenDrawId();\r\n    emit Committed(drawId);\r\n    if (address(poolToken) != address(0)) {\r\n      poolToken.poolMint(openSupply());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Commits the current open draw, if any, and opens the next draw using the passed hash.  Really this function is only called twice:\r\n   * the first after Pool contract creation and the second immediately after.\r\n   * Can only be called by an admin.\r\n   * May fire the Committed event, and always fires the Open event.\r\n   * @param nextSecretHash The secret hash to use to open a new Draw\r\n   */\r\n  function openNextDraw(bytes32 nextSecretHash) public onlyAdmin {\r\n    if (currentCommittedDrawId() > 0) {\r\n      require(currentCommittedDrawHasBeenRewarded(), \"Pool/not-reward\");\r\n    }\r\n    if (currentOpenDrawId() != 0) {\r\n      emitCommitted();\r\n    }\r\n    open(nextSecretHash);\r\n  }\r\n\r\n  /**\r\n   * @notice Ignores the current draw, and opens the next draw.\r\n   * @dev This function will be removed once the winner selection has been decentralized.\r\n   * @param nextSecretHash The hash to commit for the next draw\r\n   */\r\n  function rolloverAndOpenNextDraw(bytes32 nextSecretHash) public onlyAdmin {\r\n    rollover();\r\n    openNextDraw(nextSecretHash);\r\n  }\r\n\r\n  /**\r\n   * @notice Rewards the current committed draw using the passed secret, commits the current open draw, and opens the next draw using the passed secret hash.\r\n   * Can only be called by an admin.\r\n   * Fires the Rewarded event, the Committed event, and the Open event.\r\n   * @param nextSecretHash The secret hash to use to open a new Draw\r\n   * @param lastSecret The secret to reveal to reward the current committed Draw.\r\n   * @param _salt The salt that was used to conceal the secret\r\n   */\r\n  function rewardAndOpenNextDraw(bytes32 nextSecretHash, bytes32 lastSecret, bytes32 _salt) public onlyAdmin {\r\n    reward(lastSecret, _salt);\r\n    openNextDraw(nextSecretHash);\r\n  }\r\n\r\n  /**\r\n   * @notice Rewards the winner for the current committed Draw using the passed secret.\r\n   * The gross winnings are calculated by subtracting the accounted balance from the current underlying cToken balance.\r\n   * A winner is calculated using the revealed secret.\r\n   * If there is a winner (i.e. any eligible users) then winner's balance is updated with their net winnings.\r\n   * The draw beneficiary's balance is updated with the fee.\r\n   * The accounted balance is updated to include the fee and, if there was a winner, the net winnings.\r\n   * Fires the Rewarded event.\r\n   * @param _secret The secret to reveal for the current committed Draw\r\n   * @param _salt The salt that was used to conceal the secret\r\n   */\r\n  function reward(bytes32 _secret, bytes32 _salt) public onlyAdmin onlyLocked requireCommittedNoReward nonReentrant {\r\n    blocklock.unlock(block.number);\r\n    // require that there is a committed draw\r\n    // require that the committed draw has not been rewarded\r\n    uint256 drawId = currentCommittedDrawId();\r\n\r\n    Draw storage draw = draws[drawId];\r\n\r\n    require(draw.secretHash == keccak256(abi.encodePacked(_secret, _salt)), \"Pool/bad-secret\");\r\n\r\n    // derive entropy from the revealed secret\r\n    bytes32 entropy = keccak256(abi.encodePacked(_secret));\r\n\r\n    // Select the winner using the hash as entropy\r\n    address winningAddress = calculateWinner(entropy);\r\n\r\n    // Calculate the gross winnings\r\n    uint256 underlyingBalance = balance();\r\n\r\n    uint256 grossWinnings;\r\n\r\n    // It's possible when the APR is zero that the underlying balance will be slightly lower than the accountedBalance\r\n    // due to rounding errors in the Compound contract.\r\n    if (underlyingBalance > accountedBalance) {\r\n      grossWinnings = capWinnings(underlyingBalance.sub(accountedBalance));\r\n    }\r\n\r\n    // Calculate the beneficiary fee\r\n    uint256 fee = calculateFee(draw.feeFraction, grossWinnings);\r\n\r\n    // Update balance of the beneficiary\r\n    balances[draw.feeBeneficiary] = balances[draw.feeBeneficiary].add(fee);\r\n\r\n    // Calculate the net winnings\r\n    uint256 netWinnings = grossWinnings.sub(fee);\r\n\r\n    draw.winner = winningAddress;\r\n    draw.netWinnings = netWinnings;\r\n    draw.fee = fee;\r\n    draw.entropy = entropy;\r\n\r\n    // If there is a winner who is to receive non-zero winnings\r\n    if (winningAddress != address(0) && netWinnings != 0) {\r\n      // Updated the accounted total\r\n      accountedBalance = underlyingBalance;\r\n\r\n      // Update balance of the winner\r\n      balances[winningAddress] = balances[winningAddress].add(netWinnings);\r\n\r\n      // Enter their winnings into the open draw\r\n      drawState.deposit(winningAddress, netWinnings);\r\n\r\n      callRewarded(winningAddress, netWinnings, drawId);\r\n    } else {\r\n      // Only account for the fee\r\n      accountedBalance = accountedBalance.add(fee);\r\n    }\r\n\r\n    emit Rewarded(\r\n      drawId,\r\n      winningAddress,\r\n      entropy,\r\n      netWinnings,\r\n      fee\r\n    );\r\n    emit FeeCollected(draw.feeBeneficiary, fee, drawId);\r\n  }\r\n\r\n  /**\r\n   * @notice Calls the reward listener for the winner, if a listener exists.\r\n   * @dev Checks for a listener using the ERC1820 registry.  The listener is given a gas stipend of 200,000 to run the function.\r\n   * The number 200,000 was selected because it's safely above the gas requirements for PoolTogether [Pod](https://github.com/pooltogether/pods) contract.\r\n   *\r\n   * @param winner The winner.  If they have a listener registered in the ERC1820 registry it will be called.\r\n   * @param netWinnings The amount that was won.\r\n   * @param drawId The draw id that was won.\r\n   */\r\n  function callRewarded(address winner, uint256 netWinnings, uint256 drawId) internal {\r\n    address impl = ERC1820_REGISTRY.getInterfaceImplementer(winner, REWARD_LISTENER_INTERFACE_HASH);\r\n    if (impl != address(0)) {\r\n      (bool success,) = impl.call.gas(200000)(abi.encodeWithSignature(\"rewarded(address,uint256,uint256)\", winner, netWinnings, drawId));\r\n      if (!success) {\r\n        emit RewardListenerFailed(drawId, winner, impl);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice A function that skips the reward for the committed draw id.\r\n   * @dev This function will be removed once the entropy is decentralized.\r\n   */\r\n  function rollover() public onlyAdmin requireCommittedNoReward {\r\n    uint256 drawId = currentCommittedDrawId();\r\n\r\n    Draw storage draw = draws[drawId];\r\n    draw.entropy = ROLLED_OVER_ENTROPY_MAGIC_NUMBER;\r\n\r\n    emit RolledOver(\r\n      drawId\r\n    );\r\n\r\n    emit Rewarded(\r\n      drawId,\r\n      address(0),\r\n      ROLLED_OVER_ENTROPY_MAGIC_NUMBER,\r\n      0,\r\n      0\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Ensures that the winnings don't overflow.  Note that we can make this integer max, because the fee\r\n   * is always less than zero (meaning the FixidityLib.multiply will always make the number smaller)\r\n   */\r\n  function capWinnings(uint256 _grossWinnings) internal pure returns (uint256) {\r\n    uint256 max = uint256(FixidityLib.maxNewFixed());\r\n    if (_grossWinnings > max) {\r\n      return max;\r\n    }\r\n    return _grossWinnings;\r\n  }\r\n\r\n  /**\r\n   * @notice Calculate the beneficiary fee using the passed fee fraction and gross winnings.\r\n   * @param _feeFraction The fee fraction, between 0 and 1, represented as a 18 point fixed number.\r\n   * @param _grossWinnings The gross winnings to take a fraction of.\r\n   */\r\n  function calculateFee(uint256 _feeFraction, uint256 _grossWinnings) internal pure returns (uint256) {\r\n    int256 grossWinningsFixed = FixidityLib.newFixed(int256(_grossWinnings));\r\n    // _feeFraction *must* be less than 1 ether, so it will never overflow\r\n    int256 feeFixed = FixidityLib.multiply(grossWinningsFixed, FixidityLib.newFixed(int256(_feeFraction), uint8(18)));\r\n    return uint256(FixidityLib.fromFixed(feeFixed));\r\n  }\r\n\r\n  /**\r\n   * @notice Allows a user to deposit a sponsorship amount.  The deposit is transferred into the cToken.\r\n   * Sponsorships allow a user to contribute to the pool without becoming eligible to win.  They can withdraw their sponsorship at any time.\r\n   * The deposit will immediately be added to Compound and the interest will contribute to the next draw.\r\n   * @param _amount The amount of the token underlying the cToken to deposit.\r\n   */\r\n  function depositSponsorship(uint256 _amount) public unlessDepositsPaused nonReentrant {\r\n    // Transfer the tokens into this contract\r\n    require(token().transferFrom(msg.sender, address(this), _amount), \"Pool/t-fail\");\r\n\r\n    // Deposit the sponsorship amount\r\n    _depositSponsorshipFrom(msg.sender, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Deposits the token balance for this contract as a sponsorship.\r\n   * If people erroneously transfer tokens to this contract, this function will allow us to recoup those tokens as sponsorship.\r\n   */\r\n  function transferBalanceToSponsorship() public unlessDepositsPaused {\r\n    // Deposit the sponsorship amount\r\n    _depositSponsorshipFrom(address(this), token().balanceOf(address(this)));\r\n  }\r\n\r\n  /**\r\n   * @notice Deposits into the pool under the current open Draw.  The deposit is transferred into the cToken.\r\n   * Once the open draw is committed, the deposit will be added to the user's total committed balance and increase their chances of winning\r\n   * proportional to the total committed balance of all users.\r\n   * @param _amount The amount of the token underlying the cToken to deposit.\r\n   */\r\n  function depositPool(uint256 _amount) public requireOpenDraw unlessDepositsPaused nonReentrant notLocked {\r\n    // Transfer the tokens into this contract\r\n    require(token().transferFrom(msg.sender, address(this), _amount), \"Pool/t-fail\");\r\n\r\n    // Deposit the funds\r\n    _depositPoolFrom(msg.sender, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Deposits sponsorship for a user\r\n   * @param _spender The user who is sponsoring\r\n   * @param _amount The amount they are sponsoring\r\n   */\r\n  function _depositSponsorshipFrom(address _spender, uint256 _amount) internal {\r\n    // Deposit the funds\r\n    _depositFrom(_spender, _amount);\r\n\r\n    emit SponsorshipDeposited(_spender, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Deposits into the pool for a user.  The deposit will be open until the next draw is committed.\r\n   * @param _spender The user who is depositing\r\n   * @param _amount The amount the user is depositing\r\n   */\r\n  function _depositPoolFrom(address _spender, uint256 _amount) internal {\r\n    // Update the user's eligibility\r\n    drawState.deposit(_spender, _amount);\r\n\r\n    _depositFrom(_spender, _amount);\r\n\r\n    emit Deposited(_spender, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Deposits into the pool for a user.  The deposit is made part of the currently committed draw\r\n   * @param _spender The user who is depositing\r\n   * @param _amount The amount to deposit\r\n   */\r\n  function _depositPoolFromCommitted(address _spender, uint256 _amount) internal notLocked {\r\n    // Update the user's eligibility\r\n    drawState.depositCommitted(_spender, _amount);\r\n\r\n    _depositFrom(_spender, _amount);\r\n\r\n    emit DepositedAndCommitted(_spender, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Deposits into the pool for a user.  Updates their balance and transfers their tokens into this contract.\r\n   * @param _spender The user who is depositing\r\n   * @param _amount The amount they are depositing\r\n   */\r\n  function _depositFrom(address _spender, uint256 _amount) internal {\r\n    // Update the user's balance\r\n    balances[_spender] = balances[_spender].add(_amount);\r\n\r\n    // Update the total of this contract\r\n    accountedBalance = accountedBalance.add(_amount);\r\n\r\n    // Deposit into Compound\r\n    require(token().approve(address(cToken), _amount), \"Pool/approve\");\r\n    require(cToken.mint(_amount) == 0, \"Pool/supply\");\r\n  }\r\n\r\n  /**\r\n   * Withdraws the given amount from the user's deposits.  It first withdraws from their sponsorship,\r\n   * then their open deposits, then their committed deposits.\r\n   *\r\n   * @param amount The amount to withdraw.\r\n   */\r\n  function withdraw(uint256 amount) public nonReentrant notLocked {\r\n    uint256 remainingAmount = amount;\r\n    // first sponsorship\r\n    uint256 sponsorshipAndFeesBalance = sponsorshipAndFeeBalanceOf(msg.sender);\r\n    if (sponsorshipAndFeesBalance < remainingAmount) {\r\n      withdrawSponsorshipAndFee(sponsorshipAndFeesBalance);\r\n      remainingAmount = remainingAmount.sub(sponsorshipAndFeesBalance);\r\n    } else {\r\n      withdrawSponsorshipAndFee(remainingAmount);\r\n      return;\r\n    }\r\n\r\n    // now pending\r\n    uint256 pendingBalance = drawState.openBalanceOf(msg.sender);\r\n    if (pendingBalance < remainingAmount) {\r\n      _withdrawOpenDeposit(msg.sender, pendingBalance);\r\n      remainingAmount = remainingAmount.sub(pendingBalance);\r\n    } else {\r\n      _withdrawOpenDeposit(msg.sender, remainingAmount);\r\n      return;\r\n    }\r\n\r\n    // now committed.  remainingAmount should not be greater than committed balance.\r\n    _withdrawCommittedDeposit(msg.sender, remainingAmount);\r\n  }\r\n\r\n  /**\r\n   * @notice Withdraw the sender's entire balance back to them.\r\n   */\r\n  function withdraw() public nonReentrant notLocked {\r\n    uint256 committedBalance = drawState.committedBalanceOf(msg.sender);\r\n\r\n    uint256 balance = balances[msg.sender];\r\n    // Update their chances of winning\r\n    drawState.withdraw(msg.sender);\r\n    _withdraw(msg.sender, balance);\r\n\r\n    if (address(poolToken) != address(0)) {\r\n      poolToken.poolRedeem(msg.sender, committedBalance);\r\n    }\r\n\r\n    emit Withdrawn(msg.sender, balance);\r\n  }\r\n\r\n  /**\r\n   * Withdraws only from the sender's sponsorship and fee balances\r\n   * @param _amount The amount to withdraw\r\n   */\r\n  function withdrawSponsorshipAndFee(uint256 _amount) public {\r\n    uint256 sponsorshipAndFees = sponsorshipAndFeeBalanceOf(msg.sender);\r\n    require(_amount <= sponsorshipAndFees, \"Pool/exceeds-sfee\");\r\n    _withdraw(msg.sender, _amount);\r\n\r\n    emit SponsorshipAndFeesWithdrawn(msg.sender, _amount);\r\n  }\r\n\r\n  /**\r\n   * Returns the total balance of the user's sponsorship and fees\r\n   * @param _sender The user whose balance should be returned\r\n   */\r\n  function sponsorshipAndFeeBalanceOf(address _sender) public view returns (uint256) {\r\n    return balances[_sender].sub(drawState.balanceOf(_sender));\r\n  }\r\n\r\n  /**\r\n   * Withdraws from the user's open deposits\r\n   * @param _amount The amount to withdraw\r\n   */\r\n  function withdrawOpenDeposit(uint256 _amount) public nonReentrant notLocked {\r\n    _withdrawOpenDeposit(msg.sender, _amount);\r\n  }\r\n\r\n  function _withdrawOpenDeposit(address sender, uint256 _amount) internal {\r\n    drawState.withdrawOpen(sender, _amount);\r\n    _withdraw(sender, _amount);\r\n\r\n    emit OpenDepositWithdrawn(sender, _amount);\r\n  }\r\n\r\n  /**\r\n   * Withdraws from the user's committed deposits\r\n   * @param _amount The amount to withdraw\r\n   */\r\n  function withdrawCommittedDeposit(uint256 _amount) public nonReentrant notLocked returns (bool)  {\r\n    _withdrawCommittedDeposit(msg.sender, _amount);\r\n    return true;\r\n  }\r\n\r\n  function _withdrawCommittedDeposit(address sender, uint256 _amount) internal {\r\n    _withdrawCommittedDepositAndEmit(sender, _amount);\r\n    if (address(poolToken) != address(0)) {\r\n      poolToken.poolRedeem(sender, _amount);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Allows the associated PoolToken to withdraw for a user; useful when redeeming through the token.\r\n   * @param _from The user to withdraw from\r\n   * @param _amount The amount to withdraw\r\n   */\r\n  function withdrawCommittedDepositFrom(\r\n    address _from,\r\n    uint256 _amount\r\n  ) external onlyToken notLocked returns (bool)  {\r\n    return _withdrawCommittedDepositAndEmit(_from, _amount);\r\n  }\r\n\r\n  /**\r\n   * A function that withdraws committed deposits for a user and emits the corresponding events.\r\n   * @param _from User to withdraw for\r\n   * @param _amount The amount to withdraw\r\n   */\r\n  function _withdrawCommittedDepositAndEmit(address _from, uint256 _amount) internal returns (bool) {\r\n    drawState.withdrawCommitted(_from, _amount);\r\n    _withdraw(_from, _amount);\r\n\r\n    emit CommittedDepositWithdrawn(_from, _amount);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Allows the associated PoolToken to move committed tokens from one user to another.\r\n   * @param _from The account to move tokens from\r\n   * @param _to The account that is receiving the tokens\r\n   * @param _amount The amount of tokens to transfer\r\n   */\r\n  function moveCommitted(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount\r\n  ) external onlyToken onlyCommittedBalanceGteq(_from, _amount) notLocked returns (bool) {\r\n    balances[_from] = balances[_from].sub(_amount, \"move could not sub amount\");\r\n    balances[_to] = balances[_to].add(_amount);\r\n    drawState.withdrawCommitted(_from, _amount);\r\n    drawState.depositCommitted(_to, _amount);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers tokens from the cToken contract to the sender.  Updates the accounted balance.\r\n   */\r\n  function _withdraw(address _sender, uint256 _amount) internal {\r\n    uint256 balance = balances[_sender];\r\n\r\n    require(_amount <= balance, \"Pool/no-funds\");\r\n\r\n    // Update the user's balance\r\n    balances[_sender] = balance.sub(_amount);\r\n\r\n    // Update the total of this contract\r\n    accountedBalance = accountedBalance.sub(_amount);\r\n\r\n    // Withdraw from Compound and transfer\r\n    require(cToken.redeemUnderlying(_amount) == 0, \"Pool/redeem\");\r\n    require(token().transfer(_sender, _amount), \"Pool/transfer\");\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the id of the current open Draw.\r\n   * @return The current open Draw id\r\n   */\r\n  function currentOpenDrawId() public view returns (uint256) {\r\n    return drawState.openDrawIndex;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the id of the current committed Draw.\r\n   * @return The current committed Draw id\r\n   */\r\n  function currentCommittedDrawId() public view returns (uint256) {\r\n    if (drawState.openDrawIndex > 1) {\r\n      return drawState.openDrawIndex - 1;\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Returns whether the current committed draw has been rewarded\r\n   * @return True if the current committed draw has been rewarded, false otherwise\r\n   */\r\n  function currentCommittedDrawHasBeenRewarded() internal view returns (bool) {\r\n    Draw storage draw = draws[currentCommittedDrawId()];\r\n    return draw.entropy != bytes32(0);\r\n  }\r\n\r\n  /**\r\n   * @notice Gets information for a given draw.\r\n   * @param _drawId The id of the Draw to retrieve info for.\r\n   * @return Fields including:\r\n   *  feeFraction: the fee fraction\r\n   *  feeBeneficiary: the beneficiary of the fee\r\n   *  openedBlock: The block at which the draw was opened\r\n   *  secretHash: The hash of the secret committed to this draw.\r\n   *  entropy: the entropy used to select the winner\r\n   *  winner: the address of the winner\r\n   *  netWinnings: the total winnings less the fee\r\n   *  fee: the fee taken by the beneficiary\r\n   */\r\n  function getDraw(uint256 _drawId) public view returns (\r\n    uint256 feeFraction,\r\n    address feeBeneficiary,\r\n    uint256 openedBlock,\r\n    bytes32 secretHash,\r\n    bytes32 entropy,\r\n    address winner,\r\n    uint256 netWinnings,\r\n    uint256 fee\r\n  ) {\r\n    Draw storage draw = draws[_drawId];\r\n    feeFraction = draw.feeFraction;\r\n    feeBeneficiary = draw.feeBeneficiary;\r\n    openedBlock = draw.openedBlock;\r\n    secretHash = draw.secretHash;\r\n    entropy = draw.entropy;\r\n    winner = draw.winner;\r\n    netWinnings = draw.netWinnings;\r\n    fee = draw.fee;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the total of the address's balance in committed Draws.  That is, the total that contributes to their chances of winning.\r\n   * @param _addr The address of the user\r\n   * @return The total committed balance for the user\r\n   */\r\n  function committedBalanceOf(address _addr) external view returns (uint256) {\r\n    return drawState.committedBalanceOf(_addr);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the total of the address's balance in the open Draw.  That is, the total that will *eventually* contribute to their chances of winning.\r\n   * @param _addr The address of the user\r\n   * @return The total open balance for the user\r\n   */\r\n  function openBalanceOf(address _addr) external view returns (uint256) {\r\n    return drawState.openBalanceOf(_addr);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns a user's total balance.  This includes their sponsorships, fees, open deposits, and committed deposits.\r\n   * @param _addr The address of the user to check.\r\n   * @return The user's current balance.\r\n   */\r\n  function totalBalanceOf(address _addr) external view returns (uint256) {\r\n    return balances[_addr];\r\n  }\r\n\r\n  /**\r\n   * @notice Returns a user's committed balance.  This is the balance of their Pool tokens.\r\n   * @param _addr The address of the user to check.\r\n   * @return The user's current balance.\r\n   */\r\n  function balanceOf(address _addr) external view returns (uint256) {\r\n    return drawState.committedBalanceOf(_addr);\r\n  }\r\n\r\n  /**\r\n   * @notice Calculates a winner using the passed entropy for the current committed balances.\r\n   * @param _entropy The entropy to use to select the winner\r\n   * @return The winning address\r\n   */\r\n  function calculateWinner(bytes32 _entropy) public view returns (address) {\r\n    return drawState.drawWithEntropy(_entropy);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the total committed balance.  Used to compute an address's chances of winning.\r\n   * @return The total committed balance.\r\n   */\r\n  function committedSupply() public view returns (uint256) {\r\n    return drawState.committedSupply();\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the total open balance.  This balance is the number of tickets purchased for the open draw.\r\n   * @return The total open balance\r\n   */\r\n  function openSupply() public view returns (uint256) {\r\n    return drawState.openSupply();\r\n  }\r\n\r\n  /**\r\n   * @notice Calculates the total estimated interest earned for the given number of blocks\r\n   * @param _blocks The number of block that interest accrued for\r\n   * @return The total estimated interest as a 18 point fixed decimal.\r\n   */\r\n  function estimatedInterestRate(uint256 _blocks) public view returns (uint256) {\r\n    return supplyRatePerBlock().mul(_blocks);\r\n  }\r\n\r\n  /**\r\n   * @notice Convenience function to return the supplyRatePerBlock value from the money market contract.\r\n   * @return The cToken supply rate per block\r\n   */\r\n  function supplyRatePerBlock() public view returns (uint256) {\r\n    return cToken.supplyRatePerBlock();\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the beneficiary fee fraction for subsequent Draws.\r\n   * Fires the NextFeeFractionChanged event.\r\n   * Can only be called by an admin.\r\n   * @param _feeFraction The fee fraction to use.\r\n   * Must be between 0 and 1 and formatted as a fixed point number with 18 decimals (as in Ether).\r\n   */\r\n  function setNextFeeFraction(uint256 _feeFraction) public onlyAdmin {\r\n    _setNextFeeFraction(_feeFraction);\r\n  }\r\n\r\n  function _setNextFeeFraction(uint256 _feeFraction) internal {\r\n    require(_feeFraction <= 1 ether, \"Pool/less-1\");\r\n    nextFeeFraction = _feeFraction;\r\n\r\n    emit NextFeeFractionChanged(_feeFraction);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the fee beneficiary for subsequent Draws.\r\n   * Can only be called by admins.\r\n   * @param _feeBeneficiary The beneficiary for the fee fraction.  Cannot be the 0 address.\r\n   */\r\n  function setNextFeeBeneficiary(address _feeBeneficiary) public onlyAdmin {\r\n    _setNextFeeBeneficiary(_feeBeneficiary);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the fee beneficiary for subsequent Draws.\r\n   * @param _feeBeneficiary The beneficiary for the fee fraction.  Cannot be the 0 address.\r\n   */\r\n  function _setNextFeeBeneficiary(address _feeBeneficiary) internal {\r\n    require(_feeBeneficiary != address(0), \"Pool/not-zero\");\r\n    nextFeeBeneficiary = _feeBeneficiary;\r\n\r\n    emit NextFeeBeneficiaryChanged(_feeBeneficiary);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds an administrator.\r\n   * Can only be called by administrators.\r\n   * Fires the AdminAdded event.\r\n   * @param _admin The address of the admin to add\r\n   */\r\n  function addAdmin(address _admin) public onlyAdmin {\r\n    _addAdmin(_admin);\r\n  }\r\n\r\n  /**\r\n   * @notice Checks whether a given address is an administrator.\r\n   * @param _admin The address to check\r\n   * @return True if the address is an admin, false otherwise.\r\n   */\r\n  function isAdmin(address _admin) public view returns (bool) {\r\n    return admins.has(_admin);\r\n  }\r\n\r\n  /**\r\n   * @notice Checks whether a given address is an administrator.\r\n   * @param _admin The address to check\r\n   * @return True if the address is an admin, false otherwise.\r\n   */\r\n  function _addAdmin(address _admin) internal {\r\n    admins.add(_admin);\r\n\r\n    emit AdminAdded(_admin);\r\n  }\r\n\r\n  /**\r\n   * @notice Removes an administrator\r\n   * Can only be called by an admin.\r\n   * Admins cannot remove themselves.  This ensures there is always one admin.\r\n   * @param _admin The address of the admin to remove\r\n   */\r\n  function removeAdmin(address _admin) public onlyAdmin {\r\n    require(admins.has(_admin), \"Pool/no-admin\");\r\n    require(_admin != msg.sender, \"Pool/remove-self\");\r\n    admins.remove(_admin);\r\n\r\n    emit AdminRemoved(_admin);\r\n  }\r\n\r\n  /**\r\n   * Requires that there is a committed draw that has not been rewarded.\r\n   */\r\n  modifier requireCommittedNoReward() {\r\n    require(currentCommittedDrawId() > 0, \"Pool/committed\");\r\n    require(!currentCommittedDrawHasBeenRewarded(), \"Pool/already\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the token underlying the cToken.\r\n   * @return An ERC20 token address\r\n   */\r\n  function token() public view returns (IERC20) {\r\n    return IERC20(cToken.underlying());\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the underlying balance of this contract in the cToken.\r\n   * @return The cToken underlying balance for this contract.\r\n   */\r\n  function balance() public returns (uint256) {\r\n    return cToken.balanceOfUnderlying(address(this));\r\n  }\r\n\r\n  /**\r\n   * @notice Locks the movement of tokens (essentially the committed deposits and winnings)\r\n   * @dev The lock only lasts for a duration of blocks.  The lock cannot be relocked until the cooldown duration completes.\r\n   */\r\n  function lockTokens() public onlyAdmin {\r\n    blocklock.lock(block.number);\r\n  }\r\n\r\n  /**\r\n   * @notice Unlocks the movement of tokens (essentially the committed deposits)\r\n   */\r\n  function unlockTokens() public onlyAdmin {\r\n    blocklock.unlock(block.number);\r\n  }\r\n\r\n  /**\r\n   * Pauses all deposits into the contract.  This was added so that we can slowly deprecate Pools.  Users can continue\r\n   * to collect rewards and withdraw, but eventually the Pool will grow smaller.\r\n   *\r\n   * emits DepositsPaused\r\n   */\r\n  function pauseDeposits() public unlessDepositsPaused onlyAdmin {\r\n    paused = true;\r\n\r\n    emit DepositsPaused(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Unpauses all deposits into the contract\r\n   *\r\n   * emits DepositsUnpaused\r\n   */\r\n  function unpauseDeposits() public whenDepositsPaused onlyAdmin {\r\n    paused = false;\r\n\r\n    emit DepositsUnpaused(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Check if the contract is locked.\r\n   * @return True if the contract is locked, false otherwise\r\n   */\r\n  function isLocked() public view returns (bool) {\r\n    return blocklock.isLocked(block.number);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the block number at which the lock expires\r\n   * @return The block number at which the lock expires\r\n   */\r\n  function lockEndAt() public view returns (uint256) {\r\n    return blocklock.lockEndAt();\r\n  }\r\n\r\n  /**\r\n   * @notice Check cooldown end block\r\n   * @return The block number at which the cooldown ends and the contract can be re-locked\r\n   */\r\n  function cooldownEndAt() public view returns (uint256) {\r\n    return blocklock.cooldownEndAt();\r\n  }\r\n\r\n  /**\r\n   * @notice Returns whether the contract can be locked\r\n   * @return True if the contract can be locked, false otherwise\r\n   */\r\n  function canLock() public view returns (bool) {\r\n    return blocklock.canLock(block.number);\r\n  }\r\n\r\n  /**\r\n   * @notice Duration of the lock\r\n   * @return Returns the duration of the lock in blocks.\r\n   */\r\n  function lockDuration() public view returns (uint256) {\r\n    return blocklock.lockDuration;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the cooldown duration.  The cooldown period starts after the Pool has been unlocked.\r\n   * The Pool cannot be locked during the cooldown period.\r\n   * @return The cooldown duration in blocks\r\n   */\r\n  function cooldownDuration() public view returns (uint256) {\r\n    return blocklock.cooldownDuration;\r\n  }\r\n\r\n  /**\r\n   * @notice requires the pool not to be locked\r\n   */\r\n  modifier notLocked() {\r\n    require(!blocklock.isLocked(block.number), \"Pool/locked\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice requires the pool to be locked\r\n   */\r\n  modifier onlyLocked() {\r\n    require(blocklock.isLocked(block.number), \"Pool/unlocked\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice requires the caller to be an admin\r\n   */\r\n  modifier onlyAdmin() {\r\n    require(admins.has(msg.sender), \"Pool/admin\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Requires an open draw to exist\r\n   */\r\n  modifier requireOpenDraw() {\r\n    require(currentOpenDrawId() != 0, \"Pool/no-open\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Requires deposits to be paused\r\n   */\r\n  modifier whenDepositsPaused() {\r\n    require(paused, \"Pool/d-not-paused\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Requires deposits not to be paused\r\n   */\r\n  modifier unlessDepositsPaused() {\r\n    require(!paused, \"Pool/d-paused\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Requires the caller to be the pool token\r\n   */\r\n  modifier onlyToken() {\r\n    require(msg.sender == address(poolToken), \"Pool/only-token\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice requires the passed user's committed balance to be greater than or equal to the passed amount\r\n   * @param _from The user whose committed balance should be checked\r\n   * @param _amount The minimum amount they must have\r\n   */\r\n  modifier onlyCommittedBalanceGteq(address _from, uint256 _amount) {\r\n    uint256 committedBalance = drawState.committedBalanceOf(_from);\r\n    require(_amount <= committedBalance, \"not enough funds\");\r\n    _;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract ScdMcdMigration {\r\n    SaiTubLike                  public tub;\r\n    VatLike                     public vat;\r\n    ManagerLike                 public cdpManager;\r\n    JoinLike                    public saiJoin;\r\n    JoinLike                    public wethJoin;\r\n    JoinLike                    public daiJoin;\r\n\r\n    constructor(\r\n        address tub_,           // SCD tub contract address\r\n        address cdpManager_,    // MCD manager contract address\r\n        address saiJoin_,       // MCD SAI collateral adapter contract address\r\n        address wethJoin_,      // MCD ETH collateral adapter contract address\r\n        address daiJoin_        // MCD DAI adapter contract address\r\n    ) public {\r\n        tub = SaiTubLike(tub_);\r\n        cdpManager = ManagerLike(cdpManager_);\r\n        vat = VatLike(cdpManager.vat());\r\n        saiJoin = JoinLike(saiJoin_);\r\n        wethJoin = JoinLike(wethJoin_);\r\n        daiJoin = JoinLike(daiJoin_);\r\n\r\n        require(wethJoin.gem() == tub.gem(), \"non-matching-weth\");\r\n        require(saiJoin.gem() == tub.sai(), \"non-matching-sai\");\r\n\r\n        tub.gov().approve(address(tub), uint(-1));\r\n        tub.skr().approve(address(tub), uint(-1));\r\n        tub.sai().approve(address(tub), uint(-1));\r\n        tub.sai().approve(address(saiJoin), uint(-1));\r\n        wethJoin.gem().approve(address(wethJoin), uint(-1));\r\n        daiJoin.dai().approve(address(daiJoin), uint(-1));\r\n        vat.hope(address(daiJoin));\r\n    }\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"add-overflow\");\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"sub-underflow\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"mul-overflow\");\r\n    }\r\n\r\n    function toInt(uint x) internal pure returns (int y) {\r\n        y = int(x);\r\n        require(y >= 0, \"int-overflow\");\r\n    }\r\n\r\n    // Function to swap SAI to DAI\r\n    // This function is to be used by users that want to get new DAI in exchange of old one (aka SAI)\r\n    // wad amount has to be <= the value pending to reach the debt ceiling (the minimum between general and ilk one)\r\n    function swapSaiToDai(\r\n        uint wad\r\n    ) external {\r\n        // Get wad amount of SAI from user's wallet:\r\n        saiJoin.gem().transferFrom(msg.sender, address(this), wad);\r\n        // Join the SAI wad amount to the `vat`:\r\n        saiJoin.join(address(this), wad);\r\n        // Lock the SAI wad amount to the CDP and generate the same wad amount of DAI\r\n        vat.frob(saiJoin.ilk(), address(this), address(this), address(this), toInt(wad), toInt(wad));\r\n        // Send DAI wad amount as a ERC20 token to the user's wallet\r\n        daiJoin.exit(msg.sender, wad);\r\n    }\r\n\r\n    // Function to swap DAI to SAI\r\n    // This function is to be used by users that want to get SAI in exchange of DAI\r\n    // wad amount has to be <= the amount of SAI locked (and DAI generated) in the migration contract SAI CDP\r\n    function swapDaiToSai(\r\n        uint wad\r\n    ) external {\r\n        // Get wad amount of DAI from user's wallet:\r\n        daiJoin.dai().transferFrom(msg.sender, address(this), wad);\r\n        // Join the DAI wad amount to the vat:\r\n        daiJoin.join(address(this), wad);\r\n        // Payback the DAI wad amount and unlocks the same value of SAI collateral\r\n        vat.frob(saiJoin.ilk(), address(this), address(this), address(this), -toInt(wad), -toInt(wad));\r\n        // Send SAI wad amount as a ERC20 token to the user's wallet\r\n        saiJoin.exit(msg.sender, wad);\r\n    }\r\n\r\n    // Function to migrate a SCD CDP to MCD one (needs to be used via a proxy so the code can be kept simpler). Check MigrationProxyActions.sol code for usage.\r\n    // In order to use migrate function, SCD CDP debtAmt needs to be <= SAI previously deposited in the SAI CDP * (100% - Collateralization Ratio)\r\n    function migrate(\r\n        bytes32 cup\r\n    ) external returns (uint cdp) {\r\n        // Get values\r\n        uint debtAmt = tub.tab(cup);    // CDP SAI debt\r\n        uint pethAmt = tub.ink(cup);    // CDP locked collateral\r\n        uint ethAmt = tub.bid(pethAmt); // CDP locked collateral equiv in ETH\r\n\r\n        // Take SAI out from MCD SAI CDP. For this operation is necessary to have a very low collateralization ratio\r\n        // This is not actually a problem as this ilk will only be accessed by this migration contract,\r\n        // which will make sure to have the amounts balanced out at the end of the execution.\r\n        vat.frob(\r\n            bytes32(saiJoin.ilk()),\r\n            address(this),\r\n            address(this),\r\n            address(this),\r\n            -toInt(debtAmt),\r\n            0\r\n        );\r\n        saiJoin.exit(address(this), debtAmt); // SAI is exited as a token\r\n\r\n        // Shut SAI CDP and gets WETH back\r\n        tub.shut(cup);      // CDP is closed using the SAI just exited and the MKR previously sent by the user (via the proxy call)\r\n        tub.exit(pethAmt);  // Converts PETH to WETH\r\n\r\n        // Open future user's CDP in MCD\r\n        cdp = cdpManager.open(wethJoin.ilk(), address(this));\r\n\r\n        // Join WETH to Adapter\r\n        wethJoin.join(cdpManager.urns(cdp), ethAmt);\r\n\r\n        // Lock WETH in future user's CDP and generate debt to compensate the SAI used to paid the SCD CDP\r\n        (, uint rate,,,) = vat.ilks(wethJoin.ilk());\r\n        cdpManager.frob(\r\n            cdp,\r\n            toInt(ethAmt),\r\n            toInt(mul(debtAmt, 10 ** 27) / rate + 1) // To avoid rounding issues we add an extra wei of debt\r\n        );\r\n        // Move DAI generated to migration contract (to recover the used funds)\r\n        cdpManager.move(cdp, address(this), mul(debtAmt, 10 ** 27));\r\n        // Re-balance MCD SAI migration contract's CDP\r\n        vat.frob(\r\n            bytes32(saiJoin.ilk()),\r\n            address(this),\r\n            address(this),\r\n            address(this),\r\n            0,\r\n            -toInt(debtAmt)\r\n        );\r\n\r\n        // Set ownership of CDP to the user\r\n        cdpManager.give(cdp, msg.sender);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\r\n *\r\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\r\n * contract implement this interface (contract holders can be their own\r\n * implementer) and registering it on the\r\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\r\n *\r\n * See {IERC1820Registry} and {ERC1820Implementer}.\r\n */\r\ninterface IERC777Recipient {\r\n    /**\r\n     * @dev Called by an {IERC777} token contract whenever tokens are being\r\n     * moved or created into a registered account (`to`). The type of operation\r\n     * is conveyed by `from` being the zero address or not.\r\n     *\r\n     * This call occurs _after_ the token contract's state is updated, so\r\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\r\n     *\r\n     * This function may revert to prevent the operation from being executed.\r\n     */\r\n    function tokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n\r\n/**\r\n * @title MCDAwarePool\r\n * @author Brendan Asselstine brendan@pooltogether.us\r\n * @notice This contract is a Pool that is aware of the new Multi-Collateral Dai.  It uses the ERC777Recipient interface to\r\n * detect if it's being transferred tickets from the old single collateral Dai (Sai) Pool.  If it is, it migrates the Sai to Dai\r\n * and immediately deposits the new Dai as committed tickets for that user.  We are knowingly bypassing the committed period for\r\n * users to encourage them to migrate to the MCD Pool.\r\n */\r\ncontract MCDAwarePool is BasePool, IERC777Recipient {\r\n  IERC1820Registry constant internal ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\r\n  // keccak256(\"ERC777TokensRecipient\")\r\n  bytes32 constant internal TOKENS_RECIPIENT_INTERFACE_HASH =\r\n      0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\r\n\r\n  uint256 internal constant DEFAULT_LOCK_DURATION = 40;\r\n  uint256 internal constant DEFAULT_COOLDOWN_DURATION = 80;\r\n\r\n  /**\r\n   * @notice The address of the ScdMcdMigration contract (see https://github.com/makerdao/developerguides/blob/master/mcd/upgrading-to-multi-collateral-dai/upgrading-to-multi-collateral-dai.md#direct-integration-with-smart-contracts)\r\n   */\r\n  ScdMcdMigration public scdMcdMigration;\r\n\r\n  /**\r\n   * @notice The address of the Sai Pool contract\r\n   */\r\n  MCDAwarePool public saiPool;\r\n\r\n  /**\r\n   * @notice Initializes the contract.\r\n   * @param _owner The initial administrator of the contract\r\n   * @param _cToken The Compound cToken to bind this Pool to\r\n   * @param _feeFraction The fraction of the winnings to give to the beneficiary\r\n   * @param _feeBeneficiary The beneficiary who receives the fee\r\n   */\r\n  function init (\r\n    address _owner,\r\n    address _cToken,\r\n    uint256 _feeFraction,\r\n    address _feeBeneficiary,\r\n    uint256 lockDuration,\r\n    uint256 cooldownDuration\r\n  ) public initializer {\r\n    super.init(\r\n      _owner,\r\n      _cToken,\r\n      _feeFraction,\r\n      _feeBeneficiary,\r\n      lockDuration,\r\n      cooldownDuration\r\n    );\r\n    initRegistry();\r\n    initBlocklock(lockDuration, cooldownDuration);\r\n  }\r\n\r\n  /**\r\n   * @notice Used to initialize the BasePool contract after an upgrade.  Registers the MCDAwarePool with the ERC1820 registry so that it can receive tokens, and inits the block lock.\r\n   */\r\n  function initMCDAwarePool(uint256 lockDuration, uint256 cooldownDuration) public {\r\n    initRegistry();\r\n    if (blocklock.lockDuration == 0) {\r\n      initBlocklock(lockDuration, cooldownDuration);\r\n    }\r\n  }\r\n\r\n  function initRegistry() internal {\r\n    ERC1820_REGISTRY.setInterfaceImplementer(address(this), TOKENS_RECIPIENT_INTERFACE_HASH, address(this));\r\n  }\r\n\r\n  function initMigration(ScdMcdMigration _scdMcdMigration, MCDAwarePool _saiPool) public onlyAdmin {\r\n    _initMigration(_scdMcdMigration, _saiPool);\r\n  }\r\n\r\n  function _initMigration(ScdMcdMigration _scdMcdMigration, MCDAwarePool _saiPool) internal {\r\n    require(address(scdMcdMigration) == address(0), \"Pool/init\");\r\n    require(address(_scdMcdMigration) != address(0), \"Pool/mig-def\");\r\n    scdMcdMigration = _scdMcdMigration;\r\n    saiPool = _saiPool; // may be null\r\n  }\r\n\r\n  /**\r\n   * @notice Called by an ERC777 token when tokens are sent, transferred, or minted.  If the sender is the original Sai Pool\r\n   * and this pool is bound to the Dai token then it will accept the transfer, migrate the tokens, and deposit on behalf of\r\n   * the sender.  It will reject all other tokens.\r\n   *\r\n   * If there is a committed draw this function will mint the user tickets immediately, otherwise it will place them in the\r\n   * open prize.  This is to encourage migration.\r\n   *\r\n   * @param from The sender\r\n   * @param amount The amount they are transferring\r\n   */\r\n  function tokensReceived(\r\n    address, // operator\r\n    address from,\r\n    address, // to address can't be anything but us because we don't implement ERC1820ImplementerInterface\r\n    uint256 amount,\r\n    bytes calldata,\r\n    bytes calldata\r\n  ) external unlessDepositsPaused {\r\n    require(msg.sender == address(saiPoolToken()), \"Pool/sai-only\");\r\n    require(address(token()) == address(daiToken()), \"Pool/not-dai\");\r\n\r\n    // cash out of the Pool.  This call transfers sai to this contract\r\n    saiPoolToken().redeem(amount, '');\r\n\r\n    // approve of the transfer to the migration contract\r\n    saiToken().approve(address(scdMcdMigration), amount);\r\n\r\n    // migrate the sai to dai.  The contract now has dai\r\n    scdMcdMigration.swapSaiToDai(amount);\r\n\r\n    if (currentCommittedDrawId() > 0) {\r\n      // now deposit the dai as tickets\r\n      _depositPoolFromCommitted(from, amount);\r\n    } else {\r\n      _depositPoolFrom(from, amount);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the address of the PoolSai pool token contract\r\n   * @return The address of the Sai PoolToken contract\r\n   */\r\n  function saiPoolToken() internal view returns (PoolToken) {\r\n    if (address(saiPool) != address(0)) {\r\n      return saiPool.poolToken();\r\n    } else {\r\n      return PoolToken(0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the address of the Sai token\r\n   * @return The address of the sai token\r\n   */\r\n  function saiToken() public returns (GemLike) {\r\n    return scdMcdMigration.saiJoin().gem();\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the address of the Dai token\r\n   * @return The address of the Dai token.\r\n   */\r\n  function daiToken() public returns (GemLike) {\r\n    return scdMcdMigration.daiJoin().dai();\r\n  }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"drawId\",\"type\":\"uint256\"}],\"name\":\"Committed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CommittedDepositWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositedAndCommitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"DepositsPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"DepositsUnpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"drawId\",\"type\":\"uint256\"}],\"name\":\"FeeCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeBeneficiary\",\"type\":\"address\"}],\"name\":\"NextFeeBeneficiaryChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeFraction\",\"type\":\"uint256\"}],\"name\":\"NextFeeFractionChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OpenDepositWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"drawId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeBeneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"secretHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeFraction\",\"type\":\"uint256\"}],\"name\":\"Opened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"drawId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"}],\"name\":\"RewardListenerFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"drawId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"entropy\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winnings\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Rewarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"drawId\",\"type\":\"uint256\"}],\"name\":\"RolledOver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SponsorshipAndFeesWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SponsorshipDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"accountedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cToken\",\"outputs\":[{\"internalType\":\"contract ICErc20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_entropy\",\"type\":\"bytes32\"}],\"name\":\"calculateWinner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"committedBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"committedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooldownDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooldownEndAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentCommittedDrawId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentOpenDrawId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"daiToken\",\"outputs\":[{\"internalType\":\"contract GemLike\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositSponsorship\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blocks\",\"type\":\"uint256\"}],\"name\":\"estimatedInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_drawId\",\"type\":\"uint256\"}],\"name\":\"getDraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeFraction\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feeBeneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"openedBlock\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"secretHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"entropy\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"netWinnings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeFraction\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeBeneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldownDuration\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lockDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldownDuration\",\"type\":\"uint256\"}],\"name\":\"initMCDAwarePool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ScdMcdMigration\",\"name\":\"_scdMcdMigration\",\"type\":\"address\"},{\"internalType\":\"contract MCDAwarePool\",\"name\":\"_saiPool\",\"type\":\"address\"}],\"name\":\"initMigration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockEndAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lockTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"moveCommitted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextFeeBeneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextFeeFraction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"openBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nextSecretHash\",\"type\":\"bytes32\"}],\"name\":\"openNextDraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseDeposits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolToken\",\"outputs\":[{\"internalType\":\"contract PoolToken\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_secret\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_salt\",\"type\":\"bytes32\"}],\"name\":\"reward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nextSecretHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"lastSecret\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_salt\",\"type\":\"bytes32\"}],\"name\":\"rewardAndOpenNextDraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"rollover\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nextSecretHash\",\"type\":\"bytes32\"}],\"name\":\"rolloverAndOpenNextDraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saiPool\",\"outputs\":[{\"internalType\":\"contract MCDAwarePool\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"saiToken\",\"outputs\":[{\"internalType\":\"contract GemLike\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"scdMcdMigration\",\"outputs\":[{\"internalType\":\"contract ScdMcdMigration\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeBeneficiary\",\"type\":\"address\"}],\"name\":\"setNextFeeBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeFraction\",\"type\":\"uint256\"}],\"name\":\"setNextFeeFraction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract PoolToken\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"setPoolToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"sponsorshipAndFeeBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supplyRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokensReceived\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"totalBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferBalanceToSponsorship\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpauseDeposits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawCommittedDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawCommittedDepositFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawOpenDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawSponsorshipAndFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MCDAwarePool","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"DrawManager:7d159fc60b8d67580223d080dbd742c623cf51e6;FixidityLib:92ca02e97caf1c94ab3a51faaaa409b026067113;Blocklock:533da53d2cf270056b8427d1a5812ffe2cdca2db","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://aa9fb8bc7bbe50638a280391835a9541ae016bfb1e253fb2382a46a0640d241d"}]}