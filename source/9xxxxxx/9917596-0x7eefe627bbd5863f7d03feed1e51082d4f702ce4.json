{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n\t// Empty internal constructor, to prevent people from mistakenly deploying\r\n\t// an instance of this contract, which should be used via inheritance.\r\n\tconstructor () internal { }\r\n\r\n\tfunction _msgSender() internal view virtual returns (address payable) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\r\n\tfunction _msgData() internal view virtual returns (bytes memory) {\r\n\t\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n\t\treturn msg.data;\r\n\t}\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n\taddress private _owner;\r\n\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\t/**\r\n\t * @dev Initializes the contract setting the deployer as the initial owner.\r\n\t */\r\n\tconstructor () internal {\r\n\t\taddress msgSender = _msgSender();\r\n\t\t_owner = msgSender;\r\n\t\temit OwnershipTransferred(address(0), msgSender);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the address of the current owner.\r\n\t */\r\n\tfunction owner() public view returns (address) {\r\n\t\treturn _owner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Leaves the contract without owner. It will not be possible to call\r\n\t * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n\t *\r\n\t * NOTE: Renouncing ownership will leave the contract without an owner,\r\n\t * thereby removing any functionality that is only available to the owner.\r\n\t */\r\n\tfunction renounceOwnership() public virtual onlyOwner {\r\n\t\temit OwnershipTransferred(_owner, address(0));\r\n\t\t_owner = address(0);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\t * Can only be called by the current owner.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\n\t\t_transferOwnership(newOwner);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\t */\r\n\tfunction _transferOwnership(address newOwner) internal virtual {\r\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n\t\temit OwnershipTransferred(_owner, newOwner);\r\n\t\t_owner = newOwner;\r\n\t}\r\n}\r\n\r\n\r\nlibrary LibSet_bytes4 {\r\n\tstruct set\r\n\t{\r\n\t\tbytes4[] values;\r\n\t\tmapping(bytes4 => uint256) indexes;\r\n\t}\r\n\r\n\tfunction length(set storage _set)\r\n\tinternal view returns (uint256)\r\n\t{\r\n\t\treturn _set.values.length;\r\n\t}\r\n\r\n\tfunction at(set storage _set, uint256 _index)\r\n\tinternal view returns (bytes4 )\r\n\t{\r\n\t\treturn _set.values[_index - 1];\r\n\t}\r\n\r\n\tfunction indexOf(set storage _set, bytes4  _value)\r\n\tinternal view returns (uint256)\r\n\t{\r\n\t\treturn _set.indexes[_value];\r\n\t}\r\n\r\n\tfunction contains(set storage _set, bytes4  _value)\r\n\tinternal view returns (bool)\r\n\t{\r\n\t\treturn indexOf(_set, _value) != 0;\r\n\t}\r\n\r\n\tfunction content(set storage _set)\r\n\tinternal view returns (bytes4[] memory)\r\n\t{\r\n\t\treturn _set.values;\r\n\t}\r\n\r\n\tfunction add(set storage _set, bytes4  _value)\r\n\tinternal returns (bool)\r\n\t{\r\n\t\tif (contains(_set, _value))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t_set.values.push(_value);\r\n\t\t_set.indexes[_value] = _set.values.length;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction remove(set storage _set, bytes4  _value)\r\n\tinternal returns (bool)\r\n\t{\r\n\t\tif (!contains(_set, _value))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tuint256 i    = indexOf(_set, _value);\r\n\t\tuint256 last = length(_set);\r\n\r\n\t\tif (i != last)\r\n\t\t{\r\n\t\t\tbytes4  swapValue = _set.values[last - 1];\r\n\t\t\t_set.values[i - 1] = swapValue;\r\n\t\t\t_set.indexes[swapValue] = i;\r\n\t\t}\r\n\r\n\t\tdelete _set.indexes[_value];\r\n\t\t_set.values.pop();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction clear(set storage _set)\r\n\tinternal returns (bool)\r\n\t{\r\n\t\tfor (uint256 i = _set.values.length; i > 0; --i)\r\n\t\t{\r\n\t\t\tdelete _set.indexes[_set.values[i-1]];\r\n\t\t}\r\n\t\t_set.values = new bytes4[](0);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\nlibrary LibMap2_bytes4_address_bytes {\r\n\tusing LibSet_bytes4 for LibSet_bytes4.set;\r\n\r\n\tstruct map\r\n\t{\r\n\t\tLibSet_bytes4.set keyset;\r\n\t\tmapping(bytes4 => address) values1;\r\n\t\tmapping(bytes4 => bytes) values2;\r\n\t}\r\n\r\n\tfunction length(map storage _map)\r\n\tinternal view returns (uint256)\r\n\t{\r\n\t\treturn _map.keyset.length();\r\n\t}\r\n\r\n\tfunction value1(map storage _map, bytes4  _key)\r\n\tinternal view returns (address )\r\n\t{\r\n\t\treturn _map.values1[_key];\r\n\t}\r\n\r\n\tfunction value2(map storage _map, bytes4  _key)\r\n\tinternal view returns (bytes memory)\r\n\t{\r\n\t\treturn _map.values2[_key];\r\n\t}\r\n\r\n\tfunction keyAt(map storage _map, uint256 _index)\r\n\tinternal view returns (bytes4 )\r\n\t{\r\n\t\treturn _map.keyset.at(_index);\r\n\t}\r\n\r\n\tfunction at(map storage _map, uint256 _index)\r\n\tinternal view returns (bytes4 , address , bytes memory)\r\n\t{\r\n\t\tbytes4  key = keyAt(_map, _index);\r\n\t\treturn (key, value1(_map, key), value2(_map, key));\r\n\t}\r\n\r\n\tfunction indexOf(map storage _map, bytes4  _key)\r\n\tinternal view returns (uint256)\r\n\t{\r\n\t\treturn _map.keyset.indexOf(_key);\r\n\t}\r\n\r\n\tfunction contains(map storage _map, bytes4  _key)\r\n\tinternal view returns (bool)\r\n\t{\r\n\t\treturn _map.keyset.contains(_key);\r\n\t}\r\n\r\n\tfunction keys(map storage _map)\r\n\tinternal view returns (bytes4[] memory)\r\n\t{\r\n\t\treturn _map.keyset.content();\r\n\t}\r\n\r\n\tfunction set(\r\n\t\tmap storage _map,\r\n\t\tbytes4  _key,\r\n\t\taddress  _value1,\r\n\t\tbytes memory _value2)\r\n\tinternal returns (bool)\r\n\t{\r\n\t\t_map.keyset.add(_key);\r\n\t\t_map.values1[_key] = _value1;\r\n\t\t_map.values2[_key] = _value2;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction del(map storage _map, bytes4  _key)\r\n\tinternal returns (bool)\r\n\t{\r\n\t\t_map.keyset.remove(_key);\r\n\t\tdelete _map.values1[_key];\r\n\t\tdelete _map.values2[_key];\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction clear(map storage _map)\r\n\tinternal returns (bool)\r\n\t{\r\n\t\tfor (uint256 i = _map.keyset.length(); i > 0; --i)\r\n\t\t{\r\n\t\t\tbytes4  key = keyAt(_map, i);\r\n\t\t\tdelete _map.values1[key];\r\n\t\t\tdelete _map.values2[key];\r\n\t\t}\r\n\t\t_map.keyset.clear();\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\ninterface IERC1538 {\r\n\tevent CommitMessage(string message);\r\n\tevent FunctionUpdate(bytes4 indexed functionId, address indexed oldDelegate, address indexed newDelegate, string functionSignature);\r\n}\r\n\r\ncontract ERC1538Store is Ownable\r\n{\r\n\tusing LibMap2_bytes4_address_bytes for LibMap2_bytes4_address_bytes.map;\r\n\r\n\tLibMap2_bytes4_address_bytes.map internal m_funcs;\r\n}\r\n\r\ncontract ERC1538Core is IERC1538, ERC1538Store\r\n{\r\n\tbytes4 constant internal RECEIVE  = 0xd217fcc6; // bytes4(keccak256(\"receive\"));\r\n\tbytes4 constant internal FALLBACK = 0xb32cdf4d; // bytes4(keccak256(\"fallback\"));\r\n\r\n\tevent CommitMessage(string message);\r\n\tevent FunctionUpdate(bytes4 indexed functionId, address indexed oldDelegate, address indexed newDelegate, string functionSignature);\r\n\r\n\tfunction _setFunc(string memory funcSignature, address funcDelegate)\r\n\tinternal\r\n\t{\r\n\t\tbytes4 funcId = bytes4(keccak256(bytes(funcSignature)));\r\n\t\tif (funcId == RECEIVE ) { funcId = bytes4(0x00000000); }\r\n\t\tif (funcId == FALLBACK) { funcId = bytes4(0xFFFFFFFF); }\r\n\r\n\t\taddress oldDelegate = m_funcs.value1(funcId);\r\n\r\n\t\tif (funcDelegate == oldDelegate) // No change â†’ skip\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\telse if (funcDelegate == address(0)) // Delete\r\n\t\t{\r\n\t\t\tm_funcs.del(funcId);\r\n\t\t}\r\n\t\telse // Set / Update\r\n\t\t{\r\n\t\t\tm_funcs.set(funcId, funcDelegate, bytes(funcSignature));\r\n\t\t}\r\n\r\n\t\temit FunctionUpdate(funcId, oldDelegate, funcDelegate, funcSignature);\r\n\t}\r\n}\r\n\r\ncontract ERC1538Module is ERC1538Store\r\n{\r\n\tconstructor()\r\n\tpublic\r\n\t{\r\n\t\trenounceOwnership();\r\n\t}\r\n}\r\n\r\ninterface ERC1538Query\r\n{\r\n\tfunction totalFunctions            (                           ) external view returns(uint256);\r\n\tfunction functionByIndex           (uint256          _index    ) external view returns(string memory, bytes4, address);\r\n\tfunction functionById              (bytes4           _id       ) external view returns(string memory, bytes4, address);\r\n\tfunction functionExists            (string  calldata _signature) external view returns(bool);\r\n\tfunction functionSignatures        (                           ) external view returns(string memory);\r\n\tfunction delegateFunctionSignatures(address          _delegate ) external view returns(string memory);\r\n\tfunction delegateAddress           (string  calldata _signature) external view returns(address);\r\n\tfunction delegateAddresses         (                           ) external view returns(address[] memory);\r\n}\r\n\r\ncontract ERC1538QueryDelegate is ERC1538Query, ERC1538Module\r\n{\r\n\tfunction totalFunctions()\r\n\texternal override view returns(uint256)\r\n\t{\r\n\t\treturn m_funcs.length();\r\n\t}\r\n\r\n\tfunction functionByIndex(uint256 _index)\r\n\texternal override view returns(string memory signature, bytes4 id, address delegate)\r\n\t{\r\n\t\t(bytes4 funcId, address funcDelegate, bytes memory funcSignature) = m_funcs.at(_index + 1);\r\n\t\treturn (string(funcSignature), funcId, funcDelegate);\r\n\t}\r\n\r\n\tfunction functionById(bytes4 _funcId)\r\n\texternal override view returns(string memory signature, bytes4 id, address delegate)\r\n\t{\r\n\t\treturn (string(m_funcs.value2(_funcId)), _funcId, m_funcs.value1(_funcId));\r\n\t}\r\n\r\n\tfunction functionExists(string calldata _funcSignature)\r\n\texternal override view returns(bool)\r\n\t{\r\n\t\treturn m_funcs.contains(bytes4(keccak256(bytes(_funcSignature))));\r\n\t}\r\n\r\n\tfunction delegateAddress(string calldata _funcSignature)\r\n\texternal override view returns(address)\r\n\t{\r\n\t\treturn m_funcs.value1(bytes4(keccak256(bytes(_funcSignature))));\r\n\t}\r\n\r\n\tfunction functionSignatures()\r\n\texternal override view returns(string memory)\r\n\t{\r\n\t\tuint256 signaturesLength = 0;\r\n\t\tfor (uint256 i = 1; i <= m_funcs.length(); ++i)\r\n\t\t{\r\n\t\t\tsignaturesLength += m_funcs.value2(m_funcs.keyAt(i)).length + 1; // EDIT\r\n\t\t}\r\n\r\n\t\tbytes memory signatures = new bytes(signaturesLength);\r\n\t\tuint256 charPos = 0;\r\n\t\tfor (uint256 i = 1; i <= m_funcs.length(); ++i)\r\n\t\t{\r\n\t\t\tbytes memory signature = m_funcs.value2(m_funcs.keyAt(i));\r\n\t\t\tfor (uint256 c = 0; c < signature.length; ++c)\r\n\t\t\t{\r\n\t\t\t\tsignatures[charPos] = signature[c];\r\n\t\t\t\t++charPos;\r\n\t\t\t}\r\n\t\t\tsignatures[charPos] = 0x3B;\r\n\t\t\t++charPos;\r\n\t\t}\r\n\r\n\t\treturn string(signatures);\r\n\t}\r\n\r\n\tfunction delegateFunctionSignatures(address _delegate)\r\n\texternal override view returns(string memory)\r\n\t{\r\n\t\tbytes[] memory delegateSignatures = new bytes[](m_funcs.length());\r\n\t\tuint256 delegateSignaturesLength = 0;\r\n\r\n\t\tuint256 signaturesLength = 0;\r\n\t\tfor (uint256 i = 1; i <= m_funcs.length(); ++i)\r\n\t\t{\r\n\t\t\t(bytes4 funcId, address funcDelegate, bytes memory funcSignature) = m_funcs.at(i);\r\n\t\t\tif (_delegate == funcDelegate)\r\n\t\t\t{\r\n\t\t\t\tsignaturesLength += funcSignature.length + 1;\r\n\t\t\t\tdelegateSignatures[delegateSignaturesLength] = funcSignature;\r\n\t\t\t\t++delegateSignaturesLength;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tbytes memory signatures = new bytes(signaturesLength);\r\n\t\tuint256 charPos = 0;\r\n\t\tfor (uint256 i = 0; i < delegateSignaturesLength; ++i)\r\n\t\t{\r\n\t\t\tbytes memory signature = delegateSignatures[i];\r\n\t\t\tfor (uint256 c = 0; c < signature.length; ++c)\r\n\t\t\t{\r\n\t\t\t\tsignatures[charPos] = signature[c];\r\n\t\t\t\t++charPos;\r\n\t\t\t}\r\n\t\t\tsignatures[charPos] = 0x3B;\r\n\t\t\t++charPos;\r\n\t\t}\r\n\r\n\t\treturn string(signatures);\r\n\t}\r\n\r\n\tfunction delegateAddresses()\r\n\texternal override view returns(address[] memory)\r\n\t{\r\n\t\taddress[] memory delegatesBucket = new address[](m_funcs.length());\r\n\r\n\t\tuint256 numDelegates = 0;\r\n\t\tfor (uint256 i = 1; i <= m_funcs.length(); ++i)\r\n\t\t{\r\n\t\t\taddress delegate = m_funcs.value1(m_funcs.keyAt(i));\r\n\t\t\tbool seen = false;\r\n\t\t\tfor (uint256 j = 0; j < numDelegates; ++j)\r\n\t\t\t{\r\n\t\t\t\tif (delegate == delegatesBucket[j])\r\n\t\t\t\t{\r\n\t\t\t\t\tseen = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (seen == false)\r\n\t\t\t{\r\n\t\t\t\tdelegatesBucket[numDelegates] = delegate;\r\n\t\t\t\t++numDelegates;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\taddress[] memory delegates = new address[](numDelegates);\r\n\t\tfor (uint256 i = 0; i < numDelegates; ++i)\r\n\t\t{\r\n\t\t\tdelegates[i] = delegatesBucket[i];\r\n\t\t}\r\n\t\treturn delegates;\r\n\t}\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_funcSignature\",\"type\":\"string\"}],\"name\":\"delegateAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delegateAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_delegate\",\"type\":\"address\"}],\"name\":\"delegateFunctionSignatures\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_funcId\",\"type\":\"bytes4\"}],\"name\":\"functionById\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"internalType\":\"bytes4\",\"name\":\"id\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"functionByIndex\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"internalType\":\"bytes4\",\"name\":\"id\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_funcSignature\",\"type\":\"string\"}],\"name\":\"functionExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"functionSignatures\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFunctions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ERC1538QueryDelegate","CompilerVersion":"v0.6.4+commit.1dca32f3","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://98fc9b58a1b5d0fdfeee180cfd826726897a2d24bca930c21ab2f4445c996f40"}]}