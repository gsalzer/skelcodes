{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.21 <0.6.0;\r\n\r\ncontract MultiSigInterface{\r\n  function update_and_check_reach_majority(uint64 id, string memory name, bytes32 hash, address sender) public returns (bool);\r\n  function is_signer(address addr) public view returns(bool);\r\n}\r\n\r\ncontract MultiSigTools{\r\n  MultiSigInterface public multisig_contract;\r\n  constructor(address _contract) public{\r\n    require(_contract!= address(0x0));\r\n    multisig_contract = MultiSigInterface(_contract);\r\n  }\r\n\r\n  modifier only_signer{\r\n    require(multisig_contract.is_signer(msg.sender), \"only a signer can call in MultiSigTools\");\r\n    _;\r\n  }\r\n\r\n  modifier is_majority_sig(uint64 id, string memory name) {\r\n    bytes32 hash = keccak256(abi.encodePacked(msg.sig, msg.data));\r\n    if(multisig_contract.update_and_check_reach_majority(id, name, hash, msg.sender)){\r\n      _;\r\n    }\r\n  }\r\n\r\n  event TransferMultiSig(address _old, address _new);\r\n\r\n  function transfer_multisig(uint64 id, address _contract) public only_signer\r\n  is_majority_sig(id, \"transfer_multisig\"){\r\n    require(_contract != address(0x0));\r\n    address old = address(multisig_contract);\r\n    multisig_contract = MultiSigInterface(_contract);\r\n    emit TransferMultiSig(old, _contract);\r\n  }\r\n}\r\n\r\ncontract TrustListInterface{\r\n  function is_trusted(address addr) public returns(bool);\r\n}\r\ncontract TrustListTools{\r\n  TrustListInterface public list;\r\n  constructor(address _list) public {\r\n    require(_list != address(0x0));\r\n    list = TrustListInterface(_list);\r\n  }\r\n\r\n  modifier is_trusted(address addr){\r\n    require(list.is_trusted(addr), \"not a trusted issuer\");\r\n    _;\r\n  }\r\n\r\n}\r\n\r\ncontract TransferableToken{\r\n    function balanceOf(address _owner) public returns (uint256 balance) ;\r\n    function transfer(address _to, uint256 _amount) public returns (bool success) ;\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) ;\r\n}\r\n\r\n\r\ncontract TokenClaimer{\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _to, uint _amount);\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n  function _claimStdTokens(address _token, address payable to) internal {\r\n        if (_token == address(0x0)) {\r\n            to.transfer(address(this).balance);\r\n            return;\r\n        }\r\n        TransferableToken token = TransferableToken(_token);\r\n        uint balance = token.balanceOf(address(this));\r\n\r\n        (bool status,) = _token.call(abi.encodeWithSignature(\"transfer(address,uint256)\", to, balance));\r\n        require(status, \"call failed\");\r\n        emit ClaimedTokens(_token, to, balance);\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a, \"add\");\r\n    }\r\n    function safeSub(uint a, uint b) public pure returns (uint c) {\r\n        require(b <= a, \"sub\");\r\n        c = a - b;\r\n    }\r\n    function safeMul(uint a, uint b) public pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"mul\");\r\n    }\r\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\r\n        require(b > 0, \"div\");\r\n        c = a / b;\r\n    }\r\n}\r\ncontract ERC20DepositPool is TrustListTools{\r\n  using SafeMath for uint;\r\n\r\n  address public erc20_token;\r\n  mapping(address => uint) public all_deposits;\r\n  mapping(address => uint) public locked_deposits;\r\n\r\n  constructor(address _token, address _list) public TrustListTools(_list){\r\n    erc20_token = _token;\r\n  }\r\n\r\n  event DepositPoolTransfer(address from, address to, uint amount);\r\n  event OutsideTransfer(address from, address to, uint amount);\r\n  event InternalTransfer(address from, address to, uint amount);\r\n  event DepositERC20(address addr, uint amount);\r\n  event WithdrawERC20(address addr, uint amount);\r\n\r\n  event LockERC20(address from, address addr, uint amount);\r\n  event UnlockERC20(address from, address addr, uint amount);\r\n\r\n  function deposit(uint _amount) public returns (bool){\r\n    TransferableToken token = TransferableToken(erc20_token);\r\n    uint old_balance = token.balanceOf(address(this));\r\n    (bool ret, ) = erc20_token.call(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), _amount));\r\n    require(ret, \"ERC20DepositPool, transferFrom return false\");\r\n    uint new_balance = token.balanceOf(address(this));\r\n    require(new_balance == old_balance + _amount, \"ERC20DepositPool:deposit, invalid deposit\");\r\n\r\n    all_deposits[msg.sender] = all_deposits[msg.sender].safeAdd(_amount);\r\n    emit DepositERC20(msg.sender, _amount);\r\n    return true;\r\n  }\r\n\r\n  function transfer(address _to, uint _amount) public returns (bool){\r\n    require(_to != address(0x0), \"invalid address\");\r\n    require (all_deposits[msg.sender] >= locked_deposits[msg.sender], \"already locked too much\");\r\n    require (all_deposits[msg.sender].safeSub(locked_deposits[msg.sender]) >= _amount, \"not enough deposit, maybe locked already\");\r\n\r\n    all_deposits[msg.sender] = all_deposits[msg.sender].safeSub(_amount);\r\n    all_deposits[_to] = all_deposits[_to].safeAdd(_amount);\r\n\r\n    emit DepositPoolTransfer(msg.sender, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  function withdraw(uint _amount) public returns(bool){\r\n    require (all_deposits[msg.sender] >= locked_deposits[msg.sender], \"already locked too much\");\r\n    require (all_deposits[msg.sender].safeSub(locked_deposits[msg.sender]) >= _amount, \"not enough deposit, maybe locked already\");\r\n\r\n    all_deposits[msg.sender] = all_deposits[msg.sender].safeSub(_amount);\r\n\r\n    (bool ret, ) = erc20_token.call(abi.encodeWithSignature(\"transfer(address,uint256)\", msg.sender, _amount));\r\n    require(ret, \"ERC20DepositPool:withdraw, transfer return false\");\r\n    emit WithdrawERC20(msg.sender, _amount);\r\n    return true;\r\n  }\r\n\r\n  function lock(address addr, uint amount) public is_trusted(msg.sender) returns (bool){\r\n    require(addr != address(0x0), \"invalid address\");\r\n    require(all_deposits[addr] >= amount, \"not enough deposit\");\r\n    require(all_deposits[addr].safeSub(locked_deposits[addr]) >= amount, \"not enough deposit because of already locked\" );\r\n\r\n    locked_deposits[addr] = locked_deposits[addr].safeAdd(amount);\r\n\r\n    emit LockERC20(msg.sender, addr, amount);\r\n    return true;\r\n  }\r\n\r\n  function unlock(address addr, uint amount) public is_trusted(msg.sender) returns(bool){\r\n    require(locked_deposits[addr] >= amount, \"unlock too much\");\r\n    locked_deposits[addr] = locked_deposits[addr].safeSub(amount);\r\n    emit UnlockERC20(msg.sender, addr, amount);\r\n    return true;\r\n  }\r\n\r\n  function outside_transfer(address from, address to, uint _amount) public is_trusted(msg.sender) returns(bool){\r\n    require(to != address(0x0), \"invalid address\");\r\n    require (all_deposits[from] >= locked_deposits[from], \"already locked too much\");\r\n    require (all_deposits[from].safeSub(locked_deposits[from]) >= _amount, \"not enough deposit, maybe locked already\");\r\n\r\n    all_deposits[from] = all_deposits[from].safeSub(_amount);\r\n\r\n    (bool ret, ) = erc20_token.call(abi.encodeWithSignature(\"transfer(address,uint256)\", to, _amount));\r\n    require(ret, \"ERC20DepositPool:outside_transfer, transfer return false\");\r\n\r\n    emit OutsideTransfer(from, to, _amount);\r\n    return true;\r\n  }\r\n\r\n  function internal_transfer(address from, address to, uint _amount) public is_trusted(msg.sender) returns(bool){\r\n    require(to != address(0x0), \"invalid address\");\r\n    require (all_deposits[from] >= locked_deposits[from], \"already locked too much\");\r\n    require (all_deposits[from].safeSub(locked_deposits[from]) >= _amount, \"not enough deposit, maybe locked already\");\r\n\r\n    all_deposits[from] = all_deposits[from].safeSub(_amount);\r\n    all_deposits[to] = all_deposits[to].safeAdd(_amount);\r\n\r\n    emit InternalTransfer(from, to, _amount);\r\n    return true;\r\n  }\r\n\r\n  function lockedOf(address addr) public view returns(uint){\r\n    return locked_deposits[addr];\r\n  }\r\n  function balanceOf(address addr) public view returns (uint){\r\n    return all_deposits[addr];\r\n  }\r\n}\r\n\r\ncontract ERC20DepositPoolFactory{\r\n  event NewERC20DepositPool(address addr);\r\n\r\n  function createERC20DepositPool(address token_addr, address _list) public returns(address){\r\n    ERC20DepositPool dp = new ERC20DepositPool(token_addr, _list);\r\n    emit NewERC20DepositPool(address (dp));\r\n    return address(dp);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"token_addr\",\"type\":\"address\"},{\"name\":\"_list\",\"type\":\"address\"}],\"name\":\"createERC20DepositPool\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"NewERC20DepositPool\",\"type\":\"event\"}]","ContractName":"ERC20DepositPoolFactory","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"SafeMath:a37426cdca2be3d52c950d5ca1ffac842b89b06a","LicenseType":"MIT","SwarmSource":"bzzr://cfbb3938d418292d32a50a1c8e965b1d660c3f27e1ed7b781e23c7f134d7ce34"}]}