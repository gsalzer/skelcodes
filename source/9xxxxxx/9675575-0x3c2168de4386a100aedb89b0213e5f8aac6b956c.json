{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/interfaces/IBridgeValidators.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\ninterface IBridgeValidators {\r\n    function initialize(uint256 _requiredSignatures, address[] _initialValidators, address _owner) external returns(bool);\r\n    function isValidator(address _validator) external view returns(bool);\r\n    function requiredSignatures() external view returns(uint256);\r\n    function owner() external view returns(address);\r\n}\r\n\r\n// File: contracts/interfaces/IForeignBridge.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\ncontract IForeignBridge {\r\n\r\n  function initialize(\r\n        address _validatorContract,\r\n        address _erc20token,\r\n        uint256 _requiredBlockConfirmations,\r\n        uint256 _gasPrice,\r\n        uint256 _maxPerTx,\r\n        uint256 _homeDailyLimit,\r\n        uint256 _homeMaxPerTx,\r\n        address _owner\r\n    ) public returns(bool);\r\n}\r\n\r\n// File: contracts/upgradeability/EternalStorage.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n/**\r\n * @title EternalStorage\r\n * @dev This contract holds all the necessary state variables to carry out the storage of any contract.\r\n */\r\ncontract EternalStorage {\r\n\r\n    mapping(bytes32 => uint256) internal uintStorage;\r\n    mapping(bytes32 => string) internal stringStorage;\r\n    mapping(bytes32 => address) internal addressStorage;\r\n    mapping(bytes32 => bytes) internal bytesStorage;\r\n    mapping(bytes32 => bool) internal boolStorage;\r\n    mapping(bytes32 => int256) internal intStorage;\r\n\r\n\r\n    mapping(bytes32 => uint256[]) internal uintArrayStorage;\r\n    mapping(bytes32 => string[]) internal stringArrayStorage;\r\n    mapping(bytes32 => address[]) internal addressArrayStorage;\r\n    //mapping(bytes32 => bytes[]) internal bytesArrayStorage;\r\n    mapping(bytes32 => bool[]) internal boolArrayStorage;\r\n    mapping(bytes32 => int256[]) internal intArrayStorage;\r\n    mapping(bytes32 => bytes32[]) internal bytes32ArrayStorage;\r\n}\r\n\r\n// File: contracts/upgradeability/Proxy.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n\r\n  /**\r\n  * @dev Tells the address of the implementation where every call will be delegated.\r\n  * @return address of the implementation to which it will be delegated\r\n  */\r\n    function implementation() public view returns (address);\r\n\r\n    function setImplementation(address _newImplementation) external;\r\n\r\n  /**\r\n  * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n  * This function will return whatever the implementation call returns\r\n  */\r\n    function () payable public {\r\n        address _impl = implementation();\r\n        require(_impl != address(0));\r\n\r\n        address _innerImpl;\r\n        bytes4 sig;\r\n        address thisAddress = address(this);\r\n        if (_impl.call(0x5c60da1b)) { // bytes(keccak256(\"implementation()\"))\r\n            _innerImpl = Proxy(_impl).implementation();\r\n            this.setImplementation(_innerImpl);\r\n            sig = 0xd784d426; // bytes4(keccak256(\"setImplementation(address)\"))\r\n        }\r\n\r\n        assembly {\r\n            /*\r\n                0x40 is the \"free memory slot\", meaning a pointer to next slot of empty memory. mload(0x40)\r\n                loads the data in the free memory slot, so `ptr` is a pointer to the next slot of empty\r\n                memory. It's needed because we're going to write the return data of delegatecall to the\r\n                free memory slot.\r\n            */\r\n            let ptr := mload(0x40)\r\n            /*\r\n                `calldatacopy` is copy calldatasize bytes from calldata\r\n                First argument is the destination to which data is copied(ptr)\r\n                Second argument specifies the start position of the copied data.\r\n                    Since calldata is sort of its own unique location in memory,\r\n                    0 doesn't refer to 0 in memory or 0 in storage - it just refers to the zeroth byte of calldata.\r\n                    That's always going to be the zeroth byte of the function selector.\r\n                Third argument, calldatasize, specifies how much data will be copied.\r\n                    calldata is naturally calldatasize bytes long (same thing as msg.data.length)\r\n            */\r\n            calldatacopy(ptr, 0, calldatasize)\r\n            /*\r\n                delegatecall params explained:\r\n                gas: the amount of gas to provide for the call. `gas` is an Opcode that gives\r\n                    us the amount of gas still available to execution\r\n\r\n                _impl: address of the contract to delegate to\r\n\r\n                ptr: to pass copied data\r\n\r\n                calldatasize: loads the size of `bytes memory data`, same as msg.data.length\r\n\r\n                0, 0: These are for the `out` and `outsize` params. Because the output could be dynamic,\r\n                        these are set to 0, 0 so the output data will not be written to memory. The output\r\n                        data will be read using `returndatasize` and `returdatacopy` instead.\r\n\r\n                result: This will be 0 if the call fails and 1 if it succeeds\r\n            */\r\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\r\n            /*\r\n\r\n            */\r\n            /*\r\n                ptr current points to the value stored at 0x40,\r\n                because we assigned it like ptr := mload(0x40).\r\n                Because we use 0x40 as a free memory pointer,\r\n                we want to make sure that the next time we want to allocate memory,\r\n                we aren't overwriting anything important.\r\n                So, by adding ptr and returndatasize,\r\n                we get a memory location beyond the end of the data we will be copying to ptr.\r\n                We place this in at 0x40, and any reads from 0x40 will now read from free memory\r\n            */\r\n            mstore(0x40, add(ptr, returndatasize))\r\n            /*\r\n                `returndatacopy` is an Opcode that copies the last return data to a slot. `ptr` is the\r\n                    slot it will copy to, 0 means copy from the beginning of the return data, and size is\r\n                    the amount of data to copy.\r\n                `returndatasize` is an Opcode that gives us the size of the last return data. In this case, that is the size of the data returned from delegatecall\r\n            */\r\n            returndatacopy(ptr, 0, returndatasize)\r\n\r\n            let retdatasize := returndatasize\r\n\r\n            switch sig\r\n            case 0 {}\r\n            default {\r\n                let x := mload(0x40)\r\n                mstore(x, sig)\r\n                mstore(add(x, 0x04), _impl)\r\n                let success := call(gas, thisAddress, 0, x, 0x24, x, 0x0)\r\n            }\r\n\r\n            /*\r\n                if `result` is 0, revert.\r\n                if `result` is 1, return `size` amount of data from `ptr`. This is the data that was\r\n                copied to `ptr` from the delegatecall return data\r\n            */\r\n            switch result\r\n            case 0 { revert(ptr, retdatasize) }\r\n            default { return(ptr, retdatasize) }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/upgradeability/UpgradeabilityStorage.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n/**\r\n * @title UpgradeabilityStorage\r\n * @dev This contract holds all the necessary state variables to support the upgrade functionality\r\n */\r\ncontract UpgradeabilityStorage {\r\n    // Version name of the current implementation\r\n    uint256 internal _version;\r\n\r\n    // Address of the current implementation\r\n    address internal _implementation;\r\n\r\n    /**\r\n    * @dev Tells the version name of the current implementation\r\n    * @return string representing the name of the current version\r\n    */\r\n    function version() public view returns (uint256) {\r\n        return _version;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the current implementation\r\n    * @return address of the current implementation\r\n    */\r\n    function implementation() public view returns (address) {\r\n        return _implementation;\r\n    }\r\n\r\n    function setImplementation(address _newImplementation) external {\r\n        require(msg.sender == address(this));\r\n        _implementation = _newImplementation;\r\n    }\r\n}\r\n\r\n// File: contracts/upgradeability/UpgradeabilityProxy.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\r\n */\r\ncontract UpgradeabilityProxy is Proxy, UpgradeabilityStorage {\r\n    /**\r\n    * @dev This event will be emitted every time the implementation gets upgraded\r\n    * @param version representing the version name of the upgraded implementation\r\n    * @param implementation representing the address of the upgraded implementation\r\n    */\r\n    event Upgraded(uint256 version, address indexed implementation);\r\n\r\n    /**\r\n    * @dev Upgrades the implementation address\r\n    * @param version representing the version name of the new implementation to be set\r\n    * @param implementation representing the address of the new implementation to be set\r\n    */\r\n    function _upgradeTo(uint256 version, address implementation) internal {\r\n        require(_implementation != implementation);\r\n        require(version > _version);\r\n        _version = version;\r\n        _implementation = implementation;\r\n        emit Upgraded(version, implementation);\r\n    }\r\n}\r\n\r\n// File: contracts/upgradeability/UpgradeabilityOwnerStorage.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n/**\r\n * @title UpgradeabilityOwnerStorage\r\n * @dev This contract keeps track of the upgradeability owner\r\n */\r\ncontract UpgradeabilityOwnerStorage {\r\n    // Owner of the contract\r\n    address private _upgradeabilityOwner;\r\n\r\n    /**\r\n    * @dev Tells the address of the owner\r\n    * @return the address of the owner\r\n    */\r\n    function upgradeabilityOwner() public view returns (address) {\r\n        return _upgradeabilityOwner;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the address of the owner\r\n    */\r\n    function setUpgradeabilityOwner(address newUpgradeabilityOwner) internal {\r\n        _upgradeabilityOwner = newUpgradeabilityOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/upgradeability/OwnedUpgradeabilityProxy.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title OwnedUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\r\n */\r\ncontract OwnedUpgradeabilityProxy is UpgradeabilityOwnerStorage, UpgradeabilityProxy {\r\n  /**\r\n  * @dev Event to show ownership has been transferred\r\n  * @param previousOwner representing the address of the previous owner\r\n  * @param newOwner representing the address of the new owner\r\n  */\r\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    /**\r\n    * @dev the constructor sets the original owner of the contract to the sender account.\r\n    */\r\n    constructor() public {\r\n        setUpgradeabilityOwner(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyProxyOwner() {\r\n        require(msg.sender == proxyOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the proxy owner\r\n    * @return the address of the proxy owner\r\n    */\r\n    function proxyOwner() public view returns (address) {\r\n        return upgradeabilityOwner();\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferProxyOwnership(address newOwner) public onlyProxyOwner {\r\n        require(newOwner != address(0));\r\n        emit ProxyOwnershipTransferred(proxyOwner(), newOwner);\r\n        setUpgradeabilityOwner(newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the upgradeability owner to upgrade the current version of the proxy.\r\n    * @param version representing the version name of the new implementation to be set.\r\n    * @param implementation representing the address of the new implementation to be set.\r\n    */\r\n    function upgradeTo(uint256 version, address implementation) public onlyProxyOwner {\r\n        _upgradeTo(version, implementation);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the upgradeability owner to upgrade the current version of the proxy and call the new implementation\r\n    * to initialize whatever is needed through a low level call.\r\n    * @param version representing the version name of the new implementation to be set.\r\n    * @param implementation representing the address of the new implementation to be set.\r\n    * @param data represents the msg.data to bet sent in the low level call. This parameter may include the function\r\n    * signature of the implementation to be called with the needed payload\r\n    */\r\n    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {\r\n        upgradeTo(version, implementation);\r\n        require(address(this).call.value(msg.value)(data));\r\n    }\r\n}\r\n\r\n// File: contracts/upgradeability/EternalStorageProxy.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title EternalStorageProxy\r\n * @dev This proxy holds the storage of the token contract and delegates every call to the current implementation set.\r\n * Besides, it allows to upgrade the token's behaviour towards further implementations, and provides basic\r\n * authorization control functionalities\r\n */\r\ncontract EternalStorageProxy is OwnedUpgradeabilityProxy, EternalStorage {}\r\n\r\n// File: contracts/upgradeable_contracts/EternalOwnable.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title EternalOwnable\r\n * @dev This contract has an owner address providing basic authorization control\r\n */\r\ncontract EternalOwnable is EternalStorage {\r\n    /**\r\n    * @dev Event to show ownership has been transferred\r\n    * @param previousOwner representing the address of the previous owner\r\n    * @param newOwner representing the address of the new owner\r\n    */\r\n    event EternalOwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the owner\r\n    * @return the address of the owner\r\n    */\r\n    function owner() public view returns (address) {\r\n        return addressStorage[keccak256(abi.encodePacked(\"owner\"))];\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner the address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        setOwner(newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Sets a new owner address\r\n    */\r\n    function setOwner(address newOwner) internal {\r\n        emit EternalOwnershipTransferred(owner(), newOwner);\r\n        addressStorage[keccak256(abi.encodePacked(\"owner\"))] = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/upgradeable_contracts/factories/BasicBridgeFactory.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\ncontract BasicBridgeFactory is EternalStorage, EternalOwnable {\r\n    uint256 constant public defaultDecimals = 18;\r\n\r\n    function getBridgeFactoryVersion() public pure returns(uint64 major, uint64 minor, uint64 patch) {\r\n        return (3, 0, 0);\r\n    }\r\n\r\n    function bridgeValidatorsImplementation() public view returns(address) {\r\n        return addressStorage[keccak256(abi.encodePacked(\"bridgeValidatorsImplementation\"))];\r\n    }\r\n\r\n    function setBridgeValidatorsImplementation(address _bridgeValidatorsImplementation) public onlyOwner {\r\n        addressStorage[keccak256(abi.encodePacked(\"bridgeValidatorsImplementation\"))] = _bridgeValidatorsImplementation;\r\n    }\r\n\r\n    function requiredSignatures() public view returns(uint256) {\r\n        return uintStorage[keccak256(abi.encodePacked(\"requiredSignatures\"))];\r\n    }\r\n\r\n    function setRequiredSignatures(uint256 _requiredSignatures) public onlyOwner {\r\n        require(initialValidators().length >= _requiredSignatures);\r\n        uintStorage[keccak256(abi.encodePacked(\"requiredSignatures\"))] = _requiredSignatures;\r\n    }\r\n\r\n    function initialValidators() public view returns(address[]) {\r\n        return addressArrayStorage[keccak256(abi.encodePacked(\"initialValidators\"))];\r\n    }\r\n\r\n    function setInitialValidators(address[] _initialValidators) public onlyOwner {\r\n        require(_initialValidators.length >= requiredSignatures());\r\n        addressArrayStorage[keccak256(abi.encodePacked(\"initialValidators\"))] = _initialValidators;\r\n    }\r\n\r\n    function bridgeValidatorsOwner() public view returns(address) {\r\n        return addressStorage[keccak256(abi.encodePacked(\"bridgeValidatorsOwner\"))];\r\n    }\r\n\r\n    function setBridgeValidatorsOwner(address _bridgeValidatorsOwner) public onlyOwner {\r\n        addressStorage[keccak256(abi.encodePacked(\"bridgeValidatorsOwner\"))] = _bridgeValidatorsOwner;\r\n    }\r\n\r\n    function bridgeValidatorsProxyOwner() public view returns(address) {\r\n        return addressStorage[keccak256(abi.encodePacked(\"bridgeValidatorsProxyOwner\"))];\r\n    }\r\n\r\n    function setBridgeValidatorsProxyOwner(address _bridgeValidatorsProxyOwner) public onlyOwner {\r\n        addressStorage[keccak256(abi.encodePacked(\"bridgeValidatorsProxyOwner\"))] = _bridgeValidatorsProxyOwner;\r\n    }\r\n\r\n    function requiredBlockConfirmations() public view returns(uint256) {\r\n        return uintStorage[keccak256(abi.encodePacked(\"requiredBlockConfirmations\"))];\r\n    }\r\n\r\n    function setRequiredBlockConfirmations(uint256 _requiredBlockConfirmations) public onlyOwner {\r\n        uintStorage[keccak256(abi.encodePacked(\"requiredBlockConfirmations\"))] = _requiredBlockConfirmations;\r\n    }\r\n\r\n    function gasPrice() public view returns(uint256) {\r\n        return uintStorage[keccak256(abi.encodePacked(\"gasPrice\"))];\r\n    }\r\n\r\n    function setGasPrice(uint256 _gasPrice) public onlyOwner {\r\n        uintStorage[keccak256(abi.encodePacked(\"gasPrice\"))] = _gasPrice;\r\n    }\r\n\r\n    function homeDailyLimit() public view returns(uint256) {\r\n        return uintStorage[keccak256(abi.encodePacked(\"homeDailyLimit\"))];\r\n    }\r\n\r\n    function setHomeDailyLimit(uint256 _homeDailyLimit) public onlyOwner {\r\n        uintStorage[keccak256(abi.encodePacked(\"homeDailyLimit\"))] = _homeDailyLimit;\r\n    }\r\n\r\n    function homeMaxPerTx() public view returns(uint256) {\r\n        return uintStorage[keccak256(abi.encodePacked(\"homeMaxPerTx\"))];\r\n    }\r\n\r\n    function setHomeMaxPerTx(uint256 _homeMaxPerTx) public onlyOwner {\r\n        uintStorage[keccak256(abi.encodePacked(\"homeMaxPerTx\"))] = _homeMaxPerTx;\r\n    }\r\n\r\n    function foreignMaxPerTx() public view returns(uint256) {\r\n        return uintStorage[keccak256(abi.encodePacked(\"foreignMaxPerTx\"))];\r\n    }\r\n\r\n    function setForeignMaxPerTx(uint256 _foreignMaxPerTx) public onlyOwner {\r\n        uintStorage[keccak256(abi.encodePacked(\"foreignMaxPerTx\"))] = _foreignMaxPerTx;\r\n    }\r\n\r\n    function setInitialize(bool _status) internal {\r\n        boolStorage[keccak256(abi.encodePacked(\"isInitialized\"))] = _status;\r\n    }\r\n\r\n    function isInitialized() public view returns(bool) {\r\n        return boolStorage[keccak256(abi.encodePacked(\"isInitialized\"))];\r\n    }\r\n\r\n    function adjustToDefaultDecimals(uint256 _amount, uint8 _decimals) public pure  returns(uint256) {\r\n        if (defaultDecimals > _decimals) {\r\n            return _amount / (10 ** (defaultDecimals - _decimals));\r\n        } else if (defaultDecimals < _decimals) {\r\n            return _amount * (10 ** (_decimals - defaultDecimals));\r\n        } else {\r\n            return _amount;\r\n        }\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20Detailed token\r\n * @dev The decimals are only for visualization purposes.\r\n * All the operations are done using the smallest and indivisible token unit,\r\n * just as on Ethereum all the operations are done in wei.\r\n */\r\ncontract ERC20Detailed is IERC20 {\r\n  string private _name;\r\n  string private _symbol;\r\n  uint8 private _decimals;\r\n\r\n  constructor(string name, string symbol, uint8 decimals) public {\r\n    _name = name;\r\n    _symbol = symbol;\r\n    _decimals = decimals;\r\n  }\r\n\r\n  /**\r\n   * @return the name of the token.\r\n   */\r\n  function name() public view returns(string) {\r\n    return _name;\r\n  }\r\n\r\n  /**\r\n   * @return the symbol of the token.\r\n   */\r\n  function symbol() public view returns(string) {\r\n    return _symbol;\r\n  }\r\n\r\n  /**\r\n   * @return the number of decimals of the token.\r\n   */\r\n  function decimals() public view returns(uint8) {\r\n    return _decimals;\r\n  }\r\n}\r\n\r\n// File: contracts/upgradeable_contracts/factories/ForeignBridgeFactory.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ForeignBridgeFactory is BasicBridgeFactory {\r\n\r\n    event ForeignBridgeDeployed(address indexed _foreignBridge, address indexed _foreignValidators, address _foreignToken, uint256 _blockNumber);\r\n\r\n    function initialize(address _owner,\r\n            address _bridgeValidatorsImplementation,\r\n            uint256 _requiredSignatures,\r\n            address[] _initialValidators,\r\n            address _bridgeValidatorsOwner,\r\n            address _foreignBridgeErcToErcImplementation,\r\n            uint256 _requiredBlockConfirmations,\r\n            uint256 _gasPrice,\r\n            uint256 _foreignMaxPerTx,\r\n            uint256 _homeDailyLimit,\r\n            uint256 _homeMaxPerTx,\r\n            address _foreignBridgeOwner,\r\n            address _foreignProxyOwner) public returns(bool) {\r\n\r\n        require(!isInitialized());\r\n        require(_owner != address(0));\r\n        require(_bridgeValidatorsImplementation != address(0));\r\n        require(_requiredSignatures >= 1);\r\n        require(_bridgeValidatorsOwner != address(0));\r\n        require(_foreignBridgeErcToErcImplementation != address(0));\r\n        require(_requiredBlockConfirmations != 0);\r\n        require(_gasPrice > 0);\r\n        require(_foreignMaxPerTx >= 0);\r\n        require(_homeMaxPerTx < _homeDailyLimit);\r\n        require(_foreignBridgeOwner != address(0));\r\n        require(_foreignProxyOwner != address(0));\r\n        require(_initialValidators.length >= _requiredSignatures);\r\n\r\n        setOwner(msg.sender); // set just to have access to the setters.\r\n        setBridgeValidatorsImplementation(_bridgeValidatorsImplementation);\r\n        setInitialValidators(_initialValidators);\r\n        setRequiredSignatures(_requiredSignatures);\r\n        setBridgeValidatorsOwner(_bridgeValidatorsOwner);\r\n        setBridgeValidatorsProxyOwner(_foreignProxyOwner);\r\n        setForeignBridgeErcToErcImplementation(_foreignBridgeErcToErcImplementation);\r\n        setRequiredBlockConfirmations(_requiredBlockConfirmations);\r\n        setGasPrice(_gasPrice);\r\n        setForeignMaxPerTx(_foreignMaxPerTx);\r\n        setHomeDailyLimit(_homeDailyLimit);\r\n        setHomeMaxPerTx(_homeMaxPerTx);\r\n        setForeignBridgeOwner(_foreignBridgeOwner);\r\n        setForeignBridgeProxyOwner(_foreignProxyOwner);\r\n        setInitialize(true);\r\n        setOwner(_owner); // set to the real owner.\r\n        return isInitialized();\r\n    }\r\n\r\n    function deployForeignBridge(address _erc20Token) public {\r\n        // deploy new EternalStorageProxy\r\n        EternalStorageProxy proxy = new EternalStorageProxy();\r\n        // connect it to the static BridgeValidators implementation\r\n        proxy.upgradeTo(1, bridgeValidatorsImplementation());\r\n        // cast proxy as IBridgeValidators\r\n        IBridgeValidators bridgeValidators = IBridgeValidators(proxy);\r\n        // initialize bridgeValidators\r\n        bridgeValidators.initialize(requiredSignatures(), initialValidators(), bridgeValidatorsOwner());\r\n        // transfer proxy upgradeability admin\r\n        proxy.transferProxyOwnership(bridgeValidatorsProxyOwner());\r\n        // deploy new EternalStorageProxy\r\n        proxy = new EternalStorageProxy();\r\n        // connect it to the static ForeignBridgeErcToErc implementation\r\n        proxy.upgradeTo(1, foreignBridgeErcToErcImplementation());\r\n        // cast proxy as IForeignBridge\r\n        IForeignBridge foreignBridge = IForeignBridge(proxy);\r\n        // take the token decimals for limits adjustments\r\n        uint8 tokenDecimals = ERC20Detailed(_erc20Token).decimals();\r\n        // initialize foreignBridge\r\n        uint256 foreignMaxPerTxVal = adjustToDefaultDecimals(foreignMaxPerTx(), tokenDecimals);\r\n        uint256 homeDailyLimitVal = adjustToDefaultDecimals(homeDailyLimit(), tokenDecimals);\r\n        uint256 homeMaxPerTxVal = adjustToDefaultDecimals(homeMaxPerTx(), tokenDecimals);\r\n        foreignBridge.initialize(bridgeValidators, _erc20Token, requiredBlockConfirmations(), gasPrice(), foreignMaxPerTxVal, homeDailyLimitVal, homeMaxPerTxVal, foreignBridgeOwner());\r\n        // transfer proxy upgradeability admin\r\n        proxy.transferProxyOwnership(foreignBridgeProxyOwner());\r\n        // emit event\r\n        emit ForeignBridgeDeployed(foreignBridge, bridgeValidators, _erc20Token, block.number);\r\n    }\r\n\r\n    function registerForeignBridge(address _foreignBridge, address _foreignValidators, address _erc20Token, uint256 _blockNumber) public onlyOwner {\r\n        emit ForeignBridgeDeployed(_foreignBridge, _foreignValidators, _erc20Token, _blockNumber);\r\n    }\r\n\r\n    function foreignBridgeErcToErcImplementation() public view returns(address) {\r\n        return addressStorage[keccak256(abi.encodePacked(\"foreignBridgeErcToErcImplementation\"))];\r\n    }\r\n\r\n    function setForeignBridgeErcToErcImplementation(address _foreignBridgeErcToErcImplementation) public onlyOwner {\r\n        addressStorage[keccak256(abi.encodePacked(\"foreignBridgeErcToErcImplementation\"))] = _foreignBridgeErcToErcImplementation;\r\n    }\r\n\r\n    function foreignBridgeOwner() public view returns(address) {\r\n        return addressStorage[keccak256(abi.encodePacked(\"foreignBridgeOwner\"))];\r\n    }\r\n\r\n    function setForeignBridgeOwner(address _foreignBridgeOwner) public onlyOwner {\r\n        addressStorage[keccak256(abi.encodePacked(\"foreignBridgeOwner\"))] = _foreignBridgeOwner;\r\n    }\r\n\r\n    function foreignBridgeProxyOwner() public view returns(address) {\r\n        return addressStorage[keccak256(abi.encodePacked(\"foreignBridgeProxyOwner\"))];\r\n    }\r\n\r\n    function setForeignBridgeProxyOwner(address _foreignBridgeProxyOwner) public onlyOwner {\r\n        addressStorage[keccak256(abi.encodePacked(\"foreignBridgeProxyOwner\"))] = _foreignBridgeProxyOwner;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_decimals\",\"type\":\"uint8\"}],\"name\":\"adjustToDefaultDecimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bridgeValidatorsOwner\",\"type\":\"address\"}],\"name\":\"setBridgeValidatorsOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foreignBridgeProxyOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foreignBridgeOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"homeMaxPerTx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultDecimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foreignMaxPerTx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foreignBridgeErcToErcImplementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requiredBlockConfirmations\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBridgeFactoryVersion\",\"outputs\":[{\"name\":\"major\",\"type\":\"uint64\"},{\"name\":\"minor\",\"type\":\"uint64\"},{\"name\":\"patch\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_foreignBridgeErcToErcImplementation\",\"type\":\"address\"}],\"name\":\"setForeignBridgeErcToErcImplementation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialValidators\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_bridgeValidatorsImplementation\",\"type\":\"address\"},{\"name\":\"_requiredSignatures\",\"type\":\"uint256\"},{\"name\":\"_initialValidators\",\"type\":\"address[]\"},{\"name\":\"_bridgeValidatorsOwner\",\"type\":\"address\"},{\"name\":\"_foreignBridgeErcToErcImplementation\",\"type\":\"address\"},{\"name\":\"_requiredBlockConfirmations\",\"type\":\"uint256\"},{\"name\":\"_gasPrice\",\"type\":\"uint256\"},{\"name\":\"_foreignMaxPerTx\",\"type\":\"uint256\"},{\"name\":\"_homeDailyLimit\",\"type\":\"uint256\"},{\"name\":\"_homeMaxPerTx\",\"type\":\"uint256\"},{\"name\":\"_foreignBridgeOwner\",\"type\":\"address\"},{\"name\":\"_foreignProxyOwner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bridgeValidatorsProxyOwner\",\"type\":\"address\"}],\"name\":\"setBridgeValidatorsProxyOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_homeMaxPerTx\",\"type\":\"uint256\"}],\"name\":\"setHomeMaxPerTx\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bridgeValidatorsImplementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_requiredSignatures\",\"type\":\"uint256\"}],\"name\":\"setRequiredSignatures\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bridgeValidatorsOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"homeDailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_foreignBridge\",\"type\":\"address\"},{\"name\":\"_foreignValidators\",\"type\":\"address\"},{\"name\":\"_erc20Token\",\"type\":\"address\"},{\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"registerForeignBridge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requiredSignatures\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_foreignBridgeOwner\",\"type\":\"address\"}],\"name\":\"setForeignBridgeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_requiredBlockConfirmations\",\"type\":\"uint256\"}],\"name\":\"setRequiredBlockConfirmations\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_homeDailyLimit\",\"type\":\"uint256\"}],\"name\":\"setHomeDailyLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bridgeValidatorsProxyOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gasPrice\",\"type\":\"uint256\"}],\"name\":\"setGasPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_foreignMaxPerTx\",\"type\":\"uint256\"}],\"name\":\"setForeignMaxPerTx\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_erc20Token\",\"type\":\"address\"}],\"name\":\"deployForeignBridge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bridgeValidatorsImplementation\",\"type\":\"address\"}],\"name\":\"setBridgeValidatorsImplementation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_foreignBridgeProxyOwner\",\"type\":\"address\"}],\"name\":\"setForeignBridgeProxyOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_initialValidators\",\"type\":\"address[]\"}],\"name\":\"setInitialValidators\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_foreignBridge\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_foreignValidators\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_foreignToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"ForeignBridgeDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"EternalOwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ForeignBridgeFactory","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://9bf72477a210aa9abf64a63cf1dd0bf52985c21e25f461d57890859af898b404"}]}