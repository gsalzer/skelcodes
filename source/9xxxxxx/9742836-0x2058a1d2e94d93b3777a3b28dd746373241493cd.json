{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n    Copyright 2020 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title Bytes32Library\r\n * @author Set Protocol\r\n *\r\n * As of version contracts 1.3.36-beta Bytes32Library is made external in order for library\r\n * to be linked.\r\n */\r\nlibrary Bytes32Library {\r\n    /**\r\n     * Converts a bytes32 data structure into a bytes array.\r\n     *\r\n     * @param  data       Piece of data encoded as bytes32\r\n     * @return bytes\r\n     */\r\n    function bytes32ToBytes(bytes32 data)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        uint256 i = 0;\r\n        while (i < 32 && uint256(bytes32(data[i])) != 0) {\r\n            ++i;\r\n        }\r\n        bytes memory result = new bytes(i);\r\n        i = 0;\r\n        while (i < 32 && data[i] != 0) {\r\n            result[i] = data[i];\r\n            ++i;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Converts a piece of data encoded as bytes32 into a string.\r\n     *\r\n     * @param  data       Piece of data encoded as bytes32\r\n     * @return string\r\n     */\r\n    function bytes32ToString(bytes32 data)\r\n        external\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        bytes memory intermediate = bytes32ToBytes(data);\r\n        return string(abi.encodePacked(intermediate));\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/core/interfaces/ICore.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title ICore\r\n * @author Set Protocol\r\n *\r\n * The ICore Contract defines all the functions exposed in the Core through its\r\n * various extensions and is a light weight way to interact with the contract.\r\n */\r\ninterface ICore {\r\n    /**\r\n     * Return transferProxy address.\r\n     *\r\n     * @return address       transferProxy address\r\n     */\r\n    function transferProxy()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /**\r\n     * Return vault address.\r\n     *\r\n     * @return address       vault address\r\n     */\r\n    function vault()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /**\r\n     * Return address belonging to given exchangeId.\r\n     *\r\n     * @param  _exchangeId       ExchangeId number\r\n     * @return address           Address belonging to given exchangeId\r\n     */\r\n    function exchangeIds(\r\n        uint8 _exchangeId\r\n    )\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /*\r\n     * Returns if valid set\r\n     *\r\n     * @return  bool      Returns true if Set created through Core and isn't disabled\r\n     */\r\n    function validSets(address)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /*\r\n     * Returns if valid module\r\n     *\r\n     * @return  bool      Returns true if valid module\r\n     */\r\n    function validModules(address)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * Return boolean indicating if address is a valid Rebalancing Price Library.\r\n     *\r\n     * @param  _priceLibrary    Price library address\r\n     * @return bool             Boolean indicating if valid Price Library\r\n     */\r\n    function validPriceLibraries(\r\n        address _priceLibrary\r\n    )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * Exchanges components for Set Tokens\r\n     *\r\n     * @param  _set          Address of set to issue\r\n     * @param  _quantity     Quantity of set to issue\r\n     */\r\n    function issue(\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Issues a specified Set for a specified quantity to the recipient\r\n     * using the caller's components from the wallet and vault.\r\n     *\r\n     * @param  _recipient    Address to issue to\r\n     * @param  _set          Address of the Set to issue\r\n     * @param  _quantity     Number of tokens to issue\r\n     */\r\n    function issueTo(\r\n        address _recipient,\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Converts user's components into Set Tokens held directly in Vault instead of user's account\r\n     *\r\n     * @param _set          Address of the Set\r\n     * @param _quantity     Number of tokens to redeem\r\n     */\r\n    function issueInVault(\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Function to convert Set Tokens into underlying components\r\n     *\r\n     * @param _set          The address of the Set token\r\n     * @param _quantity     The number of tokens to redeem. Should be multiple of natural unit.\r\n     */\r\n    function redeem(\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Redeem Set token and return components to specified recipient. The components\r\n     * are left in the vault\r\n     *\r\n     * @param _recipient    Recipient of Set being issued\r\n     * @param _set          Address of the Set\r\n     * @param _quantity     Number of tokens to redeem\r\n     */\r\n    function redeemTo(\r\n        address _recipient,\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Function to convert Set Tokens held in vault into underlying components\r\n     *\r\n     * @param _set          The address of the Set token\r\n     * @param _quantity     The number of tokens to redeem. Should be multiple of natural unit.\r\n     */\r\n    function redeemInVault(\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Composite method to redeem and withdraw with a single transaction\r\n     *\r\n     * Normally, you should expect to be able to withdraw all of the tokens.\r\n     * However, some have central abilities to freeze transfers (e.g. EOS). _toExclude\r\n     * allows you to optionally specify which component tokens to exclude when\r\n     * redeeming. They will remain in the vault under the users' addresses.\r\n     *\r\n     * @param _set          Address of the Set\r\n     * @param _to           Address to withdraw or attribute tokens to\r\n     * @param _quantity     Number of tokens to redeem\r\n     * @param _toExclude    Mask of indexes of tokens to exclude from withdrawing\r\n     */\r\n    function redeemAndWithdrawTo(\r\n        address _set,\r\n        address _to,\r\n        uint256 _quantity,\r\n        uint256 _toExclude\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Deposit multiple tokens to the vault. Quantities should be in the\r\n     * order of the addresses of the tokens being deposited.\r\n     *\r\n     * @param  _tokens           Array of the addresses of the ERC20 tokens\r\n     * @param  _quantities       Array of the number of tokens to deposit\r\n     */\r\n    function batchDeposit(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Withdraw multiple tokens from the vault. Quantities should be in the\r\n     * order of the addresses of the tokens being withdrawn.\r\n     *\r\n     * @param  _tokens            Array of the addresses of the ERC20 tokens\r\n     * @param  _quantities        Array of the number of tokens to withdraw\r\n     */\r\n    function batchWithdraw(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Deposit any quantity of tokens into the vault.\r\n     *\r\n     * @param  _token           The address of the ERC20 token\r\n     * @param  _quantity        The number of tokens to deposit\r\n     */\r\n    function deposit(\r\n        address _token,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Withdraw a quantity of tokens from the vault.\r\n     *\r\n     * @param  _token           The address of the ERC20 token\r\n     * @param  _quantity        The number of tokens to withdraw\r\n     */\r\n    function withdraw(\r\n        address _token,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Transfer tokens associated with the sender's account in vault to another user's\r\n     * account in vault.\r\n     *\r\n     * @param  _token           Address of token being transferred\r\n     * @param  _to              Address of user receiving tokens\r\n     * @param  _quantity        Amount of tokens being transferred\r\n     */\r\n    function internalTransfer(\r\n        address _token,\r\n        address _to,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Deploys a new Set Token and adds it to the valid list of SetTokens\r\n     *\r\n     * @param  _factory              The address of the Factory to create from\r\n     * @param  _components           The address of component tokens\r\n     * @param  _units                The units of each component token\r\n     * @param  _naturalUnit          The minimum unit to be issued or redeemed\r\n     * @param  _name                 The bytes32 encoded name of the new Set\r\n     * @param  _symbol               The bytes32 encoded symbol of the new Set\r\n     * @param  _callData             Byte string containing additional call parameters\r\n     * @return setTokenAddress       The address of the new Set\r\n     */\r\n    function createSet(\r\n        address _factory,\r\n        address[] calldata _components,\r\n        uint256[] calldata _units,\r\n        uint256 _naturalUnit,\r\n        bytes32 _name,\r\n        bytes32 _symbol,\r\n        bytes calldata _callData\r\n    )\r\n        external\r\n        returns (address);\r\n\r\n    /**\r\n     * Exposes internal function that deposits a quantity of tokens to the vault and attributes\r\n     * the tokens respectively, to system modules.\r\n     *\r\n     * @param  _from            Address to transfer tokens from\r\n     * @param  _to              Address to credit for deposit\r\n     * @param  _token           Address of token being deposited\r\n     * @param  _quantity        Amount of tokens to deposit\r\n     */\r\n    function depositModule(\r\n        address _from,\r\n        address _to,\r\n        address _token,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Exposes internal function that withdraws a quantity of tokens from the vault and\r\n     * deattributes the tokens respectively, to system modules.\r\n     *\r\n     * @param  _from            Address to decredit for withdraw\r\n     * @param  _to              Address to transfer tokens to\r\n     * @param  _token           Address of token being withdrawn\r\n     * @param  _quantity        Amount of tokens to withdraw\r\n     */\r\n    function withdrawModule(\r\n        address _from,\r\n        address _to,\r\n        address _token,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Exposes internal function that deposits multiple tokens to the vault, to system\r\n     * modules. Quantities should be in the order of the addresses of the tokens being\r\n     * deposited.\r\n     *\r\n     * @param  _from              Address to transfer tokens from\r\n     * @param  _to                Address to credit for deposits\r\n     * @param  _tokens            Array of the addresses of the tokens being deposited\r\n     * @param  _quantities        Array of the amounts of tokens to deposit\r\n     */\r\n    function batchDepositModule(\r\n        address _from,\r\n        address _to,\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Exposes internal function that withdraws multiple tokens from the vault, to system\r\n     * modules. Quantities should be in the order of the addresses of the tokens being withdrawn.\r\n     *\r\n     * @param  _from              Address to decredit for withdrawals\r\n     * @param  _to                Address to transfer tokens to\r\n     * @param  _tokens            Array of the addresses of the tokens being withdrawn\r\n     * @param  _quantities        Array of the amounts of tokens to withdraw\r\n     */\r\n    function batchWithdrawModule(\r\n        address _from,\r\n        address _to,\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose internal function that exchanges components for Set tokens,\r\n     * accepting any owner, to system modules\r\n     *\r\n     * @param  _owner        Address to use tokens from\r\n     * @param  _recipient    Address to issue Set to\r\n     * @param  _set          Address of the Set to issue\r\n     * @param  _quantity     Number of tokens to issue\r\n     */\r\n    function issueModule(\r\n        address _owner,\r\n        address _recipient,\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose internal function that exchanges Set tokens for components,\r\n     * accepting any owner, to system modules\r\n     *\r\n     * @param  _burnAddress         Address to burn token from\r\n     * @param  _incrementAddress    Address to increment component tokens to\r\n     * @param  _set                 Address of the Set to redeem\r\n     * @param  _quantity            Number of tokens to redeem\r\n     */\r\n    function redeemModule(\r\n        address _burnAddress,\r\n        address _incrementAddress,\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose vault function that increments user's balance in the vault.\r\n     * Available to system modules\r\n     *\r\n     * @param  _tokens          The addresses of the ERC20 tokens\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantities      The numbers of tokens to attribute to owner\r\n     */\r\n    function batchIncrementTokenOwnerModule(\r\n        address[] calldata _tokens,\r\n        address _owner,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose vault function that decrement user's balance in the vault\r\n     * Only available to system modules.\r\n     *\r\n     * @param  _tokens          The addresses of the ERC20 tokens\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantities      The numbers of tokens to attribute to owner\r\n     */\r\n    function batchDecrementTokenOwnerModule(\r\n        address[] calldata _tokens,\r\n        address _owner,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose vault function that transfer vault balances between users\r\n     * Only available to system modules.\r\n     *\r\n     * @param  _tokens           Addresses of tokens being transferred\r\n     * @param  _from             Address tokens being transferred from\r\n     * @param  _to               Address tokens being transferred to\r\n     * @param  _quantities       Amounts of tokens being transferred\r\n     */\r\n    function batchTransferBalanceModule(\r\n        address[] calldata _tokens,\r\n        address _from,\r\n        address _to,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Transfers token from one address to another using the transfer proxy.\r\n     * Only available to system modules.\r\n     *\r\n     * @param  _token          The address of the ERC20 token\r\n     * @param  _quantity       The number of tokens to transfer\r\n     * @param  _from           The address to transfer from\r\n     * @param  _to             The address to transfer to\r\n     */\r\n    function transferModule(\r\n        address _token,\r\n        uint256 _quantity,\r\n        address _from,\r\n        address _to\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose transfer proxy function to transfer tokens from one address to another\r\n     * Only available to system modules.\r\n     *\r\n     * @param  _tokens         The addresses of the ERC20 token\r\n     * @param  _quantities     The numbers of tokens to transfer\r\n     * @param  _from           The address to transfer from\r\n     * @param  _to             The address to transfer to\r\n     */\r\n    function batchTransferModule(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _quantities,\r\n        address _from,\r\n        address _to\r\n    )\r\n        external;\r\n}\r\n\r\n// File: contracts/core/interfaces/IWhiteList.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n/**\r\n * @title IWhiteList\r\n * @author Set Protocol\r\n *\r\n * The IWhiteList interface exposes the whitelist mapping to check components\r\n */\r\ninterface IWhiteList {\r\n\r\n    /* ============ External Functions ============ */\r\n\r\n    /**\r\n     * Validates address against white list\r\n     *\r\n     * @param  _address       Address to check\r\n     * @return bool           Whether passed in address is whitelisted\r\n     */\r\n    function whiteList(\r\n        address _address\r\n    )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * Verifies an array of addresses against the whitelist\r\n     *\r\n     * @param  _addresses    Array of addresses to verify\r\n     * @return bool          Whether all addresses in the list are whitelsited\r\n     */\r\n    function areValidAddresses(\r\n        address[] calldata _addresses\r\n    )\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n// File: contracts/external/0x/LibBytes.sol\r\n\r\n/*\r\n  Copyright 2018 ZeroEx Intl.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\nlibrary LibBytes {\r\n\r\n    using LibBytes for bytes;\r\n\r\n    /// @dev Gets the memory address for the contents of a byte array.\r\n    /// @param input Byte array to lookup.\r\n    /// @return memoryAddress Memory address of the contents of the byte array.\r\n    function contentAddress(bytes memory input)\r\n        internal\r\n        pure\r\n        returns (uint256 memoryAddress)\r\n    {\r\n        assembly {\r\n            memoryAddress := add(input, 32)\r\n        }\r\n        return memoryAddress;\r\n    }\r\n\r\n    /// @dev Reads an unpadded bytes4 value from a position in a byte array.\r\n    /// @param b Byte array containing a bytes4 value.\r\n    /// @param index Index in byte array of bytes4 value.\r\n    /// @return bytes4 value from byte array.\r\n    function readBytes4(\r\n        bytes memory b,\r\n        uint256 index)\r\n        internal\r\n        pure\r\n        returns (bytes4 result)\r\n    {\r\n        require(\r\n            b.length >= index + 4,\r\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\r\n        );\r\n        assembly {\r\n            result := mload(add(b, 32))\r\n            // Solidity does not require us to clean the trailing bytes.\r\n            // We do it anyway\r\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\r\n        }\r\n        return result;\r\n    }\r\n\r\n\r\n    /// @dev Reads a bytes32 value from a position in a byte array.\r\n    /// @param b Byte array containing a bytes32 value.\r\n    /// @param index Index in byte array of bytes32 value.\r\n    /// @return bytes32 value from byte array.\r\n    function readBytes32(\r\n        bytes memory b,\r\n        uint256 index\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes32 result)\r\n    {\r\n        require(\r\n            b.length >= index + 32,\r\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\r\n        );\r\n\r\n        // Arrays are prefixed by a 256 bit length parameter\r\n        index += 32;\r\n\r\n        // Read the bytes32 from array memory\r\n        assembly {\r\n            result := mload(add(b, index))\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /// @dev Copies `length` bytes from memory location `source` to `dest`.\r\n    /// @param dest memory address to copy bytes to.\r\n    /// @param source memory address to copy bytes from.\r\n    /// @param length number of bytes to copy.\r\n    function memCopy(\r\n        uint256 dest,\r\n        uint256 source,\r\n        uint256 length\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (length < 32) {\r\n            // Handle a partial word by reading destination and masking\r\n            // off the bits we are interested in.\r\n            // This correctly handles overlap, zero lengths and source == dest\r\n            assembly {\r\n                let mask := sub(exp(256, sub(32, length)), 1)\r\n                let s := and(mload(source), not(mask))\r\n                let d := and(mload(dest), mask)\r\n                mstore(dest, or(s, d))\r\n            }\r\n        } else {\r\n            // Skip the O(length) loop when source == dest.\r\n            if (source == dest) {\r\n                return;\r\n            }\r\n\r\n            // For large copies we copy whole words at a time. The final\r\n            // word is aligned to the end of the range (instead of after the\r\n            // previous) to handle partial words. So a copy will look like this:\r\n            //\r\n            //  ####\r\n            //      ####\r\n            //          ####\r\n            //            ####\r\n            //\r\n            // We handle overlap in the source and destination range by\r\n            // changing the copying direction. This prevents us from\r\n            // overwriting parts of source that we still need to copy.\r\n            //\r\n            // This correctly handles source == dest\r\n            //\r\n            if (source > dest) {\r\n                assembly {\r\n                    // We subtract 32 from `sEnd` and `dEnd` because it\r\n                    // is easier to compare with in the loop, and these\r\n                    // are also the addresses we need for copying the\r\n                    // last bytes.\r\n                    length := sub(length, 32)\r\n                    let sEnd := add(source, length)\r\n                    let dEnd := add(dest, length)\r\n\r\n                    // Remember the last 32 bytes of source\r\n                    // This needs to be done here and not after the loop\r\n                    // because we may have overwritten the last bytes in\r\n                    // source already due to overlap.\r\n                    let last := mload(sEnd)\r\n\r\n                    // Copy whole words front to back\r\n                    // Note: the first check is always true,\r\n                    // this could have been a do-while loop.\r\n                    for {} lt(source, sEnd) {} {\r\n                        mstore(dest, mload(source))\r\n                        source := add(source, 32)\r\n                        dest := add(dest, 32)\r\n                    }\r\n\r\n                    // Write the last 32 bytes\r\n                    mstore(dEnd, last)\r\n                }\r\n            } else {\r\n                assembly {\r\n                    // We subtract 32 from `sEnd` and `dEnd` because those\r\n                    // are the starting points when copying a word at the end.\r\n                    length := sub(length, 32)\r\n                    let sEnd := add(source, length)\r\n                    let dEnd := add(dest, length)\r\n\r\n                    // Remember the first 32 bytes of source\r\n                    // This needs to be done here and not after the loop\r\n                    // because we may have overwritten the first bytes in\r\n                    // source already due to overlap.\r\n                    let first := mload(source)\r\n\r\n                    // Copy whole words back to front\r\n                    // We use a signed comparisson here to allow dEnd to become\r\n                    // negative (happens when source and dest < 32). Valid\r\n                    // addresses in local memory will never be larger than\r\n                    // 2**255, so they can be safely re-interpreted as signed.\r\n                    // Note: the first check is always true,\r\n                    // this could have been a do-while loop.\r\n                    for {} slt(dest, dEnd) {} {\r\n                        mstore(dEnd, mload(sEnd))\r\n                        sEnd := sub(sEnd, 32)\r\n                        dEnd := sub(dEnd, 32)\r\n                    }\r\n\r\n                    // Write the first 32 bytes\r\n                    mstore(dest, first)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a slices from a byte array.\r\n    /// @param b The byte array to take a slice from.\r\n    /// @param from The starting index for the slice (inclusive).\r\n    /// @param to The final index for the slice (exclusive).\r\n    /// @return result The slice containing bytes at indices [from, to)\r\n    function slice(bytes memory b, uint256 from, uint256 to)\r\n        internal\r\n        pure\r\n        returns (bytes memory result)\r\n    {\r\n        require(\r\n            from <= to,\r\n            \"FROM_LESS_THAN_TO_REQUIRED\"\r\n        );\r\n        require(\r\n            // NOTE: Set Protocol changed from `to < b.length` so that the last byte can be sliced off\r\n            to <= b.length,\r\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\r\n        );\r\n\r\n        // Create a new bytes structure and copy contents\r\n        result = new bytes(to - from);\r\n        memCopy(\r\n            result.contentAddress(),\r\n            b.contentAddress() + from,\r\n            result.length);\r\n        return result;\r\n    }\r\n}\r\n\r\n// File: contracts/core/interfaces/ISetToken.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n/**\r\n * @title ISetToken\r\n * @author Set Protocol\r\n *\r\n * The ISetToken interface provides a light-weight, structured way to interact with the\r\n * SetToken contract from another contract.\r\n */\r\ninterface ISetToken {\r\n\r\n    /* ============ External Functions ============ */\r\n\r\n    /*\r\n     * Get natural unit of Set\r\n     *\r\n     * @return  uint256       Natural unit of Set\r\n     */\r\n    function naturalUnit()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get addresses of all components in the Set\r\n     *\r\n     * @return  componentAddresses       Array of component tokens\r\n     */\r\n    function getComponents()\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    /*\r\n     * Get units of all tokens in Set\r\n     *\r\n     * @return  units       Array of component units\r\n     */\r\n    function getUnits()\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /*\r\n     * Checks to make sure token is component of Set\r\n     *\r\n     * @param  _tokenAddress     Address of token being checked\r\n     * @return  bool             True if token is component of Set\r\n     */\r\n    function tokenIsComponent(\r\n        address _tokenAddress\r\n    )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /*\r\n     * Mint set token for given address.\r\n     * Can only be called by authorized contracts.\r\n     *\r\n     * @param  _issuer      The address of the issuing account\r\n     * @param  _quantity    The number of sets to attribute to issuer\r\n     */\r\n    function mint(\r\n        address _issuer,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Burn set token for given address\r\n     * Can only be called by authorized contracts\r\n     *\r\n     * @param  _from        The address of the redeeming account\r\n     * @param  _quantity    The number of sets to burn from redeemer\r\n     */\r\n    function burn(\r\n        address _from,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n    * Transfer token for a specified address\r\n    *\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function transfer(\r\n        address to,\r\n        uint256 value\r\n    )\r\n        external;\r\n}\r\n\r\n// File: contracts/core/lib/SetTokenLibrary.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\npragma experimental \"ABIEncoderV2\";\r\n\r\n\r\n\r\n\r\n\r\nlibrary SetTokenLibrary {\r\n    using SafeMath for uint256;\r\n\r\n    struct SetDetails {\r\n        uint256 naturalUnit;\r\n        address[] components;\r\n        uint256[] units;\r\n    }\r\n\r\n    /**\r\n     * Validates that passed in tokens are all components of the Set\r\n     *\r\n     * @param _set                      Address of the Set\r\n     * @param _tokens                   List of tokens to check\r\n     */\r\n    function validateTokensAreComponents(\r\n        address _set,\r\n        address[] calldata _tokens\r\n    )\r\n        external\r\n        view\r\n    {\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            // Make sure all tokens are members of the Set\r\n            require(\r\n                ISetToken(_set).tokenIsComponent(_tokens[i]),\r\n                \"SetTokenLibrary.validateTokensAreComponents: Component must be a member of Set\"\r\n            );\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates that passed in quantity is a multiple of the natural unit of the Set.\r\n     *\r\n     * @param _set                      Address of the Set\r\n     * @param _quantity                 Quantity to validate\r\n     */\r\n    function isMultipleOfSetNaturalUnit(\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external\r\n        view\r\n    {\r\n        require(\r\n            _quantity.mod(ISetToken(_set).naturalUnit()) == 0,\r\n            \"SetTokenLibrary.isMultipleOfSetNaturalUnit: Quantity is not a multiple of nat unit\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Validates that passed in quantity is a multiple of the natural unit of the Set.\r\n     *\r\n     * @param _core                     Address of Core\r\n     * @param _set                      Address of the Set\r\n     */\r\n    function requireValidSet(\r\n        ICore _core,\r\n        address _set\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(\r\n            _core.validSets(_set),\r\n            \"SetTokenLibrary: Must be an approved SetToken address\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Retrieves the Set's natural unit, components, and units.\r\n     *\r\n     * @param _set                      Address of the Set\r\n     * @return SetDetails               Struct containing the natural unit, components, and units\r\n     */\r\n    function getSetDetails(\r\n        address _set\r\n    )\r\n        internal\r\n        view\r\n        returns (SetDetails memory)\r\n    {\r\n        // Declare interface variables\r\n        ISetToken setToken = ISetToken(_set);\r\n\r\n        // Fetch set token properties\r\n        uint256 naturalUnit = setToken.naturalUnit();\r\n        address[] memory components = setToken.getComponents();\r\n        uint256[] memory units = setToken.getUnits();\r\n\r\n        return SetDetails({\r\n            naturalUnit: naturalUnit,\r\n            components: components,\r\n            units: units\r\n        });\r\n    }\r\n}\r\n\r\n// File: contracts/core/tokens/rebalancing-v3/FactoryUtilsLibrary.sol\r\n\r\n/*\r\n    Copyright 2020 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n * We segmented the FactoryUtils into it's own library to lower RebalancingSetTokenV3Factory\r\n * deployed bytecode size.\r\n */\r\nlibrary FactoryUtilsLibrary {\r\n    using SafeMath for uint256;\r\n    using LibBytes for bytes;\r\n\r\n    struct InitRebalancingParameters {\r\n        address manager;\r\n        address liquidator;\r\n        address feeRecipient;\r\n        address rebalanceFeeCalculator;\r\n        uint256 rebalanceInterval;\r\n        uint256 rebalanceFailPeriod;\r\n        uint256 lastRebalanceTimestamp;\r\n        uint256 entryFee;\r\n        bytes rebalanceFeeCalculatorData;\r\n    }\r\n\r\n    /*\r\n     * Performs set calldata validations\r\n     */\r\n    function validateRebalanceSetCalldata(\r\n        InitRebalancingParameters memory _parameters,\r\n        address _liquidatorWhitelist,\r\n        address _feeCalculatorWhitelist,\r\n        uint256 _minimumRebalanceInterval,\r\n        uint256 _minimumFailRebalancePeriod,\r\n        uint256 _maximumFailRebalancePeriod\r\n    )\r\n        public\r\n        view\r\n    {\r\n        require(\r\n            _parameters.manager != address(0),\r\n            \"Null manager\"\r\n        );\r\n\r\n        require(\r\n            _parameters.lastRebalanceTimestamp <= block.timestamp,\r\n            \"Bad RebalanceTimestamp\"\r\n        );\r\n\r\n        // Require liquidator address is non-zero and is whitelisted by the liquidatorWhitelist\r\n        require(\r\n            _parameters.liquidator != address(0) &&\r\n            IWhiteList(_liquidatorWhitelist).whiteList(_parameters.liquidator),\r\n            \"Bad liquidator\"\r\n        );\r\n\r\n        // Require rebalance fee calculator is whitelisted by the liquidatorWhitelist\r\n        require(\r\n            IWhiteList(_feeCalculatorWhitelist).whiteList(address(_parameters.rebalanceFeeCalculator)),\r\n            \"Bad fee calculator\"\r\n        );\r\n\r\n        require(\r\n            _parameters.rebalanceInterval >= _minimumRebalanceInterval,\r\n            \"Bad Rebalance interval\"\r\n        );\r\n\r\n        require(\r\n            _parameters.rebalanceFailPeriod >= _minimumFailRebalancePeriod &&\r\n            _parameters.rebalanceFailPeriod <= _maximumFailRebalancePeriod,\r\n            \"Bad Fail Period\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Parses the calldata, which is configured as follows:\r\n     *\r\n     *\r\n     * | CallData                   | Location                      |\r\n     * |----------------------------|-------------------------------|\r\n     * | manager                    | 32                            |\r\n     * | liquidator                 | 64                            |\r\n     * | feeRecipient               | 96                            |\r\n     * | rebalanceFeeCalculator     | 128                           |\r\n     * | rebalanceInterval          | 160                           |\r\n     * | rebalanceFailPeriod        | 192                           |\r\n     * | entryFee                   | 224                           |\r\n     * | rebalanceFeeCalculatorData | 256 to end                    |\r\n     */\r\n    function parseRebalanceSetCallData(\r\n        bytes memory _callData\r\n    )\r\n        public\r\n        pure\r\n        returns (InitRebalancingParameters memory)\r\n    {\r\n        InitRebalancingParameters memory parameters;\r\n\r\n        assembly {\r\n            mstore(parameters,           mload(add(_callData, 32)))   // manager\r\n            mstore(add(parameters, 32),  mload(add(_callData, 64)))   // liquidator\r\n            mstore(add(parameters, 64),  mload(add(_callData, 96)))   // feeRecipient\r\n            mstore(add(parameters, 96),  mload(add(_callData, 128)))  // rebalanceFeeCalculator\r\n            mstore(add(parameters, 128), mload(add(_callData, 160)))  // rebalanceInterval\r\n            mstore(add(parameters, 160), mload(add(_callData, 192)))  // rebalanceFailPeriod\r\n            mstore(add(parameters, 192), mload(add(_callData, 224)))  // lastRebalanceTimestamp\r\n            mstore(add(parameters, 224), mload(add(_callData, 256)))  // entryFee\r\n        }\r\n\r\n        // Extracts the fee calculator data from the remaining calldata\r\n        parameters.rebalanceFeeCalculatorData = _callData.slice(256, _callData.length);\r\n\r\n        return parameters;\r\n    }\r\n\r\n    function validateRebalancingSet(\r\n        SetTokenLibrary.SetDetails memory _setDetails,\r\n        address _core,\r\n        address _sender,\r\n        uint256 _minimumNaturalUnit,\r\n        uint256 _maximumNaturalUnit\r\n    )\r\n        public\r\n        view\r\n    {\r\n        ICore coreInstance = ICore(_core);\r\n\r\n        require(\r\n            _sender == address(coreInstance),\r\n            \"Must be core\"\r\n        );\r\n\r\n        // Ensure component array only includes one address which will be the currentSet\r\n        require(\r\n            _setDetails.components.length == 1 &&\r\n            _setDetails.units.length == 1,\r\n            \"Components or units len != 1\"\r\n        );\r\n\r\n        require(\r\n            _setDetails.units[0] > 0,\r\n            \"UnitShares not > 0\"\r\n        );\r\n\r\n        // Expect Set to rebalance to be valid and enabled Set\r\n        require(\r\n            coreInstance.validSets(_setDetails.components[0]),\r\n            \"Bad Set\"\r\n        );\r\n\r\n        // Natural unit must be within minimum and maximum bounds\r\n        require(\r\n            _setDetails.naturalUnit >= _minimumNaturalUnit &&\r\n            _setDetails.naturalUnit <= _maximumNaturalUnit,\r\n            \"Bad natural unit\"\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/core/lib/RebalancingLibrary.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title RebalancingLibrary\r\n * @author Set Protocol\r\n *\r\n * The RebalancingLibrary contains functions for facilitating the rebalancing process for\r\n * Rebalancing Set Tokens. Removes the old calculation functions\r\n *\r\n */\r\nlibrary RebalancingLibrary {\r\n\r\n    /* ============ Enums ============ */\r\n\r\n    enum State { Default, Proposal, Rebalance, Drawdown }\r\n\r\n    /* ============ Structs ============ */\r\n\r\n    struct AuctionPriceParameters {\r\n        uint256 auctionStartTime;\r\n        uint256 auctionTimeToPivot;\r\n        uint256 auctionStartPrice;\r\n        uint256 auctionPivotPrice;\r\n    }\r\n\r\n    struct BiddingParameters {\r\n        uint256 minimumBid;\r\n        uint256 remainingCurrentSets;\r\n        uint256[] combinedCurrentUnits;\r\n        uint256[] combinedNextSetUnits;\r\n        address[] combinedTokenArray;\r\n    }\r\n}\r\n\r\n// File: contracts/core/interfaces/IRebalancingSetToken.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title IRebalancingSetToken\r\n * @author Set Protocol\r\n *\r\n * The IRebalancingSetToken interface provides a light-weight, structured way to interact with the\r\n * RebalancingSetToken contract from another contract.\r\n */\r\n\r\ninterface IRebalancingSetToken {\r\n\r\n    /*\r\n     * Get the auction library contract used for the current rebalance\r\n     *\r\n     * @return address    Address of auction library used in the upcoming auction\r\n     */\r\n    function auctionLibrary()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /*\r\n     * Get totalSupply of Rebalancing Set\r\n     *\r\n     * @return  totalSupply\r\n     */\r\n    function totalSupply()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get proposalTimeStamp of Rebalancing Set\r\n     *\r\n     * @return  proposalTimeStamp\r\n     */\r\n    function proposalStartTime()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get lastRebalanceTimestamp of Rebalancing Set\r\n     *\r\n     * @return  lastRebalanceTimestamp\r\n     */\r\n    function lastRebalanceTimestamp()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get rebalanceInterval of Rebalancing Set\r\n     *\r\n     * @return  rebalanceInterval\r\n     */\r\n    function rebalanceInterval()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get rebalanceState of Rebalancing Set\r\n     *\r\n     * @return RebalancingLibrary.State    Current rebalance state of the RebalancingSetToken\r\n     */\r\n    function rebalanceState()\r\n        external\r\n        view\r\n        returns (RebalancingLibrary.State);\r\n\r\n    /*\r\n     * Get the starting amount of current SetToken for the current auction\r\n     *\r\n     * @return  rebalanceState\r\n     */\r\n    function startingCurrentSetAmount()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Gets the balance of the specified address.\r\n     *\r\n     * @param owner      The address to query the balance of.\r\n     * @return           A uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(\r\n        address owner\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Function used to set the terms of the next rebalance and start the proposal period\r\n     *\r\n     * @param _nextSet                      The Set to rebalance into\r\n     * @param _auctionLibrary               The library used to calculate the Dutch Auction price\r\n     * @param _auctionTimeToPivot           The amount of time for the auction to go ffrom start to pivot price\r\n     * @param _auctionStartPrice            The price to start the auction at\r\n     * @param _auctionPivotPrice            The price at which the price curve switches from linear to exponential\r\n     */\r\n    function propose(\r\n        address _nextSet,\r\n        address _auctionLibrary,\r\n        uint256 _auctionTimeToPivot,\r\n        uint256 _auctionStartPrice,\r\n        uint256 _auctionPivotPrice\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Get natural unit of Set\r\n     *\r\n     * @return  uint256       Natural unit of Set\r\n     */\r\n    function naturalUnit()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Returns the address of the current base SetToken with the current allocation\r\n     *\r\n     * @return           A address representing the base SetToken\r\n     */\r\n    function currentSet()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /**\r\n     * Returns the address of the next base SetToken with the post auction allocation\r\n     *\r\n     * @return  address    Address representing the base SetToken\r\n     */\r\n    function nextSet()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /*\r\n     * Get the unit shares of the rebalancing Set\r\n     *\r\n     * @return  unitShares       Unit Shares of the base Set\r\n     */\r\n    function unitShares()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Burn set token for given address.\r\n     * Can only be called by authorized contracts.\r\n     *\r\n     * @param  _from        The address of the redeeming account\r\n     * @param  _quantity    The number of sets to burn from redeemer\r\n     */\r\n    function burn(\r\n        address _from,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Place bid during rebalance auction. Can only be called by Core.\r\n     *\r\n     * @param _quantity                 The amount of currentSet to be rebalanced\r\n     * @return combinedTokenArray       Array of token addresses invovled in rebalancing\r\n     * @return inflowUnitArray          Array of amount of tokens inserted into system in bid\r\n     * @return outflowUnitArray         Array of amount of tokens taken out of system in bid\r\n     */\r\n    function placeBid(\r\n        uint256 _quantity\r\n    )\r\n        external\r\n        returns (address[] memory, uint256[] memory, uint256[] memory);\r\n\r\n    /*\r\n     * Get combinedTokenArray of Rebalancing Set\r\n     *\r\n     * @return  combinedTokenArray\r\n     */\r\n    function getCombinedTokenArrayLength()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get combinedTokenArray of Rebalancing Set\r\n     *\r\n     * @return  combinedTokenArray\r\n     */\r\n    function getCombinedTokenArray()\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    /*\r\n     * Get failedAuctionWithdrawComponents of Rebalancing Set\r\n     *\r\n     * @return  failedAuctionWithdrawComponents\r\n     */\r\n    function getFailedAuctionWithdrawComponents()\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    /*\r\n     * Get auctionPriceParameters for current auction\r\n     *\r\n     * @return uint256[4]    AuctionPriceParameters for current rebalance auction\r\n     */\r\n    function getAuctionPriceParameters()\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /*\r\n     * Get biddingParameters for current auction\r\n     *\r\n     * @return uint256[2]    BiddingParameters for current rebalance auction\r\n     */\r\n    function getBiddingParameters()\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /*\r\n     * Get token inflows and outflows required for bid. Also the amount of Rebalancing\r\n     * Sets that would be generated.\r\n     *\r\n     * @param _quantity               The amount of currentSet to be rebalanced\r\n     * @return inflowUnitArray        Array of amount of tokens inserted into system in bid\r\n     * @return outflowUnitArray       Array of amount of tokens taken out of system in bid\r\n     */\r\n    function getBidPrice(\r\n        uint256 _quantity\r\n    )\r\n        external\r\n        view\r\n        returns (uint256[] memory, uint256[] memory);\r\n\r\n}\r\n\r\n// File: contracts/core/lib/Rebalance.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title Rebalance\r\n * @author Set Protocol\r\n *\r\n * Types and functions for Rebalance-related data.\r\n */\r\nlibrary Rebalance {\r\n\r\n    struct TokenFlow {\r\n        address[] addresses;\r\n        uint256[] inflow;\r\n        uint256[] outflow;\r\n    }\r\n\r\n    function composeTokenFlow(\r\n        address[] memory _addresses,\r\n        uint256[] memory _inflow,\r\n        uint256[] memory _outflow\r\n    )\r\n        internal\r\n        pure\r\n        returns(TokenFlow memory)\r\n    {\r\n        return TokenFlow({addresses: _addresses, inflow: _inflow, outflow: _outflow });\r\n    }\r\n\r\n    function decomposeTokenFlow(TokenFlow memory _tokenFlow)\r\n        internal\r\n        pure\r\n        returns (address[] memory, uint256[] memory, uint256[] memory)\r\n    {\r\n        return (_tokenFlow.addresses, _tokenFlow.inflow, _tokenFlow.outflow);\r\n    }\r\n\r\n    function decomposeTokenFlowToBidPrice(TokenFlow memory _tokenFlow)\r\n        internal\r\n        pure\r\n        returns (uint256[] memory, uint256[] memory)\r\n    {\r\n        return (_tokenFlow.inflow, _tokenFlow.outflow);\r\n    }\r\n\r\n    /**\r\n     * Get token flows array of addresses, inflows and outflows\r\n     *\r\n     * @param    _rebalancingSetToken   The rebalancing Set Token instance\r\n     * @param    _quantity              The amount of currentSet to be rebalanced\r\n     * @return   combinedTokenArray     Array of token addresses\r\n     * @return   inflowArray            Array of amount of tokens inserted into system in bid\r\n     * @return   outflowArray           Array of amount of tokens returned from system in bid\r\n     */\r\n    function getTokenFlows(\r\n        IRebalancingSetToken _rebalancingSetToken,\r\n        uint256 _quantity\r\n    )\r\n        internal\r\n        view\r\n        returns (address[] memory, uint256[] memory, uint256[] memory)\r\n    {\r\n        // Get token addresses\r\n        address[] memory combinedTokenArray = _rebalancingSetToken.getCombinedTokenArray();\r\n\r\n        // Get inflow and outflow arrays for the given bid quantity\r\n        (\r\n            uint256[] memory inflowArray,\r\n            uint256[] memory outflowArray\r\n        ) = _rebalancingSetToken.getBidPrice(_quantity);\r\n\r\n        return (combinedTokenArray, inflowArray, outflowArray);\r\n    }\r\n}\r\n\r\n// File: contracts/core/interfaces/ILiquidator.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ILiquidator\r\n * @author Set Protocol\r\n *\r\n */\r\ninterface ILiquidator {\r\n\r\n    /* ============ External Functions ============ */\r\n\r\n    function startRebalance(\r\n        ISetToken _currentSet,\r\n        ISetToken _nextSet,\r\n        uint256 _startingCurrentSetQuantity,\r\n        bytes calldata _liquidatorData\r\n    )\r\n        external;\r\n\r\n    function getBidPrice(\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external\r\n        view\r\n        returns (Rebalance.TokenFlow memory);\r\n\r\n    function placeBid(\r\n        uint256 _quantity\r\n    )\r\n        external\r\n        returns (Rebalance.TokenFlow memory);\r\n\r\n\r\n    function settleRebalance()\r\n        external;\r\n\r\n    function endFailedRebalance() external;\r\n\r\n    // ----------------------------------------------------------------------\r\n    // Auction Price\r\n    // ----------------------------------------------------------------------\r\n\r\n    function auctionPriceParameters(address _set)\r\n        external\r\n        view\r\n        returns (RebalancingLibrary.AuctionPriceParameters memory);\r\n\r\n    // ----------------------------------------------------------------------\r\n    // Auction\r\n    // ----------------------------------------------------------------------\r\n\r\n    function hasRebalanceFailed(address _set) external view returns (bool);\r\n    function minimumBid(address _set) external view returns (uint256);\r\n    function startingCurrentSets(address _set) external view returns (uint256);\r\n    function remainingCurrentSets(address _set) external view returns (uint256);\r\n    function getCombinedCurrentSetUnits(address _set) external view returns (uint256[] memory);\r\n    function getCombinedNextSetUnits(address _set) external view returns (uint256[] memory);\r\n    function getCombinedTokenArray(address _set) external view returns (address[] memory);\r\n}\r\n\r\n// File: contracts/core/interfaces/IFeeCalculator.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n/**\r\n * @title IFeeCalculator\r\n * @author Set Protocol\r\n *\r\n */\r\ninterface IFeeCalculator {\r\n\r\n    /* ============ External Functions ============ */\r\n\r\n    function initialize(\r\n        bytes calldata _feeCalculatorData\r\n    )\r\n        external;\r\n\r\n    function getFee()\r\n        external\r\n        view\r\n        returns(uint256);\r\n\r\n    function updateAndGetFee()\r\n        external\r\n        returns(uint256);\r\n\r\n    function adjustFee(\r\n        bytes calldata _newFeeData\r\n    )\r\n        external;\r\n}\r\n\r\n// File: contracts/core/interfaces/IRebalancingSetTokenV2.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title IRebalancingSetTokenV2\r\n * @author Set Protocol\r\n *\r\n * The IRebalancingSetTokenV2 interface provides a light-weight, structured way to interact with the\r\n * RebalancingSetTokenV2 contract from another contract.\r\n */\r\n\r\ninterface IRebalancingSetTokenV2 {\r\n\r\n    /*\r\n     * Get totalSupply of Rebalancing Set\r\n     *\r\n     * @return  totalSupply\r\n     */\r\n    function totalSupply()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Returns liquidator instance\r\n     *\r\n     * @return  ILiquidator    Liquidator instance\r\n     */\r\n    function liquidator()\r\n        external\r\n        view\r\n        returns (ILiquidator);\r\n\r\n    /*\r\n     * Get lastRebalanceTimestamp of Rebalancing Set\r\n     *\r\n     * @return  lastRebalanceTimestamp\r\n     */\r\n    function lastRebalanceTimestamp()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get rebalanceStartTime of Rebalancing Set\r\n     *\r\n     * @return  rebalanceStartTime\r\n     */\r\n    function rebalanceStartTime()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get startingCurrentSets of RebalancingSetToken\r\n     *\r\n     * @return  startingCurrentSets\r\n     */\r\n    function startingCurrentSetAmount()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get rebalanceInterval of Rebalancing Set\r\n     *\r\n     * @return  rebalanceInterval\r\n     */\r\n    function rebalanceInterval()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get array returning [startTime, timeToPivot, startPrice, endPrice]\r\n     *\r\n     * @return  AuctionPriceParameters\r\n     */\r\n    function getAuctionPriceParameters() external view returns (uint256[] memory);\r\n\r\n    /*\r\n     * Get array returning [minimumBid, remainingCurrentSets]\r\n     *\r\n     * @return  BiddingParameters\r\n     */\r\n    function getBiddingParameters() external view returns (uint256[] memory);\r\n\r\n    /*\r\n     * Get rebalanceState of Rebalancing Set\r\n     *\r\n     * @return RebalancingLibrary.State    Current rebalance state of the RebalancingSetTokenV2\r\n     */\r\n    function rebalanceState()\r\n        external\r\n        view\r\n        returns (RebalancingLibrary.State);\r\n\r\n    /**\r\n     * Gets the balance of the specified address.\r\n     *\r\n     * @param owner      The address to query the balance of.\r\n     * @return           A uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(\r\n        address owner\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get manager of Rebalancing Set\r\n     *\r\n     * @return  manager\r\n     */\r\n    function manager()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /*\r\n     * Get feeRecipient of Rebalancing Set\r\n     *\r\n     * @return  feeRecipient\r\n     */\r\n    function feeRecipient()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /*\r\n     * Get entryFee of Rebalancing Set\r\n     *\r\n     * @return  entryFee\r\n     */\r\n    function entryFee()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Retrieves the current expected fee from the fee calculator\r\n     * Value is returned as a scale decimal figure.\r\n     */\r\n    function rebalanceFee()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get calculator contract used to compute rebalance fees\r\n     *\r\n     * @return  rebalanceFeeCalculator\r\n     */\r\n    function rebalanceFeeCalculator()\r\n        external\r\n        view\r\n        returns (IFeeCalculator);\r\n\r\n    /*\r\n     * Initializes the RebalancingSetToken. Typically called by the Factory during creation\r\n     */\r\n    function initialize(\r\n        bytes calldata _rebalanceFeeCalldata\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Set new liquidator address. Only whitelisted addresses are valid.\r\n     */\r\n    function setLiquidator(\r\n        ILiquidator _newLiquidator\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Set new fee recipient address.\r\n     */\r\n    function setFeeRecipient(\r\n        address _newFeeRecipient\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Set new fee entry fee.\r\n     */\r\n    function setEntryFee(\r\n        uint256 _newEntryFee\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Initiates the rebalance in coordination with the Liquidator contract.\r\n     * In this step, we redeem the currentSet and pass relevant information\r\n     * to the liquidator.\r\n     *\r\n     * @param _nextSet                      The Set to rebalance into\r\n     * @param _liquidatorData               Bytecode formatted data with liquidator-specific arguments\r\n     *\r\n     * Can only be called if the rebalance interval has elapsed.\r\n     * Can only be called by manager.\r\n     */\r\n    function startRebalance(\r\n        address _nextSet,\r\n        bytes calldata _liquidatorData\r\n\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * After a successful rebalance, the new Set is issued. If there is a rebalance fee,\r\n     * the fee is paid via inflation of the Rebalancing Set to the feeRecipient.\r\n     * Full issuance functionality is now returned to set owners.\r\n     *\r\n     * Anyone can call this function.\r\n     */\r\n    function settleRebalance()\r\n        external;\r\n\r\n    /*\r\n     * Get natural unit of Set\r\n     *\r\n     * @return  uint256       Natural unit of Set\r\n     */\r\n    function naturalUnit()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Returns the address of the current base SetToken with the current allocation\r\n     *\r\n     * @return           A address representing the base SetToken\r\n     */\r\n    function currentSet()\r\n        external\r\n        view\r\n        returns (ISetToken);\r\n\r\n    /**\r\n     * Returns the address of the next base SetToken with the post auction allocation\r\n     *\r\n     * @return  address    Address representing the base SetToken\r\n     */\r\n    function nextSet()\r\n        external\r\n        view\r\n        returns (ISetToken);\r\n\r\n    /*\r\n     * Get the unit shares of the rebalancing Set\r\n     *\r\n     * @return  unitShares       Unit Shares of the base Set\r\n     */\r\n    function unitShares()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Place bid during rebalance auction. Can only be called by Core.\r\n     *\r\n     * @param _quantity                 The amount of currentSet to be rebalanced\r\n     * @return combinedTokenArray       Array of token addresses invovled in rebalancing\r\n     * @return inflowUnitArray          Array of amount of tokens inserted into system in bid\r\n     * @return outflowUnitArray         Array of amount of tokens taken out of system in bid\r\n     */\r\n    function placeBid(\r\n        uint256 _quantity\r\n    )\r\n        external\r\n        returns (address[] memory, uint256[] memory, uint256[] memory);\r\n\r\n    /*\r\n     * Get token inflows and outflows required for bid. Also the amount of Rebalancing\r\n     * Sets that would be generated.\r\n     *\r\n     * @param _quantity               The amount of currentSet to be rebalanced\r\n     * @return inflowUnitArray        Array of amount of tokens inserted into system in bid\r\n     * @return outflowUnitArray       Array of amount of tokens taken out of system in bid\r\n     */\r\n    function getBidPrice(\r\n        uint256 _quantity\r\n    )\r\n        external\r\n        view\r\n        returns (uint256[] memory, uint256[] memory);\r\n\r\n    /*\r\n     * Get name of Rebalancing Set\r\n     *\r\n     * @return  name\r\n     */\r\n    function name()\r\n        external\r\n        view\r\n        returns (string memory);\r\n\r\n    /*\r\n     * Get symbol of Rebalancing Set\r\n     *\r\n     * @return  symbol\r\n     */\r\n    function symbol()\r\n        external\r\n        view\r\n        returns (string memory);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://eips.ethereum.org/EIPS/eip-20\r\n * Originally based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n *\r\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\r\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\r\n * compliant implementations may not do it.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev Total number of tokens in existence\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param owner The address to query the balance of.\r\n     * @return A uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token to a specified address\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        _transfer(from, to, value);\r\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified addresses\r\n     * @param from The address to transfer from.\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0));\r\n\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that mints an amount of the token and assigns it to\r\n     * an account. This encapsulates the modification of balances such that the\r\n     * proper events are emitted.\r\n     * @param account The account that will receive the created tokens.\r\n     * @param value The amount that will be created.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.add(value);\r\n        _balances[account] = _balances[account].add(value);\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account.\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve an address to spend another addresses' tokens.\r\n     * @param owner The address that owns the tokens.\r\n     * @param spender The address that will spend the tokens.\r\n     * @param value The number of tokens that can be spent.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(spender != address(0));\r\n        require(owner != address(0));\r\n\r\n        _allowed[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account, deducting from the sender's allowance for said account. Uses the\r\n     * internal burn function.\r\n     * Emits an Approval event (reflecting the reduced allowance).\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burnFrom(address account, uint256 value) internal {\r\n        _burn(account, value);\r\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title ERC20Detailed token\r\n * @dev The decimals are only for visualization purposes.\r\n * All the operations are done using the smallest and indivisible token unit,\r\n * just as on Ethereum all the operations are done in wei.\r\n */\r\ncontract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    /**\r\n     * @return the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @return the symbol of the token.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @return the number of decimals of the token.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n// File: zos-lib/contracts/Initializable.sol\r\n\r\npragma solidity >=0.4.24 <0.6.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts/core/interfaces/ISetFactory.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title ISetFactory\r\n * @author Set Protocol\r\n *\r\n * The ISetFactory interface provides operability for authorized contracts\r\n * to interact with SetTokenFactory\r\n */\r\ninterface ISetFactory {\r\n\r\n    /* ============ External Functions ============ */\r\n\r\n    /**\r\n     * Return core address\r\n     *\r\n     * @return address        core address\r\n     */\r\n    function core()\r\n        external\r\n        returns (address);\r\n\r\n    /**\r\n     * Deploys a new Set Token and adds it to the valid list of SetTokens\r\n     *\r\n     * @param  _components           The address of component tokens\r\n     * @param  _units                The units of each component token\r\n     * @param  _naturalUnit          The minimum unit to be issued or redeemed\r\n     * @param  _name                 The bytes32 encoded name of the new Set\r\n     * @param  _symbol               The bytes32 encoded symbol of the new Set\r\n     * @param  _callData             Byte string containing additional call parameters\r\n     * @return setTokenAddress       The address of the new Set\r\n     */\r\n    function createSet(\r\n        address[] calldata _components,\r\n        uint[] calldata _units,\r\n        uint256 _naturalUnit,\r\n        bytes32 _name,\r\n        bytes32 _symbol,\r\n        bytes calldata _callData\r\n    )\r\n        external\r\n        returns (address);\r\n}\r\n\r\n// File: contracts/core/interfaces/IRebalancingSetFactory.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title IRebalancingSetFactory\r\n * @author Set Protocol\r\n *\r\n * The IRebalancingSetFactory interface provides operability for authorized contracts\r\n * to interact with RebalancingSetTokenFactory\r\n */\r\ncontract IRebalancingSetFactory is\r\n    ISetFactory\r\n{\r\n    /**\r\n     * Getter for minimumRebalanceInterval of RebalancingSetTokenFactory, used\r\n     * to enforce rebalanceInterval when creating a RebalancingSetToken\r\n     *\r\n     * @return uint256    Minimum amount of time between rebalances in seconds\r\n     */\r\n    function minimumRebalanceInterval()\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Getter for minimumProposalPeriod of RebalancingSetTokenFactory, used\r\n     * to enforce proposalPeriod when creating a RebalancingSetToken\r\n     *\r\n     * @return uint256    Minimum amount of time users can review proposals in seconds\r\n     */\r\n    function minimumProposalPeriod()\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Getter for minimumTimeToPivot of RebalancingSetTokenFactory, used\r\n     * to enforce auctionTimeToPivot when proposing a rebalance\r\n     *\r\n     * @return uint256    Minimum amount of time before auction pivot reached\r\n     */\r\n    function minimumTimeToPivot()\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Getter for maximumTimeToPivot of RebalancingSetTokenFactory, used\r\n     * to enforce auctionTimeToPivot when proposing a rebalance\r\n     *\r\n     * @return uint256    Maximum amount of time before auction pivot reached\r\n     */\r\n    function maximumTimeToPivot()\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Getter for minimumNaturalUnit of RebalancingSetTokenFactory\r\n     *\r\n     * @return uint256    Minimum natural unit\r\n     */\r\n    function minimumNaturalUnit()\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Getter for maximumNaturalUnit of RebalancingSetTokenFactory\r\n     *\r\n     * @return uint256    Maximum Minimum natural unit\r\n     */\r\n    function maximumNaturalUnit()\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Getter for rebalanceAuctionModule address on RebalancingSetTokenFactory\r\n     *\r\n     * @return address      Address of rebalanceAuctionModule\r\n     */\r\n    function rebalanceAuctionModule()\r\n        external\r\n        returns (address);\r\n}\r\n\r\n// File: contracts/core/interfaces/IVault.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n/**\r\n * @title IVault\r\n * @author Set Protocol\r\n *\r\n * The IVault interface provides a light-weight, structured way to interact with the Vault\r\n * contract from another contract.\r\n */\r\ninterface IVault {\r\n\r\n    /*\r\n     * Withdraws user's unassociated tokens to user account. Can only be\r\n     * called by authorized core contracts.\r\n     *\r\n     * @param  _token          The address of the ERC20 token\r\n     * @param  _to             The address to transfer token to\r\n     * @param  _quantity       The number of tokens to transfer\r\n     */\r\n    function withdrawTo(\r\n        address _token,\r\n        address _to,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Increment quantity owned of a token for a given address. Can\r\n     * only be called by authorized core contracts.\r\n     *\r\n     * @param  _token           The address of the ERC20 token\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantity        The number of tokens to attribute to owner\r\n     */\r\n    function incrementTokenOwner(\r\n        address _token,\r\n        address _owner,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Decrement quantity owned of a token for a given address. Can only\r\n     * be called by authorized core contracts.\r\n     *\r\n     * @param  _token           The address of the ERC20 token\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantity        The number of tokens to deattribute to owner\r\n     */\r\n    function decrementTokenOwner(\r\n        address _token,\r\n        address _owner,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Transfers tokens associated with one account to another account in the vault\r\n     *\r\n     * @param  _token          Address of token being transferred\r\n     * @param  _from           Address token being transferred from\r\n     * @param  _to             Address token being transferred to\r\n     * @param  _quantity       Amount of tokens being transferred\r\n     */\r\n\r\n    function transferBalance(\r\n        address _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n\r\n    /*\r\n     * Withdraws user's unassociated tokens to user account. Can only be\r\n     * called by authorized core contracts.\r\n     *\r\n     * @param  _tokens          The addresses of the ERC20 tokens\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantities      The numbers of tokens to attribute to owner\r\n     */\r\n    function batchWithdrawTo(\r\n        address[] calldata _tokens,\r\n        address _to,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Increment quantites owned of a collection of tokens for a given address. Can\r\n     * only be called by authorized core contracts.\r\n     *\r\n     * @param  _tokens          The addresses of the ERC20 tokens\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantities      The numbers of tokens to attribute to owner\r\n     */\r\n    function batchIncrementTokenOwner(\r\n        address[] calldata _tokens,\r\n        address _owner,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Decrements quantites owned of a collection of tokens for a given address. Can\r\n     * only be called by authorized core contracts.\r\n     *\r\n     * @param  _tokens          The addresses of the ERC20 tokens\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantities      The numbers of tokens to attribute to owner\r\n     */\r\n    function batchDecrementTokenOwner(\r\n        address[] calldata _tokens,\r\n        address _owner,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n   /**\r\n     * Transfers tokens associated with one account to another account in the vault\r\n     *\r\n     * @param  _tokens           Addresses of tokens being transferred\r\n     * @param  _from             Address tokens being transferred from\r\n     * @param  _to               Address tokens being transferred to\r\n     * @param  _quantities       Amounts of tokens being transferred\r\n     */\r\n    function batchTransferBalance(\r\n        address[] calldata _tokens,\r\n        address _from,\r\n        address _to,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Get balance of particular contract for owner.\r\n     *\r\n     * @param  _token    The address of the ERC20 token\r\n     * @param  _owner    The address of the token owner\r\n     */\r\n    function getOwnerBalance(\r\n        address _token,\r\n        address _owner\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts/lib/ScaleValidations.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\nlibrary ScaleValidations {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private constant ONE_HUNDRED_PERCENT = 1e18;\r\n    uint256 private constant ONE_BASIS_POINT = 1e14;\r\n\r\n    function validateLessThanEqualOneHundredPercent(uint256 _value) internal view {\r\n        require(_value <= ONE_HUNDRED_PERCENT, \"Must be <= 100%\");\r\n    }\r\n\r\n    function validateMultipleOfBasisPoint(uint256 _value) internal view {\r\n        require(\r\n            _value.mod(ONE_BASIS_POINT) == 0,\r\n            \"Must be multiple of 0.01%\"\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/core/tokens/rebalancing-v2/RebalancingSetState.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title RebalancingSetState\r\n * @author Set Protocol\r\n *\r\n */\r\ncontract RebalancingSetState {\r\n\r\n    /* ============ State Variables ============ */\r\n\r\n    // ----------------------------------------------------------------------\r\n    // System Related\r\n    // ----------------------------------------------------------------------\r\n\r\n    // Set Protocol's Core Contract\r\n    ICore public core;\r\n\r\n    // The Factory that created this Set\r\n    IRebalancingSetFactory public factory;\r\n\r\n    // Set Protocol's Vault contract\r\n    IVault public vault;\r\n\r\n    // The token whitelist that components are checked against during proposals\r\n    IWhiteList public componentWhiteList;\r\n\r\n    // WhiteList of liquidator contracts\r\n    IWhiteList public liquidatorWhiteList;\r\n\r\n    // Contract holding the state and logic required for rebalance liquidation\r\n    // The Liquidator interacts closely with the Set during rebalances.\r\n    ILiquidator public liquidator;\r\n\r\n    // Contract responsible for calculation of rebalance fees\r\n    IFeeCalculator public rebalanceFeeCalculator;\r\n\r\n    // The account that is allowed to make proposals\r\n    address public manager;\r\n\r\n    // The account that receives any fees\r\n    address public feeRecipient;\r\n\r\n    // ----------------------------------------------------------------------\r\n    // Configuration\r\n    // ----------------------------------------------------------------------\r\n\r\n    // Time in seconds that must elapsed from last rebalance to propose\r\n    uint256 public rebalanceInterval;\r\n\r\n    // Time in seconds after rebalanceStartTime before the Set believes the auction has failed\r\n    uint256 public rebalanceFailPeriod;\r\n\r\n    // Fee levied to feeRecipient every mint operation, paid during minting\r\n    // Represents a decimal value scaled by 1e18 (e.g. 100% = 1e18 and 1% = 1e16)\r\n    uint256 public entryFee;\r\n\r\n    // ----------------------------------------------------------------------\r\n    // Current State\r\n    // ----------------------------------------------------------------------\r\n\r\n    // The Set currently collateralizing the Rebalancing Set\r\n    ISetToken public currentSet;\r\n\r\n    // The number of currentSet per naturalUnit of the Rebalancing Set\r\n    uint256 public unitShares;\r\n\r\n    // The minimum issuable value of a Set\r\n    uint256 public naturalUnit;\r\n\r\n    // The current state of the Set (e.g. Default, Proposal, Rebalance, Drawdown)\r\n    // Proposal is unused\r\n    RebalancingLibrary.State public rebalanceState;\r\n\r\n    // The number of rebalances in the Set's history; starts at index 0\r\n    uint256 public rebalanceIndex;\r\n\r\n    // The timestamp of the last completed rebalance\r\n    uint256 public lastRebalanceTimestamp;\r\n\r\n    // ----------------------------------------------------------------------\r\n    // Live Rebalance State\r\n    // ----------------------------------------------------------------------\r\n\r\n    // The proposal's SetToken to rebalance into\r\n    ISetToken public nextSet;\r\n\r\n    // The timestamp of the last rebalance was initiated at\r\n    uint256 public rebalanceStartTime;\r\n\r\n    // Whether a successful bid has been made during the rebalance.\r\n    // In the case that the rebalance has failed, hasBidded is used\r\n    // to determine whether the Set should be put into Drawdown or Default state.\r\n    bool public hasBidded;\r\n\r\n    // In the event a Set is put into the Drawdown state, these components\r\n    // that can be withdrawn by users\r\n    address[] internal failedRebalanceComponents;\r\n\r\n    /* ============ Modifier ============ */\r\n\r\n    modifier onlyManager() {\r\n        validateManager();\r\n        _;\r\n    }\r\n\r\n    /* ============ Events ============ */\r\n\r\n    event NewManagerAdded(\r\n        address newManager,\r\n        address oldManager\r\n    );\r\n\r\n    event NewLiquidatorAdded(\r\n        address newLiquidator,\r\n        address oldLiquidator\r\n    );\r\n\r\n    event NewEntryFee(\r\n        uint256 newEntryFee,\r\n        uint256 oldEntryFee\r\n    );\r\n\r\n    event NewFeeRecipient(\r\n        address newFeeRecipient,\r\n        address oldFeeRecipient\r\n    );\r\n\r\n    event EntryFeePaid(\r\n        address indexed feeRecipient,\r\n        uint256 feeQuantity\r\n    );\r\n\r\n    event RebalanceStarted(\r\n        address oldSet,\r\n        address newSet,\r\n        uint256 rebalanceIndex,\r\n        uint256 currentSetQuantity\r\n    );\r\n\r\n    event RebalanceSettled(\r\n        address indexed feeRecipient,\r\n        uint256 feeQuantity,\r\n        uint256 feePercentage,\r\n        uint256 rebalanceIndex,\r\n        uint256 issueQuantity,\r\n        uint256 unitShares\r\n    );\r\n\r\n    /* ============ Setter Functions ============ */\r\n\r\n    /*\r\n     * Set new manager address.\r\n     */\r\n    function setManager(\r\n        address _newManager\r\n    )\r\n        external\r\n        onlyManager\r\n    {\r\n        emit NewManagerAdded(_newManager, manager);\r\n        manager = _newManager;\r\n    }\r\n\r\n    function setEntryFee(\r\n        uint256 _newEntryFee\r\n    )\r\n        external\r\n        onlyManager\r\n    {\r\n        ScaleValidations.validateLessThanEqualOneHundredPercent(_newEntryFee);\r\n\r\n        ScaleValidations.validateMultipleOfBasisPoint(_newEntryFee);\r\n\r\n        emit NewEntryFee(_newEntryFee, entryFee);\r\n        entryFee = _newEntryFee;\r\n    }\r\n\r\n    /*\r\n     * Set new liquidator address. Only whitelisted addresses are valid.\r\n     */\r\n    function setLiquidator(\r\n        ILiquidator _newLiquidator\r\n    )\r\n        external\r\n        onlyManager\r\n    {\r\n        require(\r\n            rebalanceState != RebalancingLibrary.State.Rebalance,\r\n            \"Invalid state\"\r\n        );\r\n\r\n        require(\r\n            liquidatorWhiteList.whiteList(address(_newLiquidator)),\r\n            \"Not whitelisted\"\r\n        );\r\n\r\n        emit NewLiquidatorAdded(address(_newLiquidator), address(liquidator));\r\n        liquidator = _newLiquidator;\r\n    }\r\n\r\n    function setFeeRecipient(\r\n        address _newFeeRecipient\r\n    )\r\n        external\r\n        onlyManager\r\n    {\r\n        emit NewFeeRecipient(_newFeeRecipient, feeRecipient);\r\n        feeRecipient = _newFeeRecipient;\r\n    }\r\n\r\n    /* ============ Getter Functions ============ */\r\n\r\n    /*\r\n     * Retrieves the current expected fee from the fee calculator\r\n     * Value is returned as a scale decimal figure.\r\n     */\r\n    function rebalanceFee()\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return rebalanceFeeCalculator.getFee();\r\n    }\r\n\r\n    /*\r\n     * Function for compatability with ISetToken interface. Returns currentSet.\r\n     */\r\n    function getComponents()\r\n        external\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        address[] memory components = new address[](1);\r\n        components[0] = address(currentSet);\r\n        return components;\r\n    }\r\n\r\n    /*\r\n     * Function for compatability with ISetToken interface. Returns unitShares.\r\n     */\r\n    function getUnits()\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory units = new uint256[](1);\r\n        units[0] = unitShares;\r\n        return units;\r\n    }\r\n\r\n    /*\r\n     * Returns whether the address is the current set of the RebalancingSetToken.\r\n     * Conforms to the ISetToken Interface.\r\n     */\r\n    function tokenIsComponent(\r\n        address _tokenAddress\r\n    )\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _tokenAddress == address(currentSet);\r\n    }\r\n\r\n    /* ============ Validations ============ */\r\n    function validateManager() internal view {\r\n        require(\r\n            msg.sender == manager,\r\n            \"Not manager\"\r\n        );\r\n    }\r\n\r\n    function validateCallerIsCore() internal view {\r\n        require(\r\n            msg.sender == address(core),\r\n            \"Not Core\"\r\n        );\r\n    }\r\n\r\n    function validateCallerIsModule() internal view {\r\n        require(\r\n            core.validModules(msg.sender),\r\n            \"Not approved module\"\r\n        );\r\n    }\r\n\r\n    function validateRebalanceStateIs(RebalancingLibrary.State _requiredState) internal view {\r\n        require(\r\n            rebalanceState == _requiredState,\r\n            \"Invalid state\"\r\n        );\r\n    }\r\n\r\n    function validateRebalanceStateIsNot(RebalancingLibrary.State _requiredState) internal view {\r\n        require(\r\n            rebalanceState != _requiredState,\r\n            \"Invalid state\"\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/core/tokens/rebalancing-v2/BackwardCompatibility.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title BackwardCompatibility\r\n * @author Set Protocol\r\n *\r\n * This module allows full backwards compatability with RebalancingSetTokenV1. It implements\r\n * all the same getter functions to allow upstream applications to make minimized changes\r\n * to support the new version.\r\n *\r\n * The following interfaces are not included:\r\n * - propose(address, address, uint256, uint256, uint256): Implementation would have\r\n *.    been a revert.\r\n * - biddingParameters: RebalancingSetToken V1 biddingParameters reverts on call\r\n */\r\ncontract BackwardCompatibility is\r\n    RebalancingSetState\r\n{\r\n    /* ============ Empty Variables ============ */\r\n\r\n    // Deprecated auctionLibrary. Returns 0x00 to prevent reverts\r\n    address public auctionLibrary;\r\n\r\n    // Deprecated proposal period. Returns 0 to prevent reverts\r\n    uint256 public proposalPeriod;\r\n\r\n    // Deprecated proposal start time. Returns 0 to prevent reverts\r\n    uint256 public proposalStartTime;\r\n\r\n    /* ============ Getters ============ */\r\n\r\n    function getAuctionPriceParameters() external view returns (uint256[] memory) {\r\n        RebalancingLibrary.AuctionPriceParameters memory params = liquidator.auctionPriceParameters(\r\n            address(this)\r\n        );\r\n\r\n        uint256[] memory auctionPriceParams = new uint256[](4);\r\n        auctionPriceParams[0] = params.auctionStartTime;\r\n        auctionPriceParams[1] = params.auctionTimeToPivot;\r\n        auctionPriceParams[2] = params.auctionStartPrice;\r\n        auctionPriceParams[3] = params.auctionPivotPrice;\r\n\r\n        return auctionPriceParams;\r\n    }\r\n\r\n    function getCombinedCurrentUnits() external view returns (uint256[] memory) {\r\n        return liquidator.getCombinedCurrentSetUnits(address(this));\r\n    }\r\n\r\n    function getCombinedNextSetUnits() external view returns (uint256[] memory) {\r\n        return liquidator.getCombinedNextSetUnits(address(this));\r\n    }\r\n\r\n    function getCombinedTokenArray() external view returns (address[] memory) {\r\n        return liquidator.getCombinedTokenArray(address(this));\r\n    }\r\n\r\n    function getCombinedTokenArrayLength() external view returns (uint256) {\r\n        return liquidator.getCombinedTokenArray(address(this)).length;\r\n    }\r\n\r\n    function startingCurrentSetAmount() external view returns (uint256) {\r\n        return liquidator.startingCurrentSets(address(this));\r\n    }\r\n\r\n    function auctionPriceParameters() external view\r\n        returns (RebalancingLibrary.AuctionPriceParameters memory)\r\n    {\r\n        return liquidator.auctionPriceParameters(address(this));\r\n    }\r\n\r\n    /*\r\n     * Since structs with arrays cannot be retrieved, we return\r\n     * minimumBid and remainingCurrentSets separately.\r\n     *\r\n     * @return  biddingParams       Array with minimumBid and remainingCurrentSets\r\n     */\r\n    function getBiddingParameters() public view returns (uint256[] memory) {\r\n        uint256[] memory biddingParams = new uint256[](2);\r\n        biddingParams[0] = liquidator.minimumBid(address(this));\r\n        biddingParams[1] = liquidator.remainingCurrentSets(address(this));\r\n        return biddingParams;\r\n    }\r\n\r\n    function biddingParameters()\r\n        external\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        uint256[] memory biddingParams = getBiddingParameters();\r\n        return (biddingParams[0], biddingParams[1]);\r\n    }\r\n\r\n    function getFailedAuctionWithdrawComponents() external view returns (address[] memory) {\r\n        return failedRebalanceComponents;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/Math.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the average of two numbers. Since these are integers,\r\n     * averages of an even and odd number cannot be represented, and will be\r\n     * rounded down.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/AddressArrayUtils.sol\r\n\r\n// Pulled in from Cryptofin Solidity package in order to control Solidity compiler version\r\n// https://github.com/cryptofinlabs/cryptofin-solidity/blob/master/contracts/array-utils/AddressArrayUtils.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\nlibrary AddressArrayUtils {\r\n\r\n    /**\r\n     * Finds the index of the first occurrence of the given element.\r\n     * @param A The input array to search\r\n     * @param a The value to find\r\n     * @return Returns (index and isIn) for the first occurrence starting from index 0\r\n     */\r\n    function indexOf(address[] memory A, address a) internal pure returns (uint256, bool) {\r\n        uint256 length = A.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            if (A[i] == a) {\r\n                return (i, true);\r\n            }\r\n        }\r\n        return (0, false);\r\n    }\r\n\r\n    /**\r\n    * Returns true if the value is present in the list. Uses indexOf internally.\r\n    * @param A The input array to search\r\n    * @param a The value to find\r\n    * @return Returns isIn for the first occurrence starting from index 0\r\n    */\r\n    function contains(address[] memory A, address a) internal pure returns (bool) {\r\n        bool isIn;\r\n        (, isIn) = indexOf(A, a);\r\n        return isIn;\r\n    }\r\n\r\n    /**\r\n     * Returns the combination of the two arrays\r\n     * @param A The first array\r\n     * @param B The second array\r\n     * @return Returns A extended by B\r\n     */\r\n    function extend(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\r\n        uint256 aLength = A.length;\r\n        uint256 bLength = B.length;\r\n        address[] memory newAddresses = new address[](aLength + bLength);\r\n        for (uint256 i = 0; i < aLength; i++) {\r\n            newAddresses[i] = A[i];\r\n        }\r\n        for (uint256 j = 0; j < bLength; j++) {\r\n            newAddresses[aLength + j] = B[j];\r\n        }\r\n        return newAddresses;\r\n    }\r\n\r\n    /**\r\n     * Returns the array with a appended to A.\r\n     * @param A The first array\r\n     * @param a The value to append\r\n     * @return Returns A appended by a\r\n     */\r\n    function append(address[] memory A, address a) internal pure returns (address[] memory) {\r\n        address[] memory newAddresses = new address[](A.length + 1);\r\n        for (uint256 i = 0; i < A.length; i++) {\r\n            newAddresses[i] = A[i];\r\n        }\r\n        newAddresses[A.length] = a;\r\n        return newAddresses;\r\n    }\r\n\r\n    /**\r\n     * Returns the intersection of two arrays. Arrays are treated as collections, so duplicates are kept.\r\n     * @param A The first array\r\n     * @param B The second array\r\n     * @return The intersection of the two arrays\r\n     */\r\n    function intersect(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\r\n        uint256 length = A.length;\r\n        bool[] memory includeMap = new bool[](length);\r\n        uint256 newLength = 0;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            if (contains(B, A[i])) {\r\n                includeMap[i] = true;\r\n                newLength++;\r\n            }\r\n        }\r\n        address[] memory newAddresses = new address[](newLength);\r\n        uint256 j = 0;\r\n        for (uint256 k = 0; k < length; k++) {\r\n            if (includeMap[k]) {\r\n                newAddresses[j] = A[k];\r\n                j++;\r\n            }\r\n        }\r\n        return newAddresses;\r\n    }\r\n\r\n    /**\r\n     * Returns the union of the two arrays. Order is not guaranteed.\r\n     * @param A The first array\r\n     * @param B The second array\r\n     * @return The union of the two arrays\r\n     */\r\n    function union(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\r\n        address[] memory leftDifference = difference(A, B);\r\n        address[] memory rightDifference = difference(B, A);\r\n        address[] memory intersection = intersect(A, B);\r\n        return extend(leftDifference, extend(intersection, rightDifference));\r\n    }\r\n\r\n    /**\r\n     * Computes the difference of two arrays. Assumes there are no duplicates.\r\n     * @param A The first array\r\n     * @param B The second array\r\n     * @return The difference of the two arrays\r\n     */\r\n    function difference(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\r\n        uint256 length = A.length;\r\n        bool[] memory includeMap = new bool[](length);\r\n        uint256 count = 0;\r\n        // First count the new length because can't push for in-memory arrays\r\n        for (uint256 i = 0; i < length; i++) {\r\n            address e = A[i];\r\n            if (!contains(B, e)) {\r\n                includeMap[i] = true;\r\n                count++;\r\n            }\r\n        }\r\n        address[] memory newAddresses = new address[](count);\r\n        uint256 j = 0;\r\n        for (uint256 k = 0; k < length; k++) {\r\n            if (includeMap[k]) {\r\n                newAddresses[j] = A[k];\r\n                j++;\r\n            }\r\n        }\r\n        return newAddresses;\r\n    }\r\n\r\n    /**\r\n    * Removes specified index from array\r\n    * Resulting ordering is not guaranteed\r\n    * @return Returns the new array and the removed entry\r\n    */\r\n    function pop(address[] memory A, uint256 index)\r\n        internal\r\n        pure\r\n        returns (address[] memory, address)\r\n    {\r\n        uint256 length = A.length;\r\n        address[] memory newAddresses = new address[](length - 1);\r\n        for (uint256 i = 0; i < index; i++) {\r\n            newAddresses[i] = A[i];\r\n        }\r\n        for (uint256 j = index + 1; j < length; j++) {\r\n            newAddresses[j - 1] = A[j];\r\n        }\r\n        return (newAddresses, A[index]);\r\n    }\r\n\r\n    /**\r\n     * @return Returns the new array\r\n     */\r\n    function remove(address[] memory A, address a)\r\n        internal\r\n        pure\r\n        returns (address[] memory)\r\n    {\r\n        (uint256 index, bool isIn) = indexOf(A, a);\r\n        if (!isIn) {\r\n            revert();\r\n        } else {\r\n            (address[] memory _A,) = pop(A, index);\r\n            return _A;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not there's a duplicate. Runs in O(n^2).\r\n     * @param A Array to search\r\n     * @return Returns true if duplicate, false otherwise\r\n     */\r\n    function hasDuplicate(address[] memory A) internal pure returns (bool) {\r\n        if (A.length == 0) {\r\n            return false;\r\n        }\r\n        for (uint256 i = 0; i < A.length - 1; i++) {\r\n            for (uint256 j = i + 1; j < A.length; j++) {\r\n                if (A[i] == A[j]) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns whether the two arrays are equal.\r\n     * @param A The first array\r\n     * @param B The second array\r\n     * @return True is the arrays are equal, false if not.\r\n     */\r\n    function isEqual(address[] memory A, address[] memory B) internal pure returns (bool) {\r\n        if (A.length != B.length) {\r\n            return false;\r\n        }\r\n        for (uint256 i = 0; i < A.length; i++) {\r\n            if (A[i] != B[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/CommonMath.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\nlibrary CommonMath {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public constant SCALE_FACTOR = 10 ** 18;\r\n    uint256 public constant MAX_UINT_256 = 2 ** 256 - 1;\r\n\r\n    /**\r\n     * Returns scale factor equal to 10 ** 18\r\n     *\r\n     * @return  10 ** 18\r\n     */\r\n    function scaleFactor()\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return SCALE_FACTOR;\r\n    }\r\n\r\n    /**\r\n     * Calculates and returns the maximum value for a uint256\r\n     *\r\n     * @return  The maximum value for uint256\r\n     */\r\n    function maxUInt256()\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return MAX_UINT_256;\r\n    }\r\n\r\n    /**\r\n     * Increases a value by the scale factor to allow for additional precision\r\n     * during mathematical operations\r\n     */\r\n    function scale(\r\n        uint256 a\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a.mul(SCALE_FACTOR);\r\n    }\r\n\r\n    /**\r\n     * Divides a value by the scale factor to allow for additional precision\r\n     * during mathematical operations\r\n    */\r\n    function deScale(\r\n        uint256 a\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a.div(SCALE_FACTOR);\r\n    }\r\n\r\n    /**\r\n    * @dev Performs the power on a specified value, reverts on overflow.\r\n    */\r\n    function safePower(\r\n        uint256 a,\r\n        uint256 pow\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(a > 0);\r\n\r\n        uint256 result = 1;\r\n        for (uint256 i = 0; i < pow; i++){\r\n            uint256 previousResult = result;\r\n\r\n            // Using safemath multiplication prevents overflows\r\n            result = previousResult.mul(a);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n    * @dev Performs division where if there is a modulo, the value is rounded up\r\n    */\r\n    function divCeil(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return a.mod(b) > 0 ? a.div(b).add(1) : a.div(b);\r\n    }\r\n\r\n    /**\r\n     * Checks for rounding errors and returns value of potential partial amounts of a principal\r\n     *\r\n     * @param  _principal       Number fractional amount is derived from\r\n     * @param  _numerator       Numerator of fraction\r\n     * @param  _denominator     Denominator of fraction\r\n     * @return uint256          Fractional amount of principal calculated\r\n     */\r\n    function getPartialAmount(\r\n        uint256 _principal,\r\n        uint256 _numerator,\r\n        uint256 _denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // Get remainder of partial amount (if 0 not a partial amount)\r\n        uint256 remainder = mulmod(_principal, _numerator, _denominator);\r\n\r\n        // Return if not a partial amount\r\n        if (remainder == 0) {\r\n            return _principal.mul(_numerator).div(_denominator);\r\n        }\r\n\r\n        // Calculate error percentage\r\n        uint256 errPercentageTimes1000000 = remainder.mul(1000000).div(_numerator.mul(_principal));\r\n\r\n        // Require error percentage is less than 0.1%.\r\n        require(\r\n            errPercentageTimes1000000 < 1000,\r\n            \"CommonMath.getPartialAmount: Rounding error exceeds bounds\"\r\n        );\r\n\r\n        return _principal.mul(_numerator).div(_denominator);\r\n    }\r\n\r\n    /*\r\n     * Gets the rounded up log10 of passed value\r\n     *\r\n     * @param  _value         Value to calculate ceil(log()) on\r\n     * @return uint256        Output value\r\n     */\r\n    function ceilLog10(\r\n        uint256 _value\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // Make sure passed value is greater than 0\r\n        require (\r\n            _value > 0,\r\n            \"CommonMath.ceilLog10: Value must be greater than zero.\"\r\n        );\r\n\r\n        // Since log10(1) = 0, if _value = 1 return 0\r\n        if (_value == 1) return 0;\r\n\r\n        // Calcualte ceil(log10())\r\n        uint256 x = _value - 1;\r\n\r\n        uint256 result = 0;\r\n\r\n        if (x >= 10 ** 64) {\r\n            x /= 10 ** 64;\r\n            result += 64;\r\n        }\r\n        if (x >= 10 ** 32) {\r\n            x /= 10 ** 32;\r\n            result += 32;\r\n        }\r\n        if (x >= 10 ** 16) {\r\n            x /= 10 ** 16;\r\n            result += 16;\r\n        }\r\n        if (x >= 10 ** 8) {\r\n            x /= 10 ** 8;\r\n            result += 8;\r\n        }\r\n        if (x >= 10 ** 4) {\r\n            x /= 10 ** 4;\r\n            result += 4;\r\n        }\r\n        if (x >= 100) {\r\n            x /= 100;\r\n            result += 2;\r\n        }\r\n        if (x >= 10) {\r\n            result += 1;\r\n        }\r\n\r\n        return result + 1;\r\n    }\r\n}\r\n\r\n// File: contracts/core/tokens/rebalancing-v2/RebalancingSettlement.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title RebalancingSettlement\r\n * @author Set Protocol\r\n *\r\n */\r\ncontract RebalancingSettlement is\r\n    ERC20,\r\n    RebalancingSetState\r\n{\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public constant SCALE_FACTOR = 10 ** 18;\r\n\r\n    /* ============ Internal Functions ============ */\r\n\r\n    /*\r\n     * Validates that the settle function can be called.\r\n     */\r\n    function validateRebalancingSettlement()\r\n        internal\r\n        view\r\n    {\r\n        validateRebalanceStateIs(RebalancingLibrary.State.Rebalance);\r\n    }\r\n\r\n    /*\r\n     * Issue nextSet to RebalancingSetToken; The issued Set is held in the Vault\r\n     *\r\n     * @param  _issueQuantity   Quantity of next Set to issue\r\n     */\r\n    function issueNextSet(\r\n        uint256 _issueQuantity\r\n    )\r\n        internal\r\n    {\r\n        core.issueInVault(\r\n            address(nextSet),\r\n            _issueQuantity\r\n        );\r\n    }\r\n\r\n    /*\r\n     * Updates state post-settlement.\r\n     *\r\n     * @param  _nextUnitShares   The new implied unit shares\r\n     */\r\n    function transitionToDefault(\r\n        uint256 _newUnitShares\r\n    )\r\n        internal\r\n    {\r\n        rebalanceState = RebalancingLibrary.State.Default;\r\n        lastRebalanceTimestamp = block.timestamp;\r\n        currentSet = nextSet;\r\n        unitShares = _newUnitShares;\r\n        rebalanceIndex = rebalanceIndex.add(1);\r\n\r\n        nextSet = ISetToken(address(0));\r\n        hasBidded = false;\r\n    }\r\n\r\n    /**\r\n     * Calculate the amount of Sets to issue by using the component amounts in the\r\n     * vault.\r\n     */\r\n    function calculateSetIssueQuantity(\r\n        ISetToken _setToken\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // Collect data necessary to compute issueAmounts\r\n        SetTokenLibrary.SetDetails memory setToken = SetTokenLibrary.getSetDetails(address(_setToken));\r\n        uint256 maxIssueAmount = calculateMaxIssueAmount(setToken);\r\n\r\n        // Issue amount of Sets that is closest multiple of nextNaturalUnit to the maxIssueAmount\r\n        uint256 issueAmount = maxIssueAmount.sub(maxIssueAmount.mod(setToken.naturalUnit));\r\n\r\n        return issueAmount;\r\n    }\r\n\r\n    /**\r\n     * Calculates the fee and mints the rebalancing SetToken quantity to the recipient.\r\n     * The minting is done without an increase to the total collateral controlled by the\r\n     * rebalancing SetToken. In effect, the existing holders are paying the fee via inflation.\r\n     *\r\n     * @return feePercentage\r\n     * @return feeQuantity\r\n     */\r\n    function handleFees()\r\n        internal\r\n        returns (uint256, uint256)\r\n    {\r\n        // Represents a decimal value scaled by 1e18 (e.g. 100% = 1e18 and 1% = 1e16)\r\n        uint256 feePercent = rebalanceFeeCalculator.getFee();\r\n        uint256 feeQuantity = calculateRebalanceFeeInflation(feePercent);\r\n\r\n        if (feeQuantity > 0) {\r\n            ERC20._mint(feeRecipient, feeQuantity);\r\n        }\r\n\r\n        return (feePercent, feeQuantity);\r\n    }\r\n\r\n    /**\r\n     * Returns the new rebalance fee. The calculation for the fee involves implying\r\n     * mint quantity so that the feeRecipient owns the fee percentage of the entire\r\n     * supply of the Set.\r\n     *\r\n     * The formula to solve for fee is:\r\n     * feeQuantity / feeQuantity + totalSupply = fee / scaleFactor\r\n     *\r\n     * The simplified formula utilized below is:\r\n     * feeQuantity = fee * totalSupply / (scaleFactor - fee)\r\n     *\r\n     * @param   _rebalanceFeePercent    Fee levied to feeRecipient every rebalance, paid during settlement\r\n     * @return  uint256                 New RebalancingSet issue quantity\r\n     */\r\n    function calculateRebalanceFeeInflation(\r\n        uint256 _rebalanceFeePercent\r\n    )\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // fee * totalSupply\r\n        uint256 a = _rebalanceFeePercent.mul(totalSupply());\r\n\r\n        // ScaleFactor (10e18) - fee\r\n        uint256 b = SCALE_FACTOR.sub(_rebalanceFeePercent);\r\n\r\n        return a.div(b);\r\n    }\r\n\r\n    /**\r\n     * Calculates the new unitShares, defined as issueQuantity / naturalUnitsOutstanding\r\n     *\r\n     * @param  _issueQuantity   Amount of nextSets to issue\r\n     *\r\n     * @return  uint256             New unitShares for the rebalancingSetToken\r\n     */\r\n    function calculateNextSetNewUnitShares(\r\n        uint256 _issueQuantity\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // Calculate the amount of naturalUnits worth of rebalancingSetToken outstanding.\r\n        uint256 naturalUnitsOutstanding = totalSupply().div(naturalUnit);\r\n\r\n        // Divide final issueAmount by naturalUnitsOutstanding to get newUnitShares\r\n        return _issueQuantity.div(naturalUnitsOutstanding);\r\n    }\r\n\r\n    /* ============ Private Functions ============ */\r\n\r\n    /**\r\n     * Get the maximum possible issue amount of nextSet based on number of components owned by rebalancing\r\n     * set token.\r\n     *\r\n     * @param  _setToken    Struct of Set Token details\r\n     */\r\n    function calculateMaxIssueAmount(\r\n        SetTokenLibrary.SetDetails memory _setToken\r\n    )\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 maxIssueAmount = CommonMath.maxUInt256();\r\n\r\n        for (uint256 i = 0; i < _setToken.components.length; i++) {\r\n            // Get amount of components in vault owned by rebalancingSetToken\r\n            uint256 componentAmount = vault.getOwnerBalance(\r\n                _setToken.components[i],\r\n                address(this)\r\n            );\r\n\r\n            // Calculate amount of Sets that can be issued from those components, if less than amount for other\r\n            // components then set that as maxIssueAmount. We divide before multiplying so that we don't get\r\n            // an amount that isn't a multiple of the naturalUnit\r\n            uint256 componentIssueAmount = componentAmount.div(_setToken.units[i]).mul(_setToken.naturalUnit);\r\n            if (componentIssueAmount < maxIssueAmount) {\r\n                maxIssueAmount = componentIssueAmount;\r\n            }\r\n        }\r\n\r\n        return maxIssueAmount;\r\n    }\r\n}\r\n\r\n// File: contracts/core/tokens/rebalancing-v2/RebalancingFailure.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title RebalancingFailure\r\n * @author Set Protocol\r\n *\r\n */\r\ncontract RebalancingFailure is\r\n    RebalancingSetState,\r\n    RebalancingSettlement\r\n{\r\n    using SafeMath for uint256;\r\n    using AddressArrayUtils for address[];\r\n\r\n    /* ============ Internal Functions ============ */\r\n\r\n    /*\r\n     * Validations for failRebalance:\r\n     *  - State is Rebalance\r\n     *  - Either liquidator recognizes failure OR fail period breached on RB Set\r\n     *\r\n     * @param _quantity                 The amount of currentSet to be rebalanced\r\n     */\r\n    function validateFailRebalance()\r\n        internal\r\n        view\r\n    {\r\n        // Token must be in Rebalance State\r\n        validateRebalanceStateIs(RebalancingLibrary.State.Rebalance);\r\n\r\n        // Failure triggers must be met\r\n        require(\r\n            liquidatorBreached() || failPeriodBreached(),\r\n            \"Triggers not breached\"\r\n        );\r\n    }\r\n\r\n    /*\r\n     * Determine the new Rebalance State. If there has been a bid, then we put it to\r\n     * Drawdown, where the Set is effectively killed. If no bids, we reissue the currentSet.\r\n     */\r\n    function getNewRebalanceState()\r\n        internal\r\n        view\r\n        returns (RebalancingLibrary.State)\r\n    {\r\n        return hasBidded ? RebalancingLibrary.State.Drawdown : RebalancingLibrary.State.Default;\r\n    }\r\n\r\n    /*\r\n     * Update state based on new Rebalance State.\r\n     *\r\n     * @param  _newRebalanceState      The new State to transition to\r\n     */\r\n    function transitionToNewState(\r\n        RebalancingLibrary.State _newRebalanceState\r\n    )\r\n        internal\r\n    {\r\n        reissueSetIfRevertToDefault(_newRebalanceState);\r\n\r\n        setWithdrawComponentsIfDrawdown(_newRebalanceState);\r\n\r\n        rebalanceState = _newRebalanceState;\r\n        rebalanceIndex = rebalanceIndex.add(1);\r\n        lastRebalanceTimestamp = block.timestamp;\r\n\r\n        nextSet = ISetToken(address(0));\r\n        hasBidded = false;\r\n    }\r\n\r\n    /* ============ Private Functions ============ */\r\n\r\n    /*\r\n     * Returns whether the liquidator believes the rebalance has failed.\r\n     *\r\n     * @return        If liquidator thinks rebalance failed\r\n     */\r\n    function liquidatorBreached()\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return liquidator.hasRebalanceFailed(address(this));\r\n    }\r\n\r\n    /*\r\n     * Returns whether the the fail time has elapsed, which means that a period\r\n     * of time where the auction should have succeeded has not.\r\n     *\r\n     * @return        If fail period has passed on Rebalancing Set Token\r\n     */\r\n    function failPeriodBreached()\r\n        private\r\n        view\r\n        returns(bool)\r\n    {\r\n        uint256 rebalanceFailTime = rebalanceStartTime.add(rebalanceFailPeriod);\r\n\r\n        return block.timestamp >= rebalanceFailTime;\r\n    }\r\n\r\n    /*\r\n     * If the determination is Default State, reissue the Set.\r\n     */\r\n    function reissueSetIfRevertToDefault(\r\n        RebalancingLibrary.State _newRebalanceState\r\n    )\r\n        private\r\n    {\r\n        if (_newRebalanceState ==  RebalancingLibrary.State.Default) {\r\n            uint256 issueQuantity = calculateSetIssueQuantity(currentSet);\r\n\r\n            // If bid not placed, reissue current Set\r\n            core.issueInVault(\r\n                address(currentSet),\r\n                issueQuantity\r\n            );\r\n        }\r\n    }\r\n\r\n    /*\r\n     * If the determination is Drawdown State, set the drawdown components which is the union of\r\n     * the current and next Set components.\r\n     */\r\n    function setWithdrawComponentsIfDrawdown(\r\n        RebalancingLibrary.State _newRebalanceState\r\n    )\r\n        private\r\n    {\r\n        if (_newRebalanceState ==  RebalancingLibrary.State.Drawdown) {\r\n            address[] memory currentSetComponents = currentSet.getComponents();\r\n            address[] memory nextSetComponents = nextSet.getComponents();\r\n\r\n            failedRebalanceComponents = currentSetComponents.union(nextSetComponents);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/core/tokens/rebalancing-v2/Issuance.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Issuance\r\n * @author Set Protocol\r\n *\r\n * Default implementation of Rebalancing Set Token propose function\r\n */\r\ncontract Issuance is\r\n    ERC20,\r\n    RebalancingSetState\r\n{\r\n    using SafeMath for uint256;\r\n    using CommonMath for uint256;\r\n\r\n    /* ============ Internal Functions ============ */\r\n\r\n    /*\r\n     * Validate call to mint new Rebalancing Set Token\r\n     *\r\n     *  - Make sure caller is Core\r\n     *  - Make sure state is not Rebalance or Drawdown\r\n     */\r\n    function validateMint()\r\n        internal\r\n        view\r\n    {\r\n        validateCallerIsCore();\r\n\r\n        validateRebalanceStateIs(RebalancingLibrary.State.Default);\r\n    }\r\n\r\n    /*\r\n     * Validate call to burn Rebalancing Set Token\r\n     *\r\n     *  - Make sure state is not Rebalance or Drawdown\r\n     *  - Make sure sender is module when in drawdown, core otherwise\r\n     */\r\n    function validateBurn()\r\n        internal\r\n        view\r\n    {\r\n        validateRebalanceStateIsNot(RebalancingLibrary.State.Rebalance);\r\n\r\n        if (rebalanceState == RebalancingLibrary.State.Drawdown) {\r\n            // In Drawdown Sets can only be burned as part of the withdrawal process\r\n            validateCallerIsModule();\r\n        } else {\r\n            // When in non-Rebalance or Drawdown state, check that function caller is Core\r\n            // so that Sets can be redeemed\r\n            validateCallerIsCore();\r\n        }\r\n    }\r\n    /*\r\n     * Calculates entry fees and mints the feeRecipient a portion of the issue quantity.\r\n     *\r\n     * @param  _quantity              The number of rebalancing SetTokens the issuer mints\r\n     * @return issueQuantityNetOfFees Quantity of rebalancing SetToken to mint issuer net of fees\r\n     */\r\n    function handleEntryFees(\r\n        uint256 _quantity\r\n    )\r\n        internal\r\n        returns(uint256)\r\n    {\r\n        // The entryFee is a scaled decimal figure by 10e18. We multiply the fee by the quantity\r\n        // Then descale by 10e18\r\n        uint256 fee = _quantity.mul(entryFee).deScale();\r\n\r\n        if (fee > 0) {\r\n            ERC20._mint(feeRecipient, fee);\r\n\r\n            emit EntryFeePaid(feeRecipient, fee);\r\n        }\r\n\r\n        // Return the issue quantity less fees\r\n        return _quantity.sub(fee);\r\n    }\r\n}\r\n\r\n// File: contracts/core/tokens/rebalancing-v2/RebalancingBid.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title RebalancingBid\r\n * @author Set Protocol\r\n *\r\n * Implementation of Rebalancing Set Token V2 bidding-related functionality.\r\n */\r\ncontract RebalancingBid is\r\n    RebalancingSetState\r\n{\r\n    using SafeMath for uint256;\r\n\r\n    /* ============ Internal Functions ============ */\r\n\r\n    /*\r\n     * Validates conditions to retrieve a Bid Price:\r\n     *  - State is Rebalance\r\n     *  - Quanity is greater than zero\r\n     *\r\n     * @param _quantity                 The amount of currentSet to be rebalanced\r\n     */\r\n    function validateGetBidPrice(\r\n        uint256 _quantity\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        validateRebalanceStateIs(RebalancingLibrary.State.Rebalance);\r\n\r\n        require(\r\n            _quantity > 0,\r\n            \"Bid not > 0\"\r\n        );\r\n    }\r\n\r\n    /*\r\n     * Validations for placeBid:\r\n     *  - Module is sender\r\n     *  - getBidPrice validations\r\n     *\r\n     * @param _quantity                 The amount of currentSet to be rebalanced\r\n     */\r\n    function validatePlaceBid(\r\n        uint256 _quantity\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        validateCallerIsModule();\r\n\r\n        validateGetBidPrice(_quantity);\r\n    }\r\n\r\n    /*\r\n     * If a successful bid has been made, flip the hasBidded boolean.\r\n     */\r\n    function updateHasBiddedIfNecessary()\r\n        internal\r\n    {\r\n        if (!hasBidded) {\r\n            hasBidded = true;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/core/tokens/rebalancing-v2/RebalancingStart.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title RebalancingStart\r\n * @author Set Protocol\r\n *\r\n * Implementation of Rebalancing Set Token V2 start rebalance functionality\r\n */\r\ncontract RebalancingStart is\r\n    ERC20,\r\n    RebalancingSetState\r\n{\r\n    using SafeMath for uint256;\r\n\r\n    /* ============ Internal Functions ============ */\r\n\r\n    /**\r\n     * Validate that start rebalance can be called:\r\n     *  - Current state is Default\r\n     *  - rebalanceInterval has elapsed\r\n     *  - Proposed set is valid in Core\r\n     *  - Components in set are all valid\r\n     *  - NaturalUnits are multiples of each other\r\n     *\r\n     * @param _nextSet                    The Set to rebalance into\r\n     */\r\n    function validateStartRebalance(\r\n        ISetToken _nextSet\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        validateRebalanceStateIs(RebalancingLibrary.State.Default);\r\n\r\n        // Enough time must have passed from last rebalance to start a new proposal\r\n        require(\r\n            block.timestamp >= lastRebalanceTimestamp.add(rebalanceInterval),\r\n            \"Interval not elapsed\"\r\n        );\r\n\r\n        // Must be a positive supply of the Set\r\n        require(\r\n            totalSupply() > 0,\r\n            \"Invalid supply\"\r\n        );\r\n\r\n        // New proposed Set must be a valid Set created by Core\r\n        require(\r\n            core.validSets(address(_nextSet)),\r\n            \"Invalid Set\"\r\n        );\r\n\r\n        // Check proposed components on whitelist. This is to ensure managers are unable to add contract addresses\r\n        // to a propose that prohibit the set from carrying out an auction i.e. a token that only the manager possesses\r\n        require(\r\n            componentWhiteList.areValidAddresses(_nextSet.getComponents()),\r\n            \"Invalid component\"\r\n        );\r\n\r\n        // Check that the proposed set natural unit is a multiple of current set natural unit, or vice versa.\r\n        // Done to make sure that when calculating token units there will are be rounding errors.\r\n        require(\r\n            naturalUnitsAreValid(currentSet, _nextSet),\r\n            \"Invalid natural unit\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Calculates the maximum quantity of the currentSet that can be redeemed. This is defined\r\n     * by how many naturalUnits worth of the Set there are.\r\n     *\r\n     * @return   Maximum quantity of the current Set that can be redeemed\r\n     */\r\n    function calculateStartingSetQuantity()\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 currentSetBalance = vault.getOwnerBalance(address(currentSet), address(this));\r\n        uint256 currentSetNaturalUnit = currentSet.naturalUnit();\r\n\r\n        // Rounds the redemption quantity to a multiple of the current Set natural unit\r\n        return currentSetBalance.sub(currentSetBalance.mod(currentSetNaturalUnit));\r\n    }\r\n\r\n    /**\r\n     * Signals to the Liquidator to initiate the rebalance.\r\n     *\r\n     * @param _nextSet                         Next set instance\r\n     * @param _startingCurrentSetQuantity      Amount of currentSets the rebalance is initiated with\r\n     * @param _liquidatorData                  Bytecode formatted data with liquidator-specific arguments\r\n     */\r\n    function liquidatorRebalancingStart(\r\n        ISetToken _nextSet,\r\n        uint256 _startingCurrentSetQuantity,\r\n        bytes memory _liquidatorData\r\n    )\r\n        internal\r\n    {\r\n        liquidator.startRebalance(\r\n            currentSet,\r\n            _nextSet,\r\n            _startingCurrentSetQuantity,\r\n            _liquidatorData\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Updates rebalance-related state parameters.\r\n     *\r\n     * @param _nextSet                    The Set to rebalance into\r\n     */\r\n    function transitionToRebalance(ISetToken _nextSet) internal {\r\n        nextSet = _nextSet;\r\n        rebalanceState = RebalancingLibrary.State.Rebalance;\r\n        rebalanceStartTime = block.timestamp;\r\n    }\r\n\r\n    /* ============ Private Functions ============ */\r\n\r\n    /**\r\n     * Check that the proposed set natural unit is a multiple of current set natural unit, or vice versa.\r\n     * Done to make sure that when calculating token units there will be no rounding errors.\r\n     *\r\n     * @param _currentSet                 The current base SetToken\r\n     * @param _nextSet                    The proposed SetToken\r\n     */\r\n    function naturalUnitsAreValid(\r\n        ISetToken _currentSet,\r\n        ISetToken _nextSet\r\n    )\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint256 currentNaturalUnit = _currentSet.naturalUnit();\r\n        uint256 nextSetNaturalUnit = _nextSet.naturalUnit();\r\n\r\n        return Math.max(currentNaturalUnit, nextSetNaturalUnit).mod(\r\n            Math.min(currentNaturalUnit, nextSetNaturalUnit)\r\n        ) == 0;\r\n    }\r\n}\r\n\r\n// File: contracts/core/tokens/RebalancingSetTokenV2.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title RebalancingSetTokenV2\r\n * @author Set Protocol\r\n *\r\n * Implementation of Rebalancing Set token V2. Major improvements vs. V1 include:\r\n * - Decouple the Rebalancing Set state and rebalance state from the rebalance execution (e.g. auction)\r\n *   This allows us to rapidly iterate and build new liquidation mechanisms for rebalances.\r\n * - Proposals are removed in favor of starting an auction directly.\r\n * - The Set retains ability to fail an auction if the minimum fail time has elapsed.\r\n * - RebalanceAuctionModule execution should be backwards compatible with V1.\r\n * - Bidding and auction parameters state no longer live on this contract. They live on the liquidator\r\n *   BackwardsComptability is used to allow retrieving of previous supported states.\r\n * - Introduces entry and rebalance fees, where rebalance fees are configurable based on an external\r\n *   fee calculator contract\r\n */\r\ncontract RebalancingSetTokenV2 is\r\n    ERC20,\r\n    ERC20Detailed,\r\n    Initializable,\r\n    RebalancingSetState,\r\n    BackwardCompatibility,\r\n    Issuance,\r\n    RebalancingStart,\r\n    RebalancingBid,\r\n    RebalancingSettlement,\r\n    RebalancingFailure\r\n{\r\n\r\n    /* ============ Constructor ============ */\r\n\r\n    /**\r\n     * Constructor function for Rebalancing Set Token\r\n     *\r\n     * addressConfig [factory, manager, liquidator, initialSet, componentWhiteList,\r\n     *                liquidatorWhiteList, feeRecipient, rebalanceFeeCalculator]\r\n     * [0]factory                   Factory used to create the Rebalancing Set\r\n     * [1]manager                   Address that is able to propose the next Set\r\n     * [2]liquidator                Address of the liquidator contract\r\n     * [3]initialSet                Initial set that collateralizes the Rebalancing set\r\n     * [4]componentWhiteList        Whitelist that nextSet components are checked against during propose\r\n     * [5]liquidatorWhiteList       Whitelist of valid liquidators\r\n     * [6]feeRecipient              Address that receives any incentive fees\r\n     * [7]rebalanceFeeCalculator    Address to retrieve rebalance fee during settlement\r\n     *\r\n     * uintConfig [initialUnitShares, naturalUnit, rebalanceInterval, rebalanceFailPeriod,\r\n     *             lastRebalanceTimestamp, entryFee]\r\n     * [0]initialUnitShares         Units of currentSet that equals one share\r\n     * [1]naturalUnit               The minimum multiple of Sets that can be issued or redeemed\r\n     * [2]rebalanceInterval:        Minimum amount of time between rebalances\r\n     * [3]rebalanceFailPeriod:      Time after auctionStart where something in the rebalance has gone wrong\r\n     * [4]lastRebalanceTimestamp:   Time of the last rebalance; Allows customized deployments\r\n     * [5]entryFee:                 Mint fee represented in a scaled decimal value (e.g. 100% = 1e18, 1% = 1e16)\r\n     *\r\n     * @param _addressConfig             List of configuration addresses\r\n     * @param _uintConfig                List of uint addresses\r\n     * @param _name                      The name of the new RebalancingSetTokenV2\r\n     * @param _symbol                    The symbol of the new RebalancingSetTokenV2\r\n     */\r\n    constructor(\r\n        address[8] memory _addressConfig,\r\n        uint256[6] memory _uintConfig,\r\n        string memory _name,\r\n        string memory _symbol\r\n    )\r\n        public\r\n        ERC20Detailed(\r\n            _name,\r\n            _symbol,\r\n            18\r\n        )\r\n    {\r\n        factory = IRebalancingSetFactory(_addressConfig[0]);\r\n        manager = _addressConfig[1];\r\n        liquidator = ILiquidator(_addressConfig[2]);\r\n        currentSet = ISetToken(_addressConfig[3]);\r\n        componentWhiteList = IWhiteList(_addressConfig[4]);\r\n        liquidatorWhiteList = IWhiteList(_addressConfig[5]);\r\n        feeRecipient = _addressConfig[6];\r\n        rebalanceFeeCalculator = IFeeCalculator(_addressConfig[7]);\r\n\r\n        unitShares = _uintConfig[0];\r\n        naturalUnit = _uintConfig[1];\r\n        rebalanceInterval = _uintConfig[2];\r\n        rebalanceFailPeriod = _uintConfig[3];\r\n        lastRebalanceTimestamp = _uintConfig[4];\r\n        entryFee = _uintConfig[5];\r\n\r\n        core = ICore(factory.core());\r\n        vault = IVault(core.vault());\r\n        rebalanceState = RebalancingLibrary.State.Default;\r\n    }\r\n\r\n    /*\r\n     * Intended to be called during creation by the RebalancingSetTokenFactory. Can only be initialized\r\n     * once. This implementation initializes the rebalance fee.\r\n     *\r\n     *\r\n     * @param _rebalanceFeeCalldata       Bytes encoded rebalance fee represented as a scaled percentage value\r\n     */\r\n    function initialize(\r\n        bytes calldata _rebalanceFeeCalldata\r\n    )\r\n        external\r\n        initializer\r\n    {\r\n        rebalanceFeeCalculator.initialize(_rebalanceFeeCalldata);\r\n    }\r\n\r\n   /* ============ External Functions ============ */\r\n\r\n    /*\r\n     * Initiates the rebalance in coordination with the Liquidator contract.\r\n     * In this step, we redeem the currentSet and pass relevant information\r\n     * to the liquidator.\r\n     *\r\n     * @param _nextSet                      The Set to rebalance into\r\n     * @param _liquidatorData               Bytecode formatted data with liquidator-specific arguments\r\n     *\r\n     * Can only be called if the rebalance interval has elapsed.\r\n     * Can only be called by manager.\r\n     */\r\n    function startRebalance(\r\n        ISetToken _nextSet,\r\n        bytes calldata _liquidatorData\r\n    )\r\n        external\r\n        onlyManager\r\n    {\r\n        RebalancingStart.validateStartRebalance(_nextSet);\r\n\r\n        uint256 startingCurrentSetQuantity = RebalancingStart.calculateStartingSetQuantity();\r\n\r\n        core.redeemInVault(address(currentSet), startingCurrentSetQuantity);\r\n\r\n        RebalancingStart.liquidatorRebalancingStart(_nextSet, startingCurrentSetQuantity, _liquidatorData);\r\n\r\n        RebalancingStart.transitionToRebalance(_nextSet);\r\n\r\n        emit RebalanceStarted(\r\n            address(currentSet),\r\n            address(nextSet),\r\n            rebalanceIndex,\r\n            startingCurrentSetQuantity\r\n        );\r\n    }\r\n\r\n    /*\r\n     * Get token inflows and outflows required for bid from the Liquidator.\r\n     *\r\n     * @param _quantity               The amount of currentSet to be rebalanced\r\n     * @return inflowUnitArray          Array of amount of tokens inserted into system in bid\r\n     * @return outflowUnitArray         Array of amount of tokens taken out of system in bid\r\n     */\r\n    function getBidPrice(\r\n        uint256 _quantity\r\n    )\r\n        public\r\n        view\r\n        returns (uint256[] memory, uint256[] memory)\r\n    {\r\n        RebalancingBid.validateGetBidPrice(_quantity);\r\n\r\n        return Rebalance.decomposeTokenFlowToBidPrice(\r\n            liquidator.getBidPrice(address(this), _quantity)\r\n        );\r\n    }\r\n\r\n    /*\r\n     * Place bid during rebalance auction.\r\n     *\r\n     * The intended caller is the RebalanceAuctionModule, which must be approved by Core.\r\n     * Call Flow:\r\n     * RebalanceAuctionModule -> RebalancingSetTokenV2 -> Liquidator\r\n     *\r\n     * @param _quantity                 The amount of currentSet to be rebalanced\r\n     * @return combinedTokenArray       Array of token addresses invovled in rebalancing\r\n     * @return inflowUnitArray          Array of amount of tokens inserted into system in bid\r\n     * @return outflowUnitArray         Array of amount of tokens taken out of system in bid\r\n     */\r\n    function placeBid(\r\n        uint256 _quantity\r\n    )\r\n        external\r\n        returns (address[] memory, uint256[] memory, uint256[] memory)\r\n    {\r\n        RebalancingBid.validatePlaceBid(_quantity);\r\n\r\n        // Place bid and get back inflow and outflow arrays\r\n        Rebalance.TokenFlow memory tokenFlow = liquidator.placeBid(_quantity);\r\n\r\n        RebalancingBid.updateHasBiddedIfNecessary();\r\n\r\n        return Rebalance.decomposeTokenFlow(tokenFlow);\r\n    }\r\n\r\n    /*\r\n     * After a successful rebalance, the new Set is issued. If there is a rebalance fee,\r\n     * the fee is paid via inflation of the Rebalancing Set to the feeRecipient.\r\n     * Full issuance functionality is now returned to set owners.\r\n     *\r\n     * Anyone can call this function.\r\n     */\r\n    function settleRebalance()\r\n        external\r\n    {\r\n        RebalancingSettlement.validateRebalancingSettlement();\r\n\r\n        uint256 issueQuantity = RebalancingSettlement.calculateSetIssueQuantity(nextSet);\r\n\r\n        // Calculates fees and mints Rebalancing Set to the feeRecipient, increasing supply\r\n        (uint256 feePercent, uint256 feeQuantity) = RebalancingSettlement.handleFees();\r\n\r\n        uint256 newUnitShares = RebalancingSettlement.calculateNextSetNewUnitShares(issueQuantity);\r\n\r\n        // The unit shares must result in a quantity greater than the number of natural units outstanding\r\n        require(\r\n            newUnitShares > 0,\r\n            \"Failed: unitshares is 0.\"\r\n        );\r\n\r\n        RebalancingSettlement.issueNextSet(issueQuantity);\r\n\r\n        liquidator.settleRebalance();\r\n\r\n        // Rebalance index is the current vs next rebalance\r\n        emit RebalanceSettled(\r\n            feeRecipient,\r\n            feeQuantity,\r\n            feePercent,\r\n            rebalanceIndex,\r\n            issueQuantity,\r\n            newUnitShares\r\n        );\r\n\r\n        RebalancingSettlement.transitionToDefault(newUnitShares);\r\n\r\n    }\r\n\r\n    /*\r\n     * Ends a rebalance if there are any signs that there is a failure.\r\n     * Possible failure reasons:\r\n     * 1. The rebalance has elapsed the failRebalancePeriod\r\n     * 2. The liquidator responds that the rebalance has failed\r\n     *\r\n     * Move to Drawdown state if bids have been placed. Reset to Default state if no bids placed.\r\n     */\r\n    function endFailedRebalance()\r\n        public\r\n    {\r\n        RebalancingFailure.validateFailRebalance();\r\n\r\n        RebalancingLibrary.State newRebalanceState = RebalancingFailure.getNewRebalanceState();\r\n\r\n        liquidator.endFailedRebalance();\r\n\r\n        RebalancingFailure.transitionToNewState(newRebalanceState);\r\n    }\r\n\r\n    /*\r\n     * Mint set token for given address. If there if is an entryFee, calculates the fee and mints\r\n     * the rebalancing SetToken to the feeRecipient.\r\n     *\r\n     * Can only be called by Core contract.\r\n     *\r\n     * @param  _issuer      The address of the issuing account\r\n     * @param  _quantity    The number of sets to attribute to issuer\r\n     */\r\n    function mint(\r\n        address _issuer,\r\n        uint256 _quantity\r\n    )\r\n        external\r\n    {\r\n        Issuance.validateMint();\r\n\r\n        uint256 issueQuantityNetOfFees = Issuance.handleEntryFees(_quantity);\r\n\r\n        ERC20._mint(_issuer, issueQuantityNetOfFees);\r\n    }\r\n\r\n    /*\r\n     * Burn set token for given address. Can only be called by authorized contracts.\r\n     *\r\n     * @param  _from        The address of the redeeming account\r\n     * @param  _quantity    The number of sets to burn from redeemer\r\n     */\r\n    function burn(\r\n        address _from,\r\n        uint256 _quantity\r\n    )\r\n        external\r\n    {\r\n        Issuance.validateBurn();\r\n\r\n        ERC20._burn(_from, _quantity);\r\n    }\r\n\r\n    /* ============ Backwards Compatability ============ */\r\n\r\n    /*\r\n     * Alias for endFailedRebalance\r\n     */\r\n    function endFailedAuction() external {\r\n        endFailedRebalance();\r\n    }\r\n}\r\n\r\n// File: contracts/core/tokens/RebalancingSetTokenV2Factory.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title RebalancingSetTokenV2Factory\r\n * @author Set Protocol\r\n *\r\n * RebalancingSetTokenV2Factory is a smart contract used to deploy new RebalancingSetTokenV2 contracts.\r\n * RebalancingSetTokenV2s deployed by the factory can only have their mint and burn functions\r\n * called by Core\r\n */\r\ncontract RebalancingSetTokenV2Factory {\r\n    using LibBytes for bytes;\r\n    using Bytes32Library for bytes32;\r\n\r\n    /* ============ State Variables ============ */\r\n\r\n    // Address of the Core contract used to verify factory when creating a Set\r\n    ICore public core;\r\n\r\n    // Address of the WhiteList contract used to verify the tokens in a rebalance proposal\r\n    IWhiteList public rebalanceComponentWhitelist;\r\n\r\n    // Whitelist contract for approved liquidators\r\n    IWhiteList public liquidatorWhitelist;\r\n\r\n    // Whitelist contract for approved fee calcualtors\r\n    IWhiteList public feeCalculatorWhitelist;\r\n\r\n    // Minimum amount of time between rebalances in seconds\r\n    uint256 public minimumRebalanceInterval;\r\n\r\n    // Minimum fail auction period\r\n    uint256 public minimumFailRebalancePeriod;\r\n\r\n    // Maximum fail auction period\r\n    uint256 public maximumFailRebalancePeriod;\r\n\r\n    // Minimum number for the token natural unit\r\n    // The bounds are used for calculations of unitShares and in settlement\r\n    uint256 public minimumNaturalUnit;\r\n\r\n    // Maximum number for the token natural unit\r\n    uint256 public maximumNaturalUnit;\r\n\r\n    // ============ Structs ============\r\n\r\n    struct InitRebalancingParameters {\r\n        address manager;\r\n        ILiquidator liquidator;\r\n        address feeRecipient;\r\n        address rebalanceFeeCalculator;\r\n        uint256 rebalanceInterval;\r\n        uint256 rebalanceFailPeriod;\r\n        uint256 lastRebalanceTimestamp;\r\n        uint256 entryFee;\r\n        bytes rebalanceFeeCalculatorData;\r\n    }\r\n\r\n    /* ============ Constructor ============ */\r\n\r\n    /**\r\n     * Set core. Also requires a minimum rebalance interval and minimum proposal periods that are enforced\r\n     * on RebalancingSetTokenV2\r\n     *\r\n     * @param  _core                       Address of deployed core contract\r\n     * @param  _componentWhitelist         Address of component whitelist contract\r\n     * @param  _liquidatorWhitelist        Address of liquidator whitelist contract\r\n     * @param  _feeCalculatorWhitelist     Address of feeCalculator whitelist contract\r\n     * @param  _minimumRebalanceInterval   Minimum amount of time between rebalances in seconds\r\n     * @param  _minimumNaturalUnit         Minimum number for the token natural unit\r\n     * @param  _maximumNaturalUnit         Maximum number for the token natural unit\r\n     */\r\n    constructor(\r\n        ICore _core,\r\n        IWhiteList _componentWhitelist,\r\n        IWhiteList _liquidatorWhitelist,\r\n        IWhiteList _feeCalculatorWhitelist,\r\n        uint256 _minimumRebalanceInterval,\r\n        uint256 _minimumFailRebalancePeriod,\r\n        uint256 _maximumFailRebalancePeriod,\r\n        uint256 _minimumNaturalUnit,\r\n        uint256 _maximumNaturalUnit\r\n    )\r\n        public\r\n    {\r\n        core = _core;\r\n        rebalanceComponentWhitelist = _componentWhitelist;\r\n        liquidatorWhitelist = _liquidatorWhitelist;\r\n        feeCalculatorWhitelist = _feeCalculatorWhitelist;\r\n        minimumRebalanceInterval = _minimumRebalanceInterval;\r\n        minimumFailRebalancePeriod = _minimumFailRebalancePeriod;\r\n        maximumFailRebalancePeriod = _maximumFailRebalancePeriod;\r\n        minimumNaturalUnit = _minimumNaturalUnit;\r\n        maximumNaturalUnit = _maximumNaturalUnit;\r\n    }\r\n\r\n    /* ============ External Functions ============ */\r\n\r\n    /**\r\n     * Deploys a new RebalancingSetTokenV2 contract, conforming to IFactory\r\n     * Can only be called by core contracts.\r\n     *\r\n     *\r\n     * | CallData                   | Location                      |\r\n     * |----------------------------|-------------------------------|\r\n     * | manager                    | 32                            |\r\n     * | liquidator                 | 64                            |\r\n     * | feeRecipient               | 96                            |\r\n     * | rebalanceFeeCalculator     | 128                           |\r\n     * | rebalanceInterval          | 160                           |\r\n     * | rebalanceFailPeriod        | 192                           |\r\n     * | entryFee                   | 224                           |\r\n     * | rebalanceFeeCalculatorData | 256 to end                    |\r\n     *\r\n     * @param  _components     The address of component tokens\r\n     * @param  _units          The units of each component token\r\n     * -- Unused natural unit parameters, passed in to conform to IFactory --\r\n     * @param  _name           The bytes32 encoded name of the new RebalancingSetTokenV2\r\n     * @param  _symbol         The bytes32 encoded symbol of the new RebalancingSetTokenV2\r\n     * @param  _callData       Byte string containing additional call parameters\r\n     *\r\n     * @return setToken        The address of the newly created SetToken\r\n     */\r\n    function createSet(\r\n        address[] calldata _components,\r\n        uint256[] calldata _units,\r\n        uint256 _naturalUnit,\r\n        bytes32 _name,\r\n        bytes32 _symbol,\r\n        bytes calldata _callData\r\n    )\r\n        external\r\n        returns (address)\r\n    {\r\n        require(\r\n            msg.sender == address(core),\r\n            \"Sender must be core\"\r\n        );\r\n\r\n        // Ensure component array only includes one address which will be the currentSet\r\n        require(\r\n            _components.length == 1 &&\r\n            _units.length == 1,\r\n            \"Components & units must be len 1\"\r\n        );\r\n\r\n        require(\r\n            _units[0] > 0,\r\n            \"UnitShares not > 0\"\r\n        );\r\n\r\n        address startingSet = _components[0];\r\n\r\n        // Expect Set to rebalance to be valid and enabled Set\r\n        require(\r\n            core.validSets(startingSet),\r\n            \"Invalid SetToken\"\r\n        );\r\n\r\n        require(\r\n            _naturalUnit >= minimumNaturalUnit && _naturalUnit <= maximumNaturalUnit,\r\n            \"Invalid natural unit\"\r\n        );\r\n\r\n        InitRebalancingParameters memory parameters = parseRebalanceSetCallData(_callData);\r\n\r\n        require(\r\n            parameters.manager != address(0),\r\n            \"Invalid manager\"\r\n        );\r\n\r\n        // Require liquidator address is non-zero and is whitelisted by the liquidatorWhitelist\r\n        require(\r\n            address(parameters.liquidator) != address(0) &&\r\n            liquidatorWhitelist.whiteList(address(parameters.liquidator)),\r\n            \"Invalid liquidator\"\r\n        );\r\n\r\n        // Require rebalance fee is whitelisted by the liquidatorWhitelist\r\n        require(\r\n            feeCalculatorWhitelist.whiteList(address(parameters.rebalanceFeeCalculator)),\r\n            \"Invalid fee calculator\"\r\n        );\r\n\r\n        require(\r\n            parameters.rebalanceInterval >= minimumRebalanceInterval,\r\n            \"Rebalance interval too short\"\r\n        );\r\n\r\n        require(\r\n            parameters.rebalanceFailPeriod >= minimumFailRebalancePeriod &&\r\n            parameters.rebalanceFailPeriod <= maximumFailRebalancePeriod,\r\n            \"Invalid Fail Period\"\r\n        );\r\n\r\n        require(\r\n            parameters.lastRebalanceTimestamp <= block.timestamp,\r\n            \"Invalid RebalanceTimestamp\"\r\n        );\r\n\r\n        address rebalancingSet = address(\r\n            new RebalancingSetTokenV2(\r\n                [\r\n                    address(this),                          // factory\r\n                    parameters.manager,                     // manager\r\n                    address(parameters.liquidator),         // liquidator\r\n                    startingSet,                            // initialSet\r\n                    address(rebalanceComponentWhitelist),   // componentWhiteList\r\n                    address(liquidatorWhitelist),           // liquidatorWhiteList\r\n                    parameters.feeRecipient,                // feeRecipient\r\n                    parameters.rebalanceFeeCalculator       // rebalanceFeeCalculator\r\n                ],\r\n                [\r\n                    _units[0],                              // unitShares\r\n                    _naturalUnit,                           // naturalUnit\r\n                    parameters.rebalanceInterval,           // rebalanceInterval\r\n                    parameters.rebalanceFailPeriod,         // rebalanceFailPeriod\r\n                    parameters.lastRebalanceTimestamp,      // lastRebalanceTimestamp\r\n                    parameters.entryFee                     // entryFee\r\n                ],\r\n                _name.bytes32ToString(),\r\n                _symbol.bytes32ToString()\r\n            )\r\n        );\r\n\r\n        // Initializes the RebalancingSetToken\r\n        IRebalancingSetTokenV2(rebalancingSet).initialize(parameters.rebalanceFeeCalculatorData);\r\n\r\n        return rebalancingSet;\r\n    }\r\n\r\n    /* ============ Private Functions ============ */\r\n\r\n    function parseRebalanceSetCallData(\r\n        bytes memory _callData\r\n    )\r\n        private\r\n        pure\r\n        returns (InitRebalancingParameters memory)\r\n    {\r\n        InitRebalancingParameters memory parameters;\r\n\r\n        assembly {\r\n            mstore(parameters,           mload(add(_callData, 32)))   // manager\r\n            mstore(add(parameters, 32),  mload(add(_callData, 64)))   // liquidator\r\n            mstore(add(parameters, 64),  mload(add(_callData, 96)))   // feeRecipient\r\n            mstore(add(parameters, 96),  mload(add(_callData, 128)))  // rebalanceFeeCalculator\r\n            mstore(add(parameters, 128), mload(add(_callData, 160)))  // rebalanceInterval\r\n            mstore(add(parameters, 160), mload(add(_callData, 192)))  // rebalanceFailPeriod\r\n            mstore(add(parameters, 192), mload(add(_callData, 224)))  // lastRebalanceTimestamp\r\n            mstore(add(parameters, 224), mload(add(_callData, 256)))  // entryFee\r\n        }\r\n\r\n        // Extracts the fee calculator data from the remaining calldata\r\n        parameters.rebalanceFeeCalculatorData = _callData.slice(256, _callData.length);\r\n\r\n        return parameters;\r\n    }\r\n}\r\n\r\n// File: contracts/core/tokens/rebalancing-v3/IncentiveFee.sol\r\n\r\n/*\r\n    Copyright 2020 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title IncentiveFee\r\n * @author Set Protocol\r\n */\r\ncontract IncentiveFee is\r\n    ERC20,\r\n    RebalancingSetState\r\n{\r\n    using SafeMath for uint256;\r\n    using CommonMath for uint256;\r\n\r\n    /* ============ Events ============ */\r\n\r\n    event IncentiveFeePaid(\r\n        address indexed feeRecipient,\r\n        uint256 feeQuantity,\r\n        uint256 feePercentage,\r\n        uint256 newUnitShares\r\n    );\r\n\r\n    /* ============ Internal Functions ============ */\r\n\r\n    /**\r\n     * Calculates the fee and mints the rebalancing SetToken quantity to the recipient.\r\n     * The minting is done without an increase to the total collateral controlled by the\r\n     * rebalancing SetToken. In effect, the existing holders are paying the fee via inflation.\r\n     *\r\n     * @return feePercentage\r\n     * @return feeQuantity\r\n     */\r\n    function handleFees()\r\n        internal\r\n        returns (uint256, uint256)\r\n    {\r\n        // Represents a decimal value scaled by 1e18 (e.g. 100% = 1e18 and 1% = 1e16)\r\n        uint256 feePercent = rebalanceFeeCalculator.updateAndGetFee();\r\n        uint256 feeQuantity = calculateIncentiveFeeInflation(feePercent);\r\n\r\n        if (feeQuantity > 0) {\r\n            ERC20._mint(feeRecipient, feeQuantity);\r\n        }\r\n\r\n        return (feePercent, feeQuantity);\r\n    }\r\n\r\n    /**\r\n     * Returns the new incentive fee. The calculation for the fee involves implying\r\n     * mint quantity so that the feeRecipient owns the fee percentage of the entire\r\n     * supply of the Set.\r\n     *\r\n     * The formula to solve for fee is:\r\n     * feeQuantity / feeQuantity + totalSupply = fee / scaleFactor\r\n     *\r\n     * The simplified formula utilized below is:\r\n     * feeQuantity = fee * totalSupply / (scaleFactor - fee)\r\n     *\r\n     * @param   _feePercentage          Fee levied to feeRecipient\r\n     * @return  uint256                 New RebalancingSet issue quantity\r\n     */\r\n    function calculateIncentiveFeeInflation(\r\n        uint256 _feePercentage\r\n    )\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // fee * totalSupply\r\n        uint256 a = _feePercentage.mul(totalSupply());\r\n\r\n        // ScaleFactor (10e18) - fee\r\n        uint256 b = CommonMath.scaleFactor().sub(_feePercentage);\r\n\r\n        return a.div(b);\r\n    }\r\n\r\n    /*\r\n     * The Rebalancing SetToken must be in Default state.\r\n     */\r\n    function validateFeeActualization() internal view {\r\n        validateRebalanceStateIs(RebalancingLibrary.State.Default);\r\n    }\r\n\r\n    /*\r\n     * After the minting of new inflation fees, the unit shares must be updated.\r\n     * The formula is as follows:\r\n     * newUnitShares = currentSetAmount * rebalanceSetNaturalUnit / rebalanceSetTotalSupply\r\n     */\r\n    function calculateNewUnitShares() internal view returns(uint256) {\r\n        uint256 currentSetAmount = vault.getOwnerBalance(\r\n            address(currentSet),\r\n            address(this)\r\n        );\r\n\r\n        return currentSetAmount.mul(naturalUnit).divCeil(totalSupply());\r\n    }\r\n}\r\n\r\n// File: contracts/core/tokens/RebalancingSetTokenV3.sol\r\n\r\n/*\r\n    Copyright 2020 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title RebalancingSetTokenV3\r\n * @author Set Protocol\r\n *\r\n * Implementation of Rebalancing Set token V2. Major improvements vs. V2 include:\r\n * - Separating incentive fees from the settlement process.\r\n */\r\ncontract RebalancingSetTokenV3 is\r\n    IncentiveFee,\r\n    RebalancingSetTokenV2\r\n{\r\n    /* ============ Constructor ============ */\r\n\r\n    /**\r\n     * Constructor function for Rebalancing Set Token\r\n     *\r\n     * addressConfig [factory, manager, liquidator, initialSet, componentWhiteList,\r\n     *                liquidatorWhiteList, feeRecipient, rebalanceFeeCalculator]\r\n     * [0]factory                   Factory used to create the Rebalancing Set\r\n     * [1]manager                   Address that is able to propose the next Set\r\n     * [2]liquidator                Address of the liquidator contract\r\n     * [3]initialSet                Initial set that collateralizes the Rebalancing set\r\n     * [4]componentWhiteList        Whitelist that nextSet components are checked against during propose\r\n     * [5]liquidatorWhiteList       Whitelist of valid liquidators\r\n     * [6]feeRecipient              Address that receives any incentive fees\r\n     * [7]rebalanceFeeCalculator    Address to retrieve rebalance fee during settlement\r\n     *\r\n     * uintConfig [initialUnitShares, naturalUnit, rebalanceInterval, rebalanceFailPeriod,\r\n     *             lastRebalanceTimestamp, entryFee]\r\n     * [0]initialUnitShares         Units of currentSet that equals one share\r\n     * [1]naturalUnit               The minimum multiple of Sets that can be issued or redeemed\r\n     * [2]rebalanceInterval:        Minimum amount of time between rebalances\r\n     * [3]rebalanceFailPeriod:      Time after auctionStart where something in the rebalance has gone wrong\r\n     * [4]lastRebalanceTimestamp:   Time of the last rebalance; Allows customized deployments\r\n     * [5]entryFee:                 Mint fee represented in a scaled decimal value (e.g. 100% = 1e18, 1% = 1e16)\r\n     *\r\n     * @param _addressConfig             List of configuration addresses\r\n     * @param _uintConfig                List of uint addresses\r\n     * @param _name                      The name of the new RebalancingSetTokenV2\r\n     * @param _symbol                    The symbol of the new RebalancingSetTokenV2\r\n     */\r\n    constructor(\r\n        address[8] memory _addressConfig,\r\n        uint256[6] memory _uintConfig,\r\n        string memory _name,\r\n        string memory _symbol\r\n    )\r\n        public\r\n        RebalancingSetTokenV2(\r\n            _addressConfig,\r\n            _uintConfig,\r\n            _name,\r\n            _symbol\r\n        )\r\n    {}\r\n\r\n    /*\r\n     * Overrides the RebalancingSetTokenV2 settleRebalance function.\r\n     *\r\n     * After a successful rebalance, the new Set is issued.\r\n     * Full issuance functionality is now returned to set owners. No fees are captured.\r\n     *\r\n     * Anyone can call this function.\r\n     */\r\n    function settleRebalance()\r\n        external\r\n    {\r\n        // It can only be callable in the Default state\r\n        RebalancingSettlement.validateRebalancingSettlement();\r\n\r\n        uint256 issueQuantity = RebalancingSettlement.calculateSetIssueQuantity(nextSet);\r\n        uint256 newUnitShares = RebalancingSettlement.calculateNextSetNewUnitShares(issueQuantity);\r\n\r\n        validateUnitShares(newUnitShares);\r\n\r\n        RebalancingSettlement.issueNextSet(issueQuantity);\r\n\r\n        liquidator.settleRebalance();\r\n\r\n        emit RebalanceSettled(\r\n            address(0),      // No longer used\r\n            0,               // No longer used\r\n            0,               // No longer used\r\n            rebalanceIndex,  // Current Rebalance index\r\n            issueQuantity,\r\n            newUnitShares\r\n        );\r\n\r\n        RebalancingSettlement.transitionToDefault(newUnitShares);\r\n    }\r\n\r\n    /*\r\n     * During the Default stage, the incentive / rebalance Fee can be triggered. This will\r\n     * retrieve the current inflation fee from the fee calulator and mint the according\r\n     * inflation to the feeRecipient. The unit shares is then adjusted based on the new\r\n     * supply.\r\n     *\r\n     * Anyone can call this function.\r\n     */\r\n    function actualizeFee()\r\n        public\r\n    {\r\n        IncentiveFee.validateFeeActualization();\r\n\r\n        // Calculates fees and mints Rebalancing Set to the feeRecipient, increasing supply\r\n        (uint256 feePercent, uint256 feeQuantity) = IncentiveFee.handleFees();\r\n\r\n        // The minting of new supply changes the unit Shares\r\n        uint256 newUnitShares = IncentiveFee.calculateNewUnitShares();\r\n\r\n        validateUnitShares(newUnitShares);\r\n\r\n        // Set the new unit shares\r\n        unitShares = newUnitShares;\r\n\r\n        // Emit IncentiveFeePaid event\r\n        emit IncentiveFeePaid(\r\n            feeRecipient,\r\n            feeQuantity,\r\n            feePercent,\r\n            newUnitShares\r\n        );\r\n    }\r\n\r\n    /*\r\n     * Accrue any fees then adjust fee parameters on feeCalculator. Only callable by manager.\r\n     *\r\n     * @param  _newFeeData       Fee type and new streaming fee encoded in bytes\r\n     */\r\n    function adjustFee(\r\n        bytes calldata _newFeeData\r\n    )\r\n        external\r\n        onlyManager\r\n    {\r\n        actualizeFee();\r\n\r\n        rebalanceFeeCalculator.adjustFee(_newFeeData);\r\n    }\r\n\r\n    /* ============ V3 Internal Functions ============ */\r\n\r\n    /*\r\n     * The unit shares must result in a quantity greater than the number of natural units outstanding.\r\n     * In other words, it must be greater than 0\r\n     */\r\n    function validateUnitShares(uint256 _newUnitShares) internal view {\r\n        require(\r\n            _newUnitShares > 0,\r\n            \"Unitshares is 0\"\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/core/tokens/RebalancingSetTokenV3Factory.sol\r\n\r\n/*\r\n    Copyright 2020 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title RebalancingSetTokenV3Factory\r\n * @author Set Protocol\r\n *\r\n * RebalancingSetTokenV3Factory is a smart contract used to deploy new RebalancingSetTokenV3 contracts.\r\n */\r\ncontract RebalancingSetTokenV3Factory is RebalancingSetTokenV2Factory {\r\n\r\n    /* ============ Constructor ============ */\r\n\r\n    /**\r\n     *\r\n     * @param  _core                       Address of deployed core contract\r\n     * @param  _componentWhitelist         Address of component whitelist contract\r\n     * @param  _liquidatorWhitelist        Address of liquidator whitelist contract\r\n     * @param  _feeCalculatorWhitelist     Address of feeCalculator whitelist contract\r\n     * @param  _minimumRebalanceInterval   Minimum amount of time between rebalances in seconds\r\n     * @param  _minimumNaturalUnit         Minimum number for the token natural unit\r\n     * @param  _maximumNaturalUnit         Maximum number for the token natural unit\r\n     */\r\n    constructor(\r\n        ICore _core,\r\n        IWhiteList _componentWhitelist,\r\n        IWhiteList _liquidatorWhitelist,\r\n        IWhiteList _feeCalculatorWhitelist,\r\n        uint256 _minimumRebalanceInterval,\r\n        uint256 _minimumFailRebalancePeriod,\r\n        uint256 _maximumFailRebalancePeriod,\r\n        uint256 _minimumNaturalUnit,\r\n        uint256 _maximumNaturalUnit\r\n    )\r\n        public\r\n        RebalancingSetTokenV2Factory(\r\n            _core,\r\n            _componentWhitelist,\r\n            _liquidatorWhitelist,\r\n            _feeCalculatorWhitelist,\r\n            _minimumRebalanceInterval,\r\n            _minimumFailRebalancePeriod,\r\n            _maximumFailRebalancePeriod,\r\n            _minimumNaturalUnit,\r\n            _maximumNaturalUnit\r\n        )\r\n    {}\r\n\r\n    /* ============ External Functions ============ */\r\n\r\n    /**\r\n     * Overrides the RebalancingSetTokenV2Factory createSet function.\r\n     *\r\n     * Deploys a new RebalancingSetTokenV3 contract, conforming to IFactory\r\n     * Can only be called by core contracts.\r\n     *\r\n     *\r\n     * | CallData                   | Location                      |\r\n     * |----------------------------|-------------------------------|\r\n     * | manager                    | 32                            |\r\n     * | liquidator                 | 64                            |\r\n     * | feeRecipient               | 96                            |\r\n     * | rebalanceFeeCalculator     | 128                           |\r\n     * | rebalanceInterval          | 160                           |\r\n     * | rebalanceFailPeriod        | 192                           |\r\n     * | entryFee                   | 224                           |\r\n     * | rebalanceFeeCalculatorData | 256 to end                    |\r\n     *\r\n     * @param  _components     The address of component tokens\r\n     * @param  _units          The units of each component token\r\n     * @param  _naturalUnit    Minimum issuable amount of the RebalancingSetTokenV3\r\n     * @param  _name           The bytes32 encoded name of the new RebalancingSetTokenV3\r\n     * @param  _symbol         The bytes32 encoded symbol of the new RebalancingSetTokenV3\r\n     * @param  _callData       Byte string containing additional call parameters\r\n     *\r\n     * @return setToken        The address of the newly created SetToken\r\n     */\r\n    function createSet(\r\n        address[] calldata _components,\r\n        uint256[] calldata _units,\r\n        uint256 _naturalUnit,\r\n        bytes32 _name,\r\n        bytes32 _symbol,\r\n        bytes calldata _callData\r\n    )\r\n        external\r\n        returns (address)\r\n    {\r\n        SetTokenLibrary.SetDetails memory rebalancingSetDetails = SetTokenLibrary.SetDetails({\r\n            naturalUnit: _naturalUnit,\r\n            components: _components,\r\n            units: _units\r\n        });\r\n\r\n        FactoryUtilsLibrary.validateRebalancingSet(\r\n            rebalancingSetDetails,\r\n            address(core),\r\n            msg.sender,\r\n            minimumNaturalUnit,\r\n            maximumNaturalUnit\r\n        );\r\n\r\n        // Parse the calldata\r\n        FactoryUtilsLibrary.InitRebalancingParameters memory parameters =\r\n            FactoryUtilsLibrary.parseRebalanceSetCallData(_callData);\r\n\r\n        // Ensure validity of rebalancing Set calldata\r\n        FactoryUtilsLibrary.validateRebalanceSetCalldata(\r\n            parameters,\r\n            address(liquidatorWhitelist),\r\n            address(feeCalculatorWhitelist),\r\n            minimumRebalanceInterval,\r\n            minimumFailRebalancePeriod,\r\n            maximumFailRebalancePeriod\r\n        );\r\n\r\n        address rebalancingSet = address(\r\n            new RebalancingSetTokenV3(\r\n                [\r\n                    address(this),                          // factory\r\n                    parameters.manager,                     // manager\r\n                    parameters.liquidator,                  // liquidator\r\n                    _components[0],                            // initialSet\r\n                    address(rebalanceComponentWhitelist),   // componentWhiteList\r\n                    address(liquidatorWhitelist),           // liquidatorWhiteList\r\n                    parameters.feeRecipient,                // feeRecipient\r\n                    parameters.rebalanceFeeCalculator       // rebalanceFeeCalculator\r\n                ],\r\n                [\r\n                    _units[0],                              // unitShares\r\n                    _naturalUnit,                           // naturalUnit\r\n                    parameters.rebalanceInterval,           // rebalanceInterval\r\n                    parameters.rebalanceFailPeriod,         // rebalanceFailPeriod\r\n                    parameters.lastRebalanceTimestamp,      // lastRebalanceTimestamp\r\n                    parameters.entryFee                     // entryFee\r\n                ],\r\n                _name.bytes32ToString(),\r\n                _symbol.bytes32ToString()\r\n            )\r\n        );\r\n\r\n        // Initializes the RebalancingSetToken using the V2 interface (as the interface has not changed)\r\n        IRebalancingSetTokenV2(rebalancingSet).initialize(parameters.rebalanceFeeCalculatorData);\r\n\r\n        return rebalancingSet;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"maximumFailRebalancePeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_components\",\"type\":\"address[]\"},{\"name\":\"_units\",\"type\":\"uint256[]\"},{\"name\":\"_naturalUnit\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_symbol\",\"type\":\"bytes32\"},{\"name\":\"_callData\",\"type\":\"bytes\"}],\"name\":\"createSet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeCalculatorWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rebalanceComponentWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumRebalanceInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumNaturalUnit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumNaturalUnit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidatorWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumFailRebalancePeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"core\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_core\",\"type\":\"address\"},{\"name\":\"_componentWhitelist\",\"type\":\"address\"},{\"name\":\"_liquidatorWhitelist\",\"type\":\"address\"},{\"name\":\"_feeCalculatorWhitelist\",\"type\":\"address\"},{\"name\":\"_minimumRebalanceInterval\",\"type\":\"uint256\"},{\"name\":\"_minimumFailRebalancePeriod\",\"type\":\"uint256\"},{\"name\":\"_maximumFailRebalancePeriod\",\"type\":\"uint256\"},{\"name\":\"_minimumNaturalUnit\",\"type\":\"uint256\"},{\"name\":\"_maximumNaturalUnit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"RebalancingSetTokenV3Factory","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000345ab8af61d107c3972f0d73640e33d8ac545a070000000000000000000000006a2d7d65d1e92c3ea4fbc2d6d1383ca77978c3d30000000000000000000000002d979d78f5493b7917a3b67772465a36e98b261a0000000000000000000000005b4295de4a0a4d6d73a1c8bcac0902827ce62c8e000000000000000000000000000000000000000000000000000000000000003c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000015180000000000000000000000000000000000000000000000000000000000000271000000000000000000000000000000000000000000000000000005af3107a4000","Library":"Bytes32Library:18b89cc312b6079e6ac252e93ca21013f6c61465;FactoryUtilsLibrary:46741db3ed84bdc3d735c8f484adde35823b4011","LicenseType":"Apache-2.0","SwarmSource":"bzzr://01788162cade1dbe477f8a8e6386d4aba317f1660282501d88fd51cf6e05ccbe"}]}