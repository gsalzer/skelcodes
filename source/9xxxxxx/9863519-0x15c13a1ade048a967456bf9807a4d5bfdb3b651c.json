{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.10;\r\n\r\ninterface IDistribution {\r\n    function supply() external view returns(uint256);\r\n    function poolAddress(uint8) external view returns(address);\r\n}\r\n\r\n\r\ninterface IMultipleDistribution {\r\n    function initialize(address _tokenAddress) external;\r\n    function poolStake() external view returns (uint256);\r\n}\r\n\r\n\r\ninterface IERC677MultiBridgeToken {\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferDistribution(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function balanceOf(address _account) external view returns (uint256);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type,\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @dev Distributes STAKE tokens for Private Offering and Advisors Reward.\r\ncontract MultipleDistribution is Ownable, IMultipleDistribution {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    /// @dev Emits when `initialize` method has been called.\r\n    /// @param token The address of ERC677MultiBridgeToken contract.\r\n    /// @param caller The address of the caller.\r\n    event Initialized(address token, address caller);\r\n\r\n    /// @dev Emits when the `Distribution` address has been set.\r\n    /// @param distribution `Distribution` contract address.\r\n    /// @param caller The address of the caller.\r\n    event DistributionAddressSet(address distribution, address caller);\r\n\r\n    /// @dev Emits when `withdraw` method has been called.\r\n    /// @param recipient Recipient address.\r\n    /// @param value Transferred value.\r\n    event Withdrawn(address recipient, uint256 value);\r\n\r\n    /// @dev Emits when `burn` method has been called.\r\n    /// @param value Burnt value.\r\n    event Burnt(uint256 value);\r\n\r\n    /// @dev Emits when `addParticipants` method has been called.\r\n    /// @param participants Participants addresses.\r\n    /// @param stakes Participants stakes.\r\n    /// @param caller The address of the caller.\r\n    event ParticipantsAdded(address[] participants, uint256[] stakes, address caller);\r\n\r\n    /// @dev Emits when `editParticipant` method has been called.\r\n    /// @param participant Participant address.\r\n    /// @param oldStake Old participant stake.\r\n    /// @param newStake New participant stake.\r\n    /// @param caller The address of the caller.\r\n    event ParticipantEdited(address participant, uint256 oldStake, uint256 newStake, address caller);\r\n\r\n    /// @dev Emits when `removeParticipant` method has been called.\r\n    /// @param participant Participant address.\r\n    /// @param stake Participant stake.\r\n    /// @param caller The address of the caller.\r\n    event ParticipantRemoved(address participant, uint256 stake, address caller);\r\n\r\n    /// @dev Emits when `finalizeParticipants` method has been called.\r\n    /// @param numberOfParticipants Number of participants.\r\n    /// @param caller The address of the caller.\r\n    event ParticipantsFinalized(uint256 numberOfParticipants, address caller);\r\n\r\n    uint256 public TOTAL_STAKE;\r\n    uint8 public POOL_NUMBER;\r\n\r\n    /// @dev The instance of ERC677MultiBridgeToken contract.\r\n    IERC677MultiBridgeToken public token;\r\n\r\n    /// @dev Distribution contract address.\r\n    address public distributionAddress;\r\n\r\n    /// @dev Participants addresses.\r\n    address[] public participants;\r\n\r\n    /// @dev Stake for a specified participant.\r\n    mapping (address => uint256) public participantStake;\r\n\r\n    /// @dev Amount of tokens that have already been withdrawn by a specified participant.\r\n    mapping (address => uint256) public paidAmount;\r\n\r\n    /// @dev Contains max balance (sum of all installments).\r\n    uint256 public maxBalance = 0;\r\n\r\n    /// @dev Boolean variable that indicates whether the contract was initialized.\r\n    bool public isInitialized = false;\r\n\r\n    /// @dev Boolean variable that indicates whether the participant set was finalized.\r\n    bool public isFinalized = false;\r\n\r\n    /// @dev Contains current sum of stakes.\r\n    uint256 public sumOfStakes = 0;\r\n\r\n    /// @dev Checks that the contract is initialized.\r\n    modifier initialized() {\r\n        require(isInitialized, \"not initialized\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Checks that the participant set is not finalized.\r\n    modifier notFinalized() {\r\n        require(!isFinalized, \"already finalized\");\r\n        _;\r\n    }\r\n\r\n    constructor(uint8 _pool) public {\r\n        require(_pool == 3 || _pool == 4, \"wrong pool number\");\r\n        POOL_NUMBER = _pool;\r\n\r\n        if (POOL_NUMBER == 3) {\r\n            TOTAL_STAKE = 1970951 ether; // Private Offering supply\r\n        } else {\r\n            TOTAL_STAKE = 651000 ether; // Advisors Reward supply\r\n        }\r\n    }\r\n\r\n    /// @dev Adds participants.\r\n    /// @param _participants The addresses of new participants.\r\n    /// @param _stakes The amounts of the tokens that belong to each participant.\r\n    function addParticipants(\r\n        address[] calldata _participants,\r\n        uint256[] calldata _stakes\r\n    ) external onlyOwner notFinalized {\r\n        require(_participants.length == _stakes.length, \"different arrays sizes\");\r\n        for (uint256 i = 0; i < _participants.length; i++) {\r\n            require(_participants[i] != address(0), \"invalid address\");\r\n            require(_stakes[i] > 0, \"the participant stake must be more than 0\");\r\n            require(participantStake[_participants[i]] == 0, \"participant already added\");\r\n            participants.push(_participants[i]);\r\n            participantStake[_participants[i]] = _stakes[i];\r\n            sumOfStakes = sumOfStakes.add(_stakes[i]);\r\n        }\r\n        require(sumOfStakes <= TOTAL_STAKE, \"wrong sum of values\");\r\n        emit ParticipantsAdded(_participants, _stakes, msg.sender);\r\n    }\r\n\r\n    /// @dev Edits participant stake.\r\n    /// @param _participant Participant address.\r\n    /// @param _newStake New stake of the participant.\r\n    function editParticipant(\r\n        address _participant,\r\n        uint256 _newStake\r\n    ) external onlyOwner notFinalized {\r\n        require(_participant != address(0), \"invalid address\");\r\n\r\n        uint256 oldStake = participantStake[_participant];\r\n        require(oldStake > 0, \"the participant doesn't exist\");\r\n        require(_newStake > 0, \"the participant stake must be more than 0\");\r\n\r\n        sumOfStakes = sumOfStakes.sub(oldStake).add(_newStake);\r\n        require(sumOfStakes <= TOTAL_STAKE, \"wrong sum of values\");\r\n        participantStake[_participant] = _newStake;\r\n\r\n        emit ParticipantEdited(_participant, oldStake, _newStake, msg.sender);\r\n    }\r\n\r\n    /// @dev Removes participant.\r\n    /// @param _participant Participant address.\r\n    function removeParticipant(\r\n        address _participant\r\n    ) external onlyOwner notFinalized {\r\n        require(_participant != address(0), \"invalid address\");\r\n\r\n        uint256 stake = participantStake[_participant];\r\n        require(stake > 0, \"the participant doesn't exist\");\r\n\r\n        uint256 index = 0;\r\n        uint256 participantsLength = participants.length;\r\n        for (uint256 i = 0; i < participantsLength; i++) {\r\n            if (participants[i] == _participant) {\r\n                index = i;\r\n                break;\r\n            }\r\n        }\r\n        require(participants[index] == _participant, \"the participant not found\");\r\n        sumOfStakes = sumOfStakes.sub(stake);\r\n        participantStake[_participant] = 0;\r\n\r\n        address lastParticipant = participants[participants.length.sub(1)];\r\n        participants[index] = lastParticipant;\r\n        participants.length = participants.length.sub(1);\r\n\r\n        emit ParticipantRemoved(_participant, stake, msg.sender);\r\n    }\r\n\r\n    /// @dev Calculates unused stake and disables the following additions/edits.\r\n    function finalizeParticipants() external onlyOwner notFinalized {\r\n        uint256 unusedStake = TOTAL_STAKE.sub(sumOfStakes);\r\n        if (unusedStake > 0) {\r\n            participants.push(address(0));\r\n            participantStake[address(0)] = unusedStake;\r\n        }\r\n        isFinalized = true;\r\n        emit ParticipantsFinalized(participants.length, msg.sender);\r\n    }\r\n\r\n    /// @dev Initializes the contract after the token is created.\r\n    /// @param _tokenAddress The address of the STAKE token contract.\r\n    function initialize(\r\n        address _tokenAddress\r\n    ) external {\r\n        require(msg.sender == distributionAddress, \"wrong sender\");\r\n        require(!isInitialized, \"already initialized\");\r\n        require(isFinalized, \"not finalized\");\r\n        require(_tokenAddress != address(0));\r\n        token = IERC677MultiBridgeToken(_tokenAddress);\r\n        isInitialized = true;\r\n        emit Initialized(_tokenAddress, msg.sender);\r\n    }\r\n\r\n    /// @dev The removed implementation of the ownership renouncing.\r\n    function renounceOwnership() public onlyOwner {\r\n        revert(\"not implemented\");\r\n    }\r\n\r\n    /// @dev Sets the `Distribution` contract address.\r\n    /// @param _distributionAddress The `Distribution` contract address.\r\n    function setDistributionAddress(address _distributionAddress) external onlyOwner {\r\n        require(distributionAddress == address(0), \"already set\");\r\n        require(\r\n            address(this) == IDistribution(_distributionAddress).poolAddress(POOL_NUMBER),\r\n            \"wrong address\"\r\n        );\r\n        distributionAddress = _distributionAddress;\r\n        emit DistributionAddressSet(distributionAddress, msg.sender);\r\n    }\r\n\r\n    /// @dev Transfers a share to participant.\r\n    function withdraw() external {\r\n        uint256 amount = _withdraw(msg.sender);\r\n        emit Withdrawn(msg.sender, amount);\r\n    }\r\n\r\n    /// @dev Transfers unclaimed part to address(0).\r\n    function burn() external onlyOwner {\r\n        uint256 amount = _withdraw(address(0));\r\n        emit Burnt(amount);\r\n    }\r\n\r\n    /// @dev Updates an internal value of the balance to use it for correct\r\n    /// share calculation (see the `_withdraw` function) and prevents transferring\r\n    /// tokens to this contract not from the `Distribution` contract.\r\n    /// @param _from The address from which the tokens are transferred.\r\n    /// @param _value The amount of transferred tokens.\r\n    function onTokenTransfer(\r\n        address _from,\r\n        uint256 _value,\r\n        bytes calldata\r\n    ) external returns (bool) {\r\n        require(msg.sender == address(token), \"the caller can only be the token contract\");\r\n        require(_from == distributionAddress, \"the _from value can only be the distribution contract\");\r\n        maxBalance = maxBalance.add(_value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Returns a total amount of tokens.\r\n    function poolStake() external view returns (uint256) {\r\n        return TOTAL_STAKE;\r\n    }\r\n\r\n    /// @dev Returns an array of participants.\r\n    function getParticipants() external view returns (address[] memory) {\r\n        return participants;\r\n    }\r\n\r\n    function _withdraw(address _recipient) internal initialized returns(uint256) {\r\n        uint256 stake = participantStake[_recipient];\r\n        require(stake > 0, \"you are not a participant\");\r\n\r\n        uint256 maxShare = maxBalance.mul(stake).div(TOTAL_STAKE);\r\n        uint256 currentShare = maxShare.sub(paidAmount[_recipient]);\r\n        require(currentShare > 0, \"no tokens available to withdraw\");\r\n\r\n        paidAmount[_recipient] = paidAmount[_recipient].add(currentShare);\r\n        token.transferDistribution(_recipient, currentShare);\r\n\r\n        return currentShare;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"finalizeParticipants\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"participants\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributionAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getParticipants\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"}],\"name\":\"removeParticipant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_STAKE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"paidAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sumOfStakes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_distributionAddress\",\"type\":\"address\"}],\"name\":\"setDistributionAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"},{\"name\":\"_newStake\",\"type\":\"uint256\"}],\"name\":\"editParticipant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"POOL_NUMBER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participants\",\"type\":\"address[]\"},{\"name\":\"_stakes\",\"type\":\"uint256[]\"}],\"name\":\"addParticipants\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"participantStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_pool\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"distribution\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"DistributionAddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burnt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"participants\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"stakes\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"ParticipantsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldStake\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newStake\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"ParticipantEdited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"stake\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"ParticipantRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"numberOfParticipants\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"ParticipantsFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"MultipleDistribution","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000003","Library":"","LicenseType":"None","SwarmSource":"bzzr://ad5b42d619bcf2ee5a93846f682a4d4afc0e5aa7d209f4afaa5c1c94dc7a1086"}]}