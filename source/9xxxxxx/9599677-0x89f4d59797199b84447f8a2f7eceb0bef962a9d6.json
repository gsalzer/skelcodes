{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.9;\r\n\r\ncontract CryptoKingdoms\r\n{\r\n    uint public constant gameNumber = 8;\r\n    \r\n    address public constant previousGameAddress = 0x2c8dc01FB73c7079cC8A9e7a339C172Bbf2d3EbC;\r\n    \r\n    address public nextGameAddress;\r\n    \r\n    enum Race\r\n    {\r\n        None,\r\n        Humane\r\n    }\r\n\r\n    struct Kingdom\r\n    {\r\n        Race race;\r\n\r\n        string name;\r\n\r\n        uint actions;\r\n        \r\n        uint gold;\r\n        \r\n        uint soldiers;\r\n        uint spies;\r\n        uint wizards;\r\n        uint dragons;\r\n        \r\n        uint hovels;\r\n        uint miningCamps;\r\n        uint banks;\r\n        uint barracks;\r\n        uint castles;\r\n    }\r\n    \r\n    Kingdom public winner;\r\n    uint winnerPrize;\r\n    \r\n    uint constant defaultJoinDuration = 26 days;\r\n    uint constant defaultGameDuration = 33 days;\r\n    uint constant defaultTurnTime = 11 hours;\r\n    \r\n    uint constant joinGameCost = 0.0225 ether;\r\n    \r\n    uint constant soldierCost = 3;\r\n    uint constant spyCost = 100;\r\n    uint constant wizardCost = 250;\r\n    uint constant dragonCost = 3000;\r\n    uint constant hovelCost = 100;\r\n    uint constant miningCampCost = 1000;\r\n    uint constant bankCost = 1500;\r\n    uint constant barracksCost = 300;\r\n    uint constant castleCost = 15000;\r\n    \r\n    uint constant soldierAttack = 1;\r\n    uint constant spyAttack = 5;\r\n    uint constant wizardAttack = 100;\r\n    uint constant dragonAttack = 500;\r\n    \r\n    uint constant barracksDefence = 5;\r\n    uint constant castleDefence = 1000;\r\n    \r\n    uint constant wizardGoldPerTurn = 20;\r\n    uint constant hovelGoldPerTurn = 5;\r\n    uint constant miningCampGoldPerTurn = 150;\r\n\r\n    uint constant bankedGoldPerUnitGoldPerTurn = 50;\r\n    uint constant bankLimit = 15;\r\n    \r\n    uint constant barracksSoldiersPerTurn = 25;\r\n    uint constant castleSoldiersPerTurn = 50;\r\n    \r\n    uint constant hovelCapacity = 3;\r\n    \r\n    uint constant espionageCost = 25;\r\n    \r\n    address payable[] private players;\r\n    address payable private host;\r\n    \r\n    mapping (address => Kingdom) private kingdoms;\r\n    \r\n    uint gameTurnTime = defaultTurnTime;\r\n    uint gameDuration = defaultGameDuration;\r\n    uint gameJoinDuration = defaultJoinDuration;\r\n    uint gameTotalTurns;\r\n    uint gameStartTime;\r\n    uint gameEndTime;\r\n    \r\n    uint hostFees;\r\n    \r\n    uint currentTurnNumber;\r\n    uint leaderPlayerIndex;\r\n    uint espionageInformationType;\r\n    \r\n    event turnCompleted();\r\n    event newPlayerJoined(string playerName);\r\n    event attackCompleted(uint goldExchanged, uint soldierDeaths, uint wizardDeaths, uint dragonDeaths);\r\n    event spyReported(string name, uint detail, uint info, uint moreInfo);\r\n    event sabotaged(uint sabotagedGold, uint sabotagedDragons, uint sabotagedHovels, uint sabotagedMiningCamps, uint sabotagedBanks, uint dragonsKilled);\r\n    event hostMessage(string message);\r\n    event gameEnded();\r\n    \r\n    constructor (uint joinTimeSeconds, uint gameTimeSeconds, uint turnTimeSeconds) public\r\n    {\r\n        if (joinTimeSeconds > 0)\r\n        {\r\n            gameJoinDuration = joinTimeSeconds;\r\n        }\r\n        \r\n        if (gameTimeSeconds > 0)\r\n        {\r\n            gameDuration = gameTimeSeconds;\r\n        }\r\n        \r\n        if (turnTimeSeconds > 0)\r\n        {\r\n            gameTurnTime = turnTimeSeconds;\r\n        }\r\n        \r\n        gameStartTime = block.timestamp + gameJoinDuration;\r\n        gameEndTime = gameStartTime + gameDuration;\r\n        gameTotalTurns = (gameDuration / gameTurnTime) + 1; // +1 for the last turn\r\n        host = msg.sender;\r\n    }\r\n    \r\n    function gameStats() public view returns (uint version,\r\n                                              uint numberPlayers,\r\n                                              uint totalGold,\r\n                                              uint totalPrizePool,\r\n                                              uint gameStartTimeSeconds,\r\n                                              uint gameDurationSeconds,\r\n                                              uint gameTurns,\r\n                                              uint gameTurnTimeSeconds,\r\n                                              uint gameCurrentTurn,\r\n                                              uint gameLeaderIndex)\r\n    {\r\n        for (uint playerIndex = 0; playerIndex < players.length; playerIndex++)\r\n        {\r\n            address playerAddress = players[playerIndex];\r\n            Kingdom storage kingdom = kingdoms[playerAddress];\r\n            totalGold += kingdom.gold;\r\n        }\r\n        return (gameNumber, players.length, totalGold, winnerPrize,\r\n                gameStartTime, gameDuration,\r\n                gameTotalTurns, gameTurnTime,\r\n                currentTurnNumber,\r\n                leaderPlayerIndex);\r\n    }\r\n    \r\n    \r\n    //  === Host Functions ===\r\n    \r\n    modifier onlyHost()\r\n    {\r\n        require(msg.sender == host);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfGameStarted()\r\n    {\r\n        require(block.timestamp > gameStartTime);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfTurnTime()\r\n    {\r\n        if (block.timestamp < gameEndTime)\r\n        {\r\n            uint time = block.timestamp;\r\n            uint turnsRemaining = ((gameEndTime - time) / gameTurnTime) + 1; // For game start turn.\r\n            uint blocktimeTurnNumber = gameTotalTurns - turnsRemaining;\r\n            require(currentTurnNumber < blocktimeTurnNumber);\r\n        }\r\n        else\r\n        {\r\n            require(currentTurnNumber < gameTotalTurns);\r\n        }\r\n        _;\r\n    }\r\n    \r\n    // Called by the game host (at most) every gameTurnTime to update the game state and to allow players to progress.\r\n    function turn() public onlyIfGameStarted() onlyIfTurnTime()\r\n    {\r\n        uint turnsToUpdate = 0;\r\n        if (block.timestamp < gameEndTime)\r\n        {\r\n            uint turnsRemaining = ((gameEndTime - block.timestamp) / gameTurnTime) + 1;\r\n            uint blocktimeTurnNumber = gameTotalTurns - turnsRemaining;\r\n            turnsToUpdate = blocktimeTurnNumber - currentTurnNumber;\r\n        }\r\n        else\r\n        {\r\n            turnsToUpdate = gameTotalTurns - currentTurnNumber;\r\n        }\r\n        \r\n        leaderPlayerIndex = 0;\r\n        uint maxPlayerRank = 0;\r\n        \r\n        for (uint playerIndex = 0; playerIndex < players.length; playerIndex++)\r\n        {\r\n            address player = players[playerIndex];\r\n            Kingdom storage kingdom = kingdoms[player];\r\n            kingdom.actions += turnsToUpdate;\r\n            kingdom.gold += (kingdom.hovels * hovelGoldPerTurn\r\n                           + kingdom.miningCamps * miningCampGoldPerTurn\r\n                           + kingdom.wizards * wizardGoldPerTurn\r\n                           + (kingdom.banks * (kingdom.gold / bankedGoldPerUnitGoldPerTurn))) * turnsToUpdate;\r\n            kingdom.soldiers += (kingdom.barracks * barracksSoldiersPerTurn + kingdom.castles * castleSoldiersPerTurn) * turnsToUpdate;\r\n            \r\n            uint estimatedPlayerRank = kingdom.gold * ((currentTurnNumber * 100) / (gameTotalTurns * 100))\r\n                                   + ((kingdom.soldiers * soldierCost) + (kingdom.wizards * wizardCost) + (kingdom.dragons * dragonCost)\r\n                                    + (kingdom.hovels * hovelCost) + (kingdom.miningCamps * miningCampCost) + (kingdom.banks * bankCost)\r\n                                    + (kingdom.barracks * barracksCost)) * (gameTotalTurns / 4);\r\n            if (estimatedPlayerRank > maxPlayerRank)\r\n            {\r\n                maxPlayerRank = estimatedPlayerRank;\r\n                leaderPlayerIndex = playerIndex;\r\n            }\r\n        }\r\n        \r\n        currentTurnNumber += turnsToUpdate;\r\n        \r\n        if (currentTurnNumber == gameTotalTurns)\r\n        {\r\n            endGame();\r\n        }\r\n        \r\n        emit turnCompleted();\r\n    }\r\n    \r\n    function endGame() private\r\n    {\r\n        uint largestGoldAmount = 0;\r\n        address payable winnerAddress;\r\n        for (uint playerIndex = 0; playerIndex < players.length; playerIndex++)\r\n        {\r\n            address payable playerAddress = players[playerIndex];\r\n            Kingdom storage kingdom = kingdoms[playerAddress];\r\n            if (kingdom.gold > largestGoldAmount)\r\n            {\r\n                largestGoldAmount = kingdom.gold;\r\n                winnerAddress = playerAddress;\r\n            }\r\n        }\r\n        \r\n        winner = kingdoms[winnerAddress];\r\n        winnerAddress.transfer(winnerPrize);\r\n        host.transfer(hostFees);\r\n    }\r\n    \r\n    function setNextGame(address gameAddress) public onlyHost()\r\n    {\r\n        nextGameAddress = gameAddress;\r\n    }\r\n    \r\n    // The game host reserves the right to modify abusive kingdom names.\r\n    function changeKingdomName(uint kingdomIndex, string memory newName) public onlyHost()\r\n    {\r\n        address payable playerAddress = players[kingdomIndex];\r\n        Kingdom storage kingdom = kingdoms[playerAddress];\r\n        kingdom.name = newName;\r\n    }\r\n    \r\n    function message(string memory s) public onlyHost()\r\n    {\r\n        emit hostMessage(s);\r\n    }\r\n    \r\n    \r\n    //  === Player Functions ===\r\n\r\n    modifier onlyIfNewPlayer()\r\n    {\r\n        // No existing kingdom for sender address.\r\n        require(kingdoms[msg.sender].race == Race.None);\r\n        require(currentTurnNumber < gameTotalTurns);\r\n        require(msg.value == joinGameCost);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfTurnsRemaining()\r\n    {\r\n        require(currentTurnNumber < gameTotalTurns);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfValidPlayerIndex(uint playerIndex)\r\n    {\r\n        require(playerIndex < players.length);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfOtherPlayerIndex(uint otherPlayerIndex)\r\n    {\r\n        address otherPlayer = players[otherPlayerIndex];\r\n        require(msg.sender != otherPlayer);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfActions()\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        require(kingdom.actions > 0);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfGold(uint goldCost)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        require(kingdom.gold >= goldCost);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfHovels(uint amount)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        require(kingdom.hovels >= ((kingdom.spies + kingdom.wizards + amount) / hovelCapacity));\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfUnderBankLimit(uint amount)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        require((kingdom.banks + amount) <= bankLimit);\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfSpies()\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        require(kingdom.spies > 0);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfWizards(uint number)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        require(kingdom.wizards > 0);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfDragons()\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        require(kingdom.dragons > 0);\r\n        _;\r\n    }\r\n    \r\n    function joinGame(string memory playerName) public payable onlyIfNewPlayer() onlyIfTurnsRemaining()\r\n    {\r\n        winnerPrize += (msg.value * 7) / 10;\r\n        hostFees += (msg.value * 3) / 10;\r\n        \r\n        kingdoms[msg.sender] = Kingdom({\r\n            race: Race.Humane,\r\n            name: playerName,\r\n            actions: currentTurnNumber,\r\n            gold: 1320 + (currentTurnNumber * hovelGoldPerTurn * 5),\r\n            soldiers: 25,\r\n            spies: 0,\r\n            wizards: 0,\r\n            dragons: 0,\r\n            hovels: 3,\r\n            miningCamps: 1,\r\n            banks: 0,\r\n            barracks: 0,\r\n            castles: 0\r\n        });\r\n        \r\n        players.push(msg.sender);\r\n        \r\n        emit newPlayerJoined(playerName);\r\n    }\r\n\r\n    function playerStats() public view\r\n             returns (Race race, string memory kingdomName, uint actions, uint gold,\r\n                      uint soldiers, uint spies, uint wizards, uint dragons,\r\n                      uint hovels, uint miningCamps, uint banks, uint barracks, uint castles)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        return (kingdom.race, kingdom.name, kingdom.actions, kingdom.gold,\r\n                kingdom.soldiers, kingdom.spies, kingdom.wizards, kingdom.dragons,\r\n                kingdom.hovels, kingdom.miningCamps, kingdom.banks, kingdom.barracks, kingdom.castles);\r\n    }\r\n    \r\n    function playerAtIndex(uint playerIndex) public view\r\n             onlyIfValidPlayerIndex(playerIndex)\r\n             returns (string memory playerName)\r\n    {\r\n        address playerAddress = players[playerIndex];\r\n        Kingdom storage kingdom = kingdoms[playerAddress];\r\n        return kingdom.name;\r\n    }\r\n    \r\n    // === Player Actions ===\r\n\r\n    function recruitSoldiers(uint amount) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfActions() onlyIfGold(amount * soldierCost)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        kingdom.gold -= amount * soldierCost;\r\n        kingdom.soldiers += amount;\r\n        kingdom.actions -= 1;\r\n    }\r\n\r\n    function recruitSpies(uint amount) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfActions() onlyIfGold(amount * spyCost) onlyIfHovels(amount)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        kingdom.gold -= amount * spyCost;\r\n        kingdom.spies += amount;\r\n    }\r\n    \r\n    function summonWizards(uint amount) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfActions() onlyIfGold(amount * wizardCost) onlyIfHovels(amount)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        kingdom.gold -= amount * wizardCost;\r\n        kingdom.wizards += amount;\r\n        kingdom.actions -= 1;\r\n    }\r\n    \r\n    function trainDragons(uint amount) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfActions() onlyIfGold(amount * dragonCost)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        kingdom.gold -= amount * dragonCost;\r\n        kingdom.dragons += amount;\r\n        kingdom.actions -= 1;\r\n    }\r\n\r\n    function buildHovels(uint amount) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfActions() onlyIfGold(amount * hovelCost)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        kingdom.gold -= amount * hovelCost;\r\n        kingdom.hovels += amount;\r\n        kingdom.actions -= 1;\r\n    }\r\n\r\n    function buildBarracks(uint amount) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfActions() onlyIfGold(amount * barracksCost)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        kingdom.gold -= amount * barracksCost;\r\n        kingdom.barracks += amount;\r\n        kingdom.actions -= 1;\r\n    }\r\n\r\n    function buildMiningCamps(uint amount) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfActions() onlyIfGold(amount * miningCampCost)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        kingdom.gold -= amount * miningCampCost;\r\n        kingdom.miningCamps += amount;\r\n        kingdom.actions -= 1;\r\n    }\r\n    \r\n    function buildBanks(uint amount) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfActions() onlyIfGold(amount * bankCost) onlyIfUnderBankLimit(amount)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        kingdom.gold -= amount * bankCost;\r\n        kingdom.banks += amount;\r\n        kingdom.actions -= 1;\r\n    }\r\n\r\n    function buildCastles(uint amount) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfActions() onlyIfGold(amount * castleCost)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        kingdom.gold -= amount * castleCost;\r\n        kingdom.castles += amount;\r\n        kingdom.actions -= 1;\r\n    }\r\n\r\n    function attack(uint targetPlayerIndex, uint numberOfSoldiers) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfActions() onlyIfOtherPlayerIndex(targetPlayerIndex)\r\n    {\r\n        Kingdom storage attackingKingdom = kingdoms[msg.sender];\r\n        require(attackingKingdom.soldiers >= numberOfSoldiers);\r\n        \r\n        address targetPlayer = players[targetPlayerIndex];        \r\n        Kingdom storage defendingKingdom = kingdoms[targetPlayer];\r\n        \r\n        uint goldExchanged = 0;\r\n        \r\n        uint randomValue = (uint(keccak256(abi.encodePacked(block.timestamp))) << 2) >> ((block.timestamp / 9753) % 7);\r\n\r\n        uint attackForce = numberOfSoldiers         * soldierAttack\r\n                         + attackingKingdom.spies   * spyAttack\r\n                         + attackingKingdom.wizards * wizardAttack\r\n                         + attackingKingdom.dragons * dragonAttack\r\n                         + 1;\r\n        attackForce *= 100 + (randomValue % 10);\r\n        attackForce /= 100;\r\n\r\n        uint defenceForce = defendingKingdom.soldiers * soldierAttack\r\n                          + defendingKingdom.spies    * spyAttack\r\n                          + defendingKingdom.wizards  * wizardAttack\r\n                          + defendingKingdom.dragons  * dragonAttack\r\n                          + defendingKingdom.barracks * barracksDefence\r\n                          + defendingKingdom.castles  * castleDefence\r\n                          + 1;\r\n        \r\n        uint attackingArmySoldierDeaths = 0;\r\n        uint attackingArmyWizardDeaths = 0;\r\n        uint attackingArmyDragonsDeaths = 0;\r\n        \r\n        if (attackForce > defenceForce)\r\n        {\r\n            // Victory\r\n            \r\n            goldExchanged = (defenceForce * defendingKingdom.gold * 1000000) / (attackForce * 2000000);\r\n            \r\n            attackingArmySoldierDeaths = (defenceForce * numberOfSoldiers * 1000000) / (attackForce * 3000000);\r\n            \r\n            if (defendingKingdom.gold < goldExchanged)\r\n            {\r\n                goldExchanged = defendingKingdom.gold;\r\n            }\r\n            defendingKingdom.gold -= goldExchanged;\r\n            defendingKingdom.soldiers -= (defenceForce * defendingKingdom.soldiers * 1000000) / (attackForce * 4000000);\r\n            \r\n            goldExchanged += randomValue % (currentTurnNumber * 3); // We found this along the way!\r\n            attackingKingdom.gold += goldExchanged;\r\n            attackingKingdom.soldiers -= attackingArmySoldierDeaths;\r\n        }\r\n        else\r\n        {\r\n            // Defeat\r\n            \r\n            defendingKingdom.soldiers -= (attackForce * defendingKingdom.soldiers * 250000) / (defenceForce * 1000000);\r\n            \r\n            if (numberOfSoldiers > 0)\r\n            {\r\n                attackingArmySoldierDeaths = randomValue % numberOfSoldiers;\r\n                attackingKingdom.soldiers -= attackingArmySoldierDeaths;\r\n            }\r\n        }\r\n        \r\n        if (goldExchanged > 0 || attackingArmySoldierDeaths > 0)\r\n        {\r\n            if ((numberOfSoldiers * soldierAttack) < // Whirlwind Attack\r\n                ((attackingKingdom.spies * spyAttack) + (attackingKingdom.wizards * wizardAttack) + (attackingKingdom.dragons * dragonAttack)))\r\n            {\r\n                attackingArmyWizardDeaths = attackingKingdom.wizards / ((randomValue % 5) + 4);\r\n                attackingArmyDragonsDeaths = attackingKingdom.dragons / ((randomValue % 3) + 3);\r\n            }\r\n            else\r\n            {\r\n                attackingArmyWizardDeaths = attackingKingdom.wizards / ((randomValue % 6) + 6);\r\n                attackingArmyDragonsDeaths = attackingKingdom.dragons / ((randomValue % 9) + 7);\r\n            }\r\n            attackingKingdom.wizards -= attackingArmyWizardDeaths;\r\n            attackingKingdom.dragons -= attackingArmyDragonsDeaths;\r\n        \r\n            defendingKingdom.wizards -= defendingKingdom.wizards  / ((randomValue % 7) + 6);\r\n            defendingKingdom.dragons -= defendingKingdom.dragons / ((randomValue % 9) + 9);\r\n        }\r\n        \r\n        attackingKingdom.actions -= 1;\r\n        \r\n        emit attackCompleted(goldExchanged, attackingArmySoldierDeaths, attackingArmyWizardDeaths, attackingArmyDragonsDeaths);\r\n    }\r\n\r\n    function espionage(uint targetPlayerIndex) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfSpies() onlyIfActions() onlyIfGold(espionageCost) onlyIfOtherPlayerIndex(targetPlayerIndex)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        kingdom.gold -= espionageCost;\r\n        \r\n        address targetPlayer = players[targetPlayerIndex];        \r\n        Kingdom storage defendingKingdom = kingdoms[targetPlayer];\r\n        \r\n        if (kingdom.spies * 2 > defendingKingdom.spies)\r\n        {\r\n            // Success\r\n            \r\n            uint infoType = (currentTurnNumber + espionageInformationType) % 3;\r\n            if (infoType == 0)\r\n            {\r\n                emit spyReported(defendingKingdom.name, 1, defendingKingdom.gold, defendingKingdom.dragons);\r\n            }\r\n            else if (infoType == 1)\r\n            {\r\n                emit spyReported(defendingKingdom.name, 2, defendingKingdom.soldiers, defendingKingdom.banks);\r\n            }\r\n            else if (infoType == 2)\r\n            {\r\n                emit spyReported(defendingKingdom.name, 3, defendingKingdom.miningCamps, defendingKingdom.castles);\r\n            }\r\n            \r\n            espionageInformationType++;\r\n        }\r\n        else\r\n        {\r\n            // Failure\r\n            \r\n            emit spyReported(defendingKingdom.name, 0, kingdom.spies, 0);\r\n        }\r\n    }\r\n\r\n    function sabotage(uint targetPlayerIndex) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfActions() onlyIfDragons() onlyIfOtherPlayerIndex(targetPlayerIndex)\r\n    {\r\n        Kingdom storage attackingKingdom = kingdoms[msg.sender];\r\n\r\n        address targetPlayer = players[targetPlayerIndex];\r\n        Kingdom storage defendingKingdom = kingdoms[targetPlayer];\r\n        \r\n        uint attackForce = attackingKingdom.dragons;\r\n        uint defenceForce = defendingKingdom.dragons + defendingKingdom.castles;\r\n        if (attackForce > defenceForce)\r\n        {\r\n            // Victory\r\n            \r\n            uint sabotagedFraction = ((attackForce * 3) / (defenceForce + 1)) + 2;\r\n            uint sabotagedGold = defendingKingdom.gold / (sabotagedFraction * 3);\r\n            uint sabotagedDragons = defendingKingdom.dragons / (sabotagedFraction * 4);\r\n            uint sabotagedHovels = defendingKingdom.hovels / (sabotagedFraction * 5);\r\n            uint sabotagedMiningCamps = defendingKingdom.miningCamps / sabotagedFraction;\r\n            uint sabotagedBanks = defendingKingdom.banks / (sabotagedFraction * 5);\r\n            defendingKingdom.gold -= sabotagedGold;\r\n            defendingKingdom.dragons -= sabotagedDragons;\r\n            defendingKingdom.hovels -= sabotagedHovels;\r\n            defendingKingdom.miningCamps -= sabotagedMiningCamps;\r\n            defendingKingdom.banks -= sabotagedBanks;\r\n            \r\n            uint dragonsKilled = sabotagedDragons * 3 + 2;\r\n            if (dragonsKilled > attackingKingdom.dragons)\r\n            {\r\n                dragonsKilled = attackingKingdom.dragons;\r\n            }\r\n            attackingKingdom.dragons -= dragonsKilled;\r\n            \r\n            emit sabotaged(sabotagedGold, sabotagedDragons, sabotagedHovels, sabotagedMiningCamps, sabotagedBanks, dragonsKilled);\r\n        }\r\n        else\r\n        {\r\n            // Defeat\r\n            \r\n            uint dragonsKilled = attackingKingdom.dragons / 20 + 1;\r\n            attackingKingdom.dragons -= dragonsKilled;\r\n            \r\n            if (defendingKingdom.dragons < dragonsKilled)\r\n            {\r\n                defendingKingdom.dragons = 0;\r\n            }\r\n            else\r\n            {\r\n                defendingKingdom.dragons -= dragonsKilled;\r\n            }\r\n            \r\n            emit sabotaged(0, dragonsKilled, 0, 0, 0, dragonsKilled);\r\n        }\r\n        \r\n        attackingKingdom.actions -= 1;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"joinTimeSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gameTimeSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"turnTimeSeconds\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"goldExchanged\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"soldierDeaths\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wizardDeaths\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dragonDeaths\",\"type\":\"uint256\"}],\"name\":\"attackCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"gameEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"hostMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"playerName\",\"type\":\"string\"}],\"name\":\"newPlayerJoined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sabotagedGold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sabotagedDragons\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sabotagedHovels\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sabotagedMiningCamps\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sabotagedBanks\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dragonsKilled\",\"type\":\"uint256\"}],\"name\":\"sabotaged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"detail\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"info\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"moreInfo\",\"type\":\"uint256\"}],\"name\":\"spyReported\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"turnCompleted\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetPlayerIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfSoldiers\",\"type\":\"uint256\"}],\"name\":\"attack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buildBanks\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buildBarracks\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buildCastles\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buildHovels\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buildMiningCamps\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"kingdomIndex\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"changeKingdomName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetPlayerIndex\",\"type\":\"uint256\"}],\"name\":\"espionage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberPlayers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalGold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPrizePool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gameStartTimeSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gameDurationSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gameTurns\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gameTurnTimeSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gameCurrentTurn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gameLeaderIndex\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"playerName\",\"type\":\"string\"}],\"name\":\"joinGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"s\",\"type\":\"string\"}],\"name\":\"message\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextGameAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"playerIndex\",\"type\":\"uint256\"}],\"name\":\"playerAtIndex\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"playerName\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"playerStats\",\"outputs\":[{\"internalType\":\"enum CryptoKingdoms.Race\",\"name\":\"race\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"kingdomName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"actions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"soldiers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spies\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wizards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dragons\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hovels\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"miningCamps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"banks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"barracks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"castles\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"previousGameAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recruitSoldiers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recruitSpies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetPlayerIndex\",\"type\":\"uint256\"}],\"name\":\"sabotage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"gameAddress\",\"type\":\"address\"}],\"name\":\"setNextGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"summonWizards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"trainDragons\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"turn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winner\",\"outputs\":[{\"internalType\":\"enum CryptoKingdoms.Race\",\"name\":\"race\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"actions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"soldiers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spies\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wizards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dragons\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hovels\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"miningCamps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"banks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"barracks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"castles\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CryptoKingdoms","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://983f5d101a7e6e279d4cf4e6ff0db71c2e5b33dfe3259fcfbe82cb1f98a719be"}]}