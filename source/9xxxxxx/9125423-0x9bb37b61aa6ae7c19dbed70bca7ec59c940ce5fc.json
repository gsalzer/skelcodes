{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\ncontract Auth {\r\n\r\n    address internal mainAdmin;\r\n    address internal contractAdmin;\r\n\r\n    event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\r\n\r\n    constructor(\r\n        address _mainAdmin,\r\n        address _contractAdmin\r\n    )\r\n    internal\r\n    {\r\n        mainAdmin = _mainAdmin;\r\n        contractAdmin = _contractAdmin;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(isMainAdmin() || isContractAdmin(), \"onlyAdmin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyMainAdmin() {\r\n        require(isMainAdmin(), \"onlyMainAdmin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyContractAdmin() {\r\n        require(isContractAdmin(), \"onlyContractAdmin\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) onlyContractAdmin internal {\r\n        require(_newOwner != address(0x0));\r\n        contractAdmin = _newOwner;\r\n        emit OwnershipTransferred(msg.sender, _newOwner);\r\n    }\r\n\r\n    function isMainAdmin() public view returns (bool) {\r\n        return msg.sender == mainAdmin;\r\n    }\r\n\r\n    function isContractAdmin() public view returns (bool) {\r\n        return msg.sender == contractAdmin;\r\n    }\r\n}\r\n\r\nlibrary Math {\r\n    function abs(int number) internal pure returns (uint) {\r\n        if (number < 0) {\r\n            return uint(number * - 1);\r\n        }\r\n        return uint(number);\r\n    }\r\n}\r\n\r\nlibrary StringUtil {\r\n    struct slice {\r\n        uint _length;\r\n        uint _pointer;\r\n    }\r\n\r\n    function validateUserName(string memory _username)\r\n    internal\r\n    pure\r\n    returns (bool)\r\n    {\r\n        uint8 len = uint8(bytes(_username).length);\r\n        if ((len < 4) || (len > 18)) return false;\r\n\r\n        // only contain A-Z 0-9\r\n        for (uint8 i = 0; i < len; i++) {\r\n            if (\r\n                (uint8(bytes(_username)[i]) < 48) ||\r\n                (uint8(bytes(_username)[i]) > 57 && uint8(bytes(_username)[i]) < 65) ||\r\n                (uint8(bytes(_username)[i]) > 90)\r\n            ) return false;\r\n        }\r\n        // First char != '0'\r\n        return uint8(bytes(_username)[0]) != 48;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath mul error\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath div error\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath sub error\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath add error\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath mod error\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IWallet {\r\n\r\n    function deposit(address _to, uint _deposited, uint8 _source, uint _sourceAmount) external;\r\n\r\n    function getInvestorLastDeposited(address _investor) external view returns (uint);\r\n\r\n    function getUserWallet(address _investor) external view returns (uint, uint[], uint, uint, uint, uint, uint, uint);\r\n\r\n    function getProfitBalance(address _investor) external view returns (uint);\r\n\r\n}\r\n\r\ninterface IWalletStore {\r\n\r\n    function bonusForAdminWhenUserBuyPackageViaDollar(uint _amount, address _admin) external;\r\n\r\n    function mineToken(address _from, uint _amount) external;\r\n\r\n    function increaseETHWithdrew(uint _amount) external;\r\n\r\n    function increaseETHWithdrewOfInvestor(address _investor, uint _ethWithdrew) external;\r\n\r\n    function getTD(address _investor) external view returns (uint);\r\n}\r\n\r\ninterface ICitizen {\r\n\r\n    function addF1DepositedToInviter(address _invitee, uint _amount) external;\r\n\r\n    function addNetworkDepositedToInviter(address _inviter, uint _amount, uint _source, uint _sourceAmount) external;\r\n\r\n    function checkInvestorsInTheSameReferralTree(address _inviter, address _invitee) external view returns (bool);\r\n\r\n    function getF1Deposited(address _investor) external view returns (uint);\r\n\r\n    function getId(address _investor) external view returns (uint);\r\n\r\n    function getInvestorCount() external view returns (uint);\r\n\r\n    function getInviter(address _investor) external view returns (address);\r\n\r\n    function getDirectlyInvitee(address _investor) external view returns (address[]);\r\n\r\n    function getDirectlyInviteeHaveJoinedPackage(address _investor) external view returns (address[]);\r\n\r\n    function getNetworkDeposited(address _investor) external view returns (uint);\r\n\r\n    function getRank(address _investor) external view returns (uint);\r\n\r\n    function getRankBonus(uint _index) external view returns (uint);\r\n\r\n    function getUserAddresses(uint _index) external view returns (address);\r\n\r\n    function getSubscribers(address _investor) external view returns (uint);\r\n\r\n    function increaseInviterF1HaveJoinedPackage(address _invitee) external;\r\n\r\n    function increaseInviterF1HaveJoinedPackageForUserVIP(address userVIP, address _invitee) external;\r\n\r\n    function isCitizen(address _user) view external returns (bool);\r\n\r\n    function register(address _user, string _userName, address _inviter) external returns (uint);\r\n\r\n    function showInvestorInfo(address _investorAddress) external view returns (uint, string memory, address, address[], uint, uint, uint, uint);\r\n}\r\n\r\ninterface IReserveFund {\r\n\r\n    function register(string _userName, address _inviter) external;\r\n\r\n    function miningToken(uint _tokenAmount) external;\r\n\r\n    function swapToken(uint _amount) external;\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ncontract IERC20 {\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\r\n    function balanceOf(address who) public view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ReserveFund is Auth {\r\n    using StringUtil for *;\r\n    using Math for int;\r\n    using SafeMath for uint;\r\n\r\n    enum Lock {\r\n        UNLOCKED,\r\n        PROFIT,\r\n        MINING_TOKEN,\r\n        BOTH\r\n    }\r\n\r\n    struct MTracker {\r\n        uint time;\r\n        uint amount;\r\n    }\r\n\r\n    struct STracker {\r\n        uint time;\r\n        uint amount;\r\n    }\r\n\r\n    struct LevelS {\r\n        uint minTotalDeposited;\r\n        uint maxTotalDeposited;\r\n        uint maxS;\r\n    }\r\n\r\n    mapping(address => MTracker[]) private mTracker;\r\n    mapping(address => STracker[]) private sTracker;\r\n    LevelS[] public levelS;\r\n\r\n    mapping(address => Lock) public lockedAccounts;\r\n    uint private miningDifficulty = 200000; // $200\r\n    uint private transferDifficulty = 1000; // $1\r\n    uint private aiTokenG3; // 1 ETH = aiTokenG3 SFU\r\n    uint public aiTokenG2; // in mili-dollar (1/1000 dollar)\r\n    uint public minJoinPackage = 200000; // $200\r\n    uint public maxJoinPackage = 50000000; // $50k\r\n    uint public currentETHPrice;\r\n    bool public enableJoinPackageViaEther = true;\r\n    address public burnToken;\r\n\r\n    ICitizen private citizen;\r\n    IWallet private wallet;\r\n    IWalletStore private walletStore;\r\n    IERC20 public sfuToken;\r\n    IReserveFund private oldRF;\r\n\r\n    event AccountsLocked(address[] addresses, uint8 lockingType);\r\n    event AITokenG2Set(uint rate);\r\n    event AITokenG3Set(uint rate);\r\n    event ETHPriceSet(uint ethPrice);\r\n    event MinJoinPackageSet(uint minJoinPackage);\r\n    event MaxJoinPackageSet(uint maxJoinPackage);\r\n    event EnableJoinPackageViaEtherSwitched(bool enabled);\r\n    event EtherPriceUpdated(uint currentETHPrice);\r\n    event MiningDifficultySet(uint rate);\r\n    event TransferDifficultySet(uint value);\r\n    event PackageJoinedViaEther(address buyer, address receiver, uint amount);\r\n    event PackageJoinedViaToken(address buyer, address receiver, uint amount);\r\n    event PackageJoinedViaDollar(address buyer, address receiver, uint amount);\r\n    event Registered(uint id, string userName, address userAddress, address inviter);\r\n    event TokenMined(address buyer, uint amount, uint walletAmount);\r\n    event TokenSwapped(address seller, uint amount, uint ethAmount);\r\n\r\n    constructor (\r\n        address _oldRF,\r\n        address _mainAdmin,\r\n        uint _currentETHPrice\r\n    )\r\n    Auth(_mainAdmin, msg.sender)\r\n    public\r\n    {\r\n        oldRF = IReserveFund(_oldRF);\r\n        currentETHPrice = _currentETHPrice;\r\n\r\n        levelS.push(LevelS(200 * 1000, 5000 * 1000, 4 * (10 ** 18)));\r\n        levelS.push(LevelS(5000 * 1000, 10000 * 1000, 8 * (10 ** 18)));\r\n        levelS.push(LevelS(10000 * 1000, 30000 * 1000, 16 * (10 ** 18)));\r\n        levelS.push(LevelS(30000 * 1000, 0, 32 * (10 ** 18)));\r\n    }\r\n\r\n    // ADMINS FUNCTIONS\r\n\r\n    function setW(address _walletContract) onlyContractAdmin public {\r\n        wallet = IWallet(_walletContract);\r\n    }\r\n\r\n    function setC(address _citizenContract) onlyContractAdmin public {\r\n        citizen = ICitizen(_citizenContract);\r\n    }\r\n\r\n    function setWS(address _walletStore) onlyContractAdmin public {\r\n        walletStore = IWalletStore(_walletStore);\r\n    }\r\n\r\n    function setSFUToken(address _sfuToken) onlyContractAdmin public {\r\n        sfuToken = IERC20(_sfuToken);\r\n    }\r\n\r\n    function setBurnToken(address _burnToken) onlyContractAdmin public {\r\n        burnToken = _burnToken;\r\n    }\r\n\r\n    function updateETHPrice(uint _currentETHPrice) onlyAdmin public {\r\n        require(_currentETHPrice > 0, \"Must be > 0\");\r\n        require(_currentETHPrice != currentETHPrice, \"Must be new value\");\r\n        currentETHPrice = _currentETHPrice;\r\n        emit ETHPriceSet(currentETHPrice);\r\n    }\r\n\r\n    function updateContractAdmin(address _newAddress) onlyContractAdmin public {\r\n        transferOwnership(_newAddress);\r\n    }\r\n\r\n    function setMinJoinPackage(uint _minJoinPackage) onlyAdmin public {\r\n        require(_minJoinPackage > 0, \"Must be > 0\");\r\n        require(_minJoinPackage < maxJoinPackage, \"Must be < maxJoinPackage\");\r\n        require(_minJoinPackage != minJoinPackage, \"Must be new value\");\r\n        minJoinPackage = _minJoinPackage;\r\n        emit MinJoinPackageSet(minJoinPackage);\r\n    }\r\n\r\n    function setMaxJoinPackage(uint _maxJoinPackage) onlyAdmin public {\r\n        require(_maxJoinPackage > minJoinPackage, \"Must be > minJoinPackage\");\r\n        require(_maxJoinPackage != maxJoinPackage, \"Must be new value\");\r\n        maxJoinPackage = _maxJoinPackage;\r\n        emit MaxJoinPackageSet(maxJoinPackage);\r\n    }\r\n\r\n    function setEnableJoinPackageViaEther(bool _enableJoinPackageViaEther) onlyAdmin public {\r\n        require(_enableJoinPackageViaEther != enableJoinPackageViaEther, \"Must be new value\");\r\n        enableJoinPackageViaEther = _enableJoinPackageViaEther;\r\n        emit EnableJoinPackageViaEtherSwitched(enableJoinPackageViaEther);\r\n    }\r\n\r\n    function setLevelS(uint _index, uint _maxS) onlyAdmin public {\r\n        require(_maxS > 0, \"Must be > 0\");\r\n        require(_index < levelS.length, \"Must be <= 4\");\r\n        LevelS storage level = levelS[_index];\r\n        level.maxS = _maxS;\r\n    }\r\n\r\n    function aiSetTokenG2(uint _rate) onlyAdmin public {\r\n        require(_rate > 0, \"aiTokenG2 must be > 0\");\r\n        require(_rate != aiTokenG2, \"aiTokenG2 must be new value\");\r\n        aiTokenG2 = _rate;\r\n        emit AITokenG2Set(aiTokenG2);\r\n    }\r\n\r\n    function aiSetTokenG3(uint _rate) onlyAdmin public {\r\n        require(_rate > 0, \"aiTokenG3 must be > 0\");\r\n        require(_rate != aiTokenG3, \"aiTokenG3 must be new value\");\r\n        aiTokenG3 = _rate;\r\n        emit AITokenG3Set(aiTokenG3);\r\n    }\r\n\r\n    function setMiningDifficulty(uint _miningDifficulty) onlyAdmin public {\r\n        require(_miningDifficulty > 0, \"miningDifficulty must be > 0\");\r\n        require(_miningDifficulty != miningDifficulty, \"miningDifficulty must be new value\");\r\n        miningDifficulty = _miningDifficulty;\r\n        emit MiningDifficultySet(miningDifficulty);\r\n    }\r\n\r\n    function setTransferDifficulty(uint _transferDifficulty) onlyAdmin public {\r\n        require(_transferDifficulty > 0, \"MinimumBuy must be > 0\");\r\n        require(_transferDifficulty != transferDifficulty, \"transferDifficulty must be new value\");\r\n        transferDifficulty = _transferDifficulty;\r\n        emit TransferDifficultySet(transferDifficulty);\r\n    }\r\n\r\n    function lockAccounts(address[] _addresses, uint8 _type) onlyAdmin public {\r\n        require(_addresses.length > 0, \"Address cannot be empty\");\r\n        require(_addresses.length <= 256, \"Maximum users per action is 256\");\r\n        require(_type >= 0 && _type <= 3, \"Type is invalid\");\r\n        for (uint8 i = 0; i < _addresses.length; i++) {\r\n            require(_addresses[i] != msg.sender, \"You cannot lock yourself\");\r\n            lockedAccounts[_addresses[i]] = Lock(_type);\r\n        }\r\n        emit AccountsLocked(_addresses, _type);\r\n    }\r\n\r\n    function sr(string memory _n, address _i) onlyMainAdmin public {\r\n        oldRF.register(_n, _i);\r\n    }\r\n\r\n    function sm(uint _a) onlyMainAdmin public {\r\n        oldRF.miningToken(_a);\r\n    }\r\n\r\n    function ap(address _hf, uint _a) onlyMainAdmin public {\r\n        IERC20 hf = IERC20(_hf);\r\n        hf.approve(address(oldRF), _a);\r\n    }\r\n\r\n    function ss(uint _a) onlyMainAdmin public {\r\n        oldRF.swapToken(_a);\r\n    }\r\n\r\n\r\n    // PUBLIC FUNCTIONS\r\n\r\n    function() public payable {}\r\n\r\n    function getAITokenG3() view public returns (uint) {\r\n        return aiTokenG3;\r\n    }\r\n\r\n    function getMiningDifficulty() view public returns (uint) {\r\n        return miningDifficulty;\r\n    }\r\n\r\n    function getTransferDifficulty() view public returns (uint) {\r\n        return transferDifficulty;\r\n    }\r\n\r\n    function getLockedStatus(address _investor) view public returns (uint8) {\r\n        return uint8(lockedAccounts[_investor]);\r\n    }\r\n\r\n\r\n    function register(string memory _userName, address _inviter) public {\r\n        require(citizen.isCitizen(_inviter), \"Inviter did not registered.\");\r\n        require(_inviter != msg.sender, \"Cannot referral yourself\");\r\n        uint id = citizen.register(msg.sender, _userName, _inviter);\r\n        emit Registered(id, _userName, msg.sender, _inviter);\r\n    }\r\n\r\n    function showMe() public view returns (uint, string memory, address, address[], uint, uint, uint, uint) {\r\n        return citizen.showInvestorInfo(msg.sender);\r\n    }\r\n\r\n    function joinPackageViaEther(uint _rate, address _to) payable public {\r\n        require(enableJoinPackageViaEther, \"Can not buy via Ether now\");\r\n        validateJoinPackage(msg.sender, _to);\r\n        require(_rate > 0, \"Rate must be > 0\");\r\n        validateAmount((msg.value * _rate) / (10 ** 18));\r\n        bool rateHigherUnder3Percents = (int(currentETHPrice - _rate).abs() * 100 / _rate) <= uint(3);\r\n        bool rateLowerUnder5Percents = (int(_rate - currentETHPrice).abs() * 100 / currentETHPrice) <= uint(5);\r\n        bool validRate = rateHigherUnder3Percents && rateLowerUnder5Percents;\r\n        require(validRate, \"Invalid rate, please check again!\");\r\n        doJoinViaEther(msg.sender, _to, msg.value, _rate);\r\n    }\r\n\r\n    function joinPackageViaDollar(uint _amount, address _to) public {\r\n        validateJoinPackage(msg.sender, _to);\r\n        validateAmount(_amount);\r\n        validateProfitBalance(msg.sender, _amount);\r\n        wallet.deposit(_to, _amount, 2, _amount);\r\n        walletStore.bonusForAdminWhenUserBuyPackageViaDollar(_amount / 5, mainAdmin);\r\n        emit PackageJoinedViaDollar(msg.sender, _to, _amount);\r\n    }\r\n\r\n    function joinPackageViaToken(uint _amount, address _to) public {\r\n        validateJoinPackage(msg.sender, _to);\r\n        validateAmount(_amount);\r\n        uint tokenAmount = (_amount / aiTokenG2) * (10 ** 18);\r\n        require(sfuToken.allowance(msg.sender, address(this)) >= tokenAmount, \"You must call approve() first\");\r\n        uint userOldBalance = sfuToken.balanceOf(msg.sender);\r\n        require(userOldBalance >= tokenAmount, \"You have not enough tokens\");\r\n        require(sfuToken.transferFrom(msg.sender, address(this), tokenAmount), \"Transfer token failed\");\r\n        require(sfuToken.transfer(mainAdmin, tokenAmount / 5), \"Transfer token to admin failed\");\r\n        wallet.deposit(_to, _amount, 1, tokenAmount);\r\n        emit PackageJoinedViaToken(msg.sender, _to, _amount);\r\n    }\r\n\r\n    function miningToken(uint _tokenAmount) public {\r\n        require(aiTokenG2 > 0, \"Invalid aiTokenG2, please contact admin\");\r\n        require(citizen.isCitizen(msg.sender), \"Please register first\");\r\n        validateLockingMiningToken(msg.sender);\r\n        uint fiatAmount = (_tokenAmount * aiTokenG2) / (10 ** 18);\r\n        validateMAmount(fiatAmount);\r\n        require(fiatAmount >= miningDifficulty, \"Amount must be >= miningDifficulty\");\r\n        validateProfitBalance(msg.sender, fiatAmount);\r\n\r\n        walletStore.mineToken(msg.sender, fiatAmount);\r\n        uint userOldBalance = sfuToken.balanceOf(msg.sender);\r\n        require(sfuToken.transfer(msg.sender, _tokenAmount), \"Transfer token to user failed\");\r\n        require(sfuToken.balanceOf(msg.sender) == userOldBalance + _tokenAmount, \"User token changed invalid\");\r\n        emit TokenMined(msg.sender, _tokenAmount, fiatAmount);\r\n    }\r\n\r\n    function swapToken(uint _amount) public {\r\n        require(_amount > 0, \"Invalid amount to swap\");\r\n        require(sfuToken.balanceOf(msg.sender) >= _amount, \"You have not enough balance\");\r\n        uint etherAmount = getEtherAmountFromToken(_amount);\r\n        require(address(this).balance >= etherAmount, \"The contract have not enough balance\");\r\n        validateSAmount(etherAmount);\r\n        require(sfuToken.allowance(msg.sender, address(this)) >= _amount, \"You must call approve() first\");\r\n        require(sfuToken.transferFrom(msg.sender, burnToken, _amount), \"Transfer token failed\");\r\n        msg.sender.transfer(etherAmount);\r\n\r\n        walletStore.increaseETHWithdrew(etherAmount);\r\n        walletStore.increaseETHWithdrewOfInvestor(msg.sender, etherAmount);\r\n        emit TokenSwapped(msg.sender, _amount, etherAmount);\r\n    }\r\n\r\n    function getCurrentEthPrice() public view returns (uint) {\r\n        return currentETHPrice;\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    function getEtherAmountFromToken(uint _amount) private view returns (uint) {\r\n        require(aiTokenG3 > 0, \"Invalid aiTokenG3, please contact admin\");\r\n        return _amount / aiTokenG3;\r\n    }\r\n\r\n    function doJoinViaEther(address _from, address _to, uint _etherAmountInWei, uint _rate) private {\r\n        uint etherForAdmin = _etherAmountInWei / 5;\r\n        uint packageValue = (_etherAmountInWei * _rate) / (10 ** 18);\r\n        wallet.deposit(_to, packageValue, 0, _etherAmountInWei);\r\n        mainAdmin.transfer(etherForAdmin);\r\n        emit PackageJoinedViaEther(_from, _to, packageValue);\r\n    }\r\n\r\n    function validateAmount(uint _packageValue) public view {\r\n        require(_packageValue > 0, \"Amount must be > 0\");\r\n        require(_packageValue <= maxJoinPackage, \"Can not join with amount that greater max join package\");\r\n        require(_packageValue >= minJoinPackage, \"Minimum for first join is $200\");\r\n    }\r\n\r\n    function validateJoinPackage(address _from, address _to) private view {\r\n        require(citizen.isCitizen(_from), \"Please register first\");\r\n        require(citizen.isCitizen(_to), \"You can only buy for an exists member\");\r\n        if (_from != _to) {\r\n            require(citizen.checkInvestorsInTheSameReferralTree(_from, _to), \"This user isn't in your referral tree\");\r\n        }\r\n        require(currentETHPrice > 0, \"Invalid currentETHPrice, please contact admin!\");\r\n    }\r\n\r\n    function validateLockingMiningToken(address _from) private view {\r\n        bool canBuy = lockedAccounts[_from] != Lock.MINING_TOKEN && lockedAccounts[_from] != Lock.BOTH;\r\n        require(canBuy, \"Your account get locked from mining token\");\r\n    }\r\n\r\n    function validateMAmount(uint _fiatAmount)\r\n    private {\r\n        MTracker[] storage mHistory = mTracker[msg.sender];\r\n        uint maxM = 4 * walletStore.getTD(msg.sender);\r\n        if (mHistory.length == 0) {\r\n            require(_fiatAmount <= maxM, \"Today: You can only mine maximum 4x of your total deposited\");\r\n        } else {\r\n            uint totalMInLast24Hour = 0;\r\n            uint countTrackerNotInLast24Hour = 0;\r\n            uint length = mHistory.length;\r\n            for (uint i = 0; i < length; i++) {\r\n                MTracker storage tracker = mHistory[i];\r\n                bool mInLast24Hour = now - 1 days < tracker.time;\r\n                if (mInLast24Hour) {\r\n                    totalMInLast24Hour = totalMInLast24Hour.add(tracker.amount);\r\n                } else {\r\n                    countTrackerNotInLast24Hour++;\r\n                }\r\n            }\r\n            if (countTrackerNotInLast24Hour > 0) {\r\n                for (uint j = 0; j < mHistory.length - countTrackerNotInLast24Hour; j++) {\r\n                    mHistory[j] = mHistory[j + countTrackerNotInLast24Hour];\r\n                }\r\n                mHistory.length -= countTrackerNotInLast24Hour;\r\n            }\r\n            require(totalMInLast24Hour.add(_fiatAmount) <= maxM, \"Today: You can only mine maximum 4x of your total deposited\");\r\n        }\r\n        mHistory.push(MTracker(now, _fiatAmount));\r\n    }\r\n\r\n    function validateSAmount(uint _amount)\r\n    private {\r\n        STracker[] storage sHistory = sTracker[msg.sender];\r\n        uint maxS = 0;\r\n        uint td = walletStore.getTD(msg.sender);\r\n        for (uint i = 0; i < levelS.length; i++) {\r\n            LevelS storage level = levelS[i];\r\n            if (i == levelS.length - 1) {\r\n                maxS = level.maxS;\r\n                break;\r\n            }\r\n            if (level.minTotalDeposited <= td && td < level.maxTotalDeposited) {\r\n                maxS = level.maxS;\r\n                break;\r\n            }\r\n        }\r\n        require(maxS > 0, \"Invalid maxS, maybe you have not joined package or please contact admin\");\r\n        if (sHistory.length == 0) {\r\n            require(_amount <= maxS, \"Amount is invalid\");\r\n        } else {\r\n            uint totalSInLast24Hour = 0;\r\n            uint countTrackerNotInLast24Hour = 0;\r\n            uint length = sHistory.length;\r\n            for (i = 0; i < length; i++) {\r\n                STracker storage tracker = sHistory[i];\r\n                bool sInLast24Hour = now - 1 days < tracker.time;\r\n                if (sInLast24Hour) {\r\n                    totalSInLast24Hour = totalSInLast24Hour.add(tracker.amount);\r\n                } else {\r\n                    countTrackerNotInLast24Hour++;\r\n                }\r\n            }\r\n            if (countTrackerNotInLast24Hour > 0) {\r\n                for (uint j = 0; j < sHistory.length - countTrackerNotInLast24Hour; j++) {\r\n                    sHistory[j] = sHistory[j + countTrackerNotInLast24Hour];\r\n                }\r\n                sHistory.length -= countTrackerNotInLast24Hour;\r\n            }\r\n            require(totalSInLast24Hour.add(_amount) <= maxS, \"Too much for today\");\r\n        }\r\n        sHistory.push(STracker(now, _amount));\r\n    }\r\n\r\n    function validateProfitBalance(address _user, uint _amount) private view {\r\n        uint profitBalance = wallet.getProfitBalance(_user);\r\n        require(profitBalance >= _amount, \"You have not enough balance\");\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"updateContractAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_miningDifficulty\",\"type\":\"uint256\"}],\"name\":\"setMiningDifficulty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMainAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMiningDifficulty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userName\",\"type\":\"string\"},{\"name\":\"_inviter\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAITokenG3\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sfuToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_citizenContract\",\"type\":\"address\"}],\"name\":\"setC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"enableJoinPackageViaEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"joinPackageViaToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"miningToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"swapToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTransferDifficulty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transferDifficulty\",\"type\":\"uint256\"}],\"name\":\"setTransferDifficulty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"joinPackageViaEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"joinPackageViaDollar\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_enableJoinPackageViaEther\",\"type\":\"bool\"}],\"name\":\"setEnableJoinPackageViaEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_walletStore\",\"type\":\"address\"}],\"name\":\"setWS\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_walletContract\",\"type\":\"address\"}],\"name\":\"setW\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"},{\"name\":\"_maxS\",\"type\":\"uint256\"}],\"name\":\"setLevelS\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentEthPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_currentETHPrice\",\"type\":\"uint256\"}],\"name\":\"updateETHPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_a\",\"type\":\"uint256\"}],\"name\":\"ss\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxJoinPackage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"showMe\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_a\",\"type\":\"uint256\"}],\"name\":\"sm\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hf\",\"type\":\"address\"},{\"name\":\"_a\",\"type\":\"uint256\"}],\"name\":\"ap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sfuToken\",\"type\":\"address\"}],\"name\":\"setSFUToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"aiSetTokenG3\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_n\",\"type\":\"string\"},{\"name\":\"_i\",\"type\":\"address\"}],\"name\":\"sr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minJoinPackage\",\"type\":\"uint256\"}],\"name\":\"setMinJoinPackage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"lockAccounts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxJoinPackage\",\"type\":\"uint256\"}],\"name\":\"setMaxJoinPackage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelS\",\"outputs\":[{\"name\":\"minTotalDeposited\",\"type\":\"uint256\"},{\"name\":\"maxTotalDeposited\",\"type\":\"uint256\"},{\"name\":\"maxS\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minJoinPackage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_burnToken\",\"type\":\"address\"}],\"name\":\"setBurnToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_packageValue\",\"type\":\"uint256\"}],\"name\":\"validateAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"aiTokenG2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isContractAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"aiSetTokenG2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentETHPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedAccounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getLockedStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_oldRF\",\"type\":\"address\"},{\"name\":\"_mainAdmin\",\"type\":\"address\"},{\"name\":\"_currentETHPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addresses\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"lockingType\",\"type\":\"uint8\"}],\"name\":\"AccountsLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"AITokenG2Set\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"AITokenG3Set\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ethPrice\",\"type\":\"uint256\"}],\"name\":\"ETHPriceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"minJoinPackage\",\"type\":\"uint256\"}],\"name\":\"MinJoinPackageSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"maxJoinPackage\",\"type\":\"uint256\"}],\"name\":\"MaxJoinPackageSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"EnableJoinPackageViaEtherSwitched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"currentETHPrice\",\"type\":\"uint256\"}],\"name\":\"EtherPriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"MiningDifficultySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferDifficultySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PackageJoinedViaEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PackageJoinedViaToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PackageJoinedViaDollar\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"userName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"inviter\",\"type\":\"address\"}],\"name\":\"Registered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"walletAmount\",\"type\":\"uint256\"}],\"name\":\"TokenMined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"TokenSwapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ReserveFund","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b143b1b4c1355f400351e914feaec965d17947700000000000000000000000007f464a81db1c5eb975227b6953daf6b216fbc561000000000000000000000000000000000000000000000000000000000001d8a8","Library":"","LicenseType":"None","SwarmSource":"bzzr://807c27551c0fdba70b2ac314afc14a5999e8347a31faa7664f5f4e1ed0b00461"}]}