{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\n// OpenZeppelin https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an `address` into `address payable`. Note that this is\\r\\n     * simply a type cast: the actual underlying value is not changed.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function toPayable(address account) internal pure returns (address payable) {\\r\\n        return address(uint160(account));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\"},\"AucReceiverInterface.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\n/**\\r\\n * @title AucReceiverInterface\\r\\n * @dev Contract interface to receive Auc through an EIP 223 transfer.\\r\\n */\\r\\ninterface AucReceiverInterface {\\r\\n\\tfunction tokenFallback(address from, uint256 amount, bytes calldata data) external;\\r\\n}\"},\"DPiggy.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\nimport \\\"SafeMath.sol\\\";\\r\\nimport \\\"EIP20Interface.sol\\\";\\r\\nimport \\\"AucReceiverInterface.sol\\\";\\r\\nimport \\\"UniswapFactoryInterface.sol\\\";\\r\\nimport \\\"DPiggyInterface.sol\\\";\\r\\nimport \\\"DPiggyAssetInterface.sol\\\";\\r\\nimport \\\"DPiggyBaseProxyInterface.sol\\\";\\r\\nimport \\\"DPiggyAssetProxy.sol\\\";\\r\\nimport \\\"DPiggyData.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title DPiggy\\r\\n * @dev The contract is proxied for dPiggyProxy.\\r\\n * It is the implementation of the gateway contract for dPiggy.\\r\\n * The contract manages all assets and general data for dPiggy system.\\r\\n */\\r\\ncontract DPiggy is DPiggyData, DPiggyInterface, AucReceiverInterface {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to initialize the contract.\\r\\n     * It should be called through the `data` argument when creating the proxy.\\r\\n     * It must be called only once. The `assert` is to guarantee that behavior.\\r\\n     * @param _percentagePrecision The percentage precision. The value represents the 100%.\\r\\n     * @param _dailyFee The daily fee percentage (with percentage precision).\\r\\n     * @param _maximumDailyFee The maximum value that can be defined for the daily fee percentage.\\r\\n     * @param _minimumAucToFreeFee The minimum amount of Auc escrowed to have the fee exemption.\\r\\n     * @param _dai Address for the Dai token contract.\\r\\n     * @param _compound Address for the cDai (the Compound contract).\\r\\n     * @param _uniswapFactory Address for the Uniswap factory contract.\\r\\n     * @param _auc Address for the Auc token contract.\\r\\n     * @param _assetImplementation Address for the asset base implementation contract.\\r\\n     */\\r\\n    function init(\\r\\n        uint256 _percentagePrecision,\\r\\n        uint256 _dailyFee,\\r\\n        uint256 _maximumDailyFee,\\r\\n        uint256 _minimumAucToFreeFee,\\r\\n        address _dai,\\r\\n        address _compound,\\r\\n        address _uniswapFactory,\\r\\n        address _auc,\\r\\n        address _assetImplementation) public {\\r\\n        \\r\\n        assert(\\r\\n            assetImplementation == address(0) \\u0026\\u0026 \\r\\n            auc == address(0) \\u0026\\u0026 \\r\\n            dai == address(0) \\u0026\\u0026 \\r\\n            percentagePrecision == 0 \\u0026\\u0026 \\r\\n            maximumDailyFee == 0\\r\\n        );\\r\\n        \\r\\n        require(_dailyFee \\u003c= _maximumDailyFee, \\\"DPiggy::init: Invalid fee\\\");\\r\\n        \\r\\n        percentagePrecision = _percentagePrecision;\\r\\n        dailyFee = _dailyFee;\\r\\n        maximumDailyFee = _maximumDailyFee;\\r\\n        minimumAucToFreeFee = _minimumAucToFreeFee;\\r\\n        dai = _dai;\\r\\n        auc = _auc;\\r\\n        compound = _compound;\\r\\n        assetImplementation = _assetImplementation;\\r\\n        uniswapFactory = _uniswapFactory;\\r\\n        \\r\\n        //Set Dai Uniswap exchange using the uniswapFactory address.\\r\\n        setExchange();\\r\\n        \\r\\n        /* Initialize the stored data that controls the reentrancy guard.\\r\\n         * Due to the proxy, it must be set on a separate initialize method instead of the constructor.\\r\\n         */\\r\\n        _notEntered = true;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to guarantee that the contract will not receive ether.\\r\\n     */\\r\\n    receive() external payable {\\r\\n        revert();\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to calculate the Compound redeem fee.\\r\\n     * It calculates how many days the argument represents then it is calculated:\\r\\n     * (100% + `dailyFee`)^(number of days) - 100%\\r\\n     * @param baseTime Period of time in seconds. It is not a Unix time.\\r\\n     * @return Fee for the amount of time informed with a dPiggy percentage precision.\\r\\n     */\\r\\n    function executionFee(uint256 baseTime) external override(DPiggyInterface) view returns(uint256) {\\r\\n        uint256 daysAmount = baseTime / 86400;\\r\\n        if (daysAmount == 0) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            uint256 pow = percentagePrecision + dailyFee;\\r\\n            uint256 base = pow;\\r\\n            for (uint256 i = 1; i \\u003c daysAmount; ++i) {\\r\\n                pow = (base * pow / percentagePrecision);\\r\\n            }\\r\\n            return pow - percentagePrecision;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to return the escrow start time.\\r\\n     * @param user User\\u0027s address.\\r\\n     * @return The Unix time for user escrow start. Zero means no escrow.\\r\\n     */\\r\\n    function escrowStart(address user) external override(DPiggyInterface) view returns(uint256) {\\r\\n        EscrowData storage escrow = usersEscrow[user];\\r\\n        return escrow.time;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Forwarding function to dPiggy asset to get the total amount of Dai deposited.\\r\\n     * @param tokenAddress The ERC20 token address on the chain or \\u00270x0\\u0027 for Ethereum. \\r\\n     * @return The total amount of Dai deposited.\\r\\n     */\\r\\n    function getTotalInvested(address tokenAddress) external view returns(uint256) {\\r\\n        return _getValueFromAsset(tokenAddress, abi.encodeWithSignature(\\\"totalBalance()\\\"));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Forwarding function to dPiggy asset to get the minimum time for the next Compound redeem execution.\\r\\n     * @param tokenAddress The ERC20 token address on the chain or \\u00270x0\\u0027 for Ethereum. \\r\\n     * @return The minimum time in Unix for the next Compound redeem execution.\\r\\n     */\\r\\n    function getMinimumTimeForNextExecution(address tokenAddress) external view returns(uint256) {\\r\\n        return _getValueFromAsset(tokenAddress, abi.encodeWithSignature(\\\"getMinimumTimeForNextExecution()\\\"));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the minimum amount of Dai allowed to deposit on the asset.\\r\\n     * @param tokenAddress The ERC20 token address on the chain or \\u00270x0\\u0027 for Ethereum. \\r\\n     * @return The minimum amount of Dai allowed to deposit on the asset.\\r\\n     */\\r\\n    function getMinimumDeposit(address tokenAddress) external view returns(uint256) {\\r\\n        AssetData storage assetData = assetsData[tokenAddress];\\r\\n        if (assetData.time \\u003e 0) {\\r\\n            return assetData.minimumDeposit;\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Forwarding function to dPiggy asset to get the user\\u0027s Dai gross profit, asset net profit and the fee amount in Dai.\\r\\n     * @param tokenAddress The ERC20 token address on the chain or \\u00270x0\\u0027 for Ethereum. \\r\\n     * @param user User\\u0027s address. \\r\\n     * @return The user\\u0027s Dai gross profit, asset net profit and the fee amount charged in Dai. \\r\\n     * First return is the gross profit in Dai.\\r\\n     * Second return is the asset net profit.\\r\\n     * Third return is the fee amount charged in Dai.\\r\\n     */\\r\\n    function getUserProfitsAndFeeAmount(address tokenAddress, address user) external view returns(uint256, uint256, uint256) {\\r\\n        AssetData storage assetData = assetsData[tokenAddress];\\r\\n        if (assetData.time \\u003e 0) {\\r\\n            return DPiggyAssetInterface(assetData.proxy).getUserProfitsAndFeeAmount(user);\\r\\n        }\\r\\n        return (0, 0, 0);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Forwarding function to dPiggy asset to get the estimated current gross profit in Dai for the user.\\r\\n     * So it is not the total gross profit, it is only for the user amount of Dai on the next Compound redeem execution.\\r\\n     * The estimative to the amount of Dai on the Compound redeem execution considering the Compound exchange rate now.\\r\\n     * For an estimated total of the gross profit: `getUserProfit` + `getUserEstimatedCurrentProfitWithoutFee`.\\r\\n     * @param tokenAddress The ERC20 token address on the chain or \\u00270x0\\u0027 for Ethereum. \\r\\n     * @param user User\\u0027s address. \\r\\n     * @return The estimated gross profit in Dai. \\r\\n     */\\r\\n    function getUserEstimatedCurrentProfitWithoutFee(address tokenAddress, address user) external view returns(uint256) {\\r\\n        return _getValueFromAsset(tokenAddress, abi.encodeWithSignature(\\\"getUserEstimatedCurrentProfitWithoutFee(address)\\\", user));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Forwarding function to dPiggy asset to get the estimated current fee in Dai for the user.\\r\\n     * To estimate the amount of fee on the Compound redeem execution, it is calculated by the difference between the `time` and the last execution time.\\r\\n     * So it is not the total amount of fee, for an estimated total of the fee in Dai: \\r\\n     * `getUserAssetProfitAndFeeAmount(second return)` + `getUserEstimatedCurrentFee`.\\r\\n     * @param tokenAddress The ERC20 token address on the chain or \\u00270x0\\u0027 for Ethereum. \\r\\n     * @param user User\\u0027s address. \\r\\n     * @param time The Unix time to calculate the fee. It should be the current Unix time. \\r\\n     * @return The estimated fee in Dai. \\r\\n     */\\r\\n    function getUserEstimatedCurrentFee(address tokenAddress, address user, uint256 time) external view returns(uint256) {\\r\\n        return _getValueFromAsset(tokenAddress, abi.encodeWithSignature(\\\"getUserEstimatedCurrentFee(address,uint256)\\\", user, time));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Forwarding function to dPiggy asset to get the amount of asset redeemed for the user.\\r\\n     * @param tokenAddress The ERC20 token address on the chain or \\u00270x0\\u0027 for Ethereum. \\r\\n     * @param user User\\u0027s address. \\r\\n     * @return The amount of asset redeemed. \\r\\n     */\\r\\n    function getUserAssetRedeemed(address tokenAddress, address user) external view returns(uint256) {\\r\\n        return _getValueFromAsset(tokenAddress, abi.encodeWithSignature(\\\"getUserAssetRedeemed(address)\\\", user));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Forwarding function to dPiggy asset to get the amount of Dai deposited for the user.\\r\\n     * @param tokenAddress The ERC20 token address on the chain or \\u00270x0\\u0027 for Ethereum. \\r\\n     * @param user User\\u0027s address. \\r\\n     * @return The amount of Dai deposited. \\r\\n     */\\r\\n    function getUserTotalInvested(address tokenAddress, address user) external view returns(uint256) {\\r\\n        return _getValueFromAsset(tokenAddress, abi.encodeWithSignature(\\\"getUserTotalInvested(address)\\\", user));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to set Dai Uniswap exchange using the uniswapFactory address.\\r\\n     * It is public because uses fixed and controlled parameters.\\r\\n     */\\r\\n    function setExchange() public {\\r\\n        exchange = UniswapFactoryInterface(uniswapFactory).getExchange(dai);  \\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to set the daily fee.\\r\\n     * Only can be called by the admin.\\r\\n     * The new value must be lower than the stored maximum daily fee.\\r\\n     * @param _dailyFee New daily fee with dPiggy percentage precision.\\r\\n     */\\r\\n    function setDailyFee(uint256 _dailyFee) onlyAdmin external {\\r\\n        require(_dailyFee \\u003c= maximumDailyFee, \\\"DPiggy::setDailyFee: Invalid fee\\\");\\r\\n        uint256 oldDailyFee = dailyFee;\\r\\n        dailyFee = _dailyFee;\\r\\n        emit SetDailyFee(_dailyFee, oldDailyFee);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to set the minimum amount of Auc escrowed to have the fee exemption.\\r\\n     * Only can be called by the admin.\\r\\n     * @param _minimumAucToFreeFee New minimum amount of Auc.\\r\\n     */\\r\\n    function setMinimumAucToFreeFee(uint256 _minimumAucToFreeFee) onlyAdmin external {\\r\\n        uint256 oldMinimumAucToFreeFee = minimumAucToFreeFee;\\r\\n        minimumAucToFreeFee = _minimumAucToFreeFee;\\r\\n        emit SetMinimumAucToFreeFee(_minimumAucToFreeFee, oldMinimumAucToFreeFee);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to set the implementation address for the dPiggy assets proxy.\\r\\n     * Only can be called by the admin.\\r\\n     * @param _assetImplementation New implementation contract address.\\r\\n     * @param updateData (optional) ABI encoded with signature data that will be delegated on the new implementation.\\r\\n     */\\r\\n    function setAssetImplementation(address _assetImplementation, bytes calldata updateData) onlyAdmin external payable {\\r\\n        for (uint256 i = 0; i \\u003c assets.length; i++) {\\r\\n            AssetData storage assetData = assetsData[assets[i]];\\r\\n            DPiggyBaseProxyInterface(assetData.proxy).setImplementation(_assetImplementation, updateData);\\r\\n        }\\r\\n        \\r\\n        assetImplementation = _assetImplementation;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to create a new dPiggy asset.\\r\\n     * Only can be called by the admin.\\r\\n     * The asset cannot already exist on dPiggy.\\r\\n     * A DPiggyAssetProxy is created using the `assetImplementation` address.\\r\\n     * dPiggy contract is the admin for this proxy.\\r\\n     * @param tokenAddress The ERC20 token address on the chain or \\u00270x0\\u0027 for Ethereum. \\r\\n     * @param minimumDeposit The minimum amount of Dai that can be deposited for the asset.\\r\\n     * @param creationData ABI encoded with signature data that will be delegated on the new implementation.\\r\\n     */\\r\\n    function createAsset(\\r\\n        address tokenAddress, \\r\\n        uint256 minimumDeposit,\\r\\n        bytes calldata creationData\\r\\n    ) onlyAdmin external payable {     \\r\\n        \\r\\n        AssetData storage assetData = assetsData[tokenAddress];\\r\\n        require(assetData.time == 0, \\\"DPiggy::createAsset: Asset already exists\\\");\\r\\n        assetData.time = now;\\r\\n        assetData.depositAllowed = false;\\r\\n        assetData.minimumDeposit = minimumDeposit;\\r\\n        assetData.proxy = address(new DPiggyAssetProxy(address(this), assetImplementation, creationData));\\r\\n        \\r\\n        assets.push(tokenAddress);\\r\\n        numberOfAssets++;\\r\\n        \\r\\n        emit SetNewAsset(tokenAddress, assetData.proxy); \\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to set the deposit permission for dPiggy asset.\\r\\n     * Only can be called by the admin.\\r\\n     * Both array parameters must be the same size because the value is set through the same array index position.\\r\\n     * @param tokenAddresses Array with ERC20 token addresses or \\u00270x0\\u0027 for Ethereum. The asset must already exist on dPiggy.\\r\\n     * @param allowed Array with the deposit permission conditions.\\r\\n     */\\r\\n    function setAssetsDepositAllowed(address[] calldata tokenAddresses, bool[] calldata allowed) onlyAdmin external {\\r\\n        require(tokenAddresses.length \\u003e 0, \\\"DPiggy::setAssetsDepositAllowed: tokenAddresses is required\\\");\\r\\n        require(tokenAddresses.length == allowed.length, \\\"DPiggy::setAssetsDepositAllowed: Invalid data\\\");\\r\\n        \\r\\n        for (uint256 i = 0; i \\u003c tokenAddresses.length; i++) {\\r\\n            AssetData storage assetData = assetsData[tokenAddresses[i]];\\r\\n            if (assetData.time \\u003e 0) {\\r\\n                bool oldDepositAllowed = assetData.depositAllowed;\\r\\n                assetData.depositAllowed = allowed[i];\\r\\n                emit SetAssetDepositAllowed(tokenAddresses[i], allowed[i], oldDepositAllowed);\\r\\n            }\\r\\n        }   \\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to set the minimum amount of Dai allowed to deposit on dPiggy asset.\\r\\n     * Only can be called by the admin.\\r\\n     * Both array parameters must be the same size because the value is set through the same array index position.\\r\\n     * @param tokenAddresses Array with ERC20 token addresses or \\u00270x0\\u0027 for Ethereum. The asset must already exist on dPiggy.\\r\\n     * @param minimumDeposits Array with the minimum amount of Dai allowed for deposit.\\r\\n     */\\r\\n    function setAssetsMinimumDeposit(address[] calldata tokenAddresses, uint256[] calldata minimumDeposits) onlyAdmin external {\\r\\n        require(tokenAddresses.length \\u003e 0, \\\"DPiggy::setAssetsMinimumDeposit: tokenAddresses is required\\\");\\r\\n        require(tokenAddresses.length == minimumDeposits.length, \\\"DPiggy::setAssetsMinimumDeposit: Invalid data\\\");\\r\\n        \\r\\n        for (uint256 i = 0; i \\u003c tokenAddresses.length; i++) {\\r\\n            AssetData storage assetData = assetsData[tokenAddresses[i]];\\r\\n            if (assetData.time \\u003e 0) {\\r\\n                uint256 oldMinimumDeposit = assetData.minimumDeposit;\\r\\n                assetData.minimumDeposit = minimumDeposits[i];\\r\\n                emit SetAssetMinimumDeposit(tokenAddresses[i], minimumDeposits[i], oldMinimumDeposit);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Forwarding function to dPiggy asset to set the minimum time between the Compound redeem executions for a dPiggy asset.\\r\\n     * Only can be called by the admin.\\r\\n     * @param tokenAddress The ERC20 token address on the chain or \\u00270x0\\u0027 for Ethereum. The asset must already exist on dPiggy.\\r\\n     * @param time New minimum time in seconds between the Compound redeem executions.\\r\\n     */\\r\\n    function setMinimumTimeBetweenExecutions(address tokenAddress, uint256 time) onlyAdmin external {\\r\\n        AssetData storage assetData = assetsData[tokenAddress];\\r\\n        require(assetData.time \\u003e 0, \\\"DPiggy::setMinimumTimeBetweenExecutions: Invalid tokenAddress\\\");\\r\\n        DPiggyAssetInterface(assetData.proxy).setMinimumTimeBetweenExecutions(time);  \\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Forwarding function to dPiggy asset to deliberately redeem the user asset profit.\\r\\n     * Only can be called by the admin.\\r\\n     * Although being called by the admin, the user asset profit is redeemed to the respective user address. \\r\\n     * @param users Array with user addresses.\\r\\n     * @param tokenAddresses Array with ERC20 token addresses or \\u00270x0\\u0027 for Ethereum. The asset must already exist on dPiggy.\\r\\n     */\\r\\n    function forceRedeem(address[] calldata users, address[] calldata tokenAddresses) nonReentrant onlyAdmin external {\\r\\n        require(users.length \\u003e 0, \\\"DPiggy::forceRedeem: users is required\\\");\\r\\n        \\r\\n        for (uint256 i = 0; i \\u003c users.length; i++) {\\r\\n            _setAsset(tokenAddresses, abi.encodeWithSignature(\\\"forceRedeem(address)\\\", users[i]));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Forwarding function to dPiggy asset to deliberately finish the user participation.\\r\\n     * All asset profit is redeemed as well as all the Dai deposited for the respective assets. \\r\\n     * Only can be called by the admin.\\r\\n     * Although being called by the admin, assets and Dai redeemed are done to the respective user address. \\r\\n     * @param users Array with user addresses.\\r\\n     * @param tokenAddresses Array with ERC20 token addresses or \\u00270x0\\u0027 for Ethereum. The asset must already exist on dPiggy.\\r\\n     */\\r\\n    function forceFinish(address[] calldata users, address[] calldata tokenAddresses) nonReentrant onlyAdmin external {\\r\\n        require(users.length \\u003e 0, \\\"DPiggyAssetManager::forceFinish: users is required\\\");\\r\\n        \\r\\n        for (uint256 i = 0; i \\u003c users.length; i++) {\\r\\n            _setAsset(tokenAddresses, abi.encodeWithSignature(\\\"forceFinish(address)\\\", users[i]));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Forwarding function to dPiggy asset to deliberately finish the user participation in all dPiggy assets.\\r\\n     * All assets profit is redeemed as well as all the Dai deposited. \\r\\n     * Whether the user has the Auc escrow it will be redeemed also.\\r\\n     * Only can be called by the admin.\\r\\n     * Although being called by the admin, assets and Dai redeemed are done to the respective user address. \\r\\n     * @param users Array with user addresses.\\r\\n     */\\r\\n    function forceFinishAll(address[] calldata users) nonReentrant onlyAdmin external {\\r\\n        require(users.length \\u003e 0, \\\"DPiggyAssetManager::forceFinishAll: users is required\\\");\\r\\n        \\r\\n        for (uint256 i = 0; i \\u003c users.length; i++) {\\r\\n            _setAsset(assets, abi.encodeWithSignature(\\\"forceFinish(address)\\\", users[i]));\\r\\n            _redeemEscrow(users[i]);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to deposit Dai on dPiggy assets.\\r\\n     * Both array parameters must be the same size because the percentage is set through the same array index position.\\r\\n     * @param tokenAddresses Array with ERC20 token addresses or \\u00270x0\\u0027 for Ethereum. \\r\\n     * @param percentages Array with respective assets percentage allocation (with dPiggy percentage precision).\\r\\n     */\\r\\n    function deposit(address[] calldata tokenAddresses, uint256[] calldata percentages) nonReentrant external {\\r\\n        require(tokenAddresses.length \\u003e 0, \\\"DPiggy::deposit: Distribution is required\\\");\\r\\n        require(tokenAddresses.length == percentages.length, \\\"DPiggy::deposit: Invalid distribution\\\");\\r\\n        \\r\\n        //The amount of Dai is the allowed quantity defined by the user for the dPiggy contract on a previous transaction.\\r\\n        uint256 amount = EIP20Interface(dai).allowance(msg.sender, address(this));\\r\\n        \\r\\n        if (amount \\u003e 0) {\\r\\n            require(EIP20Interface(dai).transferFrom(msg.sender, address(this), amount), \\\"DPiggy::deposit: Error on transfer Dai\\\");\\r\\n            \\r\\n            uint256 totalDistribution = 0;\\r\\n            uint256 remainingAmount = amount;\\r\\n            for (uint256 i = 0; i \\u003c tokenAddresses.length; i++) {\\r\\n                AssetData storage assetData = assetsData[tokenAddresses[i]];\\r\\n                \\r\\n                require(assetData.depositAllowed, \\\"DPiggy::deposit: Deposit denied\\\");\\r\\n                \\r\\n                uint256 assetAmount;\\r\\n                if (i == (tokenAddresses.length - 1)) {\\r\\n                    //The last iterated asset gets the remaining amount to avoid rounding losses on percentage calculations.\\r\\n                    assetAmount = remainingAmount;\\r\\n                } else {\\r\\n                    assetAmount = amount.mul(percentages[i]).div(percentagePrecision);\\r\\n                    remainingAmount = remainingAmount.sub(assetAmount);\\r\\n                } \\r\\n                \\r\\n                require(assetAmount \\u003e= assetData.minimumDeposit, \\\"DPiggy::deposit: Invalid amount\\\");\\r\\n                \\r\\n                //Forwarding the deposit amount of Dai for the respective asset.\\r\\n                require(EIP20Interface(dai).transfer(assetData.proxy, assetAmount), \\\"DPiggy::deposit: Error on transfer Dai to asset\\\");\\r\\n                DPiggyAssetInterface(assetData.proxy).deposit(msg.sender, assetAmount);\\r\\n                \\r\\n                totalDistribution = totalDistribution.add(percentages[i]);\\r\\n            }\\r\\n            \\r\\n            require(totalDistribution == percentagePrecision, \\\"DPiggy::deposit: Invalid percentage distribution\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Forwarding function to dPiggy asset to execute the Compound redeem.\\r\\n     * @param tokenAddresses Array with ERC20 token addresses or \\u00270x0\\u0027 for Ethereum. The asset must already exist on dPiggy.\\r\\n     */\\r\\n    function executeCompoundRedeem(address[] calldata tokenAddresses) nonReentrant external {\\r\\n        _setAsset(tokenAddresses, abi.encodeWithSignature(\\\"executeCompoundRedeem()\\\"));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Forwarding function to dPiggy asset to redeem the asset profit.\\r\\n     * @param tokenAddresses Array with ERC20 token addresses or \\u00270x0\\u0027 for Ethereum. The asset must already exist on dPiggy.\\r\\n     */\\r\\n    function redeem(address[] calldata tokenAddresses) nonReentrant external {\\r\\n        _setAsset(tokenAddresses, abi.encodeWithSignature(\\\"forceRedeem(address)\\\", msg.sender));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Forwarding function to dPiggy asset to finish the participation.\\r\\n     * All assets profit is redeemed as well as all the Dai deposited.\\r\\n     * @param tokenAddresses Array with ERC20 token addresses or \\u00270x0\\u0027 for Ethereum. The asset must already exist on dPiggy.\\r\\n     */\\r\\n    function finish(address[] calldata tokenAddresses) nonReentrant external {\\r\\n        _setAsset(tokenAddresses, abi.encodeWithSignature(\\\"forceFinish(address)\\\", msg.sender));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Forwarding function to dPiggy asset to finish the participation in all dPiggy assets.\\r\\n     * All assets profit is redeemed as well as all the Dai deposited.\\r\\n     * Whether the transaction sender has the Auc escrow it will be redeemed also.\\r\\n     */\\r\\n    function finishAll() nonReentrant external {\\r\\n        _setAsset(assets, abi.encodeWithSignature(\\\"forceFinish(address)\\\", msg.sender));\\r\\n        _redeemEscrow(msg.sender);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to receive the Auc escrowed.\\r\\n     * The sender must be the Auc token contract. It occurs after an EIP 223 transfer call.\\r\\n     * On this transfer, the destination address is the dPiggy contract.\\r\\n     * The user must send exactly the minimum amount of Auc to have the fee exemption and cannot already have Auc escrowed.\\r\\n     * @param from The user address. \\r\\n     * @param amount Amount of Auc.\\r\\n     */\\r\\n    function tokenFallback(address from, uint256 amount, bytes calldata) nonReentrant external override(AucReceiverInterface) {\\r\\n        require(msg.sender == address(auc), \\\"DPiggy::tokenFallback: Invalid sender\\\");\\r\\n        require(amount == minimumAucToFreeFee, \\\"DPiggy::tokenFallback: Invalid amount\\\");\\r\\n        \\r\\n        EscrowData storage escrow = usersEscrow[from];\\r\\n        require(escrow.time == 0, \\\"DPiggy::tokenFallback: User already has an escrow\\\");\\r\\n        \\r\\n        escrow.time = now;\\r\\n        escrow.amount = amount;\\r\\n        totalEscrow = totalEscrow.add(amount);\\r\\n        \\r\\n        bool escrowAdded = false;\\r\\n        for (uint256 i = 0; i \\u003c assets.length; i++) {\\r\\n            AssetData storage assetData = assetsData[assets[i]];\\r\\n            \\r\\n            //Forwarding the Auc escrowed situation for the respective asset.\\r\\n            if (DPiggyAssetInterface(assetData.proxy).addEscrow(from) \\u0026\\u0026 !escrowAdded) {\\r\\n                escrowAdded = true;\\r\\n            }\\r\\n        }\\r\\n        require(escrowAdded, \\\"DPiggy::tokenFallback: User without data\\\");\\r\\n        \\r\\n        emit SetUserAucEscrow(from, amount);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to redeem the Auc escrowed.\\r\\n     * It transfers the Auc escrowed for the user address and remove the escrow from the stored data.\\r\\n     * @param user User\\u0027s address. \\r\\n     */\\r\\n    function _redeemEscrow(address user) internal {\\r\\n        EscrowData storage escrow = usersEscrow[user];\\r\\n        uint256 amount = escrow.amount;\\r\\n        if (amount \\u003e 0) {\\r\\n            escrow.time = 0;\\r\\n            escrow.amount = 0;\\r\\n            totalEscrow = totalEscrow.sub(amount);\\r\\n            require(EIP20Interface(auc).transfer(user, amount), \\\"DPiggy::redeemEscrow: Error on transfer escrow\\\");\\r\\n            emit RedeemUserAucEscrow(user, amount);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to run a command on dPiggy asset.\\r\\n     * @param tokenAddresses Array with ERC20 token addresses or \\u00270x0\\u0027 for Ethereum. The asset must already exist on dPiggy. \\r\\n     * @param data ABI encoded with signature data that will be called on dPiggy asset.\\r\\n     */\\r\\n    function _setAsset(address[] memory tokenAddresses, bytes memory data) internal {\\r\\n        require(tokenAddresses.length \\u003e 0, \\\"DPiggy::setAsset: tokenAddresses is required\\\");\\r\\n        \\r\\n        for (uint256 i = 0; i \\u003c tokenAddresses.length; i++) {\\r\\n            AssetData storage assetData = assetsData[tokenAddresses[i]];\\r\\n            if (assetData.time \\u003e 0) {\\r\\n                (bool success,) = assetData.proxy.call(data);\\r\\n                assert(success);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get a unit256 value on dPiggy asset.\\r\\n     * @param tokenAddress The ERC20 token address on the chain or \\u00270x0\\u0027 for Ethereum. The asset must already exist on dPiggy. \\r\\n     * @param data ABI encoded with signature data that will be static called on dPiggy asset.\\r\\n     */\\r\\n    function _getValueFromAsset(address tokenAddress, bytes memory data) internal view returns(uint256) {\\r\\n        AssetData storage assetData = assetsData[tokenAddress];\\r\\n        if (assetData.time \\u003e 0) {\\r\\n            (bool success, bytes memory returndata) = assetData.proxy.staticcall(data);\\r\\n            if (success) {\\r\\n                return abi.decode(returndata, (uint256));\\r\\n            } else {\\r\\n                return 0;\\r\\n            }\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"DPiggyAssetData.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\nimport \\\"DPiggyBaseProxyData.sol\\\";\\r\\nimport \\\"ReentrancyGuard.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title DPiggyAssetData\\r\\n * @dev Contract for all dPiggy asset stored data.\\r\\n * It must inherit from DPiggyBaseProxyData contract for properly generate the proxy.\\r\\n * Each dPiggy asset has your own DPiggyAssetData.\\r\\n */\\r\\ncontract DPiggyAssetData is DPiggyBaseProxyData, ReentrancyGuard {\\r\\n    \\r\\n    /**\\r\\n     * @dev The Struct to store each Compound redeem execution data.\\r\\n     */\\r\\n    struct Execution {\\r\\n        /**\\r\\n         * @dev The time in Unix.\\r\\n         */\\r\\n        uint256 time;\\r\\n        \\r\\n        /**\\r\\n         * @dev The calculated rate based on Dai amount variation on Compound.\\r\\n         */\\r\\n        uint256 rate;\\r\\n        \\r\\n        /**\\r\\n         * @dev The total amount of Dai on Compound.\\r\\n         */\\r\\n        uint256 totalDai;\\r\\n        \\r\\n        /**\\r\\n         * @dev The amount of Dai redeemed on Compound.\\r\\n         */\\r\\n        uint256 totalRedeemed;\\r\\n        \\r\\n        /**\\r\\n         * @dev The amount of asset purchased.\\r\\n         */\\r\\n        uint256 totalBought;\\r\\n        \\r\\n        /**\\r\\n         * @dev The total of Dai deposited on the contract.\\r\\n         */\\r\\n        uint256 totalBalance;\\r\\n        \\r\\n        /**\\r\\n         * @dev The total of Dai with fee exemption.\\r\\n         */\\r\\n        uint256 totalFeeDeduction;\\r\\n        \\r\\n        /**\\r\\n         * @dev The total of Dai redeemed that was regarded as the fee.\\r\\n         */\\r\\n        uint256 feeAmount;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev The Struct to store the user data.\\r\\n     */\\r\\n    struct UserData {\\r\\n        /**\\r\\n         * @dev The last execution Id on deposit.\\r\\n         */\\r\\n        uint256 baseExecutionId;\\r\\n        \\r\\n        /**\\r\\n         * @dev The rate on deposit.\\r\\n         * The value is the weighted average of all deposit rates with the same base execution Id.\\r\\n         * It is used to calculate the user\\u0027s corresponding profit on the next Compound redeem execution (baseExecutionId + 1).\\r\\n         */\\r\\n        uint256 baseExecutionAvgRate;\\r\\n        \\r\\n        /**\\r\\n         * @dev The amount of Dai on deposit.\\r\\n         * The value is the amount of Dai accumulated of all deposits with the same base execution Id.\\r\\n         */\\r\\n        uint256 baseExecutionAccumulatedAmount;\\r\\n        \\r\\n        /**\\r\\n         * @dev The accumulated weight for the rate calculation.\\r\\n         * The value is auxiliary for the base execution rate calculation for all deposits with the same base execution Id.\\r\\n         */\\r\\n        uint256 baseExecutionAccumulatedWeightForRate;\\r\\n        \\r\\n        /**\\r\\n         * @dev The amount of Dai that will be applied the fee on the next Compound redeem execution (baseExecutionId + 1).\\r\\n         */\\r\\n        uint256 baseExecutionAmountForFee;\\r\\n        \\r\\n        /**\\r\\n         * @dev The total of Dai deposited.\\r\\n         */\\r\\n        uint256 currentAllocated;\\r\\n        \\r\\n        /**\\r\\n         * @dev The total of Dai previously deposited before the regarded deposit.\\r\\n         * The deposits are regarded the same if they have the same base execution Id.\\r\\n         */\\r\\n        uint256 previousAllocated;\\r\\n        \\r\\n        /**\\r\\n         * @dev The previous Dai profit before the regarded deposit.\\r\\n         * The deposits are regarded the same if they have the same base execution Id.\\r\\n         */\\r\\n        uint256 previousProfit;\\r\\n        \\r\\n        /**\\r\\n         * @dev The previous asset amount before the regarded deposit.\\r\\n         * The deposits are regarded the same if they have the same base execution Id.\\r\\n         */\\r\\n        uint256 previousAssetAmount;\\r\\n        \\r\\n        /**\\r\\n         * @dev The previous fee on Dai before the regarded deposit.\\r\\n         * The deposits are regarded the same if they have the same base execution Id.\\r\\n         */\\r\\n        uint256 previousFeeAmount;\\r\\n        \\r\\n        /**\\r\\n         * @dev The total amount of asset redeemed.\\r\\n         */\\r\\n        uint256 redeemed;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the minimum time between Compound redeem executions has been changed.\\r\\n     * @param newTime The new minimum time between Compound redeem executions.\\r\\n     * @param oldTime The previous minimum time between Compound redeem executions.\\r\\n     */\\r\\n    event SetMinimumTimeBetweenExecutions(uint256 newTime, uint256 oldTime);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when a user has deposited Dai on the contract.\\r\\n     * @param user The user\\u0027s address.\\r\\n     * @param amount The amount of Dai deposited.\\r\\n     * @param rate The calculated rate.\\r\\n     * @param baseExecutionId The last Compound redeem execution Id.\\r\\n     * @param baseExecutionAmountForFee The amount of Dai that will be applied the fee on the next Compound redeem execution (baseExecutionId + 1).\\r\\n     */\\r\\n    event Deposit(address indexed user, uint256 amount, uint256 rate, uint256 baseExecutionId, uint256 baseExecutionAmountForFee);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when a user has redeemed the asset profit on the contract.\\r\\n     * @param user The user\\u0027s address.\\r\\n     * @param amount The amount of asset redeemed.\\r\\n     */\\r\\n    event Redeem(address indexed user, uint256 amount);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when a Compound redeem has been executed.\\r\\n     * @param executionId The respective Id.\\r\\n     * @param rate The calculated rate.\\r\\n     * @param totalBalance The total of Dai deposited on the contract.\\r\\n     * @param totalRedeemed The amount of Dai redeemed on Compound.\\r\\n     * @param fee The total of Dai redeemed that was regarded as the fee.\\r\\n     * @param totalBought The amount of asset purchased.\\r\\n     * @param totalAucBurned The amount of Auc purchased and burned with the fee.\\r\\n     */\\r\\n    event CompoundRedeem(uint256 indexed executionId, uint256 rate, uint256 totalBalance, uint256 totalRedeemed, uint256 fee, uint256 totalBought, uint256 totalAucBurned);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when a user has finished the own participation on the dPiggy asset.\\r\\n     * All asset profit is redeemed as well as all the Dai deposited. \\r\\n     * @param user The user\\u0027s address.\\r\\n     * @param totalRedeemed The amount of Dai redeemed on Compound.\\r\\n     * @param yield The user yield in Dai redeemed since the last Compound redeem execution.\\r\\n     * @param fee The total of Dai redeemed that was regarded as the fee.\\r\\n     * @param totalAucBurned The amount of Auc purchased and burned with the fee.\\r\\n     */\\r\\n    event Finish(address indexed user, uint256 totalRedeemed, uint256 yield, uint256 fee, uint256 totalAucBurned);\\r\\n    \\r\\n    /**\\r\\n     * @dev The ERC20 token address on the chain or \\u00270x0\\u0027 for Ethereum. \\r\\n     * It is the asset for the respective contract. \\r\\n     */\\r\\n    address public tokenAddress;\\r\\n    \\r\\n    /**\\r\\n     * @dev Minimum time in seconds between executions to run the Compound redeem.\\r\\n     */\\r\\n    uint256 public minimumTimeBetweenExecutions;\\r\\n    \\r\\n    /**\\r\\n     * @dev Last Compound redeem execution Id (it is an incremental number).\\r\\n     */\\r\\n    uint256 public executionId;\\r\\n    \\r\\n    /**\\r\\n     * @dev The total balance of Dai deposited.\\r\\n     */\\r\\n    uint256 public totalBalance;\\r\\n    \\r\\n    /**\\r\\n     * @dev The amount of deposited Dai that has a fee exemption due to the Auc escrowed.\\r\\n     */\\r\\n    uint256 public feeExemptionAmountForAucEscrowed;\\r\\n    \\r\\n    /**\\r\\n     * @dev It indicates if the contract asset is the cDai.\\r\\n     */\\r\\n    bool public isCompound;\\r\\n    \\r\\n    /**\\r\\n     * @dev The difference between the amount of Dai deposited and the respective value normalized to the last Compound redeem execution time.\\r\\n     * _key is the execution Id.\\r\\n     * _value is the difference of Dai.\\r\\n     */\\r\\n    mapping(uint256 =\\u003e uint256) public totalBalanceNormalizedDifference;\\r\\n    \\r\\n    /**\\r\\n     * @dev The amount of Dai that has a fee exemption for the respective execution due to the user deposit time.\\r\\n     * _key is the execution Id.\\r\\n     * _value is the amount of Dai.\\r\\n     * The user amount of Dai proportion is calculated based on the difference between the deposit time and the next execution time.\\r\\n     */\\r\\n    mapping(uint256 =\\u003e uint256) public feeExemptionAmountForUserBaseData;\\r\\n    \\r\\n    /**\\r\\n     * @dev The Compound redeem executions data.\\r\\n     * _key is the execution Id.\\r\\n     * _value is the execution data.\\r\\n     */\\r\\n    mapping(uint256 =\\u003e Execution) public executions;\\r\\n    \\r\\n    /**\\r\\n     * @dev The user data for the asset.\\r\\n     * _key is the user address.\\r\\n     * _value is the user data.\\r\\n     */\\r\\n    mapping(address =\\u003e UserData) public usersData;\\r\\n}\\r\\n\"},\"DPiggyAssetInterface.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\n/**\\r\\n * @title DPiggyAssetInterface\\r\\n * @dev DPiggyAsset interface for external functions used directly on dPiggy.\\r\\n */\\r\\ninterface DPiggyAssetInterface {\\r\\n    function getUserProfitsAndFeeAmount(address user) external view returns(uint256, uint256, uint256);\\r\\n    function setMinimumTimeBetweenExecutions(uint256 time) external;\\r\\n    function deposit(address user, uint256 amount) external;\\r\\n    function addEscrow(address user) external returns(bool);\\r\\n}\"},\"DPiggyAssetProxy.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\nimport \\\"DPiggyBaseProxy.sol\\\";\\r\\nimport \\\"DPiggyAssetData.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title DPiggyAssetProxy\\r\\n * @dev A proxy contract for dPiggy asset.\\r\\n * It must inherit first from DPiggyBaseProxy contract for properly works.\\r\\n * The stored data is on DPiggyAssetData contract.\\r\\n */\\r\\ncontract DPiggyAssetProxy is DPiggyBaseProxy, DPiggyAssetData {\\r\\n    constructor(\\r\\n        address _admin, \\r\\n        address _implementation, \\r\\n        bytes memory data\\r\\n    ) public payable DPiggyBaseProxy(_admin, _implementation, data) {\\r\\n    } \\r\\n}\"},\"DPiggyBaseProxy.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\nimport \\\"Address.sol\\\";\\r\\nimport \\\"DPiggyBaseProxyData.sol\\\";\\r\\nimport \\\"DPiggyBaseProxyInterface.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title DPiggyBaseProxy\\r\\n * @dev A proxy contract that implements delegation of calls to other contracts.\\r\\n * The stored data is on DPiggyBaseProxyData contract.\\r\\n */\\r\\ncontract DPiggyBaseProxy is DPiggyBaseProxyData, DPiggyBaseProxyInterface {\\r\\n\\r\\n    constructor(address _admin, address _implementation, bytes memory data) public payable {\\r\\n        admin = _admin;\\r\\n        _setImplementation(_implementation, data);\\r\\n    } \\r\\n  \\r\\n    /**\\r\\n     * @dev Fallback function that delegates the execution to an implementation contract.\\r\\n     */\\r\\n    fallback() external payable {\\r\\n        address addr = implementation;\\r\\n        assembly {\\r\\n            calldatacopy(0, 0, calldatasize())\\r\\n            let result := delegatecall(gas(), addr, 0, calldatasize(), 0, 0)\\r\\n            returndatacopy(0, 0, returndatasize())\\r\\n            switch result\\r\\n            case 0 { revert(0, returndatasize()) }\\r\\n            default { return(0, returndatasize()) }\\r\\n        }\\r\\n    }\\r\\n  \\r\\n    /**\\r\\n     * @dev Function to be compliance with EIP 897.\\r\\n     * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-897.md\\r\\n     * It is an \\\"upgradable proxy\\\".\\r\\n     */\\r\\n    function proxyType() public pure returns(uint256) {\\r\\n        return 2; \\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to set the proxy implementation address.\\r\\n     * Only can be called by the proxy admin.\\r\\n     * The implementation address must a contract.\\r\\n     * @param newImplementation Address of the new proxy implementation.\\r\\n     * @param data ABI encoded with signature data that will be delegated over the new implementation.\\r\\n     */\\r\\n    function setImplementation(address newImplementation, bytes calldata data) onlyAdmin external override(DPiggyBaseProxyInterface) payable {\\r\\n        require(Address.isContract(newImplementation));\\r\\n        address oldImplementation = implementation;\\r\\n        _setImplementation(newImplementation, data);\\r\\n        emit SetProxyImplementation(newImplementation, oldImplementation);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to set the proxy admin address.\\r\\n     * Only can be called by the proxy admin.\\r\\n     * @param newAdmin Address of the new proxy admin.\\r\\n     */\\r\\n    function setAdmin(address newAdmin) onlyAdmin external override(DPiggyBaseProxyInterface) {\\r\\n        require(newAdmin != address(0));\\r\\n        address oldAdmin = admin;\\r\\n        admin = newAdmin;\\r\\n        emit SetProxyAdmin(newAdmin, oldAdmin);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to set the implementation address.\\r\\n     * @param _implementation Address of the new proxy implementation.\\r\\n     * @param data ABI encoded with signature data that will be delegated over the new implementation.\\r\\n     */\\r\\n    function _setImplementation(address _implementation, bytes memory data) internal {\\r\\n        implementation = _implementation;\\r\\n        if (data.length \\u003e 0) {\\r\\n            (bool success,) = _implementation.delegatecall(data);\\r\\n            assert(success);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"DPiggyBaseProxyData.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\n/**\\r\\n * @title DPiggyBaseProxyData\\r\\n * @dev Contract for all DPiggyBaseProxyData stored data.\\r\\n */\\r\\ncontract DPiggyBaseProxyData {\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the proxy implementation has been changed.\\r\\n     * @param newImplementation Address of the new proxy implementation.\\r\\n     * @param oldImplementation Address of the previous proxy implementation.\\r\\n     */\\r\\n    event SetProxyImplementation(address indexed newImplementation, address oldImplementation);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the admin address has been changed.\\r\\n     * @param newAdmin Address of the new admin.\\r\\n     * @param oldAdmin Address of the previous admin.\\r\\n     */\\r\\n    event SetProxyAdmin(address indexed newAdmin, address oldAdmin);\\r\\n    \\r\\n    /**\\r\\n     * @dev Modifier to check if the `msg.sender` is the admin.\\r\\n     * Only admin address can execute.\\r\\n     */\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == admin);\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev The contract address of the implementation.\\r\\n     */\\r\\n    address public implementation;\\r\\n    \\r\\n    /**\\r\\n     * @dev The admin address.\\r\\n     */\\r\\n    address public admin;\\r\\n}\\r\\n\"},\"DPiggyBaseProxyInterface.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\n/**\\r\\n * @title DPiggyBaseProxyInterface\\r\\n * @dev DPiggyBaseProxy interface with external functions.\\r\\n */\\r\\ninterface DPiggyBaseProxyInterface {\\r\\n    function setImplementation(address newImplementation, bytes calldata data) external payable;\\r\\n    function setAdmin(address newAdmin) external;\\r\\n}\"},\"DPiggyData.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\nimport \\\"DPiggyBaseProxyData.sol\\\";\\r\\nimport \\\"ReentrancyGuard.sol\\\";\\r\\nimport \\\"DPiggyInterface.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title DPiggyData\\r\\n * @dev Contract for all dPiggy stored data.\\r\\n * It must inherit from DPiggyBaseProxyData contract for properly generate the proxy.\\r\\n */\\r\\ncontract DPiggyData is DPiggyBaseProxyData, ReentrancyGuard, DPiggyDataInterface {\\r\\n    \\r\\n    /**\\r\\n     * @dev The Struct to store each user escrow data.\\r\\n     */\\r\\n    struct EscrowData {\\r\\n        /**\\r\\n         * @dev The amount of Auc escrowed.\\r\\n         */\\r\\n        uint256 amount;\\r\\n        \\r\\n        /**\\r\\n         * @dev The time in Unix that the escrow occurred.\\r\\n         */\\r\\n        uint256 time;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev The Struct to store each dPiggy asset data.\\r\\n     */\\r\\n    struct AssetData {\\r\\n        /**\\r\\n         * @dev The proxy contract address that runs the asset base implementation contract.\\r\\n         */\\r\\n        address proxy;\\r\\n        \\r\\n        /**\\r\\n         * @dev It defines whether the deposit of Dai is allowed.\\r\\n         */\\r\\n        bool depositAllowed;\\r\\n        \\r\\n        /**\\r\\n         * @dev The creation time in Unix.\\r\\n         */\\r\\n        uint256 time;\\r\\n        \\r\\n        /**\\r\\n         * @dev The minimum amount of Dai that can be deposited.\\r\\n         */\\r\\n        uint256 minimumDeposit;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the daily fee has been changed.\\r\\n     * @param newDailylFee The new daily fee.\\r\\n     * @param oldDailylFee The previous daily fee.\\r\\n     */\\r\\n    event SetDailyFee(uint256 newDailylFee, uint256 oldDailylFee);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the minimum amount of Auc escrowed to have the fee exemption has been changed.\\r\\n     * @param newMinimumAuc The new minimum amount of Auc escrowed to have the fee exemption.\\r\\n     * @param oldMinimumAuc The previous minimum amount of Auc escrowed to have the fee exemption.\\r\\n     */\\r\\n    event SetMinimumAucToFreeFee(uint256 newMinimumAuc, uint256 oldMinimumAuc);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when a user has escrowed Auc on the contract.\\r\\n     * @param user The user\\u0027s address.\\r\\n     * @param amount The amount of Auc escrowed.\\r\\n     */\\r\\n    event SetUserAucEscrow(address indexed user, uint256 amount);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when a user has redeemed the Auc escrowed.\\r\\n     * @param user The user\\u0027s address.\\r\\n     * @param amount The amount of Auc redeemed.\\r\\n     */\\r\\n    event RedeemUserAucEscrow(address indexed user, uint256 amount);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when a new dPiggy asset has been created.\\r\\n     * @param tokenAddress The ERC20 token address (0x0 for Ethereum).\\r\\n     * @param proxy The proxy contract address created that runs the asset base implementation contract.\\r\\n     */\\r\\n    event SetNewAsset(address indexed tokenAddress, address proxy);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the dPiggy asset deposit permission has changed.\\r\\n     * @param tokenAddress The ERC20 token address (0x0 for Ethereum).\\r\\n     * @param newDepositAllowed The new condition for the permission for the deposit of Dai.\\r\\n     * @param oldDepositAllowed The previous condition for the permission for the deposit of Dai.\\r\\n     */\\r\\n    event SetAssetDepositAllowed(address indexed tokenAddress, bool newDepositAllowed, bool oldDepositAllowed);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the dPiggy asset minimum Dai for deposit has changed.\\r\\n     * @param tokenAddress The ERC20 token address (0x0 for Ethereum).\\r\\n     * @param newMinimumDeposit The new minimum amount of Dai that can be deposited.\\r\\n     * @param oldMinimumDeposit The previous minimum amount of Dai that can be deposited.\\r\\n     */\\r\\n    event SetAssetMinimumDeposit(address indexed tokenAddress, uint256 newMinimumDeposit, uint256 oldMinimumDeposit);\\r\\n\\r\\n    /**\\r\\n     * @dev Address for the Auc token contract.\\r\\n     */\\r\\n    address public override(DPiggyDataInterface) auc;\\r\\n    \\r\\n    /**\\r\\n     * @dev Address for the Dai token contract.\\r\\n     */\\r\\n    address public override(DPiggyDataInterface) dai;\\r\\n    \\r\\n    /**\\r\\n     * @dev Address for the cDai (the Compound contract).\\r\\n     */\\r\\n    address public override(DPiggyDataInterface) compound;\\r\\n    \\r\\n    /**\\r\\n     * @dev Address for the Uniswap Dai exchange contract.\\r\\n     */\\r\\n    address public override(DPiggyDataInterface) exchange;\\r\\n    \\r\\n    /**\\r\\n     * @dev Address for the Uniswap factory contract.\\r\\n     */\\r\\n    address public uniswapFactory;\\r\\n    \\r\\n    /**\\r\\n     * @dev Address for the asset base implementation contract.\\r\\n     */\\r\\n    address public assetImplementation;\\r\\n    \\r\\n    /**\\r\\n     * @dev The percentage precision. \\r\\n     * The value represents the 100%.\\r\\n     */\\r\\n    uint256 public override(DPiggyDataInterface) percentagePrecision;\\r\\n    \\r\\n    /**\\r\\n     * @dev The minimum amount of Auc escrowed to have the fee exemption.\\r\\n     */\\r\\n    uint256 public minimumAucToFreeFee;\\r\\n    \\r\\n    /**\\r\\n     * @dev Total amount of Auc escrowed.\\r\\n     */\\r\\n    uint256 public totalEscrow;\\r\\n    \\r\\n    /**\\r\\n     * @dev The maximum value that can be defined for the daily fee percentage.\\r\\n     */\\r\\n    uint256 public maximumDailyFee;\\r\\n    \\r\\n    /**\\r\\n     * @dev The daily fee percentage (with percentage precision).\\r\\n     */\\r\\n    uint256 public dailyFee;\\r\\n    \\r\\n    /**\\r\\n     * @dev The number of dPiggy assets.\\r\\n     */\\r\\n    uint256 public numberOfAssets;\\r\\n    \\r\\n    /**\\r\\n     * @dev Array for all dPiggy assets. \\r\\n     * The ERC20 token addresses (0x0 for Ethereum).\\r\\n     */\\r\\n    address[] public assets;\\r\\n    \\r\\n    /**\\r\\n     * @dev The user escrow data.\\r\\n     * _key is the user address.\\r\\n     * _value is the user escrow data.\\r\\n     */\\r\\n    mapping(address =\\u003e EscrowData) public usersEscrow;\\r\\n    \\r\\n    /**\\r\\n     * @dev The dPiggy asset data.\\r\\n     * _key is the ERC20 token address (0x0 for Ethereum).\\r\\n     * _value is the dPiggy asset data.\\r\\n     */\\r\\n    mapping(address =\\u003e AssetData) public assetsData;\\r\\n}\"},\"DPiggyInterface.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\n/**\\r\\n * @title DPiggyDataInterface\\r\\n * @dev DPiggyData interface with stored data used by other contracts.\\r\\n */\\r\\ninterface DPiggyDataInterface {\\r\\n    function auc() external view returns(address);\\r\\n    function dai() external view returns(address);\\r\\n    function compound() external view returns(address);\\r\\n    function exchange() external view returns(address);\\r\\n    function percentagePrecision() external view returns(uint256);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title DPiggyInterface\\r\\n * @dev DPiggy interface with stored data and functions used by other contracts.\\r\\n */\\r\\ninterface DPiggyInterface is DPiggyDataInterface {\\r\\n    function executionFee(uint256 baseTime) external view returns(uint256);\\r\\n    function escrowStart(address user) external view returns(uint256);\\r\\n}\"},\"EIP20Interface.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\n/**\\r\\n * @title EIP20Interface\\r\\n * @dev EIP 20 token contract interface.\\r\\n */\\r\\ninterface EIP20Interface {\\r\\n    function name() external view returns(string memory);\\r\\n    function symbol() external view returns(string memory);\\r\\n    function decimals() external view returns(uint8);\\r\\n    function totalSupply() external view returns(uint256);\\r\\n    function balanceOf(address owner) external view returns(uint256);\\r\\n    function allowance(address owner, address spender) external view returns(uint256);\\r\\n    function approve(address usr, uint amount) external returns(bool);\\r\\n    function transfer(address dst, uint256 amount) external returns(bool);\\r\\n    function transferFrom(address src, address dst, uint amount) external returns(bool);\\r\\n    \\r\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\r\\n}\"},\"ReentrancyGuard.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\n/**\\r\\n * @title ReentrancyGuard\\r\\n * @dev Base contract with a modifier that implements a reentrancy guard.\\r\\n */\\r\\ncontract ReentrancyGuard {\\r\\n    /**\\r\\n     * @dev Internal data to control the reentrancy.\\r\\n     */\\r\\n    bool internal _notEntered;\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to prevents a contract from calling itself during the function execution.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        require(_notEntered, \\\"ReentrancyGuard:: reentry\\\");\\r\\n        _notEntered = false;\\r\\n        _;\\r\\n        _notEntered = true;\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\n// OpenZeppelin https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol \\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"},\"UniswapFactoryInterface.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\n/**\\r\\n * @title UniswapFactoryInterface\\r\\n * @dev Uniswap factory interface.\\r\\n * https://docs.uniswap.io/smart-contract-api/factory\\r\\n */\\r\\ninterface UniswapFactoryInterface {\\r\\n    // Create Exchange\\r\\n    function createExchange(address token) external returns (address exchange);\\r\\n    // Get Exchange and Token Info\\r\\n    function getExchange(address token) external view returns (address exchange);\\r\\n    function getToken(address exchange) external view returns (address token);\\r\\n    function getTokenWithId(uint256 tokenId) external view returns (address token);\\r\\n    // Never use\\r\\n    function initializeFactory(address template) external;\\r\\n}\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RedeemUserAucEscrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newDepositAllowed\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"oldDepositAllowed\",\"type\":\"bool\"}],\"name\":\"SetAssetDepositAllowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMinimumDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMinimumDeposit\",\"type\":\"uint256\"}],\"name\":\"SetAssetMinimumDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDailylFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDailylFee\",\"type\":\"uint256\"}],\"name\":\"SetDailyFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMinimumAuc\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMinimumAuc\",\"type\":\"uint256\"}],\"name\":\"SetMinimumAucToFreeFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"SetNewAsset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"}],\"name\":\"SetProxyAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldImplementation\",\"type\":\"address\"}],\"name\":\"SetProxyImplementation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SetUserAucEscrow\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"assets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"assetsData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"depositAllowed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumDeposit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auc\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compound\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumDeposit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"creationData\",\"type\":\"bytes\"}],\"name\":\"createAsset\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dai\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dailyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"percentages\",\"type\":\"uint256[]\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"escrowStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchange\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"executeCompoundRedeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"baseTime\",\"type\":\"uint256\"}],\"name\":\"executionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"finish\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finishAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"forceFinish\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"forceFinishAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"forceRedeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getMinimumDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getMinimumTimeForNextExecution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getTotalInvested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserAssetRedeemed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"getUserEstimatedCurrentFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserEstimatedCurrentProfitWithoutFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserProfitsAndFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserTotalInvested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percentagePrecision\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dailyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maximumDailyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumAucToFreeFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_dai\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_compound\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_auc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_assetImplementation\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumDailyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumAucToFreeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentagePrecision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_assetImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"updateData\",\"type\":\"bytes\"}],\"name\":\"setAssetImplementation\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"allowed\",\"type\":\"bool[]\"}],\"name\":\"setAssetsDepositAllowed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minimumDeposits\",\"type\":\"uint256[]\"}],\"name\":\"setAssetsMinimumDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dailyFee\",\"type\":\"uint256\"}],\"name\":\"setDailyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setExchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimumAucToFreeFee\",\"type\":\"uint256\"}],\"name\":\"setMinimumAucToFreeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setMinimumTimeBetweenExecutions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEscrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"usersEscrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"DPiggy","CompilerVersion":"v0.6.4+commit.1dca32f3","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"ipfs://2be757e046fef54effefff8384810ec9d3163d4ce7e3522df08bb926b586a02a"}]}