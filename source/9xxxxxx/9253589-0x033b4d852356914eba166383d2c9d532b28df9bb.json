{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *  https://contributing.kleros.io/smart-contract-workflow\r\n *  @reviewers: [unknownunknown1, marsrobertson]\r\n *  @auditors: []\r\n *  @bounties: []\r\n *  @deployments: []\r\n */\r\n/* solium-disable error-reason */\r\n/* solium-disable security/no-block-members */\r\npragma solidity ^0.5.8;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n *  @title ERC20Seller\r\n *  @author Cl√©ment Lesaege - <clement@kleros.io>\r\n *  @dev A contract to allow the sale of tokens against ETH at a price decided by the seller.\r\n *  Note that this contract is kept as simple as possible.\r\n *  It is not optimized for handling a high amount of orders by the seller but to support 1-10 orders on average.\r\n *  If you intend to use a lot more simultaneous orders, we would suggest developing a heap-based version of this contract.\r\n *  Note that:\r\n *      - Orders are not automatically removed when they are completely fulfilled in order to avoid changing the orderID without intervention of the seller.\r\n *      - Tokens amounts and prices are supposed to be reasonable such that multiplying them does not overflow.\r\n *      - A few wei or basic token units may be lost in the process. Only use this contract to sell a token whose basic unit price is insignificant.\r\n *      - The token contract is trusted not to reenter during a call to this contract.\r\n */\r\ncontract ERC20Seller {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /* Storage */\r\n\r\n    address payable seller; // The party selling the tokens.\r\n    IERC20 public token;    // The token to be sold.\r\n    uint public divisor;    // The divisor of the token price. It is used to allow prices lower than 1 wei / basic_unit.\r\n\r\n    // A sell order.\r\n    struct Order {\r\n        uint price;  // The selling price in wei * divisor / basic_unit.\r\n        uint amount; // The amount of token to sell in base unit.\r\n    }\r\n\r\n    Order[] public orders; // A list of orders.\r\n\r\n    /* Constant */\r\n\r\n    uint public MAX_ORDERS = 100;   // The maximum amount of simultaneous orders. It is used to avoid having so much orders that the calls would run out of gas.\r\n    uint NO_ORDER_FOUND = uint(-1); // Value returned by findCheapestOrder when no orders are found.\r\n    uint MAX_VALUE = uint(-1);      // Maximum value, such that it is never exceeded.\r\n\r\n    /* Events */\r\n\r\n    /**\r\n     *  @dev Emitted when a contributor makes a purchase.\r\n     *  @param _contributor The account that made the purchase.\r\n     *  @param _amount The amount of tokens in basic units.\r\n     */\r\n    event TokenPurchase(address _contributor, uint _amount);\r\n\r\n    /* Constructor */\r\n\r\n    /** @dev Constructs the seller contract.\r\n     *  @param _token The token to sell.\r\n     *  @param _divisor The divisor of the price.\r\n     */\r\n    constructor(IERC20 _token, uint _divisor) public {\r\n        seller  = msg.sender;\r\n        token   = _token;\r\n        divisor = _divisor;\r\n    }\r\n\r\n    /* External */\r\n\r\n    /** @dev Add a sell order.\r\n     *  @param _price The selling price in wei * divisor / basic_unit.\r\n     *  @param _amount The amount of tokens to sell in basic units.\r\n     */\r\n    function addOrder(uint _price, uint _amount) external {\r\n        require(msg.sender == seller, \"Only the seller can perform this action.\");\r\n        require(orders.length < MAX_ORDERS, \"The maximum number of orders should not have already been reached.\");\r\n        require(token.transferFrom(msg.sender, address(this), _amount));\r\n        orders.push(Order({price: _price, amount: _amount}));\r\n    }\r\n\r\n    /** @dev Increase the amount of an order.\r\n     *  @param _orderID The ID of the order to increase the amount.\r\n     *  @param _amount The amount of tokens to add to the total amount in basic units.\r\n     */\r\n    function increaseAmount(uint _orderID, uint _amount) external {\r\n        require(msg.sender == seller, \"Only the seller can perform this action.\");\r\n        require(token.transferFrom(msg.sender, address(this), _amount));\r\n        orders[_orderID].amount = orders[_orderID].amount.add(_amount);\r\n    }\r\n\r\n    /** @dev Decrease the amount of an order.\r\n     *  @param _orderID The ID of the order to decrease the amount.\r\n     *  @param _amount The amount of tokens to remove from the total amount in base units. If it is higher than the amount, all the tokens will be removed.\r\n     */\r\n    function decreaseAmount(uint _orderID, uint _amount) external {\r\n        require(msg.sender == seller, \"Only the seller can perform this action.\");\r\n        uint amountToDecrease = orders[_orderID].amount < _amount ? orders[_orderID].amount : _amount;\r\n        require(token.transfer(seller, amountToDecrease));\r\n        orders[_orderID].amount = orders[_orderID].amount.sub(amountToDecrease);\r\n    }\r\n\r\n    /** @dev Remove an order.\r\n     *  @param _orderID The ID of the order to remove.\r\n     */\r\n    function removeOrder(uint _orderID) external {\r\n        require(msg.sender == seller, \"Only the seller can perform this action.\");\r\n        require(token.transfer(seller, orders[_orderID].amount));\r\n        orders[_orderID] = orders[orders.length - 1];\r\n        --orders.length;\r\n    }\r\n\r\n    /** @dev Fallback function automatically buys all it can, no matter the price.\r\n     */\r\n    function () external payable {\r\n        buy(MAX_VALUE);\r\n    }\r\n\r\n    /* Public */\r\n\r\n    /** @dev Buy all the tokens possible at _maxPrice or lower.\r\n     *  This function is in O(n¬≤), where n is the amount of orders.\r\n     *  @param _maxPrice Maximum price to pay.\r\n     */\r\n    function buy(uint _maxPrice) public payable {\r\n        uint remainingETH  = msg.value;\r\n        uint cheapestOrder = findCheapestOrder();\r\n        uint tokensBought;\r\n\r\n        while(remainingETH!=0 && cheapestOrder!=NO_ORDER_FOUND && orders[cheapestOrder].price<=_maxPrice) { // Check if there is an order to take. Note that this will never revert due to short-circuit evaluation rules.\r\n            uint fullOrderValue = orders[cheapestOrder].price.mul(orders[cheapestOrder].amount).div(divisor);\r\n            if (fullOrderValue <= remainingETH) { // Take the whole order.\r\n                tokensBought = tokensBought.add(orders[cheapestOrder].amount);\r\n                remainingETH = remainingETH.sub(fullOrderValue);\r\n                orders[cheapestOrder].amount = 0;\r\n                cheapestOrder = findCheapestOrder();\r\n            } else { // Take the whole buy.\r\n                uint amountBought = remainingETH.mul(divisor).div(orders[cheapestOrder].price);\r\n                tokensBought = tokensBought.add(amountBought);\r\n                orders[cheapestOrder].amount = orders[cheapestOrder].amount.sub(amountBought);\r\n                remainingETH = 0;\r\n            }\r\n\r\n        }\r\n\r\n        require(token.transfer(msg.sender, tokensBought));\r\n        emit TokenPurchase(msg.sender, tokensBought);\r\n        if (remainingETH != 0)\r\n            msg.sender.transfer(remainingETH); // Send back the ETH not used.\r\n        seller.transfer(address(this).balance); // Send the ETH to the seller.\r\n    }\r\n\r\n\r\n    /* Views */\r\n\r\n    /** @dev Find the cheapest order. This function is in O(n), where n is the amount of orders.\r\n     *  @return _orderID The ID of the cheapest order. NO_ORDER_FOUND if there are no orders.\r\n     */\r\n    function findCheapestOrder() public view returns (uint _orderID) {\r\n        uint bestPrice = MAX_VALUE;\r\n        _orderID = NO_ORDER_FOUND;\r\n\r\n        for (uint i = 0; i < orders.length; ++i) {\r\n            if (orders[i].price<bestPrice && orders[i].amount!=0) {\r\n                bestPrice = orders[i].price;\r\n                _orderID = i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @dev Fetch all open order IDs. This function is O(n) where n is the amount of orders.\r\n     *  @return _orderIDs The IDs of all open orders.\r\n     */\r\n    function getOpenOrders() external view returns (uint[] memory orderIDs) {\r\n      uint orderCount = 0;\r\n      for (uint i = 0; i < orders.length; i++) {\r\n        if (orders[i].amount > 0)\r\n          orderCount++;\r\n      }\r\n\r\n      orderIDs = new uint[](orderCount);\r\n      uint counter = 0;\r\n      for (uint j = 0; j < orders.length; j++) {\r\n        if (orders[j].amount > 0) {\r\n          orderIDs[counter] = j;\r\n          counter++;\r\n        }\r\n      }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"divisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderID\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"decreaseAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_ORDERS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderID\",\"type\":\"uint256\"}],\"name\":\"removeOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orders\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderID\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"increaseAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"findCheapestOrder\",\"outputs\":[{\"name\":\"_orderID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxPrice\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOpenOrders\",\"outputs\":[{\"name\":\"orderIDs\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_divisor\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"}]","ContractName":"ERC20Seller","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://18160a62b399ea08e74d45cbd664d8e2282cc80ecb8831cdeb52a2c63efa8ef7"}]}