{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    event LockBalance(address indexed from, address indexed to, uint tokens);\r\n    event FreezeBalance(address indexed from, uint tokens, uint until);\r\n    event LogUint(string key, uint value);\r\n    event LogString(string key, string value);\r\n    event LogAddress(string key, address value);\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\ncontract SRFX is ERC20Interface, Owned {\r\n\r\n    /*\r\n     * Use SafeMath Library\r\n     * for uint operations.\r\n     */\r\n    using SafeMath for uint;\r\n\r\n    /*\r\n     * Token symbol listed\r\n     * on exchanges.\r\n     */\r\n    string public symbol;\r\n\r\n    /*\r\n     * Token name displayed\r\n     * on block explorers\r\n     */\r\n    string public  name;\r\n\r\n    /*\r\n     * Atomic unit of the token.\r\n     */\r\n    uint8 public decimals;\r\n\r\n    /*\r\n     * Total supply available\r\n     * of the token.\r\n     */\r\n    uint _totalSupply;\r\n\r\n    /*\r\n     * Stores token holder\r\n     * balances.\r\n     */\r\n    mapping(address => uint) balances;\r\n\r\n    /*\r\n     * Stores allowances\r\n     * of tokens holders to\r\n     * each other.\r\n     */\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n    /*\r\n     * Method to claim unsold\r\n     * private sale tokens into\r\n     * the reserve.\r\n     */\r\n    function claimReserve() public {\r\n\r\n        //ONLY RESERVE ADDRESS CAN CLAIM\r\n        require(msg.sender == roles[4], 'Only reserve address can claim!');\r\n\r\n        //RESERVE CAN ONLY BE CLAIMED AFTER END OF PUBLIC SALE\r\n        if(block.timestamp < pubSaleEnd + 7 * 24 * 60 * 60){\r\n            revert('Reserve can not be claimed before end of public sale!');\r\n        }\r\n\r\n        //CLAIM FUNDS\r\n        balances[roles[4]] = balances[roles[4]].add(balances[roles[0]]);\r\n\r\n        //EMIT TRANSFER EVENTS\r\n        emit Transfer(roles[0], roles[4], balances[roles[0]]);\r\n\r\n        //DEDUCT BALANCES OF EXCHANGE AND PRIV SELLER\r\n        balances[roles[0]] = 0;\r\n    }\r\n\r\n    /*\r\n     * Mapping for roles\r\n     * to addresses:\r\n     * 0 => Private seller\r\n     * 1 => Exchange\r\n     * 2 => Management\r\n     * 3 => Centrum Circle\r\n     * 4 => Reserve\r\n     * 5 => Rate updater\r\n     */\r\n    mapping(uint => address) roles;\r\n\r\n    /*\r\n     * Get the current address\r\n     * for a given role.\r\n     */\r\n    function getRoleAddress(uint _roleId) public view returns (address) {\r\n        return roles[_roleId];\r\n    }\r\n\r\n    /*\r\n     * Sets an address\r\n     * for a given role.\r\n     */\r\n    function setRoleAddress(uint _roleId, address _newAddress) public onlyOwner {\r\n\r\n        //ENSURE THAT ONLY ADDRESSES WITHOUT BALANCE CAN BE ASSIGNED\r\n        require(balances[_newAddress] == 0, 'Only zero balance addresses can be assigned!');\r\n\r\n        //GET OLD ADDRESS OF THE ROLE\r\n        address _oldAddress = roles[_roleId];\r\n\r\n        //IF TRYING TO UPDATE EXCHANGE ADDRESS, REVERT\r\n        if(_roleId == 1 && _oldAddress != address(0)){\r\n            revert('Exchange address MUST not be updated!');\r\n        }\r\n\r\n        //IF THIS IS THE INITIALIZATION OF THE ADDRESS\r\n        if(_oldAddress == address(0)){\r\n\r\n            //INITIALIZATION BALANCE\r\n            uint initBalance = 0;\r\n\r\n            //PRIVATE SELLER\r\n            if(_roleId == 0){\r\n                initBalance = 133333200;\r\n            }\r\n\r\n            //EXCHANGE\r\n            if(_roleId == 1){\r\n                initBalance = 88888800;\r\n            }\r\n\r\n            //MANAGEMENT\r\n            if(_roleId == 2){\r\n                initBalance = 44444400;\r\n            }\r\n\r\n            //CENTRUM\r\n            if(_roleId == 3){\r\n                initBalance = 44444400;\r\n            }\r\n\r\n            //RESERVE\r\n            if(_roleId == 4){\r\n                initBalance = 22222200;\r\n            }\r\n\r\n            //5 = RATE UPDATER\r\n\r\n            //IF THERE IS BALANCE TO BE INITIALIZED, DO IT\r\n            if(initBalance > 0){\r\n                initBalance = initBalance * 10**uint(decimals);\r\n                balances[_newAddress] = initBalance;\r\n                emit Transfer(address(0), _newAddress, initBalance);\r\n\r\n                //FOR MANAGEMENT AND RESERVE, APPLY FREEZE TO THE INIT BALANCE\r\n                if(_roleId == 2 || _roleId == 4){\r\n                    frozenBalances[_newAddress] = initBalance;\r\n                    frozenTiming[_newAddress] = block.timestamp + 180 * 24 * 60 * 60;\r\n                    emit FreezeBalance(_newAddress, initBalance, frozenTiming[_newAddress]);\r\n                }\r\n            }\r\n        }\r\n\r\n        //IF CURRENT ACCOUNT HAS BALANCE\r\n        if(balances[_oldAddress] > 0){\r\n\r\n            //MOVE FUNDS OF OLD ACCOUNT TO NEW ACCOUNT\r\n            balances[_newAddress] = balances[_oldAddress];\r\n\r\n            //EMIT TRANSFER EVENT\r\n            emit Transfer(_oldAddress, _newAddress, balances[_oldAddress]);\r\n\r\n            //REMOVE OLD BALANCE\r\n            balances[_oldAddress] = 0;\r\n\r\n            //TRANSFER FROZEN BALANCES AS WELL\r\n            if(frozenBalances[_oldAddress] > 0){\r\n\r\n                frozenBalances[_newAddress] = frozenBalances[_oldAddress];\r\n                frozenTiming[_newAddress] = frozenTiming[_oldAddress];\r\n\r\n                emit FreezeBalance(_newAddress, frozenBalances[_newAddress], frozenTiming[_newAddress]);\r\n\r\n                frozenBalances[_oldAddress] = 0;\r\n                frozenTiming[_oldAddress] = 0;\r\n            }\r\n        }\r\n\r\n        //ASSIGN NEW ADDRESS\r\n        roles[_roleId] = _newAddress;\r\n    }\r\n\r\n    /*\r\n     * The current conversion rate of\r\n     * 1 QARK => USD cents.\r\n     */\r\n    uint public conversionRate;\r\n\r\n    function setRate(uint _newConversionRate) public {\r\n        require(msg.sender == roles[5], 'Only rate updater is allowed to perform this!');\r\n        conversionRate = _newConversionRate;\r\n    }\r\n\r\n    /*\r\n     * Stores the locked balances\r\n     * of those who bought during\r\n     * private sale and are restricted\r\n     * from selling after public sale.\r\n     */\r\n    mapping(address => uint256) lockedBalances;\r\n\r\n    /*\r\n     * UNIX timestamp of the start\r\n     * time of the public sale.\r\n     */\r\n    uint public pubSaleStart;\r\n\r\n    /*\r\n     * UNIX timestamp of the end\r\n     * time of the public sale.\r\n     */\r\n    uint public pubSaleEnd;\r\n\r\n    /*\r\n     * UNIX timestamp of the end\r\n     * time of the private buyers'\r\n     * restrictions.\r\n     */\r\n    uint public restrictionEnd;\r\n\r\n    /*\r\n     * Sets the public sale and\r\n     * restrictions related timings.\r\n     */\r\n    function setTiming(uint _pubSaleStart, uint _pubSaleEnd, uint _restrictionEnd) public onlyOwner {\r\n        require(pubSaleStart == 0 && pubSaleEnd == 0 && restrictionEnd == 0, 'Timing only can be set once');\r\n        pubSaleStart = _pubSaleStart;\r\n        pubSaleEnd = _pubSaleEnd;\r\n        restrictionEnd = _restrictionEnd;\r\n    }\r\n\r\n    /*\r\n     * Constructs the contract\r\n     * with 333,333,300 QARK tokens\r\n     * with 18 decimals.\r\n     */\r\n    constructor() public {\r\n        symbol = \"SRFX\";\r\n        name = \"Something Random For Testing #2\";\r\n        decimals = 18;\r\n        _totalSupply = 333333000 * 10**uint(decimals);\r\n    }\r\n\r\n    /*\r\n     * Returns the total supply\r\n     * minus the amounts of burned tokens.\r\n     */\r\n    function totalSupply() public view returns (uint) {\r\n        return _totalSupply.sub(balances[address(0)]);\r\n    }\r\n\r\n    /*\r\n     * Returns the balance\r\n     * of a given token holder.\r\n     */\r\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n    /*\r\n     * Returns the locked balance\r\n     * of a given token holder.\r\n     */\r\n    function lockedBalanceOf(address tokenOwner) public view returns (uint lockedBalance) {\r\n        return lockedBalances[tokenOwner];\r\n    }\r\n\r\n    /*\r\n     * Stores the frozen balances\r\n     * of those who bought have\r\n     * frozen their own balances\r\n     * until a certain UNIX timestamp.\r\n     */\r\n    mapping(address => uint) frozenBalances;\r\n\r\n    /*\r\n     * Stores the UNIX timestamps\r\n     * until when a certain token\r\n     * holders' tokens have frozen\r\n     * their own tokens.\r\n     */\r\n    mapping(address => uint) frozenTiming;\r\n\r\n    /*\r\n     * Method to freeze own\r\n     * tokens until a certain time.\r\n     */\r\n    function freezeOwnTokens(uint amount, uint until) public {\r\n\r\n        //FIRST AUTO UNFREEZE ANY PREVIOUSLY LOCKED TOKENS\r\n        _autoUnfreeze();\r\n\r\n        //AVAIL BALANCE MUST BE GREATER THAN TOKENS TO BE LOCKED\r\n        require(balances[msg.sender] - lockedBalances[msg.sender] > amount);\r\n\r\n        //ALSO CURRENTLY LOCKED AMOUNT MUST BE LESS THAN TOKENS TO BE LOCKED\r\n        require(frozenBalances[msg.sender] < amount);\r\n\r\n        //LOCK PERIOD MUST BE FUTURE, AND GREATER THAN CURRENT LOCK\r\n        require(until > block.timestamp && until > frozenTiming[msg.sender]);\r\n\r\n        //MAKE FREEZE\r\n        frozenBalances[msg.sender] = amount;\r\n        frozenTiming[msg.sender] = until;\r\n    }\r\n\r\n    /*\r\n     * Returns the frozen balance\r\n     * of a given token holder.\r\n     */\r\n    function frozenBalanceOf(address tokenOwner) public view returns (uint frozenBalance) {\r\n        return frozenBalances[tokenOwner];\r\n    }\r\n\r\n    /*\r\n     * Returns the UNIX timestamp\r\n     * until when some tokens\r\n     * of a given token holder\r\n     * are frozen.\r\n     */\r\n    function frozenTimingOf(address tokenOwner) public view returns (uint until) {\r\n        return frozenTiming[tokenOwner];\r\n    }\r\n\r\n    /*\r\n     * Automatically unfreezes\r\n     * all tokens of msg.sender\r\n     * if freeze time has passed.\r\n     */\r\n    function _autoUnfreeze() private {\r\n\r\n        if(frozenBalances[msg.sender] > 0 && block.timestamp > frozenTiming[msg.sender]){\r\n            frozenBalances[msg.sender] = 0;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Private method to handle private\r\n     * sale transfers.\r\n     */\r\n    function _privTransfer(address to, uint tokens) private returns (bool success) {\r\n\r\n        //ONLY PRIVATE SELLER CAN EXECUTE PRIVATE SALE TRANSACTION\r\n        require(msg.sender == roles[0], 'Only private seller can make private sale TX!');\r\n\r\n        //NO PRIVATE SALE TRANSACTION CAN BE MADE AFTER PUBLIC SALE CLOSED\r\n        require(block.timestamp < pubSaleEnd, 'No transfer from private seller after public sale!');\r\n\r\n        //LOCK THE TOKEN AMOUNT OF THE BUYER\r\n        lockedBalances[to] = lockedBalances[to].add(tokens);\r\n        emit LockBalance(msg.sender, to, tokens);\r\n        emit LogAddress('PrivateSaleFrom', msg.sender);\r\n        //MAKE A REGULAR TRANSFER\r\n        return _regularTransfer(to, tokens);\r\n    }\r\n\r\n    /*\r\n     * Private method to handle public\r\n     * sale (IEO) transfers.\r\n     */\r\n    function _pubTransfer(address to, uint tokens) private returns (bool success) {\r\n\r\n        //MAKE SURE PRIVATE AND RESTRICTED TRANSACTIONS ARE NOT HANDLED HERE\r\n        require(msg.sender != roles[0], 'Public transfer not allowed from private seller');\r\n\r\n        //MAKE SURE THAT ONLY REGULAR TRANSACTIONS CAN BE EXECUTED NOT INVOLVING LOCKED TOKENS\r\n        require(balances[msg.sender].sub(lockedBalances[msg.sender]) >= tokens, 'Not enough unlocked tokens!');\r\n        emit LogAddress('PublicSaleFrom', msg.sender);\r\n        //MAKE A REGULAR TRANSFER\r\n        return _regularTransfer(to, tokens);\r\n    }\r\n\r\n    /*\r\n     * Private method to handle secondary\r\n     * market transfers (after IEO).\r\n     */\r\n    function _postPubTransfer(address to, uint tokens) private returns (bool success) {\r\n\r\n        //IF PUBLIC SALE ENDED AND EXCHANGE OR PRIVATE SELLER TRIES TO MAKE A TRANSFER\r\n        if(block.timestamp > pubSaleEnd + 7 * 24 * 60 * 60 && (msg.sender == roles[1] || msg.sender == roles[0])){\r\n            revert('No transfer from exchange / private seller after public sale!');\r\n        }\r\n\r\n        //IF PRIVATE SALE RESTRICTIONS DID NOT END YET AND SENDER IS A PRIVATE SALE BUYER\r\n        if(block.timestamp < restrictionEnd && lockedBalances[msg.sender] > 0){\r\n            emit LogAddress('RestrictedSaleFrom', msg.sender);\r\n            return _restrictedTransfer(to, tokens);\r\n        }\r\n        emit LogAddress('PostPublicSaleFrom', msg.sender);\r\n        //ELSE MAKE A REGULAR TRANSFER\r\n        return _regularTransfer(to, tokens);\r\n    }\r\n\r\n    /*\r\n     * Makes sure that private sale buyers\r\n     * can withdraw unsold tokens on exchanges\r\n     * even if restrictions are active.\r\n     */\r\n    mapping(address => address) withdrawMap;\r\n\r\n    /*\r\n     * Private method to handle transactions\r\n     * of private sale buyers to whom certain\r\n     * restrictions apply to protect market prices.\r\n     */\r\n    function _restrictedTransfer(address to, uint tokens) private returns (bool success) {\r\n\r\n        //DECLARE CURRENT BALANCES\r\n        uint totalBalance = balances[msg.sender];\r\n        uint lockedBalance = lockedBalances[msg.sender];\r\n        uint unlockedBalance = totalBalance.sub(lockedBalance);\r\n\r\n        //IF PRICE IS LOW, THIS ADDRESS IS RESTRICTED, AND IS NOT TRYING TO WITHDRAW TO HIS PREVIOUS ACCOUNT\r\n        if(conversionRate < 39 && unlockedBalance < tokens && to != withdrawMap[msg.sender]){\r\n            revert('Private token trading halted because of low market prices!');\r\n        }\r\n\r\n        //IF THERE IS NOT ENOUGH UNLOCKED BALANCE TO SEND TOKENS\r\n        if(unlockedBalance < tokens){\r\n\r\n            //CALCULATE TOKENS TO BE LOCKED ON RECIPIENT'S ACCOUNT\r\n            uint lockables = tokens.sub(unlockedBalance);\r\n\r\n            //LOCK THEM\r\n            lockedBalances[to] = lockedBalances[to].add(lockables);\r\n            emit LockBalance(msg.sender, to, lockables);\r\n\r\n            //RELEASE LOCK ON SENDER\r\n            lockedBalances[msg.sender] = lockedBalances[msg.sender].sub(lockables);\r\n\r\n            //UPDATE WITHDRAW MAP TO ENABLE SENDER TO SEND FUNDS BACK TO HIMSELF LATER\r\n            withdrawMap[to] = msg.sender;\r\n        }\r\n\r\n        //PERFORM A REGULAR TRANSFER\r\n        return _regularTransfer(to, tokens);\r\n    }\r\n\r\n    /*\r\n     * Performs a regular\r\n     * ERC20 transfer.\r\n     */\r\n    function _regularTransfer(address to, uint tokens) private returns (bool success) {\r\n\r\n        //DEDUCT FROM SENDER, CREDIT BENEFICIARY\r\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        emit Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * Transfer logic to handle\r\n     * all possible scenarios:\r\n     * - Private sale\r\n     * - Public sale (IEO)\r\n     * - Secondary market trading\r\n     */\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n\r\n        //AUTOMATICALLY UNFREEZE ANY UNFREEZABLE TOKENS\r\n        _autoUnfreeze();\r\n\r\n        //IF THE SENDER STILL HAS FROZEN BALANCE, CHECK FOR LIQUIDITY\r\n        if(frozenBalances[msg.sender] > 0 && balances[msg.sender] - frozenBalances[msg.sender] < tokens){\r\n            revert('Frozen balance can not be spent yet, insufficient tokens!');\r\n        }\r\n\r\n        //REQUIRE THAT SENDER HAS THE BALANCE TO MAKE THE TRANSFER\r\n        require(balances[msg.sender] >= tokens, 'Not enough liquid tokens!');\r\n\r\n        //IF RESERVE IS TRYING TO MAKE A TRANSFER AND 1 YEAR FREEZE NOT PASSED YET, REVERT\r\n        if(msg.sender == roles[4] && block.timestamp < pubSaleEnd + 60 * 60 * 24 * 30 * 12){\r\n            revert('Reserve can not be accessed before the 1 year freeze period');\r\n        }\r\n\r\n        //HANDLE PRIVATE SALE TRANSACTIONS\r\n        if(msg.sender == roles[0]){\r\n            return _privTransfer(to, tokens);\r\n        }\r\n\r\n        //HANDLE PUBLIC SALE TRANSACTIONS\r\n        if(block.timestamp > pubSaleStart && block.timestamp < pubSaleEnd){\r\n            return _pubTransfer(to, tokens);\r\n        }\r\n\r\n        //HANDLE TRANSACTIONS AFTER PUBLIC SALE ENDED\r\n        if(block.timestamp > pubSaleEnd){\r\n            return _postPubTransfer(to, tokens);\r\n        }\r\n\r\n        //NO CASES MATCHED\r\n        return false;\r\n    }\r\n\r\n    /*\r\n     * Grant spend ability\r\n     * of tokens to a third party.\r\n     */\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n\r\n        //DURING RESTRICTION PERIOD, NO APPROVAL TRANSFERS FOR PRIV BUYERS\r\n        if(block.timestamp < restrictionEnd){\r\n            require(lockedBalances[msg.sender] == 0, 'This address MUST not start approval related transactions!');\r\n            require(lockedBalances[spender] == 0, 'This address MUST not start approval related transactions!');\r\n        }\r\n\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * Transfer tokens from another\r\n     * address given they granted approval\r\n     * to msg.sender of the current call.\r\n     */\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n\r\n        //DURING RESTRICTION PERIOD, NO APPROVAL TRANSFERS FOR PRIV BUYERS\r\n        if(block.timestamp < restrictionEnd){\r\n            require(lockedBalances[msg.sender] == 0, 'This address MUST not start approval related transactions!');\r\n            require(lockedBalances[from] == 0, 'This address MUST not start approval related transactions!');\r\n            require(lockedBalances[to] == 0, 'This address MUST not start approval related transactions!');\r\n        }\r\n\r\n        balances[from] = balances[from].sub(tokens);\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        emit Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * Returns the amount of tokens a\r\n     * spender is allowed to spend\r\n     * from tokenOwner's balance.\r\n     */\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n    function () external payable {\r\n\r\n        //DON'T ACCEPT ETH\r\n        revert();\r\n    }\r\n\r\n    /*\r\n     * Enables the contract owner\r\n     * to retrieve other ERC20 tokens\r\n     * sent to the contract.\r\n     */\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"frozenTimingOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"until\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newConversionRate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimReserve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pubSaleStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pubSaleEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_restrictionEnd\",\"type\":\"uint256\"}],\"name\":\"setTiming\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"lockedBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lockedBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pubSaleEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roleId\",\"type\":\"uint256\"}],\"name\":\"getRoleAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"conversionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"until\",\"type\":\"uint256\"}],\"name\":\"freezeOwnTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"frozenBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"frozenBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pubSaleStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"restrictionEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roleId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setRoleAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"LockBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"until\",\"type\":\"uint256\"}],\"name\":\"FreezeBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogUint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"LogString\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"LogAddress\",\"type\":\"event\"}]","ContractName":"SRFX","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://f427df193256e13a82e04b90dd312c2b75de57dc5047600ff07b52c92605c3a7"}]}