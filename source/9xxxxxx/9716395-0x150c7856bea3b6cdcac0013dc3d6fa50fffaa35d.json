{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11;\r\n\r\n/**\r\n * @title Gods Unchained - Fission Pool\r\n * @author Mythic Titan\r\n */\r\ncontract FissionPool {\r\n    // Create a pool by sending a Shadow, Gold, or Diamond Gods Unchained Card\r\n    // Set how many lower tier cards are required to select a Champion\r\n    // Players send a lower tier Gods Unchained Card to the pool\r\n    // One Champion selected at random wins the higher tier card\r\n\r\n    // ==== EVENTS ==== //\r\n\r\n    /**\r\n     * @dev OnAddPlayer emits an event when a player enters a pool\r\n     *\r\n     * @param _poolId - The ID of the pool\r\n     * @param _owner - Token owner\r\n     * @param _tokenId - The Gods Unchained Token ID\r\n     */\r\n    event OnAddPlayer(\r\n        uint256 indexed _poolId,\r\n        address indexed _owner,\r\n        uint256 _tokenId\r\n    );\r\n\r\n    /**\r\n     * @dev OnCancelPool emits an event when a host cancels a pool\r\n     *\r\n     * @param _poolId - The ID of the pool\r\n     */\r\n    event OnCancelPool(\r\n        uint256 indexed _poolId\r\n    );\r\n\r\n    /**\r\n     * @dev OnCollect emits an event when the host collects their cards from a pool\r\n     *\r\n     * @param _poolId - The ID of the pool\r\n     */\r\n    event OnCollect(\r\n        uint256 indexed _poolId\r\n    );\r\n\r\n    /**\r\n     * @dev OnCreatePool emits an event when a host creates a new pool\r\n     *\r\n     * @param _poolId - The ID of the pool\r\n     * @param _host - Address of the pool Host\r\n     * @param _proto - Gods Unchained proto ID\r\n     * @param _quality - Gods Unchained card quality\r\n     * @param _quorum - Number of cards required to activate\r\n     * @param _tokenId - The Gods Unchained Token ID\r\n     */\r\n    event OnCreatePool(\r\n        uint256 indexed _poolId,\r\n        address indexed _host,\r\n        uint16 _proto,\r\n        uint8 _quality,\r\n        uint256 _quorum,\r\n        uint256 _tokenId\r\n    );\r\n\r\n    /**\r\n     * @dev OnRemovePlayer emits an event when a player leaves a pool\r\n     *\r\n     * @param _poolId - The ID of the pool\r\n     * @param _index - The index of the Player removed\r\n     */\r\n    event OnRemovePlayer(\r\n        uint256 indexed _poolId,\r\n        uint256 _index\r\n    );\r\n\r\n    /**\r\n     * @dev OnWinner emits an event when a winner is selected\r\n     *\r\n     * @param _poolId - The ID of the pool\r\n     * @param _winner - The player's address that won\r\n     * @param _random - The randomly selected index\r\n     */\r\n    event OnWinner(\r\n        uint256 indexed _poolId,\r\n        address indexed _winner,\r\n        uint256 _random\r\n    );\r\n\r\n    // ==== STRUCT ==== //\r\n    struct Pool {\r\n        address host;\r\n        Player[] players;\r\n        uint16 proto;\r\n        uint8 quality;\r\n        uint256 quorum;\r\n        uint256 tokenId;\r\n    }\r\n\r\n    struct Player {\r\n        address owner;\r\n        uint256 tokenId;\r\n    }\r\n\r\n    // ==== PUBLIC VARIABLES ==== //\r\n\r\n    // Mapping pool ID to Pool\r\n    mapping(uint256 => Pool) public pools;\r\n\r\n    /**\r\n     * @dev tokenInterface interfaces with the ERC721\r\n     */\r\n    interfaceERC721 public tokenInterface;\r\n\r\n    /**\r\n     * @dev totalPools increments each time a new pool is created\r\n     */\r\n    uint256 public totalPools;\r\n\r\n    // ==== CONSTRUCTOR ==== //\r\n\r\n    /**\r\n     * @dev constructor runs once during contract deployment\r\n     *\r\n     * @param _tokenAddress - The Gods Unchained contract address\r\n     */\r\n    constructor(address _tokenAddress)\r\n        public\r\n    {\r\n        tokenInterface = interfaceERC721(_tokenAddress);\r\n    }\r\n\r\n    // ==== MODIFIERS ==== //\r\n\r\n    /**\r\n     * @dev onlyEOA requires msg.sender to be an externally owned account\r\n     */\r\n    modifier onlyEOA() {\r\n        require(msg.sender == tx.origin, \"only externally owned accounts\");\r\n        _;\r\n    }\r\n\r\n    // ==== PUBLIC WRITE FUNCTIONS ==== //\r\n\r\n    /**\r\n     * @dev activatePool selects a winner\r\n     *\r\n     * @param poolId - The ID of the pool\r\n     */\r\n    function activatePool(uint256 poolId)\r\n        public\r\n        onlyEOA\r\n    {\r\n        // Reference the pool\r\n        Pool storage pool = pools[poolId];\r\n\r\n        // Require pool is ready to activate\r\n        require( pool.quorum > 0 && pool.players.length == pool.quorum, \"requires minimum number of players\");\r\n\r\n        // Select Winner at random\r\n        uint256 random = getRandom(pool.quorum, poolId);\r\n\r\n        // Winner\r\n        address winner = pool.players[random].owner;\r\n\r\n        // Invalidate the Pool\r\n        delete pool.quorum;\r\n\r\n        // Transfer prize to the winner\r\n        tokenInterface.transferFrom(address(this), winner, pool.tokenId);\r\n\r\n        // Emit an event log when a winner is selected\r\n        emit OnWinner(poolId, winner, random);\r\n    }\r\n\r\n    function cancelPool(uint256 poolId)\r\n        public\r\n        onlyEOA\r\n    {\r\n        // Reference the pool\r\n        Pool storage pool = pools[poolId];\r\n\r\n        // Check pool is active\r\n        require(pool.quorum > 0, \"must be an active pool\");\r\n\r\n        // Check msg.sender is the host\r\n        require(pool.host == msg.sender, \"must be the host\");\r\n\r\n        // Refund all cards in the pool\r\n        if (pool.players.length > 0) {\r\n            for(uint256 i = pool.players.length - 1; i >= 0; i--) {\r\n                tokenInterface.transferFrom(address(this), pool.players[i].owner, pool.players[i].tokenId);\r\n                pool.players.pop();\r\n            }\r\n        }\r\n\r\n        // Store reference to the host and token\r\n        address host = pool.host;\r\n        uint256 tokenId = pool.tokenId;\r\n\r\n        // Delete the pool\r\n        delete pools[poolId];\r\n\r\n        // Refund the host's card\r\n        tokenInterface.transferFrom(address(this), host, tokenId);\r\n\r\n        emit OnCancelPool(poolId);\r\n    }\r\n\r\n    /**\r\n     * @dev collectCards enables a host to collect their cards after a pool activates\r\n     *\r\n     * @param poolId - The ID of the pool\r\n     */\r\n    function collectCards(uint256 poolId)\r\n        public\r\n    {\r\n        // Reference the pool\r\n        Pool storage pool = pools[poolId];\r\n\r\n        // Require msg.sender is the host\r\n        require(pool.host == msg.sender, \"must be the host\");\r\n\r\n        // Require pool was activated\r\n        require(pool.quorum == 0, \"pool not activated\");\r\n\r\n        // Send all cards in the pool to the host\r\n        for(uint256 i = pool.players.length - 1; i >= 0; i--) {\r\n            tokenInterface.transferFrom(address(this), pool.host, pool.players[i].tokenId);\r\n            pool.players.pop();\r\n        }\r\n\r\n        // Delete the pool\r\n        delete pools[poolId];\r\n\r\n        emit OnCollect(poolId);\r\n    }\r\n\r\n    /**\r\n     * @dev exitPool allows a player to remove a card from a Pool\r\n     *\r\n     * @param poolId - The ID of the pool\r\n     */\r\n    function exitPool(uint256 poolId, uint256 index)\r\n        public\r\n        onlyEOA\r\n    {\r\n        // Reference players in the pool\r\n        Player[] storage players = pools[poolId].players;\r\n\r\n        // Require msg.sender is the player\r\n        require(players[index].owner == msg.sender, \"Must be the player\");\r\n\r\n        // Store the token ID\r\n        uint256 tokenId = players[index].tokenId;\r\n\r\n        // Set the last index equal to the removed player\r\n        players[index] = players[players.length - 1];\r\n\r\n        // Remove last element in the list of players\r\n        players.pop();\r\n\r\n        // Transfer the token to the owner\r\n        tokenInterface.transferFrom(address(this), msg.sender, tokenId);\r\n\r\n        // Emit an event when a player leaves a pool\r\n        emit OnRemovePlayer(poolId, index);\r\n    }\r\n\r\n    // ==== PUBLIC READ FUNCTIONS ==== //\r\n\r\n    /**\r\n     * @dev exitPool allows a player to remove a card from a Pool\r\n     *\r\n     * @param poolId - The ID of the pool\r\n     *\r\n     * @return _tokenId - The host's token ID\r\n     * @return _host - The pool host\r\n     * @return _proto - The proto\r\n     * @return _quality - The quality player's send to the pool\r\n     * @return _quorum - Number of tokens required to activate\r\n     * @return _players - List of players in the pool\r\n     * @return _tokenIds - List of token ids in the pool\r\n     */\r\n    function getPool(uint256 poolId)\r\n        public\r\n        view\r\n        returns(uint256 _tokenId, address _host, uint16 _proto, uint8 _quality, uint256 _quorum, address[] memory _players, uint256[] memory _tokenIds)\r\n    {\r\n        // Reference the pool\r\n        Pool storage pool = pools[poolId];\r\n\r\n        _host = pool.host;\r\n        _proto = pool.proto;\r\n        _quality = pool.quality;\r\n        _quorum = pool.quorum;\r\n        _tokenId = pool.tokenId;\r\n\r\n        for(uint256 i = 0; i < pool.players.length; i++) {\r\n            _players[i] = pool.players[i].owner;\r\n            _tokenIds[i] = pool.players[i].tokenId;\r\n        }\r\n    }\r\n\r\n    // ==== EXTERNAL FUNCTIONS ==== //\r\n\r\n    /**\r\n     * @dev onERC721Received handles receiving an ERC721 token\r\n     *\r\n     * _operator - The address which called `safeTransferFrom` function\r\n     * @param _from - The address which previously owned the token\r\n     * @param _tokenId - The NFT IDentifier which is being transferred\r\n     * @param _data - Additional data with no specified format\r\n     *\r\n     * @return Receipt\r\n     */\r\n    function onERC721Received(address /*_operator*/, address _from, uint256 _tokenId, bytes calldata _data)\r\n        external\r\n        returns(bytes4)\r\n    {\r\n        // Require token address is authorized\r\n        require(msg.sender == address(tokenInterface), \"must be the token address\");\r\n\r\n        // Require token holder is an externally owned account\r\n        require(tx.origin == _from, \"token owner must be an externally owned account\");\r\n\r\n        // Parse data payload\r\n        (uint256 poolId, uint256 quorum) = abi.decode(_data, (uint256, uint256));\r\n\r\n        // Get the Gods Unchained Proto and Quality from Token ID\r\n        (uint16 proto, uint8 quality) = tokenInterface.getDetails(_tokenId);\r\n\r\n        // Create or Join a Fusion Pool\r\n        if (poolId == 0) {\r\n            // Create new pool\r\n            createPool(_from, proto, quality, quorum, _tokenId);\r\n        } else {\r\n            // Join existing pool\r\n            joinPool(poolId, _from, proto, quality, _tokenId);\r\n        }\r\n\r\n        // ERC721_RECEIVED Receipt (magic value)\r\n        return 0x150b7a02;\r\n    }\r\n\r\n    // ==== PRIVATE FUNCTIONS ==== //\r\n\r\n    /**\r\n     * @dev createPool creates a new pool\r\n     *\r\n     * @param host - The host of the pool\r\n     * @param proto - Gods Unchained proto\r\n     * @param quality - Gods Unchained quality\r\n     * @param quorum - Number of players needed to activate a pool\r\n     * @param tokenId - ERC721 Token ID\r\n     */\r\n    function createPool(address host, uint16 proto, uint8 quality, uint256 quorum, uint256 tokenId)\r\n        private\r\n    {\r\n        // Check token quality\r\n        require(quality < 4, \"Must be Shadow, Gold, or Diamond\");\r\n\r\n        // Check quorum\r\n        require(quorum > 0 && quorum < 11, \"must be an integer from 1 to 10\");\r\n\r\n        // Increment total number of pools\r\n        totalPools = totalPools + 1;\r\n\r\n        // Reference the pool\r\n        Pool storage pool = pools[totalPools];\r\n\r\n        // Create new pool\r\n        pool.host = host;\r\n        pool.proto = proto;\r\n        pool.quality = quality + 1;\r\n        pool.quorum = quorum;\r\n        pool.tokenId = tokenId;\r\n\r\n        // Emit event when a pool is created\r\n        emit OnCreatePool(totalPools, host, proto, quality, quorum, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev joinPool adds a card to a pool\r\n     *\r\n     * @param poolId - The host of the pool\r\n     * @param owner - Card Owner\r\n     * @param proto - Gods Unchained proto\r\n     * @param quality - Gods Unchained quality\r\n     * @param tokenId - ERC721 Token ID\r\n     */\r\n    function joinPool(uint256 poolId, address owner, uint16 proto, uint8 quality, uint256 tokenId)\r\n        private\r\n    {\r\n        // Reference to the pool\r\n        Pool storage pool = pools[poolId];\r\n\r\n        // Require a valid pool\r\n        require(pool.quorum > 0, \"invalid pool\");\r\n\r\n        // Require an opening in the pool\r\n        require(pool.players.length < pool.quorum, \"full pool\");\r\n\r\n        // Require valid proto\r\n        require(proto == pool.proto, \"proto must match\");\r\n\r\n        // Require valid quality\r\n        require(quality == pool.quality, \"quality must match\");\r\n\r\n        // Add player to the pool\r\n        pool.players.push(Player(owner, tokenId));\r\n\r\n        // Emit event when a new player joins a pool\r\n        emit OnAddPlayer(poolId, owner, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev getRandom generates a random integer from 0 to (max - 1)\r\n     *\r\n     * @param max - Maximum number of integers to select from\r\n     * @param poolId - ID of the Pool\r\n     * @return random - The randomly selected integer\r\n     */\r\n    function getRandom(uint256 max, uint256 poolId)\r\n        private\r\n        view\r\n        returns(uint256 random)\r\n    {\r\n        // Blockhash from last block\r\n        uint256 blockhash_ = uint256(blockhash(block.number - 1));\r\n\r\n        // Randomly generated integer\r\n        random = uint256(keccak256(abi.encodePacked(\r\n            // Unix timestamp in seconds\r\n            block.timestamp,\r\n            // Address of the block miner\r\n            block.coinbase,\r\n            // Difficulty of the block\r\n            block.difficulty,\r\n            // Blockhash from last block\r\n            blockhash_,\r\n            // Pool ID\r\n            poolId\r\n        ))) % max;\r\n    }\r\n}\r\n\r\n// ==== INTERFACE ==== //\r\n/**\r\n * @title Abstract Contract Interface\r\n */\r\ncontract interfaceERC721 {\r\n    function getDetails(uint256 _tokenId) public view returns (uint16, uint8);\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"getPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_host\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_proto\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"_quality\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_quorum\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_players\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"activatePool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"collectCards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"cancelPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"host\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"proto\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"quality\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"quorum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"exitPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenInterface\",\"outputs\":[{\"internalType\":\"contract interfaceERC721\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"OnAddPlayer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"}],\"name\":\"OnCancelPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"}],\"name\":\"OnCollect\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_host\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_proto\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_quality\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_quorum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"OnCreatePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"OnRemovePlayer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_random\",\"type\":\"uint256\"}],\"name\":\"OnWinner\",\"type\":\"event\"}]","ContractName":"FissionPool","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000e3a2a1f2146d86a604adc220b4967a898d7fe07","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://ce05e550afec8f1f143a24ca1a19c815224ba18736f7d8433364e7b23590a808"}]}