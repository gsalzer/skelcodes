{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\ncontract Auth {\r\n  address internal backupAdmin;\r\n  address internal mainAdmin;\r\n  address internal contractAdmin;\r\n  address internal dabAdmin;\r\n  address internal gemAdmin;\r\n  address internal LAdmin;\r\n\r\n  constructor(\r\n    address _backupAdmin,\r\n    address _mainAdmin,\r\n    address _contractAdmin,\r\n    address _dabAdmin,\r\n    address _gemAdmin,\r\n    address _LAdmin\r\n  )\r\n  internal\r\n  {\r\n    backupAdmin = _backupAdmin;\r\n    mainAdmin = _mainAdmin;\r\n    contractAdmin = _contractAdmin;\r\n    dabAdmin = _dabAdmin;\r\n    gemAdmin = _gemAdmin;\r\n    LAdmin = _LAdmin;\r\n  }\r\n\r\n  modifier onlyBackupAdmin() {\r\n    require(isBackupAdmin(), \"onlyBackupAdmin\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyMainAdmin() {\r\n    require(isMainAdmin(), \"onlyMainAdmin\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyBackupOrMainAdmin() {\r\n    require(isMainAdmin() || isBackupAdmin(), \"onlyBackupOrMainAdmin\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyContractAdmin() {\r\n    require(isContractAdmin() || isMainAdmin(), \"onlyContractAdmin\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyLAdmin() {\r\n    require(isLAdmin() || isMainAdmin(), \"onlyLAdmin\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyDABAdmin() {\r\n    require(isDABAdmin() || isMainAdmin(), \"onlyDABAdmin\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyGEMAdmin() {\r\n    require(isGEMAdmin() || isMainAdmin(), \"onlyGEMAdmin\");\r\n    _;\r\n  }\r\n\r\n  function isBackupAdmin() public view returns (bool) {\r\n    return msg.sender == backupAdmin;\r\n  }\r\n\r\n  function isMainAdmin() public view returns (bool) {\r\n    return msg.sender == mainAdmin;\r\n  }\r\n\r\n  function isContractAdmin() public view returns (bool) {\r\n    return msg.sender == contractAdmin;\r\n  }\r\n\r\n  function isLAdmin() public view returns (bool) {\r\n    return msg.sender == LAdmin;\r\n  }\r\n\r\n  function isDABAdmin() public view returns (bool) {\r\n    return msg.sender == dabAdmin;\r\n  }\r\n\r\n  function isGEMAdmin() public view returns (bool) {\r\n    return msg.sender == gemAdmin;\r\n  }\r\n}\r\n\r\n\r\ninterface IContractNo1 {\r\n  function minJP() external returns (uint);\r\n}\r\n\r\ninterface IContractNo3 {\r\n\r\n  function isCitizen(address _user) view external returns (bool);\r\n\r\n  function register(address _user, string _userName, address _inviter) external returns (uint);\r\n\r\n  function addF1M9DepositedToInviter(address _invitee, uint _amount) external;\r\n\r\n  function checkInvestorsInTheSameReferralTree(address _inviter, address _invitee) external view returns (bool);\r\n\r\n  function increaseInviterF1HaveJoinedPackage(address _invitee) external;\r\n\r\n  function increaseInviterF1HaveJoinedM9Package(address _invitee) external;\r\n\r\n  function addNetworkDepositedToInviter(address _inviter, uint _dabAmount, uint _gemAmount) external;\r\n\r\n  function getF1M9Deposited(address _investor) external view returns (uint);\r\n\r\n  function getDirectlyInviteeHaveJoinedM9Package(address _investor) external view returns (address[]);\r\n\r\n  function getRank(address _investor) external view returns (uint8);\r\n\r\n  function getInviter(address _investor) external view returns (address);\r\n\r\n  function showInvestorInfo(address _investorAddress) external view returns (uint, string memory, address, address[],  address[],  address[], uint, uint, uint, uint, uint);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Multiplies two unsigned integers, reverts on overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, 'SafeMath mul error');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, 'SafeMath div error');\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, 'SafeMath sub error');\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two unsigned integers, reverts on overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, 'SafeMath add error');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n   * reverts when dividing by zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, 'SafeMath mod error');\r\n    return a % b;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ncontract IERC20 {\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\r\n    function balanceOf(address who) public view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ContractNo2 is Auth {\r\n  using SafeMath for uint;\r\n\r\n  enum PackageType {\r\n    M0,\r\n    M3,\r\n    M6,\r\n    M9,\r\n    M12,\r\n    M15,\r\n    M18\r\n  }\r\n\r\n  enum CommissionType {\r\n    DAB,\r\n    GEM\r\n  }\r\n\r\n  struct Balance {\r\n    uint totalDeposited;\r\n    uint dividendBalance;\r\n    uint dabStakingBalance;\r\n    uint gemStakingBalance;\r\n    int gemBalance;\r\n    uint totalProfited;\r\n  }\r\n\r\n  struct Package {\r\n    PackageType packageType;\r\n    uint lastPackage;\r\n    uint dabAmount;\r\n    uint gemAmount;\r\n    uint startAt;\r\n    uint endAt;\r\n  }\r\n\r\n  struct TTracker {\r\n    uint time;\r\n    uint amount;\r\n  }\r\n\r\n  IContractNo1 public contractNo1;\r\n  IContractNo3 public contractNo3;\r\n\r\n  uint constant private secondsInOntMonth = 2592000; // 30 * 24 * 3600\r\n\r\n  uint public minT = 1e18;\r\n  uint public maxT = 10000e18;\r\n  uint8 public gemCommission = 10;\r\n  uint32 public profitInterval = 60;\r\n  uint public minProfit = 1e18;\r\n  bool private gemT = true;\r\n  string DAB = 'DAB';\r\n  string GEM = 'GEM';\r\n  uint16 firstProfitCheckpoint = 1e4;\r\n  uint16 secondProfitCheckpoint = 2e4;\r\n  uint16 thirdProfitCheckpoint = 3e4;\r\n  mapping(address => TTracker[]) private tTracker;\r\n  mapping(address => Package) private packages;\r\n  mapping(address => Balance) private balances;\r\n  mapping(address => bool) private ha;\r\n  mapping(address => uint) private lP;\r\n  mapping(address => uint) private lW;\r\n  mapping(address => mapping(address => mapping(string => uint))) private commissions;\r\n\r\n  event DividendBalanceChanged(address user, address reason, int amount);\r\n  event GEMBalanceChanged(address user, address reason, int amount);\r\n  event GEMBalanceTransferred(address from, address to, int amount, int receivedAmount);\r\n\r\n  modifier onlyContractAContract() {\r\n    require(msg.sender == address(contractNo1), 'onlyContractAContract');\r\n    _;\r\n  }\r\n\r\nconstructor(\r\n    address _backupAdmin,\r\n    address _mainAdmin,\r\n    address _gemAdmin\r\n  )\r\n  public\r\n  Auth(\r\n    _backupAdmin,\r\n    _mainAdmin,\r\n    msg.sender,\r\n    address(0x0),\r\n    _gemAdmin,\r\n    address(0x0)\r\n  ) {\r\n  }\r\n\r\n  // ADMINS FUNCTIONS\r\n\r\n  function setE(address _u) onlyMainAdmin public {\r\n    packages[_u].endAt = now;\r\n  }\r\n\r\n  function setLW(address _u) onlyMainAdmin public {\r\n    lW[_u] = now - 31 days;\r\n  }\r\n\r\n  function setC(address _c) onlyContractAdmin public {\r\n    contractNo3 = IContractNo3(_c);\r\n  }\r\n\r\n  function setS(address _s) onlyContractAdmin public {\r\n    contractNo1 = IContractNo1(_s);\r\n  }\r\n\r\n  function updateBackupAdmin(address _newBackupAdmin) onlyBackupAdmin public {\r\n    require(_newBackupAdmin != address(0x0), 'Invalid address');\r\n    backupAdmin = _newBackupAdmin;\r\n  }\r\n\r\n  function updateMainAdmin(address _newMainAdmin) onlyBackupOrMainAdmin public {\r\n    require(_newMainAdmin != address(0x0), 'Invalid address');\r\n    mainAdmin = _newMainAdmin;\r\n  }\r\n\r\n  function updateContractAdmin(address _newContractAdmin) onlyMainAdmin public {\r\n    require(_newContractAdmin != address(0x0), 'Invalid address');\r\n    contractAdmin = _newContractAdmin;\r\n  }\r\n\r\n  function updateGEMAdmin(address _newGEMAdmin) onlyMainAdmin public {\r\n    require(_newGEMAdmin != address(0x0), 'Invalid address');\r\n    gemAdmin = _newGEMAdmin;\r\n  }\r\n\r\n  function setMinT(uint _minT) onlyMainAdmin public {\r\n    require(_minT > 0, 'Must be > 0');\r\n    require(_minT < maxT, 'Must be < maxT');\r\n    minT = _minT;\r\n  }\r\n\r\n  function setMaxT(uint _maxT) onlyMainAdmin public {\r\n    require(_maxT > minT, 'Must be > minT');\r\n    maxT = _maxT;\r\n  }\r\n\r\n  function setMinProfit(uint _minProfit) onlyMainAdmin public {\r\n    require(_minProfit > 0, 'Must be > 0');\r\n    minProfit = _minProfit;\r\n  }\r\n\r\n  function setProfitInterval(uint32 _profitInterval) onlyMainAdmin public {\r\n    require(0 < _profitInterval, 'Must be > 0');\r\n    profitInterval = _profitInterval;\r\n  }\r\n\r\n  function setGemCommission(uint8 _gemCommission) onlyMainAdmin public {\r\n    require(0 < _gemCommission && _gemCommission < 101, 'Must be in range 1-100');\r\n    gemCommission = _gemCommission;\r\n  }\r\n\r\n  function setGemT(bool _gemT) onlyMainAdmin public {\r\n    gemT = _gemT;\r\n  }\r\n\r\n  function updateHA(address[] _addresses, bool _value) onlyMainAdmin public {\r\n    require(_addresses.length <= 256, 'Max length is 256');\r\n    for(uint8 i; i < _addresses.length; i++) {\r\n      ha[_addresses[i]] = _value;\r\n    }\r\n  }\r\n\r\n  function checkHA(address _address) onlyMainAdmin public view returns (bool) {\r\n    return ha[_address];\r\n  }\r\n\r\n  // ONLY-STAKING-CONTRACT FUNCTIONS\r\n\r\n  function validateJoinPackage(address _from, address _to, uint8 _type, uint _dabAmount, uint _gemAmount)\r\n  onlyContractAContract\r\n  public\r\n  view\r\n  returns (bool)\r\n  {\r\n    Package storage package = packages[_to];\r\n    Balance storage balance = balances[_from];\r\n    return _type > uint8(PackageType.M0) &&\r\n      _type <= uint8(PackageType.M18) &&\r\n      _type >= uint8(package.packageType) &&\r\n      _dabAmount.add(_gemAmount) >= package.lastPackage &&\r\n      (_gemAmount == 0 || balance.gemBalance >= int(_gemAmount));\r\n  }\r\n\r\n  function adminCommission(uint _amount) onlyContractAContract public {\r\n    Balance storage balance = balances[gemAdmin];\r\n    balance.gemBalance += int(_amount);\r\n  }\r\n\r\n  function deposit(address _to, uint8 _type, uint _packageAmount, uint _dabAmount, uint _gemAmount) onlyContractAContract public {\r\n    PackageType packageType = parsePackageType(_type);\r\n\r\n    updatePackageInfo(_to, packageType, _dabAmount, _gemAmount);\r\n\r\n    Balance storage userBalance = balances[_to];\r\n    bool firstDeposit = userBalance.dividendBalance == 0;\r\n    if (firstDeposit) {\r\n      userBalance.dividendBalance = _packageAmount;\r\n      emit DividendBalanceChanged(_to, address(0x0), int(_packageAmount));\r\n    } else {\r\n      userBalance.dividendBalance = userBalance.dividendBalance.add(_packageAmount.div(2));\r\n      emit DividendBalanceChanged(_to, address(0x0), int(_packageAmount.div(2)));\r\n    }\r\n    userBalance.totalDeposited = userBalance.totalDeposited.add(_packageAmount);\r\n    userBalance.dabStakingBalance = userBalance.dabStakingBalance.add(_dabAmount);\r\n    userBalance.gemStakingBalance = userBalance.gemStakingBalance.add(_gemAmount);\r\n\r\n    if (_gemAmount > 0) {\r\n      bool selfDeposit = _to == tx.origin;\r\n      if (selfDeposit) {\r\n        userBalance.gemBalance -= int(_gemAmount);\r\n      } else {\r\n        Balance storage senderBalance = balances[tx.origin];\r\n        senderBalance.gemBalance -= int(_gemAmount);\r\n      }\r\n      emit GEMBalanceChanged(tx.origin, address(0x0), int(_gemAmount) * -1);\r\n    }\r\n\r\n    if (packageType >= PackageType.M9) {\r\n      contractNo3.addF1M9DepositedToInviter(_to, _packageAmount);\r\n      contractNo3.increaseInviterF1HaveJoinedM9Package(_to);\r\n    }\r\n    if (firstDeposit) {\r\n      contractNo3.increaseInviterF1HaveJoinedPackage(_to);\r\n    }\r\n    addRewardToUpLines(_to, _dabAmount, _gemAmount, packageType);\r\n    lW[_to] = 0;\r\n    lP[_to] = packages[_to].startAt;\r\n  }\r\n\r\n  function getProfit(address _user, uint _contractNo1Balance) onlyContractAContract public returns (uint, uint) {\r\n    require(getProfitWallet(_user) <= 300000, 'You have got max profit');\r\n    Package storage userPackage = packages[_user];\r\n    uint lastProfit = lP[_user];\r\n    require(lastProfit < userPackage.endAt, 'You have got all your profits');\r\n    uint profitableTime = userPackage.endAt < now ? userPackage.endAt.sub(lastProfit) : now.sub(lastProfit);\r\n    require(profitableTime >= uint(profitInterval), 'Please wait more time and comeback later');\r\n    Balance storage userBalance = balances[_user];\r\n\r\n    uint rate = parseProfitRate(userPackage.packageType);\r\n    uint profitable = userBalance.dividendBalance.mul(rate).div(100).mul(profitableTime).div(secondsInOntMonth);\r\n    if (userBalance.totalProfited.add(profitable) > userBalance.totalDeposited.mul(3)) {\r\n      profitable = userBalance.totalDeposited.mul(3).sub(userBalance.totalProfited);\r\n    }\r\n    require(profitable > minProfit, 'Please wait for more profit and comeback later');\r\n    uint dabProfit;\r\n    uint gemProfit;\r\n    (dabProfit, gemProfit) = calculateProfit(_user, profitable);\r\n    if (gemProfit > 0) {\r\n      userBalance.gemBalance += int(gemProfit);\r\n      emit GEMBalanceChanged(_user, address(0x0), int(gemProfit));\r\n    }\r\n    lP[_user] = now;\r\n    if (_contractNo1Balance < dabProfit) {\r\n      userBalance.gemBalance += int(dabProfit.sub(_contractNo1Balance));\r\n      emit GEMBalanceChanged(_user, address(0x0), int(dabProfit.sub(_contractNo1Balance)));\r\n      return (_contractNo1Balance, gemProfit.add(dabProfit.sub(_contractNo1Balance)));\r\n    }\r\n    userBalance.totalProfited = userBalance.totalProfited.add(profitable);\r\n    return (dabProfit, gemProfit);\r\n  }\r\n\r\n  function getWithdraw(address _user, uint _contractNo1Balance, uint8 _type) onlyContractAContract public returns (uint, uint) {\r\n    require(getEndAt(_user) <= now, 'Please wait for more times and comeback later');\r\n    uint lastWithdraw = lW[_user];\r\n    bool firstWithdraw = lastWithdraw == 0;\r\n    Balance storage userBalance = balances[_user];\r\n    resetUserBalance(_user);\r\n\r\n    uint dabWithdrawable;\r\n    uint gemWithdrawable;\r\n    if (_type == 1) {\r\n      require(firstWithdraw, 'You have withdrew 50%');\r\n      dabWithdrawable = userBalance.dabStakingBalance.mul(90).div(100);\r\n      gemWithdrawable = userBalance.gemStakingBalance.mul(90).div(100);\r\n      userBalance.gemBalance += int(gemWithdrawable);\r\n      emit GEMBalanceChanged(_user, address(0x0), int(gemWithdrawable));\r\n      userBalance.dabStakingBalance = 0;\r\n      userBalance.gemStakingBalance = 0;\r\n      removeUpLineCommission(_user);\r\n      return calculateWithdrawableDAB(_user, _contractNo1Balance, dabWithdrawable);\r\n    } else {\r\n      require(now - lastWithdraw >= secondsInOntMonth, 'Please wait for more times and comeback later');\r\n      if (firstWithdraw) {\r\n        dabWithdrawable = userBalance.dabStakingBalance.div(2);\r\n        gemWithdrawable = userBalance.gemStakingBalance.div(2);\r\n        userBalance.dabStakingBalance = dabWithdrawable;\r\n        userBalance.gemStakingBalance = gemWithdrawable;\r\n        removeUpLineCommission(_user);\r\n      } else {\r\n        dabWithdrawable = userBalance.dabStakingBalance;\r\n        gemWithdrawable = userBalance.gemStakingBalance;\r\n        userBalance.dabStakingBalance = 0;\r\n        userBalance.gemStakingBalance = 0;\r\n      }\r\n      userBalance.gemBalance += int(gemWithdrawable);\r\n      emit GEMBalanceChanged(_user, address(0x0), int(gemWithdrawable));\r\n      lW[_user] = now;\r\n      return calculateWithdrawableDAB(_user, _contractNo1Balance, dabWithdrawable);\r\n    }\r\n  }\r\n\r\n  // PUBLIC-FUNCTIONS\r\n\r\n  function getUserWallet(address _investor)\r\n  public\r\n  view\r\n  returns (uint, uint, uint, uint, int, uint)\r\n  {\r\n    validateSender(_investor);\r\n    Balance storage balance = balances[_investor];\r\n    return (\r\n      balance.totalDeposited,\r\n      balance.dividendBalance,\r\n      balance.dabStakingBalance,\r\n      balance.gemStakingBalance,\r\n      balance.gemBalance,\r\n      balance.totalProfited\r\n    );\r\n  }\r\n\r\n  function getUserPackage(address _investor)\r\n  public\r\n  view\r\n  returns (uint8, uint, uint, uint, uint, uint)\r\n  {\r\n    validateSender(_investor);\r\n    Package storage package = packages[_investor];\r\n    return (\r\n      uint8(package.packageType),\r\n      package.lastPackage,\r\n      package.dabAmount,\r\n      package.gemAmount,\r\n      package.startAt,\r\n      package.endAt\r\n    );\r\n  }\r\n\r\n  function transferGem(address _to, uint _amount) public {\r\n    require(gemT, 'Not available right now');\r\n    int amountToTransfer = int(_amount);\r\n    validateTransferGem(msg.sender, _to, _amount);\r\n    Balance storage senderBalance = balances[msg.sender];\r\n    require(senderBalance.gemBalance >= amountToTransfer, 'You have not enough balance');\r\n    Balance storage receiverBalance = balances[_to];\r\n    Balance storage adminBalance = balances[gemAdmin];\r\n    senderBalance.gemBalance -= amountToTransfer;\r\n    int fee = amountToTransfer * int(gemCommission) / 100;\r\n    require(fee > 0, 'Invalid fee');\r\n    adminBalance.gemBalance += fee;\r\n    int receivedAmount = amountToTransfer - int(fee);\r\n    receiverBalance.gemBalance += receivedAmount;\r\n    emit GEMBalanceTransferred(msg.sender, _to, amountToTransfer, receivedAmount);\r\n  }\r\n\r\n  function getProfitWallet(address _user) public view returns (uint16) {\r\n    validateSender(_user);\r\n    Balance storage userBalance = balances[_user];\r\n    return uint16(userBalance.totalProfited.mul(1e4).div(userBalance.totalDeposited));\r\n  }\r\n\r\n  function getEndAt(address _user) public view returns (uint) {\r\n    validateSender(_user);\r\n    return packages[_user].endAt;\r\n  }\r\n\r\n  function getNextWithdraw(address _user) public view returns (uint) {\r\n    validateSender(_user);\r\n    uint lastWithdraw = lW[_user];\r\n    if (lastWithdraw == 0) {\r\n      return 0;\r\n    }\r\n    return lastWithdraw + 30 days;\r\n  }\r\n\r\n  function getLastProfited(address _user) public view returns (uint) {\r\n    validateSender(_user);\r\n    return lP[_user];\r\n  }\r\n\r\n  // PRIVATE-FUNCTIONS\r\n\r\n  function updatePackageInfo(address _to, PackageType _packageType, uint _dabAmount, uint _gemAmount) private {\r\n    Package storage package = packages[_to];\r\n    package.packageType = _packageType;\r\n    package.lastPackage = _dabAmount.add(_gemAmount);\r\n    package.dabAmount = package.dabAmount.add(_dabAmount);\r\n    package.gemAmount = package.gemAmount.add(_gemAmount);\r\n    package.startAt = now;\r\n    package.endAt = package.startAt + parseEndAt(_packageType);\r\n  }\r\n\r\n  function parsePackageType(uint8 _index) private pure returns (PackageType) {\r\n    require(_index >= 0 && _index <= 10, 'Invalid index');\r\n    if (_index == 1) {\r\n      return PackageType.M3;\r\n    } else if (_index == 2) {\r\n      return PackageType.M6;\r\n    } else if (_index == 3) {\r\n      return PackageType.M9;\r\n    } else if (_index == 4) {\r\n      return PackageType.M12;\r\n    } else if (_index == 5) {\r\n      return PackageType.M15;\r\n    } else if (_index == 6) {\r\n      return PackageType.M18;\r\n    } else {\r\n      return PackageType.M0;\r\n    }\r\n  }\r\n\r\n  function parseEndAt(PackageType _type) private pure returns (uint) {\r\n    return uint(_type) * 3 * 30 days;\r\n  }\r\n\r\n  function parseProfitRate(PackageType _type) private pure returns (uint) {\r\n    if (_type == PackageType.M3) {\r\n      return 4;\r\n    } else if (_type == PackageType.M6) {\r\n      return 5;\r\n    } else if (_type == PackageType.M9) {\r\n      return 6;\r\n    } else if (_type == PackageType.M12) {\r\n      return 8;\r\n    } else if (_type == PackageType.M15) {\r\n      return 10;\r\n    } else if (_type == PackageType.M18) {\r\n      return 12;\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  function addRewardToUpLines(address _invitee, uint _dabAmount, uint _gemAmount, PackageType _packageType) private {\r\n    address inviter;\r\n    uint16 referralLevel = 1;\r\n    address tempInvitee = _invitee;\r\n    do {\r\n      inviter = contractNo3.getInviter(tempInvitee);\r\n      if (inviter != address(0x0)) {\r\n        contractNo3.addNetworkDepositedToInviter(inviter, _dabAmount, _gemAmount);\r\n        if (_packageType >= PackageType.M6) {\r\n          checkAddReward(_invitee, inviter, referralLevel, _dabAmount.add(_gemAmount));\r\n        }\r\n        tempInvitee = inviter;\r\n        referralLevel += 1;\r\n      }\r\n    } while (inviter != address(0x0));\r\n  }\r\n\r\n  function checkAddReward(address _invitee, address _inviter, uint16 _referralLevel, uint _packageAmount) private {\r\n    Balance storage inviterBalance = balances[_inviter];\r\n    Package storage inviterPackage = packages[_inviter];\r\n    bool userCannotGetCommission = inviterBalance.totalProfited > inviterBalance.totalDeposited.mul(3);\r\n    if (inviterPackage.packageType < PackageType.M9 || userCannotGetCommission) {\r\n      return;\r\n    }\r\n    uint f1M9Deposited = contractNo3.getF1M9Deposited(_inviter);\r\n    uint16 directlyM9InviteeCount = uint16(contractNo3.getDirectlyInviteeHaveJoinedM9Package(_inviter).length);\r\n    uint8 rank = contractNo3.getRank(_inviter);\r\n    mapping(string => uint) userCommission = commissions[_inviter][_invitee];\r\n    uint commissionAmount;\r\n    if (_referralLevel == 1) {\r\n      commissionAmount = _packageAmount.div(5);\r\n      inviterBalance.dividendBalance = inviterBalance.dividendBalance.add(commissionAmount);\r\n      emit DividendBalanceChanged(_inviter, _invitee, int(commissionAmount));\r\n      userCommission[DAB] = userCommission[DAB].add(commissionAmount);\r\n    } else if (_referralLevel > 1 && _referralLevel < 11) {\r\n      bool condition1 = f1M9Deposited >= contractNo1.minJP().mul(3);\r\n      bool condition2 = directlyM9InviteeCount >= _referralLevel;\r\n      if (condition1 && condition2) {\r\n        commissionAmount = _packageAmount.div(20);\r\n        inviterBalance.dividendBalance = inviterBalance.dividendBalance.add(commissionAmount);\r\n        emit DividendBalanceChanged(_inviter, _invitee, int(commissionAmount));\r\n        inviterBalance.gemBalance += int(commissionAmount);\r\n        emit GEMBalanceChanged(_inviter, _invitee, int(commissionAmount));\r\n        userCommission[DAB] = userCommission[DAB].add(commissionAmount);\r\n        userCommission[GEM] = userCommission[GEM].add(commissionAmount);\r\n      }\r\n    } else if (_referralLevel < 21) {\r\n      if (rank == 1) {\r\n        commissionAmount = _packageAmount.div(20);\r\n        inviterBalance.dividendBalance = inviterBalance.dividendBalance.add(commissionAmount);\r\n      } else if (2 <= rank && rank <= 5) {\r\n        commissionAmount = increaseInviterDividendBalance(inviterBalance, rank, _packageAmount);\r\n      }\r\n      userCommission[DAB] = userCommission[DAB].add(commissionAmount);\r\n      emit DividendBalanceChanged(_inviter, _invitee, int(commissionAmount));\r\n    } else {\r\n      commissionAmount = increaseInviterDividendBalance(inviterBalance, rank, _packageAmount);\r\n      userCommission[DAB] = userCommission[DAB].add(commissionAmount);\r\n      emit DividendBalanceChanged(_inviter, _invitee, int(commissionAmount));\r\n    }\r\n  }\r\n\r\n  function increaseInviterDividendBalance(Balance storage inviterBalance, uint8 _rank, uint _packageAmount) private returns (uint) {\r\n    uint commissionAmount;\r\n    if (_rank == 2) {\r\n      commissionAmount = _packageAmount.div(20);\r\n      inviterBalance.dividendBalance = inviterBalance.dividendBalance.add(commissionAmount);\r\n    } else if (_rank == 3) {\r\n      commissionAmount = _packageAmount.div(10);\r\n      inviterBalance.dividendBalance = inviterBalance.dividendBalance.add(commissionAmount);\r\n    } else if (_rank == 4) {\r\n      commissionAmount = _packageAmount.mul(15).div(100);\r\n      inviterBalance.dividendBalance = inviterBalance.dividendBalance.add(commissionAmount);\r\n    } else if (_rank == 5) {\r\n      commissionAmount = _packageAmount.div(5);\r\n      inviterBalance.dividendBalance = inviterBalance.dividendBalance.add(commissionAmount);\r\n    }\r\n    return commissionAmount;\r\n  }\r\n\r\n  function validateTransferGem(address _from, address _to, uint _amount) private {\r\n    require(contractNo3.isCitizen(_from), 'Please register first');\r\n    require(contractNo3.isCitizen(_to), 'You can only transfer to exists member');\r\n    if (_from != _to) {\r\n      require(contractNo3.checkInvestorsInTheSameReferralTree(_from, _to), 'This user isn\\'t in your referral tree');\r\n    }\r\n    validateTAmount(_amount);\r\n  }\r\n\r\n  function validateTAmount(uint _amount) private {\r\n    require(_amount >= minT, 'Transfer failed due to difficulty');\r\n    TTracker[] storage userTransferHistory = tTracker[msg.sender];\r\n    if (userTransferHistory.length == 0) {\r\n      require(_amount <= maxT, 'Amount is invalid');\r\n    } else {\r\n      uint totalTransferredInLast24Hour = 0;\r\n      uint countTrackerNotInLast24Hour = 0;\r\n      uint length = userTransferHistory.length;\r\n      for (uint i = 0; i < length; i++) {\r\n        TTracker storage tracker = userTransferHistory[i];\r\n        bool transferInLast24Hour = now - 1 days < tracker.time;\r\n        if(transferInLast24Hour) {\r\n          totalTransferredInLast24Hour = totalTransferredInLast24Hour.add(tracker.amount);\r\n        } else {\r\n          countTrackerNotInLast24Hour++;\r\n        }\r\n      }\r\n      if (countTrackerNotInLast24Hour > 0) {\r\n        for (uint j = 0; j < userTransferHistory.length - countTrackerNotInLast24Hour; j++){\r\n          userTransferHistory[j] = userTransferHistory[j + countTrackerNotInLast24Hour];\r\n        }\r\n        userTransferHistory.length -= countTrackerNotInLast24Hour;\r\n      }\r\n      require(totalTransferredInLast24Hour.add(_amount) <= maxT, 'Too much for today');\r\n    }\r\n    userTransferHistory.push(TTracker(now, _amount));\r\n  }\r\n\r\n  function calculateProfit(address _user, uint _profitable) private view returns (uint, uint) {\r\n    uint16 profitedPercent = getProfitWallet(_user);\r\n    if (profitedPercent <= firstProfitCheckpoint) {\r\n      return (_profitable, 0);\r\n    } else if (profitedPercent <= secondProfitCheckpoint) {\r\n      return (_profitable.div(2), _profitable.div(2));\r\n    } else if (profitedPercent <= thirdProfitCheckpoint) {\r\n      Balance storage userBalance = balances[_user];\r\n      if (userBalance.totalProfited.add(_profitable) > userBalance.totalDeposited.mul(3)) {\r\n        _profitable = userBalance.totalDeposited.mul(3).sub(userBalance.totalProfited);\r\n      }\r\n      return (_profitable.mul(30).div(100), _profitable.mul(70).div(100));\r\n    } else {\r\n      return (0, 0);\r\n    }\r\n  }\r\n\r\n  function calculateWithdrawableDAB(address _user, uint _contractNo1Balance, uint _withdrawable) private returns (uint, uint) {\r\n    Balance storage userBalance = balances[_user];\r\n    if (_contractNo1Balance < _withdrawable) {\r\n      int gemAmount = int(_withdrawable.sub(_contractNo1Balance));\r\n      userBalance.gemBalance += gemAmount;\r\n      emit GEMBalanceChanged(_user, address(0x0), gemAmount);\r\n      return (_contractNo1Balance, _withdrawable.sub(_contractNo1Balance));\r\n    } else {\r\n      return (_withdrawable, 0);\r\n    }\r\n  }\r\n\r\n  function resetUserBalance(address _user) private {\r\n    Balance storage userBalance = balances[_user];\r\n    emit DividendBalanceChanged(_user, address(0x0), int(int(userBalance.dividendBalance) * -1));\r\n    userBalance.dividendBalance = 0;\r\n    userBalance.totalProfited = 0;\r\n    Package storage userPackage = packages[_user];\r\n    userPackage.packageType = PackageType.M0;\r\n    userPackage.lastPackage = 0;\r\n    userPackage.dabAmount = 0;\r\n    userPackage.gemAmount = 0;\r\n    userPackage.startAt = 0;\r\n    userPackage.endAt = 0;\r\n  }\r\n\r\n  function removeUpLineCommission(address _invitee) private {\r\n    address inviter;\r\n    address directInvitee = _invitee;\r\n    do {\r\n      inviter = contractNo3.getInviter(directInvitee);\r\n      if (inviter != address(0x0)) {\r\n        mapping(string => uint) userCommission = commissions[inviter][_invitee];\r\n        Balance storage userBalance = balances[inviter];\r\n        if (userBalance.dividendBalance > userCommission[DAB]) {\r\n          userBalance.dividendBalance = userBalance.dividendBalance.sub(userCommission[DAB]);\r\n        } else {\r\n          userBalance.dividendBalance = 0;\r\n        }\r\n        if (int(int(userCommission[DAB]) * -1) != 0) {\r\n          emit DividendBalanceChanged(inviter, address(0x0), int(int(userCommission[DAB]) * -1));\r\n        }\r\n        userBalance.gemBalance -= int(userCommission[GEM]);\r\n        if (int(int(userCommission[GEM]) * -1) != 0) {\r\n          emit GEMBalanceChanged(inviter, address(0x0), int(int(userCommission[GEM]) * -1));\r\n        }\r\n        userCommission[DAB] = 0;\r\n        userCommission[GEM] = 0;\r\n        directInvitee = inviter;\r\n      }\r\n    } while (inviter != address(0x0));\r\n  }\r\n\r\n  function validateSender(address _investor) private view {\r\n    if (msg.sender != _investor &&\r\n    msg.sender != mainAdmin &&\r\n    msg.sender != address(contractNo1) &&\r\n    msg.sender != address(contractNo3) &&\r\n    msg.sender != address(this)\r\n    ) {\r\n      require(!ha[_investor], 'Stop!!!');\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getProfitWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newContractAdmin\",\"type\":\"address\"}],\"name\":\"updateContractAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractNo3\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gemT\",\"type\":\"bool\"}],\"name\":\"setGemT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_u\",\"type\":\"address\"}],\"name\":\"setE\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_type\",\"type\":\"uint8\"},{\"name\":\"_dabAmount\",\"type\":\"uint256\"},{\"name\":\"_gemAmount\",\"type\":\"uint256\"}],\"name\":\"validateJoinPackage\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMainAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getEndAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_type\",\"type\":\"uint8\"},{\"name\":\"_packageAmount\",\"type\":\"uint256\"},{\"name\":\"_dabAmount\",\"type\":\"uint256\"},{\"name\":\"_gemAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getLastProfited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxT\",\"type\":\"uint256\"}],\"name\":\"setMaxT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferGem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_c\",\"type\":\"address\"}],\"name\":\"setC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minT\",\"type\":\"uint256\"}],\"name\":\"setMinT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBackupAdmin\",\"type\":\"address\"}],\"name\":\"updateBackupAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDABAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"updateHA\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractNo1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"adminCommission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minProfit\",\"type\":\"uint256\"}],\"name\":\"setMinProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getNextWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"checkHA\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_u\",\"type\":\"address\"}],\"name\":\"setLW\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gemCommission\",\"type\":\"uint8\"}],\"name\":\"setGemCommission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getUserPackage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getUserWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"profitInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isBackupAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isGEMAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_contractNo1Balance\",\"type\":\"uint256\"}],\"name\":\"getProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gemCommission\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMainAdmin\",\"type\":\"address\"}],\"name\":\"updateMainAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isContractAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_s\",\"type\":\"address\"}],\"name\":\"setS\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_profitInterval\",\"type\":\"uint32\"}],\"name\":\"setProfitInterval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_contractNo1Balance\",\"type\":\"uint256\"},{\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"getWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newGEMAdmin\",\"type\":\"address\"}],\"name\":\"updateGEMAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_backupAdmin\",\"type\":\"address\"},{\"name\":\"_mainAdmin\",\"type\":\"address\"},{\"name\":\"_gemAdmin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reason\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"int256\"}],\"name\":\"DividendBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reason\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"int256\"}],\"name\":\"GEMBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"receivedAmount\",\"type\":\"int256\"}],\"name\":\"GEMBalanceTransferred\",\"type\":\"event\"}]","ContractName":"ContractNo2","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ba62976c30f1d8790fb6ad5ac475531bcb5cca860000000000000000000000005420bb0005d00baf4d600b9f255c56e6016113470000000000000000000000000829a4dc4d8d85d37dff80f7a4da5211b1f0818f","Library":"","LicenseType":"GNU LGPLv3","SwarmSource":"bzzr://fd3c968ecd33ffc2bdfae87d944e8de76a0004fb5daa67fcdcaf58cc8f10d7cb"}]}