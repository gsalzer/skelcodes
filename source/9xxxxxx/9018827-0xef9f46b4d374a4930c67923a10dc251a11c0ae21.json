{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.22 <0.7.0;\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\nlibrary SafeMath {\n \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n     \n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\nlibrary ECDSA {\n\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return address(0);\n        }\n\n        if (v != 27 && v != 28) {\n            return address(0);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        return ecrecover(hash, v, r, s);\n    }\n\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\ncontract Ownable {\n    address  private  _owner;\n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n}\n\ncontract Management is Ownable{\n    using Roles for Roles.Role;\n\n    event ManagerAdded(address indexed account);\n    event ManagerRemoved(address indexed account);\n    \n    Roles.Role private _managers;\n    \n\n\n    constructor ()  internal {\n        addManager(msg.sender);\n    }\n    \n    modifier onlyManager()  {\n        require(isManager(msg.sender), \"Management: caller is not the manager\");\n        _;\n    }\n    \n    function isManager(address account) public view returns (bool) {\n        return _managers.has(account);\n    }\n    \n    function addManager(address account) public onlyOwner {\n        _addManager(account);\n    }\n\n    function renounceManager() public onlyOwner {\n        _removeManager(msg.sender);\n    }\n\n    function _addManager(address account) internal {\n        _managers.add(account);\n        emit ManagerAdded(account);\n    }\n\n    function _removeManager(address account) internal {\n        _managers.remove(account);\n        emit ManagerRemoved(account);\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract DragonBallGT is Management{\n    using Address for address;\n    using SafeMath for uint256;\n    \n    IERC20 public _usdt;\n    enum DragonBall {\n        AllCorlor,\n        Red,\n        Orange,\n        Yellow,\n        Green,\n        Blue,\n        Indigo,\n        Violet\n    }\n    \n    struct BetMod{\n\n        address beter;\n        uint256 amount;\n        uint256 betTime;\n        DragonBall color;\n        bool win;\n        \n    }\n    mapping(uint256 => mapping(uint256 => BetMod)) public betinfo;\n\n    enum GameState{Inprogress,Entertained}\n\n    struct Record{\n        bool Awarded;\n        DragonBall color;\n    }\n    \n    mapping(uint256=>Record) public winrecords; \n    \n    enum State { Locked,Active}\n    \n    State public state;\n\n    uint256 public startTime;\n    uint256 public interval;\n\n    event Bet(address indexed beter,uint256 indexed round,uint256 indexed id);\n    \n    constructor() public {\n\n        state = State.Locked;\n        interval = 3600;\n        _usdt = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    }\n    \n    modifier inState(State _state) {\n        require(state == _state,\"Invalid state\");\n        _;\n    }\n     function USDTSet(IERC20 _usdtaddress) \n        public \n        onlyOwner \n    {\n        require(Address.isContract(address(_usdtaddress)),\"Invalid address\");\n        _usdt = _usdtaddress;\n    }\n    \n    function setState(State _state) \n        public\n        onlyManager\n    {\n        require(_state != state,\"Invalid state\");\n        state = _state;\n        if(_state == State.Locked){\n            startTime = 0;\n        }else{\n            startTime = now.sub(now.mod(interval));\n        }\n    }\n    \n    \n    function checkGameState(uint256 _time) public view returns(GameState _s,uint256 _r,uint256 _st,uint256 _ft,uint256 _et){\n        require(_time >= startTime && startTime>0 ,\"Game have already stopped\");\n        uint256 _interval = _time.sub(startTime);\n        _s = GameState.Inprogress;\n        if(_interval.div(interval.div(2)).mod(2) == 1){\n            _s = GameState.Entertained;\n        }\n        _st = _time.sub(_time.mod(interval));\n        _ft = _st.add(interval.div(2));\n        _et = _st.add(interval);\n        _r = _st;\n    }\n    \n    function bet(uint256 amount,address beter,DragonBall color,uint256 _round,uint256 orderid) \n        public \n        inState(State.Active)\n        onlyManager\n        returns(bool)\n    {\n        (GameState _s,uint256 _r,,,) =  checkGameState(now);\n        require(_round == _r,\"Invalid Round\");\n        require(_s == GameState.Inprogress && color != DragonBall.AllCorlor,\"currunt round has Entertained or Invalid Color\");\n        BetMod storage _b = betinfo[_r][orderid];\n        require(_b.beter == address(0),\"Invalid orderid\");\n        _b.beter = beter;\n        _b.amount = amount;\n        _b.color = color;\n        _b.betTime = now;\n        emit Bet(beter,_r,orderid);\n        return true;\n    }\n    \n    function lottery(uint256 _round,uint256[] memory _ids,uint256[] memory _rewards,DragonBall _color) \n        public \n        onlyManager\n        returns(bool)\n    {\n        require(_ids.length == _rewards.length,\"Invalid ids or reward length\");\n        Record storage r = winrecords[_round];\n        if(!r.Awarded){\n            r.Awarded = true;\n            r.color = _color;\n        }else{\n            require(_color == r.color,\"Invalid color\");\n        }\n        for(uint256 i=0;i<_ids.length;i++){\n            BetMod storage _b = betinfo[_round][_ids[i]];\n            require(_b.color==_color && !_b.win ,\"Invalid beter\");\n            callOptionalReturn(_usdt, abi.encodeWithSelector(_usdt.transfer.selector,_b.beter, _rewards[i]));\n            _b.win = true;\n        }\n    }\n    \n    function managerWithDraw(address recipient, uint256 amount) \n        public \n        onlyManager \n        returns(bool)\n    {\n        require(_usdt.balanceOf(address(this)) >= amount,\"Insufficient balance\");\n        callOptionalReturn(_usdt, abi.encodeWithSelector(_usdt.transfer.selector,address(this), recipient, amount));\n        return true;\n    } \n    \n    function callOptionalReturn(IERC20 token, bytes memory data) \n        private \n    {\n        require(address(_usdt).isContract(), \"SafeERC20: call to non-contract\");\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n    \n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beter\",\"type\":\"address\"},{\"internalType\":\"enum DragonBallGT.DragonBall\",\"name\":\"color\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"orderid\",\"type\":\"uint256\"}],\"name\":\"bet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"managerWithDraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winrecords\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"Awarded\",\"type\":\"bool\"},{\"internalType\":\"enum DragonBallGT.DragonBall\",\"name\":\"color\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum DragonBallGT.State\",\"name\":\"_state\",\"type\":\"uint8\"}],\"name\":\"setState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"betinfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"beter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"betTime\",\"type\":\"uint256\"},{\"internalType\":\"enum DragonBallGT.DragonBall\",\"name\":\"color\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"win\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_usdtaddress\",\"type\":\"address\"}],\"name\":\"USDTSet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"checkGameState\",\"outputs\":[{\"internalType\":\"enum DragonBallGT.GameState\",\"name\":\"_s\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_r\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_st\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_et\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_usdt\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum DragonBallGT.State\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_rewards\",\"type\":\"uint256[]\"},{\"internalType\":\"enum DragonBallGT.DragonBall\",\"name\":\"_color\",\"type\":\"uint8\"}],\"name\":\"lottery\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Bet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ManagerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ManagerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DragonBallGT","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://d03e41416e42c918ca78dfffd4acdf943b9b0496568397486c699ab2bbf986e5"}]}