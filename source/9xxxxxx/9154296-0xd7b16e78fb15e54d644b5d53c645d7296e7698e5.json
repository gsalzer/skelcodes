{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\ncontract Auth {\r\n\r\n    address internal mainAdmin;\r\n    address internal contractAdmin;\r\n\r\n    event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\r\n\r\n    constructor(\r\n        address _mainAdmin,\r\n        address _contractAdmin\r\n    )\r\n    internal\r\n    {\r\n        mainAdmin = _mainAdmin;\r\n        contractAdmin = _contractAdmin;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(isMainAdmin() || isContractAdmin(), \"onlyAdmin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyMainAdmin() {\r\n        require(isMainAdmin(), \"onlyMainAdmin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyContractAdmin() {\r\n        require(isContractAdmin(), \"onlyContractAdmin\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) onlyContractAdmin internal {\r\n        require(_newOwner != address(0x0));\r\n        contractAdmin = _newOwner;\r\n        emit OwnershipTransferred(msg.sender, _newOwner);\r\n    }\r\n\r\n    function isMainAdmin() public view returns (bool) {\r\n        return msg.sender == mainAdmin;\r\n    }\r\n\r\n    function isContractAdmin() public view returns (bool) {\r\n        return msg.sender == contractAdmin;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface ICitizen {\r\n\r\n    function addF1DepositedToInviter(address _invitee, uint _amount) external;\r\n\r\n    function addNetworkDepositedToInviter(address _inviter, uint _amount, uint _source, uint _sourceAmount) external;\r\n\r\n    function checkInvestorsInTheSameReferralTree(address _inviter, address _invitee) external view returns (bool);\r\n\r\n    function getF1Deposited(address _investor) external view returns (uint);\r\n\r\n    function getId(address _investor) external view returns (uint);\r\n\r\n    function getInvestorCount() external view returns (uint);\r\n\r\n    function getInviter(address _investor) external view returns (address);\r\n\r\n    function getDirectlyInvitee(address _investor) external view returns (address[]);\r\n\r\n    function getDirectlyInviteeHaveJoinedPackage(address _investor) external view returns (address[]);\r\n\r\n    function getNetworkDeposited(address _investor) external view returns (uint);\r\n\r\n    function getRank(address _investor) external view returns (uint);\r\n\r\n    function getRankBonus(uint _index) external view returns (uint);\r\n\r\n    function getUserAddresses(uint _index) external view returns (address);\r\n\r\n    function getSubscribers(address _investor) external view returns (uint);\r\n\r\n    function increaseInviterF1HaveJoinedPackage(address _invitee) external;\r\n\r\n    function isCitizen(address _user) view external returns (bool);\r\n\r\n    function register(address _user, string _userName, address _inviter) external returns (uint);\r\n\r\n    function showInvestorInfo(address _investorAddress) external view returns (uint, string memory, address, address[], uint, uint, uint, uint);\r\n}\r\n\r\ninterface IReserveFund {\r\n\r\n    function getLockedStatus(address _investor) view external returns (uint8);\r\n\r\n    function getTransferDifficulty() view external returns (uint);\r\n}\r\n\r\ninterface IWalletStore {\r\n\r\n    function makeDailyProfit(address _user, uint dailyProfit) external;\r\n\r\n    function bonusForAdminWhenUserBuyPackageViaDollar(uint _amount, address _admin) external;\r\n\r\n    function increaseETHWithdrew(uint _amount) external;\r\n\r\n    function mineToken(address _from, uint _amount) external;\r\n\r\n    function getProfitPaid() view external returns (uint);\r\n\r\n    function setTotalDeposited(address _investor, uint _totalDeposited) external;\r\n\r\n    function getTotalDeposited(address _investor) view external returns (uint);\r\n\r\n    function pushDeposited(address _investor, uint _deposited) external;\r\n\r\n    function getDeposited(address _investor) view external returns (uint[]);\r\n\r\n    function setProfitableBalance(address _investor, uint _profitableBalance) external;\r\n\r\n    function getProfitableBalance(address _investor) view external returns (uint);\r\n\r\n    function setProfitSourceBalance(address _investor, uint _profitSourceBalance) external;\r\n\r\n    function getProfitSourceBalance(address _investor) view external returns (uint);\r\n\r\n    function setProfitBalance(address _investor, uint _profitBalance) external;\r\n\r\n    function getProfitBalance(address _investor) view external returns (uint);\r\n\r\n    function setTotalProfited(address _investor, uint _totalProfited) external;\r\n\r\n    function getTotalProfited(address _investor) view external returns (uint);\r\n\r\n    function setAmountToMineToken(address _investor, uint _amountToMineToken) external;\r\n\r\n    function getAmountToMineToken(address _investor) view external returns (uint);\r\n\r\n    function getEthWithdrewOfInvestor(address _investor) view external returns (uint);\r\n\r\n    function getEthWithdrew() view external returns (uint);\r\n\r\n    function getUserWallet(address _investor) view external returns (uint, uint[], uint, uint, uint, uint, uint, uint);\r\n\r\n    function getInvestorLastDeposited(address _investor) view external returns (uint);\r\n\r\n    function getF11RewardCondition() view external returns (uint);\r\n}\r\n\r\ncontract Wallet is Auth {\r\n    using SafeMath for uint;\r\n\r\n    IReserveFund private reserveFundContract;\r\n    ICitizen private citizen;\r\n    IWalletStore private walletStore;\r\n\r\n    modifier onlyReserveFundContract() {\r\n        require(msg.sender == address(reserveFundContract), \"onlyReserveFundContract\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyCitizenContract() {\r\n        require(msg.sender == address(citizen), \"onlyCitizenContract\");\r\n        _;\r\n    }\r\n\r\n    event ProfitBalanceTransferred(address from, address to, uint amount);\r\n    event RankBonusSent(address investor, uint rank, uint amount);\r\n    // source: 0-eth 1-token 2-usdt\r\n    event ProfitSourceBalanceChanged(address investor, int amount, address from, uint8 source);\r\n    event ProfitableBalanceChanged(address investor, int amount, address from, uint8 source);\r\n    // source: 0-profit paid 1-active user\r\n    event ProfitBalanceChanged(address from, address to, int amount, uint8 source);\r\n\r\n    constructor (address _mainAdmin) Auth(_mainAdmin, msg.sender) public {}\r\n\r\n\r\n    // ONLY-CONTRACT-ADMIN FUNCTIONS\r\n\r\n    function setReserveFundContract(address _reserveFundContract) onlyContractAdmin public {\r\n        reserveFundContract = IReserveFund(_reserveFundContract);\r\n    }\r\n\r\n    function setC(address _citizenContract) onlyContractAdmin public {\r\n        citizen = ICitizen(_citizenContract);\r\n    }\r\n\r\n    function setWS(address _walletStore) onlyContractAdmin public {\r\n        walletStore = IWalletStore(_walletStore);\r\n    }\r\n\r\n    function updateContractAdmin(address _newAddress) onlyContractAdmin public {\r\n        transferOwnership(_newAddress);\r\n    }\r\n\r\n    function makeDailyProfit(address[] _users) onlyContractAdmin public {\r\n        require(_users.length > 0, \"Invalid input\");\r\n        uint investorCount = citizen.getInvestorCount();\r\n        uint dailyPercent;\r\n        uint dailyProfit;\r\n        uint8 lockProfit = 1;\r\n        uint id;\r\n        address userAddress;\r\n        for (uint i = 0; i < _users.length; i++) {\r\n            id = citizen.getId(_users[i]);\r\n            require(investorCount > id, \"Invalid userId\");\r\n            userAddress = _users[i];\r\n            if (reserveFundContract.getLockedStatus(userAddress) != lockProfit) {\r\n                uint totalDeposited = walletStore.getTotalDeposited(userAddress);\r\n                uint profitableBalance = walletStore.getProfitableBalance(userAddress);\r\n                uint totalProfited = walletStore.getTotalProfited(userAddress);\r\n\r\n                dailyPercent = (totalProfited == 0 || totalProfited < totalDeposited) ? 5 : (totalProfited < 4 * totalDeposited) ? 4 : 3;\r\n                dailyProfit = profitableBalance.mul(dailyPercent).div(1000);\r\n\r\n                walletStore.makeDailyProfit(userAddress, dailyProfit);\r\n                emit ProfitBalanceChanged(address(0x0), userAddress, int(dailyProfit), 0);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // ONLY-MAIN-ADMIN-FUNCTIONS\r\n    function getProfitPaid() onlyMainAdmin public view returns (uint) {\r\n        return walletStore.getProfitPaid();\r\n    }\r\n\r\n    // ONLY-SFU-CONTRACT FUNCTIONS\r\n    // _source: 0-eth 1-token 2-usdt\r\n    function deposit(address _to, uint _deposited, uint8 _source, uint _sourceAmount)\r\n    onlyReserveFundContract\r\n    public {\r\n        require(_to != address(0x0), \"User address can not be empty\");\r\n        require(_deposited > 0, \"Package value must be > 0\");\r\n\r\n        uint totalDeposited = walletStore.getTotalDeposited(_to);\r\n        uint[] memory deposited = walletStore.getDeposited(_to);\r\n        uint profitableBalance = walletStore.getProfitableBalance(_to);\r\n        uint profitSourceBalance = walletStore.getProfitSourceBalance(_to);\r\n        uint profitBalance = getProfitBalance(_to);\r\n\r\n\r\n        bool firstDeposit = deposited.length == 0;\r\n        walletStore.pushDeposited(_to, _deposited);\r\n        uint profitableIncreaseAmount = _deposited * (firstDeposit ? 2 : 1);\r\n        uint profitSourceIncreaseAmount = _deposited * 10;\r\n        walletStore.setTotalDeposited(_to, totalDeposited.add(_deposited));\r\n        walletStore.setProfitableBalance(_to, profitableBalance.add(profitableIncreaseAmount));\r\n        walletStore.setProfitSourceBalance(_to, profitSourceBalance.add(profitSourceIncreaseAmount));\r\n        if (_source == 2) {\r\n            if (_to == tx.origin) {\r\n                // self deposit\r\n                walletStore.setProfitBalance(_to, profitBalance.sub(_deposited));\r\n            } else {\r\n                // deposit to another\r\n                uint senderProfitBalance = getProfitBalance(tx.origin);\r\n                walletStore.setProfitBalance(tx.origin, senderProfitBalance.sub(_deposited));\r\n            }\r\n            emit ProfitBalanceChanged(tx.origin, _to, int(_deposited) * - 1, 1);\r\n        }\r\n        citizen.addF1DepositedToInviter(_to, _deposited);\r\n        addRewardToInviter(_to, _deposited, _source, _sourceAmount);\r\n\r\n        if (firstDeposit) {\r\n            citizen.increaseInviterF1HaveJoinedPackage(_to);\r\n        }\r\n\r\n        if (profitableIncreaseAmount > 0) {\r\n            emit ProfitableBalanceChanged(_to, int(profitableIncreaseAmount), _to, _source);\r\n            emit ProfitSourceBalanceChanged(_to, int(profitSourceIncreaseAmount), _to, _source);\r\n        }\r\n    }\r\n\r\n    // ONLY-CITIZEN-CONTRACT FUNCTIONS\r\n\r\n    function bonusNewRank(address _investor, uint _currentRank, uint _newRank)\r\n    onlyCitizenContract\r\n    public {\r\n        require(_newRank > _currentRank, \"Invalid ranks\");\r\n        uint profitBalance = getProfitBalance(_investor);\r\n\r\n        for (uint8 i = uint8(_currentRank) + 1; i <= uint8(_newRank); i++) {\r\n            uint rankBonusAmount = citizen.getRankBonus(i);\r\n            walletStore.setProfitBalance(_investor, profitBalance.add(rankBonusAmount));\r\n            if (rankBonusAmount > 0) {\r\n                emit RankBonusSent(_investor, i, rankBonusAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    // PUBLIC FUNCTIONS\r\n\r\n    function getUserWallet(address _investor)\r\n    public\r\n    view\r\n    returns (uint, uint[], uint, uint, uint, uint, uint, uint)\r\n    {\r\n        if (msg.sender != address(reserveFundContract) && msg.sender != contractAdmin && msg.sender != mainAdmin) {\r\n            require(_investor != mainAdmin, \"You can not see admin account\");\r\n        }\r\n\r\n        return walletStore.getUserWallet(_investor);\r\n    }\r\n\r\n    function getInvestorLastDeposited(address _investor)\r\n    public\r\n    view\r\n    returns (uint) {\r\n        return walletStore.getInvestorLastDeposited(_investor);\r\n    }\r\n\r\n    function transferProfitWallet(uint _amount, address _to)\r\n    public {\r\n        require(_amount >= reserveFundContract.getTransferDifficulty(), \"Amount must be >= minimumTransferProfitBalance\");\r\n        uint profitBalanceOfSender = getProfitBalance(msg.sender);\r\n\r\n        require(citizen.isCitizen(msg.sender), \"Please register first\");\r\n        require(citizen.isCitizen(_to), \"You can only transfer to an exists member\");\r\n        require(profitBalanceOfSender >= _amount, \"You have not enough balance\");\r\n        bool inTheSameTree = citizen.checkInvestorsInTheSameReferralTree(msg.sender, _to);\r\n        require(inTheSameTree, \"This user isn't in your referral tree\");\r\n\r\n        uint profitBalanceOfReceiver = getProfitBalance(_to);\r\n        walletStore.setProfitBalance(msg.sender, profitBalanceOfSender.sub(_amount));\r\n        walletStore.setProfitBalance(_to, profitBalanceOfReceiver.add(_amount));\r\n        emit ProfitBalanceTransferred(msg.sender, _to, _amount);\r\n    }\r\n\r\n    function getProfitBalance(address _investor)\r\n    public\r\n    view\r\n    returns (uint) {\r\n        return walletStore.getProfitBalance(_investor);\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    function addRewardToInviter(address _invitee, uint _amount, uint8 _source, uint _sourceAmount)\r\n    private {\r\n        address inviter;\r\n        uint16 referralLevel = 1;\r\n        do {\r\n            inviter = citizen.getInviter(_invitee);\r\n            if (inviter != address(0x0)) {\r\n                citizen.addNetworkDepositedToInviter(inviter, _amount, _source, _sourceAmount);\r\n                checkAddReward(_invitee, inviter, referralLevel, _source, _amount);\r\n                _invitee = inviter;\r\n                referralLevel += 1;\r\n            }\r\n        }\r\n        while (inviter != address(0x0));\r\n    }\r\n\r\n    function checkAddReward(address _invitee, address _inviter, uint16 _referralLevel, uint8 _source, uint _amount)\r\n    private {\r\n        if (_referralLevel == 1) {\r\n            moveBalanceForInviting(_invitee, _inviter, _referralLevel, _source, _amount);\r\n        } else {\r\n            uint[] memory deposited = walletStore.getDeposited(_inviter);\r\n            uint directlyInviteeCount = citizen.getDirectlyInviteeHaveJoinedPackage(_inviter).length;\r\n\r\n            bool condition1 = deposited.length > 0;\r\n            bool condition2 = directlyInviteeCount >= _referralLevel;\r\n\r\n            if (_referralLevel > 1 && _referralLevel < 11) {\r\n                if (condition1 && condition2) {\r\n                    moveBalanceForInviting(_invitee, _inviter, _referralLevel, _source, _amount);\r\n                }\r\n            } else {\r\n                uint f11RewardCondition = walletStore.getF11RewardCondition();\r\n                uint totalDeposited = walletStore.getTotalDeposited(_inviter);\r\n                uint rank = citizen.getRank(_inviter);\r\n\r\n                bool condition3 = totalDeposited > f11RewardCondition;\r\n                bool condition4 = rank >= 1;\r\n\r\n                if (condition1 && condition2 && condition3 && condition4) {\r\n                    moveBalanceForInviting(_invitee, _inviter, _referralLevel, _source, _amount);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function moveBalanceForInviting(address _invitee, address _inviter, uint16 _referralLevel, uint8 _source, uint _amount)\r\n    private\r\n    {\r\n        uint willMoveAmount = 0;\r\n        uint profitableBalance = walletStore.getProfitableBalance(_inviter);\r\n        uint profitSourceBalance = walletStore.getProfitSourceBalance(_inviter);\r\n        uint profitBalance = getProfitBalance(_inviter);\r\n\r\n        if (_referralLevel == 1) {\r\n            willMoveAmount = (_amount * 50) / 100;\r\n            uint reward = (_amount * 3) / 100;\r\n            walletStore.setProfitBalance(_inviter, profitBalance.add(reward));\r\n            emit ProfitBalanceChanged(_invitee, _inviter, int(reward), 1);\r\n        }\r\n        else if (_referralLevel == 2) {\r\n            willMoveAmount = (_amount * 20) / 100;\r\n        } else if (_referralLevel == 3) {\r\n            willMoveAmount = (_amount * 15) / 100;\r\n        } else if (_referralLevel == 4 || _referralLevel == 5) {\r\n            willMoveAmount = (_amount * 10) / 100;\r\n        } else if (_referralLevel >= 6 && _referralLevel <= 10) {\r\n            willMoveAmount = (_amount * 5) / 100;\r\n        } else {\r\n            willMoveAmount = (_amount * 5) / 100;\r\n        }\r\n        if (willMoveAmount == 0) {\r\n            return;\r\n        }\r\n        if (profitSourceBalance > willMoveAmount) {\r\n            walletStore.setProfitableBalance(_inviter, profitableBalance.add(willMoveAmount));\r\n            walletStore.setProfitSourceBalance(_inviter, profitSourceBalance.sub(willMoveAmount));\r\n            notifyMoveSuccess(_invitee, _inviter, _source, willMoveAmount);\r\n        } else if (willMoveAmount > 0 && profitSourceBalance > 0 && profitSourceBalance <= willMoveAmount) {\r\n            walletStore.setProfitableBalance(_inviter, profitableBalance.add(profitSourceBalance));\r\n            walletStore.setProfitSourceBalance(_inviter, 0);\r\n            notifyMoveSuccess(_invitee, _inviter, _source, profitSourceBalance);\r\n        }\r\n    }\r\n\r\n\r\n    function notifyMoveSuccess(address _invitee, address _inviter, uint8 _source, uint move)\r\n    private\r\n    {\r\n        emit ProfitableBalanceChanged(_inviter, int(move), _invitee, _source);\r\n        emit ProfitSourceBalanceChanged(_inviter, int(move) * - 1, _invitee, _source);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"updateContractAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMainAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reserveFundContract\",\"type\":\"address\"}],\"name\":\"setReserveFundContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_currentRank\",\"type\":\"uint256\"},{\"name\":\"_newRank\",\"type\":\"uint256\"}],\"name\":\"bonusNewRank\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_citizenContract\",\"type\":\"address\"}],\"name\":\"setC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferProfitWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_walletStore\",\"type\":\"address\"}],\"name\":\"setWS\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getInvestorLastDeposited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_users\",\"type\":\"address[]\"}],\"name\":\"makeDailyProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getUserWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getProfitBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProfitPaid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isContractAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_deposited\",\"type\":\"uint256\"},{\"name\":\"_source\",\"type\":\"uint8\"},{\"name\":\"_sourceAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_mainAdmin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProfitBalanceTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rank\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RankBonusSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"source\",\"type\":\"uint8\"}],\"name\":\"ProfitSourceBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"source\",\"type\":\"uint8\"}],\"name\":\"ProfitableBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"source\",\"type\":\"uint8\"}],\"name\":\"ProfitBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Wallet","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007f464a81db1c5eb975227b6953daf6b216fbc561","Library":"","LicenseType":"None","SwarmSource":"bzzr://f917481eb8e4ebc17647e01ef48355842f5e80dd5c2803345c67f8e1ff351502"}]}