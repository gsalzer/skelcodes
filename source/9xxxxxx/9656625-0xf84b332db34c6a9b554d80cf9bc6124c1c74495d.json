{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/utility/interfaces/IOwned.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ncontract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public view returns (address) {this;}\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n}\r\n\r\n// File: contracts/utility/Owned.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n/**\r\n  * @dev Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    /**\r\n      * @dev triggered when the owner is updated\r\n      * \r\n      * @param _prevOwner previous owner\r\n      * @param _newOwner  new owner\r\n    */\r\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\r\n\r\n    /**\r\n      * @dev initializes a new Owned instance\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n      * @dev allows transferring the contract ownership\r\n      * the new owner still needs to accept the transfer\r\n      * can only be called by the contract owner\r\n      * \r\n      * @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n      * @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/utility/Utils.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/**\r\n  * @dev Utilities & Common Modifiers\r\n*/\r\ncontract Utils {\r\n    /**\r\n      * constructor\r\n    */\r\n    constructor() public {\r\n    }\r\n\r\n    // verifies that an amount is greater than zero\r\n    modifier greaterThanZero(uint256 _amount) {\r\n        require(_amount > 0);\r\n        _;\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        require(_address != address(0));\r\n        _;\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        require(_address != address(this));\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/utility/interfaces/IContractRegistry.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    Contract Registry interface\r\n*/\r\ncontract IContractRegistry {\r\n    function addressOf(bytes32 _contractName) public view returns (address);\r\n\r\n    // deprecated, backward compatibility\r\n    function getAddress(bytes32 _contractName) public view returns (address);\r\n}\r\n\r\n// File: contracts/utility/ContractRegistryClient.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n\r\n/**\r\n  * @dev Base contract for ContractRegistry clients\r\n*/\r\ncontract ContractRegistryClient is Owned, Utils {\r\n    bytes32 internal constant CONTRACT_FEATURES = \"ContractFeatures\";\r\n    bytes32 internal constant CONTRACT_REGISTRY = \"ContractRegistry\";\r\n    bytes32 internal constant BANCOR_NETWORK = \"BancorNetwork\";\r\n    bytes32 internal constant BANCOR_FORMULA = \"BancorFormula\";\r\n    bytes32 internal constant BANCOR_CONVERTER_FACTORY = \"BancorConverterFactory\";\r\n    bytes32 internal constant BANCOR_CONVERTER_UPGRADER = \"BancorConverterUpgrader\";\r\n    bytes32 internal constant BANCOR_CONVERTER_REGISTRY = \"BancorConverterRegistry\";\r\n    bytes32 internal constant BANCOR_CONVERTER_REGISTRY_DATA = \"BancorConverterRegistryData\";\r\n    bytes32 internal constant BNT_TOKEN = \"BNTToken\";\r\n    bytes32 internal constant BANCOR_X = \"BancorX\";\r\n    bytes32 internal constant BANCOR_X_UPGRADER = \"BancorXUpgrader\";\r\n\r\n    IContractRegistry public registry;      // address of the current contract-registry\r\n    IContractRegistry public prevRegistry;  // address of the previous contract-registry\r\n    bool public onlyOwnerCanUpdateRegistry; // only an owner can update the contract-registry\r\n\r\n    /**\r\n      * @dev verifies that the caller is mapped to the given contract name\r\n      * \r\n      * @param _contractName    contract name\r\n    */\r\n    modifier only(bytes32 _contractName) {\r\n        require(msg.sender == addressOf(_contractName));\r\n        _;\r\n    }\r\n\r\n    /**\r\n      * @dev initializes a new ContractRegistryClient instance\r\n      * \r\n      * @param  _registry   address of a contract-registry contract\r\n    */\r\n    constructor(IContractRegistry _registry) internal validAddress(_registry) {\r\n        registry = IContractRegistry(_registry);\r\n        prevRegistry = IContractRegistry(_registry);\r\n    }\r\n\r\n    /**\r\n      * @dev updates to the new contract-registry\r\n     */\r\n    function updateRegistry() public {\r\n        // verify that this function is permitted\r\n        require(msg.sender == owner || !onlyOwnerCanUpdateRegistry);\r\n\r\n        // get the new contract-registry\r\n        address newRegistry = addressOf(CONTRACT_REGISTRY);\r\n\r\n        // verify that the new contract-registry is different and not zero\r\n        require(newRegistry != address(registry) && newRegistry != address(0));\r\n\r\n        // verify that the new contract-registry is pointing to a non-zero contract-registry\r\n        require(IContractRegistry(newRegistry).addressOf(CONTRACT_REGISTRY) != address(0));\r\n\r\n        // save a backup of the current contract-registry before replacing it\r\n        prevRegistry = registry;\r\n\r\n        // replace the current contract-registry with the new contract-registry\r\n        registry = IContractRegistry(newRegistry);\r\n    }\r\n\r\n    /**\r\n      * @dev restores the previous contract-registry\r\n    */\r\n    function restoreRegistry() public ownerOnly {\r\n        // restore the previous contract-registry\r\n        registry = prevRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev restricts the permission to update the contract-registry\r\n      * \r\n      * @param _onlyOwnerCanUpdateRegistry  indicates whether or not permission is restricted to owner only\r\n    */\r\n    function restrictRegistryUpdate(bool _onlyOwnerCanUpdateRegistry) ownerOnly public {\r\n        // change the permission to update the contract-registry\r\n        onlyOwnerCanUpdateRegistry = _onlyOwnerCanUpdateRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the address associated with the given contract name\r\n      * \r\n      * @param _contractName    contract name\r\n      * \r\n      * @return contract address\r\n    */\r\n    function addressOf(bytes32 _contractName) internal view returns (address) {\r\n        return registry.addressOf(_contractName);\r\n    }\r\n}\r\n\r\n// File: contracts/token/interfaces/IERC20Token.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ncontract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public view returns (string) {this;}\r\n    function symbol() public view returns (string) {this;}\r\n    function decimals() public view returns (uint8) {this;}\r\n    function totalSupply() public view returns (uint256) {this;}\r\n    function balanceOf(address _owner) public view returns (uint256) {_owner; this;}\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {_owner; _spender; this;}\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n// File: contracts/utility/interfaces/IWhitelist.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    Whitelist interface\r\n*/\r\ncontract IWhitelist {\r\n    function isWhitelisted(address _address) public view returns (bool);\r\n}\r\n\r\n// File: contracts/converter/interfaces/IBancorConverter.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n/*\r\n    Bancor Converter interface\r\n*/\r\ncontract IBancorConverter {\r\n    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public view returns (uint256, uint256);\r\n    function convert2(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn, address _affiliateAccount, uint256 _affiliateFee) public returns (uint256);\r\n    function quickConvert2(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _affiliateAccount, uint256 _affiliateFee) public payable returns (uint256);\r\n    function conversionWhitelist() public view returns (IWhitelist) {this;}\r\n    function conversionFee() public view returns (uint32) {this;}\r\n    function reserves(address _address) public view returns (uint256, uint32, bool, bool, bool) {_address; this;}\r\n    function getReserveBalance(IERC20Token _reserveToken) public view returns (uint256);\r\n    function reserveTokens(uint256 _index) public view returns (IERC20Token) {_index; this;}\r\n\r\n    // deprecated, backward compatibility\r\n    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\r\n    function convert(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\r\n    function quickConvert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256);\r\n    function connectors(address _address) public view returns (uint256, uint32, bool, bool, bool);\r\n    function getConnectorBalance(IERC20Token _connectorToken) public view returns (uint256);\r\n    function connectorTokens(uint256 _index) public view returns (IERC20Token);\r\n    function connectorTokenCount() public view returns (uint16);\r\n}\r\n\r\n// File: contracts/converter/interfaces/IBancorConverterRegistry.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\ninterface IBancorConverterRegistry {\r\n    function addConverter(IBancorConverter _converter) external;\r\n    function removeConverter(IBancorConverter _converter) external;\r\n    function getSmartTokenCount() external view returns (uint);\r\n    function getSmartTokens() external view returns (address[]);\r\n    function getSmartToken(uint _index) external view returns (address);\r\n    function isSmartToken(address _value) external view returns (bool);\r\n    function getLiquidityPoolCount() external view returns (uint);\r\n    function getLiquidityPools() external view returns (address[]);\r\n    function getLiquidityPool(uint _index) external view returns (address);\r\n    function isLiquidityPool(address _value) external view returns (bool);\r\n    function getConvertibleTokenCount() external view returns (uint);\r\n    function getConvertibleTokens() external view returns (address[]);\r\n    function getConvertibleToken(uint _index) external view returns (address);\r\n    function isConvertibleToken(address _value) external view returns (bool);\r\n    function getConvertibleTokenSmartTokenCount(address _convertibleToken) external view returns (uint);\r\n    function getConvertibleTokenSmartTokens(address _convertibleToken) external view returns (address[]);\r\n    function getConvertibleTokenSmartToken(address _convertibleToken, uint _index) external view returns (address);\r\n    function isConvertibleTokenSmartToken(address _convertibleToken, address _value) external view returns (bool);\r\n}\r\n\r\n// File: contracts/converter/interfaces/IBancorConverterRegistryData.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\ninterface IBancorConverterRegistryData {\r\n    function addSmartToken(address _smartToken) external;\r\n    function removeSmartToken(address _smartToken) external;\r\n    function addLiquidityPool(address _liquidityPool) external;\r\n    function removeLiquidityPool(address _liquidityPool) external;\r\n    function addConvertibleToken(address _convertibleToken, address _smartToken) external;\r\n    function removeConvertibleToken(address _convertibleToken, address _smartToken) external;\r\n    function getSmartTokenCount() external view returns (uint);\r\n    function getSmartTokens() external view returns (address[]);\r\n    function getSmartToken(uint _index) external view returns (address);\r\n    function isSmartToken(address _value) external view returns (bool);\r\n    function getLiquidityPoolCount() external view returns (uint);\r\n    function getLiquidityPools() external view returns (address[]);\r\n    function getLiquidityPool(uint _index) external view returns (address);\r\n    function isLiquidityPool(address _value) external view returns (bool);\r\n    function getConvertibleTokenCount() external view returns (uint);\r\n    function getConvertibleTokens() external view returns (address[]);\r\n    function getConvertibleToken(uint _index) external view returns (address);\r\n    function isConvertibleToken(address _value) external view returns (bool);\r\n    function getConvertibleTokenSmartTokenCount(address _convertibleToken) external view returns (uint);\r\n    function getConvertibleTokenSmartTokens(address _convertibleToken) external view returns (address[]);\r\n    function getConvertibleTokenSmartToken(address _convertibleToken, uint _index) external view returns (address);\r\n    function isConvertibleTokenSmartToken(address _convertibleToken, address _value) external view returns (bool);\r\n}\r\n\r\n// File: contracts/token/interfaces/ISmartToken.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n/*\r\n    Smart Token interface\r\n*/\r\ncontract ISmartToken is IOwned, IERC20Token {\r\n    function disableTransfers(bool _disable) public;\r\n    function issue(address _to, uint256 _amount) public;\r\n    function destroy(address _from, uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/token/interfaces/ISmartTokenController.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n/*\r\n    Smart Token Controller interface\r\n*/\r\ncontract ISmartTokenController {\r\n    function claimTokens(address _from, uint256 _amount) public;\r\n    function token() public view returns (ISmartToken) {this;}\r\n}\r\n\r\n// File: contracts/converter/BancorConverterRegistry.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n  * @dev The BancorConverterRegistry maintains a list of all active converters in the Bancor Network.\r\n  *\r\n  * Since converters can be upgraded and thus their address can change, the registry actually keeps smart tokens internally and not the converters themselves.\r\n  * The active converter for each smart token can be easily accessed by querying the smart token owner.\r\n  *\r\n  * The registry exposes 3 differnet lists that can be accessed and iterated, based on the use-case of the caller:\r\n  * - Smart tokens - can be used to get all the latest / historical data in the network\r\n  * - Liquidity pools - can be used to get all liquidity pools for funding, liquidation etc.\r\n  * - Convertible tokens - can be used to get all tokens that can be converted in the network (excluding pool\r\n  *   tokens), and for each one - all smart tokens that hold it in their reserves\r\n  *\r\n  *\r\n  * The contract fires events whenever one of the primitives is added to or removed from the registry\r\n  *\r\n  * The contract is upgradable.\r\n*/\r\ncontract BancorConverterRegistry is IBancorConverterRegistry, ContractRegistryClient {\r\n    /**\r\n      * @dev triggered when a smart token is added to the registry\r\n      * \r\n      * @param _smartToken smart token\r\n    */\r\n    event SmartTokenAdded(address indexed _smartToken);\r\n\r\n    /**\r\n      * @dev triggered when a smart token is removed from the registry\r\n      * \r\n      * @param _smartToken smart token\r\n    */\r\n    event SmartTokenRemoved(address indexed _smartToken);\r\n\r\n    /**\r\n      * @dev triggered when a liquidity pool is added to the registry\r\n      * \r\n      * @param _liquidityPool liquidity pool\r\n    */\r\n    event LiquidityPoolAdded(address indexed _liquidityPool);\r\n\r\n    /**\r\n      * @dev triggered when a liquidity pool is removed from the registry\r\n      * \r\n      * @param _liquidityPool liquidity pool\r\n    */\r\n    event LiquidityPoolRemoved(address indexed _liquidityPool);\r\n\r\n    /**\r\n      * @dev triggered when a convertible token is added to the registry\r\n      * \r\n      * @param _convertibleToken convertible token\r\n      * @param _smartToken associated smart token\r\n    */\r\n    event ConvertibleTokenAdded(address indexed _convertibleToken, address indexed _smartToken);\r\n\r\n    /**\r\n      * @dev triggered when a convertible token is removed from the registry\r\n      * \r\n      * @param _convertibleToken convertible token\r\n      * @param _smartToken associated smart token\r\n    */\r\n    event ConvertibleTokenRemoved(address indexed _convertibleToken, address indexed _smartToken);\r\n\r\n    /**\r\n      * @dev initializes a new BancorConverterRegistry instance\r\n      * \r\n      * @param _registry address of a contract registry contract\r\n    */\r\n    constructor(IContractRegistry _registry) ContractRegistryClient(_registry) public {\r\n    }\r\n\r\n    /**\r\n      * @dev adds a converter to the registry\r\n      * anyone can add a converter to the registry, as long as the converter is active and valid\r\n      * note that a liquidity pool converter can be added only if no converter with the same reserve-configuration is already registered\r\n      * \r\n      * @param _converter converter\r\n    */\r\n    function addConverter(IBancorConverter _converter) external {\r\n        // validate input\r\n        require(isConverterValid(_converter) && !isSimilarLiquidityPoolRegistered(_converter));\r\n\r\n        IBancorConverterRegistryData converterRegistryData = IBancorConverterRegistryData(addressOf(BANCOR_CONVERTER_REGISTRY_DATA));\r\n        ISmartToken token = ISmartTokenController(_converter).token();\r\n        uint reserveTokenCount = _converter.connectorTokenCount();\r\n\r\n        // add the smart token\r\n        addSmartToken(converterRegistryData, token);\r\n        if (reserveTokenCount > 1)\r\n            addLiquidityPool(converterRegistryData, token);\r\n        else\r\n            addConvertibleToken(converterRegistryData, token, token);\r\n\r\n        // add all reserve tokens\r\n        for (uint i = 0; i < reserveTokenCount; i++)\r\n            addConvertibleToken(converterRegistryData, _converter.connectorTokens(i), token);\r\n    }\r\n\r\n    /**\r\n      * @dev removes a converter from the registry\r\n      * anyone can remove invalid or inactive converters from the registry\r\n      * note that the owner can also remove valid converters\r\n      * \r\n      * @param _converter converter\r\n    */\r\n    function removeConverter(IBancorConverter _converter) external {\r\n      // validate input\r\n        require(msg.sender == owner || !isConverterValid(_converter));\r\n\r\n        IBancorConverterRegistryData converterRegistryData = IBancorConverterRegistryData(addressOf(BANCOR_CONVERTER_REGISTRY_DATA));\r\n        ISmartToken token = ISmartTokenController(_converter).token();\r\n        uint reserveTokenCount = _converter.connectorTokenCount();\r\n\r\n        // remove the smart token\r\n        removeSmartToken(converterRegistryData, token);\r\n        if (reserveTokenCount > 1)\r\n            removeLiquidityPool(converterRegistryData, token);\r\n        else\r\n            removeConvertibleToken(converterRegistryData, token, token);\r\n\r\n        // remove all reserve tokens\r\n        for (uint i = 0; i < reserveTokenCount; i++)\r\n            removeConvertibleToken(converterRegistryData, _converter.connectorTokens(i), token);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the number of smart tokens in the registry\r\n      * \r\n      * @return number of smart tokens\r\n    */\r\n    function getSmartTokenCount() external view returns (uint) {\r\n        return IBancorConverterRegistryData(addressOf(BANCOR_CONVERTER_REGISTRY_DATA)).getSmartTokenCount();\r\n    }\r\n\r\n    /**\r\n      * @dev returns the list of smart tokens in the registry\r\n      * \r\n      * @return list of smart tokens\r\n    */\r\n    function getSmartTokens() external view returns (address[]) {\r\n        return IBancorConverterRegistryData(addressOf(BANCOR_CONVERTER_REGISTRY_DATA)).getSmartTokens();\r\n    }\r\n\r\n    /**\r\n      * @dev returns the smart token at a given index\r\n      * \r\n      * @param _index index\r\n      * @return smart token at the given index\r\n    */\r\n    function getSmartToken(uint _index) external view returns (address) {\r\n        return IBancorConverterRegistryData(addressOf(BANCOR_CONVERTER_REGISTRY_DATA)).getSmartToken(_index);\r\n    }\r\n\r\n    /**\r\n      * @dev checks whether or not a given value is a smart token\r\n      * \r\n      * @param _value value\r\n      * @return true if the given value is a smart token, false if not\r\n    */\r\n    function isSmartToken(address _value) external view returns (bool) {\r\n        return IBancorConverterRegistryData(addressOf(BANCOR_CONVERTER_REGISTRY_DATA)).isSmartToken(_value);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the number of liquidity pools in the registry\r\n      * \r\n      * @return number of liquidity pools\r\n    */\r\n    function getLiquidityPoolCount() external view returns (uint) {\r\n        return IBancorConverterRegistryData(addressOf(BANCOR_CONVERTER_REGISTRY_DATA)).getLiquidityPoolCount();\r\n    }\r\n\r\n    /**\r\n      * @dev returns the list of liquidity pools in the registry\r\n      * \r\n      * @return list of liquidity pools\r\n    */\r\n    function getLiquidityPools() external view returns (address[]) {\r\n        return IBancorConverterRegistryData(addressOf(BANCOR_CONVERTER_REGISTRY_DATA)).getLiquidityPools();\r\n    }\r\n\r\n    /**\r\n      * @dev returns the liquidity pool at a given index\r\n      * \r\n      * @param _index index\r\n      * @return liquidity pool at the given index\r\n    */\r\n    function getLiquidityPool(uint _index) external view returns (address) {\r\n        return IBancorConverterRegistryData(addressOf(BANCOR_CONVERTER_REGISTRY_DATA)).getLiquidityPool(_index);\r\n    }\r\n\r\n    /**\r\n      * @dev checks whether or not a given value is a liquidity pool\r\n      * \r\n      * @param _value value\r\n      * @return true if the given value is a liquidity pool, false if not\r\n    */\r\n    function isLiquidityPool(address _value) external view returns (bool) {\r\n        return IBancorConverterRegistryData(addressOf(BANCOR_CONVERTER_REGISTRY_DATA)).isLiquidityPool(_value);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the number of convertible tokens in the registry\r\n      * \r\n      * @return number of convertible tokens\r\n    */\r\n    function getConvertibleTokenCount() external view returns (uint) {\r\n        return IBancorConverterRegistryData(addressOf(BANCOR_CONVERTER_REGISTRY_DATA)).getConvertibleTokenCount();\r\n    }\r\n\r\n    /**\r\n      * @dev returns the list of convertible tokens in the registry\r\n      * \r\n      * @return list of convertible tokens\r\n    */\r\n    function getConvertibleTokens() external view returns (address[]) {\r\n        return IBancorConverterRegistryData(addressOf(BANCOR_CONVERTER_REGISTRY_DATA)).getConvertibleTokens();\r\n    }\r\n\r\n    /**\r\n      * @dev returns the convertible token at a given index\r\n      * \r\n      * @param _index index\r\n      * @return convertible token at the given index\r\n    */\r\n    function getConvertibleToken(uint _index) external view returns (address) {\r\n        return IBancorConverterRegistryData(addressOf(BANCOR_CONVERTER_REGISTRY_DATA)).getConvertibleToken(_index);\r\n    }\r\n\r\n    /**\r\n      * @dev checks whether or not a given value is a convertible token\r\n      * \r\n      * @param _value value\r\n      * @return true if the given value is a convertible token, false if not\r\n    */\r\n    function isConvertibleToken(address _value) external view returns (bool) {\r\n        return IBancorConverterRegistryData(addressOf(BANCOR_CONVERTER_REGISTRY_DATA)).isConvertibleToken(_value);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the number of smart tokens associated with a given convertible token\r\n      * \r\n      * @param _convertibleToken convertible token\r\n      * @return number of smart tokens associated with the given convertible token\r\n    */\r\n    function getConvertibleTokenSmartTokenCount(address _convertibleToken) external view returns (uint) {\r\n        return IBancorConverterRegistryData(addressOf(BANCOR_CONVERTER_REGISTRY_DATA)).getConvertibleTokenSmartTokenCount(_convertibleToken);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the list of smart tokens associated with a given convertible token\r\n      * \r\n      * @param _convertibleToken convertible token\r\n      * @return list of smart tokens associated with the given convertible token\r\n    */\r\n    function getConvertibleTokenSmartTokens(address _convertibleToken) external view returns (address[]) {\r\n        return IBancorConverterRegistryData(addressOf(BANCOR_CONVERTER_REGISTRY_DATA)).getConvertibleTokenSmartTokens(_convertibleToken);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the smart token associated with a given convertible token at a given index\r\n      * \r\n      * @param _index index\r\n      * @return smart token associated with the given convertible token at the given index\r\n    */\r\n    function getConvertibleTokenSmartToken(address _convertibleToken, uint _index) external view returns (address) {\r\n        return IBancorConverterRegistryData(addressOf(BANCOR_CONVERTER_REGISTRY_DATA)).getConvertibleTokenSmartToken(_convertibleToken, _index);\r\n    }\r\n\r\n    /**\r\n      * @dev checks whether or not a given value is a smart token of a given convertible token\r\n      * \r\n      * @param _convertibleToken convertible token\r\n      * @param _value value\r\n      * @return true if the given value is a smart token of the given convertible token, false if not\r\n    */\r\n    function isConvertibleTokenSmartToken(address _convertibleToken, address _value) external view returns (bool) {\r\n        return IBancorConverterRegistryData(addressOf(BANCOR_CONVERTER_REGISTRY_DATA)).isConvertibleTokenSmartToken(_convertibleToken, _value);\r\n    }\r\n\r\n    /**\r\n      * @dev returns a list of converters for a given list of smart tokens\r\n      * this is a utility function that can be used to reduce the number of calls to the contract\r\n      * \r\n      * @param _smartTokens list of smart tokens\r\n      * @return list of converters\r\n    */\r\n    function getConvertersBySmartTokens(address[] _smartTokens) external view returns (address[]) {\r\n        address[] memory converters = new address[](_smartTokens.length);\r\n\r\n        for (uint i = 0; i < _smartTokens.length; i++)\r\n            converters[i] = ISmartToken(_smartTokens[i]).owner();\r\n\r\n        return converters;\r\n    }\r\n\r\n    /**\r\n      * @dev checks whether or not a given converter is valid\r\n      * \r\n      * @param _converter converter\r\n      * @return true if the given converter is valid, false if not\r\n    */\r\n    function isConverterValid(IBancorConverter _converter) public view returns (bool) {\r\n        // verify the the smart token has a supply and that the converter is active\r\n        ISmartToken token = ISmartTokenController(_converter).token();\r\n        if (token.totalSupply() == 0 || token.owner() != address(_converter))\r\n            return false;\r\n\r\n        // verify that the converter holds balance in each of its reserves\r\n        uint reserveTokenCount = _converter.connectorTokenCount();\r\n        for (uint i = 0; i < reserveTokenCount; i++) {\r\n            if (_converter.connectorTokens(i).balanceOf(_converter) == 0)\r\n                return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @dev searches for a liquidity pool with specific reserve tokens/ratios\r\n      * \r\n      * @param _reserveTokens   reserve tokens\r\n      * @param _reserveRatios   reserve ratios\r\n      * @return the liquidity pool, or zero if no such liquidity pool exists\r\n    */\r\n    function getLiquidityPoolByReserveConfig(address[] memory _reserveTokens, uint[] memory _reserveRatios) public view returns (ISmartToken) {\r\n        // verify that the input parameters represent a valid liquidity pool\r\n        if (_reserveTokens.length == _reserveRatios.length && _reserveTokens.length > 1) {\r\n            // get the smart tokens of the least frequent token (optimization)\r\n            address[] memory convertibleTokenSmartTokens = getLeastFrequentTokenSmartTokens(_reserveTokens);\r\n            // search for a converter with an identical reserve-configuration\r\n            for (uint i = 0; i < convertibleTokenSmartTokens.length; i++) {\r\n                ISmartToken smartToken = ISmartToken(convertibleTokenSmartTokens[i]);\r\n                IBancorConverter converter = IBancorConverter(smartToken.owner());\r\n                if (isConverterReserveConfigEqual(converter, _reserveTokens, _reserveRatios))\r\n                    return smartToken;\r\n            }\r\n        }\r\n\r\n        return ISmartToken(0);\r\n    }\r\n\r\n    /**\r\n      * @dev checks if a liquidity pool with given reserve tokens/ratios is already registered\r\n      * \r\n      * @param _converter converter with specific reserve tokens/ratios\r\n      * @return if a liquidity pool with the same reserve tokens/ratios is already registered\r\n    */\r\n    function isSimilarLiquidityPoolRegistered(IBancorConverter _converter) internal view returns (bool) {\r\n        uint reserveTokenCount = _converter.connectorTokenCount();\r\n        address[] memory reserveTokens = new address[](reserveTokenCount);\r\n        uint[] memory reserveRatios = new uint[](reserveTokenCount);\r\n\r\n        // get the reserve-configuration of the converter\r\n        for (uint i = 0; i < reserveTokenCount; i++) {\r\n            IERC20Token reserveToken = _converter.connectorTokens(i);\r\n            reserveTokens[i] = reserveToken;\r\n            reserveRatios[i] = getReserveRatio(_converter, reserveToken);\r\n        }\r\n\r\n        // return if a liquidity pool with the same reserve tokens/ratios is already registered\r\n        return getLiquidityPoolByReserveConfig(reserveTokens, reserveRatios) != ISmartToken(0);\r\n    }\r\n\r\n    /**\r\n      * @dev adds a smart token to the registry\r\n      * \r\n      * @param _smartToken smart token\r\n    */\r\n    function addSmartToken(IBancorConverterRegistryData _converterRegistryData, address _smartToken) internal {\r\n        _converterRegistryData.addSmartToken(_smartToken);\r\n        emit SmartTokenAdded(_smartToken);\r\n    }\r\n\r\n    /**\r\n      * @dev removes a smart token from the registry\r\n      * \r\n      * @param _smartToken smart token\r\n    */\r\n    function removeSmartToken(IBancorConverterRegistryData _converterRegistryData, address _smartToken) internal {\r\n        _converterRegistryData.removeSmartToken(_smartToken);\r\n        emit SmartTokenRemoved(_smartToken);\r\n    }\r\n\r\n    /**\r\n      * @dev adds a liquidity pool to the registry\r\n      * \r\n      * @param _liquidityPool liquidity pool\r\n    */\r\n    function addLiquidityPool(IBancorConverterRegistryData _converterRegistryData, address _liquidityPool) internal {\r\n        _converterRegistryData.addLiquidityPool(_liquidityPool);\r\n        emit LiquidityPoolAdded(_liquidityPool);\r\n    }\r\n\r\n    /**\r\n      * @dev removes a liquidity pool from the registry\r\n      * \r\n      * @param _liquidityPool liquidity pool\r\n    */\r\n    function removeLiquidityPool(IBancorConverterRegistryData _converterRegistryData, address _liquidityPool) internal {\r\n        _converterRegistryData.removeLiquidityPool(_liquidityPool);\r\n        emit LiquidityPoolRemoved(_liquidityPool);\r\n    }\r\n\r\n    /**\r\n      * @dev adds a convertible token to the registry\r\n      * \r\n      * @param _convertibleToken convertible token\r\n      * @param _smartToken associated smart token\r\n    */\r\n    function addConvertibleToken(IBancorConverterRegistryData _converterRegistryData, address _convertibleToken, address _smartToken) internal {\r\n        _converterRegistryData.addConvertibleToken(_convertibleToken, _smartToken);\r\n        emit ConvertibleTokenAdded(_convertibleToken, _smartToken);\r\n    }\r\n\r\n    /**\r\n      * @dev removes a convertible token from the registry\r\n      * \r\n      * @param _convertibleToken convertible token\r\n      * @param _smartToken associated smart token\r\n    */\r\n    function removeConvertibleToken(IBancorConverterRegistryData _converterRegistryData, address _convertibleToken, address _smartToken) internal {\r\n        _converterRegistryData.removeConvertibleToken(_convertibleToken, _smartToken);\r\n        emit ConvertibleTokenRemoved(_convertibleToken, _smartToken);\r\n    }\r\n\r\n    function getLeastFrequentTokenSmartTokens(address[] memory _tokens) private view returns (address[] memory) {\r\n        IBancorConverterRegistryData bancorConverterRegistryData = IBancorConverterRegistryData(addressOf(BANCOR_CONVERTER_REGISTRY_DATA));\r\n\r\n        // find the token that has the smallest number of smart tokens\r\n        uint minSmartTokenCount = bancorConverterRegistryData.getConvertibleTokenSmartTokenCount(_tokens[0]);\r\n        address[] memory smartTokens = bancorConverterRegistryData.getConvertibleTokenSmartTokens(_tokens[0]);\r\n        for (uint i = 1; i < _tokens.length; i++) {\r\n            uint convertibleTokenSmartTokenCount = bancorConverterRegistryData.getConvertibleTokenSmartTokenCount(_tokens[i]);\r\n            if (minSmartTokenCount > convertibleTokenSmartTokenCount) {\r\n                minSmartTokenCount = convertibleTokenSmartTokenCount;\r\n                smartTokens = bancorConverterRegistryData.getConvertibleTokenSmartTokens(_tokens[i]);\r\n            }\r\n        }\r\n        return smartTokens;\r\n    }\r\n\r\n    function isConverterReserveConfigEqual(IBancorConverter _converter, address[] memory _reserveTokens, uint[] memory _reserveRatios) private view returns (bool) {\r\n        if (_reserveTokens.length != _converter.connectorTokenCount())\r\n            return false;\r\n\r\n        for (uint i = 0; i < _reserveTokens.length; i++) {\r\n            if (_reserveRatios[i] != getReserveRatio(_converter, _reserveTokens[i]))\r\n                return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    bytes4 private constant CONNECTORS_FUNC_SELECTOR = bytes4(uint256(keccak256(\"connectors(address)\") >> (256 - 4 * 8)));\r\n\r\n    function getReserveRatio(address _converter, address _reserveToken) private view returns (uint256) {\r\n        uint256[2] memory ret;\r\n        bytes memory data = abi.encodeWithSelector(CONNECTORS_FUNC_SELECTOR, _reserveToken);\r\n\r\n        assembly {\r\n            let success := staticcall(\r\n                gas,           // gas remaining\r\n                _converter,    // destination address\r\n                add(data, 32), // input buffer (starts after the first 32 bytes in the `data` array)\r\n                mload(data),   // input length (loaded from the first 32 bytes in the `data` array)\r\n                ret,           // output buffer\r\n                64             // output length\r\n            )\r\n            if iszero(success) {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n\r\n        return ret[1];\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_onlyOwnerCanUpdateRegistry\",\"type\":\"bool\"}],\"name\":\"restrictRegistryUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSmartTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_smartTokens\",\"type\":\"address[]\"}],\"name\":\"getConvertersBySmartTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"onlyOwnerCanUpdateRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"isConvertibleToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"isSmartToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getConvertibleTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prevRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getConvertibleTokenCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_converter\",\"type\":\"address\"}],\"name\":\"addConverter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_convertibleToken\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"isConvertibleTokenSmartToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLiquidityPoolCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLiquidityPools\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_reserveTokens\",\"type\":\"address[]\"},{\"name\":\"_reserveRatios\",\"type\":\"uint256[]\"}],\"name\":\"getLiquidityPoolByReserveConfig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getConvertibleToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_converter\",\"type\":\"address\"}],\"name\":\"isConverterValid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_converter\",\"type\":\"address\"}],\"name\":\"removeConverter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getSmartToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_convertibleToken\",\"type\":\"address\"}],\"name\":\"getConvertibleTokenSmartTokenCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getLiquidityPool\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restoreRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_convertibleToken\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getConvertibleTokenSmartToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSmartTokenCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"isLiquidityPool\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_convertibleToken\",\"type\":\"address\"}],\"name\":\"getConvertibleTokenSmartTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_smartToken\",\"type\":\"address\"}],\"name\":\"SmartTokenAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_smartToken\",\"type\":\"address\"}],\"name\":\"SmartTokenRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_liquidityPool\",\"type\":\"address\"}],\"name\":\"LiquidityPoolAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_liquidityPool\",\"type\":\"address\"}],\"name\":\"LiquidityPoolRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_convertibleToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_smartToken\",\"type\":\"address\"}],\"name\":\"ConvertibleTokenAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_convertibleToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_smartToken\",\"type\":\"address\"}],\"name\":\"ConvertibleTokenRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"BancorConverterRegistry","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000052ae12abe5d8bd778bd5397f99ca900624cfadd4","Library":"","LicenseType":"None","SwarmSource":"bzzr://af949f2819597af3b8cb143bfe4395a899cf4ffad6e514278858082d6856e5a9"}]}