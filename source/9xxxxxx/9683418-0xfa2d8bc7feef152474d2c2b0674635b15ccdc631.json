{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.12;\r\n\r\n/**\r\n* @author TradeInvicta.\r\n*/\r\n\r\n/**\r\n* @title IERC223RecipientContract\r\n* @dev abstract class that define by erc223, the method tokenFallback must by receiver contract if it want \r\n*      to accept erc223 tokens.\r\n*      ERC223 Receiving Contract interface\r\n*/\r\ncontract IERC223RecipientContract {\r\n    function tokenFallback(address from, uint value, bytes memory _data) public;\r\n}\r\n\r\n/**\r\n* @title IERC223Token\r\n* @dev ERC223 Contract Interface\r\n*/\r\ncontract IERC223Token {\r\n    function balanceOf(address who)public view returns (uint);\r\n    function transfer(address to, uint value)public returns (bool success);\r\n    function transfer(address to, uint value, bytes memory data)public returns (bool success);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\n/**\r\n* @title IUpgradedToken\r\n* @dev Contract Upgraded Interface\r\n*/\r\ncontract IUpgradedToken{\r\n    function transferToHolder(address _to, uint _value) external;\r\n}\r\n\r\n/**\r\n* @title IAuthorization\r\n* @dev Address IAuthorization Interface\r\n*/\r\ncontract IAuthorization{\r\n    function isAuthorizedAddress(address contratAddress) public view returns (bool);\r\n}\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n*/\r\nlibrary safeMath {\r\n    \r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    \r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    \r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n/**\r\n* @title Ownable\r\n* @dev The Ownable contract has an owner address, and provides basic authorization control\r\n*      functions, this simplifies the implementation of \"user permissions\".\r\n*/\r\ncontract Ownable {\r\n    address public owner;\r\n    \r\n    /** @dev owner transfer event */\r\n    event OwnershipTransferred(address previousOwner, address newOwner);\r\n    \r\n    constructor() internal{\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n    * @dev function thet change the owner of the contract   \r\n    * @param _newOwner The address of the new owner of the contract \r\n    */\r\n    function transferOwnership(address _newOwner) public onlyOwner { \r\n        owner = _newOwner;\r\n        emit OwnershipTransferred(msg.sender, _newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n* @title BlockList\r\n* @dev The BlockList contract has an BlockList address, and provides basic authorization control\r\n*      functions, this simplifies the implementation of \"user address authorization\".\r\n*/\r\ncontract BlockList is Ownable{\r\n    \r\n    mapping (address => bool) internal isBlockListed;\r\n    \r\n    event AddedBlockList(address _user);\r\n    event RemovedBlockList(address _user);\r\n    \r\n    function getBlockListStatus(address _maker) external view returns (bool) {\r\n        return isBlockListed[_maker];\r\n    }\r\n    \r\n    /**\r\n    * @param _evilUser address of user the owner want to add in BlockList \r\n    */\r\n    function addToBlockList (address _evilUser) public onlyOwner {\r\n        require(!isBlockListed[_evilUser]);\r\n        isBlockListed[_evilUser] = true;\r\n        emit AddedBlockList(_evilUser);\r\n    }\r\n\r\n    /**\r\n    * @param _clearedUser address of user the owner want to remove BlockList \r\n    */\r\n    function removeFromBlockList (address _clearedUser) public onlyOwner {\r\n        require(isBlockListed[_clearedUser]);\r\n        isBlockListed[_clearedUser] = false;\r\n        emit RemovedBlockList(_clearedUser);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n/**\r\n* @title ERC223Token\r\n* @dev standard ERC223 contract\r\n*/\r\ncontract ERC223Token is BlockList, IERC223Token {\r\n    \r\n    using safeMath for uint;\r\n    uint8 public basisPointsRate;\r\n    uint public minimumFee;\r\n    uint public maximumFee;\r\n    uint256 public totalHolder;     \r\n    \r\n    mapping(address => bool) internal isHolder;     \r\n    mapping(uint => address) public holders; \r\n    mapping(address => uint) internal balances;\r\n    \r\n    event Transfer(address from, address to, uint256 value, bytes data, uint256 fee);\r\n    \r\n    /**\r\n    * @dev Function that is called when a user or another contract wants to transfer funds.\r\n    * @param _address address of contract.\r\n    * @return true is _address was contract address.\r\n    */\r\n    function isContract(address _address) internal view returns (bool is_contract) {\r\n        uint length;\r\n        require(_address != address(0));\r\n        assembly {\r\n            length := extcodesize(_address)\r\n        }\r\n        return (length > 0);\r\n    }\r\n    \r\n    /**\r\n    * @dev function that is called by transfer method to calculate Fee.\r\n    * @param _amount Amount of tokens.\r\n    * @return fee calculate from _amount.\r\n    */\r\n    function calculateFee(uint _amount) internal view returns(uint fee){\r\n        fee = (_amount.mul(basisPointsRate)).div(1000);\r\n        if (fee > maximumFee) fee = maximumFee;\r\n        if (fee < minimumFee) fee = minimumFee;\r\n    }\r\n    \r\n    /**\r\n    * @dev function that is called when transaction target is a contract.\r\n    * @return true if transferToContract execute successfully.\r\n    */\r\n    function transferToContract(address _to, uint _value, bytes memory _data) internal returns (bool success) {\r\n        require(_value > 0 && balances[msg.sender]>=_value);\r\n        require(_to != msg.sender && _to != address(0));\r\n        uint fee = calculateFee(_value);\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value.sub(fee));\r\n        if (fee > 0) {\r\n            balances[owner] = balances[owner].add(fee);\r\n        }\r\n        IERC223RecipientContract receiver = IERC223RecipientContract(_to);\r\n        receiver.tokenFallback(msg.sender, _value, _data);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        emit Transfer(msg.sender, _to, _value,  _data, fee);\r\n        holderIsExist(_to);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n    * @dev function that is called when transaction target is a external Address.\r\n    * @return true if transferToAddress execute successfully.\r\n    */\r\n    function transferToAddress(address _to, uint _value, bytes memory _data) internal returns (bool success) {\r\n        require(_value > 0 && balances[msg.sender]>=_value);\r\n        require(_to != msg.sender && _to != address(0));\r\n        uint fee = calculateFee(_value);\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value.sub(fee));\r\n        if (fee > 0) {\r\n            balances[owner] = balances[owner].add(fee);\r\n        }\r\n        emit Transfer(msg.sender, _to, _value);\r\n        emit Transfer(msg.sender, _to, _value,  _data, fee);\r\n        holderIsExist(_to);\r\n        return true;\r\n    }\r\n    \r\n    /**     \r\n    * @dev Check for existing holder address if not then add it .     \r\n    * @param _holder The address to check it already exist or not.     \r\n    * @return true if holderIsExist execute successfully.     \r\n    */     \r\n    function holderIsExist(address _holder) internal returns (bool success){         \r\n        if(isHolder[_holder] == true){             \r\n            success = true;          \r\n        } else {             \r\n            isHolder[_holder] = true;             \r\n            holders[totalHolder] = _holder;\r\n            totalHolder = totalHolder.add(1);\r\n            success = true;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n* @title Euinvicta.\r\n* @dev Euinvicta that implements Functionality of ERC223 and Burn, Mint and Pause.\r\n*/\r\ncontract Euinvicta is ERC223Token, Pausable {\r\n    string public  name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 internal _totalSupply;\r\n    bool public Auth;\r\n    bool public deprecated;\r\n    bytes private empty;\r\n    IUpgradedToken private upd;\r\n   \r\n    /** @dev fee Events */\r\n    event Params(uint8 feeBasisPoints,uint maximumFee,uint minimumFee);\r\n    \r\n    /* @dev This notifies about the amount burnt */\r\n    event Burn(address indexed from, uint256 value);\t\r\n    \r\n    /* @dev This notifies about the amount burnt */\r\n    event Mint(address indexed from, uint256 value);\r\n    \r\n    /** @dev IsAutheticate is modifier use to check contract is verifyed or not. */\r\n    modifier IsAuthenticate(){\r\n        require(Auth);\r\n        _;\r\n    }\r\n    \r\n    constructor(string memory _name, string memory _symbol, uint256 totalSupply) public {\r\n        name = _name;                                       // Name of token\r\n        symbol = _symbol;                                   // Symbol of token\r\n        decimals = 18;                                      // Decimal unit of token\r\n        _totalSupply = totalSupply * 10**uint(decimals);    // Initial supply of token\r\n        balances[msg.sender] = _totalSupply;                // Token owner will credited defined token supply\r\n        isHolder[msg.sender] = true;             \r\n        holders[totalHolder] = msg.sender;\r\n        totalHolder = totalHolder.add(1);\r\n        emit Transfer(address(this),msg.sender,_totalSupply);\r\n    }\r\n    \r\n    /**\r\n    * @dev Get totalSupply of tokens.\r\n    */\r\n    function totalSupply() IsAuthenticate public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    \r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) IsAuthenticate public view returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n    \r\n    /**\r\n    * @dev Transfer the specified amount of tokens to the specified address.\r\n    *      This function works the same with the previous one\r\n    *      but doesn't contain `_data` param.\r\n    *      Added due to backwards compatibility reasons.\r\n    * @param to    Receiver address.\r\n    * @param value Amount of tokens that will be transferred.\r\n    * @return true if transfer execute successfully.\r\n    */\r\n    function transfer(address to, uint value) public IsAuthenticate whenNotPaused returns (bool success) {\r\n        require(!deprecated);\r\n        require(!isBlockListed[msg.sender] && !isBlockListed[to]);\r\n        if(isContract(to)) return transferToContract(to, value, empty);\r\n        else return transferToAddress(to, value, empty);\r\n    }\r\n    \r\n    /**\r\n    * @dev Transfer the specified amount of tokens to the specified address.\r\n    *      Invokes the `tokenFallback` function if the recipient is a contract.\r\n    *      The token transfer fails if the recipient is a contract\r\n    *      but does not implement the `tokenFallback` function\r\n    *      or the fallback function to receive funds.\r\n    * @param to    Receiver address.\r\n    * @param value Amount of tokens that will be transferred.\r\n    * @param data  Transaction metadata.\r\n    * @return true if transfer execute successfully.\r\n    */\r\n    function transfer(address to, uint value, bytes memory data) public IsAuthenticate whenNotPaused returns (bool success) {\r\n        require(!deprecated);\r\n        require(!isBlockListed[msg.sender] && !isBlockListed[to]);\r\n        if(isContract(to)) return transferToContract(to, value, data);\r\n        else return transferToAddress(to, value, data);\r\n    }\r\n    \r\n    /**\r\n    * @dev authenticate the address is valid or not \r\n    * @param _authorizationContract The address is authenticate or not.\r\n    * @return true if address is valid.\r\n    */\r\n    function verifyAuthorization(address _authorizationContract) onlyOwner public returns(bool){\r\n        return Auth = IAuthorization(_authorizationContract).isAuthorizedAddress(address(this));\r\n    }\r\n    \r\n    /**\r\n    * @dev withdraw the token on our contract to owner \r\n    * @param _tokenContract address of contract to withdraw token.\r\n    * @return true if transfer success.\r\n    */\r\n    function withdrawForeignTokens(address _tokenContract) onlyOwner IsAuthenticate public returns (bool) {\r\n        IERC223Token token = IERC223Token(_tokenContract);\r\n        uint tokenBalance = token.balanceOf(address(this));\r\n        return token.transfer(owner,tokenBalance);\r\n    }\r\n    \r\n    /**\r\n    * @dev Issue a new amount of tokens\r\n    *      these tokens are deposited into the owner address\r\n    * @param amount Number of tokens to be issue\r\n    */\r\n    function increaseSupply(uint amount) public onlyOwner IsAuthenticate{\r\n        require(amount <= 10000000);\r\n        amount = amount.mul(10**uint(decimals));\r\n        balances[owner] = balances[owner].add(amount);\r\n        _totalSupply = _totalSupply.add(amount);\r\n        emit Transfer(address(0), owner, amount);\r\n    }\r\n    \r\n    /**\r\n    * @dev destory tokens.These tokens are withdrawn from the owner address,\r\n    *      balance must be equal to requested amount else goes fail      \r\n    * @param amount Number of tokens to be destory\r\n    */\r\n    function decreaseSupply(uint amount) public onlyOwner IsAuthenticate {\r\n        require(amount <= 10000000);\r\n        amount = amount.mul(10**uint(decimals));\r\n        require(_totalSupply >= amount && balances[owner] >= amount);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        balances[owner] = balances[owner].sub(amount);\r\n        emit Transfer(owner, address(0), amount);\r\n    }\r\n    \r\n    /**\r\n    * @dev Function to set the basis point rate, min fee, max fee.\r\n    * @param newBasisPoints uint which is <= 9.\r\n    * @param newMaxFee uint which is <= 100 and >= 5.\r\n    * @param newMinFee uint which is <= 5.\r\n    */\r\n    function setTransactionFee(uint8 newBasisPoints, uint newMaxFee, uint newMinFee) public onlyOwner IsAuthenticate{\r\n        require(newBasisPoints <= 9);\r\n        require(newMaxFee >= 5 && newMaxFee <= 100);\r\n        require(newMinFee <= 5);\r\n        basisPointsRate = newBasisPoints;\r\n        maximumFee = newMaxFee.mul(10**uint(decimals));\r\n        minimumFee = newMinFee.mul(10**uint(decimals));\r\n        emit Params(basisPointsRate, maximumFee, minimumFee);\r\n    }\r\n    \r\n    /**\r\n    * @dev destroy blocklisted user token and decrease the totalsupply.\r\n    * @param _blockListedUser destroy token of blocklisted user.\r\n    */\r\n    function flushBlackFunds(address _blockListedUser) public onlyOwner IsAuthenticate{\r\n        require(isBlockListed[_blockListedUser]);\r\n        uint dirtyFunds = balances[_blockListedUser];\r\n        balances[_blockListedUser] = 0;\r\n        _totalSupply = _totalSupply.sub(dirtyFunds);\r\n        emit Transfer(_blockListedUser, address(0), dirtyFunds);\r\n    }\r\n    \r\n    /**\r\n    * @dev deprecate current contract in favour of a new one.\r\n    * @param _upgradedAddress contract address of upgradable contract.\r\n    * @return true if deprecate execute successfully.\r\n    */\r\n    function deprecate(address _upgradedAddress) public onlyOwner IsAuthenticate returns (bool success){\r\n        require(!deprecated);\r\n        deprecated = true;\r\n        upd = IUpgradedToken(_upgradedAddress);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n    * @dev transfer all holders balance on upgraded contract.\r\n    * @param _holder The address who's balanace will be reset.  \r\n    * @return true if deprecate execute successfully.\r\n    */\r\n    function transferHolders(address[] memory _holder) public onlyOwner IsAuthenticate returns (bool success){\r\n        require(deprecated);\r\n        require(_holder.length > 0);\r\n        for(uint i=0; i<_holder.length; i++){\r\n            if(balances[_holder[i]] > 0 && !isBlockListed[_holder[i]]){\r\n                upd.transferToHolder(_holder[i],balances[_holder[i]]);\r\n                _totalSupply = _totalSupply.sub(balances[_holder[i]]);\r\n                balances[_holder[i]] = 0;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n    * @dev Destroy the contract.\r\n    */\r\n    function terminateContract(address payable _owner) public onlyOwner IsAuthenticate{\r\n        require(_owner == owner);\r\n        selfdestruct(_owner);\r\n    }\r\n    \r\n    /**\r\n    * @dev Burn token amount.\r\n    */\r\n    function burn(uint256 _value)public onlyOwner IsAuthenticate {\r\n        require(!deprecated);\r\n        require(!isBlockListed[msg.sender]);\r\n        if (balances[msg.sender] < _value) revert();// Check if the msg.sender has enough\r\n\t    if (_value <= 0) revert(); \r\n        balances[msg.sender] = safeMath.sub(balances[msg.sender], _value);// Subtract from the msg.sender\r\n        _totalSupply = safeMath.sub(_totalSupply,_value);// Updates totalSupply\r\n        emit Burn(msg.sender, _value);\r\n        emit Transfer(msg.sender, address(0), _value);\r\n    }\r\n    \r\n    /**\r\n    * @dev Burn token amount from specific account.\r\n    */\r\n    function burnFrom(address account,uint256 _value) public onlyOwner IsAuthenticate {\r\n        require(!deprecated);\r\n        require(!isBlockListed[msg.sender] && !isBlockListed[account]);\r\n        if (balances[account] < _value) revert();// Check if the account has enough balance to burn\r\n\t    if (_value <= 0) revert(); \r\n        balances[account] = safeMath.sub(balances[account], _value);// Subtract from the account\r\n        _totalSupply = safeMath.sub(_totalSupply,_value);// Updates totalSupply\r\n        emit Burn(account, _value);\r\n        emit Transfer(account, address(0), _value);\r\n    }\r\n    \r\n     /**\r\n    * @dev Mint token amount.\r\n    */\r\n    function mint(address account, uint256 _value)public onlyOwner IsAuthenticate returns (bool success){\r\n        require(!deprecated);\r\n        require(!isBlockListed[account]);\r\n        if (_value <= 0) revert();\r\n        balances[account] = safeMath.add(balances[account], _value);// Add to the account\r\n        _totalSupply = safeMath.add(_totalSupply,_value);// Updates totalSupply\r\n        emit Mint(account, _value);\r\n        emit Transfer(address(0), account,_value);\r\n        return true;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"AddedBlockList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"feeBasisPoints\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maximumFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumFee\",\"type\":\"uint256\"}],\"name\":\"Params\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"RemovedBlockList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"Auth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_evilUser\",\"type\":\"address\"}],\"name\":\"addToBlockList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"basisPointsRate\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"decreaseSupply\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_upgradedAddress\",\"type\":\"address\"}],\"name\":\"deprecate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deprecated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_blockListedUser\",\"type\":\"address\"}],\"name\":\"flushBlackFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_maker\",\"type\":\"address\"}],\"name\":\"getBlockListStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseSupply\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_clearedUser\",\"type\":\"address\"}],\"name\":\"removeFromBlockList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newBasisPoints\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"newMaxFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMinFee\",\"type\":\"uint256\"}],\"name\":\"setTransactionFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"terminateContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalHolder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_holder\",\"type\":\"address[]\"}],\"name\":\"transferHolders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authorizationContract\",\"type\":\"address\"}],\"name\":\"verifyAuthorization\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"withdrawForeignTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Euinvicta","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000098968000000000000000000000000000000000000000000000000000000000000000094555494e5649435441000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044555494e00000000000000000000000000000000000000000000000000000000","Library":"","LicenseType":"None","SwarmSource":"bzzr://5859cf0925f8cb860cad1002323a934ce0f64b85c24af0f0b32951ec5f6f9207"}]}