{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.17; // optimization runs: 200\r\n\r\n\r\n/**\r\n  * @title Compound's InterestRateModel Interface\r\n  * @author Compound\r\n  */\r\ninterface InterestRateModel {\r\n    /**\r\n     * @notice Indicator that this is an InterestRateModel contract (for inspection)\r\n     */\r\n    function isInterestRateModel() external pure returns (bool);\r\n\r\n    /**\r\n      * @notice Calculates the current borrow interest rate per block\r\n      * @param cash The total amount of cash the market has\r\n      * @param borrows The total amount of borrows the market has outstanding\r\n      * @param reserves The total amnount of reserves the market has\r\n      * @return The borrow rate per block (as a percentage, and scaled by 1e18)\r\n      */\r\n    function getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) external view returns (uint256 borrowRateMantissa);\r\n\r\n    /**\r\n      * @notice Calculates the current supply interest rate per block\r\n      * @param cash The total amount of cash the market has\r\n      * @param borrows The total amount of borrows the market has outstanding\r\n      * @param reserves The total amnount of reserves the market has\r\n      * @param reserveFactorMantissa The current reserve factor the market has\r\n      * @return The supply rate per block (as a percentage, and scaled by 1e18)\r\n      */\r\n    function getSupplyRate(uint256 cash, uint256 borrows, uint256 reserves, uint256 reserveFactorMantissa) external view returns (uint256 supplyRateMantissa);\r\n\r\n}\r\n\r\n\r\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\r\n// Subject to the MIT license.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n  * @title Compound's JumpRateModel Contract\r\n  * @author Compound\r\n  */\r\ncontract JumpRateModel is InterestRateModel {\r\n    using SafeMath for uint256;\r\n\r\n    event NewInterestParams(uint256 baseRatePerBlock, uint256 multiplierPerBlock, uint256 jumpMultiplierPerBlock, uint256 kink);\r\n\r\n    /**\r\n     * @notice Indicator that this is an InterestRateModel contract (for inspection)\r\n     */\r\n    bool public constant isInterestRateModel = true;\r\n\r\n    /**\r\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\r\n     */\r\n    uint256 public constant blocksPerYear = 2102400;\r\n\r\n    /**\r\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\r\n     */\r\n    uint256 public multiplierPerBlock;\r\n\r\n    /**\r\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\r\n     */\r\n    uint256 public baseRatePerBlock;\r\n\r\n    /**\r\n     * @notice The multiplierPerBlock after hitting a specified utilization point\r\n     */\r\n    uint256 public jumpMultiplierPerBlock;\r\n\r\n    /**\r\n     * @notice The utilization point at which the jump multiplier is applied\r\n     */\r\n    uint256 public kink;\r\n\r\n    /**\r\n     * @notice Construct an interest rate model\r\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\r\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\r\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\r\n     * @param kink_ The utilization point at which the jump multiplier is applied\r\n     */\r\n    constructor(uint256 baseRatePerYear, uint256 multiplierPerYear, uint256 jumpMultiplierPerYear, uint256 kink_) public {\r\n        baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\r\n        multiplierPerBlock = multiplierPerYear.div(blocksPerYear);\r\n        jumpMultiplierPerBlock = jumpMultiplierPerYear.div(blocksPerYear);\r\n        kink = kink_;\r\n\r\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\r\n     * @param cash The amount of cash in the market\r\n     * @param borrows The amount of borrows in the market\r\n     * @param reserves The amount of reserves in the market (currently unused)\r\n     * @return The utilization rate as a mantissa between [0, 1e18]\r\n     */\r\n    function utilizationRate(uint256 cash, uint256 borrows, uint256 reserves) public pure returns (uint256 utilizationRateMantissa) {\r\n        // Utilization rate is 0 when there are no borrows\r\n        if (borrows == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return (borrows.mul(1e18)).div((cash.add(borrows)).sub(reserves));\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\r\n     * @param cash The amount of cash in the market\r\n     * @param borrows The amount of borrows in the market\r\n     * @param reserves The amount of reserves in the market\r\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\r\n     */\r\n    function getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) public view returns (uint256 borrowRateMantissa) {\r\n        uint256 util = utilizationRate(cash, borrows, reserves);\r\n\r\n        if (util <= kink) {\r\n            return ((util.mul(multiplierPerBlock)).div(1e18)).add(baseRatePerBlock);\r\n        } else {\r\n            uint256 normalRate = ((kink.mul(multiplierPerBlock)).div(1e18)).add(baseRatePerBlock);\r\n            uint256 excessUtil = util.sub(kink);\r\n            return ((excessUtil.mul(jumpMultiplierPerBlock)).div(1e18)).add(normalRate);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the current supply rate per block\r\n     * @param cash The amount of cash in the market\r\n     * @param borrows The amount of borrows in the market\r\n     * @param reserves The amount of reserves in the market\r\n     * @param reserveFactorMantissa The current reserve factor for the market\r\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\r\n     */\r\n    function getSupplyRate(uint256 cash, uint256 borrows, uint256 reserves, uint256 reserveFactorMantissa) public view returns (uint256 supplyRateMantissa) {\r\n        uint256 oneMinusReserveFactor = uint256(1e18).sub(reserveFactorMantissa);\r\n        uint256 borrowRate = getBorrowRate(cash, borrows, reserves);\r\n        uint256 rateToPool = (borrowRate.mul(oneMinusReserveFactor)).div(1e18);\r\n        return (utilizationRate(cash, borrows, reserves).mul(rateToPool)).div(1e18);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n  * @title Compound's DAIInterestRateModel Contract (version 2)\r\n  * @author Compound\r\n  * @notice The parameterized model described in section 2.4 of the original Compound Protocol whitepaper.\r\n  * Version 2 modifies the original interest rate model by increasing the \"gap\" or slope of the model prior\r\n  * to the \"kink\" from 0.05% to 2% with the goal of \"smoothing out\" interest rate changes as the utilization\r\n  * rate increases.\r\n  */\r\ncontract DAIInterestRateModelV2 is JumpRateModel {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @notice The additional margin per block separating the base borrow rate from the roof (2% / block).\r\n     * Note that this value has been increased from the original value of 0.05% per block.\r\n     */\r\n    uint256 public constant gapPerBlock = 2e16 / blocksPerYear;\r\n\r\n    /**\r\n     * @notice The assumed (1 - reserve factor) used to calculate the minimum borrow rate (reserve factor = 0.05)\r\n     */\r\n    uint256 public constant assumedOneMinusReserveFactorMantissa = 0.95e18;\r\n\r\n    PotLike pot;\r\n    JugLike jug;\r\n\r\n    /**\r\n     * @notice Construct an interest rate model\r\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\r\n     * @param kink_ The utilization point at which the jump multiplier is applied\r\n     * @param pot_ The address of the Dai pot (where DSR is earned)\r\n     * @param jug_ The address of the Dai jug (where SF is kept)\r\n     */\r\n    constructor(uint256 jumpMultiplierPerYear, uint256 kink_, address pot_, address jug_) JumpRateModel(0, 0, jumpMultiplierPerYear, kink_) public {\r\n        pot = PotLike(pot_);\r\n        jug = JugLike(jug_);\r\n        poke();\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the current supply interest rate per block including the Dai savings rate\r\n     * @param cash The total amount of cash the market has\r\n     * @param borrows The total amount of borrows the market has outstanding\r\n     * @param reserves The total amnount of reserves the market has\r\n     * @param reserveFactorMantissa The current reserve factor the market has\r\n     * @return The supply rate per block (as a percentage, and scaled by 1e18)\r\n     */\r\n    function getSupplyRate(uint256 cash, uint256 borrows, uint256 reserves, uint256 reserveFactorMantissa) public view returns (uint256 supplyRateMantissa) {\r\n        uint256 protocolRate = super.getSupplyRate(cash, borrows, reserves, reserveFactorMantissa);\r\n\r\n        uint256 underlying = cash.add(borrows).sub(reserves);\r\n        if (underlying == 0) {\r\n            return protocolRate;\r\n        } else {\r\n            uint256 cashRate = cash.mul(dsrPerBlock()).div(underlying);\r\n            return cashRate.add(protocolRate);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the Dai savings rate per block\r\n     * @return The Dai savings rate per block (as a percentage, and scaled by 1e18)\r\n     */\r\n    function dsrPerBlock() public view returns (uint256) {\r\n        return ((pot.dsr()\r\n            .sub(1e27))    // scaled 1e27 aka RAY, and includes an extra \"ONE\" before subraction\r\n            .div(1e9))     // descale to 1e18\r\n            .mul(15);      // 15 seconds per block\r\n    }\r\n\r\n    /**\r\n     * @notice Resets the baseRate and multiplier per block based on the stability fee and Dai savings rate\r\n     */\r\n    function poke() public {\r\n        (uint256 duty, ) = jug.ilks(\"ETH-A\");\r\n        uint256 stabilityFeePerBlock = (((duty.add(jug.base())).sub(1e27)).mul(15e18)).div(1e27);\r\n\r\n        // We ensure the minimum borrow rate >= DSR / (1 - reserve factor)\r\n        baseRatePerBlock = (dsrPerBlock().mul(1e18)).div(assumedOneMinusReserveFactorMantissa);\r\n\r\n        // The roof borrow rate is max(base rate, stability fee) + gap, from which we derive the slope\r\n        if (baseRatePerBlock < stabilityFeePerBlock) {\r\n            multiplierPerBlock = (((stabilityFeePerBlock.add(gapPerBlock)).sub(baseRatePerBlock)).mul(1e18)).div(kink);\r\n        } else {\r\n            multiplierPerBlock = (gapPerBlock.mul(1e18)).div(kink);\r\n        }\r\n\r\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\r\n    }\r\n}\r\n\r\n\r\n/*** Maker Interfaces ***/\r\n\r\ninterface PotLike {\r\n    function chi() external view returns (uint256);\r\n    function dsr() external view returns (uint256);\r\n    function rho() external view returns (uint256);\r\n    function pie(address) external view returns (uint256);\r\n    function drip() external returns (uint256);\r\n    function join(uint256) external;\r\n    function exit(uint256) external;\r\n}\r\n\r\n\r\ninterface JugLike {\r\n   function ilks(bytes32) external view returns (uint256 duty, uint256 rho);\r\n   function base() external view returns (uint256);\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"jumpMultiplierPerYear\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"kink_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pot_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"jug_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseRatePerBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"multiplierPerBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"jumpMultiplierPerBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"kink\",\"type\":\"uint256\"}],\"name\":\"NewInterestParams\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"assumedOneMinusReserveFactorMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blocksPerYear\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dsrPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gapPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrows\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserves\",\"type\":\"uint256\"}],\"name\":\"getBorrowRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowRateMantissa\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrows\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveFactorMantissa\",\"type\":\"uint256\"}],\"name\":\"getSupplyRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"supplyRateMantissa\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInterestRateModel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jumpMultiplierPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kink\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multiplierPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"poke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrows\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserves\",\"type\":\"uint256\"}],\"name\":\"utilizationRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"utilizationRateMantissa\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"DAIInterestRateModelV2","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000010a741a4627800000000000000000000000000000000000000000000000000000c7d713b49da0000000000000000000000000000197e90f9fad81970ba7976f33cbd77088e5d7cf700000000000000000000000019c0976f590d67707e62397c87829d896dc0f1f1","Library":"","LicenseType":"None","SwarmSource":"bzzr://8dc5865ba62c47c2c59354d9f50d9fc4e291245cc9f4482c2fcaf464472c764e"}]}