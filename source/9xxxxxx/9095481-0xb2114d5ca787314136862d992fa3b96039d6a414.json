{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\n\n\ncontract FundSmart {\n    address payable manager;\n\n\n    uint256 private TOP_BORDER_LEVEL = 1000 ether;\n    \n    \n    uint256 private MIN_DEPOSIT = 1 ether;\n    \n    uint256 public DEADLINE = 15;\n\n    modifier onlyOwner() {\n        require (msg.sender == owner);\n        _;\n    }\n    \n    uint public count = 0;\n    \n    mapping(address => Invest[]) public invests;\n    \n    mapping (uint => address) public userCount;\n    \n    mapping(address => User) public users;\n    \n    mapping(address => profitBySystem) public profitOfUser;\n    \n    mapping(address =>  Ancestor[]) public ancestors;\n    \n    mapping(address => address[]) public children;\n\n    mapping(address => uint) public level;\n    \n\n    address public owner;\n    // uint countInvest;\n    event LogDepositMade(address indexed accountAddress, uint amount);\n    \n    \n    struct Ancestor {\n        address payable add;\n    }\n    \n    struct profitBySystem {\n        bool exists;\n        uint profitRef;\n        uint profitReceive;\n        uint profitOfRefReceive;\n    }\n    \n    struct Invest {\n        bool exists;\n        bool requireWithdraw;\n        uint lending;\n        uint deadline;\n        uint timeinvest;\n        uint starttime;\n    }\n\n    struct User {\n        bool exists;\n        address payable parent;\n        uint256 total;\n        uint totalUser;\n    }\n\n    event AddNewUser(\n        bool exists,\n        address parent,\n        uint256 total\n    );\n    \n    event Withdraw (\n        string msg\n    );\n\n\n    function Balance() public view returns (uint) {\n        return address(this).balance;\n    }\n    \n    constructor() public payable {\n        owner = msg.sender;\n        manager = msg.sender;\n    }\n    \n    function() external payable {\n        payForManager(msg.value);\n    }\n    \n    function setDeadline(uint _deadline) public onlyOwner{\n        require(_deadline>=15 && _deadline <=30);\n        DEADLINE = _deadline;\n    }\n    \n    function deposit() public payable {\n         \n        require(msg.value >= MIN_DEPOSIT);\n         \n        address payable _add = msg.sender;\n       \n        payForManager(msg.value);\n         \n        if(users[_add].exists) {\n            users[_add].total +=  msg.value;\n            users[_add].totalUser += msg.value;\n            uint  _deadlines = now + DEADLINE * 1 days;\n            profitOfUser[_add].exists = true;\n            invests[_add].push(Invest({\n                lending : msg.value,\n                requireWithdraw: true,\n                timeinvest : now,\n                starttime : now,\n                deadline : _deadlines,\n                exists : true\n            }));\n            if(profitOfUser[users[_add].parent].exists){\n                profitOfUser[users[_add].parent].profitRef += msg.value * 8 / 100;   \n            }\n            \n            if(level[_add]==0){\n                if(handlerlevelOne(_add)){\n                    level[_add] = 1;\n                }\n            } \n            handlerAncestorTotal(_add,msg.value);\n\n            emit LogDepositMade(_add, msg.value);\n        } else {\n            \n        }\n    }\n    \n    function getProfit(uint _level) private pure returns(uint){\n        if(_level == 0){\n            return 0;\n        }\n        \n        if(_level == 1){\n            return 3;\n        }\n        \n        if(_level ==2){\n            return 5;\n        }\n        \n        if(_level==3){\n            return 6;\n        }\n        \n        return 0;\n    }\n    function handlerAncestorTotal(address _add, uint256 _total) private {\n        Ancestor[] memory _ancestors = ancestors[_add];\n        uint numberAncentors = _ancestors.length;\n        if(numberAncentors>0){\n            for(uint i=0; i< numberAncentors;i++){\n                address addr = _ancestors[numberAncentors-1-i].add;\n                updateTotalOfUser(addr,_total);\n            }\n        }\n    }\n\n    function payForManager(uint amount) private  {\n        manager.transfer(amount / 10);\n    }\n\n\n    function addNewUser(string memory _parent) public payable{\n        address payable parent;\n        \n        if (bytes(_parent).length > 0) {\n             parent = parseAddr(_parent); \n        } else {\n             parent = address(0x0);\n        }\n        \n        if(!users[parent].exists){\n            parent = address(0x0);\n        }\n        address payable _add = msg.sender;\n        if(!users[msg.sender].exists && msg.sender != parent){\n            count++;\n            handlerAncestor(_add, parent);\n             \n            handlerChildren(_add, parent);\n\n            User memory user = User({\n                 exists: true, \n                 parent: parent, \n                 total: 0,\n                 totalUser: 0\n            });\n    \n            users[msg.sender] = user;\n            userCount[count] = msg.sender;\n            emit AddNewUser(true, parent, 0);\n        }\n    }\n    \n    \n    function handlerAncestor(address payable _add, address payable _parents) private {       \n        User storage user = users[_parents];\n        if(user.exists) {\n            ancestors[_add] = ancestors[_parents];\n            ancestors[_add].push(Ancestor({add: _parents}));\n        }\n    }\n    \n    function handlerChildren(address _add, address payable _parents) private {\n        User storage user = users[_parents];        \n          if(user.exists) {\n            children[_parents].push(_add);\n        }\n    }\n    \n    \n    function updateTotalOfUser(address add, uint256 total) private {\n        require(total > 0);\n        User storage user = users[add];\n        if(user.exists) {\n            user.total += total;\n            if(level[add]==0){\n                if(handlerlevelOne(add)){\n                    level[add] = 1;\n                }\n            } else {\n                uint _percent = getProfit(level[add]);\n                profitOfUser[add].profitRef += total * _percent /100;\n                if(handlerLevel(add, level[add])){\n                    level[add]++;\n                    if(level[add]>=3){\n                        level[add] == 3;\n                    }\n                }\n                \n            }\n        } \n    }\n    \n    function handlerlevelOne(address _add) private view returns(bool){\n        bool result = false;\n        address[] memory _children = children[_add];\n        if(users[_add].total>= TOP_BORDER_LEVEL && _children.length >=3 && profitOfUser[_add].exists){\n            uint _currentChildTotal;\n            uint threeMin = 0 ether;\n            uint twoMin = 0 ether;\n            for(uint i = 0; i< _children.length; i++){\n                _currentChildTotal = users[_children[i]].total;\n                if(_currentChildTotal >=200 ether && _currentChildTotal < 300 ether){\n                   if(twoMin == 0 || _currentChildTotal < twoMin){\n                       twoMin = _currentChildTotal;\n                   } \n                }\n                if(_currentChildTotal >= 300 ether){\n                    if(threeMin == 0 || _currentChildTotal < threeMin){\n                        threeMin = _currentChildTotal;\n                    }\n                }\n            }\n            \n            if(threeMin >0 && threeMin > 0){\n                if(users[_add].total - threeMin - twoMin >= 500 ether){\n                    result = true;\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    function handlerLevel(address _add, uint _level) private view returns(bool){\n        bool result = false;\n         address[] memory _children = children[_add];\n        if(users[_add].total>= TOP_BORDER_LEVEL && _children.length >=3){\n            uint _subTotal = users[_add].total;\n            uint _countLevel;\n            for(uint i = 0; i< _children.length; i++){\n                if(level[_children[i]] >= _level){\n                    _countLevel++;\n                    _subTotal = _subTotal - users[_children[i]].total;\n                }\n            }\n            \n           if(_countLevel ==2 ){\n               if(_subTotal >= 500 ether){\n                   result = true;\n               }\n           }\n           \n           if(_countLevel >=3){\n               result = true;\n           }\n            \n        }\n        \n        return result;\n    }\n\n    function downGradeLevel(address _add) private {\n        if(level[_add]==3){\n            if(!handlerLevel(_add,2)){\n                level[_add] = 2;\n            }\n        }\n        \n        if(level[_add] == 2){\n            if(!handlerLevel(_add,1)){\n                level[_add] = 1;\n            }\n        }\n        \n        if(level[_add]==1){\n            if(!handlerlevelOne(_add)){\n                level[_add] = 0;\n            }\n        }\n    }\n\n    \n    function parseAddr(string memory _a) private pure returns (address payable _parsedAddress) {\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i = 2; i < 2 + 2 * 20; i += 2) {\n            iaddr *= 256;\n            b1 = uint160(uint8(tmp[i]));\n            b2 = uint160(uint8(tmp[i + 1]));\n            if ((b1 >= 97) && (b1 <= 102)) {\n                b1 -= 87;\n            } else if ((b1 >= 65) && (b1 <= 70)) {\n                b1 -= 55;\n            } else if ((b1 >= 48) && (b1 <= 57)) {\n                b1 -= 48;\n            }\n            if ((b2 >= 97) && (b2 <= 102)) {\n                b2 -= 87;\n            } else if ((b2 >= 65) && (b2 <= 70)) {\n                b2 -= 55;\n            } else if ((b2 >= 48) && (b2 <= 57)) {\n                b2 -= 48;\n            }\n            iaddr += (b1 * 16 + b2);\n        }\n        return address(iaddr);\n    }\n    \n    \n    function checkWithdraw(uint _index, uint _time, Invest[] storage _invests) private returns (bool) {\n\n        uint i = _index+1;\n        bool isCheck = false;\n        while(i < _invests.length && !isCheck){\n            if(_invests[i].starttime >= _time && _invests[i].requireWithdraw){\n                if(_invests[i].lending >= _invests[_index].lending){\n                     isCheck = true;\n                    _invests[i].requireWithdraw = false;\n                }\n            }\n            \n            i +=1;\n        }\n    \n        return isCheck;\n    }\n    \n    \n    function userWithdraw(address _add) private returns (uint) {\n        Invest[] storage _invest = invests[_add];\n        uint total = 0;\n        \n        for(uint i =0 ; i< _invest.length; i++){\n            if(now >= _invest[i].deadline){\n                if(_invest[i].exists){\n                    if(checkWithdraw(i,_invest[i].deadline,_invest)){\n                        total += _invest[i].lending;\n                        _invest[i].exists = false;\n                        _invest[i].timeinvest = now;\n                    } \n                }\n                \n            }\n        }\n        \n        return total;\n    }\n\n    event LogWithdraw(address indexed accountAddress, string msg);\n    \n    \n    function downGradeLevelAncentor(address _add, uint _total) private {\n        Ancestor[] memory _ancestors = ancestors[_add];\n        for(uint i =0; i <_ancestors.length; i++){\n            address _anc = _ancestors[_ancestors.length-1-i].add;\n            users[_anc].total -= _total;\n            downGradeLevel(_anc);\n        }\n    }\n   \n    function originalWithdraw () public payable{\n        address payable add = msg.sender;\n        if(profitOfUser[add].exists){\n            uint _total = userWithdraw(add);\n            if(_total > 0){\n                uint amount = _total + _total * 8 / 100 ;\n                users[add].total -= _total;\n                users[add].totalUser -= _total;\n                add.transfer(amount);\n                downGradeLevel(add);\n                downGradeLevelAncentor(add,_total);\n                profitOfUser[add].profitReceive += amount;\n                emit LogWithdraw(add, \"Withdraw Succes\");\n            } else {\n                emit LogWithdraw(add, \"You Are Not Eligible To Withdraw\");\n            }\n        } else {\n            emit LogWithdraw(add, \"You May Invest To Withdraw\");\n        }\n    }\n    \n    function withdrawProfit() public payable {\n        address payable add = msg.sender;\n        if(profitOfUser[add].exists){\n            uint _total = profitOfUser[add].profitRef + profitOfUser[add].profitOfRefReceive;\n            if(_total >= users[add].totalUser){\n                if(users[add].totalUser > profitOfUser[add].profitOfRefReceive){\n                    add.transfer(users[add].totalUser-profitOfUser[add].profitOfRefReceive);\n                    profitOfUser[add].profitRef = _total- users[add].totalUser;\n                    profitOfUser[add].profitOfRefReceive = users[add].totalUser;\n                }\n            } else {\n                add.transfer(profitOfUser[add].profitRef);\n                profitOfUser[add].profitOfRefReceive += profitOfUser[add].profitRef;\n                profitOfUser[add].profitRef = 0;\n            }\n            \n            emit LogWithdraw(add, \"Withdraw Succes\");\n        } else {\n             emit LogWithdraw(add, \"You May Invest To Withdraw \");\n        }\n    }\n\n}","ABI":"[{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"AddNewUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogDepositMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"LogWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"Balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEADLINE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_parent\",\"type\":\"string\"}],\"name\":\"addNewUser\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ancestors\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"add\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"children\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"count\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"invests\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"requireWithdraw\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lending\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeinvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"starttime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"level\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"originalWithdraw\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"profitOfUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"profitRef\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profitReceive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profitOfRefReceive\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"setDeadline\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userCount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"parent\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalUser\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawProfit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"FundSmart","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://cd24eee56d9c270042f1e21f01d5b6bf2bcbd1b189d603cbaee61dcb33ea140c"}]}