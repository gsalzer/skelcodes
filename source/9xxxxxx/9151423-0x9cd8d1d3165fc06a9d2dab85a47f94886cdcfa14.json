{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n// File: contracts/zeppelin_v1_12_0/ERC20Basic.sol\r\n\r\n//copy from https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v1.12.0/contracts/token/ERC20/ERC20Basic.sol\r\n//changes: upgraded pragma\r\n\r\npragma solidity ^0.5.12;\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/zeppelin_v1_12_0/BasicToken.sol\r\n\r\n//copy from https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v1.12.0/contracts/token/ERC20/BasicToken.sol\r\n//changes: upgraded pragma, used SafeMath from current openzeppelin\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) internal balances;\r\n\r\n  uint256 internal totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_value <= balances[msg.sender], \"too little\");\r\n    require(_to != address(0));\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/zeppelin_v1_12_0/ERC20.sol\r\n\r\n//copy from https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v1.12.0/contracts/token/ERC20/ERC20.sol\r\n//changes: upgraded pragma\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: contracts/zeppelin_v1_12_0/StandardToken.sol\r\n\r\n//copy from https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v1.12.0/contracts/token/ERC20/StandardToken.sol\r\n//changes: upgraded pragma\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n    require(_to != address(0));\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue >= oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts\\CrwdToken.sol\r\n\r\n/*\r\nImplements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20.\r\n*/\r\npragma solidity ^0.5.12;\r\n\r\n\r\ncontract CrwdToken is StandardToken {\r\n\r\n    // data structures\r\n    enum States {\r\n        Initial, // deployment time\r\n        ValuationSet,\r\n        Ico, // whitelist addresses, accept funds, update balances\r\n        Underfunded, // ICO time finished and minimal amount not raised\r\n        Operational, // production phase\r\n        Paused // for contract upgrades\r\n    }\r\n\r\n    mapping(address => uint256) public ethPossibleRefunds;\r\n\r\n    uint256 public soldTokens;\r\n\r\n    string public constant name = \"CRWDToken\";\r\n\r\n    string public constant symbol = \"CRWT\";\r\n\r\n    uint8 public constant decimals = 18;\r\n\r\n    mapping(address => bool) public whitelist;\r\n\r\n    address public teamTimeLock;\r\n    address public devTimeLock;\r\n    address public countryTimeLock;\r\n\r\n    address public miscNotLocked;\r\n\r\n    address public stateControl;\r\n\r\n    address public whitelistControl;\r\n\r\n    address public withdrawControl;\r\n\r\n    address public tokenAssignmentControl;\r\n\r\n    States public state;\r\n\r\n    uint256 public weiICOMinimum;\r\n\r\n    uint256 public weiICOMaximum;\r\n\r\n    uint256 public silencePeriod;\r\n\r\n    uint256 public startAcceptingFundsBlock;\r\n\r\n    uint256 public endBlock;\r\n\r\n    uint256 public ETH_CRWDTOKEN; //number of tokens per ETH\r\n\r\n    uint256 constant pointMultiplier = 1e18; //100% = 1*10^18 points\r\n\r\n    uint256 public constant maxTotalSupply = 45000000 * pointMultiplier;\r\n\r\n    uint256 public constant percentForSale = 50;\r\n\r\n    event Mint(address indexed to, uint256 amount);\r\n    event MintFinished();\r\n\r\n    bool public mintingFinished = false;\r\n\r\n    //this creates the contract and stores the owner. it also passes in 3 addresses to be used later during the lifetime of the contract.\r\n    constructor(\r\n        address _stateControl,\r\n        address _whitelistControl,\r\n        address _withdrawControl,\r\n        address _tokenAssignmentControl,\r\n        address _notLocked, //15%\r\n        address _lockedTeam, //15%\r\n        address _lockedDev, //10%\r\n        address _lockedCountry //10%\r\n    ) public {\r\n        stateControl = _stateControl;\r\n        whitelistControl = _whitelistControl;\r\n        withdrawControl = _withdrawControl;\r\n        tokenAssignmentControl = _tokenAssignmentControl;\r\n        moveToState(States.Initial);\r\n        weiICOMinimum = 0;\r\n        //to be overridden\r\n        weiICOMaximum = 0;\r\n        endBlock = 0;\r\n        ETH_CRWDTOKEN = 0;\r\n        totalSupply_ = 0;\r\n        soldTokens = 0;\r\n        teamTimeLock = _lockedTeam;\r\n        devTimeLock = _lockedDev;\r\n        countryTimeLock = _lockedCountry;\r\n        miscNotLocked = _notLocked;\r\n    }\r\n\r\n    event Whitelisted(address addr);\r\n\r\n    event StateTransition(States oldState, States newState);\r\n\r\n    modifier onlyWhitelist() {\r\n        require(msg.sender == whitelistControl, \"only whitelisted wallets\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyStateControl() {\r\n        require(msg.sender == stateControl, \"only state-controller\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyTokenAssignmentControl() {\r\n        require(msg.sender == tokenAssignmentControl, \"only assignment controller\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWithdraw() {\r\n        require(msg.sender == withdrawControl, \"only withdraw controller\");\r\n        _;\r\n    }\r\n\r\n    modifier requireState(States _requiredState) {\r\n        require(state == _requiredState, \"invalid token state\");\r\n        _;\r\n    }\r\n\r\n    modifier requireAnyOfTwoStates(States _requiredState1, States _requiredState2) {\r\n        require(state == _requiredState1 || state == _requiredState2, \"wrong token state\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    BEGIN ICO functions\r\n    */\r\n\r\n    //this is the main funding function, it updates the balances of tokens during the ICO.\r\n    //no particular incentive schemes have been implemented here\r\n    //it is only accessible during the \"ICO\" phase.\r\n    function() external payable\r\n    requireState(States.Ico)\r\n    {\r\n        require(whitelist[msg.sender] == true, \"not whitelisted\");\r\n        require(address(this).balance <= weiICOMaximum, \"weiICOMaximum\");\r\n        //note that msg.value is already included in address(this).balance\r\n        require(block.number < endBlock, \"endBlock reached\");\r\n        require(block.number >= startAcceptingFundsBlock, \"startBlock future\");\r\n\r\n        uint256 basisTokens = msg.value.mul(ETH_CRWDTOKEN);\r\n\r\n        issueTokensToUser(msg.sender, basisTokens);\r\n        ethPossibleRefunds[msg.sender] = ethPossibleRefunds[msg.sender].add(msg.value);\r\n    }\r\n\r\n    function issueTokensToUser(address beneficiary, uint256 amount)\r\n    internal\r\n    {\r\n        balances[beneficiary] = balances[beneficiary].add(amount);\r\n        soldTokens = soldTokens.add(amount);\r\n        totalSupply_ = totalSupply_.add(amount.mul(100).div(percentForSale));\r\n        emit Mint(beneficiary, amount);\r\n        emit Transfer(address(0x0), beneficiary, amount);\r\n    }\r\n\r\n    function issuePercentToReserve(address beneficiary, uint256 percentOfSold)\r\n    internal\r\n    {\r\n        uint256 amount = totalSupply_.mul(percentOfSold).div(100);\r\n        balances[beneficiary] = balances[beneficiary].add(amount);\r\n        emit Mint(beneficiary, amount);\r\n        emit Transfer(address(0x0), beneficiary, amount);\r\n    }\r\n\r\n    function moveToState(States _newState)\r\n    internal\r\n    {\r\n        emit StateTransition(state, _newState);\r\n        state = _newState;\r\n    }\r\n\r\n    // ICO contract configuration function\r\n    // newEthICOMinimum is the minimum amount of funds to raise\r\n    // newEthICOMaximum is the maximum amount of funds to raise\r\n    // silencePeriod is a number of blocks to wait after starting the ICO. No funds are accepted during the silence period. It can be set to zero.\r\n    // newEndBlock is the absolute block number at which the ICO must stop. It must be set after now + silence period.\r\n    function updateEthICOThresholds(uint256 _newWeiICOMinimum, uint256 _newWeiICOMaximum, uint256 _silencePeriod, uint256 _newEndBlock)\r\n    public\r\n    onlyStateControl\r\n    {\r\n        require(state == States.Initial || state == States.ValuationSet, \"invalid state\");\r\n        require(_newWeiICOMaximum > _newWeiICOMinimum, \"weiMax\");\r\n        require(block.number + silencePeriod < _newEndBlock, \"high silence\");\r\n        require(block.number < _newEndBlock, \"past endBock\");\r\n        weiICOMinimum = _newWeiICOMinimum;\r\n        weiICOMaximum = _newWeiICOMaximum;\r\n        silencePeriod = _silencePeriod;\r\n        endBlock = _newEndBlock;\r\n        // initial conversion rate of ETH_CRWDTOKEN set now, this is used during the Ico phase.\r\n        ETH_CRWDTOKEN = maxTotalSupply.mul(percentForSale).div(100).div(weiICOMaximum);\r\n        // check pointMultiplier\r\n        moveToState(States.ValuationSet);\r\n    }\r\n\r\n    function startICO()\r\n    public\r\n    onlyStateControl\r\n    requireState(States.ValuationSet)\r\n    {\r\n        require(block.number < endBlock, \"ended\");\r\n        require(block.number + silencePeriod < endBlock, \"ended w silence\");\r\n        startAcceptingFundsBlock = block.number + silencePeriod;\r\n        moveToState(States.Ico);\r\n    }\r\n\r\n    function addPresaleAmount(address beneficiary, uint256 amount)\r\n    public\r\n    onlyTokenAssignmentControl\r\n    {\r\n        require(state == States.ValuationSet || state == States.Ico, \"invalid token state\");\r\n        issueTokensToUser(beneficiary, amount);\r\n    }\r\n\r\n\r\n    function endICO()\r\n    public\r\n    onlyStateControl\r\n    requireState(States.Ico)\r\n    {\r\n        if (address(this).balance < weiICOMinimum) {\r\n            moveToState(States.Underfunded);\r\n        }\r\n        else {\r\n            burnAndFinish();\r\n            moveToState(States.Operational);\r\n        }\r\n    }\r\n\r\n    function anyoneEndICO()\r\n    public\r\n    requireState(States.Ico)\r\n    {\r\n        require(block.number > endBlock, \"not ended\");\r\n        if (address(this).balance < weiICOMinimum) {\r\n            moveToState(States.Underfunded);\r\n        }\r\n        else {\r\n            burnAndFinish();\r\n            moveToState(States.Operational);\r\n        }\r\n    }\r\n\r\n    function burnAndFinish()\r\n    internal\r\n    {\r\n        issuePercentToReserve(teamTimeLock, 15);\r\n        issuePercentToReserve(devTimeLock, 10);\r\n        issuePercentToReserve(countryTimeLock, 10);\r\n        issuePercentToReserve(miscNotLocked, 15);\r\n\r\n        totalSupply_ = soldTokens\r\n        .add(balances[teamTimeLock])\r\n        .add(balances[devTimeLock])\r\n        .add(balances[countryTimeLock])\r\n        .add(balances[miscNotLocked]);\r\n\r\n        mintingFinished = true;\r\n        emit MintFinished();\r\n    }\r\n\r\n    function addToWhitelist(address _whitelisted)\r\n    public\r\n    onlyWhitelist\r\n        //    requireState(States.Ico)\r\n    {\r\n        whitelist[_whitelisted] = true;\r\n        emit Whitelisted(_whitelisted);\r\n    }\r\n\r\n\r\n    //emergency pause for the ICO\r\n    function pause()\r\n    public\r\n    onlyStateControl\r\n    requireState(States.Ico)\r\n    {\r\n        moveToState(States.Paused);\r\n    }\r\n\r\n    //in case we want to completely abort\r\n    function abort()\r\n    public\r\n    onlyStateControl\r\n    requireState(States.Paused)\r\n    {\r\n        moveToState(States.Underfunded);\r\n    }\r\n\r\n    //un-pause\r\n    function resumeICO()\r\n    public\r\n    onlyStateControl\r\n    requireState(States.Paused)\r\n    {\r\n        moveToState(States.Ico);\r\n    }\r\n\r\n    //in case of a failed/aborted ICO every investor can get back their money\r\n    function requestRefund()\r\n    public\r\n    requireState(States.Underfunded)\r\n    {\r\n        require(ethPossibleRefunds[msg.sender] > 0, \"nothing to refund\");\r\n        //there is no need for updateAccount(msg.sender) since the token never became active.\r\n        uint256 payout = ethPossibleRefunds[msg.sender];\r\n        //reverse calculate the amount to pay out\r\n        ethPossibleRefunds[msg.sender] = 0;\r\n        msg.sender.transfer(payout);\r\n    }\r\n\r\n    //after the ico has run its course, the withdraw account can drain funds bit-by-bit as needed.\r\n    function requestPayout(uint _amount)\r\n    public\r\n    onlyWithdraw //very important!\r\n    requireState(States.Operational)\r\n    {\r\n        msg.sender.transfer(_amount);\r\n    }\r\n\r\n    //if this contract gets a balance in some other ERC20 contract - or even iself - then we can rescue it.\r\n    function rescueToken(ERC20Basic _foreignToken, address _to)\r\n    public\r\n    onlyTokenAssignmentControl\r\n    requireState(States.Operational)\r\n    {\r\n        _foreignToken.transfer(_to, _foreignToken.balanceOf(address(this)));\r\n    }\r\n    /**\r\n    END ICO functions\r\n    */\r\n\r\n    /**\r\n    BEGIN ERC20 functions\r\n    */\r\n    function transfer(address _to, uint256 _value)\r\n    public\r\n    requireAnyOfTwoStates(States.Operational, States.Ico)\r\n    returns (bool success) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n    public\r\n    requireAnyOfTwoStates(States.Operational, States.Ico)\r\n    returns (bool success) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function balanceOf(address _account)\r\n    public\r\n    view\r\n    returns (uint256 balance) {\r\n        return balances[_account];\r\n    }\r\n\r\n    /**\r\n    END ERC20 functions\r\n    */\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stateControl\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_whitelistControl\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_withdrawControl\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAssignmentControl\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_notLocked\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lockedTeam\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lockedDev\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lockedCountry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum CrwdToken.States\",\"name\":\"oldState\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"enum CrwdToken.States\",\"name\":\"newState\",\"type\":\"uint8\"}],\"name\":\"StateTransition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_CRWDTOKEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"abort\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addPresaleAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_whitelisted\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"anyoneEndICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countryTimeLock\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devTimeLock\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ethPossibleRefunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"miscNotLocked\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percentForSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"requestPayout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"requestRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20Basic\",\"name\":\"_foreignToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"rescueToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resumeICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"silencePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startAcceptingFundsBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum CrwdToken.States\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stateControl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamTimeLock\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAssignmentControl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newWeiICOMinimum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newWeiICOMaximum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_silencePeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newEndBlock\",\"type\":\"uint256\"}],\"name\":\"updateEthICOThresholds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiICOMaximum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiICOMinimum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistControl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawControl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CrwdToken","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000006f136a56dd00f89207cbb9d20d32cc493b2c5c2f000000000000000000000000fb2330a6c58a792b27997481ab7097978adbbdb80000000000000000000000009a1d2f0f3a882e38fbfe4b74d6295576ea866e37000000000000000000000000bf72a1f9edb56188ec69bf790bacae596a5d1e1b0000000000000000000000003c90233869f9819b925896fc5539d1b4380c04eb0000000000000000000000004eb6716f6fa6ed53c7e6d77ad78be0630ee9a397000000000000000000000000eda8af69383cb55db25e8427ccffc43bf9faea870000000000000000000000007f2b19a8c6f61f417ba2ffe8c6f2f9cb3476e2ef","Library":"","LicenseType":"None","SwarmSource":"bzzr://15657c000028fe70a9622a7d92e41d55208226f3a0de58bc4f8aa17d85f3f8cd"}]}