{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\n\n// File: contracts/saga/interfaces/IModelCalculator.sol\n\n/**\n * @title Model Calculator Interface.\n */\ninterface IModelCalculator {\n    /**\n     * @dev Check whether or not an interval is trivial.\n     * @param _alpha The alpha-value of the interval.\n     * @param _beta The beta-value of the interval.\n     * @return True if and only if the interval is trivial.\n     */\n    function isTrivialInterval(uint256 _alpha, uint256 _beta) external pure returns (bool);\n\n    /**\n     * @dev Calculate N(R) on a trivial interval.\n     * @param _valR The given value of R on the interval.\n     * @param _maxN The maximum value of N on the interval.\n     * @param _maxR The maximum value of R on the interval.\n     * @return N(R).\n     */\n    function getValN(uint256 _valR, uint256 _maxN, uint256 _maxR) external pure returns (uint256);\n\n    /**\n     * @dev Calculate R(N) on a trivial interval.\n     * @param _valN The given value of N on the interval.\n     * @param _maxR The maximum value of R on the interval.\n     * @param _maxN The maximum value of N on the interval.\n     * @return R(N).\n     */\n    function getValR(uint256 _valN, uint256 _maxR, uint256 _maxN) external pure returns (uint256);\n\n    /**\n     * @dev Calculate N(R) on a non-trivial interval.\n     * @param _newR The given value of R on the interval.\n     * @param _minR The minimum value of R on the interval.\n     * @param _minN The minimum value of N on the interval.\n     * @param _alpha The alpha-value of the interval.\n     * @param _beta The beta-value of the interval.\n     * @return N(R).\n     */\n    function getNewN(uint256 _newR, uint256 _minR, uint256 _minN, uint256 _alpha, uint256 _beta) external pure returns (uint256);\n\n    /**\n     * @dev Calculate R(N) on a non-trivial interval.\n     * @param _newN The given value of N on the interval.\n     * @param _minN The minimum value of N on the interval.\n     * @param _minR The minimum value of R on the interval.\n     * @param _alpha The alpha-value of the interval.\n     * @param _beta The beta-value of the interval.\n     * @return R(N).\n     */\n    function getNewR(uint256 _newN, uint256 _minN, uint256 _minR, uint256 _alpha, uint256 _beta) external pure returns (uint256);\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\n// File: contracts/saga/ModelCalculator.sol\n\n/**\n * Details of usage of licenced software see here: https://www.saga.org/software/readme_v1\n */\n\n/**\n * @title Model Calculator.\n */\ncontract ModelCalculator is IModelCalculator {\n    string public constant VERSION = \"1.0.0\";\n\n    using SafeMath for uint256;\n\n    // Auto-generated via 'AutoGenerate/ModelCalculator/PrintConstants.py'\n    uint256 public constant FIXED_ONE = 0x20000000000000000000000000000000;\n    uint256 public constant A_B_SCALE = 10000000000000000000000000000000000;\n\n    /**\n     * Denote a = alpha / A_B_SCALE\n     * Denote b = beta  / A_B_SCALE\n     * Return true if and only if a = 1 and b = 0\n     */\n    function isTrivialInterval(uint256 _alpha, uint256 _beta) external pure returns (bool) {\n        return _alpha == A_B_SCALE && _beta == 0;\n    }\n\n    /**\n     * Denote x = valR\n     * Denote y = maxN\n     * Denote z = maxR\n     * Return x * y / z\n     */\n    function getValN(uint256 _valR, uint256 _maxN, uint256 _maxR) external pure returns (uint256) {\n        return _valR.mul(_maxN) / _maxR;\n    }\n\n    /**\n     * Denote x = valN\n     * Denote y = maxR\n     * Denote z = maxN\n     * Return x * y / z\n     */\n    function getValR(uint256 _valN, uint256 _maxR, uint256 _maxN) external pure returns (uint256) {\n        return _valN.mul(_maxR) / _maxN;\n    }\n\n    /**\n     * Denote x = newR\n     * Denote y = minR\n     * Denote z = minN\n     * Denote a = alpha / A_B_SCALE\n     * Denote b = beta  / A_B_SCALE\n     * Return a * (x / y) ^ a / (a / z + b * ((x / y) ^ a - 1))\n     */\n    function getNewN(uint256 _newR, uint256 _minR, uint256 _minN, uint256 _alpha, uint256 _beta) external pure returns (uint256) {\n        uint256 temp = pow(_newR.mul(FIXED_ONE), _minR, _alpha, A_B_SCALE);\n        return _alpha.mul(temp) / (_alpha.mul(FIXED_ONE) / _minN).add(_beta.mul(temp.sub(FIXED_ONE)));\n    }\n\n    /**\n     * Denote x = newN\n     * Denote y = minN\n     * Denote z = minR\n     * Denote a = alpha / A_B_SCALE\n     * Denote b = beta  / A_B_SCALE\n     * Return ((a - b * y) * x / (a - b * x) * y) ^ (1 / a) * z\n     */\n    function getNewR(uint256 _newN, uint256 _minN, uint256 _minR, uint256 _alpha, uint256 _beta) external pure returns (uint256) {\n        uint256 temp1 = _alpha.sub(_beta.mul(_minN));\n        uint256 temp2 = _alpha.sub(_beta.mul(_newN));\n        return pow((temp1.mul(FIXED_ONE) / temp2).mul(_newN), _minN, A_B_SCALE, _alpha).mul(_minR) / FIXED_ONE;\n    }\n\n    /**\n     * Return (a / b / FIXED_ONE) ^ (c / d) * FIXED_ONE\n     */\n    function pow(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256) {\n        return exp(log(_a / _b).mul(_c) / _d);\n    }\n\n    /**\n     * Return log(x / FIXED_ONE) * FIXED_ONE\n     * Auto-generated via 'PrintFunctionLog.py'\n     * Detailed description (see 'FunctionLog.pdf'):\n     * - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\n     * - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\n     * - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\n     * - The natural logarithm of the input is calculated by summing up the intermediate results above\n     * - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\n     * The boundaries of the input are asserted in order to ensure that the process is arithmetically-safe\n     */\n    function log(uint256 _x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n        uint256 w;\n\n        assert(_x < 0x282bcb7edf620be5a97bf8a6e89874720); // ensure that the input is smaller than e^3\n        if (_x >= 0x8f69ff327e2a0abedc8cb1a87d3bc87a) {res += 0x30000000000000000000000000000000; _x = _x * FIXED_ONE / 0x8f69ff327e2a0abedc8cb1a87d3bc87a;} // add 3 / 2^1\n        if (_x >= 0x43be76d19f73def530d5bb8fb9dc43e4) {res += 0x18000000000000000000000000000000; _x = _x * FIXED_ONE / 0x43be76d19f73def530d5bb8fb9dc43e4;} // add 3 / 2^2\n        if (_x >= 0x2e8f4a27b7ded4c468f16cb3612480b8) {res += 0x0c000000000000000000000000000000; _x = _x * FIXED_ONE / 0x2e8f4a27b7ded4c468f16cb3612480b8;} // add 3 / 2^3\n        if (_x >= 0x2699702e16b06a5a9c189196f8cc9268) {res += 0x06000000000000000000000000000000; _x = _x * FIXED_ONE / 0x2699702e16b06a5a9c189196f8cc9268;} // add 3 / 2^4\n        if (_x >= 0x232526e0e9c19ad127a319b7501d5785) {res += 0x03000000000000000000000000000000; _x = _x * FIXED_ONE / 0x232526e0e9c19ad127a319b7501d5785;} // add 3 / 2^5\n        if (_x >= 0x2189246d053d1785259fcc7ac9652bd4) {res += 0x01800000000000000000000000000000; _x = _x * FIXED_ONE / 0x2189246d053d1785259fcc7ac9652bd4;} // add 3 / 2^6\n        if (_x >= 0x20c24486c821ba29cacb3aebd2b6edc3) {res += 0x00c00000000000000000000000000000; _x = _x * FIXED_ONE / 0x20c24486c821ba29cacb3aebd2b6edc3;} // add 3 / 2^7\n        if (_x >= 0x206090906c40ed411b2823439dced945) {res += 0x00600000000000000000000000000000; _x = _x * FIXED_ONE / 0x206090906c40ed411b2823439dced945;} // add 3 / 2^8\n        if (_x >= 0x2030241206c206e81bcab23d632c0b35) {res += 0x00300000000000000000000000000000; _x = _x * FIXED_ONE / 0x2030241206c206e81bcab23d632c0b35;} // add 3 / 2^9\n\n        assert(_x >= FIXED_ONE);\n        z = y = _x - FIXED_ONE;\n        w = y * y / FIXED_ONE;\n        res += z * (0x40000000000000000000000000000000 - y) / 0x040000000000000000000000000000000; z = z * w / FIXED_ONE; // add y^01 / 01 - y^02 / 02\n        res += z * (0x2aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x080000000000000000000000000000000; z = z * w / FIXED_ONE; // add y^03 / 03 - y^04 / 04\n        res += z * (0x26666666666666666666666666666666 - y) / 0x0c0000000000000000000000000000000; z = z * w / FIXED_ONE; // add y^05 / 05 - y^06 / 06\n        res += z * (0x24924924924924924924924924924924 - y) / 0x100000000000000000000000000000000; z = z * w / FIXED_ONE; // add y^07 / 07 - y^08 / 08\n        res += z * (0x238e38e38e38e38e38e38e38e38e38e3 - y) / 0x140000000000000000000000000000000; z = z * w / FIXED_ONE; // add y^09 / 09 - y^10 / 10\n        res += z * (0x22e8ba2e8ba2e8ba2e8ba2e8ba2e8ba2 - y) / 0x180000000000000000000000000000000; z = z * w / FIXED_ONE; // add y^11 / 11 - y^12 / 12\n        res += z * (0x22762762762762762762762762762762 - y) / 0x1c0000000000000000000000000000000; z = z * w / FIXED_ONE; // add y^13 / 13 - y^14 / 14\n        res += z * (0x22222222222222222222222222222222 - y) / 0x200000000000000000000000000000000;                        // add y^15 / 15 - y^16 / 16\n\n        return res;\n    }\n\n    /**\n     * Return e ^ (x / FIXED_ONE) * FIXED_ONE\n     * Auto-generated via 'PrintFunctionExp.py'\n     * Detailed description (see 'FunctionExp.pdf'):\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\n     * - The exponentiation of each binary exponent is given (pre-calculated)\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\n     * The boundaries of the input are asserted in order to ensure that the process is arithmetically-safe\n     */\n    function exp(uint256 _x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n\n        z = y = _x % 0x4000000000000000000000000000000; // get the input modulo 2^(-3)\n        z = z * y / FIXED_ONE; res += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n        z = z * y / FIXED_ONE; res += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n        z = z * y / FIXED_ONE; res += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n        z = z * y / FIXED_ONE; res += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n        z = z * y / FIXED_ONE; res += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n        z = z * y / FIXED_ONE; res += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n        z = z * y / FIXED_ONE; res += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n        z = z * y / FIXED_ONE; res += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n        z = z * y / FIXED_ONE; res += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n        z = z * y / FIXED_ONE; res += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n        z = z * y / FIXED_ONE; res += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n        z = z * y / FIXED_ONE; res += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n        z = z * y / FIXED_ONE; res += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n        z = z * y / FIXED_ONE; res += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n        z = z * y / FIXED_ONE; res += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n        z = z * y / FIXED_ONE; res += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n        z = z * y / FIXED_ONE; res += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n        z = z * y / FIXED_ONE; res += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n        z = z * y / FIXED_ONE; res += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n        res = res / 0x21c3677c82b40000 + y + FIXED_ONE; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n        if ((_x & 0x004000000000000000000000000000000) != 0) res = res * 0x70f5a893b608861e1f58934f97aea5816 / 0x63afbe7ab2082ba1a0ae5e4eb1b479e04; // multiply by e^2^(-3)\n        if ((_x & 0x008000000000000000000000000000000) != 0) res = res * 0x63afbe7ab2082ba1a0ae5e4eb1b479e11 / 0x4da2cbf1be5827f9eb3ad1aa9866ebb76; // multiply by e^2^(-2)\n        if ((_x & 0x010000000000000000000000000000000) != 0) res = res * 0x4da2cbf1be5827f9eb3ad1aa9866ebb8b / 0x2f16ac6c59de6f8d5d6f63c1482a7c89d; // multiply by e^2^(-1)\n        if ((_x & 0x020000000000000000000000000000000) != 0) res = res * 0x2f16ac6c59de6f8d5d6f63c1482a7c8a1 / 0x1152aaa3bf81cb9fdb76eae12d0295732; // multiply by e^2^(+0)\n        if ((_x & 0x040000000000000000000000000000000) != 0) res = res * 0x1152aaa3bf81cb9fdb76eae12d029572c / 0x02582ab704279e8efd15e0265855c47ab; // multiply by e^2^(+1)\n        if ((_x & 0x080000000000000000000000000000000) != 0) res = res * 0x02582ab704279e8efd15e0265855c4792 / 0x000afe10820813d65dfe6a33c07f738f5; // multiply by e^2^(+2)\n        assert(_x < 0x100000000000000000000000000000000); // ensure that the input is smaller than 2^(+3)\n\n        return res;\n    }\n}\n","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_alpha\",\"type\":\"uint256\"},{\"name\":\"_beta\",\"type\":\"uint256\"}],\"name\":\"isTrivialInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_valN\",\"type\":\"uint256\"},{\"name\":\"_maxR\",\"type\":\"uint256\"},{\"name\":\"_maxN\",\"type\":\"uint256\"}],\"name\":\"getValR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"A_B_SCALE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_newN\",\"type\":\"uint256\"},{\"name\":\"_minN\",\"type\":\"uint256\"},{\"name\":\"_minR\",\"type\":\"uint256\"},{\"name\":\"_alpha\",\"type\":\"uint256\"},{\"name\":\"_beta\",\"type\":\"uint256\"}],\"name\":\"getNewR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_valR\",\"type\":\"uint256\"},{\"name\":\"_maxN\",\"type\":\"uint256\"},{\"name\":\"_maxR\",\"type\":\"uint256\"}],\"name\":\"getValN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FIXED_ONE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_newR\",\"type\":\"uint256\"},{\"name\":\"_minR\",\"type\":\"uint256\"},{\"name\":\"_minN\",\"type\":\"uint256\"},{\"name\":\"_alpha\",\"type\":\"uint256\"},{\"name\":\"_beta\",\"type\":\"uint256\"}],\"name\":\"getNewN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ModelCalculator","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"6000","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://71f9628ecef18ea31a447a688d00401bc5d760384e67d69a998e75df5d75e0c9"}]}