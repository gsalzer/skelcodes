{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.16; /*\r\n\r\n___________________________________________________________________\r\n  _      _                                        ______           \r\n  |  |  /          /                                /              \r\n--|-/|-/-----__---/----__----__---_--_----__-------/-------__------\r\n  |/ |/    /___) /   /   ' /   ) / /  ) /___)     /      /   )     \r\n__/__|____(___ _/___(___ _(___/_/_/__/_(___ _____/______(___/__o_o_\r\n\r\n\r\n .----------------.  .----------------.  .-----------------. .----------------.  .----------------. \r\n| .--------------. || .--------------. || .--------------. || .--------------. || .--------------. |\r\n| |     ______   | || |  _________   | || | ____  _____  | || |  _________   | || |     _____    | |\r\n| |   .' ___  |  | || | |_   ___  |  | || ||_   \\|_   _| | || | |  _   _  |  | || |    |_   _|   | |\r\n| |  / .'   \\_|  | || |   | |_  \\_|  | || |  |   \\ | |   | || | |_/ | | \\_|  | || |      | |     | |\r\n| |  | |         | || |   |  _|  _   | || |  | |\\ \\| |   | || |     | |      | || |      | |     | |\r\n| |  \\ `.___.'\\  | || |  _| |___/ |  | || | _| |_\\   |_  | || |    _| |_     | || |     _| |_    | |\r\n| |   `._____.'  | || | |_________|  | || ||_____|\\____| | || |   |_____|    | || |    |_____|   | |\r\n| |              | || |              | || |              | || |              | || |              | |\r\n| '--------------' || '--------------' || '--------------' || '--------------' || '--------------' |\r\n '----------------'  '----------------'  '----------------'  '----------------'  '----------------' \r\n\r\n\r\n=== 'CENTI' Token contract with following features ===\r\n    => ERC20 Compliance\r\n    => Higher degree of control by owner - safeguard functionality\r\n    => SafeMath implementation \r\n    => Burnable and minting \r\n    => user whitelisting \r\n    => air drop (active)\r\n    => In-built buy/sell tokens\r\n    => Upgradeability using Unstructured Storage: https://github.com/zeppelinos/labs/tree/master/upgradeability_using_unstructured_storage \r\n\r\n\r\n======================= Quick Stats ===================\r\n    => Name        : CENTI\r\n    => Symbol      : CEN\r\n    => Total supply: 10,000,000,000 (10 Billion)\r\n    => Decimals    : 2\r\n\r\n\r\n============= Independant Audit of the code ============\r\n    => Multiple Freelancers Auditors\r\n    => Community Audit by Bug Bounty program\r\n\r\n\r\n-------------------------------------------------------------------\r\n Copyright (c) 2020 onwards CENTI Token Inc. ( https://centitoken.com )\r\n Contract designed with ❤ by EtherAuthority ( https://EtherAuthority.io )\r\n-------------------------------------------------------------------\r\n*/ \r\n\r\n\r\n\r\n\r\n//*******************************************************************//\r\n//------------------------ SafeMath Library -------------------------//\r\n//*******************************************************************//\r\n/**\r\n    * @title SafeMath\r\n    * @dev Math operations with safety checks that throw on error\r\n    */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n        return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b, 'SafeMath mul failed');\r\n    return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, 'SafeMath sub failed');\r\n    return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, 'SafeMath add failed');\r\n    return c;\r\n    }\r\n}\r\n\r\n\r\n//*******************************************************************//\r\n//------------------ Contract to Manage Ownership -------------------//\r\n//*******************************************************************//\r\n    \r\ncontract owned {\r\n    address payable public owner;\r\n    address payable internal newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), owner);\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address payable _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    //this flow is to prevent transferring ownership to wrong wallet by mistake\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n \r\n\r\n    \r\n//****************************************************************************//\r\n//---------------------        MAIN CODE STARTS HERE     ---------------------//\r\n//****************************************************************************//\r\n    \r\ncontract CENTI is owned {\r\n    \r\n\r\n    /*===============================\r\n    =         DATA STORAGE          =\r\n    ===============================*/\r\n\r\n    // Public variables of the token\r\n    using SafeMath for uint256;\r\n    string constant private _name = \"CENTI\";\r\n    string constant private _symbol = \"CEN\";\r\n    uint256 constant private _decimals = 2;\r\n    uint256 private _totalSupply = 10000000000 * (10**_decimals);       //10 billion tokens\r\n    uint256 constant public maxSupply = 10000000000 * (10**_decimals);  //10 billion tokens\r\n    bool public safeguard;  //putting safeguard on will halt all non-owner functions\r\n\r\n    // This creates a mapping with all data storage\r\n    mapping (address => uint256) private _balanceOf;\r\n    mapping (address => mapping (address => uint256)) private _allowance;\r\n    mapping (address => bool) public frozenAccount;\r\n\r\n\r\n    /*===============================\r\n    =         PUBLIC EVENTS         =\r\n    ===============================*/\r\n\r\n    // This generates a public event of token transfer\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // This notifies clients about the amount burnt\r\n    event Burn(address indexed from, uint256 value);\r\n        \r\n    // This generates a public event for frozen (blacklisting) accounts\r\n    event FrozenAccounts(address target, bool frozen);\r\n    \r\n    // This will log approval of token Transfer\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n\r\n\r\n\r\n    /*======================================\r\n    =       STANDARD ERC20 FUNCTIONS       =\r\n    ======================================*/\r\n    \r\n    /**\r\n     * Returns name of token \r\n     */\r\n    function name() public pure returns(string memory){\r\n        return _name;\r\n    }\r\n    \r\n    /**\r\n     * Returns symbol of token \r\n     */\r\n    function symbol() public pure returns(string memory){\r\n        return _symbol;\r\n    }\r\n    \r\n    /**\r\n     * Returns decimals of token \r\n     */\r\n    function decimals() public pure returns(uint256){\r\n        return _decimals;\r\n    }\r\n    \r\n    /**\r\n     * Returns totalSupply of token.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    \r\n    /**\r\n     * Returns balance of token \r\n     */\r\n    function balanceOf(address user) public view returns(uint256){\r\n        return _balanceOf[user];\r\n    }\r\n    \r\n    /**\r\n     * Returns allowance of token \r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowance[owner][spender];\r\n    }\r\n    \r\n    /**\r\n     * Internal transfer, only can be called by this contract \r\n     */\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        \r\n        //checking conditions\r\n        require(!safeguard);\r\n        require (_to != address(0));                      // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\r\n        require(!frozenAccount[_to]);                       // Check if recipient is frozen\r\n        \r\n        // overflow and undeflow checked by SafeMath Library\r\n        _balanceOf[_from] = _balanceOf[_from].sub(_value);    // Subtract from the sender\r\n        _balanceOf[_to] = _balanceOf[_to].add(_value);        // Add the same to the recipient\r\n        \r\n        // emit Transfer event\r\n        emit Transfer(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n        * Transfer tokens\r\n        *\r\n        * Send `_value` tokens to `_to` from your account\r\n        *\r\n        * @param _to The address of the recipient\r\n        * @param _value the amount to send\r\n        */\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        //no need to check for input validations, as that is ruled by SafeMath\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        * Transfer tokens from other address\r\n        *\r\n        * Send `_value` tokens to `_to` in behalf of `_from`\r\n        *\r\n        * @param _from The address of the sender\r\n        * @param _to The address of the recipient\r\n        * @param _value the amount to send\r\n        */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        //checking of allowance and token value is done by SafeMath\r\n        _allowance[_from][msg.sender] = _allowance[_from][msg.sender].sub(_value);\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        * Set allowance for other address\r\n        *\r\n        * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\n        *\r\n        * @param _spender The address authorized to spend\r\n        * @param _value the max amount they can spend\r\n        */\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        require(!safeguard);\r\n        /* AUDITOR NOTE:\r\n            Many dex and dapps pre-approve large amount of tokens to save gas for subsequent transaction. This is good use case.\r\n            On flip-side, some malicious dapp, may pre-approve large amount and then drain all token balance from user.\r\n            So following condition is kept in commented. It can be be kept that way or not based on client's consent.\r\n        */\r\n        //require(_balanceOf[msg.sender] >= _value, \"Balance does not have enough tokens\");\r\n        _allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed_[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to increase the allowance by.\r\n     */\r\n    function increase_allowance(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0));\r\n        _allowance[msg.sender][spender] = _allowance[msg.sender][spender].add(value);\r\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed_[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decrease_allowance(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0));\r\n        _allowance[msg.sender][spender] = _allowance[msg.sender][spender].sub(value);\r\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n\r\n    /*=====================================\r\n    =       CUSTOM PUBLIC FUNCTIONS       =\r\n    ======================================*/\r\n    \r\n    constructor() public{\r\n        //sending all the tokens to Owner\r\n        _balanceOf[owner] = _totalSupply;\r\n        \r\n        //firing event which logs this transaction\r\n        emit Transfer(address(0), owner, _totalSupply);\r\n    }\r\n    \r\n    function () external payable {\r\n      buyTokens();\r\n    }\r\n\r\n    /**\r\n        * Destroy tokens\r\n        *\r\n        * Remove `_value` tokens from the system irreversibly\r\n        *\r\n        * @param _value the amount of money to burn\r\n        */\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(!safeguard);\r\n        //checking of enough token balance is done by SafeMath\r\n        _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(_value);  // Subtract from the sender\r\n        _totalSupply = _totalSupply.sub(_value);                      // Updates totalSupply\r\n        emit Burn(msg.sender, _value);\r\n        emit Transfer(msg.sender, address(0), _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        * Destroy tokens from other account\r\n        *\r\n        * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n        *\r\n        * @param _from the address of the sender\r\n        * @param _value the amount of money to burn\r\n        */\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(!safeguard);\r\n        //checking of allowance and token value is done by SafeMath\r\n        _balanceOf[_from] = _balanceOf[_from].sub(_value);                         // Subtract from the targeted balance\r\n        _allowance[_from][msg.sender] = _allowance[_from][msg.sender].sub(_value); // Subtract from the sender's allowance\r\n        _totalSupply = _totalSupply.sub(_value);                                   // Update totalSupply\r\n        emit  Burn(_from, _value);\r\n        emit Transfer(_from, address(0), _value);\r\n        return true;\r\n    }\r\n        \r\n    \r\n    /** \r\n        * @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\r\n        * @param target Address to be frozen\r\n        * @param freeze either to freeze it or not\r\n        */\r\n    function freezeAccount(address target, bool freeze) onlyOwner public {\r\n        frozenAccount[target] = freeze;\r\n        emit  FrozenAccounts(target, freeze);\r\n    }\r\n    \r\n    /** \r\n        * @notice Create `mintedAmount` tokens and send it to `target`\r\n        * @param target Address to receive the tokens\r\n        * @param mintedAmount the amount of tokens it will receive\r\n        */\r\n    function mintToken(address target, uint256 mintedAmount) onlyOwner public {\r\n        require(_totalSupply.add(mintedAmount) <= maxSupply, \"Cannot Mint more than maximum supply\");\r\n        _balanceOf[target] = _balanceOf[target].add(mintedAmount);\r\n        _totalSupply = _totalSupply.add(mintedAmount);\r\n        emit Transfer(address(0), target, mintedAmount);\r\n    }\r\n\r\n        \r\n\r\n    /**\r\n        * Owner can transfer tokens from contract to owner address\r\n        *\r\n        * When safeguard is true, then all the non-owner functions will stop working.\r\n        * When safeguard is false, then all the functions will resume working back again!\r\n        */\r\n    \r\n    function manualWithdrawTokens(uint256 tokenAmount) public onlyOwner{\r\n        // no need for overflow checking as that will be done in transfer function\r\n        _transfer(address(this), owner, tokenAmount);\r\n    }\r\n    \r\n    //Just in rare case, owner wants to transfer Ether from contract to owner address\r\n    function manualWithdrawEther()onlyOwner public{\r\n        address(owner).transfer(address(this).balance);\r\n    }\r\n    \r\n    /**\r\n        * Change safeguard status on or off\r\n        *\r\n        * When safeguard is true, then all the non-owner functions will stop working.\r\n        * When safeguard is false, then all the functions will resume working back again!\r\n        */\r\n    function changeSafeguardStatus() onlyOwner public{\r\n        if (safeguard == false){\r\n            safeguard = true;\r\n        }\r\n        else{\r\n            safeguard = false;    \r\n        }\r\n    }\r\n    \r\n\r\n    \r\n    /*************************************/\r\n    /*    Section for User Air drop      */\r\n    /*************************************/\r\n    \r\n    /**\r\n     * Run an ACTIVE Air-Drop\r\n     *\r\n     * It requires an array of all the addresses and amount of tokens to distribute\r\n     * It will only process first 150 recipients. That limit is fixed to prevent gas limit\r\n     */\r\n    function airdropACTIVE(address[] memory recipients,uint256[] memory tokenAmount) public returns(bool) {\r\n        uint256 totalAddresses = recipients.length;\r\n        require(totalAddresses <= 150,\"Too many recipients\");\r\n        for(uint i = 0; i < totalAddresses; i++)\r\n        {\r\n          //This will loop through all the recipients and send them the specified tokens\r\n          //Input data validation is unncessary, as that is done by SafeMath and which also saves some gas.\r\n          transfer(recipients[i], tokenAmount[i]);\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    /*************************************/\r\n    /*  Section for User whitelisting    */\r\n    /*************************************/\r\n    bool public whitelistingStatus;\r\n    mapping (address => bool) public whitelisted;\r\n    \r\n    /**\r\n     * Change whitelisting status on or off\r\n     *\r\n     * When whitelisting is true, then crowdsale will only accept investors who are whitelisted.\r\n     */\r\n    function changeWhitelistingStatus() onlyOwner public{\r\n        if (whitelistingStatus == false){\r\n            whitelistingStatus = true;\r\n        }\r\n        else{\r\n            whitelistingStatus = false;    \r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Whitelist any user address - only Owner can do this\r\n     *\r\n     * It will add user address in whitelisted mapping\r\n     */\r\n    function whitelistUser(address userAddress, bool status) onlyOwner public{\r\n        require(whitelistingStatus == true);\r\n        require(userAddress != address(0));\r\n        whitelisted[userAddress] = status;\r\n    }\r\n    \r\n    /**\r\n     * Whitelist Many user address at once - only Owner can do this\r\n     * It will require maximum of 150 addresses to prevent block gas limit max-out and DoS attack\r\n     * It will add user address in whitelisted mapping\r\n     */\r\n    function whitelistManyUsers(address[] memory userAddresses, bool status) onlyOwner public{\r\n        require(whitelistingStatus == true);\r\n        uint256 addressCount = userAddresses.length;\r\n        require(addressCount <= 150,\"Too many addresses\");\r\n        for(uint256 i = 0; i < addressCount; i++){\r\n            whitelisted[userAddresses[i]] = status;\r\n        }\r\n    }\r\n    \r\n    \r\n    /*************************************/\r\n    /*  Section for Buy/Sell of tokens   */\r\n    /*************************************/\r\n    \r\n    uint256 public sellPrice = 100;     // 2 prcision by default for 1:1\r\n    uint256 public buyPrice  = 100;     // 2 precision for this variable. so by default, it will be 1:1 with ETH\r\n    \r\n    /** \r\n     * Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth\r\n     * newSellPrice Price the users can sell to the contract\r\n     * newBuyPrice Price users can buy from the contract\r\n     */\r\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {\r\n        sellPrice = newSellPrice;   //sellPrice is 1 Token = ?? WEI\r\n        buyPrice = newBuyPrice;     //buyPrice is 1 ETH = ?? Tokens\r\n    }\r\n\r\n    /**\r\n     * Buy tokens from contract by sending ether\r\n     * buyPrice is 1 ETH = ?? Tokens\r\n     */\r\n    \r\n    function buyTokens() payable public {\r\n        //checking whitelisting status\r\n        if(whitelistingStatus){\r\n            require(whitelisted[msg.sender], 'User is not whitelisted');\r\n        }\r\n        // calculates the amount. \r\n        // devided by 100, because buyPrice is in 2 precision\r\n        // devided by 1e16 as ether is in 1e18 and token is in 1e2 precision\r\n        uint amount = msg.value * buyPrice / 100 / 1e16;       \r\n        _transfer(address(this), msg.sender, amount);       // makes the transfers\r\n        // did not transfer ether to owner to save gas cost. and owner can always withdraw by calling manualWithdrawEther function\r\n    }\r\n\r\n    /**\r\n     * Sell `amount` tokens to contract\r\n     * amount amount of tokens to be sold\r\n     */\r\n    function sellTokens(uint256 amount) public {\r\n        //checking whitelisting status\r\n        if(whitelistingStatus){\r\n            require(whitelisted[msg.sender], 'User is not whitelisted');\r\n        }\r\n        //calculates ether amount\r\n        uint256 etherAmount = amount * 1e16 * sellPrice/100;\r\n        // transfers token and ether\r\n        _transfer(msg.sender, address(this), amount);       // makes the transfers\r\n        msg.sender.transfer(etherAmount);                   // sends ether to the seller. It's important to do this last to avoid recursion attacks\r\n    }\r\n    \r\n    \r\n    /*===============================\r\n    =     UPGRADE CONTRACT CODE     =\r\n    ===============================*/\r\n    bool internal initialized;\r\n    \r\n    /**\r\n     * @notice This is initialize function would be called only once while contract initialisation\r\n     * @notice It will just set owner address\r\n     */\r\n    function initialize(\r\n        address payable _owner\r\n    ) public {\r\n        \r\n        require(!initialized);\r\n        require(owner == address(0)); //When this methods called, then owner address must be zero\r\n\r\n        owner = _owner;\r\n        //sending all the tokens to Owner\r\n        uint256 initialSupply = 10000000000 * 100;  //10 billion tokens\r\n        _totalSupply = initialSupply;\r\n        _balanceOf[owner] = initialSupply;\r\n        //firing event which logs this transaction\r\n        emit Transfer(address(0), owner, initialSupply);\r\n        initialized = true;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n//********************************************************************************//\r\n//----------------------  MAIN PROXY CONTRACTS SECTION STARTS --------------------//\r\n//********************************************************************************//\r\n\r\n\r\n/****************************************/\r\n/*            Proxy Contract            */\r\n/****************************************/\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n  /**\r\n  * @dev Tells the address of the implementation where every call will be delegated.\r\n  * @return address of the implementation to which it will be delegated\r\n  */\r\n  function implementation() public view returns (address);\r\n\r\n  /**\r\n  * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n  * This function will return whatever the implementation call returns\r\n  */\r\n  function () payable external {\r\n    address _impl = implementation();\r\n    require(_impl != address(0));\r\n\r\n    assembly {\r\n      let ptr := mload(0x40)\r\n      calldatacopy(ptr, 0, calldatasize)\r\n      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\r\n      let size := returndatasize\r\n      returndatacopy(ptr, 0, size)\r\n\r\n      switch result\r\n      case 0 { revert(ptr, size) }\r\n      default { return(ptr, size) }\r\n    }\r\n  }\r\n  \r\n}\r\n\r\n\r\n/****************************************/\r\n/*    UpgradeabilityProxy Contract      */\r\n/****************************************/\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\r\n */\r\ncontract UpgradeabilityProxy is Proxy {\r\n  /**\r\n   * @dev This event will be emitted every time the implementation gets upgraded\r\n   * @param implementation representing the address of the upgraded implementation\r\n   */\r\n  event Upgraded(address indexed implementation);\r\n\r\n  // Storage position of the address of the current implementation\r\n  bytes32 private constant implementationPosition = keccak256(\"org.zeppelinos.proxy.implementation\");\r\n\r\n  /**\r\n   * @dev Constructor function\r\n   */\r\n  constructor () public {}\r\n\r\n  /**\r\n   * @dev Tells the address of the current implementation\r\n   * @return address of the current implementation\r\n   */\r\n  function implementation() public view returns (address impl) {\r\n    bytes32 position = implementationPosition;\r\n    assembly {\r\n      impl := sload(position)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the address of the current implementation\r\n   * @param newImplementation address representing the new implementation to be set\r\n   */\r\n  function setImplementation(address newImplementation) internal {\r\n    bytes32 position = implementationPosition;\r\n    assembly {\r\n      sstore(position, newImplementation)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrades the implementation address\r\n   * @param newImplementation representing the address of the new implementation to be set\r\n   */\r\n  function _upgradeTo(address newImplementation) internal {\r\n    address currentImplementation = implementation();\r\n    require(currentImplementation != newImplementation);\r\n    setImplementation(newImplementation);\r\n    emit Upgraded(newImplementation);\r\n  }\r\n}\r\n\r\n/****************************************/\r\n/*  OwnedUpgradeabilityProxy contract   */\r\n/****************************************/\r\n/**\r\n * @title OwnedUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\r\n */\r\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\r\n  /**\r\n  * @dev Event to show ownership has been transferred\r\n  * @param previousOwner representing the address of the previous owner\r\n  * @param newOwner representing the address of the new owner\r\n  */\r\n  event ProxyOwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n  // Storage position of the owner of the contract\r\n  bytes32 private constant proxyOwnerPosition = keccak256(\"org.zeppelinos.proxy.owner\");\r\n\r\n  /**\r\n  * @dev the constructor sets the original owner of the contract to the sender account.\r\n  */\r\n  constructor () public {\r\n    setUpgradeabilityOwner(msg.sender);\r\n  }\r\n\r\n  /**\r\n  * @dev Throws if called by any account other than the owner.\r\n  */\r\n  modifier onlyProxyOwner() {\r\n    require(msg.sender == proxyOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Tells the address of the owner\r\n   * @return the address of the owner\r\n   */\r\n  function proxyOwner() public view returns (address owner) {\r\n    bytes32 position = proxyOwnerPosition;\r\n    assembly {\r\n      owner := sload(position)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the address of the owner\r\n   */\r\n  function setUpgradeabilityOwner(address newProxyOwner) internal {\r\n    bytes32 position = proxyOwnerPosition;\r\n    assembly {\r\n      sstore(position, newProxyOwner)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferProxyOwnership(address newOwner) public onlyProxyOwner {\r\n    require(newOwner != address(0));\r\n    emit ProxyOwnershipTransferred(proxyOwner(), newOwner);\r\n    setUpgradeabilityOwner(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the proxy owner to upgrade the current version of the proxy.\r\n   * @param implementation representing the address of the new implementation to be set.\r\n   */\r\n  function upgradeTo(address implementation) public onlyProxyOwner {\r\n    _upgradeTo(implementation);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the proxy owner to upgrade the current version of the proxy and call the new implementation\r\n   * to initialize whatever is needed through a low level call.\r\n   * @param implementation representing the address of the new implementation to be set.\r\n   * @param data represents the msg.data to bet sent in the low level call. This parameter may include the function\r\n   * signature of the implementation to be called with the needed payload\r\n   */\r\n  function upgradeToAndCall(address implementation, bytes memory data) payable public onlyProxyOwner {\r\n    _upgradeTo(implementation);\r\n    (bool success,) = address(this).call.value(msg.value).gas(200000)(data);\r\n    require(success);\r\n  }\r\n}\r\n\r\n\r\n/****************************************/\r\n/*        MAIN PROXY Contract         */\r\n/****************************************/\r\n\r\n/**\r\n * @title CENTI_proxy\r\n * @dev This contract proxies token contract calls and enables token contract upgrades\r\n*/ \r\ncontract CENTI_proxy is OwnedUpgradeabilityProxy {\r\n    constructor() public OwnedUpgradeabilityProxy() {\r\n    }\r\n    function returnInitialiseData(address payable owner ) public pure returns(bytes memory){\r\n        \r\n    return abi.encodeWithSignature(\"initialize(address)\",owner);\r\n      \r\n}\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenAccounts\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenAmount\",\"type\":\"uint256[]\"}],\"name\":\"airdropACTIVE\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changeSafeguardStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changeWhitelistingStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"decrease_allowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"increase_allowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"manualWithdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"manualWithdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mintedAmount\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"safeguard\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sellTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newSellPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newBuyPrice\",\"type\":\"uint256\"}],\"name\":\"setPrices\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"userAddresses\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"whitelistManyUsers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"whitelistUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistingStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CENTI","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://638e83df5d0cb4a82213f79c73ccb976df3efa37cddefebe30adc09cef196588"}]}