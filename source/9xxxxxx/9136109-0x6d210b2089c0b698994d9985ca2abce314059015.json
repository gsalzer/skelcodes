{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\n\n\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n\n    \n    function balanceOf(address account) external view returns (uint256);\n\n    \n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        \n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        \n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary Address {\n    \n    function isContract(address account) internal view returns (bool) {\n        \n        \n        \n\n        \n        \n        \n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        \n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n\n    \n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        \n        \n        \n        \n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    \n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        \n        \n\n        \n        \n        \n        \n        \n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        \n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { \n            \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\nlibrary Math {\n    \n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    \n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    \n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\ncontract EpochTokenLocker {\n    using SafeMath for uint256;\n\n    \n    uint32 public constant BATCH_TIME = 300;\n\n    \n    mapping(address => mapping(address => BalanceState)) private balanceStates;\n\n    \n    mapping(address => mapping(address => uint32)) public lastCreditBatchId;\n\n    struct BalanceState {\n        uint256 balance;\n        PendingFlux pendingDeposits; \n        PendingFlux pendingWithdraws; \n    }\n\n    struct PendingFlux {\n        uint256 amount;\n        uint32 batchId;\n    }\n\n    event Deposit(address indexed user, address indexed token, uint256 amount, uint32 batchId);\n\n    event WithdrawRequest(address indexed user, address indexed token, uint256 amount, uint32 batchId);\n\n    event Withdraw(address indexed user, address indexed token, uint256 amount);\n\n    \n    function deposit(address token, uint256 amount) public {\n        updateDepositsBalance(msg.sender, token);\n        SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), amount);\n        \n        balanceStates[msg.sender][token].pendingDeposits.amount = balanceStates[msg.sender][token].pendingDeposits.amount.add(\n            amount\n        );\n        balanceStates[msg.sender][token].pendingDeposits.batchId = getCurrentBatchId();\n        emit Deposit(msg.sender, token, amount, getCurrentBatchId());\n    }\n\n    \n    function requestWithdraw(address token, uint256 amount) public {\n        requestFutureWithdraw(token, amount, getCurrentBatchId());\n    }\n\n    \n    function requestFutureWithdraw(address token, uint256 amount, uint32 batchId) public {\n        \n        if (hasValidWithdrawRequest(msg.sender, token)) {\n            withdraw(msg.sender, token);\n        }\n        require(batchId >= getCurrentBatchId(), \"Request cannot be made in the past\");\n        balanceStates[msg.sender][token].pendingWithdraws = PendingFlux({amount: amount, batchId: batchId});\n        emit WithdrawRequest(msg.sender, token, amount, batchId);\n    }\n\n    \n    function withdraw(address user, address token) public {\n        updateDepositsBalance(user, token); \n        require(\n            balanceStates[user][token].pendingWithdraws.batchId < getCurrentBatchId(),\n            \"withdraw was not registered previously\"\n        );\n        require(\n            lastCreditBatchId[user][token] < getCurrentBatchId(),\n            \"Withdraw not possible for token that is traded in the current auction\"\n        );\n        uint256 amount = Math.min(balanceStates[user][token].balance, balanceStates[user][token].pendingWithdraws.amount);\n\n        balanceStates[user][token].balance = balanceStates[user][token].balance.sub(amount);\n        delete balanceStates[user][token].pendingWithdraws;\n\n        SafeERC20.safeTransfer(IERC20(token), user, amount);\n        emit Withdraw(user, token, amount);\n    }\n    \n\n    \n    function getPendingDeposit(address user, address token) public view returns (uint256, uint32) {\n        PendingFlux memory pendingDeposit = balanceStates[user][token].pendingDeposits;\n        return (pendingDeposit.amount, pendingDeposit.batchId);\n    }\n\n    \n    function getPendingWithdraw(address user, address token) public view returns (uint256, uint32) {\n        PendingFlux memory pendingWithdraw = balanceStates[user][token].pendingWithdraws;\n        return (pendingWithdraw.amount, pendingWithdraw.batchId);\n    }\n\n    \n    function getCurrentBatchId() public view returns (uint32) {\n        \n        return uint32(now / BATCH_TIME);\n    }\n\n    \n    function getSecondsRemainingInBatch() public view returns (uint256) {\n        \n        return BATCH_TIME - (now % BATCH_TIME);\n    }\n\n    \n    function getBalance(address user, address token) public view returns (uint256) {\n        uint256 balance = balanceStates[user][token].balance;\n        if (balanceStates[user][token].pendingDeposits.batchId < getCurrentBatchId()) {\n            balance = balance.add(balanceStates[user][token].pendingDeposits.amount);\n        }\n        if (balanceStates[user][token].pendingWithdraws.batchId < getCurrentBatchId()) {\n            balance = balance.sub(Math.min(balanceStates[user][token].pendingWithdraws.amount, balance));\n        }\n        return balance;\n    }\n\n    \n    function hasValidWithdrawRequest(address user, address token) public view returns (bool) {\n        return\n            balanceStates[user][token].pendingWithdraws.batchId < getCurrentBatchId() &&\n            balanceStates[user][token].pendingWithdraws.batchId > 0;\n    }\n\n    \n    \n    function addBalanceAndBlockWithdrawForThisBatch(address user, address token, uint256 amount) internal {\n        if (hasValidWithdrawRequest(user, token)) {\n            lastCreditBatchId[user][token] = getCurrentBatchId();\n        }\n        addBalance(user, token, amount);\n    }\n\n    function addBalance(address user, address token, uint256 amount) internal {\n        updateDepositsBalance(user, token);\n        balanceStates[user][token].balance = balanceStates[user][token].balance.add(amount);\n    }\n\n    function subtractBalance(address user, address token, uint256 amount) internal {\n        updateDepositsBalance(user, token);\n        balanceStates[user][token].balance = balanceStates[user][token].balance.sub(amount);\n    }\n\n    function updateDepositsBalance(address user, address token) private {\n        if (balanceStates[user][token].pendingDeposits.batchId < getCurrentBatchId()) {\n            balanceStates[user][token].balance = balanceStates[user][token].balance.add(\n                balanceStates[user][token].pendingDeposits.amount\n            );\n            delete balanceStates[user][token].pendingDeposits;\n        }\n    }\n}\n\nlibrary IdToAddressBiMap {\n    struct Data {\n        mapping(uint16 => address) idToAddress;\n        mapping(address => uint16) addressToId;\n    }\n\n    function hasId(Data storage self, uint16 id) public view returns (bool) {\n        return self.idToAddress[id + 1] != address(0);\n    }\n\n    function hasAddress(Data storage self, address addr) public view returns (bool) {\n        return self.addressToId[addr] != 0;\n    }\n\n    function getAddressAt(Data storage self, uint16 id) public view returns (address) {\n        require(hasId(self, id), \"Must have ID to get Address\");\n        return self.idToAddress[id + 1];\n    }\n\n    function getId(Data storage self, address addr) public view returns (uint16) {\n        require(hasAddress(self, addr), \"Must have Address to get ID\");\n        return self.addressToId[addr] - 1;\n    }\n\n    function insert(Data storage self, uint16 id, address addr) public returns (bool) {\n        \n        if (self.addressToId[addr] != 0 || self.idToAddress[id + 1] != address(0)) {\n            return false;\n        }\n        self.idToAddress[id + 1] = addr;\n        self.addressToId[addr] = id + 1;\n        return true;\n    }\n\n}\n\nlibrary IterableAppendOnlySet {\n    struct Data {\n        mapping(address => address) nextMap;\n        address last;\n    }\n\n    function insert(Data storage self, address value) public returns (bool) {\n        if (contains(self, value)) {\n            return false;\n        }\n        self.nextMap[self.last] = value;\n        self.last = value;\n        return true;\n    }\n\n    function contains(Data storage self, address value) public view returns (bool) {\n        require(value != address(0), \"Inserting address(0) is not supported\");\n        return self.nextMap[value] != address(0) || (self.last == value);\n    }\n\n    function first(Data storage self) public view returns (address) {\n        require(self.last != address(0), \"Trying to get first from empty set\");\n        return self.nextMap[address(0)];\n    }\n\n    function next(Data storage self, address value) public view returns (address) {\n        require(contains(self, value), \"Trying to get next of non-existent element\");\n        require(value != self.last, \"Trying to get next of last element\");\n        return self.nextMap[value];\n    }\n\n    function size(Data storage self) public view returns (uint256) {\n        if (self.last == address(0)) {\n            return 0;\n        }\n        uint256 count = 1;\n        address current = first(self);\n        while (current != self.last) {\n            current = next(self, current);\n            count++;\n        }\n        return count;\n    }\n}\n\nlibrary GnosisMath {\n    \n    \n    uint public constant ONE = 0x10000000000000000;\n    uint public constant LN2 = 0xb17217f7d1cf79ac;\n    uint public constant LOG2_E = 0x171547652b82fe177;\n\n    \n    \n    \n    \n    function exp(int x) public pure returns (uint) {\n        \n        \n        require(x <= 2454971259878909886679);\n        \n        \n        if (x < -818323753292969962227) return 0;\n        \n        x = x * int(ONE) / int(LN2);\n        \n        \n        \n        int shift;\n        uint z;\n        if (x >= 0) {\n            shift = x / int(ONE);\n            z = uint(x % int(ONE));\n        } else {\n            shift = x / int(ONE) - 1;\n            z = ONE - uint(-x % int(ONE));\n        }\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        uint zpow = z;\n        uint result = ONE;\n        result += 0xb17217f7d1cf79ab * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x3d7f7bff058b1d50 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0xe35846b82505fc5 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x276556df749cee5 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x5761ff9e299cc4 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0xa184897c363c3 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0xffe5fe2c4586 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x162c0223a5c8 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x1b5253d395e * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x1e4cf5158b * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x1e8cac735 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x1c3bd650 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x1816193 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x131496 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0xe1b7 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x9c7 * zpow / ONE;\n        if (shift >= 0) {\n            if (result >> (256 - shift) > 0) return (2 ** 256 - 1);\n            return result << shift;\n        } else return result >> (-shift);\n    }\n\n    \n    \n    \n    function ln(uint x) public pure returns (int) {\n        require(x > 0);\n        \n        int ilog2 = floorLog2(x);\n        int z;\n        if (ilog2 < 0) z = int(x << uint(-ilog2));\n        else z = int(x >> uint(ilog2));\n        \n        \n        \n        \n        \n        int term = (z - int(ONE)) * int(ONE) / (z + int(ONE));\n        int halflnz = term;\n        int termpow = term * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 3;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 5;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 7;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 9;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 11;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 13;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 15;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 17;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 19;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 21;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 23;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 25;\n        return (ilog2 * int(ONE)) * int(ONE) / int(LOG2_E) + 2 * halflnz;\n    }\n\n    \n    \n    \n    function floorLog2(uint x) public pure returns (int lo) {\n        lo = -64;\n        int hi = 193;\n        \n        int mid = (hi + lo) >> 1;\n        while ((lo + 1) < hi) {\n            if (mid < 0 && x << uint(-mid) < ONE || mid >= 0 && x >> uint(mid) < ONE) hi = mid;\n            else lo = mid;\n            mid = (hi + lo) >> 1;\n        }\n    }\n\n    \n    \n    \n    function max(int[] memory nums) public pure returns (int maxNum) {\n        require(nums.length > 0);\n        maxNum = -2 ** 255;\n        for (uint i = 0; i < nums.length; i++) if (nums[i] > maxNum) maxNum = nums[i];\n    }\n\n    \n    \n    \n    \n    function safeToAdd(uint a, uint b) internal pure returns (bool) {\n        return a + b >= a;\n    }\n\n    \n    \n    \n    \n    function safeToSub(uint a, uint b) internal pure returns (bool) {\n        return a >= b;\n    }\n\n    \n    \n    \n    \n    function safeToMul(uint a, uint b) internal pure returns (bool) {\n        return b == 0 || a * b / b == a;\n    }\n\n    \n    \n    \n    \n    function add(uint a, uint b) internal pure returns (uint) {\n        require(safeToAdd(a, b));\n        return a + b;\n    }\n\n    \n    \n    \n    \n    function sub(uint a, uint b) internal pure returns (uint) {\n        require(safeToSub(a, b));\n        return a - b;\n    }\n\n    \n    \n    \n    \n    function mul(uint a, uint b) internal pure returns (uint) {\n        require(safeToMul(a, b));\n        return a * b;\n    }\n\n    \n    \n    \n    \n    function safeToAdd(int a, int b) internal pure returns (bool) {\n        return (b >= 0 && a + b >= a) || (b < 0 && a + b < a);\n    }\n\n    \n    \n    \n    \n    function safeToSub(int a, int b) internal pure returns (bool) {\n        return (b >= 0 && a - b <= a) || (b < 0 && a - b > a);\n    }\n\n    \n    \n    \n    \n    function safeToMul(int a, int b) internal pure returns (bool) {\n        return (b == 0) || (a * b / b == a);\n    }\n\n    \n    \n    \n    \n    function add(int a, int b) internal pure returns (int) {\n        require(safeToAdd(a, b));\n        return a + b;\n    }\n\n    \n    \n    \n    \n    function sub(int a, int b) internal pure returns (int) {\n        require(safeToSub(a, b));\n        return a - b;\n    }\n\n    \n    \n    \n    \n    function mul(int a, int b) internal pure returns (int) {\n        require(safeToMul(a, b));\n        return a * b;\n    }\n}\n\ncontract Token {\n    \n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n\n    \n    function transfer(address to, uint value) public returns (bool);\n    function transferFrom(address from, address to, uint value) public returns (bool);\n    function approve(address spender, uint value) public returns (bool);\n    function balanceOf(address owner) public view returns (uint);\n    function allowance(address owner, address spender) public view returns (uint);\n    function totalSupply() public view returns (uint);\n}\n\ncontract Proxied {\n    address public masterCopy;\n}\n\ncontract Proxy is Proxied {\n    \n    \n    constructor(address _masterCopy) public {\n        require(_masterCopy != address(0), \"The master copy is required\");\n        masterCopy = _masterCopy;\n    }\n\n    \n    function() external payable {\n        address _masterCopy = masterCopy;\n        assembly {\n            calldatacopy(0, 0, calldatasize)\n            let success := delegatecall(not(0), _masterCopy, 0, calldatasize, 0, 0)\n            returndatacopy(0, 0, returndatasize)\n            switch success\n                case 0 {\n                    revert(0, returndatasize)\n                }\n                default {\n                    return(0, returndatasize)\n                }\n        }\n    }\n}\n\ncontract StandardTokenData {\n    \n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowances;\n    uint totalTokens;\n}\n\ncontract GnosisStandardToken is Token, StandardTokenData {\n    using GnosisMath for *;\n\n    \n    \n    \n    \n    \n    function transfer(address to, uint value) public returns (bool) {\n        if (!balances[msg.sender].safeToSub(value) || !balances[to].safeToAdd(value)) {\n            return false;\n        }\n\n        balances[msg.sender] -= value;\n        balances[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function transferFrom(address from, address to, uint value) public returns (bool) {\n        if (!balances[from].safeToSub(value) || !allowances[from][msg.sender].safeToSub(\n            value\n        ) || !balances[to].safeToAdd(value)) {\n            return false;\n        }\n        balances[from] -= value;\n        allowances[from][msg.sender] -= value;\n        balances[to] += value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    \n    \n    \n    \n    function approve(address spender, uint value) public returns (bool) {\n        allowances[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    \n    \n    \n    \n    function allowance(address owner, address spender) public view returns (uint) {\n        return allowances[owner][spender];\n    }\n\n    \n    \n    \n    function balanceOf(address owner) public view returns (uint) {\n        return balances[owner];\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalTokens;\n    }\n}\n\ncontract TokenOWL is Proxied, GnosisStandardToken {\n    using GnosisMath for *;\n\n    string public constant name = \"OWL Token\";\n    string public constant symbol = \"OWL\";\n    uint8 public constant decimals = 18;\n\n    struct masterCopyCountdownType {\n        address masterCopy;\n        uint timeWhenAvailable;\n    }\n\n    masterCopyCountdownType masterCopyCountdown;\n\n    address public creator;\n    address public minter;\n\n    event Minted(address indexed to, uint256 amount);\n    event Burnt(address indexed from, address indexed user, uint256 amount);\n\n    modifier onlyCreator() {\n        \n        require(msg.sender == creator, \"Only the creator can perform the transaction\");\n        _;\n    }\n    \n    \n    function startMasterCopyCountdown(address _masterCopy) public onlyCreator {\n        require(address(_masterCopy) != address(0), \"The master copy must be a valid address\");\n\n        \n        masterCopyCountdown.masterCopy = _masterCopy;\n        masterCopyCountdown.timeWhenAvailable = now + 30 days;\n    }\n\n    \n    function updateMasterCopy() public onlyCreator {\n        require(address(masterCopyCountdown.masterCopy) != address(0), \"The master copy must be a valid address\");\n        require(\n            block.timestamp >= masterCopyCountdown.timeWhenAvailable,\n            \"It's not possible to update the master copy during the waiting period\"\n        );\n\n        \n        masterCopy = masterCopyCountdown.masterCopy;\n    }\n\n    function getMasterCopy() public view returns (address) {\n        return masterCopy;\n    }\n\n    \n    \n    function setMinter(address newMinter) public onlyCreator {\n        minter = newMinter;\n    }\n\n    \n    \n    function setNewOwner(address newOwner) public onlyCreator {\n        creator = newOwner;\n    }\n\n    \n    \n    \n    function mintOWL(address to, uint amount) public {\n        require(minter != address(0), \"The minter must be initialized\");\n        require(msg.sender == minter, \"Only the minter can mint OWL\");\n        balances[to] = balances[to].add(amount);\n        totalTokens = totalTokens.add(amount);\n        emit Minted(to, amount);\n        emit Transfer(address(0), to, amount);\n    }\n\n    \n    \n    \n    function burnOWL(address user, uint amount) public {\n        allowances[user][msg.sender] = allowances[user][msg.sender].sub(amount);\n        balances[user] = balances[user].sub(amount);\n        totalTokens = totalTokens.sub(amount);\n        emit Burnt(msg.sender, user, amount);\n        emit Transfer(user, address(0), amount);\n    }\n\n    function getMasterCopyCountdown() public view returns (address, uint) {\n        return (masterCopyCountdown.masterCopy, masterCopyCountdown.timeWhenAvailable);\n    }\n}\n\nlibrary SafeCast {\n\n    \n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return uint128(value);\n    }\n\n    \n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return uint64(value);\n    }\n\n    \n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return uint32(value);\n    }\n\n    \n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return uint16(value);\n    }\n\n    \n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return uint8(value);\n    }\n}\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            \n            \n            tempBytes := mload(0x40)\n\n            \n            \n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            \n            \n            \n            let mc := add(tempBytes, 0x20)\n            \n            \n            let end := add(mc, length)\n\n            for {\n                \n                \n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                \n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                \n                \n                mstore(mc, mload(cc))\n            }\n\n            \n            \n            \n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            \n            \n            mc := end\n            \n            \n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            \n            \n            \n            \n            \n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) \n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            \n            \n            \n            let fslot := sload(_preBytes_slot)\n            \n            \n            \n            \n            \n            \n            \n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            \n            \n            \n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                \n                \n                \n                sstore(\n                    _preBytes_slot,\n                    \n                    \n                    add(\n                        \n                        \n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    \n                                    mload(add(_postBytes, 0x20)),\n                                    \n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                \n                                \n                                exp(0x100, sub(32, newlength))\n                            ),\n                            \n                            \n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                \n                \n                \n                mstore(0x0, _preBytes_slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                \n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                \n                \n                \n                \n                \n                \n                \n                \n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                \n                mstore(0x0, _preBytes_slot)\n                \n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                \n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                \n                \n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n                \n                for { \n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint _start,\n        uint _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_bytes.length >= (_start + _length));\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                \n                \n                tempBytes := mload(0x40)\n\n                \n                \n                \n                \n                \n                \n                \n                \n                let lengthmod := and(_length, 31)\n\n                \n                \n                \n                \n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    \n                    \n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                \n                \n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            \n            default {\n                tempBytes := mload(0x40)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\n        require(_bytes.length >= (_start + 20));\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\n        require(_bytes.length >= (_start + 1));\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\n        require(_bytes.length >= (_start + 2));\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\n        require(_bytes.length >= (_start + 4));\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\n        require(_bytes.length >= (_start + 8));\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\n        require(_bytes.length >= (_start + 12));\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\n        require(_bytes.length >= (_start + 16));\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\n        require(_bytes.length >= (_start + 32));\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\n        require(_bytes.length >= (_start + 32));\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            \n            switch eq(length, mload(_postBytes))\n            case 1 {\n                \n                \n                \n                \n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                \n                \n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    \n                    if iszero(eq(mload(mc), mload(cc))) {\n                        \n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                \n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            \n            let fslot := sload(_preBytes_slot)\n            \n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            \n            switch eq(slength, mlength)\n            case 1 {\n                \n                \n                \n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        \n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            \n                            success := 0\n                        }\n                    }\n                    default {\n                        \n                        \n                        \n                        \n                        let cb := 1\n\n                        \n                        mstore(0x0, _preBytes_slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        \n                        \n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                \n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                \n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n\nlibrary SignedSafeMath {\n    int256 constant private INT256_MIN = -2**255;\n\n    \n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    \n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    \n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n\nlibrary TokenConservation {\n    using SignedSafeMath for int256;\n\n    \n    function init(uint16[] memory tokenIdsForPrice) internal pure returns (int256[] memory) {\n        return new int256[](tokenIdsForPrice.length + 1);\n    }\n\n    \n    function feeTokenImbalance(int256[] memory self) internal pure returns (int256) {\n        return self[0];\n    }\n\n    \n    function updateTokenConservation(\n        int256[] memory self,\n        uint16 buyToken,\n        uint16 sellToken,\n        uint16[] memory tokenIdsForPrice,\n        uint128 buyAmount,\n        uint128 sellAmount\n    ) internal pure {\n        uint256 buyTokenIndex = findPriceIndex(buyToken, tokenIdsForPrice);\n        uint256 sellTokenIndex = findPriceIndex(sellToken, tokenIdsForPrice);\n        self[buyTokenIndex] = self[buyTokenIndex].sub(int256(buyAmount));\n        self[sellTokenIndex] = self[sellTokenIndex].add(int256(sellAmount));\n    }\n\n    \n    function checkTokenConservation(int256[] memory self) internal pure {\n        require(self[0] > 0, \"Token conservation at 0 must be positive.\");\n        for (uint256 i = 1; i < self.length; i++) {\n            require(self[i] == 0, \"Token conservation does not hold\");\n        }\n    }\n\n    \n    function checkPriceOrdering(uint16[] memory tokenIdsForPrice) internal pure returns (bool) {\n        for (uint256 i = 1; i < tokenIdsForPrice.length; i++) {\n            if (tokenIdsForPrice[i] <= tokenIdsForPrice[i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    function findPriceIndex(uint16 tokenId, uint16[] memory tokenIdsForPrice) private pure returns (uint256) {\n        \n        if (tokenId == 0) {\n            return 0;\n        }\n        \n        uint256 leftValue = 0;\n        uint256 rightValue = tokenIdsForPrice.length - 1;\n        while (rightValue >= leftValue) {\n            uint256 middleValue = (leftValue + rightValue) / 2;\n            if (tokenIdsForPrice[middleValue] == tokenId) {\n                \n                return middleValue + 1;\n            } else if (tokenIdsForPrice[middleValue] < tokenId) {\n                leftValue = middleValue + 1;\n            } else {\n                rightValue = middleValue - 1;\n            }\n        }\n        revert(\"Price not provided for token\");\n    }\n}\n\ncontract BatchExchange is EpochTokenLocker {\n    using SafeCast for uint256;\n    using SafeMath for uint128;\n    using BytesLib for bytes32;\n    using BytesLib for bytes;\n    using TokenConservation for int256[];\n    using TokenConservation for uint16[];\n    using IterableAppendOnlySet for IterableAppendOnlySet.Data;\n\n    \n    uint256 public constant MAX_TOUCHED_ORDERS = 25;\n\n    \n    uint256 public constant FEE_FOR_LISTING_TOKEN_IN_OWL = 10 ether;\n\n    \n    uint256 public constant AMOUNT_MINIMUM = 10**4;\n\n    \n    uint256 public constant IMPROVEMENT_DENOMINATOR = 100; \n\n    \n    uint128 public constant FEE_DENOMINATOR = 1000;\n\n    \n    \n    uint256 public MAX_TOKENS;\n\n    \n    uint16 public numTokens;\n\n    \n    TokenOWL public feeToken;\n\n    \n    mapping(address => Order[]) public orders;\n\n    \n    mapping(uint16 => uint128) public currentPrices;\n\n    \n    SolutionData public latestSolution;\n\n    \n    IterableAppendOnlySet.Data private allUsers;\n    IdToAddressBiMap.Data private registeredTokens;\n\n    struct Order {\n        uint16 buyToken;\n        uint16 sellToken;\n        uint32 validFrom; \n        uint32 validUntil; \n        uint128 priceNumerator;\n        uint128 priceDenominator;\n        uint128 usedAmount; \n    }\n\n    struct TradeData {\n        address owner;\n        uint128 volume;\n        uint16 orderId;\n    }\n\n    struct SolutionData {\n        uint32 batchId;\n        TradeData[] trades;\n        uint16[] tokenIdsForPrice;\n        address solutionSubmitter;\n        uint256 feeReward;\n        uint256 objectiveValue;\n    }\n\n    event OrderPlacement(\n        address indexed owner,\n        uint16 index,\n        uint16 indexed buyToken,\n        uint16 indexed sellToken,\n        uint32 validFrom,\n        uint32 validUntil,\n        uint128 priceNumerator,\n        uint128 priceDenominator\n    );\n\n    \n    event OrderCancelation(address indexed owner, uint256 id);\n\n    \n    event OrderDeletion(address indexed owner, uint256 id);\n\n    \n    event Trade(address indexed owner, uint16 indexed orderId, uint256 executedSellAmount, uint256 executedBuyAmount);\n\n    \n    event TradeReversion(address indexed owner, uint16 indexed orderId, uint256 executedSellAmount, uint256 executedBuyAmount);\n\n    \n    constructor(uint256 maxTokens, address _feeToken) public {\n        \n        \n        currentPrices[0] = 1 ether;\n        MAX_TOKENS = maxTokens;\n        feeToken = TokenOWL(_feeToken);\n        \n        \n        feeToken.approve(address(this), uint256(-1));\n        addToken(_feeToken); \n    }\n\n    \n    function addToken(address token) public {\n        require(numTokens < MAX_TOKENS, \"Max tokens reached\");\n        if (numTokens > 0) {\n            \n            feeToken.burnOWL(msg.sender, FEE_FOR_LISTING_TOKEN_IN_OWL);\n        }\n        require(IdToAddressBiMap.insert(registeredTokens, numTokens, token), \"Token already registered\");\n        numTokens++;\n    }\n\n    \n    function placeOrder(uint16 buyToken, uint16 sellToken, uint32 validUntil, uint128 buyAmount, uint128 sellAmount)\n        public\n        returns (uint256)\n    {\n        return placeOrderInternal(buyToken, sellToken, getCurrentBatchId(), validUntil, buyAmount, sellAmount);\n    }\n\n    \n    function placeValidFromOrders(\n        uint16[] memory buyTokens,\n        uint16[] memory sellTokens,\n        uint32[] memory validFroms,\n        uint32[] memory validUntils,\n        uint128[] memory buyAmounts,\n        uint128[] memory sellAmounts\n    ) public returns (uint16[] memory orderIds) {\n        orderIds = new uint16[](buyTokens.length);\n        for (uint256 i = 0; i < buyTokens.length; i++) {\n            orderIds[i] = placeOrderInternal(\n                buyTokens[i],\n                sellTokens[i],\n                validFroms[i],\n                validUntils[i],\n                buyAmounts[i],\n                sellAmounts[i]\n            );\n        }\n    }\n\n    \n    function cancelOrders(uint16[] memory orderIds) public {\n        uint32 batchIdBeingSolved = getCurrentBatchId() - 1;\n        for (uint16 i = 0; i < orderIds.length; i++) {\n            if (!checkOrderValidity(orders[msg.sender][orderIds[i]], batchIdBeingSolved)) {\n                delete orders[msg.sender][orderIds[i]];\n                emit OrderDeletion(msg.sender, orderIds[i]);\n            } else {\n                orders[msg.sender][orderIds[i]].validUntil = batchIdBeingSolved;\n                emit OrderCancelation(msg.sender, orderIds[i]);\n            }\n        }\n    }\n\n    \n    function replaceOrders(\n        uint16[] memory cancellations,\n        uint16[] memory buyTokens,\n        uint16[] memory sellTokens,\n        uint32[] memory validFroms,\n        uint32[] memory validUntils,\n        uint128[] memory buyAmounts,\n        uint128[] memory sellAmounts\n    ) public returns (uint16[] memory) {\n        cancelOrders(cancellations);\n        return placeValidFromOrders(buyTokens, sellTokens, validFroms, validUntils, buyAmounts, sellAmounts);\n    }\n\n    \n    function submitSolution(\n        uint32 batchId,\n        uint256 claimedObjectiveValue,\n        address[] memory owners,\n        uint16[] memory orderIds,\n        uint128[] memory buyVolumes,\n        uint128[] memory prices,\n        uint16[] memory tokenIdsForPrice\n    ) public returns (uint256) {\n        require(acceptingSolutions(batchId), \"Solutions are no longer accepted for this batch\");\n        require(\n            isObjectiveValueSufficientlyImproved(claimedObjectiveValue),\n            \"Claimed objective doesn't sufficiently improve current solution\"\n        );\n        require(verifyAmountThreshold(prices), \"At least one price lower than AMOUNT_MINIMUM\");\n        require(tokenIdsForPrice[0] != 0, \"Fee token has fixed price!\");\n        require(tokenIdsForPrice.checkPriceOrdering(), \"prices are not ordered by tokenId\");\n        require(owners.length <= MAX_TOUCHED_ORDERS, \"Solution exceeds MAX_TOUCHED_ORDERS\");\n        \n        \n        \n        \n        burnPreviousAuctionFees();\n        undoCurrentSolution();\n        updateCurrentPrices(prices, tokenIdsForPrice);\n        delete latestSolution.trades;\n        int256[] memory tokenConservation = TokenConservation.init(tokenIdsForPrice);\n        uint256 utility = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            Order memory order = orders[owners[i]][orderIds[i]];\n            require(checkOrderValidity(order, batchId), \"Order is invalid\");\n            (uint128 executedBuyAmount, uint128 executedSellAmount) = getTradedAmounts(buyVolumes[i], order);\n            require(executedBuyAmount >= AMOUNT_MINIMUM, \"buy amount less than AMOUNT_MINIMUM\");\n            require(executedSellAmount >= AMOUNT_MINIMUM, \"sell amount less than AMOUNT_MINIMUM\");\n            tokenConservation.updateTokenConservation(\n                order.buyToken,\n                order.sellToken,\n                tokenIdsForPrice,\n                executedBuyAmount,\n                executedSellAmount\n            );\n            require(getRemainingAmount(order) >= executedSellAmount, \"executedSellAmount bigger than specified in order\");\n            \n            \n            require(\n                executedSellAmount.mul(order.priceNumerator) <= executedBuyAmount.mul(order.priceDenominator),\n                \"limit price not satisfied\"\n            );\n            \n            utility = utility.add(evaluateUtility(executedBuyAmount, order));\n            updateRemainingOrder(owners[i], orderIds[i], executedSellAmount);\n            addBalanceAndBlockWithdrawForThisBatch(owners[i], tokenIdToAddressMap(order.buyToken), executedBuyAmount);\n            emit Trade(owners[i], orderIds[i], executedSellAmount, executedBuyAmount);\n        }\n        \n        for (uint256 i = 0; i < owners.length; i++) {\n            Order memory order = orders[owners[i]][orderIds[i]];\n            (, uint128 executedSellAmount) = getTradedAmounts(buyVolumes[i], order);\n            subtractBalance(owners[i], tokenIdToAddressMap(order.sellToken), executedSellAmount);\n        }\n        uint256 disregardedUtility = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            disregardedUtility = disregardedUtility.add(evaluateDisregardedUtility(orders[owners[i]][orderIds[i]], owners[i]));\n        }\n        uint256 burntFees = uint256(tokenConservation.feeTokenImbalance()) / 2;\n        \n        uint256 objectiveValue = utility.add(burntFees).sub(disregardedUtility);\n        checkAndOverrideObjectiveValue(objectiveValue);\n        grantRewardToSolutionSubmitter(burntFees);\n        tokenConservation.checkTokenConservation();\n        documentTrades(batchId, owners, orderIds, buyVolumes, tokenIdsForPrice);\n        return (objectiveValue);\n    }\n    \n\n    \n    function tokenAddressToIdMap(address addr) public view returns (uint16) {\n        return IdToAddressBiMap.getId(registeredTokens, addr);\n    }\n\n    \n    function tokenIdToAddressMap(uint16 id) public view returns (address) {\n        return IdToAddressBiMap.getAddressAt(registeredTokens, id);\n    }\n\n    \n    function hasToken(address addr) public view returns (bool) {\n        return IdToAddressBiMap.hasAddress(registeredTokens, addr);\n    }\n\n    \n    function getEncodedUserOrdersPaginated(address user, uint16 offset, uint16 pageSize)\n        public\n        view\n        returns (bytes memory elements)\n    {\n        for (uint16 i = offset; i < Math.min(orders[user].length, offset + pageSize); i++) {\n            elements = elements.concat(\n                encodeAuctionElement(user, getBalance(user, tokenIdToAddressMap(orders[user][i].sellToken)), orders[user][i])\n            );\n        }\n        return elements;\n    }\n\n    \n    function getEncodedUserOrders(address user) public view returns (bytes memory elements) {\n        return getEncodedUserOrdersPaginated(user, 0, uint16(-1));\n    }\n\n    \n    function getEncodedOrders() public view returns (bytes memory elements) {\n        if (allUsers.size() > 0) {\n            address user = allUsers.first();\n            bool stop = false;\n            while (!stop) {\n                elements = elements.concat(getEncodedUserOrders(user));\n                if (user == allUsers.last) {\n                    stop = true;\n                } else {\n                    user = allUsers.next(user);\n                }\n            }\n        }\n        return elements;\n    }\n\n    function acceptingSolutions(uint32 batchId) public view returns (bool) {\n        return batchId == getCurrentBatchId() - 1 && getSecondsRemainingInBatch() >= 1 minutes;\n    }\n\n    \n    function getCurrentObjectiveValue() public view returns (uint256) {\n        if (latestSolution.batchId == getCurrentBatchId() - 1) {\n            return latestSolution.objectiveValue;\n        } else {\n            return 0;\n        }\n    }\n    \n\n    function placeOrderInternal(\n        uint16 buyToken,\n        uint16 sellToken,\n        uint32 validFrom,\n        uint32 validUntil,\n        uint128 buyAmount,\n        uint128 sellAmount\n    ) private returns (uint16) {\n        require(buyToken != sellToken, \"Exchange tokens not distinct\");\n        require(validFrom >= getCurrentBatchId(), \"Orders can't be placed in the past\");\n        orders[msg.sender].push(\n            Order({\n                buyToken: buyToken,\n                sellToken: sellToken,\n                validFrom: validFrom,\n                validUntil: validUntil,\n                priceNumerator: buyAmount,\n                priceDenominator: sellAmount,\n                usedAmount: 0\n            })\n        );\n        uint16 orderId = (orders[msg.sender].length - 1).toUint16();\n        emit OrderPlacement(msg.sender, orderId, buyToken, sellToken, validFrom, validUntil, buyAmount, sellAmount);\n        allUsers.insert(msg.sender);\n        return orderId;\n    }\n\n    \n    function grantRewardToSolutionSubmitter(uint256 feeReward) private {\n        latestSolution.feeReward = feeReward;\n        addBalanceAndBlockWithdrawForThisBatch(msg.sender, tokenIdToAddressMap(0), feeReward);\n    }\n\n    \n    function burnPreviousAuctionFees() private {\n        if (!currentBatchHasSolution()) {\n            feeToken.burnOWL(address(this), latestSolution.feeReward);\n        }\n    }\n\n    \n    function updateCurrentPrices(uint128[] memory prices, uint16[] memory tokenIdsForPrice) private {\n        for (uint256 i = 0; i < latestSolution.tokenIdsForPrice.length; i++) {\n            currentPrices[latestSolution.tokenIdsForPrice[i]] = 0;\n        }\n        for (uint256 i = 0; i < tokenIdsForPrice.length; i++) {\n            currentPrices[tokenIdsForPrice[i]] = prices[i];\n        }\n    }\n\n    \n    function updateRemainingOrder(address owner, uint16 orderId, uint128 executedAmount) private {\n        orders[owner][orderId].usedAmount = orders[owner][orderId].usedAmount.add(executedAmount).toUint128();\n    }\n\n    \n    function revertRemainingOrder(address owner, uint16 orderId, uint128 executedAmount) private {\n        orders[owner][orderId].usedAmount = orders[owner][orderId].usedAmount.sub(executedAmount).toUint128();\n    }\n\n    \n    function documentTrades(\n        uint32 batchId,\n        address[] memory owners,\n        uint16[] memory orderIds,\n        uint128[] memory volumes,\n        uint16[] memory tokenIdsForPrice\n    ) private {\n        latestSolution.batchId = batchId;\n        for (uint256 i = 0; i < owners.length; i++) {\n            latestSolution.trades.push(TradeData({owner: owners[i], orderId: orderIds[i], volume: volumes[i]}));\n        }\n        latestSolution.tokenIdsForPrice = tokenIdsForPrice;\n        latestSolution.solutionSubmitter = msg.sender;\n    }\n\n    \n    function undoCurrentSolution() private {\n        if (currentBatchHasSolution()) {\n            for (uint256 i = 0; i < latestSolution.trades.length; i++) {\n                address owner = latestSolution.trades[i].owner;\n                uint16 orderId = latestSolution.trades[i].orderId;\n                Order memory order = orders[owner][orderId];\n                (, uint128 sellAmount) = getTradedAmounts(latestSolution.trades[i].volume, order);\n                addBalance(owner, tokenIdToAddressMap(order.sellToken), sellAmount);\n            }\n            for (uint256 i = 0; i < latestSolution.trades.length; i++) {\n                address owner = latestSolution.trades[i].owner;\n                uint16 orderId = latestSolution.trades[i].orderId;\n                Order memory order = orders[owner][orderId];\n                (uint128 buyAmount, uint128 sellAmount) = getTradedAmounts(latestSolution.trades[i].volume, order);\n                revertRemainingOrder(owner, orderId, sellAmount);\n                subtractBalance(owner, tokenIdToAddressMap(order.buyToken), buyAmount);\n                emit TradeReversion(owner, orderId, sellAmount, buyAmount);\n            }\n            \n            subtractBalance(latestSolution.solutionSubmitter, tokenIdToAddressMap(0), latestSolution.feeReward);\n        }\n    }\n\n    \n    function checkAndOverrideObjectiveValue(uint256 newObjectiveValue) private {\n        require(\n            isObjectiveValueSufficientlyImproved(newObjectiveValue),\n            \"New objective doesn't sufficiently improve current solution\"\n        );\n        latestSolution.objectiveValue = newObjectiveValue;\n    }\n\n    \n    \n    function evaluateUtility(uint128 execBuy, Order memory order) private view returns (uint256) {\n        \n        uint256 execSellTimesBuy = getExecutedSellAmount(execBuy, currentPrices[order.buyToken], currentPrices[order.sellToken])\n            .mul(order.priceNumerator);\n\n        uint256 roundedUtility = execBuy.sub(execSellTimesBuy.div(order.priceDenominator)).mul(currentPrices[order.buyToken]);\n        uint256 utilityError = execSellTimesBuy.mod(order.priceDenominator).mul(currentPrices[order.buyToken]).div(\n            order.priceDenominator\n        );\n        return roundedUtility.sub(utilityError).toUint128();\n    }\n\n    \n    function evaluateDisregardedUtility(Order memory order, address user) private view returns (uint256) {\n        uint256 leftoverSellAmount = Math.min(getRemainingAmount(order), getBalance(user, tokenIdToAddressMap(order.sellToken)));\n        uint256 limitTermLeft = currentPrices[order.sellToken].mul(order.priceDenominator);\n        uint256 limitTermRight = order.priceNumerator.mul(currentPrices[order.buyToken]).mul(FEE_DENOMINATOR).div(\n            FEE_DENOMINATOR - 1\n        );\n        uint256 limitTerm = 0;\n        if (limitTermLeft > limitTermRight) {\n            limitTerm = limitTermLeft.sub(limitTermRight);\n        }\n        return leftoverSellAmount.mul(limitTerm).div(order.priceDenominator).toUint128();\n    }\n\n    \n    function getExecutedSellAmount(uint128 executedBuyAmount, uint128 buyTokenPrice, uint128 sellTokenPrice)\n        private\n        pure\n        returns (uint128)\n    {\n        \n        return\n            uint256(executedBuyAmount)\n                .mul(buyTokenPrice)\n                .div(FEE_DENOMINATOR - 1)\n                .mul(FEE_DENOMINATOR)\n                .div(sellTokenPrice)\n                .toUint128();\n        \n    }\n\n    \n    function currentBatchHasSolution() private view returns (bool) {\n        return latestSolution.batchId == getCurrentBatchId() - 1;\n    }\n\n    \n    \n    function getTradedAmounts(uint128 executedBuyAmount, Order memory order) private view returns (uint128, uint128) {\n        uint128 executedSellAmount = getExecutedSellAmount(\n            executedBuyAmount,\n            currentPrices[order.buyToken],\n            currentPrices[order.sellToken]\n        );\n        return (executedBuyAmount, executedSellAmount);\n    }\n\n    \n    function isObjectiveValueSufficientlyImproved(uint256 objectiveValue) private view returns (bool) {\n        return (objectiveValue.mul(IMPROVEMENT_DENOMINATOR) > getCurrentObjectiveValue().mul(IMPROVEMENT_DENOMINATOR + 1));\n    }\n\n    \n    \n    function checkOrderValidity(Order memory order, uint32 batchId) private pure returns (bool) {\n        return order.validFrom <= batchId && order.validUntil >= batchId;\n    }\n\n    \n    function getRemainingAmount(Order memory order) private pure returns (uint128) {\n        return order.priceDenominator - order.usedAmount;\n    }\n\n    \n    function encodeAuctionElement(address user, uint256 sellTokenBalance, Order memory order)\n        private\n        pure\n        returns (bytes memory element)\n    {\n        element = abi.encodePacked(user);\n        element = element.concat(abi.encodePacked(sellTokenBalance));\n        element = element.concat(abi.encodePacked(order.buyToken));\n        element = element.concat(abi.encodePacked(order.sellToken));\n        element = element.concat(abi.encodePacked(order.validFrom));\n        element = element.concat(abi.encodePacked(order.validUntil));\n        element = element.concat(abi.encodePacked(order.priceNumerator));\n        element = element.concat(abi.encodePacked(order.priceDenominator));\n        element = element.concat(abi.encodePacked(getRemainingAmount(order)));\n        return element;\n    }\n\n    \n    function verifyAmountThreshold(uint128[] memory amounts) private pure returns (bool) {\n        for (uint256 i = 0; i < amounts.length; i++) {\n            if (amounts[i] < AMOUNT_MINIMUM) {\n                return false;\n            }\n        }\n        return true;\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"IMPROVEMENT_DENOMINATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSecondsRemainingInBatch\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEncodedOrders\",\"outputs\":[{\"name\":\"elements\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyToken\",\"type\":\"uint16\"},{\"name\":\"sellToken\",\"type\":\"uint16\"},{\"name\":\"validUntil\",\"type\":\"uint32\"},{\"name\":\"buyAmount\",\"type\":\"uint128\"},{\"name\":\"sellAmount\",\"type\":\"uint128\"}],\"name\":\"placeOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"batchId\",\"type\":\"uint32\"},{\"name\":\"claimedObjectiveValue\",\"type\":\"uint256\"},{\"name\":\"owners\",\"type\":\"address[]\"},{\"name\":\"orderIds\",\"type\":\"uint16[]\"},{\"name\":\"buyVolumes\",\"type\":\"uint128[]\"},{\"name\":\"prices\",\"type\":\"uint128[]\"},{\"name\":\"tokenIdsForPrice\",\"type\":\"uint16[]\"}],\"name\":\"submitSolution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint16\"}],\"name\":\"tokenIdToAddressMap\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"requestWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEE_FOR_LISTING_TOKEN_IN_OWL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderIds\",\"type\":\"uint16[]\"}],\"name\":\"cancelOrders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AMOUNT_MINIMUM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyTokens\",\"type\":\"uint16[]\"},{\"name\":\"sellTokens\",\"type\":\"uint16[]\"},{\"name\":\"validFroms\",\"type\":\"uint32[]\"},{\"name\":\"validUntils\",\"type\":\"uint32[]\"},{\"name\":\"buyAmounts\",\"type\":\"uint128[]\"},{\"name\":\"sellAmounts\",\"type\":\"uint128[]\"}],\"name\":\"placeValidFromOrders\",\"outputs\":[{\"name\":\"orderIds\",\"type\":\"uint16[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"currentPrices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getEncodedUserOrders\",\"outputs\":[{\"name\":\"elements\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orders\",\"outputs\":[{\"name\":\"buyToken\",\"type\":\"uint16\"},{\"name\":\"sellToken\",\"type\":\"uint16\"},{\"name\":\"validFrom\",\"type\":\"uint32\"},{\"name\":\"validUntil\",\"type\":\"uint32\"},{\"name\":\"priceNumerator\",\"type\":\"uint128\"},{\"name\":\"priceDenominator\",\"type\":\"uint128\"},{\"name\":\"usedAmount\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastCreditBatchId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"hasToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestSolution\",\"outputs\":[{\"name\":\"batchId\",\"type\":\"uint32\"},{\"name\":\"solutionSubmitter\",\"type\":\"address\"},{\"name\":\"feeReward\",\"type\":\"uint256\"},{\"name\":\"objectiveValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getPendingDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cancellations\",\"type\":\"uint16[]\"},{\"name\":\"buyTokens\",\"type\":\"uint16[]\"},{\"name\":\"sellTokens\",\"type\":\"uint16[]\"},{\"name\":\"validFroms\",\"type\":\"uint32[]\"},{\"name\":\"validUntils\",\"type\":\"uint32[]\"},{\"name\":\"buyAmounts\",\"type\":\"uint128[]\"},{\"name\":\"sellAmounts\",\"type\":\"uint128[]\"}],\"name\":\"replaceOrders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getPendingWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"batchId\",\"type\":\"uint32\"}],\"name\":\"acceptingSolutions\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"addToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEE_DENOMINATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BATCH_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentBatchId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"offset\",\"type\":\"uint16\"},{\"name\":\"pageSize\",\"type\":\"uint16\"}],\"name\":\"getEncodedUserOrdersPaginated\",\"outputs\":[{\"name\":\"elements\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"tokenAddressToIdMap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"batchId\",\"type\":\"uint32\"}],\"name\":\"requestFutureWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"hasValidWithdrawRequest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TOKENS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TOUCHED_ORDERS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentObjectiveValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"maxTokens\",\"type\":\"uint256\"},{\"name\":\"_feeToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint16\"},{\"indexed\":true,\"name\":\"buyToken\",\"type\":\"uint16\"},{\"indexed\":true,\"name\":\"sellToken\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"validFrom\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"validUntil\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"priceNumerator\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"priceDenominator\",\"type\":\"uint128\"}],\"name\":\"OrderPlacement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"OrderCancelation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"OrderDeletion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"orderId\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"executedSellAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"executedBuyAmount\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"orderId\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"executedSellAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"executedBuyAmount\",\"type\":\"uint256\"}],\"name\":\"TradeReversion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"batchId\",\"type\":\"uint32\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"batchId\",\"type\":\"uint32\"}],\"name\":\"WithdrawRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"}]","ContractName":"BatchExchange","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000ffff0000000000000000000000001a5f9352af8af974bfc03399e3767df6370d82e4","Library":"IdToAddressBiMap:aebd846a05eadfe42db884805e6ac99f32e8af43;IterableAppendOnlySet:cddb32b6bb2808d5b5115daab207479ce98d2636","LicenseType":"","SwarmSource":"bzzr://9bfafb3a91f98879805afa4d5e0c0e99f5d8b48e88b13dfb682293474e9f7986"}]}