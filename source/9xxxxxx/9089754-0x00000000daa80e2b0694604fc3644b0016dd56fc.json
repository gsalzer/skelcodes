{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.13; // optimization runs: 65536, version: petersburg\r\n\r\n\r\n/**\r\n * @title IndestructibleRegistry\r\n * @author 0age + flex + smarx\r\n * @notice This contract determines if other contracts are incapable of being\r\n * destroyed by confirming that they do not contain any SELFDESTRUCT, CALLCODE,\r\n * or DELEGATECALL opcodes. Just because a contract is determined to potentially\r\n * be destructible does not necessarily mean that it IS destructible - in other\r\n * words, the check performed by this contract is contract is quite strict.\r\n * To register a contract as indestructible in the registry, provide the target\r\n * contract address to the `registerAsIndestructible` function - it will throw\r\n * if the contract is potentially destructible. Then, anyone can call the\r\n * `isRegisteredAsIndestructible` view function to confirm that the contract has\r\n * been successfully registered as an indestructible contract. You can also call\r\n * the `isPotentiallyDestructible` view function to perform the destructibility\r\n * check without actually registering the contract. Note that future forks may\r\n * introduce new opcodes or other methods by which contracts can be destroyed;\r\n * in that case, this registry can no longer be relied on as a safeguard against\r\n * destructibility.\r\n */\r\ncontract IndestructibleRegistry {\r\n  // Maintain mapping of contracts that have been registered as indestructible.\r\n  mapping (address => bool) private _definitelyIndestructible;\r\n\r\n  /**\r\n   * @notice Register a target contract as indestructible. The attempt will\r\n   * revert if no code exists at the supplied target or if the target contract\r\n   * is potentially destructible (i.e. the code has reachable opcodes that could\r\n   * result in the contract being destroyed).\r\n   * @param target address The contract to check and register as indestructible.\r\n   */\r\n  function registerAsIndestructible(address target) external {\r\n    // Ensure that the target contract is not potentially destructible.\r\n    require(\r\n      !_isPotentiallyDestructible(target),\r\n      \"Supplied target is potentially destructible.\"\r\n    );\r\n\r\n    // Register the target as definitely indestructible (barring new opcodes).\r\n    _definitelyIndestructible[target] = true;\r\n  }\r\n\r\n  /**\r\n   * @notice View function to determine if a target contract has been registered\r\n   * as indestructible.\r\n   * @param target address The contract to check for potential registration as\r\n   * an indestructible contract.\r\n   * @return A boolean signifying successful registration as an indestructable\r\n   * contract.\r\n   */\r\n  function isRegisteredAsIndestructible(\r\n    address target\r\n  ) external view returns (bool registeredAsIndestructible) {\r\n    registeredAsIndestructible = _definitelyIndestructible[target];\r\n  }\r\n\r\n  /**\r\n   * @notice View function to perform a scan of a target contract and determine\r\n   * whether it is potentially destructible or not. The call will revert if no\r\n   * code exists at the supplied target.\r\n   * @param target address The contract to check for potential destructibility.\r\n   * @return A boolean signifying whether or not the target contract is\r\n   * potentially destructible.\r\n   */\r\n  function isPotentiallyDestructible(\r\n    address target\r\n  ) external view returns (bool potentiallyDestructible) {\r\n    potentiallyDestructible = _isPotentiallyDestructible(target);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function that performs a scan of a target contract and\r\n   * determines whether it is potentially destructible or not. It first\r\n   * retrieves the runtime code size of the target contract and ensures that it\r\n   * is greater than zero. Then, it retrieves the actual runtime code from the\r\n   * target contract and places it into memory. Next, it iterates over the code,\r\n   * skipping over unreachable code and push data, and ensures no SELFDESTRUCT,\r\n   * DELEGATECALL, or CALLCODE opcodes are present in the code.\r\n   * @param target address The contract to check for potential destructibility.\r\n   * @return A boolean signifying whether or not the target contract is\r\n   * potentially destructible.\r\n   */\r\n  function _isPotentiallyDestructible(\r\n    address target\r\n  ) internal view returns (bool potentiallyDestructible) {\r\n    // Get the size of the target.\r\n    uint256 size;\r\n    assembly { size := extcodesize(target) }\r\n    require(size > 0, \"No code at target.\");\r\n    \r\n    // Get code at the target and the location data starts and ends in memory.\r\n    uint256 dataStart;\r\n    bytes memory extcode = new bytes(size);\r\n    assembly {\r\n      dataStart := add(extcode, 0x20)\r\n      extcodecopy(target, dataStart, 0, size)\r\n    }\r\n    uint256 dataEnd = dataStart + size;\r\n    require (dataEnd > dataStart, \"SafeMath: addition overflow.\");\r\n    \r\n    // Look for any reachable, impermissible opcodes.\r\n    bool reachable = true;\r\n    uint256 op;\r\n    for (uint256 i = dataStart; i < dataEnd; i++) {\r\n      // Get the opcode in question.\r\n      assembly { op := shr(0xf8, mload(i)) }\r\n\r\n      // If the opcode is a PUSH, skip over the push data.\r\n      // Credit to @smarx for discovering an exploit in a prior version of this\r\n      // contract where this check only occurred as part of \"reachable\" blocks.\r\n      if (op > 95 && op < 128) { // pushN\r\n        i += (op - 95);\r\n        continue;\r\n      }\r\n   \r\n      // Check the opcode if it is reachable (i.e. not a constant or metadata).\r\n      if (reachable) {\r\n        // If execution is halted, mark opcodes that follow as unreachable.\r\n        if (\r\n          op == 254 || // invalid\r\n          op == 243 || // return\r\n          op == 253 || // revert\r\n          op == 86  || // jump\r\n          op == 0      // stop\r\n        ) {\r\n          reachable = false;\r\n          continue;\r\n        }\r\n        \r\n        // If opcode is impermissible, return true - potential destructibility!\r\n        if (\r\n          op == 242 || // callcode\r\n          op == 244 || // delegatecall\r\n          op == 255    // selfdestruct\r\n        ) {\r\n          return true; // potentially destructible!\r\n        }\r\n      } else if (op == 91) { // jumpdest\r\n        // Whenever a JUMPDEST is found, mark opcodes that follow as reachable. \r\n        reachable = true;\r\n      }\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"isPotentiallyDestructible\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"potentiallyDestructible\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"isRegisteredAsIndestructible\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"registeredAsIndestructible\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"registerAsIndestructible\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"IndestructibleRegistry","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"1","Runs":"65536","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://5582dbe5e32e15eb60bae2d03fb67afba282cdf848f468a28f24b99a8ae14920"}]}