{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n    Copyright 2020 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/v1/traders/P1TraderConstants.sol\r\n\r\n/**\r\n * @title P1TraderConstants\r\n * @author dYdX\r\n *\r\n * @notice Constants for traderFlags set by contracts implementing the I_P1Trader interface.\r\n */\r\ncontract P1TraderConstants {\r\n    bytes32 constant internal TRADER_FLAG_ORDERS = bytes32(uint256(1));\r\n    bytes32 constant internal TRADER_FLAG_LIQUIDATION = bytes32(uint256(2));\r\n    bytes32 constant internal TRADER_FLAG_DELEVERAGING = bytes32(uint256(4));\r\n}\r\n\r\n// File: contracts/protocol/lib/BaseMath.sol\r\n\r\n/**\r\n * @title BaseMath\r\n * @author dYdX\r\n *\r\n * @dev Arithmetic for fixed-point numbers with 18 decimals of precision.\r\n */\r\nlibrary BaseMath {\r\n    using SafeMath for uint256;\r\n\r\n    // The number One in the BaseMath system.\r\n    uint256 constant internal BASE = 10 ** 18;\r\n\r\n    /**\r\n     * @dev Getter function since constants can't be read directly from libraries.\r\n     */\r\n    function base()\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return BASE;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies a value by a base value (result is rounded down).\r\n     */\r\n    function baseMul(\r\n        uint256 value,\r\n        uint256 baseValue\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return value.mul(baseValue).div(BASE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies a value by a base value (result is rounded down).\r\n     *  Intended as an alternaltive to baseMul to prevent overflow, when `value` is known\r\n     *  to be divisible by `BASE`.\r\n     */\r\n    function baseDivMul(\r\n        uint256 value,\r\n        uint256 baseValue\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return value.div(BASE).mul(baseValue);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies a value by a base value (result is rounded up).\r\n     */\r\n    function baseMulRoundUp(\r\n        uint256 value,\r\n        uint256 baseValue\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (value == 0 || baseValue == 0) {\r\n            return 0;\r\n        }\r\n        return value.mul(baseValue).sub(1).div(BASE).add(1);\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/TypedSignature.sol\r\n\r\n/**\r\n * @title TypedSignature\r\n * @author dYdX\r\n *\r\n * @dev Library to unparse typed signatures.\r\n */\r\nlibrary TypedSignature {\r\n\r\n    // ============ Constants ============\r\n\r\n    bytes32 constant private FILE = \"TypedSignature\";\r\n\r\n    // Prepended message with the length of the signed hash in decimal.\r\n    bytes constant private PREPEND_DEC = \"\\x19Ethereum Signed Message:\\n32\";\r\n\r\n    // Prepended message with the length of the signed hash in hexadecimal.\r\n    bytes constant private PREPEND_HEX = \"\\x19Ethereum Signed Message:\\n\\x20\";\r\n\r\n    // Number of bytes in a typed signature.\r\n    uint256 constant private NUM_SIGNATURE_BYTES = 66;\r\n\r\n    // ============ Enums ============\r\n\r\n    // Different RPC providers may implement signing methods differently, so we allow different\r\n    // signature types depending on the string prepended to a hash before it was signed.\r\n    enum SignatureType {\r\n        NoPrepend,   // No string was prepended.\r\n        Decimal,     // PREPEND_DEC was prepended.\r\n        Hexadecimal, // PREPEND_HEX was prepended.\r\n        Invalid      // Not a valid type. Used for bound-checking.\r\n    }\r\n\r\n    // ============ Structs ============\r\n\r\n    struct Signature {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        bytes2 vType;\r\n    }\r\n\r\n    // ============ Functions ============\r\n\r\n    /**\r\n     * @dev Gives the address of the signer of a hash. Also allows for the commonly prepended string\r\n     *  of '\\x19Ethereum Signed Message:\\n' + message.length\r\n     *\r\n     * @param  hash       Hash that was signed (does not include prepended message).\r\n     * @param  signature  Type and ECDSA signature with structure: {32:r}{32:s}{1:v}{1:type}\r\n     * @return            Address of the signer of the hash.\r\n     */\r\n    function recover(\r\n        bytes32 hash,\r\n        Signature memory signature\r\n    )\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        SignatureType sigType = SignatureType(uint8(bytes1(signature.vType << 8)));\r\n\r\n        bytes32 signedHash;\r\n        if (sigType == SignatureType.NoPrepend) {\r\n            signedHash = hash;\r\n        } else if (sigType == SignatureType.Decimal) {\r\n            signedHash = keccak256(abi.encodePacked(PREPEND_DEC, hash));\r\n        } else {\r\n            assert(sigType == SignatureType.Hexadecimal);\r\n            signedHash = keccak256(abi.encodePacked(PREPEND_HEX, hash));\r\n        }\r\n\r\n        return ecrecover(\r\n            signedHash,\r\n            uint8(bytes1(signature.vType)),\r\n            signature.r,\r\n            signature.s\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Storage.sol\r\n\r\n/**\r\n * @title Storage\r\n * @author dYdX\r\n *\r\n * @dev Storage library for reading/writing storage at a low level.\r\n */\r\nlibrary Storage {\r\n\r\n    /**\r\n     * @dev Performs an SLOAD and returns the data in the slot.\r\n     */\r\n    function load(\r\n        bytes32 slot\r\n    )\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        bytes32 result;\r\n        /* solium-disable-next-line security/no-inline-assembly */\r\n        assembly {\r\n            result := sload(slot)\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Performs an SSTORE to save the value to the slot.\r\n     */\r\n    function store(\r\n        bytes32 slot,\r\n        bytes32 value\r\n    )\r\n        internal\r\n    {\r\n        /* solium-disable-next-line security/no-inline-assembly */\r\n        assembly {\r\n            sstore(slot, value)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Adminable.sol\r\n\r\n/**\r\n * @title Adminable\r\n * @author dYdX\r\n *\r\n * @dev EIP-1967 Proxy Admin contract.\r\n */\r\ncontract Adminable {\r\n    /**\r\n     * @dev Storage slot with the admin of the contract.\r\n     *  This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\r\n     */\r\n    bytes32 internal constant ADMIN_SLOT =\r\n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\r\n\r\n    /**\r\n    * @dev Modifier to check whether the `msg.sender` is the admin.\r\n    *  If it is, it will run the function. Otherwise, it will revert.\r\n    */\r\n    modifier onlyAdmin() {\r\n        require(\r\n            msg.sender == getAdmin(),\r\n            \"Adminable: caller is not admin\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return The EIP-1967 proxy admin\r\n     */\r\n    function getAdmin()\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return address(uint160(uint256(Storage.load(ADMIN_SLOT))));\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/ReentrancyGuard.sol\r\n\r\n/**\r\n * @title ReentrancyGuard\r\n * @author dYdX\r\n *\r\n * @dev Updated ReentrancyGuard library designed to be used with Proxy Contracts.\r\n */\r\ncontract ReentrancyGuard {\r\n    uint256 private constant NOT_ENTERED = 1;\r\n    uint256 private constant ENTERED = uint256(int256(-1));\r\n\r\n    uint256 private _STATUS_;\r\n\r\n    constructor () internal {\r\n        _STATUS_ = NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_STATUS_ != ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _STATUS_ = ENTERED;\r\n        _;\r\n        _STATUS_ = NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/v1/lib/P1Types.sol\r\n\r\n/**\r\n * @title P1Types\r\n * @author dYdX\r\n *\r\n * @dev Library for common types used in PerpetualV1 contracts.\r\n */\r\nlibrary P1Types {\r\n    // ============ Structs ============\r\n\r\n    /**\r\n     * @dev Used to represent the global index and each account's cached index.\r\n     *  Used to settle funding paymennts on a per-account basis.\r\n     */\r\n    struct Index {\r\n        uint32 timestamp;\r\n        bool isPositive;\r\n        uint128 value;\r\n    }\r\n\r\n    /**\r\n     * @dev Used to track the signed margin balance and position balance values for each account.\r\n     */\r\n    struct Balance {\r\n        bool marginIsPositive;\r\n        bool positionIsPositive;\r\n        uint120 margin;\r\n        uint120 position;\r\n    }\r\n\r\n    /**\r\n     * @dev Used to cache commonly-used variables that are relatively gas-intensive to obtain.\r\n     */\r\n    struct Context {\r\n        uint256 price;\r\n        uint256 minCollateral;\r\n        Index index;\r\n    }\r\n\r\n    /**\r\n     * @dev Used by contracts implementing the I_P1Trader interface to return the result of a trade.\r\n     */\r\n    struct TradeResult {\r\n        uint256 marginAmount;\r\n        uint256 positionAmount;\r\n        bool isBuy; // From taker's perspective.\r\n        bytes32 traderFlags;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/v1/impl/P1Storage.sol\r\n\r\n/**\r\n * @title P1Storage\r\n * @author dYdX\r\n *\r\n * @notice Storage contract. Contains or inherits from all contracts that have ordered storage.\r\n */\r\ncontract P1Storage is\r\n    Adminable,\r\n    ReentrancyGuard\r\n{\r\n    mapping(address => P1Types.Balance) internal _BALANCES_;\r\n    mapping(address => P1Types.Index) internal _LOCAL_INDEXES_;\r\n\r\n    mapping(address => bool) internal _GLOBAL_OPERATORS_;\r\n    mapping(address => mapping(address => bool)) internal _LOCAL_OPERATORS_;\r\n\r\n    address internal _TOKEN_;\r\n    address internal _ORACLE_;\r\n    address internal _FUNDER_;\r\n\r\n    P1Types.Index internal _GLOBAL_INDEX_;\r\n    uint256 internal _MIN_COLLATERAL_;\r\n\r\n    bool internal _FINAL_SETTLEMENT_ENABLED_;\r\n    uint256 internal _FINAL_SETTLEMENT_PRICE_;\r\n}\r\n\r\n// File: contracts/protocol/v1/impl/P1Getters.sol\r\n\r\n/**\r\n * @title P1Getters\r\n * @author dYdX\r\n *\r\n * @notice Contract for read-only getters.\r\n */\r\ncontract P1Getters is\r\n    P1Storage\r\n{\r\n    // ============ Account Getters ============\r\n\r\n    /**\r\n     * @notice Gets the most recently cached balance of an account.\r\n     *\r\n     * @param  account  The address of the account to query the balances of.\r\n     * @return          The balances of the account.\r\n     */\r\n    function getAccountBalance(\r\n        address account\r\n    )\r\n        external\r\n        view\r\n        returns (P1Types.Balance memory)\r\n    {\r\n        return _BALANCES_[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the most recently cached index of an account.\r\n     *\r\n     * @param  account  The address of the account to query the index of.\r\n     * @return          The index of the account.\r\n     */\r\n    function getAccountIndex(\r\n        address account\r\n    )\r\n        external\r\n        view\r\n        returns (P1Types.Index memory)\r\n    {\r\n        return _LOCAL_INDEXES_[account];\r\n    }\r\n\r\n    function getIsLocalOperator(\r\n        address account,\r\n        address operator\r\n    )\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _LOCAL_OPERATORS_[account][operator];\r\n    }\r\n\r\n    // ============ Global Getters ============\r\n\r\n    /**\r\n     * @notice Gets the global operator status of an address.\r\n     *\r\n     * @param  operator  The address of the operator to query the status of.\r\n     * @return           True if the address is a global operator, false otherwise.\r\n     */\r\n    function getIsGlobalOperator(\r\n        address operator\r\n    )\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _GLOBAL_OPERATORS_[operator];\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the address of the ERC20 margin contract used for margin deposits.\r\n     *\r\n     * @return The address of the ERC20 token.\r\n     */\r\n    function getTokenContract()\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        return _TOKEN_;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current address of the price oracle contract.\r\n     *\r\n     * @return The address of the price oracle contract.\r\n     */\r\n    function getOracleContract()\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        return _ORACLE_;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current address of the funder contract.\r\n     *\r\n     * @return The address of the funder contract.\r\n     */\r\n    function getFunderContract()\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        return _FUNDER_;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the most recently cached global index.\r\n     *\r\n     * @return The most recently cached global index.\r\n     */\r\n    function getGlobalIndex()\r\n        external\r\n        view\r\n        returns (P1Types.Index memory)\r\n    {\r\n        return _GLOBAL_INDEX_;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets minimum collateralization ratio of the protocol.\r\n     *\r\n     * @return The minimum-acceptable collateralization ratio, returned as a fixed-point number with\r\n     *  18 decimals of precision.\r\n     */\r\n    function getMinCollateral()\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _MIN_COLLATERAL_;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the status of whether final-settlement was initiated by the Admin.\r\n     *\r\n     * @return True if final-settlement was enabled, false otherwise.\r\n     */\r\n    function getFinalSettlementEnabled()\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _FINAL_SETTLEMENT_ENABLED_;\r\n    }\r\n\r\n    // ============ Public Getters ============\r\n\r\n    /**\r\n     * @notice Gets whether an address has permissions to operate an account.\r\n     *\r\n     * @param  account   The account to query.\r\n     * @param  operator  The address to query.\r\n     * @return           True if the operator has permission to operate the account,\r\n     *                   and false otherwise.\r\n     */\r\n    function hasAccountPermissions(\r\n        address account,\r\n        address operator\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return account == operator\r\n            || _GLOBAL_OPERATORS_[operator]\r\n            || _LOCAL_OPERATORS_[account][operator];\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/v1/traders/P1Orders.sol\r\n\r\n/**\r\n * @title P1Orders\r\n * @author dYdX\r\n *\r\n * @notice Contract allowing trading between accounts using cryptographically signed messages.\r\n */\r\ncontract P1Orders is\r\n    P1TraderConstants\r\n{\r\n    using BaseMath for uint256;\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Constants ============\r\n\r\n    // EIP191 header for EIP712 prefix\r\n    bytes2 constant private EIP191_HEADER = 0x1901;\r\n\r\n    // EIP712 Domain Name value\r\n    string constant private EIP712_DOMAIN_NAME = \"P1Orders\";\r\n\r\n    // EIP712 Domain Version value\r\n    string constant private EIP712_DOMAIN_VERSION = \"1.0\";\r\n\r\n    // Hash of the EIP712 Domain Separator Schema\r\n    /* solium-disable-next-line indentation */\r\n    bytes32 constant private EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\r\n        \"EIP712Domain(\",\r\n        \"string name,\",\r\n        \"string version,\",\r\n        \"uint256 chainId,\",\r\n        \"address verifyingContract\",\r\n        \")\"\r\n    ));\r\n\r\n    // Hash of the EIP712 LimitOrder struct\r\n    /* solium-disable-next-line indentation */\r\n    bytes32 constant private EIP712_ORDER_STRUCT_SCHEMA_HASH = keccak256(abi.encodePacked(\r\n        \"Order(\",\r\n        \"bytes32 flags,\",\r\n        \"uint256 amount,\",\r\n        \"uint256 limitPrice,\",\r\n        \"uint256 triggerPrice,\",\r\n        \"uint256 limitFee,\",\r\n        \"address maker,\",\r\n        \"address taker,\",\r\n        \"uint256 expiration\",\r\n        \")\"\r\n    ));\r\n\r\n    // Bitmasks for the flags field\r\n    bytes32 constant FLAG_MASK_NULL = bytes32(uint256(0));\r\n    bytes32 constant FLAG_MASK_IS_BUY = bytes32(uint256(1));\r\n    bytes32 constant FLAG_MASK_IS_DECREASE_ONLY = bytes32(uint256(1 << 1));\r\n    bytes32 constant FLAG_MASK_IS_NEGATIVE_LIMIT_FEE = bytes32(uint256(1 << 2));\r\n\r\n    // ============ Enums ============\r\n\r\n    enum OrderStatus {\r\n        Open,\r\n        Approved,\r\n        Canceled\r\n    }\r\n\r\n    // ============ Structs ============\r\n\r\n    struct Order {\r\n        bytes32 flags;\r\n        uint256 amount;\r\n        uint256 limitPrice;\r\n        uint256 triggerPrice;\r\n        uint256 limitFee;\r\n        address maker;\r\n        address taker;\r\n        uint256 expiration;\r\n    }\r\n\r\n    struct Fill {\r\n        uint256 amount;\r\n        uint256 price;\r\n        uint256 fee;\r\n        bool isNegativeFee;\r\n    }\r\n\r\n    struct TradeData {\r\n        Order order;\r\n        Fill fill;\r\n        TypedSignature.Signature signature;\r\n    }\r\n\r\n    struct OrderQueryOutput {\r\n        OrderStatus status;\r\n        uint256 filledAmount;\r\n    }\r\n\r\n    // ============ Events ============\r\n\r\n    event LogOrderCanceled(\r\n        address indexed maker,\r\n        bytes32 orderHash\r\n    );\r\n\r\n    event LogOrderApproved(\r\n        address indexed maker,\r\n        bytes32 orderHash\r\n    );\r\n\r\n    event LogOrderFilled(\r\n        bytes32 orderHash,\r\n        bytes32 flags,\r\n        uint256 triggerPrice,\r\n        Fill fill\r\n    );\r\n\r\n    // ============ Immutable Storage ============\r\n\r\n    // address of the perpetual contract\r\n    address public _PERPETUAL_V1_;\r\n\r\n    // Hash of the EIP712 Domain Separator data\r\n    bytes32 public _EIP712_DOMAIN_HASH_;\r\n\r\n    // ============ Mutable Storage ============\r\n\r\n    // order hash => filled amount (in position amount)\r\n    mapping (bytes32 => uint256) public _FILLED_AMOUNT_;\r\n\r\n    // order hash => status\r\n    mapping (bytes32 => OrderStatus) public _STATUS_;\r\n\r\n    // ============ Constructor ============\r\n\r\n    constructor (\r\n        address perpetualV1,\r\n        uint256 chainId\r\n    )\r\n        public\r\n    {\r\n        _PERPETUAL_V1_ = perpetualV1;\r\n\r\n        /* solium-disable-next-line indentation */\r\n        _EIP712_DOMAIN_HASH_ = keccak256(abi.encode(\r\n            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\r\n            keccak256(bytes(EIP712_DOMAIN_NAME)),\r\n            keccak256(bytes(EIP712_DOMAIN_VERSION)),\r\n            chainId,\r\n            address(this)\r\n        ));\r\n    }\r\n\r\n    // ============ External Functions ============\r\n\r\n    /**\r\n     * @notice Allows an account to take an order cryptographically signed by a different account.\r\n     * @dev Emits the LogOrderFilled event.\r\n     *\r\n     * @param  sender  The address that called the trade() function on PerpetualV1.\r\n     * @param  maker   The maker of the order.\r\n     * @param  taker   The taker of the order.\r\n     * @param  price   The current oracle price of the underlying asset.\r\n     * @param  data    A struct of type TradeData.\r\n     * @return         The assets to be traded and traderFlags that indicate that a trade occurred.\r\n     */\r\n    function trade(\r\n        address sender,\r\n        address maker,\r\n        address taker,\r\n        uint256 price,\r\n        bytes calldata data,\r\n        bytes32 /* traderFlags */\r\n    )\r\n        external\r\n        returns(P1Types.TradeResult memory)\r\n    {\r\n        address perpetual = _PERPETUAL_V1_;\r\n\r\n        require(\r\n            msg.sender == perpetual,\r\n            \"msg.sender must be PerpetualV1\"\r\n        );\r\n\r\n        if (taker != sender) {\r\n            require(\r\n                P1Getters(perpetual).hasAccountPermissions(taker, sender),\r\n                \"Sender does not have permissions for the taker\"\r\n            );\r\n        }\r\n\r\n        TradeData memory tradeData = abi.decode(data, (TradeData));\r\n        bytes32 orderHash = _getOrderHash(tradeData.order);\r\n\r\n        // validations\r\n        _verifyOrderStateAndSignature(\r\n            tradeData,\r\n            orderHash\r\n        );\r\n        _verifyOrderRequest(\r\n            tradeData,\r\n            maker,\r\n            taker,\r\n            perpetual,\r\n            price\r\n        );\r\n\r\n        // set _FILLED_AMOUNT_\r\n        uint256 oldFilledAmount = _FILLED_AMOUNT_[orderHash];\r\n        uint256 newFilledAmount = oldFilledAmount.add(tradeData.fill.amount);\r\n        require(\r\n            newFilledAmount <= tradeData.order.amount,\r\n            \"Cannot overfill order\"\r\n        );\r\n        _FILLED_AMOUNT_[orderHash] = newFilledAmount;\r\n\r\n        emit LogOrderFilled(\r\n            orderHash,\r\n            tradeData.order.flags,\r\n            tradeData.order.triggerPrice,\r\n            tradeData.fill\r\n        );\r\n\r\n        // Order fee is denoted as a percentage of execution price.\r\n        // Convert into an amount per unit position.\r\n        uint256 fee = tradeData.fill.fee.baseMul(tradeData.fill.price);\r\n\r\n        // `isBuyOrder` is from the maker's perspective.\r\n        bool isBuyOrder = _isBuy(tradeData.order);\r\n        uint256 marginPerPosition = (isBuyOrder == tradeData.fill.isNegativeFee)\r\n            ? tradeData.fill.price.sub(fee)\r\n            : tradeData.fill.price.add(fee);\r\n\r\n        return P1Types.TradeResult({\r\n            marginAmount: tradeData.fill.amount.baseMul(marginPerPosition),\r\n            positionAmount: tradeData.fill.amount,\r\n            isBuy: !isBuyOrder,\r\n            traderFlags: TRADER_FLAG_ORDERS\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @notice On-chain approves an order.\r\n     * @dev Emits the LogOrderApproved event.\r\n     *\r\n     * @param  order  The order that will be approved.\r\n     */\r\n    function approveOrder(\r\n        Order calldata order\r\n    )\r\n        external\r\n    {\r\n        require(\r\n            msg.sender == order.maker,\r\n            \"Order cannot be approved by non-maker\"\r\n        );\r\n        bytes32 orderHash = _getOrderHash(order);\r\n        require(\r\n            _STATUS_[orderHash] != OrderStatus.Canceled,\r\n            \"Canceled order cannot be approved\"\r\n        );\r\n        _STATUS_[orderHash] = OrderStatus.Approved;\r\n        emit LogOrderApproved(msg.sender, orderHash);\r\n    }\r\n\r\n    /**\r\n     * @notice On-chain cancels an order.\r\n     * @dev Emits the LogOrderCanceled event.\r\n     *\r\n     * @param  order  The order that will be permanently canceled.\r\n     */\r\n    function cancelOrder(\r\n        Order calldata order\r\n    )\r\n        external\r\n    {\r\n        require(\r\n            msg.sender == order.maker,\r\n            \"Order cannot be canceled by non-maker\"\r\n        );\r\n        bytes32 orderHash = _getOrderHash(order);\r\n        _STATUS_[orderHash] = OrderStatus.Canceled;\r\n        emit LogOrderCanceled(msg.sender, orderHash);\r\n    }\r\n\r\n    // ============ Getter Functions ============\r\n\r\n    /**\r\n     * @notice Gets the status (open/approved/canceled) and filled amount of each order in a list.\r\n     *\r\n     * @param  orderHashes  A list of the hashes of the orders to check.\r\n     * @return              A list of OrderQueryOutput structs containing the status and filled\r\n     *                      amount of each order.\r\n     */\r\n    function getOrdersStatus(\r\n        bytes32[] calldata orderHashes\r\n    )\r\n        external\r\n        view\r\n        returns (OrderQueryOutput[] memory)\r\n    {\r\n        OrderQueryOutput[] memory result = new OrderQueryOutput[](orderHashes.length);\r\n        for (uint256 i = 0; i < orderHashes.length; i++) {\r\n            bytes32 orderHash = orderHashes[i];\r\n            result[i] = OrderQueryOutput({\r\n                status: _STATUS_[orderHash],\r\n                filledAmount: _FILLED_AMOUNT_[orderHash]\r\n            });\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // ============ Helper Functions ============\r\n\r\n    function _verifyOrderStateAndSignature(\r\n        TradeData memory tradeData,\r\n        bytes32 orderHash\r\n    )\r\n        private\r\n        view\r\n    {\r\n        OrderStatus orderStatus = _STATUS_[orderHash];\r\n\r\n        if (orderStatus == OrderStatus.Open) {\r\n            require(\r\n                tradeData.order.maker == TypedSignature.recover(orderHash, tradeData.signature),\r\n                \"Order has an invalid signature\"\r\n            );\r\n        } else {\r\n            require(\r\n                orderStatus != OrderStatus.Canceled,\r\n                \"Order was already canceled\"\r\n            );\r\n            assert(orderStatus == OrderStatus.Approved);\r\n        }\r\n    }\r\n\r\n    function _verifyOrderRequest(\r\n        TradeData memory tradeData,\r\n        address maker,\r\n        address taker,\r\n        address perpetual,\r\n        uint256 price\r\n    )\r\n        private\r\n        view\r\n    {\r\n        require(\r\n            tradeData.order.maker == maker,\r\n            \"Order maker does not match maker\"\r\n        );\r\n        require(\r\n            tradeData.order.taker == taker || tradeData.order.taker == address(0),\r\n            \"Order taker does not match taker\"\r\n        );\r\n        require(\r\n            tradeData.order.expiration >= block.timestamp || tradeData.order.expiration == 0,\r\n            \"Order has expired\"\r\n        );\r\n\r\n        // `isBuyOrder` is from the maker's perspective.\r\n        bool isBuyOrder = _isBuy(tradeData.order);\r\n        bool validPrice = isBuyOrder\r\n            ? tradeData.fill.price <= tradeData.order.limitPrice\r\n            : tradeData.fill.price >= tradeData.order.limitPrice;\r\n        require(\r\n            validPrice,\r\n            \"Fill price is invalid\"\r\n        );\r\n\r\n        bool validFee = _isNegativeLimitFee(tradeData.order)\r\n            ? tradeData.fill.isNegativeFee && tradeData.fill.fee >= tradeData.order.limitFee\r\n            : tradeData.fill.isNegativeFee || tradeData.fill.fee <= tradeData.order.limitFee;\r\n        require(\r\n            validFee,\r\n            \"Fill fee is invalid\"\r\n        );\r\n\r\n        if (tradeData.order.triggerPrice != 0) {\r\n            bool validTriggerPrice = isBuyOrder\r\n                ? tradeData.order.triggerPrice <= price\r\n                : tradeData.order.triggerPrice >= price;\r\n            require(\r\n                validTriggerPrice,\r\n                \"Trigger price has not been reached\"\r\n            );\r\n        }\r\n\r\n        if (_isDecreaseOnly(tradeData.order)) {\r\n            P1Types.Balance memory balance = P1Getters(perpetual).getAccountBalance(maker);\r\n            require(\r\n                isBuyOrder != balance.positionIsPositive\r\n                && tradeData.fill.amount <= balance.position,\r\n                \"Fill does not decrease position\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the EIP712 hash of an order.\r\n     */\r\n    function _getOrderHash(\r\n        Order memory order\r\n    )\r\n        private\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        // compute the overall signed struct hash\r\n        /* solium-disable-next-line indentation */\r\n        bytes32 structHash = keccak256(abi.encode(\r\n            EIP712_ORDER_STRUCT_SCHEMA_HASH,\r\n            order\r\n        ));\r\n\r\n        // compute eip712 compliant hash\r\n        /* solium-disable-next-line indentation */\r\n        return keccak256(abi.encodePacked(\r\n            EIP191_HEADER,\r\n            _EIP712_DOMAIN_HASH_,\r\n            structHash\r\n        ));\r\n    }\r\n\r\n    function _isBuy(\r\n        Order memory order\r\n    )\r\n        private\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return (order.flags & FLAG_MASK_IS_BUY) != FLAG_MASK_NULL;\r\n    }\r\n\r\n    function _isDecreaseOnly(\r\n        Order memory order\r\n    )\r\n        private\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return (order.flags & FLAG_MASK_IS_DECREASE_ONLY) != FLAG_MASK_NULL;\r\n    }\r\n\r\n    function _isNegativeLimitFee(\r\n        Order memory order\r\n    )\r\n        private\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return (order.flags & FLAG_MASK_IS_NEGATIVE_LIMIT_FEE) != FLAG_MASK_NULL;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"perpetualV1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"LogOrderApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"LogOrderCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"flags\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"triggerPrice\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isNegativeFee\",\"type\":\"bool\"}],\"indexed\":false,\"internalType\":\"struct P1Orders.Fill\",\"name\":\"fill\",\"type\":\"tuple\"}],\"name\":\"LogOrderFilled\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"_EIP712_DOMAIN_HASH_\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"_FILLED_AMOUNT_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_PERPETUAL_V1_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"_STATUS_\",\"outputs\":[{\"internalType\":\"enum P1Orders.OrderStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"flags\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"triggerPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"internalType\":\"struct P1Orders.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"approveOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"flags\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"triggerPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"internalType\":\"struct P1Orders.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"orderHashes\",\"type\":\"bytes32[]\"}],\"name\":\"getOrdersStatus\",\"outputs\":[{\"components\":[{\"internalType\":\"enum P1Orders.OrderStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"filledAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct P1Orders.OrderQueryOutput[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"trade\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marginAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"positionAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"traderFlags\",\"type\":\"bytes32\"}],\"internalType\":\"struct P1Types.TradeResult\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"P1Orders","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"00000000000000000000000007abe965500a49370d331ecd613c7ac47dd6e5470000000000000000000000000000000000000000000000000000000000000001","Library":"","LicenseType":"Apache-2.0","SwarmSource":"bzzr://7dfdbb99eb008836faacb25c90eabf31b80b697bae4a85ad2cd4036be8c9f980"}]}