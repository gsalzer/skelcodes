{"status":"1","message":"OK","result":[{"SourceCode":"# A \"zap\" to work with SUSD pool\r\n# (c) Curve.Fi, 2020\r\nfrom vyper.interfaces import ERC20\r\n\r\n# External Contracts\r\ncontract yERC20:\r\n    def totalSupply() -> uint256: constant\r\n    def allowance(_owner: address, _spender: address) -> uint256: constant\r\n    def transfer(_to: address, _value: uint256) -> bool: modifying\r\n    def transferFrom(_from: address, _to: address, _value: uint256) -> bool: modifying\r\n    def approve(_spender: address, _value: uint256) -> bool: modifying\r\n    def name() -> string[64]: constant\r\n    def symbol() -> string[32]: constant\r\n    def decimals() -> uint256: constant\r\n    def balanceOf(arg0: address) -> uint256: constant\r\n    def deposit(depositAmount: uint256): modifying\r\n    def withdraw(withdrawTokens: uint256): modifying\r\n    def getPricePerFullShare() -> uint256: constant\r\n\r\n\r\n\r\n# Pool looks like [ySUSD, [yDAI, yUSDC, yUSDT, yTUSD]]\r\n\r\nN_COINS: constant(int128) = 2\r\nN_COINS_Y: constant(int128) = 4\r\nN_COINS_CURVED: constant(int128) = 5\r\n\r\n# Tether transfer-only ABI\r\ncontract USDT:\r\n    def transfer(_to: address, _value: uint256): modifying\r\n    def transferFrom(_from: address, _to: address, _value: uint256): modifying\r\n\r\n\r\ncontract Curve:\r\n    def add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256): modifying\r\n    def remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS]): modifying\r\n    def remove_liquidity_imbalance(amounts: uint256[N_COINS], max_burn_amount: uint256): modifying\r\n    def balances(i: int128) -> uint256: constant\r\n    def A() -> uint256: constant\r\n    def fee() -> uint256: constant\r\n    def owner() -> address: constant\r\n    def coins(i: int128) -> address: constant\r\n    def underlying_coins(i: int128) -> address: constant\r\n    def get_virtual_price() -> uint256: constant\r\n    def donate_dust(amounts: uint256[N_COINS]): modifying\r\n    def calc_token_amount(amounts: uint256[N_COINS], deposit: bool) -> uint256: constant\r\n    def get_dy(i: int128, j: int128, dx: uint256) -> uint256: constant\r\n    def exchange_underlying(i: int128, j: int128, dx: uint256, min_dy: uint256): modifying\r\n    def exchange(i: int128, j: int128, dx: uint256, min_dy: uint256): modifying\r\n\r\n\r\ncontract YCurve:\r\n    def add_liquidity(amounts: uint256[N_COINS_Y], min_mint_amount: uint256): modifying\r\n    def remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS_Y]): modifying\r\n    def remove_liquidity_imbalance(amounts: uint256[N_COINS_Y], max_burn_amount: uint256): modifying\r\n    def balances(i: int128) -> uint256: constant\r\n    def A() -> uint256: constant\r\n    def fee() -> uint256: constant\r\n    def owner() -> address: constant\r\n    def coins(i: int128) -> address: constant\r\n    def underlying_coins(i: int128) -> address: constant\r\n    def calc_token_amount(amounts: uint256[N_COINS_Y], deposit: bool) -> uint256: constant\r\n    def get_dy(i: int128, j: int128, dx: uint256) -> uint256: constant\r\n\r\n\r\ncontract YZap:\r\n    def calc_withdraw_one_coin(_token_amount: uint256, i: int128) -> uint256: constant\r\n    def remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_uamount: uint256, donate_dust: bool = False): modifying\r\n\r\n\r\nTETHERED: constant(bool[N_COINS_CURVED]) = [False, False, False, True, False]\r\nZERO256: constant(uint256) = 0  # This hack is really bad XXX\r\nZEROS: constant(uint256[N_COINS]) = [ZERO256, ZERO256]\r\nZEROS_Y: constant(uint256[N_COINS_Y]) = [ZERO256, ZERO256, ZERO256, ZERO256]\r\nZEROS_CURVED: constant(uint256[N_COINS_CURVED]) = [ZERO256, ZERO256, ZERO256, ZERO256, ZERO256]\r\nLENDING_PRECISION: constant(uint256) = 10 ** 18\r\nPRECISION: constant(uint256) = 10 ** 18\r\nONE256: constant(uint256) = 1  # Oh man, here we go XXX\r\nPRECISION_OUTER_MUL: constant(uint256[N_COINS]) = [ONE256, ONE256]\r\nPRECISION_MUL: constant(uint256[N_COINS_CURVED]) = [convert(1000000000000000000, uint256), convert(1000000000000000000, uint256), convert(1000000, uint256), convert(1000000, uint256), convert(1000000000000000000, uint256)]\r\nFEE_DENOMINATOR: constant(uint256) = 10 ** 10\r\nFEE_IMPRECISION: constant(uint256) = 25 * 10 ** 8  # % of the fee\r\n\r\ncoins: public(address[N_COINS_CURVED])\r\nunderlying_coins: public(address[N_COINS_CURVED])\r\n\r\ncurve: public(address)\r\ntoken: public(address)\r\n\r\nycurve: public(address)\r\nytoken: public(address)\r\nyzap: public(address)\r\n\r\n\r\n@public\r\ndef __init__(_coins: address[N_COINS], _underlying_coins: address[N_COINS],\r\n             _curve: address, _token: address, _yzap: address):\r\n\r\n    for i in range(N_COINS - 1):\r\n        self.coins[i] = _coins[i]\r\n        self.underlying_coins[i] = _underlying_coins[i]\r\n\r\n    self.ycurve = _underlying_coins[N_COINS - 1]\r\n    self.ytoken = _coins[N_COINS - 1]\r\n\r\n    for i in range(N_COINS - 1, N_COINS_CURVED):\r\n        j: int128 = i + 1 - N_COINS\r\n        self.coins[i] = Curve(_underlying_coins[N_COINS-1]).coins(j)\r\n        self.underlying_coins[i] = Curve(_underlying_coins[N_COINS-1]).underlying_coins(j)\r\n\r\n    self.curve = _curve\r\n    self.token = _token\r\n    self.yzap = _yzap\r\n\r\n\r\n@public\r\n@nonreentrant('lock')\r\ndef add_liquidity(uamounts: uint256[N_COINS_CURVED], min_mint_amount: uint256):\r\n    tethered: bool[N_COINS_CURVED] = TETHERED\r\n    amounts: uint256[N_COINS_CURVED] = ZEROS_CURVED\r\n    _curve: address = self.curve\r\n    _token: address = self.token\r\n    _ycurve: address = self.ycurve\r\n    _ytoken: address = self.ytoken\r\n\r\n    for i in range(N_COINS_CURVED):\r\n        uamount: uint256 = uamounts[i]\r\n\r\n        if uamount > 0:\r\n            # Transfer the underlying coin from owner\r\n            if tethered[i]:\r\n                USDT(self.underlying_coins[i]).transferFrom(\r\n                    msg.sender, self, uamount)\r\n            else:\r\n                assert_modifiable(ERC20(self.underlying_coins[i])\\\r\n                    .transferFrom(msg.sender, self, uamount))\r\n\r\n            # Mint if needed\r\n            ERC20(self.underlying_coins[i]).approve(self.coins[i], uamount)\r\n            yERC20(self.coins[i]).deposit(uamount)\r\n            amounts[i] = yERC20(self.coins[i]).balanceOf(self)\r\n            if i < N_COINS - 1:\r\n                ERC20(self.coins[i]).approve(_curve, amounts[i])\r\n            else:\r\n                ERC20(self.coins[i]).approve(_ycurve, amounts[i])\r\n    # Now we have self owning amounts[] of ycoins, approved to both Curve contracts\r\n\r\n    amounts_inner: uint256[N_COINS_Y] = ZEROS_Y\r\n    for i in range(N_COINS-1, N_COINS_CURVED):\r\n        amounts_inner[i - (N_COINS - 1)] = amounts[i]\r\n    YCurve(_ycurve).add_liquidity(amounts_inner, 0)\r\n    ytoken_amount: uint256 = ERC20(_ytoken).balanceOf(self)\r\n\r\n    amounts_outer: uint256[N_COINS] = ZEROS\r\n    for i in range(N_COINS-1):\r\n        amounts_outer[i] = amounts[i]\r\n    amounts_outer[N_COINS-1] = ytoken_amount\r\n\r\n    ERC20(_ytoken).approve(_curve, ytoken_amount)\r\n    Curve(_curve).add_liquidity(amounts_outer, min_mint_amount)\r\n\r\n    tokens: uint256 = ERC20(_token).balanceOf(self)\r\n    assert_modifiable(ERC20(_token).transfer(msg.sender, tokens))\r\n\r\n\r\n@private\r\ndef _send_all(_addr: address, min_uamounts: uint256[N_COINS_CURVED], one: int128):\r\n    tethered: bool[N_COINS_CURVED] = TETHERED\r\n\r\n    for i in range(N_COINS_CURVED):\r\n        if (one < 0) or (i == one):\r\n            _coin: address = self.coins[i]\r\n            _balance: uint256 = yERC20(_coin).balanceOf(self)\r\n            if _balance == 0:  # Do nothing for 0 coins\r\n                continue\r\n            yERC20(_coin).withdraw(_balance)\r\n\r\n            _ucoin: address = self.underlying_coins[i]\r\n            _uamount: uint256 = ERC20(_ucoin).balanceOf(self)\r\n            assert _uamount >= min_uamounts[i], \"Not enough coins withdrawn\"\r\n\r\n            if tethered[i]:\r\n                USDT(_ucoin).transfer(_addr, _uamount)\r\n            else:\r\n                assert_modifiable(ERC20(_ucoin).transfer(_addr, _uamount))\r\n\r\n\r\n@public\r\n@nonreentrant('lock')\r\ndef remove_liquidity(_amount: uint256, min_uamounts: uint256[N_COINS_CURVED]):\r\n    assert_modifiable(ERC20(self.token).transferFrom(msg.sender, self, _amount))\r\n\r\n    # First - withdraw outer coins\r\n    zeros: uint256[N_COINS] = ZEROS\r\n    Curve(self.curve).remove_liquidity(_amount, zeros)\r\n\r\n    yamount: uint256 = ERC20(self.ytoken).balanceOf(self)\r\n    zeros_y: uint256[N_COINS_Y] = ZEROS_Y\r\n    YCurve(self.ycurve).remove_liquidity(yamount, zeros_y)\r\n\r\n    self._send_all(msg.sender, min_uamounts, -1)\r\n\r\n\r\n@public\r\n@nonreentrant('lock')\r\ndef remove_liquidity_imbalance(uamounts: uint256[N_COINS_CURVED], max_burn_amount: uint256):\r\n    \"\"\"\r\n    Get max_burn_amount in, remove requested liquidity and transfer back what is left\r\n    \"\"\"\r\n    _token: address = self.token\r\n    _ytoken: address = self.ytoken\r\n    _curve: address = self.curve\r\n    _ycurve: address = self.ycurve\r\n\r\n    amounts: uint256[N_COINS_CURVED] = uamounts\r\n    for i in range(N_COINS_CURVED):\r\n        if amounts[i] > 0:\r\n            rate: uint256 = yERC20(self.coins[i]).getPricePerFullShare()\r\n            amounts[i] = amounts[i] * LENDING_PRECISION / rate\r\n\r\n    # Transfrer max tokens in\r\n    _tokens: uint256 = ERC20(_token).balanceOf(msg.sender)\r\n    if _tokens > max_burn_amount:\r\n        _tokens = max_burn_amount\r\n    assert_modifiable(ERC20(_token).transferFrom(msg.sender, self, _tokens))\r\n\r\n    # Now this is tricky.\r\n    # * We calculate token amount needed for Y with over-estimation\r\n    # * Remove that token amount and sUSD\r\n    # * Remove individual coins other than sUSD from that Y Token\r\n    # * Deposit the rest of ytoken back to the pool\r\n    # * Return the rest of pool token back to the sender\r\n    # Phew. Expensive!\r\n\r\n    # So, calculate (the excessive) amount of ytokens to remove...\r\n    yfee: uint256 = YCurve(_ycurve).fee()\r\n    yamounts: uint256[N_COINS_Y] = ZEROS_Y\r\n    withdraw_y: bool = False\r\n    for i in range(N_COINS_Y):\r\n        j: int128 = i + N_COINS - 1\r\n        if amounts[j] > 0:\r\n            withdraw_y = True\r\n            yamounts[i] = amounts[j]\r\n    ytokens: uint256 = 0\r\n    if withdraw_y:\r\n        ytokens = YCurve(_ycurve).calc_token_amount(yamounts, False)\r\n        ytokens = ytokens + ytokens * yfee / FEE_DENOMINATOR\r\n\r\n    # Remove those amounts from the outer pool\r\n    outer_amounts: uint256[N_COINS] = ZEROS\r\n    for i in range(N_COINS - 1):\r\n        outer_amounts[i] = amounts[i]\r\n    outer_amounts[N_COINS-1] = ytokens\r\n    Curve(_curve).remove_liquidity_imbalance(outer_amounts, max_burn_amount)\r\n\r\n    # Remove yamounts from from ypool\r\n    if withdraw_y:\r\n        YCurve(_ycurve).remove_liquidity_imbalance(yamounts, ytokens)\r\n        # Add the rest of ytokens back\r\n        yback: uint256[N_COINS] = ZEROS\r\n        yback[N_COINS-1] = ERC20(_ytoken).balanceOf(self)\r\n        ERC20(_ytoken).approve(_curve, yback[N_COINS-1])\r\n        Curve(_curve).add_liquidity(yback, 0)\r\n\r\n    # Transfer unused tokens back\r\n    _tokens = ERC20(_token).balanceOf(self)\r\n    assert_modifiable(ERC20(_token).transfer(msg.sender, _tokens))\r\n\r\n    # Unwrap and transfer all the coins we've got\r\n    self._send_all(msg.sender, ZEROS_CURVED, -1)\r\n\r\n\r\n@private\r\n@constant\r\ndef get_D(A: uint256, xp: uint256[N_COINS]) -> uint256:\r\n    S: uint256 = 0\r\n    for _x in xp:\r\n        S += _x\r\n    if S == 0:\r\n        return 0\r\n\r\n    Dprev: uint256 = 0\r\n    D: uint256 = S\r\n    Ann: uint256 = A * N_COINS\r\n    for _i in range(255):\r\n        D_P: uint256 = D\r\n        for _x in xp:\r\n            D_P = D_P * D / (_x * N_COINS + 1)  # +1 is to prevent /0\r\n        Dprev = D\r\n        D = (Ann * S + D_P * N_COINS) * D / ((Ann - 1) * D + (N_COINS + 1) * D_P)\r\n        # Equality with the precision of 1\r\n        if D > Dprev:\r\n            if D - Dprev <= 1:\r\n                break\r\n        else:\r\n            if Dprev - D <= 1:\r\n                break\r\n    return D\r\n\r\n\r\n@private\r\n@constant\r\ndef get_y(A: uint256, i: int128, _xp: uint256[N_COINS], D: uint256) -> uint256:\r\n    \"\"\"\r\n    Calculate x[i] if one reduces D from being calculated for _xp to D\r\n\r\n    Done by solving quadratic equation iteratively.\r\n    x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\r\n    x_1**2 + b*x_1 = c\r\n\r\n    x_1 = (x_1**2 + c) / (2*x_1 + b)\r\n    \"\"\"\r\n    # x in the input is converted to the same price/precision\r\n\r\n    assert (i >= 0) and (i < N_COINS)\r\n\r\n    c: uint256 = D\r\n    S_: uint256 = 0\r\n    Ann: uint256 = A * N_COINS\r\n\r\n    _x: uint256 = 0\r\n    for _i in range(N_COINS):\r\n        if _i != i:\r\n            _x = _xp[_i]\r\n        else:\r\n            continue\r\n        S_ += _x\r\n        c = c * D / (_x * N_COINS)\r\n    c = c * D / (Ann * N_COINS)\r\n    b: uint256 = S_ + D / Ann\r\n    y_prev: uint256 = 0\r\n    y: uint256 = D\r\n    for _i in range(255):\r\n        y_prev = y\r\n        y = (y*y + c) / (2 * y + b - D)\r\n        # Equality with the precision of 1\r\n        if y > y_prev:\r\n            if y - y_prev <= 1:\r\n                break\r\n        else:\r\n            if y_prev - y <= 1:\r\n                break\r\n    return y\r\n\r\n\r\n@private\r\n@constant\r\ndef _calc_withdraw_one_coin(_token_amount: uint256, k: int128, rates: uint256[N_COINS]) -> uint256[2]:\r\n    # First, need to calculate\r\n    # * Get current D\r\n    # * Solve Eqn against y_i for D - _token_amount\r\n    crv: address = self.curve\r\n    A: uint256 = Curve(crv).A()\r\n    fee: uint256 = Curve(crv).fee() * N_COINS / (4 * (N_COINS - 1))\r\n    fee += fee * FEE_IMPRECISION / FEE_DENOMINATOR  # Overcharge to account for imprecision\r\n    precisions: uint256[N_COINS] = PRECISION_OUTER_MUL\r\n    total_supply: uint256 = ERC20(self.token).totalSupply()\r\n\r\n    i: int128 = k\r\n    if i >= N_COINS:\r\n        i = N_COINS - 1\r\n    # if k <= N_COINS-1: proceed as we did\r\n    # if k >= N_COINS-1: calculate number of ytoken, then call another zap to get ytoken number\r\n\r\n    xp: uint256[N_COINS] = PRECISION_OUTER_MUL\r\n    S: uint256 = 0\r\n    for j in range(N_COINS):\r\n        xp[j] *= Curve(crv).balances(j)\r\n        xp[j] = xp[j] * rates[j] / LENDING_PRECISION\r\n        S += xp[j]\r\n\r\n    D0: uint256 = self.get_D(A, xp)\r\n    D1: uint256 = D0 - _token_amount * D0 / total_supply\r\n    xp_reduced: uint256[N_COINS] = xp\r\n\r\n    # xp = xp - fee * | xp * D1 / D0 - (xp - S * dD / D0 * (0, ... 1, ..0))|\r\n    for j in range(N_COINS):\r\n        dx_expected: uint256 = 0\r\n        b_ideal: uint256 = xp[j] * D1 / D0\r\n        b_expected: uint256 = xp[j]\r\n        if j == i:\r\n            b_expected -= S * (D0 - D1) / D0\r\n        if b_ideal >= b_expected:\r\n            dx_expected = (b_ideal - b_expected)\r\n        else:\r\n            dx_expected = (b_expected - b_ideal)\r\n        xp_reduced[j] -= fee * dx_expected / FEE_DENOMINATOR\r\n\r\n    dy: uint256 = xp_reduced[i] - self.get_y(A, i, xp_reduced, D1)\r\n\r\n    dy_inner: uint256 = 0\r\n    if i == N_COINS - 1:\r\n        dy = dy * LENDING_PRECISION / rates[N_COINS-1]  # YToken\r\n        dy_inner = YZap(self.yzap).calc_withdraw_one_coin(dy, k - (N_COINS-1))\r\n    else:\r\n        dy = dy / precisions[i]  # Plain assets - plain results\r\n\r\n    return [dy, dy_inner]\r\n\r\n\r\n@public\r\n@constant\r\ndef calc_withdraw_one_coin(_token_amount: uint256, i: int128) -> uint256:\r\n    rates: uint256[N_COINS] = ZEROS\r\n\r\n    for j in range(N_COINS-1):\r\n        rates[j] = yERC20(self.coins[j]).getPricePerFullShare()\r\n    rates[N_COINS-1] = Curve(self.curve).get_virtual_price()\r\n\r\n    dys: uint256[2] = self._calc_withdraw_one_coin(_token_amount, i, rates)\r\n    if dys[1] == 0:\r\n        return dys[0]\r\n    else:\r\n        return dys[1]\r\n\r\n\r\n@public\r\n@constant\r\ndef calc_token_amount(amounts: uint256[N_COINS_CURVED], deposit: bool) -> uint256:\r\n    # amounts are compounded\r\n    amounts_inner: uint256[N_COINS_Y] = ZEROS_Y\r\n    amounts_outer: uint256[N_COINS] = ZEROS\r\n\r\n    y_needed: bool = False\r\n    for i in range(N_COINS_Y):\r\n        amounts_inner[i] = amounts[N_COINS - 1 + i]\r\n        if amounts_inner[i] > 0:\r\n            y_needed = True\r\n\r\n    ypool_token: uint256 = 0\r\n    if y_needed:\r\n        ypool_token = YCurve(self.ycurve).calc_token_amount(amounts_inner, deposit)\r\n\r\n    for i in range(N_COINS-1):\r\n        amounts_outer[i] = amounts[i]\r\n    amounts_outer[N_COINS-1] = ypool_token\r\n\r\n    return Curve(self.curve).calc_token_amount(amounts_outer, deposit)\r\n\r\n\r\n@private\r\n@constant\r\ndef _get_dy(i: int128, j: int128, dx_: uint256, underlying: bool) -> uint256:\r\n    assert (i >= N_COINS-1) or (j >= N_COINS-1)\r\n\r\n    dx: uint256 = dx_\r\n    if underlying:\r\n        dx = dx_ * LENDING_PRECISION / yERC20(self.coins[i]).getPricePerFullShare()\r\n\r\n    if i < N_COINS-1:\r\n        # In outer pool -> out of inner pool\r\n        dytoken_amount: uint256 = Curve(self.curve).get_dy(i, N_COINS-1, dx)\r\n        dy: uint256 = YZap(self.yzap).calc_withdraw_one_coin(dytoken_amount, j - (N_COINS-1))\r\n        if not underlying:\r\n            dy = dy * LENDING_PRECISION / yERC20(self.coins[j]).getPricePerFullShare()\r\n        return dy\r\n\r\n    else:\r\n        _ycurve: address = self.ycurve\r\n        # Deposit to inner pool -> get out of outer pool\r\n        amounts: uint256[N_COINS_Y] = ZEROS_Y\r\n        amounts[i - (N_COINS-1)] = dx\r\n        yfee: uint256 = YCurve(_ycurve).fee()\r\n        dytoken_amount: uint256 = YCurve(_ycurve).calc_token_amount(amounts, True)\r\n        # Half fee is taken for \"half an exchange\" on average (not precise)\r\n        dytoken_amount -= dytoken_amount * yfee / FEE_DENOMINATOR / 2\r\n        dy: uint256 = Curve(self.curve).get_dy(N_COINS-1, j, dytoken_amount)\r\n        if underlying:\r\n            dy = dy * yERC20(self.coins[j]).getPricePerFullShare() / LENDING_PRECISION\r\n        return dy\r\n\r\n\r\n@public\r\n@constant\r\ndef get_dy(i: int128, j: int128, dx: uint256) -> uint256:\r\n    return self._get_dy(i, j, dx, False)\r\n\r\n\r\n@public\r\n@constant\r\ndef get_dy_underlying(i: int128, j: int128, dx: uint256) -> uint256:\r\n    return self._get_dy(i, j, dx, True)\r\n\r\n\r\n@public\r\n@nonreentrant('lock')\r\ndef exchange(i: int128, j: int128, dx: uint256, min_dy: uint256):\r\n    assert (i >= N_COINS-1) or (j >= N_COINS-1)\r\n\r\n    coin_in: address = self.coins[i]\r\n    coin_out: address = self.coins[j]\r\n    assert_modifiable(ERC20(coin_in).transferFrom(msg.sender, self, dx))\r\n\r\n    _curve: address = self.curve\r\n    _yzap: address = self.yzap\r\n    _ytoken: address = self.ytoken\r\n    dy: uint256 = 0\r\n\r\n    if i < N_COINS-1:\r\n        # In outer pool -> out of inner pool\r\n        ERC20(coin_in).approve(_curve, dx)\r\n        Curve(_curve).exchange(i, N_COINS-1, dx, 0)\r\n        dytoken_amount: uint256 = ERC20(_ytoken).balanceOf(self)\r\n\r\n        # We repeat calculation of the other zap and do remove_liquidity_imbalance outselves\r\n        # in order to not wrap/unwrap twice\r\n        dy = YZap(_yzap).calc_withdraw_one_coin(dytoken_amount, j - (N_COINS-1))\r\n        amounts: uint256[N_COINS_Y] = ZEROS_Y\r\n        dy = dy * LENDING_PRECISION / yERC20(coin_out).getPricePerFullShare()\r\n        amounts[j - (N_COINS-1)] = dy\r\n\r\n        # Remove liquidity from Y\r\n        YCurve(self.ycurve).remove_liquidity_imbalance(amounts, dytoken_amount)\r\n\r\n        # Donate any dust left to LPs\r\n        dytoken_amount = ERC20(_ytoken).balanceOf(self)\r\n        if dytoken_amount > 0:\r\n            dust_amounts: uint256[N_COINS] = ZEROS\r\n            dust_amounts[N_COINS-1] = dytoken_amount\r\n            ERC20(_ytoken).approve(_curve, dytoken_amount)\r\n            Curve(_curve).donate_dust(dust_amounts)\r\n\r\n    else:\r\n        # Deposit to inner pool -> get out of outer pool\r\n        _ycurve: address = self.ycurve\r\n\r\n        # Deposit to YPool\r\n        amounts: uint256[N_COINS_Y] = ZEROS_Y\r\n        amounts[i - (N_COINS-1)] = dx\r\n        ERC20(coin_in).approve(_ycurve, dx)\r\n        YCurve(_ycurve).add_liquidity(amounts, 0)\r\n\r\n        dx_ytoken: uint256 = ERC20(_ytoken).balanceOf(self)\r\n        ERC20(_ytoken).approve(_curve, dx_ytoken)\r\n        # Exchange in outer pool\r\n        Curve(_curve).exchange(N_COINS-1, j, dx_ytoken, 0)\r\n\r\n        dy = ERC20(coin_out).balanceOf(self)\r\n\r\n    # Check if we've got enough and send\r\n    assert dy >= min_dy, \"Not enough coins produced as a result\"\r\n    assert_modifiable(ERC20(coin_out).transfer(msg.sender, dy))\r\n\r\n\r\n@public\r\n@nonreentrant('lock')\r\ndef exchange_underlying(i: int128, j: int128, dx: uint256, min_dy: uint256):\r\n    assert (i >= N_COINS-1) or (j >= N_COINS-1)\r\n    tethered: bool[N_COINS_CURVED] = TETHERED\r\n\r\n    ucoin_in: address = self.underlying_coins[i]\r\n    ucoin_out: address = self.underlying_coins[j]\r\n    if tethered[i]:\r\n        USDT(ucoin_in).transferFrom(msg.sender, self, dx)\r\n    else:\r\n        assert_modifiable(ERC20(ucoin_in).transferFrom(msg.sender, self, dx))\r\n\r\n    _curve: address = self.curve\r\n    _yzap: address = self.yzap\r\n    _ytoken: address = self.ytoken\r\n\r\n    if i < N_COINS-1:\r\n        # In outer pool -> out of inner pool\r\n        ERC20(ucoin_in).approve(_curve, dx)\r\n        Curve(_curve).exchange_underlying(i, N_COINS-1, dx, 0)\r\n        dytoken_amount: uint256 = ERC20(_ytoken).balanceOf(self)\r\n        ERC20(_ytoken).approve(_yzap, dytoken_amount)\r\n        YZap(_yzap).remove_liquidity_one_coin(dytoken_amount, j - (N_COINS-1), min_dy, True)\r\n\r\n    else:\r\n        # Deposit to inner pool -> get out of outer pool\r\n        coin_in: address = self.coins[i]\r\n        _ycurve: address = self.ycurve\r\n\r\n        # Wraps etc\r\n        ERC20(ucoin_in).approve(coin_in, dx)\r\n        yERC20(coin_in).deposit(dx)\r\n        dxc: uint256 = ERC20(coin_in).balanceOf(self)\r\n        amounts: uint256[N_COINS_Y] = ZEROS_Y\r\n        amounts[i - (N_COINS-1)] = dxc\r\n\r\n        # Deposit to YPool\r\n        ERC20(coin_in).approve(_ycurve, dxc)\r\n        YCurve(_ycurve).add_liquidity(amounts, 0)\r\n\r\n        dx_ytoken: uint256 = ERC20(_ytoken).balanceOf(self)\r\n        ERC20(_ytoken).approve(_curve, dx_ytoken)\r\n        # Exchange in outer pool\r\n        Curve(_curve).exchange_underlying(N_COINS-1, j, dx_ytoken, 0)\r\n\r\n    dy: uint256 = ERC20(ucoin_out).balanceOf(self)\r\n\r\n    # Check if we've got enough and send\r\n    assert dy >= min_dy, \"Not enough coins produced as a result\"\r\n    if tethered[j]:\r\n        USDT(ucoin_out).transfer(msg.sender, dy)\r\n    else:\r\n        assert_modifiable(ERC20(ucoin_out).transfer(msg.sender, dy))\r\n\r\n\r\n@public\r\n@nonreentrant('lock')\r\ndef remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_uamount: uint256, donate_dust: bool = False):\r\n    \"\"\"\r\n    Remove _amount of liquidity all in a form of coin i\r\n    \"\"\"\r\n    rates: uint256[N_COINS] = ZEROS\r\n    _curve: address = self.curve\r\n    _token: address = self.token\r\n    _ytoken: address = self.ytoken\r\n    k: int128 = i\r\n    if k >= N_COINS:\r\n        k = N_COINS - 1\r\n\r\n    for j in range(N_COINS-1):\r\n        rates[j] = yERC20(self.coins[j]).getPricePerFullShare()\r\n    rates[N_COINS-1] = Curve(self.curve).get_virtual_price()\r\n\r\n    # [dy_outer, dy_inner]\r\n    dys: uint256[2] = self._calc_withdraw_one_coin(_token_amount, i, rates)\r\n    dy_outer: uint256 = dys[0]\r\n    dy_inner: uint256 = dys[1]\r\n    dy: uint256 = 0\r\n    if dy_inner == 0:\r\n        dy = dy_outer\r\n    else:\r\n        dy = dy_inner\r\n    assert dy >= min_uamount, \"Not enough coins removed\"\r\n\r\n    assert_modifiable(\r\n        ERC20(self.token).transferFrom(msg.sender, self, _token_amount))\r\n\r\n    # First, remove any asset we need from SCurve pool\r\n    amounts: uint256[N_COINS] = ZEROS\r\n    if k == N_COINS - 1:\r\n        amounts[k] = dy_outer  # YToken\r\n    else:\r\n        amounts[k] = dy_outer * LENDING_PRECISION / rates[k]  # Compounded\r\n    token_amount_before: uint256 = ERC20(_token).balanceOf(self)\r\n    Curve(_curve).remove_liquidity_imbalance(amounts, _token_amount)\r\n\r\n    if k == N_COINS - 1:\r\n        # We need to withdraw from YToken\r\n        inner_amounts: uint256[N_COINS_Y] = ZEROS_Y\r\n        rate: uint256 = yERC20(self.coins[i]).getPricePerFullShare()\r\n        inner_amounts[i - (N_COINS - 1)] = dy_inner * LENDING_PRECISION / rate\r\n        YCurve(self.ycurve).remove_liquidity_imbalance(inner_amounts, dy_outer)\r\n        # We have some YToken dust, and we can donate it to LPs\r\n        amounts[k] = ERC20(_ytoken).balanceOf(self)\r\n        if amounts[k] > 0:\r\n            ERC20(_ytoken).approve(_curve, amounts[k])\r\n            Curve(_curve).donate_dust(amounts)\r\n\r\n    # Unwrap and transfer all the coins we've got\r\n    # And we really got only i-th coin\r\n    self._send_all(msg.sender, ZEROS_CURVED, i)\r\n\r\n    if not donate_dust:\r\n        # Transfer unused tokens back\r\n        token_amount_after: uint256 = ERC20(_token).balanceOf(self)\r\n        if token_amount_after > token_amount_before:\r\n            assert_modifiable(ERC20(_token).transfer(\r\n                msg.sender, token_amount_after - token_amount_before)\r\n            )\r\n\r\n\r\n@public\r\n@nonreentrant('lock')\r\ndef withdraw_donated_dust():\r\n    owner: address = Curve(self.curve).owner()\r\n    assert msg.sender == owner\r\n\r\n    _token: address = self.token\r\n    assert_modifiable(\r\n        ERC20(_token).transfer(owner, ERC20(_token).balanceOf(self)))","ABI":"[{\"outputs\":[],\"inputs\":[{\"type\":\"address[2]\",\"name\":\"_coins\"},{\"type\":\"address[2]\",\"name\":\"_underlying_coins\"},{\"type\":\"address\",\"name\":\"_curve\"},{\"type\":\"address\",\"name\":\"_token\"},{\"type\":\"address\",\"name\":\"_yzap\"}],\"constant\":false,\"payable\":false,\"type\":\"constructor\"},{\"name\":\"add_liquidity\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256[5]\",\"name\":\"uamounts\"},{\"type\":\"uint256\",\"name\":\"min_mint_amount\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":187139},{\"name\":\"remove_liquidity\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"uint256[5]\",\"name\":\"min_uamounts\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":115804},{\"name\":\"remove_liquidity_imbalance\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256[5]\",\"name\":\"uamounts\"},{\"type\":\"uint256\",\"name\":\"max_burn_amount\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":145631},{\"name\":\"calc_withdraw_one_coin\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_token_amount\"},{\"type\":\"int128\",\"name\":\"i\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2949022},{\"name\":\"calc_token_amount\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256[5]\",\"name\":\"amounts\"},{\"type\":\"bool\",\"name\":\"deposit\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":10255},{\"name\":\"get_dy\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"int128\",\"name\":\"i\"},{\"type\":\"int128\",\"name\":\"j\"},{\"type\":\"uint256\",\"name\":\"dx\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":18250},{\"name\":\"get_dy_underlying\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"int128\",\"name\":\"i\"},{\"type\":\"int128\",\"name\":\"j\"},{\"type\":\"uint256\",\"name\":\"dx\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":18280},{\"name\":\"exchange\",\"outputs\":[],\"inputs\":[{\"type\":\"int128\",\"name\":\"i\"},{\"type\":\"int128\",\"name\":\"j\"},{\"type\":\"uint256\",\"name\":\"dx\"},{\"type\":\"uint256\",\"name\":\"min_dy\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":82385},{\"name\":\"exchange_underlying\",\"outputs\":[],\"inputs\":[{\"type\":\"int128\",\"name\":\"i\"},{\"type\":\"int128\",\"name\":\"j\"},{\"type\":\"uint256\",\"name\":\"dx\"},{\"type\":\"uint256\",\"name\":\"min_dy\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":81992},{\"name\":\"remove_liquidity_one_coin\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_token_amount\"},{\"type\":\"int128\",\"name\":\"i\"},{\"type\":\"uint256\",\"name\":\"min_uamount\"}],\"constant\":false,\"payable\":false,\"type\":\"function\"},{\"name\":\"remove_liquidity_one_coin\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_token_amount\"},{\"type\":\"int128\",\"name\":\"i\"},{\"type\":\"uint256\",\"name\":\"min_uamount\"},{\"type\":\"bool\",\"name\":\"donate_dust\"}],\"constant\":false,\"payable\":false,\"type\":\"function\"},{\"name\":\"withdraw_donated_dust\",\"outputs\":[],\"inputs\":[],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":64123},{\"name\":\"coins\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"int128\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1830},{\"name\":\"underlying_coins\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"int128\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1860},{\"name\":\"curve\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1691},{\"name\":\"token\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1721},{\"name\":\"ycurve\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1751},{\"name\":\"ytoken\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1781},{\"name\":\"yzap\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1811}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.1.0b17","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000f61718057901f84c4eec4339ef8f0d86d2b45600000000000000000000000000df5e0e81dff6faf3a7e52ba697820c5e32d806a800000000000000000000000057ab1ec28d129707052df4df418d58a2d46d5f5100000000000000000000000045f783cce6b7ff23b2ab2d70e416cdb7d6055f51000000000000000000000000edf54bc005bc2df0cc6a675596e843d28b16a9660000000000000000000000002b645a6a426f22fb7954dc15e583e3737b8d1434000000000000000000000000bbc81d23ea2c3ec7e56d39296f0cbb648873a5d3","Library":"","LicenseType":"None","SwarmSource":""}]}