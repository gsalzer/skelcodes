{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\ncontract Revolution {\r\n\r\n  address public owner = msg.sender;\r\n  \r\n  // Criteria the citizen should match to win votes\r\n  // e.g. : \"a sans-culotte\"\r\n  string public criteria;\r\n\r\n  // Minimum number of blocks before next cake distribution from the Revolution\r\n  uint public distributionBlockPeriod;\r\n\r\n  // Amount of WEI to be distributed to each citizen matching criteria\r\n  uint public distributionAmount;\r\n\r\n  // Number of the block at last distribution\r\n  uint lastDistributionBlockNumber;\r\n\r\n  // Will this Revolution randomly close its trials ?\r\n  bool public withLottery;\r\n\r\n  // Will this Revolution automatically consider distributing cakes after each vote ?\r\n  bool public withDistribution;\r\n  \r\n  // Is this Revolution irreversibly locked (end of life) ?\r\n  \r\n  bool public locked;\r\n\r\n  // For a given citizen, let's put all positive (or negative) votes\r\n  // received into a positive (or negative) justice scale.\r\n  struct JusticeScale {\r\n    address payable [] voters;\r\n    mapping (address => uint) votes;\r\n    uint amount;\r\n  }\r\n\r\n  // This the revolutionary trial for a given citizen\r\n  struct Trial {\r\n    address payable citizen;\r\n    JusticeScale sansculotteScale;\r\n    JusticeScale privilegedScale;\r\n    uint lastClosingAttemptBlock;\r\n    bool opened;\r\n    bool matchesCriteria;\r\n  }\r\n\r\n  // Citizens known at this Revolution\r\n  address payable [] public citizens;\r\n  // Trials known at this Revolution\r\n  mapping (address => Trial) private trials;\r\n\r\n  // This is the amount of cakes in the Bastille\r\n  uint public bastilleBalance;\r\n\r\n  // Start of new trial for a given citizen\r\n  event TrialOpened(string indexed _eventName, address indexed _citizen);\r\n  // End of trial for a given citizen\r\n  event TrialClosed(string indexed _eventName, address indexed _citizen);\r\n  // New cake-vote received for a given citizen\r\n  event VoteReceived(string indexed _eventName, address _from, address indexed _citizen, bool _vote, uint indexed _amount);\r\n  // \r\n  event Distribution(string indexed _eventName, address indexed _citizen, uint _distributionAmount);\r\n\r\n\r\n  constructor(string memory _criteria, uint _distributionBlockPeriod, uint _distributionAmount, bool _withLottery, bool _withDistribution) public{\r\n    criteria = _criteria;\r\n    distributionBlockPeriod = _distributionBlockPeriod;\r\n    distributionAmount = _distributionAmount;\r\n    lastDistributionBlockNumber = block.number;\r\n    withLottery = _withLottery;\r\n    withDistribution = _withDistribution;\r\n    locked = false;\r\n  }\r\n\r\n  function lock() public {\r\n    // will irreversibly lock this Revolution\r\n    // only contract owner can lock\r\n    require(msg.sender == owner);\r\n    locked = true;\r\n  }\r\n\r\n  function vote(bool _vote, address payable _citizen) public payable {\r\n    require(locked == false || bastilleBalance > 0);\r\n    Trial storage trial = trials[_citizen];\r\n    trial.opened = true;\r\n    if (trial.citizen == address(0x0) ) {\r\n      // this is a new trial, emit an event\r\n      emit TrialOpened('TrialOpened', _citizen);\r\n      citizens.push(_citizen);\r\n      trial.citizen = _citizen;\r\n    }\r\n\r\n    JusticeScale storage scale = trial.sansculotteScale;\r\n    if (_vote == false) {\r\n      scale = trial.privilegedScale;\r\n    }\r\n    scale.voters.push(msg.sender);\r\n    scale.votes[msg.sender] += msg.value;\r\n    scale.amount+= msg.value;\r\n\r\n    emit VoteReceived('VoteReceived', msg.sender, _citizen, _vote, msg.value);\r\n\r\n    if(withLottery == true\r\n      && block.number > trial.lastClosingAttemptBlock + distributionBlockPeriod/3) {\r\n      // update trial block number\r\n      trial.lastClosingAttemptBlock = block.number;\r\n      // start closing trial lottery\r\n      if(closingLottery() == true) {\r\n        emit TrialClosed('TrialClosed', _citizen);\r\n        closeTrial(_citizen);\r\n      }\r\n    }\r\n\r\n    if(withDistribution == true) {\r\n      distribute();\r\n    }\r\n  }\r\n\r\n  function closeTrial(address payable _citizen) public {\r\n    Trial storage trial = trials[_citizen];\r\n    // Mark the trial as closed\r\n    trial.opened = false;\r\n    // Issue a verdict : is this citizen a sans-culotte or a privileged ?\r\n    // By default, citizens are seen as privileged...\r\n    JusticeScale storage winnerScale = trial.privilegedScale;\r\n    JusticeScale storage loserScale = trial.sansculotteScale;\r\n    trial.matchesCriteria = false;\r\n    // .. unless they get more votes on their sans-culotte scale than on their privileged scale.\r\n    if (trial.sansculotteScale.amount > trial.privilegedScale.amount) {\r\n      winnerScale = trial.sansculotteScale;\r\n      loserScale = trial.privilegedScale;\r\n      trial.matchesCriteria = true;\r\n    }\r\n\r\n    // Compute Bastille virtual vote\r\n    uint bastilleVote = winnerScale.amount - loserScale.amount;\r\n\r\n    // Distribute cakes to winners as rewards\r\n    // Side note : the reward scheme slightly differs from the culottes board game rules\r\n    // regarding the way decimal fractions of cakes to be given as rewards to winners are managed.\r\n    // The board game stipulates that fractions are rounded to the nearest integer and reward cakes\r\n    // are given in the descending order of winners (bigger winners first). But the code below\r\n    // states that only the integer part of reward cakes is taken into account. And the remaining\r\n    // reward cakes are put back into the Bastille. This slightly lessens the number of cakes\r\n    // rewarded to winners and slightly increases the number of cakes given to the Bastille.\r\n    // The main advantage is that it simplifies the algorithm a bit.\r\n    // But this rounding difference should not matter when dealing with Weis instead of real cakes.\r\n    uint remainingRewardCakes = loserScale.amount;\r\n    for (uint i = 0; i < winnerScale.voters.length; i++) {\r\n      address payable voter = winnerScale.voters[i];\r\n      // First distribute cakes from the winner scale, also known as winning cakes\r\n      // How many cakes did this voter put on the winnerScale ?\r\n      uint winningCakes = winnerScale.votes[voter];\r\n      // Send them back\r\n      winnerScale.votes[voter]=0;\r\n      // FIXME : handle the case of failure to send winningCakes\r\n      voter.send(winningCakes);\r\n      // How many cakes from the loser scale are to be rewarded to this winner citizen ?\r\n      // Rewards should be a share of the lost cakes that is proportionate to the fraction of\r\n      // winning cakes that were voted by this voting citizen, pretending that the Bastille\r\n      // itself took part in the vote.\r\n      uint rewardCakes = loserScale.amount * winningCakes / ( winnerScale.amount + bastilleVote );\r\n      // Send their fair share of lost cakes as reward.\r\n      // FIXME : handle the failure of sending rewardCakes\r\n      voter.send(rewardCakes);\r\n      remainingRewardCakes -= rewardCakes;\r\n    }\r\n   \r\n    // distribute cakes to the Bastille\r\n    bastilleBalance += remainingRewardCakes;\r\n\r\n    // Empty the winner scale\r\n    winnerScale.amount = 0;\r\n\r\n    // Empty the loser scale\r\n    for (uint i = 0; i < loserScale.voters.length; i++) {\r\n      address payable voter = loserScale.voters[i];\r\n      loserScale.votes[voter]=0;\r\n    }\r\n    loserScale.amount = 0;\r\n\r\n  }\r\n\r\n  function distribute() public {\r\n    // Did the last distribution happen long enough ago ?\r\n    if  (block.number - lastDistributionBlockNumber < distributionBlockPeriod) {\r\n      return;\r\n    }\r\n    // For each citizen trial\r\n    for (uint i = 0; i < citizens.length; i++) {\r\n      address payable citizen = citizens[i];\r\n      Trial memory trial = trials[citizen];\r\n      // Is the trial closed ?\r\n      // and Was the verdict \"sans-culotte\" (citizen does match criteria according to winners) ?\r\n      // and Does the Bastille have more cakes left than the amount to be distributed ?\r\n      if (trial.opened == false &&\r\n          trial.matchesCriteria == true ) {\r\n        uint distributed = 0;\r\n        if (bastilleBalance >= distributionAmount) {\r\n          distributed = distributionAmount;\r\n        } else {\r\n          if (locked == true) {\r\n            distributed = bastilleBalance;\r\n          }\r\n        }\r\n        // Then send this sans-culotte its fair share of Bastille cakes.\r\n        if (distributed > 0) {\r\n          if (citizen.send(distributed)) {\r\n            bastilleBalance -= distributed;\r\n            emit Distribution('Distribution', citizen, distributed);\r\n          } else {\r\n            // sending failed, maybe citizen is a smart contract with an expensive fallback function ?\r\n            emit Distribution('Distribution', citizen, 0);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Remember when this distribution happened.\r\n    lastDistributionBlockNumber = block.number;\r\n  }\r\n\r\n  function getScaleAmount(bool _vote, address _citizen) public view returns (uint){\r\n    Trial storage trial = trials[_citizen]; \r\n    if (_vote == true)\r\n      return trial.sansculotteScale.amount;\r\n    else\r\n      return trial.privilegedScale.amount;\r\n  }\r\n\r\n  function closingLottery() private view returns (bool) {\r\n    // returns true with a 30% probability ; false otherwise\r\n    uint randomHash = uint(keccak256(abi.encodePacked(block.difficulty,block.timestamp)));\r\n    uint res = randomHash % 10;\r\n    if(res < 4) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function trialStatus(address _citizen) public view returns(bool opened, bool matchesCriteria, uint sansculotteScale, uint privilegedScale) {\r\n    Trial memory trial = trials[_citizen];\r\n    return (trial.opened, trial.matchesCriteria, trial.sansculotteScale.amount, trial.privilegedScale.amount);\r\n  }\r\n\r\n  function() payable external {\r\n    require(locked == false);\r\n    bastilleBalance += msg.value;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"withDistribution\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"citizens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_citizen\",\"type\":\"address\"}],\"name\":\"trialStatus\",\"outputs\":[{\"name\":\"opened\",\"type\":\"bool\"},{\"name\":\"matchesCriteria\",\"type\":\"bool\"},{\"name\":\"sansculotteScale\",\"type\":\"uint256\"},{\"name\":\"privilegedScale\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withLottery\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributionBlockPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vote\",\"type\":\"bool\"},{\"name\":\"_citizen\",\"type\":\"address\"}],\"name\":\"vote\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_citizen\",\"type\":\"address\"}],\"name\":\"closeTrial\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"criteria\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributionAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bastilleBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vote\",\"type\":\"bool\"},{\"name\":\"_citizen\",\"type\":\"address\"}],\"name\":\"getScaleAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"distribute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_criteria\",\"type\":\"string\"},{\"name\":\"_distributionBlockPeriod\",\"type\":\"uint256\"},{\"name\":\"_distributionAmount\",\"type\":\"uint256\"},{\"name\":\"_withLottery\",\"type\":\"bool\"},{\"name\":\"_withDistribution\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_eventName\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"_citizen\",\"type\":\"address\"}],\"name\":\"TrialOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_eventName\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"_citizen\",\"type\":\"address\"}],\"name\":\"TrialClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_eventName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_citizen\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_vote\",\"type\":\"bool\"},{\"indexed\":true,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"VoteReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_eventName\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"_citizen\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_distributionAmount\",\"type\":\"uint256\"}],\"name\":\"Distribution\",\"type\":\"event\"}]","ContractName":"Revolution","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000001680000000000000000000000000000000000000000000000000016345785d8a00000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000646120706572736f6e2077686f20686173206265656e206f6e65206f662074686520746f702033206d6f737420646573657276696e6720636f6e7472696275746f727320746f20746869732064617070206f76657220746865206c6173742037206461797300000000000000000000000000000000000000000000000000000000","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://a7196d3a986fff48be9a470795f3507ec86e3001c44691cd8203973f639e47cd"}]}