{"status":"1","message":"OK","result":[{"SourceCode":"{\"IBancorNetwork.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ncontract IBancorNetwork {\\n    // to get rate, return dest amount + fee amount\\n    function getReturnByPath(IERC20[] calldata _path, uint256 _amount) external view returns (uint256, uint256);\\n    // to convert ETH to token, return dest amount\\n    function convert2(\\n        IERC20[] calldata _path,\\n        uint256 _amount,\\n        uint256 _minReturn,\\n        address _affiliateAccount,\\n        uint256 _affiliateFee\\n    ) external payable returns (uint256);\\n\\n    // to convert token to ETH, return dest amount\\n    function claimAndConvert2(\\n        IERC20[] calldata _path,\\n        uint256 _amount,\\n        uint256 _minReturn,\\n        address _affiliateAccount,\\n        uint256 _affiliateFee\\n    ) external returns (uint256);\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\n\\ninterface IERC20 {\\n    function transfer(address _to, uint _value) external returns (bool success);\\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\\n    function approve(address _spender, uint _value) external returns (bool success);\\n    function totalSupply() external view returns (uint supply);\\n    function balanceOf(address _owner) external view returns (uint balance);\\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\\n    function decimals() external view returns(uint digits);\\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\\n}\\n\"},\"IKyberReserve.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n\\n/// @title Kyber Reserve contract\\ninterface IKyberReserve {\\n\\n    function trade(\\n        IERC20 srcToken,\\n        uint srcAmount,\\n        IERC20 destToken,\\n        address payable destAddress,\\n        uint conversionRate,\\n        bool validate\\n    )\\n        external\\n        payable\\n        returns(bool);\\n\\n    function getConversionRate(IERC20 src, IERC20 dest, uint srcQty, uint blockNumber) external view returns(uint);\\n}\\n\"},\"KyberBancorReserve.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IKyberReserve.sol\\\";\\nimport \\\"./WithdrawableV5.sol\\\";\\nimport \\\"./UtilsV5.sol\\\";\\nimport \\\"./IBancorNetwork.sol\\\";\\n\\ncontract KyberBancorReserve is IKyberReserve, Withdrawable, Utils {\\n\\n    uint constant internal BPS = 10000; // 10^4\\n    uint constant ETH_BNT_DECIMALS = 18;\\n\\n    address public kyberNetwork;\\n    bool public tradeEnabled;\\n    uint public feeBps;\\n\\n    IBancorNetwork public bancorNetwork; // 0x3ab6564d5c214bc416ee8421e05219960504eead\\n\\n    // IERC20 public bancorEth; // 0xc0829421C1d260BD3cB3E0F06cfE2D52db2cE315\\n    // IERC20 public bancorETHBNT; // 0xb1CD6e4153B2a390Cf00A6556b0fC1458C4A5533\\n    IERC20 public bancorToken; // 0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C\\n    IERC20[] public ethToBntPath;\\n    IERC20[] public bntToEthPath;\\n\\n    constructor(\\n        address _bancorNetwork,\\n        address _kyberNetwork,\\n        uint _feeBps,\\n        address _bancorToken,\\n        address _admin\\n    )\\n        public\\n    {\\n        require(_bancorNetwork != address(0), \\\"constructor: bancorNetwork address is missing\\\");\\n        require(_kyberNetwork != address(0), \\\"constructor: kyberNetwork address is missing\\\");\\n        require(_bancorToken != address(0), \\\"constructor: bancorToken address is missing\\\");\\n        require(_admin != address(0), \\\"constructor: admin address is missing\\\");\\n        require(_feeBps \\u003c BPS, \\\"constructor: fee is too big\\\");\\n\\n        bancorNetwork = IBancorNetwork(_bancorNetwork);\\n        bancorToken = IERC20(_bancorToken);\\n        tradeEnabled = true;\\n\\n        require(bancorToken.approve(address(bancorNetwork), 2 ** 255));\\n    }\\n\\n    function() external payable { }\\n\\n    function getConversionRate(IERC20 src, IERC20 dest, uint srcQty, uint) public view returns(uint) {\\n        if (!tradeEnabled) { return 0; }\\n        if (srcQty == 0) { return 0; }\\n\\n        if (src != ETH_TOKEN_ADDRESS \\u0026\\u0026 dest != ETH_TOKEN_ADDRESS) {\\n            return 0; // either src or dest must be ETH\\n        }\\n        IERC20 token = src == ETH_TOKEN_ADDRESS ? dest : src;\\n        if (token != bancorToken) { return 0; } // not BNT token\\n\\n        IERC20[] memory path = getConversionPath(src, dest);\\n\\n        uint destQty;\\n        (destQty, ) = bancorNetwork.getReturnByPath(path, srcQty);\\n\\n        // src and dest can be only BNT or ETH\\n        uint rate = calcRateFromQty(srcQty, destQty, ETH_BNT_DECIMALS, ETH_BNT_DECIMALS);\\n\\n        rate = valueAfterReducingFee(rate);\\n\\n        return rate;\\n    }\\n\\n    event TradeExecute(\\n        address indexed sender,\\n        address src,\\n        uint srcAmount,\\n        address destToken,\\n        uint destAmount,\\n        address payable destAddress\\n    );\\n\\n    function trade(\\n        IERC20 srcToken,\\n        uint srcAmount,\\n        IERC20 destToken,\\n        address payable destAddress,\\n        uint conversionRate,\\n        bool validate\\n    )\\n        public\\n        payable\\n        returns(bool)\\n    {\\n\\n        require(tradeEnabled, \\\"trade: trade is not enabled\\\");\\n        require(msg.sender == kyberNetwork, \\\"trade: sender is not network\\\");\\n        require(srcAmount \\u003e 0, \\\"trade: src amount must be greater than 0\\\");\\n        require(srcToken == ETH_TOKEN_ADDRESS || destToken == ETH_TOKEN_ADDRESS, \\\"trade: src or dest must be ETH\\\");\\n        require(srcToken == bancorToken || destToken == bancorToken, \\\"trade: src or dest must be BNT\\\");\\n\\n        require(doTrade(srcToken, srcAmount, destToken, destAddress, conversionRate, validate), \\\"trade: doTrade function returns false\\\");\\n\\n        return true;\\n    }\\n\\n    event KyberNetworkSet(address kyberNetwork);\\n\\n    function setKyberNetwork(address _kyberNetwork) public onlyAdmin {\\n        require(_kyberNetwork != address(0), \\\"setKyberNetwork: kyberNetwork address is missing\\\");\\n\\n        kyberNetwork = _kyberNetwork;\\n        emit KyberNetworkSet(_kyberNetwork);\\n    }\\n\\n    event BancorNetworkSet(address _bancorNetwork);\\n\\n    function setBancorContract(address _bancorNetwork) public onlyAdmin {\\n        require(_bancorNetwork != address(0), \\\"setBancorContract: bancorNetwork address is missing\\\");\\n\\n        if (address(bancorNetwork) != address(0)) {\\n            require(bancorToken.approve(address(bancorNetwork), 0), \\\"setBancorContract: can not reset approve token\\\");\\n        }\\n        bancorNetwork = IBancorNetwork(_bancorNetwork);\\n        require(bancorToken.approve(address(bancorNetwork), 2 ** 255), \\\"setBancorContract: can not approve token\\\");\\n\\n        emit BancorNetworkSet(_bancorNetwork);\\n    }\\n\\n    event FeeBpsSet(uint feeBps);\\n\\n    function setFeeBps(uint _feeBps) public onlyAdmin {\\n        require(_feeBps \\u003c BPS, \\\"setFeeBps: feeBps \\u003e= BPS\\\");\\n\\n        feeBps = _feeBps;\\n        emit FeeBpsSet(feeBps);\\n    }\\n\\n    event TradeEnabled(bool enable);\\n\\n    function enableTrade() public onlyAdmin returns(bool) {\\n        tradeEnabled = true;\\n        emit TradeEnabled(true);\\n\\n        return true;\\n    }\\n\\n    event NewPathsSet(IERC20[] ethToBntPath, IERC20[] bntToEthPath);\\n\\n    function setNewEthBntPath(IERC20[] memory _ethToBntPath, IERC20[] memory _bntToEthPath) public onlyAdmin {\\n        require(_ethToBntPath.length != 0, \\\"setNewEthBntPath: path should have some elements\\\");\\n        require(_bntToEthPath.length != 0, \\\"setNewEthBntPath: path should have some elements\\\");\\n        ethToBntPath = _ethToBntPath;\\n        bntToEthPath = _bntToEthPath;\\n        emit NewPathsSet(_ethToBntPath, _bntToEthPath);\\n    }\\n\\n    function disableTrade() public onlyAlerter returns(bool) {\\n        tradeEnabled = false;\\n        emit TradeEnabled(false);\\n\\n        return true;\\n    }\\n\\n    function doTrade(\\n        IERC20 srcToken,\\n        uint srcAmount,\\n        IERC20 destToken,\\n        address payable destAddress,\\n        uint conversionRate,\\n        bool validate\\n    )\\n        internal\\n        returns(bool)\\n    {\\n        // can skip validation if done at kyber network level\\n        if (validate) {\\n            require(conversionRate \\u003e 0);\\n            if (srcToken == ETH_TOKEN_ADDRESS)\\n                require(msg.value == srcAmount, \\\"doTrade: msg value is not correct for ETH trade\\\");\\n            else\\n                require(msg.value == 0, \\\"doTrade: msg value is not correct for token trade\\\");\\n        }\\n\\n        if (srcToken != ETH_TOKEN_ADDRESS) {\\n            // collect source amount\\n            require(srcToken.transferFrom(msg.sender, address(this), srcAmount), \\\"doTrade: collect src token failed\\\");\\n        }\\n\\n        IERC20[] memory path = getConversionPath(srcToken, destToken);\\n        require(path.length \\u003e 0, \\\"doTrade: couldn\\u0027t find path\\\");\\n\\n        // BNT and ETH have the same decimals\\n        uint userExpectedDestAmount = calcDstQty(srcAmount, ETH_BNT_DECIMALS, ETH_BNT_DECIMALS, conversionRate);\\n        require(userExpectedDestAmount \\u003e 0, \\\"doTrade: user expected amount must be greater than 0\\\");\\n        uint destAmount;\\n\\n        if (srcToken == ETH_TOKEN_ADDRESS) {\\n            destAmount = bancorNetwork.convert2.value(srcAmount)(path, srcAmount, userExpectedDestAmount, address(0), 0);\\n        } else {\\n            destAmount = bancorNetwork.claimAndConvert2(path, srcAmount, userExpectedDestAmount, address(0), 0);\\n        }\\n\\n        require(destAmount \\u003e= userExpectedDestAmount, \\\"doTrade: dest amount is lower than expected amount\\\");\\n\\n        // transfer back only expected dest amount\\n        if (destToken == ETH_TOKEN_ADDRESS) {\\n            destAddress.transfer(userExpectedDestAmount);\\n        } else {\\n            require(destToken.transfer(destAddress, userExpectedDestAmount), \\\"doTrade: transfer back dest token failed\\\");\\n        }\\n\\n        emit TradeExecute(msg.sender, address(srcToken), srcAmount, address(destToken), userExpectedDestAmount, destAddress);\\n        return true;\\n    }\\n\\n    function getConversionPath(IERC20 src, IERC20 dest) public view returns(IERC20[] memory path) {\\n        if (src == bancorToken) {\\n            path = bntToEthPath;\\n        } else if (dest == bancorToken) {\\n            path = ethToBntPath;\\n        }\\n        return path;\\n    }\\n\\n    function valueAfterReducingFee(uint val) internal view returns(uint) {\\n        require(val \\u003c= MAX_QTY, \\\"valueAfterReducingFee: val \\u003e MAX_QTY\\\");\\n        return ((BPS - feeBps) * val) / BPS;\\n    }\\n}\\n\"},\"PermissionGroupsV5.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\n\\ncontract PermissionGroups {\\n\\n    address public admin;\\n    address public pendingAdmin;\\n    mapping(address=\\u003ebool) internal operators;\\n    mapping(address=\\u003ebool) internal alerters;\\n    address[] internal operatorsGroup;\\n    address[] internal alertersGroup;\\n    uint constant internal MAX_GROUP_SIZE = 50;\\n\\n    constructor() public {\\n        admin = msg.sender;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin);\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(operators[msg.sender]);\\n        _;\\n    }\\n\\n    modifier onlyAlerter() {\\n        require(alerters[msg.sender]);\\n        _;\\n    }\\n\\n    function getOperators () external view returns(address[] memory) {\\n        return operatorsGroup;\\n    }\\n\\n    function getAlerters () external view returns(address[] memory) {\\n        return alertersGroup;\\n    }\\n\\n    event TransferAdminPending(address pendingAdmin);\\n\\n    /**\\n     * @dev Allows the current admin to set the pendingAdmin address.\\n     * @param newAdmin The address to transfer ownership to.\\n     */\\n    function transferAdmin(address newAdmin) public onlyAdmin {\\n        require(newAdmin != address(0));\\n        emit TransferAdminPending(pendingAdmin);\\n        pendingAdmin = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\\n     * @param newAdmin The address to transfer ownership to.\\n     */\\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\\n        require(newAdmin != address(0));\\n        emit TransferAdminPending(newAdmin);\\n        emit AdminClaimed(newAdmin, admin);\\n        admin = newAdmin;\\n    }\\n\\n    event AdminClaimed( address newAdmin, address previousAdmin);\\n\\n    /**\\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\\n     */\\n    function claimAdmin() public {\\n        require(pendingAdmin == msg.sender);\\n        emit AdminClaimed(pendingAdmin, admin);\\n        admin = pendingAdmin;\\n        pendingAdmin = address(0);\\n    }\\n\\n    event AlerterAdded (address newAlerter, bool isAdd);\\n\\n    function addAlerter(address newAlerter) public onlyAdmin {\\n        require(!alerters[newAlerter]); // prevent duplicates.\\n        require(alertersGroup.length \\u003c MAX_GROUP_SIZE);\\n\\n        emit AlerterAdded(newAlerter, true);\\n        alerters[newAlerter] = true;\\n        alertersGroup.push(newAlerter);\\n    }\\n\\n    function removeAlerter (address alerter) public onlyAdmin {\\n        require(alerters[alerter]);\\n        alerters[alerter] = false;\\n\\n        for (uint i = 0; i \\u003c alertersGroup.length; ++i) {\\n            if (alertersGroup[i] == alerter) {\\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\\n                alertersGroup.length--;\\n                emit AlerterAdded(alerter, false);\\n                break;\\n            }\\n        }\\n    }\\n\\n    event OperatorAdded(address newOperator, bool isAdd);\\n\\n    function addOperator(address newOperator) public onlyAdmin {\\n        require(!operators[newOperator]); // prevent duplicates.\\n        require(operatorsGroup.length \\u003c MAX_GROUP_SIZE);\\n\\n        emit OperatorAdded(newOperator, true);\\n        operators[newOperator] = true;\\n        operatorsGroup.push(newOperator);\\n    }\\n\\n    function removeOperator (address operator) public onlyAdmin {\\n        require(operators[operator]);\\n        operators[operator] = false;\\n\\n        for (uint i = 0; i \\u003c operatorsGroup.length; ++i) {\\n            if (operatorsGroup[i] == operator) {\\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\\n                operatorsGroup.length -= 1;\\n                emit OperatorAdded(operator, false);\\n                break;\\n            }\\n        }\\n    }\\n}\\n\"},\"UtilsV5.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n\\n/// @title Kyber utils and utils2 contracts\\ncontract Utils {\\n\\n    IERC20 constant internal ETH_TOKEN_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\n    uint  constant internal PRECISION = (10**18);\\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\\n    uint  constant internal MAX_DECIMALS = 18;\\n    uint  constant internal ETH_DECIMALS = 18;\\n\\n    mapping(address=\\u003euint) internal decimals;\\n\\n    /// @dev get the balance of a user.\\n    /// @param token The token type\\n    /// @return The balance\\n    function getBalance(IERC20 token, address user) public view returns(uint) {\\n        if (token == ETH_TOKEN_ADDRESS)\\n            return user.balance;\\n        else\\n            return token.balanceOf(user);\\n    }\\n\\n    function setDecimals(IERC20 token) internal {\\n        if (token == ETH_TOKEN_ADDRESS)\\n            decimals[address(token)] = ETH_DECIMALS;\\n        else\\n            decimals[address(token)] = token.decimals();\\n    }\\n\\n    function getDecimals(IERC20 token) internal view returns(uint) {\\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\\n        uint tokenDecimals = decimals[address(token)];\\n        // moreover, very possible that old tokens have decimals 0\\n        // these tokens will just have higher gas fees.\\n        if (tokenDecimals == 0) return token.decimals();\\n\\n        return tokenDecimals;\\n    }\\n\\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\\n        require(srcQty \\u003c= MAX_QTY);\\n        require(rate \\u003c= MAX_RATE);\\n\\n        if (dstDecimals \\u003e= srcDecimals) {\\n            require((dstDecimals - srcDecimals) \\u003c= MAX_DECIMALS);\\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\\n        } else {\\n            require((srcDecimals - dstDecimals) \\u003c= MAX_DECIMALS);\\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\\n        }\\n    }\\n\\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\\n        require(dstQty \\u003c= MAX_QTY);\\n        require(rate \\u003c= MAX_RATE);\\n\\n        //source quantity is rounded up. to avoid dest quantity being too low.\\n        uint numerator;\\n        uint denominator;\\n        if (srcDecimals \\u003e= dstDecimals) {\\n            require((srcDecimals - dstDecimals) \\u003c= MAX_DECIMALS);\\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\\n            denominator = rate;\\n        } else {\\n            require((dstDecimals - srcDecimals) \\u003c= MAX_DECIMALS);\\n            numerator = (PRECISION * dstQty);\\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\\n        }\\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\\n    }\\n\\n    function calcDestAmount(IERC20 src, IERC20 dest, uint srcAmount, uint rate) internal view returns(uint) {\\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\\n    }\\n\\n    function calcSrcAmount(IERC20 src, IERC20 dest, uint destAmount, uint rate) internal view returns(uint) {\\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\\n    }\\n\\n    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\\n        internal pure returns(uint)\\n    {\\n        require(srcAmount \\u003c= MAX_QTY);\\n        require(destAmount \\u003c= MAX_QTY);\\n\\n        if (dstDecimals \\u003e= srcDecimals) {\\n            require((dstDecimals - srcDecimals) \\u003c= MAX_DECIMALS);\\n            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\\n        } else {\\n            require((srcDecimals - dstDecimals) \\u003c= MAX_DECIMALS);\\n            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\\n        }\\n    }\\n\\n    function minOf(uint x, uint y) internal pure returns(uint) {\\n        return x \\u003e y ? y : x;\\n    }\\n}\\n\"},\"WithdrawableV5.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./PermissionGroupsV5.sol\\\";\\n\\n\\ncontract Withdrawable is PermissionGroups {\\n\\n    event TokenWithdraw(IERC20 token, uint amount, address sendTo);\\n\\n    /**\\n     * @dev Withdraw all IERC20 compatible tokens\\n     * @param token IERC20 The address of the token contract\\n     */\\n    function withdrawToken(IERC20 token, uint amount, address sendTo) external onlyAdmin {\\n        require(token.transfer(sendTo, amount));\\n        emit TokenWithdraw(token, amount, sendTo);\\n    }\\n\\n    event EtherWithdraw(uint amount, address sendTo);\\n\\n    /**\\n     * @dev Withdraw Ethers\\n     */\\n    function withdrawEther(uint amount, address payable sendTo) external onlyAdmin {\\n        sendTo.transfer(amount);\\n        emit EtherWithdraw(amount, sendTo);\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"enableTrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"alerter\",\"type\":\"address\"}],\"name\":\"removeAlerter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bancorToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAlerter\",\"type\":\"address\"}],\"name\":\"addAlerter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_kyberNetwork\",\"type\":\"address\"}],\"name\":\"setKyberNetwork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableTrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"destAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"conversionRate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"validate\",\"type\":\"bool\"}],\"name\":\"trade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeBps\",\"type\":\"uint256\"}],\"name\":\"setFeeBps\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"dest\",\"type\":\"address\"}],\"name\":\"getConversionPath\",\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdminQuickly\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAlerters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcQty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getConversionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"_ethToBntPath\",\"type\":\"address[]\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"_bntToEthPath\",\"type\":\"address[]\"}],\"name\":\"setNewEthBntPath\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ethToBntPath\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bntToEthPath\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bancorNetwork\",\"outputs\":[{\"internalType\":\"contract IBancorNetwork\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kyberNetwork\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradeEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bancorNetwork\",\"type\":\"address\"}],\"name\":\"setBancorContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bancorNetwork\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_kyberNetwork\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeBps\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_bancorToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"destAddress\",\"type\":\"address\"}],\"name\":\"TradeExecute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"kyberNetwork\",\"type\":\"address\"}],\"name\":\"KyberNetworkSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_bancorNetwork\",\"type\":\"address\"}],\"name\":\"BancorNetworkSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeBps\",\"type\":\"uint256\"}],\"name\":\"FeeBpsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"TradeEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20[]\",\"name\":\"ethToBntPath\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"contract IERC20[]\",\"name\":\"bntToEthPath\",\"type\":\"address[]\"}],\"name\":\"NewPathsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"TokenWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"EtherWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdminPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"AdminClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAlerter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"AlerterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"}]","ContractName":"KyberBancorReserve","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003ab6564d5c214bc416ee8421e05219960504eead000000000000000000000000be2f0354d970265bfc36d383af77f72736b81b5400000000000000000000000000000000000000000000000000000000000000010000000000000000000000001f573d6fb3f13d689ff844b4ce37794d79a7ff1c000000000000000000000000be2f0354d970265bfc36d383af77f72736b81b54","Library":"","LicenseType":"None","SwarmSource":"bzzr://515b710fcc321c4adebc679965cf453dbb03d73e9bb5427b8b958106aaf225d2"}]}