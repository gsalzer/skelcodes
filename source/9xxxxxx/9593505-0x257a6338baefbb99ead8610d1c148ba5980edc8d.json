{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * Copyright Â©ï¸ 2018-2020 Galtâ€¢Project Society Construction and Terraforming Company\r\n * (Founded by [Nikolai Popeka](https://github.com/npopeka)\r\n *\r\n * Copyright Â©ï¸ 2018-2020 Galtâ€¢Core Blockchain Company\r\n * (Founded by [Nikolai Popeka](https://github.com/npopeka) by\r\n * [Basic Agreement](ipfs/QmaCiXUmSrP16Gz8Jdzq6AJESY1EAANmmwha15uR3c1bsS)).\r\n * \r\n * ðŸŒŽ Galt Project is an international decentralized land and real estate property registry\r\n * governed by DAO (Decentralized autonomous organization) and self-governance platform for communities\r\n * of homeowners on Ethereum.\r\n * \r\n * ðŸ¡ https://galtproject.io\r\n */\r\n\r\npragma solidity ^0.5.13;\r\n\r\ninterface IOwnedUpgradeabilityProxy {\r\n  function implementation() external view returns (address);\r\n  function proxyOwner() external view returns (address owner);\r\n  function transferProxyOwnership(address newOwner) external;\r\n  function upgradeTo(address _implementation) external;\r\n  function upgradeToAndCall(address _implementation, bytes calldata _data) external payable;\r\n}\r\n\r\ninterface UpgradeScript {\r\n    function argsWithSignature() external view returns (bytes memory);\r\n}\r\n\r\ncontract Proxy {\r\n  /**\r\n  * @dev Tells the address of the implementation where every call will be delegated.\r\n  * Should be implemented in a descendant contract\r\n  * @return address of the implementation to which it will be delegated\r\n  */\r\n  function implementation() public view returns (address) {\r\n    assert(false);\r\n  }\r\n\r\n  /**\r\n  * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n  * This function will return whatever the implementation call returns\r\n  */\r\n  function () payable external {\r\n    address _impl = implementation();\r\n    require(_impl != address(0));\r\n\r\n    assembly {\r\n      let ptr := mload(0x40)\r\n      calldatacopy(ptr, 0, calldatasize)\r\n      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\r\n      let size := returndatasize\r\n      returndatacopy(ptr, 0, size)\r\n\r\n      switch result\r\n      case 0 { revert(ptr, size) }\r\n      default { return(ptr, size) }\r\n    }\r\n  }\r\n}\r\n\r\n\r\ncontract UpgradeabilityProxy is Proxy {\r\n  /**\r\n   * @dev This event will be emitted every time the implementation gets upgraded\r\n   * @param implementation representing the address of the upgraded implementation\r\n   */\r\n  event Upgraded(address indexed implementation);\r\n\r\n  // Storage position of the address of the current implementation\r\n  bytes32 private constant implementationPosition = keccak256(\"io.galtproject.proxy.implementation\");\r\n\r\n  /**\r\n   * @dev Constructor function\r\n   */\r\n  constructor() public {}\r\n\r\n  /**\r\n   * @dev Tells the address of the current implementation\r\n   * @return address of the current implementation\r\n   */\r\n  function implementation() public view returns (address impl) {\r\n    bytes32 position = implementationPosition;\r\n    assembly {\r\n      impl := sload(position)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the address of the current implementation\r\n   * @param newImplementation address representing the new implementation to be set\r\n   */\r\n  function setImplementation(address newImplementation) internal {\r\n    bytes32 position = implementationPosition;\r\n    assembly {\r\n      sstore(position, newImplementation)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrades the implementation address\r\n   * @param newImplementation representing the address of the new implementation to be set\r\n   */\r\n  function _upgradeTo(address newImplementation) internal {\r\n    address currentImplementation = implementation();\r\n    require(currentImplementation != newImplementation);\r\n    setImplementation(newImplementation);\r\n    emit Upgraded(newImplementation);\r\n  }\r\n}\r\n\r\ncontract OwnedUpgradeabilityProxy is IOwnedUpgradeabilityProxy, UpgradeabilityProxy {\r\n  /**\r\n  * @dev Event to show ownership has been transferred\r\n  * @param previousOwner representing the address of the previous owner\r\n  * @param newOwner representing the address of the new owner\r\n  */\r\n  event ProxyOwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n  // Storage position of the owner of the contract\r\n  bytes32 private constant proxyOwnerPosition = keccak256(\"io.galtproject.proxy.owner\");\r\n\r\n  /**\r\n  * @dev the constructor sets the original owner of the contract to the sender account.\r\n  */\r\n  constructor() public {\r\n    setUpgradeabilityOwner(msg.sender);\r\n  }\r\n\r\n  /**\r\n  * @dev Throws if called by any account other than the owner.\r\n  */\r\n  modifier onlyProxyOwner() {\r\n    require(msg.sender == proxyOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Tells the address of the owner\r\n   * @return the address of the owner\r\n   */\r\n  function proxyOwner() public view returns (address owner) {\r\n    bytes32 position = proxyOwnerPosition;\r\n    assembly {\r\n      owner := sload(position)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the address of the owner\r\n   */\r\n  function setUpgradeabilityOwner(address newProxyOwner) internal {\r\n    bytes32 position = proxyOwnerPosition;\r\n    assembly {\r\n      sstore(position, newProxyOwner)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferProxyOwnership(address newOwner) external onlyProxyOwner {\r\n    require(newOwner != address(0));\r\n    emit ProxyOwnershipTransferred(proxyOwner(), newOwner);\r\n    setUpgradeabilityOwner(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the proxy owner to upgrade the current version of the proxy.\r\n   * @param implementation representing the address of the new implementation to be set.\r\n   */\r\n  function upgradeTo(address implementation) external onlyProxyOwner {\r\n    _upgradeTo(implementation);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the proxy owner to upgrade the current version of the proxy and call the new implementation\r\n   * to initialize whatever is needed through a low level call.\r\n   * @param implementation representing the address of the new implementation to be set.\r\n   * @param data represents the msg.data to bet sent in the low level call. This parameter may include the function\r\n   * signature of the implementation to be called with the needed payload\r\n   */\r\n  function upgradeToAndCall(address implementation, bytes calldata data) payable external onlyProxyOwner {\r\n    _upgradeTo(implementation);\r\n    (bool x,) = address(this).call.value(msg.value)(data);\r\n    require(x);\r\n  }\r\n}\r\n\r\ninterface IOwnedUpgradeabilityProxyFactory {\r\n  function build() external returns(IOwnedUpgradeabilityProxy);\r\n}\r\n\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = _msgSender();\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract FundBareFactory {\r\n  address public implementation;\r\n  IOwnedUpgradeabilityProxyFactory internal ownedUpgradeabilityProxyFactory;\r\n\r\n  constructor(IOwnedUpgradeabilityProxyFactory _factory, address _impl) public {\r\n    ownedUpgradeabilityProxyFactory = _factory;\r\n    implementation = _impl;\r\n  }\r\n\r\n  function build()\r\n    external\r\n    returns (address)\r\n  {\r\n    return _build(\"initialize(address)\", address(this), true, true);\r\n  }\r\n\r\n  function build(address _addressArgument, bool _transferOwnership, bool _transferProxyOwnership)\r\n    external\r\n    returns (address)\r\n  {\r\n    return _build(\"initialize(address)\", _addressArgument, _transferOwnership, _transferProxyOwnership);\r\n  }\r\n\r\n  function build(string calldata _signature, address _addressArgument, bool _transferOwnership, bool _transferProxyOwnership)\r\n    external\r\n    returns (address)\r\n  {\r\n    return _build(_signature, _addressArgument, _transferOwnership, _transferProxyOwnership);\r\n  }\r\n\r\n  function build(bytes calldata _payload, bool _transferOwnership, bool _transferProxyOwnership)\r\n    external\r\n    returns (address)\r\n  {\r\n    return _build(_payload, _transferOwnership, _transferProxyOwnership);\r\n  }\r\n\r\n  // INTERNAL\r\n\r\n  function _build(string memory _signature, address _addressArgument, bool _transferOwnership, bool _transferProxyOwnership)\r\n    internal\r\n    returns (address)\r\n  {\r\n    return _build(\r\n      abi.encodeWithSignature(_signature, _addressArgument),\r\n      _transferOwnership,\r\n      _transferProxyOwnership\r\n    );\r\n  }\r\n\r\n  function _build(bytes memory _payload, bool _transferOwnership, bool _transferProxyOwnership)\r\n    internal\r\n    returns (address)\r\n  {\r\n    IOwnedUpgradeabilityProxy proxy = ownedUpgradeabilityProxyFactory.build();\r\n\r\n    proxy.upgradeToAndCall(implementation, _payload);\r\n\r\n    if (_transferOwnership == true) {\r\n      Ownable(address(proxy)).transferOwnership(msg.sender);\r\n    }\r\n\r\n    if (_transferProxyOwnership == true) {\r\n      proxy.transferProxyOwnership(msg.sender);\r\n    }\r\n\r\n    return address(proxy);\r\n  }\r\n}\r\n\r\ninterface IACL {\r\n  function setRole(bytes32 _role, address _candidate, bool _allow) external;\r\n  function hasRole(address _candidate, bytes32 _role) external view returns (bool);\r\n}\r\n\r\ninterface IFundRegistry {\r\n  function setContract(bytes32 _key, address _value) external;\r\n\r\n  // GETTERS\r\n  function getContract(bytes32 _key) external view returns (address);\r\n  function getGGRAddress() external view returns (address);\r\n  function getPPGRAddress() external view returns (address);\r\n  function getACL() external view returns (IACL);\r\n  function getStorageAddress() external view returns (address);\r\n  function getMultiSigAddress() external view returns (address payable);\r\n  function getRAAddress() external view returns (address);\r\n  function getControllerAddress() external view returns (address);\r\n  function getProposalManagerAddress() external view returns (address);\r\n}\r\n\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates if the contract has been initialized.\r\n   */\r\n  bool public initialized;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initialization function of a contract.\r\n   */\r\n  modifier isInitializer() {\r\n    require(!initialized, \"Contract instance has already been initialized\");\r\n    _;\r\n    initialized = true;\r\n  }\r\n}\r\n\r\ncontract MultiSigWallet {\r\n\r\n    /*\r\n     *  Events\r\n     */\r\n    event Confirmation(address indexed sender, uint indexed transactionId);\r\n    event Revocation(address indexed sender, uint indexed transactionId);\r\n    event Submission(uint indexed transactionId);\r\n    event Execution(uint indexed transactionId);\r\n    event ExecutionFailure(uint indexed transactionId);\r\n    event Deposit(address indexed sender, uint value);\r\n    event OwnerAddition(address indexed owner);\r\n    event OwnerRemoval(address indexed owner);\r\n    event RequirementChange(uint required);\r\n\r\n    /*\r\n     *  Constants\r\n     */\r\n    uint constant public MAX_OWNER_COUNT = 50;\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    mapping (uint => Transaction) public transactions;\r\n    mapping (uint => mapping (address => bool)) public confirmations;\r\n    mapping (address => bool) public isOwner;\r\n    address[] public owners;\r\n    uint public required;\r\n    uint public transactionCount;\r\n\r\n    struct Transaction {\r\n        address destination;\r\n        uint value;\r\n        bytes data;\r\n        bool executed;\r\n    }\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier onlyWallet() {\r\n        require(msg.sender == address(this));\r\n        _;\r\n    }\r\n\r\n    modifier ownerDoesNotExist(address owner) {\r\n        require(!isOwner[owner]);\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address owner) {\r\n        require(isOwner[owner]);\r\n        _;\r\n    }\r\n\r\n    modifier transactionExists(uint transactionId) {\r\n        require(transactions[transactionId].destination != address(0));\r\n        _;\r\n    }\r\n\r\n    modifier confirmed(uint transactionId, address owner) {\r\n        require(confirmations[transactionId][owner]);\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmed(uint transactionId, address owner) {\r\n        require(!confirmations[transactionId][owner]);\r\n        _;\r\n    }\r\n\r\n    modifier notExecuted(uint transactionId) {\r\n        require(!transactions[transactionId].executed);\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address _address) {\r\n        require(_address != address(0));\r\n        _;\r\n    }\r\n\r\n    modifier validRequirement(uint ownerCount, uint _required) {\r\n        require(ownerCount <= MAX_OWNER_COUNT\r\n            && _required <= ownerCount\r\n            && _required != 0\r\n            && ownerCount != 0);\r\n        _;\r\n    }\r\n\r\n    /// @dev Fallback function allows to deposit ether.\r\n    function()\r\n        external\r\n        payable\r\n    {\r\n        if (msg.value > 0)\r\n            emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\r\n    /// @param _owners List of initial owners.\r\n    /// @param _required Number of required confirmations.\r\n    constructor(address[] memory _owners, uint _required)\r\n        public\r\n        validRequirement(_owners.length, _required)\r\n    {\r\n        for (uint i=0; i<_owners.length; i++) {\r\n            require(!isOwner[_owners[i]] && _owners[i] != address(0));\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n        owners = _owners;\r\n        required = _required;\r\n    }\r\n\r\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of new owner.\r\n    function addOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerDoesNotExist(owner)\r\n        notNull(owner)\r\n        validRequirement(owners.length + 1, required)\r\n    {\r\n        isOwner[owner] = true;\r\n        owners.push(owner);\r\n        emit OwnerAddition(owner);\r\n    }\r\n\r\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner.\r\n    function removeOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n    {\r\n        isOwner[owner] = false;\r\n        for (uint i=0; i<owners.length - 1; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }\r\n        owners.length -= 1;\r\n        if (required > owners.length)\r\n            changeRequirement(owners.length);\r\n        emit OwnerRemoval(owner);\r\n    }\r\n\r\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner to be replaced.\r\n    /// @param newOwner Address of new owner.\r\n    function replaceOwner(address owner, address newOwner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n        ownerDoesNotExist(newOwner)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = newOwner;\r\n                break;\r\n            }\r\n        isOwner[owner] = false;\r\n        isOwner[newOwner] = true;\r\n        emit OwnerRemoval(owner);\r\n        emit OwnerAddition(newOwner);\r\n    }\r\n\r\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\r\n    /// @param _required Number of required confirmations.\r\n    function changeRequirement(uint _required)\r\n        public\r\n        onlyWallet\r\n        validRequirement(owners.length, _required)\r\n    {\r\n        required = _required;\r\n        emit RequirementChange(_required);\r\n    }\r\n\r\n    /// @dev Allows an owner to submit and confirm a transaction.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function submitTransaction(address destination, uint value, bytes memory data)\r\n        public\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = addTransaction(destination, value, data);\r\n        confirmTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to confirm a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function confirmTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        transactionExists(transactionId)\r\n        notConfirmed(transactionId, msg.sender)\r\n    {\r\n        confirmations[transactionId][msg.sender] = true;\r\n        emit Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function revokeConfirmation(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        confirmations[transactionId][msg.sender] = false;\r\n        emit Revocation(msg.sender, transactionId);\r\n    }\r\n\r\n    /// @dev Allows anyone to execute a confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function executeTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction storage txn = transactions[transactionId];\r\n            txn.executed = true;\r\n            if (external_call(txn.destination, txn.value, txn.data.length, txn.data))\r\n                emit Execution(transactionId);\r\n            else {\r\n                emit ExecutionFailure(transactionId);\r\n                txn.executed = false;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // call has been separated into its own function in order to take advantage\r\n    // of the Solidity's code generator to produce a loop that copies tx.data into memory.\r\n    function external_call(address destination, uint value, uint dataLength, bytes memory data) private returns (bool) {\r\n        bool result;\r\n        assembly {\r\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\r\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\r\n            result := call(\r\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\r\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\r\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\r\n                destination,\r\n                value,\r\n                d,\r\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\r\n                x,\r\n                0                  // Output is ignored, therefore the output size is zero\r\n            )\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /// @dev Returns the confirmation status of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Confirmation status.\r\n    function isConfirmed(uint transactionId)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint count = 0;\r\n        for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Internal functions\r\n     */\r\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function addTransaction(address destination, uint value, bytes memory data)\r\n        internal\r\n        notNull(destination)\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = transactionCount;\r\n        transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        });\r\n        transactionCount += 1;\r\n        emit Submission(transactionId);\r\n    }\r\n\r\n    /*\r\n     * Web3 call functions\r\n     */\r\n    /// @dev Returns number of confirmations of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Number of confirmations.\r\n    function getConfirmationCount(uint transactionId)\r\n        public\r\n        view\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns total number of transactions after filers are applied.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Total number of transactions after filters are applied.\r\n    function getTransactionCount(bool pending, bool executed)\r\n        public\r\n        view\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns list of owners.\r\n    /// @return List of owner addresses.\r\n    function getOwners()\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return owners;\r\n    }\r\n\r\n    /// @dev Returns array with owner addresses, which confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Returns array of owner addresses.\r\n    function getConfirmations(uint transactionId)\r\n        public\r\n        view\r\n        returns (address[] memory _confirmations)\r\n    {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        _confirmations = new address[](count);\r\n        for (i=0; i<count; i++)\r\n            _confirmations[i] = confirmationsTemp[i];\r\n    }\r\n\r\n    /// @dev Returns list of transaction IDs in defined range.\r\n    /// @param from Index start position of transaction array.\r\n    /// @param to Index end position of transaction array.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Returns array of transaction IDs.\r\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n        public\r\n        view\r\n        returns (uint[] memory _transactionIds)\r\n    {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        _transactionIds = new uint[](to - from);\r\n        for (i=from; i<to; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n    }\r\n}\r\n\r\ncontract FundMultiSig is MultiSigWallet, Initializable {\r\n  event NewOwnerSet(uint256 required, uint256 total);\r\n\r\n  bytes32 public constant ROLE_OWNER_MANAGER = bytes32(\"owner_manager\");\r\n  address public constant ETH_CONTRACT_ADDRESS = address(1);\r\n\r\n  IFundRegistry public fundRegistry;\r\n\r\n  constructor(\r\n    address[] memory _owners\r\n  )\r\n    public\r\n    // WARNING: the implementation won't use this constructor data anyway\r\n    MultiSigWallet(_owners, 1)\r\n  {\r\n  }\r\n\r\n  function initialize(\r\n    address[] calldata _owners,\r\n    uint256 _required,\r\n    address _fundRegistry\r\n  )\r\n    external\r\n    isInitializer\r\n    validRequirement(_owners.length, _required)\r\n  {\r\n    // solium-disable-next-line operator-whitespace\r\n    for (uint i=0; i<_owners.length; i++) {\r\n      // solium-disable-next-line error-reason\r\n      require(!isOwner[_owners[i]] && _owners[i] != address(0));\r\n      isOwner[_owners[i]] = true;\r\n    }\r\n    owners = _owners;\r\n    required = _required;\r\n    fundRegistry = IFundRegistry(_fundRegistry);\r\n  }\r\n\r\n  modifier forbidden() {\r\n    assert(false);\r\n    _;\r\n  }\r\n\r\n  modifier onlyRole(bytes32 _role) {\r\n    require(fundRegistry.getACL().hasRole(msg.sender, _role), \"Invalid role\");\r\n\r\n    _;\r\n  }\r\n\r\n  function addOwner(address owner) public forbidden {}\r\n  function removeOwner(address owner) public forbidden {}\r\n  function replaceOwner(address owner, address newOwner) public forbidden {}\r\n  function changeRequirement(uint _required) public forbidden {}\r\n\r\n  function setOwners(address[] calldata _newOwners, uint256 _required) external onlyRole(ROLE_OWNER_MANAGER) {\r\n    require(_required <= _newOwners.length, \"Required too big\");\r\n    require(_required > 0, \"Required too low\");\r\n    require(_fundStorage().areMembersValid(_newOwners), \"Not all members are valid\");\r\n\r\n    owners = _newOwners;\r\n    required = _required;\r\n\r\n    emit NewOwnerSet(required, _newOwners.length);\r\n  }\r\n\r\n  // call has been separated into its own function in order to take advantage\r\n  // of the Solidity's code generator to produce a loop that copies tx.data into memory.\r\n  // solium-disable-next-line mixedcase\r\n  function external_call(address destination, uint value, uint dataLength, bytes memory data) private returns (bool) {\r\n    beforeTransactionHook(destination, value, dataLength, data);\r\n\r\n    bool result;\r\n    assembly {\r\n        let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\r\n        let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\r\n        result := call(\r\n            sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\r\n                               // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\r\n                               // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\r\n            destination,\r\n            value,\r\n            d,\r\n            dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\r\n            x,\r\n            0                  // Output is ignored, therefore the output size is zero\r\n        )\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function beforeTransactionHook(address _destination, uint _value, uint _dataLength, bytes memory _data) private {\r\n    if (_value > 0) {\r\n      _fundStorage().handleMultiSigTransaction(ETH_CONTRACT_ADDRESS, _value);\r\n    }\r\n\r\n    (bool active,) = _fundStorage().periodLimits(_destination);\r\n\r\n    // If a withdrawal limit exists for this t_destination\r\n    if (active) {\r\n      uint256 erc20Value;\r\n\r\n      assembly {\r\n        let code := mload(add(_data, 0x20))\r\n        code := and(code, 0xffffffff00000000000000000000000000000000000000000000000000000000)\r\n\r\n        switch code\r\n        // transfer(address,uint256)\r\n        case 0xa9059cbb00000000000000000000000000000000000000000000000000000000 {\r\n          erc20Value := mload(add(_data, 0x44))\r\n        }\r\n        default {\r\n          // Methods other than transfer are prohibited for ERC20 contracts\r\n          revert(0, 0)\r\n        }\r\n      }\r\n\r\n      if (erc20Value == 0) {\r\n        return;\r\n      }\r\n\r\n      _fundStorage().handleMultiSigTransaction(_destination, erc20Value);\r\n    }\r\n  }\r\n\r\n  function _fundStorage() internal view returns (IAbstractFundStorage) {\r\n    return IAbstractFundStorage(fundRegistry.getStorageAddress());\r\n  }\r\n}\r\n\r\ninterface IFundRA {\r\n  function balanceOf(address _owner) external view returns (uint256);\r\n  function balanceOfAt(address _owner, uint256 _blockNumber) external view returns (uint256);\r\n  function totalSupplyAt(uint256 _blockNumber) external view returns (uint256);\r\n}\r\n\r\ninterface IAbstractFundStorage {\r\n  function setConfigValue(bytes32 _key, bytes32 _value) external;\r\n\r\n  function setDefaultProposalConfig(\r\n    uint256 _support,\r\n    uint256 _quorum,\r\n    uint256 _timeout\r\n  )\r\n    external;\r\n\r\n  function setProposalConfig(\r\n    bytes32 _marker,\r\n    uint256 _support,\r\n    uint256 _quorum,\r\n    uint256 _timeout\r\n  )\r\n    external;\r\n\r\n  function addCommunityApp(\r\n    address _contract,\r\n    bytes32 _type,\r\n    bytes32 _abiIpfsHash,\r\n    string calldata _dataLink\r\n  )\r\n    external;\r\n  function removeCommunityApp(address _contract) external;\r\n\r\n  function addProposalMarker(\r\n    bytes4 _methodSignature,\r\n    address _destination,\r\n    address _proposalManager,\r\n    bytes32 _name,\r\n    string calldata _dataLink\r\n  )\r\n    external;\r\n  function removeProposalMarker(bytes32 _marker) external;\r\n  function replaceProposalMarker(bytes32 _oldMarker, bytes32 _newMethodSignature, address _newDestination) external;\r\n\r\n  function addFundRule(bytes32 _ipfsHash, string calldata _dataLink) external;\r\n\r\n  function addFeeContract(address _feeContract) external;\r\n\r\n  function removeFeeContract(address _feeContract) external;\r\n\r\n  function setMemberIdentification(address _member, bytes32 _identificationHash) external;\r\n\r\n  function disableFundRule(uint256 _id) external;\r\n\r\n  function setNameAndDataLink(\r\n    string calldata _name,\r\n    string calldata _dataLink\r\n  )\r\n    external;\r\n\r\n  function setMultiSigManager(\r\n    bool _active,\r\n    address _manager,\r\n    string calldata _name,\r\n    string calldata _dataLink\r\n  )\r\n    external;\r\n\r\n  function setPeriodLimit(bool _active, address _erc20Contract, uint256 _amount) external;\r\n\r\n  function handleMultiSigTransaction(\r\n    address _erc20Contract,\r\n    uint256 _amount\r\n  )\r\n    external;\r\n\r\n  // GETTERS\r\n  function membersIdentification(address _member) external view returns(bytes32);\r\n\r\n  function getProposalVotingConfig(bytes32 _key) external view returns (uint256 support, uint256 quorum, uint256 timeout);\r\n\r\n  function getThresholdMarker(address _destination, bytes calldata _data) external pure returns (bytes32 marker);\r\n\r\n  function config(bytes32 _key) external view returns (bytes32);\r\n\r\n  function getCommunityApps() external view returns (address[] memory);\r\n\r\n  function getActiveFundRules() external view returns (uint256[] memory);\r\n\r\n  function getActiveFundRulesCount() external view returns (uint256);\r\n\r\n  function communityAppsInfo(\r\n    address _contract\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      bytes32 appType,\r\n      bytes32 abiIpfsHash,\r\n      string memory dataLink\r\n    );\r\n\r\n  function proposalMarkers(\r\n    bytes32 _marker\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      address proposalManager,\r\n      address destination,\r\n      bytes32 name,\r\n      string memory dataLink\r\n    );\r\n\r\n  function areMembersValid(address[] calldata _members) external view returns (bool);\r\n\r\n  function getActiveMultisigManagers() external view returns (address[] memory);\r\n\r\n  function getActiveMultisigManagersCount() external view returns (uint256);\r\n\r\n  function getActivePeriodLimits() external view returns (address[] memory);\r\n\r\n  function getActivePeriodLimitsCount() external view returns (uint256);\r\n\r\n  function getFeeContracts() external view returns (address[] memory);\r\n\r\n  function getFeeContractCount() external view returns (uint256);\r\n\r\n  function multiSigManagers(address _manager)\r\n    external\r\n    view\r\n    returns (\r\n      bool active,\r\n      string memory managerName,\r\n      string memory dataLink\r\n    );\r\n\r\n  function periodLimits(address _erc20Contract) external view returns (bool active, uint256 amount);\r\n  function getCurrentPeriod() external view returns (uint256);\r\n}\r\n\r\nlibrary ArraySet {\r\n  struct AddressSet {\r\n    address[] array;\r\n    mapping(address => uint256) map;\r\n    mapping(address => bool) exists;\r\n  }\r\n\r\n  struct Bytes32Set {\r\n    bytes32[] array;\r\n    mapping(bytes32 => uint256) map;\r\n    mapping(bytes32 => bool) exists;\r\n  }\r\n\r\n  // AddressSet\r\n  function add(AddressSet storage _set, address _v) internal {\r\n    require(_set.exists[_v] == false, \"Element already exists\");\r\n\r\n    _set.map[_v] = _set.array.length;\r\n    _set.exists[_v] = true;\r\n    _set.array.push(_v);\r\n  }\r\n\r\n  function addSilent(AddressSet storage _set, address _v) internal returns (bool) {\r\n    if (_set.exists[_v] == true) {\r\n      return false;\r\n    }\r\n\r\n    _set.map[_v] = _set.array.length;\r\n    _set.exists[_v] = true;\r\n    _set.array.push(_v);\r\n\r\n    return true;\r\n  }\r\n\r\n  function remove(AddressSet storage _set, address _v) internal {\r\n    require(_set.array.length > 0, \"Array is empty\");\r\n    require(_set.exists[_v] == true, \"Element doesn't exist\");\r\n\r\n    _remove(_set, _v);\r\n  }\r\n\r\n  function removeSilent(AddressSet storage _set, address _v) internal returns (bool) {\r\n    if (_set.exists[_v] == false) {\r\n      return false;\r\n    }\r\n\r\n    _remove(_set, _v);\r\n    return true;\r\n  }\r\n\r\n  function _remove(AddressSet storage _set, address _v) internal {\r\n    uint256 lastElementIndex = _set.array.length - 1;\r\n    uint256 currentElementIndex = _set.map[_v];\r\n    address lastElement = _set.array[lastElementIndex];\r\n\r\n    _set.array[currentElementIndex] = lastElement;\r\n    delete _set.array[lastElementIndex];\r\n\r\n    _set.array.length = _set.array.length - 1;\r\n    delete _set.map[_v];\r\n    delete _set.exists[_v];\r\n    _set.map[lastElement] = currentElementIndex;\r\n  }\r\n\r\n  function clear(AddressSet storage _set) internal {\r\n    for (uint256 i = 0; i < _set.array.length; i++) {\r\n      address v = _set.array[i];\r\n      delete _set.map[v];\r\n      _set.exists[v] = false;\r\n    }\r\n\r\n    delete _set.array;\r\n  }\r\n\r\n  function has(AddressSet storage _set, address _v) internal view returns (bool) {\r\n    return _set.exists[_v];\r\n  }\r\n\r\n  function elements(AddressSet storage _set) internal view returns (address[] storage) {\r\n    return _set.array;\r\n  }\r\n\r\n  function size(AddressSet storage _set) internal view returns (uint256) {\r\n    return _set.array.length;\r\n  }\r\n\r\n  function isEmpty(AddressSet storage _set) internal view returns (bool) {\r\n    return _set.array.length == 0;\r\n  }\r\n\r\n  // Bytes32Set\r\n  function add(Bytes32Set storage _set, bytes32 _v) internal {\r\n    require(_set.exists[_v] == false, \"Element already exists\");\r\n\r\n    _add(_set, _v);\r\n  }\r\n\r\n  function addSilent(Bytes32Set storage _set, bytes32 _v) internal returns (bool) {\r\n    if (_set.exists[_v] == true) {\r\n      return false;\r\n    }\r\n\r\n    _add(_set, _v);\r\n\r\n    return true;\r\n  }\r\n\r\n  function _add(Bytes32Set storage _set, bytes32 _v) internal {\r\n    _set.map[_v] = _set.array.length;\r\n    _set.exists[_v] = true;\r\n    _set.array.push(_v);\r\n  }\r\n\r\n  function remove(Bytes32Set storage _set, bytes32 _v) internal {\r\n    require(_set.array.length > 0, \"Array is empty\");\r\n    require(_set.exists[_v] == true, \"Element doesn't exist\");\r\n\r\n    _remove(_set, _v);\r\n  }\r\n\r\n  function removeSilent(Bytes32Set storage _set, bytes32 _v) internal returns (bool) {\r\n    if (_set.exists[_v] == false) {\r\n      return false;\r\n    }\r\n\r\n    _remove(_set, _v);\r\n    return true;\r\n  }\r\n\r\n  function _remove(Bytes32Set storage _set, bytes32 _v) internal {\r\n    uint256 lastElementIndex = _set.array.length - 1;\r\n    uint256 currentElementIndex = _set.map[_v];\r\n    bytes32 lastElement = _set.array[lastElementIndex];\r\n\r\n    _set.array[currentElementIndex] = lastElement;\r\n    delete _set.array[lastElementIndex];\r\n\r\n    _set.array.length = _set.array.length - 1;\r\n    delete _set.map[_v];\r\n    delete _set.exists[_v];\r\n    _set.map[lastElement] = currentElementIndex;\r\n  }\r\n\r\n  function clear(Bytes32Set storage _set) internal {\r\n    for (uint256 i = 0; i < _set.array.length; i++) {\r\n      _set.exists[_set.array[i]] = false;\r\n    }\r\n\r\n    delete _set.array;\r\n  }\r\n\r\n  function has(Bytes32Set storage _set, bytes32 _v) internal view returns (bool) {\r\n    return _set.exists[_v];\r\n  }\r\n\r\n  function elements(Bytes32Set storage _set) internal view returns (bytes32[] storage) {\r\n    return _set.array;\r\n  }\r\n\r\n  function size(Bytes32Set storage _set) internal view returns (uint256) {\r\n    return _set.array.length;\r\n  }\r\n\r\n  function isEmpty(Bytes32Set storage _set) internal view returns (bool) {\r\n    return _set.array.length == 0;\r\n  }\r\n\r\n  ///////////////////////////// Uint256Set /////////////////////////////////////////\r\n  struct Uint256Set {\r\n    uint256[] array;\r\n    mapping(uint256 => uint256) map;\r\n    mapping(uint256 => bool) exists;\r\n  }\r\n\r\n  function add(Uint256Set storage _set, uint256 _v) internal {\r\n    require(_set.exists[_v] == false, \"Element already exists\");\r\n\r\n    _add(_set, _v);\r\n  }\r\n\r\n  function addSilent(Uint256Set storage _set, uint256 _v) internal returns (bool) {\r\n    if (_set.exists[_v] == true) {\r\n      return false;\r\n    }\r\n\r\n    _add(_set, _v);\r\n\r\n    return true;\r\n  }\r\n\r\n  function _add(Uint256Set storage _set, uint256 _v) internal {\r\n    _set.map[_v] = _set.array.length;\r\n    _set.exists[_v] = true;\r\n    _set.array.push(_v);\r\n  }\r\n\r\n  function remove(Uint256Set storage _set, uint256 _v) internal {\r\n    require(_set.array.length > 0, \"Array is empty\");\r\n    require(_set.exists[_v] == true, \"Element doesn't exist\");\r\n\r\n    _remove(_set, _v);\r\n  }\r\n\r\n  function removeSilent(Uint256Set storage _set, uint256 _v) internal returns (bool) {\r\n    if (_set.exists[_v] == false) {\r\n      return false;\r\n    }\r\n\r\n    _remove(_set, _v);\r\n    return true;\r\n  }\r\n\r\n  function _remove(Uint256Set storage _set, uint256 _v) internal {\r\n    uint256 lastElementIndex = _set.array.length - 1;\r\n    uint256 currentElementIndex = _set.map[_v];\r\n    uint256 lastElement = _set.array[lastElementIndex];\r\n\r\n    _set.array[currentElementIndex] = lastElement;\r\n    delete _set.array[lastElementIndex];\r\n\r\n    _set.array.length = _set.array.length - 1;\r\n    delete _set.map[_v];\r\n    delete _set.exists[_v];\r\n    _set.map[lastElement] = currentElementIndex;\r\n  }\r\n\r\n  function clear(Uint256Set storage _set) internal {\r\n    for (uint256 i = 0; i < _set.array.length; i++) {\r\n      _set.exists[_set.array[i]] = false;\r\n    }\r\n\r\n    delete _set.array;\r\n  }\r\n\r\n  function has(Uint256Set storage _set, uint256 _v) internal view returns (bool) {\r\n    return _set.exists[_v];\r\n  }\r\n\r\n  function elements(Uint256Set storage _set) internal view returns (uint256[] storage) {\r\n    return _set.array;\r\n  }\r\n\r\n  function size(Uint256Set storage _set) internal view returns (uint256) {\r\n    return _set.array.length;\r\n  }\r\n\r\n  function isEmpty(Uint256Set storage _set) internal view returns (bool) {\r\n    return _set.array.length == 0;\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        counter._value += 1;\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        counter._value = counter._value.sub(1);\r\n    }\r\n}\r\n\r\ncontract FundProposalManager is Initializable {\r\n  using SafeMath for uint256;\r\n  using Counters for Counters.Counter;\r\n  using ArraySet for ArraySet.AddressSet;\r\n  using ArraySet for ArraySet.Uint256Set;\r\n\r\n  // 100% == 100 ether\r\n  uint256 public constant ONE_HUNDRED_PCT = 100 ether;\r\n\r\n  event NewProposal(uint256 indexed proposalId, address indexed proposer, bytes32 indexed marker);\r\n  event AyeProposal(uint256 indexed proposalId, address indexed voter);\r\n  event NayProposal(uint256 indexed proposalId, address indexed voter);\r\n\r\n  event Approved(uint256 ayeShare, uint256 support, uint256 indexed proposalId, bytes32 indexed marker);\r\n  event Execute(uint256 indexed proposalId, address indexed executer, bool indexed success, bytes response);\r\n\r\n  struct ProposalVoting {\r\n    uint256 creationBlock;\r\n    uint256 creationTotalSupply;\r\n    uint256 createdAt;\r\n    uint256 timeoutAt;\r\n    uint256 requiredSupport;\r\n    uint256 minAcceptQuorum;\r\n    uint256 totalAyes;\r\n    uint256 totalNays;\r\n    mapping(address => Choice) participants;\r\n    ArraySet.AddressSet ayes;\r\n    ArraySet.AddressSet nays;\r\n  }\r\n\r\n  struct Proposal {\r\n    ProposalStatus status;\r\n    address creator;\r\n    address destination;\r\n    uint256 value;\r\n    bytes32 marker;\r\n    bytes data;\r\n    string dataLink;\r\n  }\r\n\r\n  IFundRegistry public fundRegistry;\r\n  Counters.Counter public idCounter;\r\n\r\n  mapping(uint256 => Proposal) public proposals;\r\n  mapping(uint256 => ProposalVoting) internal _proposalVotings;\r\n  mapping(uint256 => address) private _proposalToSender;\r\n\r\n  enum ProposalStatus {\r\n    NULL,\r\n    ACTIVE,\r\n    EXECUTED\r\n  }\r\n\r\n  enum Choice {\r\n    PENDING,\r\n    AYE,\r\n    NAY\r\n  }\r\n\r\n  modifier onlyMember() {\r\n    require(_fundRA().balanceOf(msg.sender) > 0, \"Not valid member\");\r\n\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n  }\r\n\r\n  function initialize(IFundRegistry _fundRegistry) external isInitializer {\r\n    fundRegistry = _fundRegistry;\r\n  }\r\n\r\n  function propose(\r\n    address _destination,\r\n    uint256 _value,\r\n    bool _castVote,\r\n    bool _executesIfDecided,\r\n    bytes calldata _data,\r\n    string calldata _dataLink\r\n  )\r\n    external\r\n    onlyMember\r\n  {\r\n    idCounter.increment();\r\n    uint256 id = idCounter.current();\r\n\r\n    Proposal storage p = proposals[id];\r\n    p.creator = msg.sender;\r\n    p.destination = _destination;\r\n    p.value = _value;\r\n    p.data = _data;\r\n    p.dataLink = _dataLink;\r\n    p.marker = _fundStorage().getThresholdMarker(_destination, _data);\r\n\r\n    p.status = ProposalStatus.ACTIVE;\r\n    _onNewProposal(id);\r\n\r\n    emit NewProposal(id, msg.sender, p.marker);\r\n\r\n    if (_castVote) {\r\n      _aye(id, msg.sender, _executesIfDecided);\r\n    }\r\n  }\r\n\r\n  function aye(uint256 _proposalId, bool _executeIfDecided) external {\r\n    require(_isProposalOpen(_proposalId), \"Proposal isn't open\");\r\n\r\n    _aye(_proposalId, msg.sender, _executeIfDecided);\r\n  }\r\n\r\n  function nay(uint256 _proposalId) external {\r\n    require(_isProposalOpen(_proposalId), \"Proposal isn't open\");\r\n\r\n    _nay(_proposalId, msg.sender);\r\n  }\r\n\r\n  function executeProposal(uint256 _proposalId, uint256 _gasToKeep) external {\r\n    require(proposals[_proposalId].status == ProposalStatus.ACTIVE, \"Proposal isn't active\");\r\n\r\n    (bool canExecuteThis, string memory reason) = _canExecute(_proposalId);\r\n    require(canExecuteThis, reason);\r\n\r\n    _unsafeExecuteProposal(_proposalId, _gasToKeep);\r\n  }\r\n\r\n  // INTERNAL\r\n\r\n  function _aye(uint256 _proposalId, address _voter, bool _executeIfDecided) internal {\r\n    ProposalVoting storage pV = _proposalVotings[_proposalId];\r\n    uint256 reputation = reputationOf(_voter, pV.creationBlock);\r\n    require(reputation > 0, \"Can't vote with 0 reputation\");\r\n\r\n    if (pV.participants[_voter] == Choice.NAY) {\r\n      pV.nays.remove(_voter);\r\n      pV.totalNays = pV.totalNays.sub(reputation);\r\n    }\r\n\r\n    pV.participants[_voter] = Choice.AYE;\r\n    pV.ayes.add(_voter);\r\n    pV.totalAyes = pV.totalAyes.add(reputation);\r\n\r\n    emit AyeProposal(_proposalId, _voter);\r\n\r\n    (bool canExecuteThis,) = _canExecute(_proposalId);\r\n\r\n    // Fail silently without revert\r\n    if (_executeIfDecided && canExecuteThis) {\r\n      // We've already checked if the vote can be executed with `_canExecute()`\r\n      _unsafeExecuteProposal(_proposalId, 0);\r\n    }\r\n  }\r\n\r\n  function _nay(uint256 _proposalId, address _voter) internal {\r\n    ProposalVoting storage pV = _proposalVotings[_proposalId];\r\n    uint256 reputation = reputationOf(_voter, pV.creationBlock);\r\n    require(reputation > 0, \"Can't vote with 0 reputation\");\r\n\r\n    if (pV.participants[_voter] == Choice.AYE) {\r\n      pV.ayes.remove(_voter);\r\n      pV.totalAyes = pV.totalAyes.sub(reputation);\r\n    }\r\n\r\n    pV.participants[msg.sender] = Choice.NAY;\r\n    pV.nays.add(msg.sender);\r\n    pV.totalNays = pV.totalNays.add(reputation);\r\n\r\n    emit NayProposal(_proposalId, _voter);\r\n  }\r\n\r\n  function _onNewProposal(uint256 _proposalId) internal {\r\n    bytes32 marker = proposals[_proposalId].marker;\r\n\r\n    uint256 blockNumber = block.number.sub(1);\r\n    uint256 totalSupply = _fundRA().totalSupplyAt(blockNumber);\r\n    require(totalSupply > 0, \"Total reputation is 0\");\r\n\r\n    ProposalVoting storage pv = _proposalVotings[_proposalId];\r\n\r\n    pv.creationBlock = blockNumber;\r\n    pv.creationTotalSupply = totalSupply;\r\n\r\n    (uint256 support, uint256 quorum, uint256 timeout) = _fundStorage().getProposalVotingConfig(marker);\r\n    pv.createdAt = block.timestamp;\r\n    // pv.timeoutAt = block.timestamp + timeout;\r\n    pv.timeoutAt = block.timestamp.add(timeout);\r\n\r\n    pv.requiredSupport = support;\r\n    pv.minAcceptQuorum = quorum;\r\n  }\r\n\r\n  function _unsafeExecuteProposal(uint256 _proposalId, uint256 _gasToKeep) internal {\r\n    uint256 gasToKeep = 0;\r\n    if (_gasToKeep == 0) {\r\n      gasToKeep = 100000;\r\n    }\r\n\r\n    Proposal storage p = proposals[_proposalId];\r\n\r\n    p.status = ProposalStatus.EXECUTED;\r\n\r\n    (bool ok, bytes memory response) = address(p.destination)\r\n      .call\r\n      .value(p.value)\r\n      .gas(gasleft().sub(gasToKeep))(p.data);\r\n\r\n    if (ok == false) {\r\n      p.status = ProposalStatus.ACTIVE;\r\n    }\r\n\r\n    emit Execute(_proposalId, msg.sender, ok, response);\r\n  }\r\n\r\n  function _canExecute(uint256 _proposalId) internal view returns (bool can, string memory errorReason) {\r\n    Proposal storage p = proposals[_proposalId];\r\n    ProposalVoting storage pv = _proposalVotings[_proposalId];\r\n\r\n    // Voting is not executed yet\r\n    if (p.status != ProposalStatus.ACTIVE) {\r\n      return (false, \"Proposal isn't active\");\r\n    }\r\n\r\n    // Voting is already decided\r\n    if (_isValuePct(pv.totalAyes, pv.creationTotalSupply, pv.requiredSupport)) {\r\n      return (true, \"\");\r\n    }\r\n\r\n    // Vote ended?\r\n    if (_isProposalOpen(_proposalId)) {\r\n      return (false, \"Proposal is still active\");\r\n    }\r\n\r\n    // Has enough support?\r\n    uint256 support = getCurrentSupport(_proposalId);\r\n    if (support < pv.requiredSupport) {\r\n      return (false, \"Support hasn't been reached\");\r\n    }\r\n\r\n    // Has min quorum?\r\n    uint256 ayeShare = getAyeShare(_proposalId);\r\n    if (ayeShare < pv.minAcceptQuorum) {\r\n      return (false, \"MIN aye quorum hasn't been reached\");\r\n    }\r\n\r\n    return (true, \"\");\r\n  }\r\n\r\n  function _isValuePct(uint256 _value, uint256 _total, uint256 _pct) internal pure returns (bool) {\r\n    if (_total == 0) {\r\n      return false;\r\n    }\r\n\r\n    uint256 computedPct = _value.mul(ONE_HUNDRED_PCT) / _total;\r\n    return computedPct > _pct;\r\n  }\r\n\r\n  function _isProposalOpen(uint256 _proposalId) internal view returns (bool) {\r\n    Proposal storage p = proposals[_proposalId];\r\n    ProposalVoting storage pv = _proposalVotings[_proposalId];\r\n\r\n    return block.timestamp < pv.timeoutAt && p.status == ProposalStatus.ACTIVE;\r\n  }\r\n\r\n  function _fundStorage() internal view returns (IAbstractFundStorage) {\r\n    return IAbstractFundStorage(fundRegistry.getStorageAddress());\r\n  }\r\n\r\n  function _fundRA() internal view returns (IFundRA) {\r\n    return IFundRA(fundRegistry.getRAAddress());\r\n  }\r\n\r\n  // GETTERS\r\n\r\n  function getProposalVoting(\r\n    uint256 _proposalId\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint256 creationBlock,\r\n      uint256 creationTotalSupply,\r\n      uint256 totalAyes,\r\n      uint256 totalNays,\r\n      address[] memory ayes,\r\n      address[] memory nays\r\n    )\r\n  {\r\n    ProposalVoting storage pV = _proposalVotings[_proposalId];\r\n\r\n    return (\r\n      pV.creationBlock,\r\n      pV.creationTotalSupply,\r\n      pV.totalAyes,\r\n      pV.totalNays,\r\n      pV.ayes.elements(),\r\n      pV.nays.elements()\r\n    );\r\n  }\r\n\r\n  function getProposalVotingProgress(\r\n    uint256 _proposalId\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint256 ayesShare,\r\n      uint256 naysShare,\r\n      uint256 totalAyes,\r\n      uint256 totalNays,\r\n      uint256 currentSupport,\r\n      uint256 requiredSupport,\r\n      uint256 minAcceptQuorum,\r\n      uint256 timeoutAt\r\n    )\r\n  {\r\n    ProposalVoting storage pV = _proposalVotings[_proposalId];\r\n\r\n    return (\r\n      getAyeShare(_proposalId),\r\n      getNayShare(_proposalId),\r\n      pV.totalAyes,\r\n      pV.totalNays,\r\n      getCurrentSupport(_proposalId),\r\n      pV.requiredSupport,\r\n      pV.minAcceptQuorum,\r\n      pV.timeoutAt\r\n    );\r\n  }\r\n\r\n  function reputationOf(address _address, uint256 _blockNumber) public view returns (uint256) {\r\n    return _fundRA().balanceOfAt(_address, _blockNumber);\r\n  }\r\n\r\n  function canExecute(uint256 _proposalId) external view returns (bool can, string memory errorReason) {\r\n    return _canExecute(_proposalId);\r\n  }\r\n\r\n  function getParticipantProposalChoice(uint256 _proposalId, address _participant) external view returns (Choice) {\r\n    return _proposalVotings[_proposalId].participants[_participant];\r\n  }\r\n\r\n  function getCurrentSupport(uint256 _proposalId) public view returns (uint256) {\r\n    ProposalVoting storage pv = _proposalVotings[_proposalId];\r\n\r\n    uint256 totalVotes = pv.totalAyes.add(pv.totalNays);\r\n\r\n    if (totalVotes == 0) {\r\n      return 0;\r\n    }\r\n\r\n    return pv.totalAyes.mul(ONE_HUNDRED_PCT) / totalVotes;\r\n  }\r\n\r\n  function getAyeShare(uint256 _proposalId) public view returns (uint256) {\r\n    ProposalVoting storage p = _proposalVotings[_proposalId];\r\n\r\n    return p.totalAyes.mul(ONE_HUNDRED_PCT) / p.creationTotalSupply;\r\n  }\r\n\r\n  function getNayShare(uint256 _proposalId) public view returns (uint256) {\r\n    ProposalVoting storage p = _proposalVotings[_proposalId];\r\n\r\n    return p.totalNays.mul(ONE_HUNDRED_PCT) / p.creationTotalSupply;\r\n  }\r\n}\r\n\r\ncontract AbstractFundStorage is IAbstractFundStorage, Initializable {\r\n  using SafeMath for uint256;\r\n\r\n  using ArraySet for ArraySet.AddressSet;\r\n  using ArraySet for ArraySet.Uint256Set;\r\n  using ArraySet for ArraySet.Bytes32Set;\r\n  using Counters for Counters.Counter;\r\n\r\n  event AddProposalMarker(bytes32 indexed marker, address indexed proposalManager);\r\n  event RemoveProposalMarker(bytes32 indexed marker, address indexed proposalManager);\r\n  event ReplaceProposalMarker(bytes32 indexed oldMarker, bytes32 indexed newMarker, address indexed proposalManager);\r\n\r\n  event SetProposalVotingConfig(bytes32 indexed key, uint256 support, uint256 minAcceptQuorum, uint256 timeout);\r\n  event SetDefaultProposalVotingConfig(uint256 support, uint256 minAcceptQuorum, uint256 timeout);\r\n\r\n  event AddCommunityApp(address indexed contractAddress);\r\n  event RemoveCommunityApp(address indexed contractAddress);\r\n\r\n  event AddFundRule(uint256 indexed id);\r\n  event DisableFundRule(uint256 indexed id);\r\n\r\n  event AddFeeContract(address indexed contractAddress);\r\n  event RemoveFeeContract(address indexed contractAddress);\r\n\r\n  event SetMemberIdentification(address indexed member, bytes32 identificationHash);\r\n  event SetNameAndDataLink(string name, string dataLink);\r\n  event SetMultiSigManager(address indexed manager);\r\n  event SetPeriodLimit(address indexed erc20Contract, uint256 amount, bool active);\r\n  event HandleMultiSigTransaction(address indexed erc20Contract, uint256 amount);\r\n\r\n  event SetConfig(bytes32 indexed key, bytes32 value);\r\n\r\n  // 100% == 100 ether\r\n  uint256 public constant ONE_HUNDRED_PCT = 100 ether;\r\n\r\n  bytes32 public constant ROLE_CONFIG_MANAGER = bytes32(\"CONFIG_MANAGER\");\r\n  bytes32 public constant ROLE_COMMUNITY_APPS_MANAGER = bytes32(\"CA_MANAGER\");\r\n  bytes32 public constant ROLE_PROPOSAL_MARKERS_MANAGER = bytes32(\"MARKER_MANAGER\");\r\n  bytes32 public constant ROLE_NEW_MEMBER_MANAGER = bytes32(\"NEW_MEMBER_MANAGER\");\r\n  bytes32 public constant ROLE_EXPEL_MEMBER_MANAGER = bytes32(\"EXPEL_MEMBER_MANAGER\");\r\n  bytes32 public constant ROLE_FINE_MEMBER_INCREMENT_MANAGER = bytes32(\"FINE_MEMBER_INCREMENT_MANAGER\");\r\n  bytes32 public constant ROLE_FINE_MEMBER_DECREMENT_MANAGER = bytes32(\"FINE_MEMBER_DECREMENT_MANAGER\");\r\n  bytes32 public constant ROLE_CHANGE_NAME_AND_DESCRIPTION_MANAGER = bytes32(\"CHANGE_NAME_DATA_LINK_MANAGER\");\r\n  bytes32 public constant ROLE_ADD_FUND_RULE_MANAGER = bytes32(\"ADD_FUND_RULE_MANAGER\");\r\n  bytes32 public constant ROLE_DEACTIVATE_FUND_RULE_MANAGER = bytes32(\"DEACTIVATE_FUND_RULE_MANAGER\");\r\n  bytes32 public constant ROLE_FEE_MANAGER = bytes32(\"FEE_MANAGER\");\r\n  bytes32 public constant ROLE_MEMBER_DETAILS_MANAGER = bytes32(\"MEMBER_DETAILS_MANAGER\");\r\n  bytes32 public constant ROLE_MULTI_SIG_WITHDRAWAL_LIMITS_MANAGER = bytes32(\"MULTISIG_WITHDRAWAL_MANAGER\");\r\n  bytes32 public constant ROLE_MEMBER_IDENTIFICATION_MANAGER = bytes32(\"MEMBER_IDENTIFICATION_MANAGER\");\r\n  bytes32 public constant ROLE_PROPOSAL_THRESHOLD_MANAGER = bytes32(\"THRESHOLD_MANAGER\");\r\n  bytes32 public constant ROLE_DEFAULT_PROPOSAL_THRESHOLD_MANAGER = bytes32(\"DEFAULT_THRESHOLD_MANAGER\");\r\n  bytes32 public constant ROLE_DECREMENT_TOKEN_REPUTATION = bytes32(\"DECREMENT_TOKEN_REPUTATION_ROLE\");\r\n  bytes32 public constant ROLE_MULTISIG = bytes32(\"MULTISIG\");\r\n\r\n  bytes32 public constant IS_PRIVATE = bytes32(\"is_private\");\r\n\r\n  struct FundRule {\r\n    bool active;\r\n    uint256 id;\r\n    address manager;\r\n    bytes32 ipfsHash;\r\n    string dataLink;\r\n    uint256 createdAt;\r\n  }\r\n\r\n  struct CommunityApp {\r\n    bytes32 abiIpfsHash;\r\n    bytes32 appType;\r\n    string dataLink;\r\n  }\r\n\r\n  struct ProposalMarker {\r\n    bool active;\r\n    bytes32 name;\r\n    string dataLink;\r\n    address destination;\r\n    address proposalManager;\r\n  }\r\n\r\n  struct MultiSigManager {\r\n    bool active;\r\n    address manager;\r\n    string name;\r\n    string dataLink;\r\n  }\r\n\r\n  struct MemberFines {\r\n    uint256 total;\r\n    // Assume ETH is address(0x1)\r\n    mapping(address => MemberFineItem) tokenFines;\r\n  }\r\n\r\n  struct MemberFineItem {\r\n    uint256 amount;\r\n  }\r\n\r\n  struct PeriodLimit {\r\n    bool active;\r\n    uint256 amount;\r\n  }\r\n\r\n  struct VotingConfig {\r\n    uint256 support;\r\n    uint256 minAcceptQuorum;\r\n    uint256 timeout;\r\n  }\r\n\r\n  IFundRegistry public fundRegistry;\r\n  VotingConfig public defaultVotingConfig;\r\n\r\n  string public name;\r\n  string public dataLink;\r\n  uint256 public initialTimestamp;\r\n  uint256 public periodLength;\r\n\r\n  ArraySet.AddressSet internal _communityApps;\r\n  ArraySet.Uint256Set internal _activeFundRules;\r\n  ArraySet.AddressSet internal _feeContracts;\r\n\r\n  Counters.Counter internal fundRuleCounter;\r\n\r\n  ArraySet.AddressSet internal _activeMultisigManagers;\r\n  ArraySet.AddressSet internal _activePeriodLimitsContracts;\r\n\r\n  mapping(bytes32 => bytes32) public config;\r\n  // contractAddress => details\r\n  mapping(address => CommunityApp) public communityAppsInfo;\r\n  // marker => details\r\n  mapping(bytes32 => ProposalMarker) public proposalMarkers;\r\n  // role => address\r\n  mapping(bytes32 => address) public coreContracts;\r\n  // manager => details\r\n  mapping(address => MultiSigManager) public multiSigManagers;\r\n  // erc20Contract => details\r\n  mapping(address => PeriodLimit) public periodLimits;\r\n  // periodId => (erc20Contract => runningTotal)\r\n  mapping(uint256 => mapping(address => uint256)) internal _periodRunningTotals;\r\n  // member => identification hash\r\n  mapping(address => bytes32) public membersIdentification;\r\n\r\n  // FRP => fundRuleDetails\r\n  mapping(uint256 => FundRule) public fundRules;\r\n\r\n  // marker => customVotingConfigs\r\n  mapping(bytes32 => VotingConfig) public customVotingConfigs;\r\n\r\n  modifier onlyFeeContract() {\r\n    require(_feeContracts.has(msg.sender), \"Not a fee contract\");\r\n\r\n    _;\r\n  }\r\n\r\n  modifier onlyMultiSig() {\r\n    require(fundRegistry.getACL().hasRole(msg.sender, ROLE_MULTISIG), \"Invalid role\");\r\n\r\n    _;\r\n  }\r\n\r\n  modifier onlyRole(bytes32 _role) {\r\n    require(fundRegistry.getACL().hasRole(msg.sender, _role), \"Invalid role\");\r\n\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n  }\r\n\r\n  function initialize(\r\n    IFundRegistry _fundRegistry,\r\n    bool _isPrivate,\r\n    uint256 _defaultProposalSupport,\r\n    uint256 _defaultProposalMinAcceptQuorum,\r\n    uint256 _defaultProposalTimeout,\r\n    uint256 _periodLength\r\n  )\r\n    external\r\n    isInitializer\r\n  {\r\n    config[IS_PRIVATE] = _isPrivate ? bytes32(uint256(1)) : bytes32(uint256(0));\r\n\r\n    periodLength = _periodLength;\r\n    initialTimestamp = block.timestamp;\r\n\r\n    _validateVotingConfig(_defaultProposalSupport, _defaultProposalMinAcceptQuorum, _defaultProposalTimeout);\r\n\r\n    defaultVotingConfig.support = _defaultProposalSupport;\r\n    defaultVotingConfig.minAcceptQuorum = _defaultProposalMinAcceptQuorum;\r\n    defaultVotingConfig.timeout = _defaultProposalTimeout;\r\n\r\n    fundRegistry = _fundRegistry;\r\n  }\r\n\r\n  function setDefaultProposalConfig(\r\n    uint256 _support,\r\n    uint256 _minAcceptQuorum,\r\n    uint256 _timeout\r\n  )\r\n    external\r\n    onlyRole(ROLE_DEFAULT_PROPOSAL_THRESHOLD_MANAGER)\r\n  {\r\n    _validateVotingConfig(_support, _minAcceptQuorum, _timeout);\r\n\r\n    defaultVotingConfig.support = _support;\r\n    defaultVotingConfig.minAcceptQuorum = _minAcceptQuorum;\r\n    defaultVotingConfig.timeout = _timeout;\r\n\r\n    emit SetDefaultProposalVotingConfig(_support, _minAcceptQuorum, _timeout);\r\n  }\r\n\r\n  function setProposalConfig(\r\n    bytes32 _marker,\r\n    uint256 _support,\r\n    uint256 _minAcceptQuorum,\r\n    uint256 _timeout\r\n  )\r\n    external\r\n    onlyRole(ROLE_PROPOSAL_THRESHOLD_MANAGER)\r\n  {\r\n    _validateVotingConfig(_support, _minAcceptQuorum, _timeout);\r\n\r\n    customVotingConfigs[_marker] = VotingConfig({\r\n      support: _support,\r\n      minAcceptQuorum: _minAcceptQuorum,\r\n      timeout: _timeout\r\n    });\r\n\r\n    emit SetProposalVotingConfig(_marker, _support, _minAcceptQuorum, _timeout);\r\n  }\r\n\r\n  function setConfigValue(bytes32 _key, bytes32 _value) external onlyRole(ROLE_CONFIG_MANAGER) {\r\n    config[_key] = _value;\r\n\r\n    emit SetConfig(_key, _value);\r\n  }\r\n\r\n  function addCommunityApp(\r\n    address _contract,\r\n    bytes32 _type,\r\n    bytes32 _abiIpfsHash,\r\n    string calldata _dataLink\r\n  )\r\n    external\r\n    onlyRole(ROLE_COMMUNITY_APPS_MANAGER)\r\n  {\r\n    CommunityApp storage c = communityAppsInfo[_contract];\r\n\r\n    _communityApps.addSilent(_contract);\r\n\r\n    c.appType = _type;\r\n    c.abiIpfsHash = _abiIpfsHash;\r\n    c.dataLink = _dataLink;\r\n\r\n    emit AddCommunityApp(_contract);\r\n  }\r\n\r\n  function removeCommunityApp(address _contract) external onlyRole(ROLE_COMMUNITY_APPS_MANAGER) {\r\n    _communityApps.remove(_contract);\r\n\r\n    emit RemoveCommunityApp(_contract);\r\n  }\r\n\r\n  function addProposalMarker(\r\n    bytes4 _methodSignature,\r\n    address _destination,\r\n    address _proposalManager,\r\n    bytes32 _name,\r\n    string calldata _dataLink\r\n  )\r\n    external\r\n    onlyRole(ROLE_PROPOSAL_MARKERS_MANAGER)\r\n  {\r\n    bytes32 _marker = keccak256(abi.encode(_destination, _methodSignature));\r\n\r\n    ProposalMarker storage m = proposalMarkers[_marker];\r\n\r\n    m.active = true;\r\n    m.proposalManager = _proposalManager;\r\n    m.destination = _destination;\r\n    m.name = _name;\r\n    m.dataLink = _dataLink;\r\n\r\n    emit AddProposalMarker(_marker, _proposalManager);\r\n  }\r\n\r\n  function removeProposalMarker(bytes32 _marker) external onlyRole(ROLE_PROPOSAL_MARKERS_MANAGER) {\r\n    proposalMarkers[_marker].active = false;\r\n\r\n    emit RemoveProposalMarker(_marker, proposalMarkers[_marker].proposalManager);\r\n  }\r\n\r\n  function replaceProposalMarker(\r\n    bytes32 _oldMarker,\r\n    bytes32 _newMethodSignature,\r\n    address _newDestination\r\n  )\r\n    external\r\n    onlyRole(ROLE_PROPOSAL_MARKERS_MANAGER)\r\n  {\r\n    bytes32 _newMarker = keccak256(abi.encode(_newDestination, _newMethodSignature));\r\n\r\n    proposalMarkers[_newMarker] = proposalMarkers[_oldMarker];\r\n    proposalMarkers[_newMarker].destination = _newDestination;\r\n    proposalMarkers[_oldMarker].active = false;\r\n\r\n    emit ReplaceProposalMarker(_oldMarker, _newMarker, proposalMarkers[_newMarker].proposalManager);\r\n  }\r\n\r\n  function addFundRule(\r\n    bytes32 _ipfsHash,\r\n    string calldata _dataLink\r\n  )\r\n    external\r\n    onlyRole(ROLE_ADD_FUND_RULE_MANAGER)\r\n  {\r\n    fundRuleCounter.increment();\r\n    uint256 _id = fundRuleCounter.current();\r\n\r\n    FundRule storage fundRule = fundRules[_id];\r\n\r\n    fundRule.active = true;\r\n    fundRule.id = _id;\r\n    fundRule.ipfsHash = _ipfsHash;\r\n    fundRule.dataLink = _dataLink;\r\n    fundRule.manager = msg.sender;\r\n    fundRule.createdAt = block.timestamp;\r\n\r\n    _activeFundRules.add(_id);\r\n\r\n    emit AddFundRule(_id);\r\n  }\r\n\r\n  function disableFundRule(uint256 _id) external onlyRole(ROLE_DEACTIVATE_FUND_RULE_MANAGER) {\r\n    fundRules[_id].active = false;\r\n\r\n    _activeFundRules.remove(_id);\r\n\r\n    emit DisableFundRule(_id);\r\n  }\r\n\r\n  function addFeeContract(address _feeContract) external onlyRole(ROLE_FEE_MANAGER) {\r\n    _feeContracts.add(_feeContract);\r\n\r\n    emit AddFeeContract(_feeContract);\r\n  }\r\n\r\n  function removeFeeContract(address _feeContract) external onlyRole(ROLE_FEE_MANAGER) {\r\n    _feeContracts.remove(_feeContract);\r\n\r\n    emit RemoveFeeContract(_feeContract);\r\n  }\r\n\r\n  function setMemberIdentification(address _member, bytes32 _identificationHash) external onlyRole(ROLE_MEMBER_IDENTIFICATION_MANAGER) {\r\n    membersIdentification[_member] = _identificationHash;\r\n\r\n    emit SetMemberIdentification(_member, _identificationHash);\r\n  }\r\n\r\n  function setNameAndDataLink(\r\n    string calldata _name,\r\n    string calldata _dataLink\r\n  )\r\n    external\r\n    onlyRole(ROLE_CHANGE_NAME_AND_DESCRIPTION_MANAGER)\r\n  {\r\n    name = _name;\r\n    dataLink = _dataLink;\r\n\r\n    emit SetNameAndDataLink(_name, _dataLink);\r\n  }\r\n\r\n  function setMultiSigManager(\r\n    bool _active,\r\n    address _manager,\r\n    string calldata _name,\r\n    string calldata _dataLink\r\n  )\r\n    external\r\n    onlyRole(ROLE_MEMBER_DETAILS_MANAGER)\r\n  {\r\n    MultiSigManager storage m = multiSigManagers[_manager];\r\n\r\n    m.active = _active;\r\n    m.name = _name;\r\n    m.dataLink = _dataLink;\r\n\r\n    if (_active) {\r\n      _activeMultisigManagers.addSilent(_manager);\r\n    } else {\r\n      _activeMultisigManagers.removeSilent(_manager);\r\n    }\r\n\r\n    emit SetMultiSigManager(_manager);\r\n  }\r\n\r\n  function setPeriodLimit(\r\n    bool _active,\r\n    address _erc20Contract,\r\n    uint256 _amount\r\n  )\r\n    external\r\n    onlyRole(ROLE_MULTI_SIG_WITHDRAWAL_LIMITS_MANAGER)\r\n  {\r\n    periodLimits[_erc20Contract].active = _active;\r\n    periodLimits[_erc20Contract].amount = _amount;\r\n\r\n    if (_active) {\r\n      _activePeriodLimitsContracts.addSilent(_erc20Contract);\r\n    } else {\r\n      _activePeriodLimitsContracts.removeSilent(_erc20Contract);\r\n    }\r\n\r\n    emit SetPeriodLimit(_erc20Contract, _amount, _active);\r\n  }\r\n\r\n  function handleMultiSigTransaction(\r\n    address _erc20Contract,\r\n    uint256 _amount\r\n  )\r\n    external\r\n    onlyMultiSig\r\n  {\r\n    PeriodLimit storage limit = periodLimits[_erc20Contract];\r\n    if (limit.active == false) {\r\n      return;\r\n    }\r\n\r\n    uint256 currentPeriod = getCurrentPeriod();\r\n    // uint256 runningTotalAfter = _periodRunningTotals[currentPeriod][_erc20Contract] + _amount;\r\n    uint256 runningTotalAfter = _periodRunningTotals[currentPeriod][_erc20Contract].add(_amount);\r\n\r\n    require(runningTotalAfter <= periodLimits[_erc20Contract].amount, \"Running total for the current period exceeds the limit\");\r\n    _periodRunningTotals[currentPeriod][_erc20Contract] = runningTotalAfter;\r\n\r\n    emit HandleMultiSigTransaction(_erc20Contract, _amount);\r\n  }\r\n\r\n  // INTERNAL\r\n\r\n  function _validateVotingConfig(\r\n    uint256 _support,\r\n    uint256 _minAcceptQuorum,\r\n    uint256 _timeout\r\n  )\r\n    internal\r\n    pure\r\n  {\r\n    require(_minAcceptQuorum > 0 && _minAcceptQuorum <= _support, \"Invalid min accept quorum value\");\r\n    require(_support > 0 && _support <= ONE_HUNDRED_PCT, \"Invalid support value\");\r\n    require(_timeout > 0, \"Invalid duration value\");\r\n  }\r\n\r\n  // GETTERS\r\n\r\n  function getThresholdMarker(address _destination, bytes memory _data) public pure returns(bytes32 marker) {\r\n    bytes32 methodName;\r\n\r\n    assembly {\r\n      methodName := and(mload(add(_data, 0x20)), 0xffffffff00000000000000000000000000000000000000000000000000000000)\r\n    }\r\n\r\n    return keccak256(abi.encode(_destination, methodName));\r\n  }\r\n\r\n  function getProposalVotingConfig(\r\n    bytes32 _key\r\n  )\r\n    external\r\n    view\r\n    returns (uint256 support, uint256 minAcceptQuorum, uint256 timeout)\r\n  {\r\n    uint256 to = customVotingConfigs[_key].timeout;\r\n\r\n    if (to > 0) {\r\n      return (\r\n        customVotingConfigs[_key].support,\r\n        customVotingConfigs[_key].minAcceptQuorum,\r\n        customVotingConfigs[_key].timeout\r\n      );\r\n    } else {\r\n      return (\r\n        defaultVotingConfig.support,\r\n        defaultVotingConfig.minAcceptQuorum,\r\n        defaultVotingConfig.timeout\r\n      );\r\n    }\r\n  }\r\n\r\n  function getCommunityApps() external view returns (address[] memory) {\r\n    return _communityApps.elements();\r\n  }\r\n\r\n  function getActiveFundRules() external view returns (uint256[] memory) {\r\n    return _activeFundRules.elements();\r\n  }\r\n\r\n  function getActiveFundRulesCount() external view returns (uint256) {\r\n    return _activeFundRules.size();\r\n  }\r\n\r\n  function areMembersValid(address[] calldata _members) external view returns (bool) {\r\n    uint256 len = _members.length;\r\n\r\n    for (uint256 i = 0; i < len; i++) {\r\n      if (multiSigManagers[_members[i]].active == false) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function getActiveMultisigManagers() external view returns (address[] memory) {\r\n    return _activeMultisigManagers.elements();\r\n  }\r\n\r\n  function getActiveMultisigManagersCount() external view returns (uint256) {\r\n    return _activeMultisigManagers.size();\r\n  }\r\n\r\n  function getActivePeriodLimits() external view returns (address[] memory) {\r\n    return _activePeriodLimitsContracts.elements();\r\n  }\r\n\r\n  function getActivePeriodLimitsCount() external view returns (uint256) {\r\n    return _activePeriodLimitsContracts.size();\r\n  }\r\n\r\n  function getFeeContracts() external view returns (address[] memory) {\r\n    return _feeContracts.elements();\r\n  }\r\n\r\n  function getFeeContractCount() external view returns (uint256) {\r\n    return _feeContracts.size();\r\n  }\r\n\r\n  function getCurrentPeriod() public view returns (uint256) {\r\n    // return (block.timestamp - initialTimestamp) / periodLength;\r\n    return (block.timestamp.sub(initialTimestamp)) / periodLength;\r\n  }\r\n}\r\n\r\ninterface IPPRA {\r\n  // ERC20 compatible\r\n  function balanceOf(address _owner) external view returns (uint256);\r\n\r\n  // ERC20 compatible\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  // Private Property specific getter\r\n  function reputationMinted(address _tokenContract, uint256 _tokenId) external view returns (bool);\r\n\r\n  // Ping-Pong Handshake\r\n  function ping() external pure returns (bytes32);\r\n}\r\n\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of NFTs in `owner`'s account.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the NFT specified by `tokenId`.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     *\r\n     *\r\n     * Requirements:\r\n     * - `from`, `to` cannot be zero.\r\n     * - `tokenId` must be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this\r\n     * NFT by either {approve} or {setApprovalForAll}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Requirements:\r\n     * - If the caller is not `from`, it must be approved to move this NFT by\r\n     * either {approve} or {setApprovalForAll}.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\ninterface IPPToken {\r\n  event SetBaseURI(string baseURI);\r\n  event SetContractDataLink(string indexed dataLink);\r\n  event SetLegalAgreementIpfsHash(bytes32 legalAgreementIpfsHash);\r\n  event SetController(address indexed controller);\r\n  event SetDetails(\r\n    address indexed geoDataManager,\r\n    uint256 indexed privatePropertyId\r\n  );\r\n  event SetContour(\r\n    address indexed geoDataManager,\r\n    uint256 indexed privatePropertyId\r\n  );\r\n  event SetHumanAddress(uint256 indexed tokenId, string humanAddress);\r\n  event SetDataLink(uint256 indexed tokenId, string dataLink);\r\n  event SetLedgerIdentifier(uint256 indexed tokenId, bytes32 ledgerIdentifier);\r\n  event SetVertexRootHash(uint256 indexed tokenId, bytes32 ledgerIdentifier);\r\n  event SetVertexStorageLink(uint256 indexed tokenId, string vertexStorageLink);\r\n  event SetArea(uint256 indexed tokenId, uint256 area, AreaSource areaSource);\r\n  event SetExtraData(bytes32 indexed key, bytes32 value);\r\n  event SetPropertyExtraData(uint256 indexed propertyId, bytes32 indexed key, bytes32 value);\r\n  event Mint(address indexed to, uint256 indexed privatePropertyId);\r\n  event Burn(address indexed from, uint256 indexed privatePropertyId);\r\n\r\n  enum AreaSource {\r\n    USER_INPUT,\r\n    CONTRACT\r\n  }\r\n\r\n  enum TokenType {\r\n    NULL,\r\n    LAND_PLOT,\r\n    BUILDING,\r\n    ROOM,\r\n    PACKAGE\r\n  }\r\n\r\n  struct Property {\r\n    uint256 setupStage;\r\n\r\n    // (LAND_PLOT,BUILDING,ROOM) Type cannot be changed after token creation\r\n    TokenType tokenType;\r\n    // Geohash5z (x,y,z)\r\n    uint256[] contour;\r\n    // Meters above the sea\r\n    int256 highestPoint;\r\n\r\n    // USER_INPUT or CONTRACT\r\n    AreaSource areaSource;\r\n    // Calculated either by contract (for land plots and buildings) or by manual input\r\n    // in sq. meters (1 sq. meter == 1 eth)\r\n    uint256 area;\r\n\r\n    bytes32 ledgerIdentifier;\r\n    string humanAddress;\r\n    string dataLink;\r\n\r\n    // Reserved for future use\r\n    bytes32 vertexRootHash;\r\n    string vertexStorageLink;\r\n  }\r\n\r\n  // PERMISSIONED METHODS\r\n\r\n  function setContractDataLink(string calldata _dataLink) external;\r\n  function setLegalAgreementIpfsHash(bytes32 _legalAgreementIpfsHash) external;\r\n  function setController(address payable _controller) external;\r\n  function setDetails(\r\n    uint256 _tokenId,\r\n    TokenType _tokenType,\r\n    AreaSource _areaSource,\r\n    uint256 _area,\r\n    bytes32 _ledgerIdentifier,\r\n    string calldata _humanAddress,\r\n    string calldata _dataLink\r\n  )\r\n    external;\r\n\r\n  function setContour(\r\n    uint256 _tokenId,\r\n    uint256[] calldata _contour,\r\n    int256 _highestPoint\r\n  )\r\n    external;\r\n\r\n  function setArea(uint256 _tokenId, uint256 _area, AreaSource _areaSource) external;\r\n  function setLedgerIdentifier(uint256 _tokenId, bytes32 _ledgerIdentifier) external;\r\n  function setDataLink(uint256 _tokenId, string calldata _dataLink) external;\r\n  function setVertexRootHash(uint256 _tokenId, bytes32 _vertexRootHash) external;\r\n  function setVertexStorageLink(uint256 _tokenId, string calldata _vertexStorageLink) external;\r\n  function setExtraData(bytes32 _key, bytes32 _value) external;\r\n  function setPropertyExtraData(uint256 _tokenId, bytes32 _key, bytes32 _value) external;\r\n\r\n  function incrementSetupStage(uint256 _tokenId) external;\r\n\r\n  function mint(address _to) external returns (uint256);\r\n  function burn(uint256 _tokenId) external;\r\n  function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n  // GETTERS\r\n  function controller() external view returns (address payable);\r\n  function extraData(bytes32 _key) external view returns (bytes32);\r\n  function propertyExtraData(uint256 _tokenId, bytes32 _key) external view returns (bytes32);\r\n  function propertyCreatedAt(uint256 _tokenId) external view returns (uint256);\r\n  function tokensOfOwner(address _owner) external view returns (uint256[] memory);\r\n  function ownerOf(uint256 _tokenId) external view returns (address);\r\n  function exists(uint256 _tokenId) external view returns (bool);\r\n  function getType(uint256 _tokenId) external view returns (TokenType);\r\n  function getContour(uint256 _tokenId) external view returns (uint256[] memory);\r\n  function getContourLength(uint256 _tokenId) external view returns (uint256);\r\n  function getHighestPoint(uint256 _tokenId) external view returns (int256);\r\n  function getHumanAddress(uint256 _tokenId) external view returns (string memory);\r\n  function getArea(uint256 _tokenId) external view returns (uint256);\r\n  function getAreaSource(uint256 _tokenId) external view returns (AreaSource);\r\n  function getLedgerIdentifier(uint256 _tokenId) external view returns (bytes32);\r\n  function getDataLink(uint256 _tokenId) external view returns (string memory);\r\n  function getVertexRootHash(uint256 _tokenId) external view returns (bytes32);\r\n  function getVertexStorageLink(uint256 _tokenId) external view returns (string memory);\r\n  function getSetupStage(uint256 _tokenId) external view returns (uint256);\r\n  function getDetails(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns (\r\n      TokenType tokenType,\r\n      uint256[] memory contour,\r\n      int256 highestPoint,\r\n      AreaSource areaSource,\r\n      uint256 area,\r\n      bytes32 ledgerIdentifier,\r\n      string memory humanAddress,\r\n      string memory dataLink,\r\n      uint256 setupStage,\r\n      bytes32 vertexRootHash,\r\n      string memory vertexStorageLink\r\n    );\r\n}\r\n\r\ninterface IPPLocker {\r\n  function deposit(IPPToken _tokenContract, uint256 _tokenId) external payable;\r\n  function withdraw() external;\r\n  function approveMint(IPPRA _tra) external;\r\n  function burn(IPPRA _tra) external;\r\n  function isMinted(address _tra) external view returns (bool);\r\n  function getTras() external view returns (address[] memory);\r\n  function getTrasCount() external view returns (uint256);\r\n  function isOwner() external view returns (bool);\r\n  function owner() external view returns(address);\r\n  function tokenId() external view returns(uint256);\r\n  function reputation() external view returns(uint256);\r\n  function tokenContract() external view returns(IPPToken);\r\n}\r\n\r\ninterface IPPTokenRegistry {\r\n  event AddToken(address indexed token, address indexed owener, address indexed factory);\r\n  event SetFactory(address factory);\r\n  event SetLockerRegistry(address lockerRegistry);\r\n\r\n  function tokenList(uint256 _index) external view returns (address);\r\n  function isValid(address _tokenContract) external view returns (bool);\r\n  function requireValidToken(address _token) external view;\r\n  function addToken(address _privatePropertyToken) external;\r\n  function getAllTokens() external view returns (address[] memory);\r\n}\r\n\r\ninterface IPPGlobalRegistry {\r\n  function setContract(bytes32 _key, address _value) external;\r\n\r\n  // GETTERS\r\n  function getContract(bytes32 _key) external view returns (address);\r\n  function getACL() external view returns (IACL);\r\n  function getGaltTokenAddress() external view returns (address);\r\n  function getPPTokenRegistryAddress() external view returns (address);\r\n  function getPPLockerRegistryAddress() external view returns (address);\r\n  function getPPMarketAddress() external view returns (address);\r\n}\r\n\r\ncontract PrivateFundStorage is AbstractFundStorage {\r\n\r\n  event ApproveMint(address indexed registry, uint256 indexed tokenId);\r\n\r\n  event Expel(address indexed registry, uint256 indexed tokenId);\r\n  event DecrementExpel(address indexed registry, uint256 indexed tokenId);\r\n\r\n  event ChangeFine(bool indexed isIncrement, address indexed registry, uint256 indexed tokenId, address contractAddress);\r\n\r\n  event LockChange(bool indexed isLock, address indexed registry, uint256 indexed tokenId);\r\n\r\n  // registry => (tokenId => details)\r\n  mapping(address => mapping(uint256 => MemberFines)) private _fines;\r\n  // registry => (tokenId => isMintApproved)\r\n  mapping(address => mapping(uint256 => bool)) private _mintApprovals;\r\n  // registry => (tokenId => isExpelled)\r\n  mapping(address => mapping(uint256 => bool)) private _expelledTokens;\r\n  // registry => (tokenId => availableAmountToBurn)\r\n  mapping(address => mapping(uint256 => uint256)) private _expelledTokenReputation;\r\n  // registry => (tokenId => isLocked)\r\n  mapping(address => mapping(uint256 => bool)) private _lockedTokens;\r\n\r\n  constructor() public {\r\n  }\r\n\r\n  function _onlyValidToken(address _token) internal view {\r\n    IPPGlobalRegistry ppgr = IPPGlobalRegistry(fundRegistry.getPPGRAddress());\r\n\r\n    IPPTokenRegistry(ppgr.getPPTokenRegistryAddress())\r\n      .requireValidToken(_token);\r\n  }\r\n\r\n  function approveMintAll(address[] calldata _registries, uint256[] calldata _tokenIds)\r\n    external\r\n    onlyRole(ROLE_NEW_MEMBER_MANAGER)\r\n  {\r\n    require(_registries.length == _tokenIds.length, \"Array lengths mismatch\");\r\n\r\n    uint256 len = _registries.length;\r\n\r\n    for (uint256 i = 0; i < len; i++) {\r\n      _onlyValidToken(_registries[i]);\r\n      _mintApprovals[_registries[i]][_tokenIds[i]] = true;\r\n      _expelledTokens[_registries[i]][_tokenIds[i]] = false;\r\n\r\n      emit ApproveMint(_registries[i], _tokenIds[i]);\r\n    }\r\n  }\r\n\r\n  function expel(address _registry, uint256 _tokenId)\r\n    external\r\n    onlyRole(ROLE_EXPEL_MEMBER_MANAGER)\r\n  {\r\n    _onlyValidToken(_registry);\r\n    require(_expelledTokens[_registry][_tokenId] == false, \"Already Expelled\");\r\n\r\n    address owner = IERC721(_registry).ownerOf(_tokenId);\r\n    uint256 amount = IPPLocker(owner).reputation();\r\n\r\n    assert(amount > 0);\r\n\r\n    _expelledTokens[_registry][_tokenId] = true;\r\n    _expelledTokenReputation[_registry][_tokenId] = amount;\r\n\r\n    emit Expel(_registry, _tokenId);\r\n  }\r\n\r\n  function decrementExpelledTokenReputation(\r\n    address _registry,\r\n    uint256 _tokenId,\r\n    uint256 _amount\r\n  )\r\n    external\r\n    onlyRole(ROLE_DECREMENT_TOKEN_REPUTATION)\r\n    returns (bool completelyBurned)\r\n  {\r\n    _onlyValidToken(_registry);\r\n    require(_amount > 0 && _amount <= _expelledTokenReputation[_registry][_tokenId], \"Invalid reputation amount\");\r\n\r\n    _expelledTokenReputation[_registry][_tokenId] = _expelledTokenReputation[_registry][_tokenId] - _amount;\r\n\r\n    completelyBurned = (_expelledTokenReputation[_registry][_tokenId] == 0);\r\n\r\n    emit DecrementExpel(_registry, _tokenId);\r\n  }\r\n\r\n  function incrementFine(\r\n    address _registry,\r\n    uint256 _tokenId,\r\n    address _contract,\r\n    uint256 _amount\r\n  )\r\n    external\r\n    onlyRole(ROLE_FINE_MEMBER_INCREMENT_MANAGER)\r\n  {\r\n    _onlyValidToken(_registry);\r\n    // _fines[_registry][_tokenId].tokenFines[_contract].amount += _amount;\r\n    _fines[_registry][_tokenId].tokenFines[_contract].amount = _fines[_registry][_tokenId].tokenFines[_contract].amount.add(_amount);\r\n    // _fines[_registry][_tokenId].total += _amount;\r\n    _fines[_registry][_tokenId].total = _fines[_registry][_tokenId].total.add(_amount);\r\n\r\n    emit ChangeFine(true, _registry, _tokenId, _contract);\r\n  }\r\n\r\n  function decrementFine(\r\n    address _registry,\r\n    uint256 _tokenId,\r\n    address _contract,\r\n    uint256 _amount\r\n  )\r\n    external\r\n    onlyRole(ROLE_FINE_MEMBER_DECREMENT_MANAGER)\r\n  {\r\n    _onlyValidToken(_registry);\r\n\r\n    // _fines[_registry][_tokenId].tokenFines[_contract].amount -= _amount;\r\n    _fines[_registry][_tokenId].tokenFines[_contract].amount = _fines[_registry][_tokenId].tokenFines[_contract].amount.sub(_amount);\r\n    // _fines[_registry][_tokenId].total -= _amount;\r\n    _fines[_registry][_tokenId].total -= _fines[_registry][_tokenId].total.sub(_amount);\r\n\r\n    emit ChangeFine(false, _registry, _tokenId, _contract);\r\n  }\r\n\r\n  function lockSpaceToken(\r\n    address _registry,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    onlyFeeContract\r\n  {\r\n    _onlyValidToken(_registry);\r\n    _lockedTokens[_registry][_tokenId] = true;\r\n\r\n    emit LockChange(true, _registry, _tokenId);\r\n  }\r\n\r\n  function unlockSpaceToken(\r\n    address _registry,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    onlyFeeContract\r\n  {\r\n    _onlyValidToken(_registry);\r\n    _lockedTokens[_registry][_tokenId] = false;\r\n\r\n    emit LockChange(false, _registry, _tokenId);\r\n  }\r\n\r\n  // GETTERS\r\n  function getFineAmount(\r\n    address _registry,\r\n    uint256 _tokenId,\r\n    address _erc20Contract\r\n  )\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return _fines[_registry][_tokenId].tokenFines[_erc20Contract].amount;\r\n  }\r\n\r\n  function getTotalFineAmount(\r\n    address _registry,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return _fines[_registry][_tokenId].total;\r\n  }\r\n\r\n  function getExpelledToken(\r\n    address _registry,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (bool isExpelled, uint256 amount)\r\n  {\r\n    return (\r\n      _expelledTokens[_registry][_tokenId],\r\n      _expelledTokenReputation[_registry][_tokenId]\r\n    );\r\n  }\r\n\r\n  function isMintApproved(\r\n    address _registry,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    if (_expelledTokens[_registry][_tokenId] == true) {\r\n      return false;\r\n    }\r\n\r\n    if (uint256(config[IS_PRIVATE]) == uint256(1)) {\r\n      return _mintApprovals[_registry][_tokenId];\r\n    } else {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  function isTokenLocked(\r\n    address _registry,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _lockedTokens[_registry][_tokenId];\r\n  }\r\n}\r\n\r\ncontract PrivateFundStorageFactory {\r\n  address public implementation;\r\n  IOwnedUpgradeabilityProxyFactory internal ownedUpgradeabilityProxyFactory;\r\n\r\n  constructor(IOwnedUpgradeabilityProxyFactory _factory, address _impl) public {\r\n    ownedUpgradeabilityProxyFactory = _factory;\r\n    implementation = _impl;\r\n  }\r\n\r\n  function build(\r\n    IFundRegistry _globalRegistry,\r\n    bool _isPrivate,\r\n    uint256 _defaultProposalSupport,\r\n    uint256 _defaultProposalQuorum,\r\n    uint256 _defaultProposalTimeout,\r\n    uint256 _periodLength\r\n  )\r\n    external\r\n    returns (PrivateFundStorage)\r\n  {\r\n    IOwnedUpgradeabilityProxy proxy = ownedUpgradeabilityProxyFactory.build();\r\n\r\n    proxy.upgradeToAndCall(\r\n      implementation,\r\n      abi.encodeWithSignature(\r\n        \"initialize(address,bool,uint256,uint256,uint256,uint256)\",\r\n        _globalRegistry,\r\n        _isPrivate,\r\n        _defaultProposalSupport,\r\n        _defaultProposalQuorum,\r\n        _defaultProposalTimeout,\r\n        _periodLength\r\n      )\r\n    );\r\n\r\n    proxy.transferProxyOwnership(msg.sender);\r\n\r\n    return PrivateFundStorage(address(proxy));\r\n  }\r\n}\r\n\r\ncontract FundUpgrader is Initializable {\r\n  event UpgradeSucceeded();\r\n  event UpgradeFailed(bytes result);\r\n\r\n  bytes32 public constant ROLE_UPGRADE_SCRIPT_MANAGER = bytes32(\"upgrade_script_manager\");\r\n  bytes32 public constant ROLE_IMPL_UPGRADE_MANAGER = bytes32(\"impl_upgrade_manager\");\r\n\r\n  IFundRegistry public fundRegistry;\r\n\r\n  address public nextUpgradeScript;\r\n\r\n  modifier onlyUpgradeScriptManager() {\r\n    require(fundRegistry.getACL().hasRole(msg.sender, ROLE_UPGRADE_SCRIPT_MANAGER), \"Invalid role\");\r\n\r\n    _;\r\n  }\r\n\r\n  modifier onlyImplUpgradeManager() {\r\n    require(fundRegistry.getACL().hasRole(msg.sender, ROLE_UPGRADE_SCRIPT_MANAGER), \"Invalid role\");\r\n\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n  }\r\n\r\n  function initialize(IFundRegistry _fundRegistry) external isInitializer {\r\n    fundRegistry = _fundRegistry;\r\n  }\r\n\r\n  function upgradeImplementationTo(address _proxy, address _implementation) external onlyImplUpgradeManager {\r\n    IOwnedUpgradeabilityProxy(_proxy).upgradeTo(_implementation);\r\n  }\r\n\r\n  function upgradeImplementationToAndCall(\r\n    address _proxy,\r\n    address _implementation,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n    onlyImplUpgradeManager\r\n  {\r\n    IOwnedUpgradeabilityProxy(_proxy).upgradeToAndCall(_implementation, _data);\r\n  }\r\n\r\n  function setNextUpgradeScript(address _nextUpgadeScript) external onlyUpgradeScriptManager {\r\n    nextUpgradeScript = _nextUpgadeScript;\r\n  }\r\n\r\n  function upgrade() external {\r\n    require(nextUpgradeScript != address(0), \"Upgrade script not set\");\r\n\r\n    // solium-disable-next-line security/no-low-level-calls\r\n    (bool ok, bytes memory res) = nextUpgradeScript.delegatecall(\r\n      UpgradeScript(nextUpgradeScript).argsWithSignature()\r\n    );\r\n\r\n    if (ok == true) {\r\n      nextUpgradeScript = address(0);\r\n      emit UpgradeSucceeded();\r\n    } else {\r\n      emit UpgradeFailed(res);\r\n    }\r\n  }\r\n}\r\n\r\ncontract OwnableAndInitializable is Ownable, Initializable {\r\n\r\n  /**\r\n   * @dev Modifier to use in the initialization function of a contract.\r\n   */\r\n  modifier isInitializer() {\r\n    require(!initialized, \"Contract instance has already been initialized\");\r\n    _;\r\n    initialized = true;\r\n    _transferOwnership(tx.origin);\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to use in the initialization function of a contract. Allow a custom owner setup;\r\n   */\r\n  modifier initializeWithOwner(address _owner) {\r\n    require(!initialized, \"Contract instance has already been initialized\");\r\n    _;\r\n    initialized = true;\r\n    _transferOwnership(_owner);\r\n  }\r\n}\r\n\r\ncontract FundRegistry is IFundRegistry, OwnableAndInitializable {\r\n  // solium-disable-next-line mixedcase\r\n  address internal constant ZERO_ADDRESS = address(0);\r\n\r\n  bytes32 public constant GGR = bytes32(\"GGR\");\r\n  bytes32 public constant PPGR = bytes32(\"PPGR\");\r\n\r\n  bytes32 public constant ACL = bytes32(\"ACL\");\r\n  bytes32 public constant STORAGE = bytes32(\"storage\");\r\n  bytes32 public constant MULTISIG = bytes32(\"multisig\");\r\n  bytes32 public constant RA = bytes32(\"reputation_accounting\");\r\n  bytes32 public constant CONTROLLER = bytes32(\"controller\");\r\n  bytes32 public constant PROPOSAL_MANAGER = bytes32(\"proposal_manager\");\r\n  bytes32 public constant UPGRADER = bytes32(\"UPGRADER\");\r\n\r\n  event SetContract(bytes32 indexed key, address addr);\r\n\r\n  mapping(bytes32 => address) internal contracts;\r\n\r\n  function initialize(address owner) public initializeWithOwner(owner) {\r\n  }\r\n\r\n  function setContract(bytes32 _key, address _value) external {\r\n    contracts[_key] = _value;\r\n\r\n    emit SetContract(_key, _value);\r\n  }\r\n\r\n  // GETTERS\r\n  function getContract(bytes32 _key) external view returns (address) {\r\n    return contracts[_key];\r\n  }\r\n\r\n  function getGGRAddress() external view returns (address) {\r\n    require(contracts[GGR] != ZERO_ADDRESS, \"FundRegistry: GGR not set\");\r\n    return contracts[GGR];\r\n  }\r\n\r\n  function getPPGRAddress() external view returns (address) {\r\n    require(contracts[PPGR] != ZERO_ADDRESS, \"FundRegistry: PPGR not set\");\r\n    return contracts[PPGR];\r\n  }\r\n\r\n  function getACL() external view returns (IACL) {\r\n    require(contracts[ACL] != ZERO_ADDRESS, \"FundRegistry: ACL not set\");\r\n    return IACL(contracts[ACL]);\r\n  }\r\n\r\n  function getStorageAddress() external view returns (address) {\r\n    require(contracts[STORAGE] != ZERO_ADDRESS, \"FundRegistry: STORAGE not set\");\r\n    return contracts[STORAGE];\r\n  }\r\n\r\n  function getMultiSigAddress() external view returns (address payable) {\r\n    require(contracts[MULTISIG] != ZERO_ADDRESS, \"FundRegistry: MULTISIG not set\");\r\n    address payable multiSig = address(uint160(contracts[MULTISIG]));\r\n    return multiSig;\r\n  }\r\n\r\n  function getRAAddress() external view returns (address) {\r\n    require(contracts[RA] != ZERO_ADDRESS, \"FundRegistry: RA not set\");\r\n    return contracts[RA];\r\n  }\r\n\r\n  function getControllerAddress() external view returns (address) {\r\n    require(contracts[CONTROLLER] != ZERO_ADDRESS, \"FundRegistry: CONTROLLER not set\");\r\n    return contracts[CONTROLLER];\r\n  }\r\n\r\n  function getProposalManagerAddress() external view returns (address) {\r\n    require(contracts[PROPOSAL_MANAGER] != ZERO_ADDRESS, \"FundRegistry: PROPOSAL_MANAGER not set\");\r\n    return contracts[PROPOSAL_MANAGER];\r\n  }\r\n\r\n  function getUpgraderAddress() external view returns (address) {\r\n    require(contracts[UPGRADER] != ZERO_ADDRESS, \"FundRegistry: UPGRADER not set\");\r\n    return contracts[UPGRADER];\r\n  }\r\n}\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract ChargesFee is Ownable {\r\n  using SafeERC20 for IERC20;\r\n\r\n  event SetFeeManager(address addr);\r\n  event SetFeeCollector(address addr);\r\n  event SetEthFee(uint256 ethFee);\r\n  event SetGaltFee(uint256 ethFee);\r\n  event WithdrawEth(address indexed to, uint256 amount);\r\n  event WithdrawErc20(address indexed to, address indexed tokenAddress, uint256 amount);\r\n  event WithdrawErc721(address indexed to, address indexed tokenAddress, uint256 tokenId);\r\n\r\n  uint256 public ethFee;\r\n  uint256 public galtFee;\r\n\r\n  address public feeManager;\r\n  address public feeCollector;\r\n\r\n  modifier onlyFeeManager() {\r\n    require(msg.sender == feeManager, \"ChargesFee: caller is not the feeManager\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyFeeCollector() {\r\n    require(msg.sender == feeCollector, \"ChargesFee: caller is not the feeCollector\");\r\n    _;\r\n  }\r\n\r\n  constructor(uint256 _ethFee, uint256 _galtFee) public {\r\n    ethFee = _ethFee;\r\n    galtFee = _galtFee;\r\n  }\r\n\r\n  // ABSTRACT\r\n\r\n  function _galtToken() internal view returns (IERC20);\r\n\r\n  // SETTERS\r\n\r\n  function setFeeManager(address _addr) external onlyOwner {\r\n    feeManager = _addr;\r\n\r\n    emit SetFeeManager(_addr);\r\n  }\r\n\r\n  function setFeeCollector(address _addr) external onlyOwner {\r\n    feeCollector = _addr;\r\n\r\n    emit SetFeeCollector(_addr);\r\n  }\r\n\r\n  function setEthFee(uint256 _ethFee) external onlyFeeManager {\r\n    ethFee = _ethFee;\r\n\r\n    emit SetEthFee(_ethFee);\r\n  }\r\n\r\n  function setGaltFee(uint256 _galtFee) external onlyFeeManager {\r\n    galtFee = _galtFee;\r\n\r\n    emit SetGaltFee(_galtFee);\r\n  }\r\n\r\n  // WITHDRAWERS\r\n\r\n  function withdrawErc20(address _tokenAddress, address _to) external onlyFeeCollector {\r\n    uint256 balance = IERC20(_tokenAddress).balanceOf(address(this));\r\n\r\n    IERC20(_tokenAddress).transfer(_to, balance);\r\n\r\n    emit WithdrawErc20(_to, _tokenAddress, balance);\r\n  }\r\n\r\n  function withdrawErc721(address _tokenAddress, address _to, uint256 _tokenId) external onlyFeeCollector {\r\n    IERC721(_tokenAddress).transferFrom(address(this), _to, _tokenId);\r\n\r\n    emit WithdrawErc721(_to, _tokenAddress, _tokenId);\r\n  }\r\n\r\n  function withdrawEth(address payable _to) external onlyFeeCollector {\r\n    uint256 balance = address(this).balance;\r\n\r\n    _to.transfer(balance);\r\n\r\n    emit WithdrawEth(_to, balance);\r\n  }\r\n\r\n  // INTERNAL\r\n\r\n  function _acceptPayment() internal {\r\n    if (msg.value == 0) {\r\n      _galtToken().transferFrom(msg.sender, address(this), galtFee);\r\n    } else {\r\n      require(msg.value == ethFee, \"Fee and msg.value not equal\");\r\n    }\r\n  }\r\n}\r\n\r\ncontract PrivateFundFactory is ChargesFee {\r\n\r\n  event CreateFundFirstStep(\r\n    bytes32 fundId,\r\n    address fundRegistry,\r\n    address fundACL,\r\n    address fundStorage,\r\n    address fundRA,\r\n    address fundProposalManager,\r\n    address fundMultiSig,\r\n    address fundController,\r\n    address fundUpgrader\r\n  );\r\n\r\n  event CreateFundSecondStep(\r\n    bytes32 fundId,\r\n    uint256 initialTokenCount\r\n  );\r\n\r\n  event CreateFundThirdStep(\r\n    bytes32 fundId,\r\n    uint256 markerCount\r\n  );\r\n\r\n  event CreateFundDone(\r\n    bytes32 fundId\r\n  );\r\n\r\n  event EthFeeWithdrawal(address indexed collector, uint256 amount);\r\n  event GaltFeeWithdrawal(address indexed collector, uint256 amount);\r\n\r\n  event SetDefaultConfigValues(uint256 len);\r\n\r\n  event SetSubFactoryAddresses(\r\n    FundBareFactory fundRAFactory,\r\n    FundBareFactory fundMultiSigFactory,\r\n    PrivateFundStorageFactory fundStorageFactory,\r\n    FundBareFactory fundControllerFactory,\r\n    FundBareFactory fundProposalManagerFactory,\r\n    FundBareFactory fundRegistryFactory,\r\n    FundBareFactory fundACLFactory,\r\n    FundBareFactory fundUpgraderFactory\r\n  );\r\n\r\n  enum Step {\r\n    FIRST,\r\n    SECOND,\r\n    THIRD,\r\n    DONE\r\n  }\r\n\r\n  struct FundContracts {\r\n    address creator;\r\n    address operator;\r\n    Step currentStep;\r\n    FundRegistry fundRegistry;\r\n  }\r\n\r\n  bool internal initialized;\r\n\r\n  IPPGlobalRegistry internal globalRegistry;\r\n\r\n  FundBareFactory public fundRAFactory;\r\n  PrivateFundStorageFactory public fundStorageFactory;\r\n  FundBareFactory public fundMultiSigFactory;\r\n  FundBareFactory public fundControllerFactory;\r\n  FundBareFactory public fundProposalManagerFactory;\r\n  FundBareFactory public fundACLFactory;\r\n  FundBareFactory public fundRegistryFactory;\r\n  FundBareFactory public fundUpgraderFactory;\r\n\r\n  mapping(bytes32 => address) internal managerFactories;\r\n  mapping(bytes32 => FundContracts) public fundContracts;\r\n\r\n  address[] internal defaultMarkerContracts;\r\n  bytes32[] internal defaultMarkerSignatures;\r\n  uint256[] internal defaultSupportValues;\r\n  uint256[] internal defaultQuorumValues;\r\n  uint256[] internal defaultTimeoutValues;\r\n\r\n  bytes4[] internal proposalMarkersSignatures;\r\n  bytes32[] internal proposalMarkersNames;\r\n\r\n  constructor (\r\n    IPPGlobalRegistry _globalRegistry,\r\n    FundBareFactory _fundRAFactory,\r\n    FundBareFactory _fundMultiSigFactory,\r\n    PrivateFundStorageFactory _fundStorageFactory,\r\n    FundBareFactory _fundControllerFactory,\r\n    FundBareFactory _fundProposalManagerFactory,\r\n    FundBareFactory _fundRegistryFactory,\r\n    FundBareFactory _fundACLFactory,\r\n    FundBareFactory _fundUpgraderFactory,\r\n    uint256 _ethFee,\r\n    uint256 _galtFee\r\n  )\r\n    public\r\n    Ownable()\r\n    ChargesFee(_ethFee, _galtFee)\r\n  {\r\n    fundControllerFactory = _fundControllerFactory;\r\n    fundStorageFactory = _fundStorageFactory;\r\n    fundMultiSigFactory = _fundMultiSigFactory;\r\n    fundRAFactory = _fundRAFactory;\r\n    fundProposalManagerFactory = _fundProposalManagerFactory;\r\n    fundRegistryFactory = _fundRegistryFactory;\r\n    fundACLFactory = _fundACLFactory;\r\n    fundUpgraderFactory = _fundUpgraderFactory;\r\n    globalRegistry = _globalRegistry;\r\n  }\r\n\r\n  // OWNER INTERFACE\r\n\r\n  // All the arguments don't fit into a stack limit of constructor,\r\n  // so there is one more method for initialization\r\n  function initialize(bytes4[] calldata _proposalMarkersSignatures, bytes32[] calldata _proposalMarkersNames)\r\n    external\r\n    onlyOwner\r\n  {\r\n    require(initialized == false, \"Already initialized\");\r\n\r\n    initialized = true;\r\n\r\n    proposalMarkersSignatures = _proposalMarkersSignatures;\r\n    proposalMarkersNames = _proposalMarkersNames;\r\n  }\r\n\r\n  function setSubFactoryAddresses (\r\n    FundBareFactory _fundRAFactory,\r\n    FundBareFactory _fundMultiSigFactory,\r\n    PrivateFundStorageFactory _fundStorageFactory,\r\n    FundBareFactory _fundControllerFactory,\r\n    FundBareFactory _fundProposalManagerFactory,\r\n    FundBareFactory _fundRegistryFactory,\r\n    FundBareFactory _fundACLFactory,\r\n    FundBareFactory _fundUpgraderFactory\r\n  )\r\n    external\r\n    onlyOwner\r\n  {\r\n    fundControllerFactory = _fundControllerFactory;\r\n    fundStorageFactory = _fundStorageFactory;\r\n    fundMultiSigFactory = _fundMultiSigFactory;\r\n    fundRAFactory = _fundRAFactory;\r\n    fundProposalManagerFactory = _fundProposalManagerFactory;\r\n    fundRegistryFactory = _fundRegistryFactory;\r\n    fundACLFactory = _fundACLFactory;\r\n    fundUpgraderFactory = _fundUpgraderFactory;\r\n\r\n    emit SetSubFactoryAddresses(\r\n      _fundRAFactory,\r\n      _fundMultiSigFactory,\r\n      _fundStorageFactory,\r\n      _fundControllerFactory,\r\n      _fundProposalManagerFactory,\r\n      _fundRegistryFactory,\r\n      _fundACLFactory,\r\n      _fundUpgraderFactory\r\n    );\r\n  }\r\n\r\n  function setDefaultConfigValues(\r\n    address[] calldata _markersContracts,\r\n    bytes32[] calldata _markersSignatures,\r\n    uint256[] calldata _supportValues,\r\n    uint256[] calldata _quorumValues,\r\n    uint256[] calldata _timeoutValues\r\n  )\r\n    external\r\n    onlyOwner\r\n  {\r\n    uint256 len = _markersContracts.length;\r\n    require(\r\n      len == _markersSignatures.length && len == _supportValues.length && len == _quorumValues.length && len == _timeoutValues.length,\r\n      \"Thresholds key and value array lengths mismatch\"\r\n    );\r\n\r\n    defaultMarkerContracts = _markersContracts;\r\n    defaultMarkerSignatures = _markersSignatures;\r\n    defaultSupportValues = _supportValues;\r\n    defaultQuorumValues = _quorumValues;\r\n    defaultTimeoutValues = _timeoutValues;\r\n\r\n    emit SetDefaultConfigValues(len);\r\n  }\r\n\r\n  // USER INTERFACE\r\n\r\n  function buildFirstStep(\r\n    address operator,\r\n    bool _isPrivate,\r\n    uint256 _defaultProposalSupport,\r\n    uint256 _defaultProposalQuorum,\r\n    uint256 _defaultProposalTimeout,\r\n    uint256 _periodLength,\r\n    address[] calldata _initialMultiSigOwners,\r\n    uint256 _initialMultiSigRequired\r\n  )\r\n    external\r\n    payable\r\n    returns (bytes32 fundId)\r\n  {\r\n    fundId = keccak256(abi.encode(blockhash(block.number - 1), msg.sender));\r\n\r\n    FundContracts storage c = fundContracts[fundId];\r\n    require(c.currentStep == Step.FIRST, \"Requires first step\");\r\n\r\n    _acceptPayment();\r\n\r\n    FundRegistry fundRegistry = FundRegistry(fundRegistryFactory.build());\r\n    IACL fundACL = IACL(fundACLFactory.build());\r\n\r\n    PrivateFundStorage fundStorage = fundStorageFactory.build(\r\n      fundRegistry,\r\n      _isPrivate,\r\n      _defaultProposalSupport,\r\n      _defaultProposalQuorum,\r\n      _defaultProposalTimeout,\r\n      _periodLength\r\n    );\r\n\r\n    c.creator = msg.sender;\r\n    c.operator = operator;\r\n    c.fundRegistry = fundRegistry;\r\n\r\n    fundRegistry.setContract(fundRegistry.PPGR(), address(globalRegistry));\r\n    fundRegistry.setContract(fundRegistry.ACL(), address(fundACL));\r\n    fundRegistry.setContract(fundRegistry.STORAGE(), address(fundStorage));\r\n\r\n    address _fundMultiSigNonPayable = fundMultiSigFactory.build(\r\n      abi.encodeWithSignature(\r\n        \"initialize(address[],uint256,address)\",\r\n        _initialMultiSigOwners,\r\n        _initialMultiSigRequired,\r\n        address(fundRegistry)\r\n      ),\r\n      false,\r\n      true\r\n    );\r\n    address payable _fundMultiSig = address(uint160(_fundMultiSigNonPayable));\r\n\r\n    address _fundUpgrader = fundUpgraderFactory.build(address(fundRegistry), false, true);\r\n    address _fundController = fundControllerFactory.build(address(fundRegistry), false, true);\r\n    address _fundRA = fundRAFactory.build(address(fundRegistry), false, true);\r\n    address _fundProposalManager = fundProposalManagerFactory.build(address(fundRegistry), false, true);\r\n\r\n    fundRegistry.setContract(c.fundRegistry.MULTISIG(), _fundMultiSig);\r\n    fundRegistry.setContract(c.fundRegistry.CONTROLLER(), _fundController);\r\n    fundRegistry.setContract(c.fundRegistry.UPGRADER(), _fundUpgrader);\r\n    fundRegistry.setContract(c.fundRegistry.RA(), _fundRA);\r\n    fundRegistry.setContract(c.fundRegistry.PROPOSAL_MANAGER(), _fundProposalManager);\r\n\r\n    fundACL.setRole(fundStorage.ROLE_CONFIG_MANAGER(), _fundProposalManager, true);\r\n    fundACL.setRole(fundStorage.ROLE_NEW_MEMBER_MANAGER(), _fundProposalManager, true);\r\n    fundACL.setRole(fundStorage.ROLE_EXPEL_MEMBER_MANAGER(), _fundProposalManager, true);\r\n    fundACL.setRole(fundStorage.ROLE_FINE_MEMBER_INCREMENT_MANAGER(), _fundProposalManager, true);\r\n    fundACL.setRole(fundStorage.ROLE_FINE_MEMBER_DECREMENT_MANAGER(), _fundProposalManager, true);\r\n    fundACL.setRole(fundStorage.ROLE_CHANGE_NAME_AND_DESCRIPTION_MANAGER(), _fundProposalManager, true);\r\n    fundACL.setRole(fundStorage.ROLE_ADD_FUND_RULE_MANAGER(), _fundProposalManager, true);\r\n    fundACL.setRole(fundStorage.ROLE_DEACTIVATE_FUND_RULE_MANAGER(), _fundProposalManager, true);\r\n    fundACL.setRole(fundStorage.ROLE_FEE_MANAGER(), _fundProposalManager, true);\r\n    fundACL.setRole(fundStorage.ROLE_MEMBER_DETAILS_MANAGER(), _fundProposalManager, true);\r\n    fundACL.setRole(fundStorage.ROLE_MULTI_SIG_WITHDRAWAL_LIMITS_MANAGER(), _fundProposalManager, true);\r\n    fundACL.setRole(fundStorage.ROLE_MEMBER_IDENTIFICATION_MANAGER(), _fundProposalManager, true);\r\n    fundACL.setRole(fundStorage.ROLE_PROPOSAL_THRESHOLD_MANAGER(), _fundProposalManager, true);\r\n    fundACL.setRole(fundStorage.ROLE_DEFAULT_PROPOSAL_THRESHOLD_MANAGER(), _fundProposalManager, true);\r\n    fundACL.setRole(fundStorage.ROLE_COMMUNITY_APPS_MANAGER(), _fundProposalManager, true);\r\n    fundACL.setRole(fundStorage.ROLE_PROPOSAL_MARKERS_MANAGER(), _fundProposalManager, true);\r\n    fundACL.setRole(fundStorage.ROLE_FINE_MEMBER_DECREMENT_MANAGER(), _fundController, true);\r\n    fundACL.setRole(fundStorage.ROLE_DECREMENT_TOKEN_REPUTATION(), _fundRA, true);\r\n    fundACL.setRole(fundStorage.ROLE_MULTISIG(), _fundMultiSig, true);\r\n    fundACL.setRole(FundUpgrader(_fundUpgrader).ROLE_UPGRADE_SCRIPT_MANAGER(), _fundProposalManager, true);\r\n    fundACL.setRole(FundUpgrader(_fundUpgrader).ROLE_IMPL_UPGRADE_MANAGER(), _fundProposalManager, true);\r\n    fundACL.setRole(FundMultiSig(_fundMultiSig).ROLE_OWNER_MANAGER(), _fundProposalManager, true);\r\n\r\n    fundACL.setRole(fundStorage.ROLE_COMMUNITY_APPS_MANAGER(), address(this), true);\r\n    fundStorage.addCommunityApp(_fundProposalManager, bytes32(\"\"), bytes32(\"\"), \"Default\");\r\n    fundACL.setRole(fundStorage.ROLE_COMMUNITY_APPS_MANAGER(), address(this), false);\r\n\r\n    c.currentStep = Step.SECOND;\r\n\r\n    emit CreateFundFirstStep(\r\n      fundId,\r\n      address(fundRegistry),\r\n      address(fundACL),\r\n      address(fundStorage),\r\n      _fundRA,\r\n      _fundProposalManager,\r\n      _fundMultiSig,\r\n      _fundController,\r\n      _fundUpgrader\r\n    );\r\n  }\r\n\r\n  function buildSecondStep(\r\n    bytes32 _fundId,\r\n    bool _finishFlag,\r\n    string calldata _name,\r\n    string calldata _dataLink,\r\n    address[] calldata _initialRegistriesToApprove,\r\n    uint256[] calldata _initialTokensToApprove\r\n  )\r\n    external\r\n  {\r\n    FundContracts storage c = fundContracts[_fundId];\r\n    require(msg.sender == c.creator || msg.sender == c.operator, \"Only creator/operator allowed\");\r\n    require(c.currentStep == Step.SECOND, \"Requires second step\");\r\n\r\n    PrivateFundStorage _fundStorage = PrivateFundStorage(c.fundRegistry.getStorageAddress());\r\n    IACL _fundACL = c.fundRegistry.getACL();\r\n    address _fundProposalManager = c.fundRegistry.getProposalManagerAddress();\r\n\r\n    _fundACL.setRole(_fundStorage.ROLE_CHANGE_NAME_AND_DESCRIPTION_MANAGER(), address(this), true);\r\n    _fundStorage.setNameAndDataLink(_name, _dataLink);\r\n    _fundACL.setRole(_fundStorage.ROLE_CHANGE_NAME_AND_DESCRIPTION_MANAGER(), address(this), false);\r\n\r\n    uint256 len = _initialTokensToApprove.length;\r\n\r\n    _fundACL.setRole(_fundStorage.ROLE_NEW_MEMBER_MANAGER(), address(this), true);\r\n\r\n    _fundStorage.approveMintAll(_initialRegistriesToApprove, _initialTokensToApprove);\r\n\r\n    _fundACL.setRole(_fundStorage.ROLE_NEW_MEMBER_MANAGER(), address(this), false);\r\n\r\n    _fundACL.setRole(_fundStorage.ROLE_PROPOSAL_MARKERS_MANAGER(), address(this), true);\r\n\r\n    for (uint i = 0; i < proposalMarkersSignatures.length; i++) {\r\n      if (bytes8(proposalMarkersNames[i]) == bytes8(\"storage.\")) {\r\n        _fundStorage.addProposalMarker(\r\n          proposalMarkersSignatures[i],\r\n          address(_fundStorage),\r\n          _fundProposalManager,\r\n          proposalMarkersNames[i],\r\n          \"\"\r\n        );\r\n      }\r\n      if (bytes8(proposalMarkersNames[i]) == bytes8(\"multiSig\")) {\r\n        _fundStorage.addProposalMarker(\r\n          proposalMarkersSignatures[i],\r\n          c.fundRegistry.getMultiSigAddress(),\r\n          _fundProposalManager,\r\n          proposalMarkersNames[i],\r\n          \"\"\r\n        );\r\n      }\r\n    }\r\n    _fundACL.setRole(_fundStorage.ROLE_PROPOSAL_MARKERS_MANAGER(), address(this), false);\r\n\r\n    if (_finishFlag == true) {\r\n      _applyFundDefaultConfigValues(_fundId);\r\n      _finish(_fundId);\r\n    } else {\r\n      c.currentStep = Step.THIRD;\r\n      emit CreateFundSecondStep(_fundId, len);\r\n    }\r\n  }\r\n\r\n  function _applyFundDefaultConfigValues(bytes32 _fundId) internal {\r\n    _applyMarkers(\r\n      _fundId,\r\n      _generateFundDefaultMarkers(_fundId),\r\n      defaultSupportValues,\r\n      defaultQuorumValues,\r\n      defaultTimeoutValues\r\n    );\r\n  }\r\n\r\n  function _generateFundDefaultMarkers(bytes32 _fundId) internal returns (bytes32[] memory) {\r\n    FundContracts storage c = fundContracts[_fundId];\r\n    IAbstractFundStorage fundStorage = IAbstractFundStorage(c.fundRegistry.getStorageAddress());\r\n    uint256 len = defaultMarkerContracts.length;\r\n    bytes32[] memory markers = new bytes32[](len);\r\n    bytes32 marker;\r\n\r\n    for (uint256 i = 0; i < len; i++) {\r\n      address current = defaultMarkerContracts[i];\r\n      bytes32 signature = defaultMarkerSignatures[i];\r\n\r\n      // address code for fundStorage\r\n      if (current == address(150)) {\r\n        marker = getThresholdMarker(address(fundStorage), signature);\r\n      // address code for fundMultiSig\r\n      } else if (current == address(151)) {\r\n        marker = getThresholdMarker(c.fundRegistry.getMultiSigAddress(), signature);\r\n      // address code for fundUpgrader\r\n      } else if (current == address(152)) {\r\n        marker = getThresholdMarker(c.fundRegistry.getUpgraderAddress(), signature);\r\n      } else {\r\n        marker = getThresholdMarker(current, signature);\r\n      }\r\n      markers[i] = marker;\r\n    }\r\n\r\n    return markers;\r\n  }\r\n\r\n  function buildThirdStep(\r\n    bytes32 _fundId,\r\n    bytes32[] calldata _markers,\r\n    uint256[] calldata _supportValues,\r\n    uint256[] calldata _quorumValues,\r\n    uint256[] calldata _timeoutValues\r\n  )\r\n    external\r\n  {\r\n    FundContracts storage c = fundContracts[_fundId];\r\n    require(msg.sender == c.creator || msg.sender == c.operator, \"Only creator/operator allowed\");\r\n    require(c.currentStep == Step.THIRD, \"Requires third step\");\r\n\r\n    uint256 len = _markers.length;\r\n    require(\r\n      len == _supportValues.length && len == _quorumValues.length && len == _timeoutValues.length,\r\n      \"Thresholds key and value array lengths mismatch\"\r\n    );\r\n\r\n    _applyMarkers(\r\n      _fundId,\r\n      _markers,\r\n      _supportValues,\r\n      _quorumValues,\r\n      _timeoutValues\r\n    );\r\n\r\n    emit CreateFundThirdStep(_fundId, len);\r\n\r\n    _finish(_fundId);\r\n  }\r\n\r\n  function _applyMarkers(\r\n    bytes32 _fundId,\r\n    bytes32[] memory _markers,\r\n    uint256[] memory _supportValues,\r\n    uint256[] memory _quorumValues,\r\n    uint256[] memory _timeoutValues\r\n  )\r\n    internal\r\n  {\r\n    FundContracts storage c = fundContracts[_fundId];\r\n\r\n    PrivateFundStorage _fundStorage = PrivateFundStorage(c.fundRegistry.getStorageAddress());\r\n    IACL _fundACL = c.fundRegistry.getACL();\r\n    uint256 len = _markers.length;\r\n\r\n    _fundACL.setRole(_fundStorage.ROLE_PROPOSAL_THRESHOLD_MANAGER(), address(this), true);\r\n\r\n    for (uint256 i = 0; i < len; i++) {\r\n      _fundStorage.setProposalConfig(_markers[i], _supportValues[i], _quorumValues[i], _timeoutValues[i]);\r\n    }\r\n\r\n    _fundACL.setRole(_fundStorage.ROLE_PROPOSAL_THRESHOLD_MANAGER(), address(this), false);\r\n  }\r\n\r\n  function _finish(bytes32 _fundId) internal {\r\n    FundContracts storage c = fundContracts[_fundId];\r\n    address owner = c.fundRegistry.getUpgraderAddress();\r\n    IACL _fundACL = c.fundRegistry.getACL();\r\n\r\n    IOwnedUpgradeabilityProxy(address(c.fundRegistry)).transferProxyOwnership(owner);\r\n    IOwnedUpgradeabilityProxy(address(_fundACL)).transferProxyOwnership(owner);\r\n    IOwnedUpgradeabilityProxy(c.fundRegistry.getStorageAddress()).transferProxyOwnership(owner);\r\n    IOwnedUpgradeabilityProxy(c.fundRegistry.getProposalManagerAddress()).transferProxyOwnership(owner);\r\n    IOwnedUpgradeabilityProxy(c.fundRegistry.getRAAddress()).transferProxyOwnership(owner);\r\n    IOwnedUpgradeabilityProxy(c.fundRegistry.getControllerAddress()).transferProxyOwnership(owner);\r\n    IOwnedUpgradeabilityProxy(c.fundRegistry.getUpgraderAddress()).transferProxyOwnership(owner);\r\n\r\n    c.currentStep = Step.DONE;\r\n\r\n    c.fundRegistry.transferOwnership(owner);\r\n    Ownable(address(_fundACL)).transferOwnership(owner);\r\n\r\n    emit CreateFundDone(_fundId);\r\n  }\r\n\r\n  // INTERNAL\r\n\r\n  function _galtToken() internal view returns (IERC20) {\r\n    return IERC20(globalRegistry.getGaltTokenAddress());\r\n  }\r\n\r\n  function getThresholdMarker(address _destination, bytes32 _data) public pure returns(bytes32 marker) {\r\n    bytes32 methodName;\r\n\r\n    assembly {\r\n      methodName := and(_data, 0xffffffff00000000000000000000000000000000000000000000000000000000)\r\n    }\r\n\r\n    return keccak256(abi.encode(_destination, methodName));\r\n  }\r\n\r\n  // GETTERS\r\n\r\n  function getCurrentStep(bytes32 _fundId) external view returns (Step) {\r\n    return fundContracts[_fundId].currentStep;\r\n  }\r\n\r\n  function getDefaultMarkerContracts() external view returns (address[] memory) {\r\n    return defaultMarkerContracts;\r\n  }\r\n\r\n  function getDefaultMarkerSignatures() external view returns (bytes32[] memory) {\r\n    return defaultMarkerSignatures;\r\n  }\r\n\r\n  function getDefaultSupportValues() external view returns (uint256[] memory) {\r\n    return defaultSupportValues;\r\n  }\r\n\r\n  function getDefaultQuorumValues() external view returns (uint256[] memory) {\r\n    return defaultQuorumValues;\r\n  }\r\n\r\n  function getDefaultTimeoutValues() external view returns (uint256[] memory) {\r\n    return defaultTimeoutValues;\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IPPGlobalRegistry\",\"name\":\"_globalRegistry\",\"type\":\"address\"},{\"internalType\":\"contract FundBareFactory\",\"name\":\"_fundRAFactory\",\"type\":\"address\"},{\"internalType\":\"contract FundBareFactory\",\"name\":\"_fundMultiSigFactory\",\"type\":\"address\"},{\"internalType\":\"contract PrivateFundStorageFactory\",\"name\":\"_fundStorageFactory\",\"type\":\"address\"},{\"internalType\":\"contract FundBareFactory\",\"name\":\"_fundControllerFactory\",\"type\":\"address\"},{\"internalType\":\"contract FundBareFactory\",\"name\":\"_fundProposalManagerFactory\",\"type\":\"address\"},{\"internalType\":\"contract FundBareFactory\",\"name\":\"_fundRegistryFactory\",\"type\":\"address\"},{\"internalType\":\"contract FundBareFactory\",\"name\":\"_fundACLFactory\",\"type\":\"address\"},{\"internalType\":\"contract FundBareFactory\",\"name\":\"_fundUpgraderFactory\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_ethFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_galtFee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"fundId\",\"type\":\"bytes32\"}],\"name\":\"CreateFundDone\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"fundId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fundRegistry\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fundACL\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fundStorage\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fundRA\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fundProposalManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fundMultiSig\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fundController\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fundUpgrader\",\"type\":\"address\"}],\"name\":\"CreateFundFirstStep\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"fundId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initialTokenCount\",\"type\":\"uint256\"}],\"name\":\"CreateFundSecondStep\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"fundId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"markerCount\",\"type\":\"uint256\"}],\"name\":\"CreateFundThirdStep\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EthFeeWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"GaltFeeWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"len\",\"type\":\"uint256\"}],\"name\":\"SetDefaultConfigValues\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethFee\",\"type\":\"uint256\"}],\"name\":\"SetEthFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"SetFeeCollector\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"SetFeeManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethFee\",\"type\":\"uint256\"}],\"name\":\"SetGaltFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract FundBareFactory\",\"name\":\"fundRAFactory\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract FundBareFactory\",\"name\":\"fundMultiSigFactory\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract PrivateFundStorageFactory\",\"name\":\"fundStorageFactory\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract FundBareFactory\",\"name\":\"fundControllerFactory\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract FundBareFactory\",\"name\":\"fundProposalManagerFactory\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract FundBareFactory\",\"name\":\"fundRegistryFactory\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract FundBareFactory\",\"name\":\"fundACLFactory\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract FundBareFactory\",\"name\":\"fundUpgraderFactory\",\"type\":\"address\"}],\"name\":\"SetSubFactoryAddresses\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawErc20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"WithdrawErc721\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawEth\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isPrivate\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_defaultProposalSupport\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_defaultProposalQuorum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_defaultProposalTimeout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_periodLength\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_initialMultiSigOwners\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_initialMultiSigRequired\",\"type\":\"uint256\"}],\"name\":\"buildFirstStep\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"fundId\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_fundId\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"_finishFlag\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_dataLink\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"_initialRegistriesToApprove\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_initialTokensToApprove\",\"type\":\"uint256[]\"}],\"name\":\"buildSecondStep\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_fundId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"_markers\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_supportValues\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_quorumValues\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_timeoutValues\",\"type\":\"uint256[]\"}],\"name\":\"buildThirdStep\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundACLFactory\",\"outputs\":[{\"internalType\":\"contract FundBareFactory\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"fundContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"enum PrivateFundFactory.Step\",\"name\":\"currentStep\",\"type\":\"uint8\"},{\"internalType\":\"contract FundRegistry\",\"name\":\"fundRegistry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundControllerFactory\",\"outputs\":[{\"internalType\":\"contract FundBareFactory\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundMultiSigFactory\",\"outputs\":[{\"internalType\":\"contract FundBareFactory\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundProposalManagerFactory\",\"outputs\":[{\"internalType\":\"contract FundBareFactory\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundRAFactory\",\"outputs\":[{\"internalType\":\"contract FundBareFactory\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundRegistryFactory\",\"outputs\":[{\"internalType\":\"contract FundBareFactory\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundStorageFactory\",\"outputs\":[{\"internalType\":\"contract PrivateFundStorageFactory\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundUpgraderFactory\",\"outputs\":[{\"internalType\":\"contract FundBareFactory\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"galtFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_fundId\",\"type\":\"bytes32\"}],\"name\":\"getCurrentStep\",\"outputs\":[{\"internalType\":\"enum PrivateFundFactory.Step\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDefaultMarkerContracts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDefaultMarkerSignatures\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDefaultQuorumValues\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDefaultSupportValues\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDefaultTimeoutValues\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"getThresholdMarker\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"marker\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"_proposalMarkersSignatures\",\"type\":\"bytes4[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proposalMarkersNames\",\"type\":\"bytes32[]\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_markersContracts\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_markersSignatures\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_supportValues\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_quorumValues\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_timeoutValues\",\"type\":\"uint256[]\"}],\"name\":\"setDefaultConfigValues\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethFee\",\"type\":\"uint256\"}],\"name\":\"setEthFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setFeeManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_galtFee\",\"type\":\"uint256\"}],\"name\":\"setGaltFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract FundBareFactory\",\"name\":\"_fundRAFactory\",\"type\":\"address\"},{\"internalType\":\"contract FundBareFactory\",\"name\":\"_fundMultiSigFactory\",\"type\":\"address\"},{\"internalType\":\"contract PrivateFundStorageFactory\",\"name\":\"_fundStorageFactory\",\"type\":\"address\"},{\"internalType\":\"contract FundBareFactory\",\"name\":\"_fundControllerFactory\",\"type\":\"address\"},{\"internalType\":\"contract FundBareFactory\",\"name\":\"_fundProposalManagerFactory\",\"type\":\"address\"},{\"internalType\":\"contract FundBareFactory\",\"name\":\"_fundRegistryFactory\",\"type\":\"address\"},{\"internalType\":\"contract FundBareFactory\",\"name\":\"_fundACLFactory\",\"type\":\"address\"},{\"internalType\":\"contract FundBareFactory\",\"name\":\"_fundUpgraderFactory\",\"type\":\"address\"}],\"name\":\"setSubFactoryAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawErc20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"withdrawErc721\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PrivateFundFactory","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000002d05d7dfbe60af0b4e55856820321253f04b379000000000000000000000000d1602cca4b64ef33826a878bd81625cff8fcccf2000000000000000000000000fbdf7b4391bf50986083d56d45b603c70aeb7750000000000000000000000000a1c38b9a4d363ee32ea1daa997fd6b86e22a32a0000000000000000000000000f9bcbe8c64b238ef10aba03be85af314b0b2f73900000000000000000000000087ac646401cdd90470e1ef3218bb2949a9697d45000000000000000000000000b6e9ef1f886f6da4d047e57daa2b0e1471729faa00000000000000000000000067f3081ff62ed0ef22861762a256004786d02069000000000000000000000000e454738be9dbf76e403dec357636c76501ee0e8b000000000000000000000000000000000000000000000000016345785d8a00000000000000000000000000000000000000000000000000000000000000000000","Library":"","LicenseType":"None","SwarmSource":"bzzr://126c5f42ed61c991da8a383ad5062657454f00449911286a69ba9e7a67d19587"}]}