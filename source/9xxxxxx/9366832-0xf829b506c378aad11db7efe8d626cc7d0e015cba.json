{"status":"1","message":"OK","result":[{"SourceCode":"{\"ActionKyberTrade.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\nimport \\\"./GelatoActionsStandard.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n// import \\\"../../external/SafeERC20.sol\\\";\\nimport \\\"./IKyber.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\ncontract ActionKyberTrade is GelatoActionsStandard {\\n    // using SafeERC20 for IERC20; \\u003c- internal library methods vs. try/catch\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    // actionSelector public state variable np due to this.actionSelector constant issue\\n    function actionSelector() external pure override returns(bytes4) {\\n        return this.action.selector;\\n    }\\n    uint256 public constant override actionGas = 1200000;\\n\\n    function action(\\n        // Standard Action Params\\n        address _user,\\n        address _userProxy,\\n        address _sendToken,\\n        uint256 _sendAmt,\\n        // Specific Action Params\\n        address _receiveToken\\n    )\\n        external\\n        virtual\\n    {\\n        require(address(this) == _userProxy, \\\"ErrorUserProxy\\\");\\n\\n        // !!!!!!!!! MAINNET !!!!!!\\n        address kyberAddress = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;\\n\\n        IERC20 sendERC20 = IERC20(_sendToken);\\n        try sendERC20.transferFrom(_user, _userProxy, _sendAmt) {} catch {\\n            revert(\\\"ErrorTransferFromUser\\\");\\n        }\\n        try sendERC20.approve(kyberAddress, _sendAmt) {} catch {\\n            revert(\\\"ErrorApproveKyber\\\");\\n        }\\n\\n        // !! Dapp Interaction !!\\n        try IKyber(kyberAddress).trade(\\n            _sendToken,\\n            _sendAmt,\\n            _receiveToken,\\n            _user,  // receiver\\n            2**255,\\n            0,  // minConversionRate (if price condition, limit order still possible)\\n            address(0xe1F076849B781b1395Fd332dC1758Dbc129be6EC)  // fee-sharing: gelato-node\\n        )\\n            returns(uint256 receiveAmt)\\n        {\\n            emit LogTwoWay(\\n                _user,  // origin\\n                _sendToken,\\n                _sendAmt,\\n                kyberAddress,  // destination\\n                _receiveToken,\\n                receiveAmt,\\n                _user  // receiver\\n            );\\n        } catch {\\n            revert(\\\"KyberTradeError\\\");\\n        }\\n    }\\n\\n    // ====== ACTION CONDITIONS CHECK ==========\\n    // Overriding and extending GelatoActionsStandard\\u0027s function (optional)\\n    function actionConditionsCheck(bytes calldata _actionPayloadWithSelector)\\n        external\\n        view\\n        override\\n        virtual\\n        returns(string memory)  // actionCondition\\n    {\\n        (address _user, address _userProxy, address _sendToken, uint256 _sendAmt) = abi.decode(\\n            _actionPayloadWithSelector[4:132],\\n            (address,address,address,uint256)\\n        );\\n        return _actionConditionsCheck(_user, _userProxy, _sendToken, _sendAmt);\\n    }\\n\\n    function _actionConditionsCheck(\\n        address _user,\\n        address _userProxy,\\n        address _sendToken,\\n        uint256 _sendAmt\\n    )\\n        internal\\n        view\\n        virtual\\n        returns(string memory)  // actionCondition\\n    {\\n        if (!_isUserOwnerOfUserProxy(_user, _userProxy))\\n            return \\\"ActionKyberTrade: NotOkUserProxyOwner\\\";\\n\\n        if (!_sendToken.isContract()) return \\\"ActionKyberTrade: NotOkSrcAddress\\\";\\n\\n        IERC20 sendERC20 = IERC20(_sendToken);\\n        try sendERC20.balanceOf(_user) returns(uint256 userSendTokenBalance) {\\n            if (userSendTokenBalance \\u003c _sendAmt)\\n                return \\\"ActionKyberTrade: NotOkUserBalance\\\";\\n        } catch {\\n            return \\\"ActionKyberTrade: ErrorBalanceOf\\\";\\n        }\\n        try sendERC20.allowance(_user, _userProxy) returns(uint256 userProxySendTokenAllowance) {\\n            if (userProxySendTokenAllowance \\u003c _sendAmt)\\n                return \\\"ActionKyberTrade: NotOkUserProxySendTokenAllowance\\\";\\n        } catch {\\n            return \\\"ActionKyberTrade: ErrorAllowance\\\";\\n        }\\n\\n        // STANDARD return string to signal actionConditions Ok\\n        return \\\"ok\\\";\\n    }\\n\\n    // ============ API for FrontEnds ===========\\n    function getUsersSendTokenBalance(\\n        // Standard Action Params\\n        address _user,\\n        address _userProxy,\\n        // Specific Action Params\\n        address _sendToken,  // sendToken\\n        uint256,\\n        address\\n    )\\n        external\\n        view\\n        virtual\\n        returns(uint256)\\n    {\\n        _userProxy;  // silence warning\\n        IERC20 sendERC20 = IERC20(_sendToken);\\n        try sendERC20.balanceOf(_user) returns(uint256 userSendTokenBalance) {\\n            return userSendTokenBalance;\\n        } catch {\\n            revert(\\n                \\\"Error: ActionKyberTrade.getUsersSendTokenBalance: balanceOf\\\"\\n            );\\n        }\\n    }\\n}\\n\"},\"Address.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\n     * execution of a contract\\u0027s constructor, its address will be reported as\\n     * not containing a contract.\\n     *\\n     * IMPORTANT: It is unsafe to assume that an address for which this\\n     * function returns false is an externally-owned account (EOA) and not a\\n     * contract.\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != 0x0 \\u0026\\u0026 codehash != accountHash);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account) internal pure returns (address payable) {\\n        return address(uint160(account));\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"},\"GelatoActionsStandard.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\nimport \\\"./IGelatoAction.sol\\\";\\nimport \\\"./IGelatoUserProxy.sol\\\";\\n\\n/// @title GelatoActionsStandard\\n/// @dev find all the NatSpecs inside IGelatoAction\\nabstract contract GelatoActionsStandard is IGelatoAction {\\n\\n    event LogOneWay(\\n        address origin,\\n        address sendToken,\\n        uint256 sendAmount,\\n        address destination\\n    );\\n\\n    event LogTwoWay(\\n        address origin,\\n        address sendToken,\\n        uint256 sendAmount,\\n        address destination,\\n        address receiveToken,\\n        uint256 receiveAmount,\\n        address receiver\\n    );\\n\\n    /* CAUTION: all actions must have their action() function according to the\\n    following standard format:\\n        function action(\\n            address _user,\\n            address _userProxy,\\n            address _source,\\n            uint256 _sourceAmount,\\n            address _destination,\\n            ...\\n        )\\n            external;\\n    action function not defined here because non-overridable, due to\\n    different arguments passed across different actions\\n    */\\n\\n    function actionConditionsCheck(bytes calldata)  // _actionPayloadWithSelector\\n        external\\n        view\\n        override\\n        virtual\\n        returns(string memory)  // actionCondition\\n    {\\n        this;\\n        // Standard return value for actionConditions fulfilled and no erros:\\n        return \\\"ok\\\";\\n    }\\n\\n    /// All actions must override this with their own implementation\\n    /*function getUsersSendTokenBalance(\\n        address _user,\\n        address _userProxy,\\n        address _source,\\n        uint256 _sourceAmount,\\n        address _destination,\\n        ...\\n    )\\n        external\\n        view\\n        override\\n        virtual\\n        returns(uint256 userSrcBalance);\\n    getUsersSendTokenBalance not defined here because non-overridable, due to\\n    different arguments passed across different actions\\n    */\\n\\n    function _isUserOwnerOfUserProxy(address _user, address _userProxy)\\n        internal\\n        view\\n        virtual\\n        returns(bool)\\n    {\\n        address owner = IGelatoUserProxy(_userProxy).user();\\n        return _user == owner;\\n    }\\n}\\n\"},\"GelatoCoreEnums.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\nabstract contract GelatoCoreEnums {\\n\\n    enum CanExecuteResults {\\n        ExecutionClaimAlreadyExecutedOrCancelled,\\n        ExecutionClaimNonExistant,\\n        ExecutionClaimExpired,\\n        WrongCalldata,  // also returns if a not-selected executor calls fn\\n        ConditionNotOk,\\n        UnhandledConditionError,\\n        Executable\\n    }\\n\\n    // Not needed atm due to revert with string memory reason\\n    /* enum ExecutionResults {\\n        ActionGasNotOk,\\n        ActionNotOk,  // Mostly for caught/handled (by action) action errors\\n        DappNotOk,  // Mostly for caught/handled (by action) dapp errors\\n        UnhandledActionError,\\n        UnhandledUserProxyError,\\n        Success\\n    } */\\n\\n    enum StandardReason { Ok, NotOk, UnhandledError }\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IGelatoAction.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/// @title IGelatoAction - solidity interface of GelatoActionsStandard\\n/// @notice all the APIs and events of GelatoActionsStandard\\n/// @dev all the APIs are implemented inside GelatoActionsStandard\\ninterface IGelatoAction {\\n    function actionSelector() external pure returns(bytes4);\\n    function actionGas() external pure returns(uint256);\\n\\n    /* CAUTION: all actions must have their action() function according to the\\n    following standard format:\\n        function action(\\n            address _user,\\n            address _userProxy,\\n            address _source,\\n            uint256 _sourceAmount,\\n            address _destination,\\n            ...\\n        )\\n            external;\\n    action function not defined here because non-overridable, due to\\n    different arguments passed across different actions\\n    */\\n\\n    /**\\n     * @notice Returns whether the action-specific conditions are fulfilled\\n     * @dev if actions have specific conditions they should override and extend this fn\\n     * @param _actionPayloadWithSelector: the actionPayload (with actionSelector)\\n     * @return actionCondition\\n     */\\n    function actionConditionsCheck(bytes calldata _actionPayloadWithSelector)\\n        external\\n        view\\n        returns(string memory);\\n\\n    /// All actions must override this with their own implementation\\n    /*function getUsersSendTokenBalance(\\n        address _user,\\n        address _userProxy,\\n        address _source,\\n        uint256 _sourceAmount,\\n        address _destination,\\n        ...\\n    )\\n        external\\n        view\\n        override\\n        virtual\\n        returns(uint256 userSrcBalance);\\n    getUsersSendTokenBalance not defined here because non-overridable, due to\\n    different arguments passed across different actions\\n    */\\n}\"},\"IGelatoUserProxy.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\nimport \\\"./IGelatoAction.sol\\\";\\nimport \\\"./GelatoCoreEnums.sol\\\";\\n\\n/// @title IGelatoUserProxy - solidity interface of GelatoConditionsStandard\\n/// @notice GelatoUserProxy.execute() API called by gelatoCore during .execute()\\n/// @dev all the APIs are implemented inside GelatoUserProxy\\ninterface IGelatoUserProxy {\\n    function callAccount(address, bytes calldata) external payable returns(bool, bytes memory);\\n    function delegatecallAccount(address, bytes calldata) external payable returns(bool, bytes memory);\\n\\n    function delegatecallGelatoAction(\\n        IGelatoAction _action,\\n        bytes calldata _actionPayloadWithSelector,\\n        uint256 _actionGas\\n    )\\n        external\\n        payable;\\n\\n    function user() external view returns(address);\\n    function gelatoCore() external view returns(address);\\n}\"},\"IKyber.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\ninterface IKyber {\\n    /**\\n     * @dev Makes a trade between src and dest token and send dest tokens to destAddress\\n     * @param src source ERC20 token contract address\\n     * @param srcAmount source ERC20 token amount in its token decimals\\n     * @param dest destination ERC20 token contract address\\n     * @param destAddress recipient address for destination ERC20 token\\n     * @param maxDestAmount limit on the amount of destination tokens\\n     * @param minConversionRate minimum conversion rate; trade is canceled if actual rate is lower\\n     * @param walletId wallet address to send part of the fees to\\n     * @return Amount of actual destination tokens\\n     * @notice srcAmount | maxDestAmount These amounts should be in the source and\\n         destination token decimals respectively. For example, if the user wants to swap\\n         from / to 10 POWR,which has 6 decimals, it would be 10 * (10 ** 6) = 10000000\\n     * @notice maxDestAmount should not be 0. Set it to an arbitarily large amount\\n         if you want all source tokens to be converted.\\n     * @notice minConversionRate: This rate is independent of the source and\\n         destination token decimals. To calculate this rate, take yourRate * 10**18.\\n         For example, even though ZIL has 12 token decimals, if we want the minimum\\n         conversion rate to be 1 ZIL = 0.00017 ETH, then\\n         minConversionRate = 0.00017 * (10 ** 18).\\n     * @notice walletId: If you are part of our fee sharing program, this will be\\n         your registered wallet address. Set it as 0 if you are not a participant.\\n     * @notice Since ETH is not an ERC20 token, we use\\n        0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee as a proxy address to represent it.\\n     * @notice If src is ETH, then you also need to send ether along with your call.\\n     * @notice There is a minimum trading value of 1000 wei tokens.\\n        Anything fewer is considered as 0.\\n     */\\n    function trade(\\n        address src,\\n        uint256 srcAmount,\\n        address dest,\\n        address destAddress,\\n        uint256 maxDestAmount,\\n        uint256 minConversionRate,\\n        address walletId\\n    )\\n        external\\n        payable\\n        returns (uint256);\\n\\n    /**\\n     * @dev Get the expected exchange rate.\\n     * @param src source ERC20 token contract address\\n     * @param dest destination ERC20 token contract address\\n     * @param srcQty wei amount of source ERC20 token\\n     * @return The expected exchange rate and slippage rate.\\n     * @notice Returned values are in precision values (10**18)\\n        To understand what this rate means, divide the obtained value by 10**18\\n        (tA, tB,)\\n     */\\n    function getExpectedRate(address src, address dest, uint256 srcQty)\\n        external\\n        view\\n        returns (uint256, uint256);\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sendAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"LogOneWay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sendAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiveToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receiveAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"LogTwoWay\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_userProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sendToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sendAmt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiveToken\",\"type\":\"address\"}],\"name\":\"action\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_actionPayloadWithSelector\",\"type\":\"bytes\"}],\"name\":\"actionConditionsCheck\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"actionGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"actionSelector\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_userProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sendToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getUsersSendTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ActionKyberTrade","CompilerVersion":"v0.6.1+commit.e6f7d5a4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"ipfs://36b83ddd65aa8eaace05a4e243b2fa320a43921de8321fa7dc24e38e24c83e3a"}]}