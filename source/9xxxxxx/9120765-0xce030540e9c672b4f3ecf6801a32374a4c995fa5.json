{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/token/interfaces/IERC20Token.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ncontract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public view returns (string) {this;}\r\n    function symbol() public view returns (string) {this;}\r\n    function decimals() public view returns (uint8) {this;}\r\n    function totalSupply() public view returns (uint256) {this;}\r\n    function balanceOf(address _owner) public view returns (uint256) {_owner; this;}\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {_owner; _spender; this;}\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n// File: contracts/utility/interfaces/IWhitelist.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    Whitelist interface\r\n*/\r\ncontract IWhitelist {\r\n    function isWhitelisted(address _address) public view returns (bool);\r\n}\r\n\r\n// File: contracts/converter/interfaces/IBancorConverter.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n/*\r\n    Bancor Converter interface\r\n*/\r\ncontract IBancorConverter {\r\n    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public view returns (uint256, uint256);\r\n    function convert2(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn, address _affiliateAccount, uint256 _affiliateFee) public returns (uint256);\r\n    function quickConvert2(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _affiliateAccount, uint256 _affiliateFee) public payable returns (uint256);\r\n    function conversionsEnabled() public view returns (bool) {this;}\r\n    function conversionWhitelist() public view returns (IWhitelist) {this;}\r\n    function conversionFee() public view returns (uint32) {this;}\r\n    function reserves(address _address) public view returns (uint256, uint32, bool, bool, bool) {_address; this;}\r\n    function getReserveBalance(IERC20Token _reserveToken) public view returns (uint256);\r\n    function reserveTokens(uint256 _index) public view returns (IERC20Token) {_index; this;}\r\n    // deprecated, backward compatibility\r\n    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\r\n    function convert(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\r\n    function quickConvert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256);\r\n    function connectors(address _address) public view returns (uint256, uint32, bool, bool, bool);\r\n    function getConnectorBalance(IERC20Token _connectorToken) public view returns (uint256);\r\n    function connectorTokens(uint256 _index) public view returns (IERC20Token);\r\n    function connectorTokenCount() public view returns (uint16);\r\n}\r\n\r\n// File: contracts/converter/interfaces/IBancorConverterUpgrader.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n/*\r\n    Bancor Converter Upgrader interface\r\n*/\r\ncontract IBancorConverterUpgrader {\r\n    function upgrade(bytes32 _version) public;\r\n    function upgrade(uint16 _version) public;\r\n}\r\n\r\n// File: contracts/converter/interfaces/IBancorFormula.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    Bancor Formula interface\r\n*/\r\ncontract IBancorFormula {\r\n    function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _depositAmount) public view returns (uint256);\r\n    function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _sellAmount) public view returns (uint256);\r\n    function calculateCrossReserveReturn(uint256 _fromReserveBalance, uint32 _fromReserveRatio, uint256 _toReserveBalance, uint32 _toReserveRatio, uint256 _amount) public view returns (uint256);\r\n    function calculateFundCost(uint256 _supply, uint256 _reserveBalance, uint32 _totalRatio, uint256 _amount) public view returns (uint256);\r\n    function calculateLiquidateReturn(uint256 _supply, uint256 _reserveBalance, uint32 _totalRatio, uint256 _amount) public view returns (uint256);\r\n    // deprecated, backward compatibility\r\n    function calculateCrossConnectorReturn(uint256 _fromConnectorBalance, uint32 _fromConnectorWeight, uint256 _toConnectorBalance, uint32 _toConnectorWeight, uint256 _amount) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/IBancorNetwork.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n/*\r\n    Bancor Network interface\r\n*/\r\ncontract IBancorNetwork {\r\n    function convert2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) public payable returns (uint256);\r\n\r\n    function claimAndConvert2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) public returns (uint256);\r\n\r\n    function convertFor2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) public payable returns (uint256);\r\n\r\n    function claimAndConvertFor2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) public returns (uint256);\r\n\r\n    function convertForPrioritized4(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        uint256[] memory _signature,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) public payable returns (uint256);\r\n\r\n    // deprecated, backward compatibility\r\n    function convert(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn\r\n    ) public payable returns (uint256);\r\n\r\n    // deprecated, backward compatibility\r\n    function claimAndConvert(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn\r\n    ) public returns (uint256);\r\n\r\n    // deprecated, backward compatibility\r\n    function convertFor(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for\r\n    ) public payable returns (uint256);\r\n\r\n    // deprecated, backward compatibility\r\n    function claimAndConvertFor(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for\r\n    ) public returns (uint256);\r\n\r\n    // deprecated, backward compatibility\r\n    function convertForPrioritized3(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        uint256 _customVal,\r\n        uint256 _block,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) public payable returns (uint256);\r\n\r\n    // deprecated, backward compatibility\r\n    function convertForPrioritized2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        uint256 _block,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) public payable returns (uint256);\r\n\r\n    // deprecated, backward compatibility\r\n    function convertForPrioritized(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        uint256 _block,\r\n        uint256 _nonce,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) public payable returns (uint256);\r\n}\r\n\r\n// File: contracts/FeatureIds.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/**\r\n  * @dev Id definitions for bancor contract features\r\n  * \r\n  * Can be used to query the ContractFeatures contract to check whether a certain feature is supported by a contract\r\n*/\r\ncontract FeatureIds {\r\n    // converter features\r\n    uint256 public constant CONVERTER_CONVERSION_WHITELIST = 1 << 0;\r\n}\r\n\r\n// File: contracts/utility/interfaces/IOwned.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ncontract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public view returns (address) {this;}\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n}\r\n\r\n// File: contracts/utility/Owned.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n/**\r\n  * @dev Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    /**\r\n      * @dev triggered when the owner is updated\r\n      * \r\n      * @param _prevOwner previous owner\r\n      * @param _newOwner  new owner\r\n    */\r\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\r\n\r\n    /**\r\n      * @dev initializes a new Owned instance\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n      * @dev allows transferring the contract ownership\r\n      * the new owner still needs to accept the transfer\r\n      * can only be called by the contract owner\r\n      * \r\n      * @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n      * @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/utility/Managed.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n/**\r\n  * @dev Provides support and utilities for contract management\r\n  * Note that a managed contract must also have an owner\r\n*/\r\ncontract Managed is Owned {\r\n    address public manager;\r\n    address public newManager;\r\n\r\n    /**\r\n      * @dev triggered when the manager is updated\r\n      * \r\n      * @param _prevManager previous manager\r\n      * @param _newManager  new manager\r\n    */\r\n    event ManagerUpdate(address indexed _prevManager, address indexed _newManager);\r\n\r\n    /**\r\n      * @dev initializes a new Managed instance\r\n    */\r\n    constructor() public {\r\n        manager = msg.sender;\r\n    }\r\n\r\n    // allows execution by the manager only\r\n    modifier managerOnly {\r\n        assert(msg.sender == manager);\r\n        _;\r\n    }\r\n\r\n    // allows execution by either the owner or the manager only\r\n    modifier ownerOrManagerOnly {\r\n        require(msg.sender == owner || msg.sender == manager);\r\n        _;\r\n    }\r\n\r\n    /**\r\n      * @dev allows transferring the contract management\r\n      * the new manager still needs to accept the transfer\r\n      * can only be called by the contract manager\r\n      * \r\n      * @param _newManager    new contract manager\r\n    */\r\n    function transferManagement(address _newManager) public ownerOrManagerOnly {\r\n        require(_newManager != manager);\r\n        newManager = _newManager;\r\n    }\r\n\r\n    /**\r\n      * @dev used by a new manager to accept a management transfer\r\n    */\r\n    function acceptManagement() public {\r\n        require(msg.sender == newManager);\r\n        emit ManagerUpdate(manager, newManager);\r\n        manager = newManager;\r\n        newManager = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/utility/SafeMath.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/**\r\n  * @dev Library for basic math operations with overflow/underflow protection\r\n*/\r\nlibrary SafeMath {\r\n    /**\r\n      * @dev returns the sum of _x and _y, reverts if the calculation overflows\r\n      * \r\n      * @param _x   value 1\r\n      * @param _y   value 2\r\n      * \r\n      * @return sum\r\n    */\r\n    function add(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        require(z >= _x);\r\n        return z;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the difference of _x minus _y, reverts if the calculation underflows\r\n      * \r\n      * @param _x   minuend\r\n      * @param _y   subtrahend\r\n      * \r\n      * @return difference\r\n    */\r\n    function sub(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_x >= _y);\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the product of multiplying _x by _y, reverts if the calculation overflows\r\n      * \r\n      * @param _x   factor 1\r\n      * @param _y   factor 2\r\n      * \r\n      * @return product\r\n    */\r\n    function mul(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        // gas optimization\r\n        if (_x == 0)\r\n            return 0;\r\n\r\n        uint256 z = _x * _y;\r\n        require(z / _x == _y);\r\n        return z;\r\n    }\r\n\r\n      /**\r\n        * ev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n        * \r\n        * aram _x   dividend\r\n        * aram _y   divisor\r\n        * \r\n        * eturn quotient\r\n    */\r\n    function div(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_y > 0);\r\n        uint256 c = _x / _y;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/utility/Utils.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/**\r\n  * @dev Utilities & Common Modifiers\r\n*/\r\ncontract Utils {\r\n    /**\r\n      * constructor\r\n    */\r\n    constructor() public {\r\n    }\r\n\r\n    // verifies that an amount is greater than zero\r\n    modifier greaterThanZero(uint256 _amount) {\r\n        require(_amount > 0);\r\n        _;\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        require(_address != address(0));\r\n        _;\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        require(_address != address(this));\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/utility/interfaces/IContractRegistry.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    Contract Registry interface\r\n*/\r\ncontract IContractRegistry {\r\n    function addressOf(bytes32 _contractName) public view returns (address);\r\n\r\n    // deprecated, backward compatibility\r\n    function getAddress(bytes32 _contractName) public view returns (address);\r\n}\r\n\r\n// File: contracts/utility/ContractRegistryClient.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n\r\n/**\r\n  * @dev Base contract for ContractRegistry clients\r\n*/\r\ncontract ContractRegistryClient is Owned, Utils {\r\n    bytes32 internal constant CONTRACT_FEATURES = \"ContractFeatures\";\r\n    bytes32 internal constant CONTRACT_REGISTRY = \"ContractRegistry\";\r\n    bytes32 internal constant NON_STANDARD_TOKEN_REGISTRY = \"NonStandardTokenRegistry\";\r\n    bytes32 internal constant BANCOR_NETWORK = \"BancorNetwork\";\r\n    bytes32 internal constant BANCOR_FORMULA = \"BancorFormula\";\r\n    bytes32 internal constant BANCOR_GAS_PRICE_LIMIT = \"BancorGasPriceLimit\";\r\n    bytes32 internal constant BANCOR_CONVERTER_FACTORY = \"BancorConverterFactory\";\r\n    bytes32 internal constant BANCOR_CONVERTER_UPGRADER = \"BancorConverterUpgrader\";\r\n    bytes32 internal constant BANCOR_CONVERTER_REGISTRY = \"BancorConverterRegistry\";\r\n    bytes32 internal constant BANCOR_CONVERTER_REGISTRY_DATA = \"BancorConverterRegistryData\";\r\n    bytes32 internal constant BNT_TOKEN = \"BNTToken\";\r\n    bytes32 internal constant BANCOR_X = \"BancorX\";\r\n    bytes32 internal constant BANCOR_X_UPGRADER = \"BancorXUpgrader\";\r\n\r\n    IContractRegistry public registry;      // address of the current contract-registry\r\n    IContractRegistry public prevRegistry;  // address of the previous contract-registry\r\n    bool public adminOnly;                  // only an administrator can update the contract-registry\r\n\r\n    /**\r\n      * @dev verifies that the caller is mapped to the given contract name\r\n      * \r\n      * @param _contractName    contract name\r\n    */\r\n    modifier only(bytes32 _contractName) {\r\n        require(msg.sender == addressOf(_contractName));\r\n        _;\r\n    }\r\n\r\n    /**\r\n      * @dev initializes a new ContractRegistryClient instance\r\n      * \r\n      * @param  _registry   address of a contract-registry contract\r\n    */\r\n    constructor(IContractRegistry _registry) internal validAddress(_registry) {\r\n        registry = IContractRegistry(_registry);\r\n        prevRegistry = IContractRegistry(_registry);\r\n    }\r\n\r\n    /**\r\n      * @dev updates to the new contract-registry\r\n     */\r\n    function updateRegistry() public {\r\n        // verify that this function is permitted\r\n        require(!adminOnly || isAdmin());\r\n\r\n        // get the new contract-registry\r\n        address newRegistry = addressOf(CONTRACT_REGISTRY);\r\n\r\n        // verify that the new contract-registry is different and not zero\r\n        require(newRegistry != address(registry) && newRegistry != address(0));\r\n\r\n        // verify that the new contract-registry is pointing to a non-zero contract-registry\r\n        require(IContractRegistry(newRegistry).addressOf(CONTRACT_REGISTRY) != address(0));\r\n\r\n        // save a backup of the current contract-registry before replacing it\r\n        prevRegistry = registry;\r\n\r\n        // replace the current contract-registry with the new contract-registry\r\n        registry = IContractRegistry(newRegistry);\r\n    }\r\n\r\n    /**\r\n      * @dev restores the previous contract-registry\r\n    */\r\n    function restoreRegistry() public {\r\n        // verify that this function is permitted\r\n        require(isAdmin());\r\n\r\n        // restore the previous contract-registry\r\n        registry = prevRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev restricts the permission to update the contract-registry\r\n      * \r\n      * @param _adminOnly    indicates whether or not permission is restricted to administrator only\r\n    */\r\n    function restrictRegistryUpdate(bool _adminOnly) public {\r\n        // verify that this function is permitted\r\n        require(adminOnly != _adminOnly && isAdmin());\r\n\r\n        // change the permission to update the contract-registry\r\n        adminOnly = _adminOnly;\r\n    }\r\n\r\n    /**\r\n      * @dev returns whether or not the caller is an administrator\r\n     */\r\n    function isAdmin() internal view returns (bool) {\r\n        return msg.sender == owner;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the address associated with the given contract name\r\n      * \r\n      * @param _contractName    contract name\r\n      * \r\n      * @return contract address\r\n    */\r\n    function addressOf(bytes32 _contractName) internal view returns (address) {\r\n        return registry.addressOf(_contractName);\r\n    }\r\n}\r\n\r\n// File: contracts/utility/interfaces/IContractFeatures.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    Contract Features interface\r\n*/\r\ncontract IContractFeatures {\r\n    function isSupported(address _contract, uint256 _features) public view returns (bool);\r\n    function enableFeatures(uint256 _features, bool _enable) public;\r\n}\r\n\r\n// File: contracts/utility/interfaces/IAddressList.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    Address list interface\r\n*/\r\ncontract IAddressList {\r\n    mapping (address => bool) public listedAddresses;\r\n}\r\n\r\n// File: contracts/token/interfaces/ISmartToken.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n/*\r\n    Smart Token interface\r\n*/\r\ncontract ISmartToken is IOwned, IERC20Token {\r\n    function disableTransfers(bool _disable) public;\r\n    function issue(address _to, uint256 _amount) public;\r\n    function destroy(address _from, uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/token/interfaces/ISmartTokenController.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n/*\r\n    Smart Token Controller interface\r\n*/\r\ncontract ISmartTokenController {\r\n    function claimTokens(address _from, uint256 _amount) public;\r\n    function token() public view returns (ISmartToken) {this;}\r\n}\r\n\r\n// File: contracts/utility/interfaces/ITokenHolder.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n/*\r\n    Token Holder interface\r\n*/\r\ncontract ITokenHolder is IOwned {\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/token/interfaces/INonStandardERC20.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    ERC20 Standard Token interface which doesn't return true/false for transfer, transferFrom and approve\r\n*/\r\ncontract INonStandardERC20 {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public view returns (string) {this;}\r\n    function symbol() public view returns (string) {this;}\r\n    function decimals() public view returns (uint8) {this;}\r\n    function totalSupply() public view returns (uint256) {this;}\r\n    function balanceOf(address _owner) public view returns (uint256) {_owner; this;}\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {_owner; _spender; this;}\r\n\r\n    function transfer(address _to, uint256 _value) public;\r\n    function transferFrom(address _from, address _to, uint256 _value) public;\r\n    function approve(address _spender, uint256 _value) public;\r\n}\r\n\r\n// File: contracts/utility/TokenHolder.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n  * @dev We consider every contract to be a 'token holder' since it's currently not possible\r\n  * for a contract to deny receiving tokens.\r\n  * \r\n  * The TokenHolder's contract sole purpose is to provide a safety mechanism that allows\r\n  * the owner to send tokens that were sent to the contract by mistake back to their sender.\r\n  * \r\n  * Note that we use the non standard ERC-20 interface which has no return value for transfer\r\n  * in order to support both non standard as well as standard token contracts.\r\n  * see https://github.com/ethereum/solidity/issues/4116\r\n*/\r\ncontract TokenHolder is ITokenHolder, Owned, Utils {\r\n    /**\r\n      * @dev initializes a new TokenHolder instance\r\n    */\r\n    constructor() public {\r\n    }\r\n\r\n    /**\r\n      * @dev withdraws tokens held by the contract and sends them to an account\r\n      * can only be called by the owner\r\n      * \r\n      * @param _token   ERC20 token contract address\r\n      * @param _to      account to receive the new amount\r\n      * @param _amount  amount to withdraw\r\n    */\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        ownerOnly\r\n        validAddress(_token)\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        INonStandardERC20(_token).transfer(_to, _amount);\r\n    }\r\n}\r\n\r\n// File: contracts/token/SmartTokenController.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n\r\n/**\r\n  * @dev The smart token controller is an upgradable part of the smart token that allows\r\n  * more functionality as well as fixes for bugs/exploits.\r\n  * Once it accepts ownership of the token, it becomes the token's sole controller\r\n  * that can execute any of its functions.\r\n  * \r\n  * To upgrade the controller, ownership must be transferred to a new controller, along with\r\n  * any relevant data.\r\n  * \r\n  * The smart token must be set on construction and cannot be changed afterwards.\r\n  * Wrappers are provided (as opposed to a single 'execute' function) for each of the token's functions, for easier access.\r\n  * \r\n  * Note that the controller can transfer token ownership to a new controller that\r\n  * doesn't allow executing any function on the token, for a trustless solution.\r\n  * Doing that will also remove the owner's ability to upgrade the controller.\r\n*/\r\ncontract SmartTokenController is ISmartTokenController, TokenHolder {\r\n    ISmartToken public token;   // Smart Token contract\r\n    address public bancorX;     // BancorX contract\r\n\r\n    /**\r\n      * @dev initializes a new SmartTokenController instance\r\n      * \r\n      * @param  _token      smart token governed by the controller\r\n    */\r\n    constructor(ISmartToken _token)\r\n        public\r\n        validAddress(_token)\r\n    {\r\n        token = _token;\r\n    }\r\n\r\n    // ensures that the controller is the token's owner\r\n    modifier active() {\r\n        require(token.owner() == address(this));\r\n        _;\r\n    }\r\n\r\n    // ensures that the controller is not the token's owner\r\n    modifier inactive() {\r\n        require(token.owner() != address(this));\r\n        _;\r\n    }\r\n\r\n    /**\r\n      * @dev allows transferring the token ownership\r\n      * the new owner needs to accept the transfer\r\n      * can only be called by the contract owner\r\n      * \r\n      * @param _newOwner    new token owner\r\n    */\r\n    function transferTokenOwnership(address _newOwner) public ownerOnly {\r\n        token.transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n      * @dev used by a new owner to accept a token ownership transfer\r\n      * can only be called by the contract owner\r\n    */\r\n    function acceptTokenOwnership() public ownerOnly {\r\n        token.acceptOwnership();\r\n    }\r\n\r\n    /**\r\n      * @dev withdraws tokens held by the controller and sends them to an account\r\n      * can only be called by the owner\r\n      * \r\n      * @param _token   ERC20 token contract address\r\n      * @param _to      account to receive the new amount\r\n      * @param _amount  amount to withdraw\r\n    */\r\n    function withdrawFromToken(IERC20Token _token, address _to, uint256 _amount) public ownerOnly {\r\n        ITokenHolder(token).withdrawTokens(_token, _to, _amount);\r\n    }\r\n\r\n    /**\r\n      * @dev allows the associated BancorX contract to claim tokens from any address (so that users\r\n      * dont have to first give allowance when calling BancorX)\r\n      * \r\n      * @param _from      address to claim the tokens from\r\n      * @param _amount    the amount of tokens to claim\r\n     */\r\n    function claimTokens(address _from, uint256 _amount) public {\r\n        // only the associated BancorX contract may call this method\r\n        require(msg.sender == bancorX);\r\n\r\n        // destroy the tokens belonging to _from, and issue the same amount to bancorX\r\n        token.destroy(_from, _amount);\r\n        token.issue(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n      * @dev allows the owner to set the associated BancorX contract\r\n      * @param _bancorX    BancorX contract\r\n     */\r\n    function setBancorX(address _bancorX) public ownerOnly {\r\n        bancorX = _bancorX;\r\n    }\r\n}\r\n\r\n// File: contracts/token/interfaces/IEtherToken.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n/*\r\n    Ether Token interface\r\n*/\r\ncontract IEtherToken is ITokenHolder, IERC20Token {\r\n    function deposit() public payable;\r\n    function withdraw(uint256 _amount) public;\r\n    function withdrawTo(address _to, uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/bancorx/interfaces/IBancorX.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\ncontract IBancorX {\r\n    function xTransfer(bytes32 _toBlockchain, bytes32 _to, uint256 _amount, uint256 _id) public;\r\n    function getXTransferAmount(uint256 _xTransferId, address _for) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/converter/BancorConverter.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n  * @dev Bancor Converter\r\n  * \r\n  * The Bancor converter allows for conversions between a Smart Token and other ERC20 tokens and between different ERC20 tokens and themselves. \r\n  * \r\n  * The ERC20 reserve balance can be virtual, meaning that conversions between reserve tokens are based on the virtual balance instead of relying on the actual reserve balance.\r\n  * \r\n  * This mechanism opens the possibility to create different financial tools (for example, lower slippage in conversions).\r\n  * \r\n  * The converter is upgradable (just like any SmartTokenController) and all upgrades are opt-in. \r\n  * \r\n  * WARNING: It is NOT RECOMMENDED to use the converter with Smart Tokens that have less than 8 decimal digits or with very small numbers because of precision loss \r\n  * \r\n  * Open issues:\r\n  * - Front-running attacks are currently mitigated by the following mechanisms:\r\n  *     - minimum return argument for each conversion provides a way to define a minimum/maximum price for the transaction\r\n  *     - gas price limit prevents users from having control over the order of execution\r\n  *     - gas price limit check can be skipped if the transaction comes from a trusted, whitelisted signer\r\n  * \r\n  * Other potential solutions might include a commit/reveal based schemes\r\n  * - Possibly add getters for the reserve fields so that the client won't need to rely on the order in the struct\r\n*/\r\ncontract BancorConverter is IBancorConverter, SmartTokenController, Managed, ContractRegistryClient, FeatureIds {\r\n    using SafeMath for uint256;\r\n\r\n    uint32 private constant RATIO_RESOLUTION = 1000000;\r\n    uint64 private constant CONVERSION_FEE_RESOLUTION = 1000000;\r\n\r\n    struct Reserve {\r\n        uint256 virtualBalance;         // reserve virtual balance\r\n        uint32 ratio;                   // reserve ratio, represented in ppm, 1-1000000\r\n        bool isVirtualBalanceEnabled;   // true if virtual balance is enabled, false if not\r\n        bool isSaleEnabled;             // is sale of the reserve token enabled, can be set by the owner\r\n        bool isSet;                     // used to tell if the mapping element is defined\r\n    }\r\n\r\n    /**\r\n      * @dev version number\r\n    */\r\n    uint16 public version = 22;\r\n    string public converterType = 'bancor';\r\n\r\n    IWhitelist public conversionWhitelist;              // whitelist contract with list of addresses that are allowed to use the converter\r\n    IERC20Token[] public reserveTokens;                 // ERC20 standard token addresses (prior version 17, use 'connectorTokens' instead)\r\n    mapping (address => Reserve) public reserves;       // reserve token addresses -> reserve data (prior version 17, use 'connectors' instead)\r\n    uint32 private totalReserveRatio = 0;               // used to efficiently prevent increasing the total reserve ratio above 100%\r\n    uint32 public maxConversionFee = 0;                 // maximum conversion fee for the lifetime of the contract,\r\n                                                        // represented in ppm, 0...1000000 (0 = no fee, 100 = 0.01%, 1000000 = 100%)\r\n    uint32 public conversionFee = 0;                    // current conversion fee, represented in ppm, 0...maxConversionFee\r\n    bool public conversionsEnabled = true;              // true if token conversions is enabled, false if not\r\n\r\n    /**\r\n      * @dev triggered when a conversion between two tokens occurs\r\n      * \r\n      * @param _fromToken       ERC20 token converted from\r\n      * @param _toToken         ERC20 token converted to\r\n      * @param _trader          wallet that initiated the trade\r\n      * @param _amount          amount converted, in fromToken\r\n      * @param _return          amount returned, minus conversion fee\r\n      * @param _conversionFee   conversion fee\r\n    */\r\n    event Conversion(\r\n        address indexed _fromToken,\r\n        address indexed _toToken,\r\n        address indexed _trader,\r\n        uint256 _amount,\r\n        uint256 _return,\r\n        int256 _conversionFee\r\n    );\r\n\r\n    /**\r\n      * @dev triggered after a conversion with new price data\r\n      * \r\n      * @param  _connectorToken     reserve token\r\n      * @param  _tokenSupply        smart token supply\r\n      * @param  _connectorBalance   reserve balance\r\n      * @param  _connectorWeight    reserve ratio\r\n    */\r\n    event PriceDataUpdate(\r\n        address indexed _connectorToken,\r\n        uint256 _tokenSupply,\r\n        uint256 _connectorBalance,\r\n        uint32 _connectorWeight\r\n    );\r\n\r\n    /**\r\n      * @dev triggered when the conversion fee is updated\r\n      * \r\n      * @param  _prevFee    previous fee percentage, represented in ppm\r\n      * @param  _newFee     new fee percentage, represented in ppm\r\n    */\r\n    event ConversionFeeUpdate(uint32 _prevFee, uint32 _newFee);\r\n\r\n    /**\r\n      * @dev triggered when conversions are enabled/disabled\r\n      * \r\n      * @param  _conversionsEnabled true if conversions are enabled, false if not\r\n    */\r\n    event ConversionsEnable(bool _conversionsEnabled);\r\n\r\n    /**\r\n      * @dev triggered when virtual balances are enabled/disabled\r\n      * \r\n      * @param  _enabled true if virtual balances are enabled, false if not\r\n    */\r\n    event VirtualBalancesEnable(bool _enabled);\r\n\r\n    /**\r\n      * @dev initializes a new BancorConverter instance\r\n      * \r\n      * @param  _token              smart token governed by the converter\r\n      * @param  _registry           address of a contract registry contract\r\n      * @param  _maxConversionFee   maximum conversion fee, represented in ppm\r\n      * @param  _reserveToken       optional, initial reserve, allows defining the first reserve at deployment time\r\n      * @param  _reserveRatio       optional, ratio for the initial reserve\r\n    */\r\n    constructor(\r\n        ISmartToken _token,\r\n        IContractRegistry _registry,\r\n        uint32 _maxConversionFee,\r\n        IERC20Token _reserveToken,\r\n        uint32 _reserveRatio\r\n    )   ContractRegistryClient(_registry)\r\n        public\r\n        SmartTokenController(_token)\r\n        validConversionFee(_maxConversionFee)\r\n    {\r\n        IContractFeatures features = IContractFeatures(addressOf(CONTRACT_FEATURES));\r\n\r\n        // initialize supported features\r\n        if (features != address(0))\r\n            features.enableFeatures(FeatureIds.CONVERTER_CONVERSION_WHITELIST, true);\r\n\r\n        maxConversionFee = _maxConversionFee;\r\n\r\n        if (_reserveToken != address(0))\r\n            addReserve(_reserveToken, _reserveRatio);\r\n    }\r\n\r\n    // validates a reserve token address - verifies that the address belongs to one of the reserve tokens\r\n    modifier validReserve(IERC20Token _address) {\r\n        require(reserves[_address].isSet);\r\n        _;\r\n    }\r\n\r\n    // validates conversion fee\r\n    modifier validConversionFee(uint32 _conversionFee) {\r\n        require(_conversionFee >= 0 && _conversionFee <= CONVERSION_FEE_RESOLUTION);\r\n        _;\r\n    }\r\n\r\n    // validates reserve ratio\r\n    modifier validReserveRatio(uint32 _ratio) {\r\n        require(_ratio > 0 && _ratio <= RATIO_RESOLUTION);\r\n        _;\r\n    }\r\n\r\n    // allows execution only when conversions aren't disabled\r\n    modifier conversionsAllowed {\r\n        require(conversionsEnabled);\r\n        _;\r\n    }\r\n\r\n    // allows execution only if the total-supply of the token is greater than zero\r\n    modifier totalSupplyGreaterThanZeroOnly {\r\n        require(token.totalSupply() > 0);\r\n        _;\r\n    }\r\n\r\n    // allows execution only on a multiple-reserve converter\r\n    modifier multipleReservesOnly {\r\n        require(reserveTokens.length > 1);\r\n        _;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the number of reserve tokens defined\r\n      * note that prior to version 17, you should use 'connectorTokenCount' instead\r\n      * \r\n      * @return number of reserve tokens\r\n    */\r\n    function reserveTokenCount() public view returns (uint16) {\r\n        return uint16(reserveTokens.length);\r\n    }\r\n\r\n    /**\r\n      * @dev allows the owner to update & enable the conversion whitelist contract address\r\n      * when set, only addresses that are whitelisted are actually allowed to use the converter\r\n      * note that the whitelist check is actually done by the BancorNetwork contract\r\n      * \r\n      * @param _whitelist    address of a whitelist contract\r\n    */\r\n    function setConversionWhitelist(IWhitelist _whitelist)\r\n        public\r\n        ownerOnly\r\n        notThis(_whitelist)\r\n    {\r\n        conversionWhitelist = _whitelist;\r\n    }\r\n\r\n    /**\r\n      * @dev disables the entire conversion functionality\r\n      * this is a safety mechanism in case of a emergency\r\n      * can only be called by the manager\r\n      * \r\n      * @param _disable true to disable conversions, false to re-enable them\r\n    */\r\n    function disableConversions(bool _disable) public ownerOrManagerOnly {\r\n        if (conversionsEnabled == _disable) {\r\n            conversionsEnabled = !_disable;\r\n            emit ConversionsEnable(conversionsEnabled);\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @dev allows transferring the token ownership\r\n      * the new owner needs to accept the transfer\r\n      * can only be called by the contract owner\r\n      * note that token ownership can only be transferred while the owner is the converter upgrader contract\r\n      * \r\n      * @param _newOwner    new token owner\r\n    */\r\n    function transferTokenOwnership(address _newOwner)\r\n        public\r\n        ownerOnly\r\n        only(BANCOR_CONVERTER_UPGRADER)\r\n    {\r\n        super.transferTokenOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n      * @dev used by a new owner to accept a token ownership transfer\r\n      * can only be called by the contract owner\r\n      * note that token ownership can only be accepted if its total-supply is greater than zero\r\n    */\r\n    function acceptTokenOwnership()\r\n        public\r\n        ownerOnly\r\n        totalSupplyGreaterThanZeroOnly\r\n    {\r\n        super.acceptTokenOwnership();\r\n    }\r\n\r\n    /**\r\n      * @dev updates the current conversion fee\r\n      * can only be called by the manager\r\n      * \r\n      * @param _conversionFee new conversion fee, represented in ppm\r\n    */\r\n    function setConversionFee(uint32 _conversionFee)\r\n        public\r\n        ownerOrManagerOnly\r\n    {\r\n        require(_conversionFee >= 0 && _conversionFee <= maxConversionFee);\r\n        emit ConversionFeeUpdate(conversionFee, _conversionFee);\r\n        conversionFee = _conversionFee;\r\n    }\r\n\r\n    /**\r\n      * @dev given a return amount, returns the amount minus the conversion fee\r\n      * \r\n      * @param _amount      return amount\r\n      * @param _magnitude   1 for standard conversion, 2 for cross reserve conversion\r\n      * \r\n      * @return return amount minus conversion fee\r\n    */\r\n    function getFinalAmount(uint256 _amount, uint8 _magnitude) public view returns (uint256) {\r\n        return _amount.mul((CONVERSION_FEE_RESOLUTION - conversionFee) ** _magnitude).div(CONVERSION_FEE_RESOLUTION ** _magnitude);\r\n    }\r\n\r\n    /**\r\n      * @dev withdraws tokens held by the converter and sends them to an account\r\n      * can only be called by the owner\r\n      * note that reserve tokens can only be withdrawn by the owner while the converter is inactive\r\n      * unless the owner is the converter upgrader contract\r\n      * \r\n      * @param _token   ERC20 token contract address\r\n      * @param _to      account to receive the new amount\r\n      * @param _amount  amount to withdraw\r\n    */\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public {\r\n        address converterUpgrader = addressOf(BANCOR_CONVERTER_UPGRADER);\r\n\r\n        // if the token is not a reserve token, allow withdrawal\r\n        // otherwise verify that the converter is inactive or that the owner is the upgrader contract\r\n        require(!reserves[_token].isSet || token.owner() != address(this) || owner == converterUpgrader);\r\n        super.withdrawTokens(_token, _to, _amount);\r\n    }\r\n\r\n    /**\r\n      * @dev upgrades the converter to the latest version\r\n      * can only be called by the owner\r\n      * note that the owner needs to call acceptOwnership/acceptManagement on the new converter after the upgrade\r\n    */\r\n    function upgrade() public ownerOnly {\r\n        IBancorConverterUpgrader converterUpgrader = IBancorConverterUpgrader(addressOf(BANCOR_CONVERTER_UPGRADER));\r\n\r\n        transferOwnership(converterUpgrader);\r\n        converterUpgrader.upgrade(version);\r\n        acceptOwnership();\r\n    }\r\n\r\n    /**\r\n      * @dev defines a new reserve for the token\r\n      * can only be called by the owner while the converter is inactive\r\n      * note that prior to version 17, you should use 'addConnector' instead\r\n      * \r\n      * @param _token                  address of the reserve token\r\n      * @param _ratio                  constant reserve ratio, represented in ppm, 1-1000000\r\n    */\r\n    function addReserve(IERC20Token _token, uint32 _ratio)\r\n        public\r\n        ownerOnly\r\n        inactive\r\n        validAddress(_token)\r\n        notThis(_token)\r\n        validReserveRatio(_ratio)\r\n    {\r\n        require(_token != token && !reserves[_token].isSet && totalReserveRatio + _ratio <= RATIO_RESOLUTION); // validate input\r\n\r\n        reserves[_token].ratio = _ratio;\r\n        reserves[_token].isVirtualBalanceEnabled = false;\r\n        reserves[_token].virtualBalance = 0;\r\n        reserves[_token].isSaleEnabled = true;\r\n        reserves[_token].isSet = true;\r\n        reserveTokens.push(_token);\r\n        totalReserveRatio += _ratio;\r\n    }\r\n\r\n    /**\r\n      * @dev updates a reserve's virtual balance\r\n      * only used during an upgrade process\r\n      * can only be called by the contract owner while the owner is the converter upgrader contract\r\n      * note that prior to version 17, you should use 'updateConnector' instead\r\n      * \r\n      * @param _reserveToken    address of the reserve token\r\n      * @param _virtualBalance  new reserve virtual balance, or 0 to disable virtual balance\r\n    */\r\n    function updateReserveVirtualBalance(IERC20Token _reserveToken, uint256 _virtualBalance)\r\n        public\r\n        ownerOnly\r\n        only(BANCOR_CONVERTER_UPGRADER)\r\n        validReserve(_reserveToken)\r\n    {\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        reserve.isVirtualBalanceEnabled = _virtualBalance != 0;\r\n        reserve.virtualBalance = _virtualBalance;\r\n    }\r\n\r\n    /**\r\n      * @dev enables virtual balance for the reserves\r\n      * virtual balance only affects conversions between reserve tokens\r\n      * virtual balance of all reserves can only scale by the same factor, to keep the ratio between them the same\r\n      * note that the balance is determined during the execution of this function and set statically -\r\n      * meaning that it's not calculated dynamically based on the factor after each conversion\r\n      * can only be called by the contract owner while the converter is active\r\n      * \r\n      * @param _scaleFactor  percentage, 100-1000 (100 = no virtual balance, 1000 = virtual balance = actual balance * 10)\r\n    */\r\n    function enableVirtualBalances(uint16 _scaleFactor)\r\n        public\r\n        ownerOnly\r\n        active\r\n    {\r\n        // validate input\r\n        require(_scaleFactor >= 100 && _scaleFactor <= 1000);\r\n        bool enable = _scaleFactor != 100;\r\n\r\n        // iterate through the reserves and scale their balance by the ratio provided,\r\n        // or disable virtual balance altogether if a factor of 100% is passed in\r\n        IERC20Token reserveToken;\r\n        for (uint16 i = 0; i < reserveTokens.length; i++) {\r\n            reserveToken = reserveTokens[i];\r\n            Reserve storage reserve = reserves[reserveToken];\r\n            reserve.isVirtualBalanceEnabled = enable;\r\n            reserve.virtualBalance = enable ? reserveToken.balanceOf(this).mul(_scaleFactor).div(100) : 0;\r\n        }\r\n\r\n        emit VirtualBalancesEnable(enable);\r\n    }\r\n\r\n    /**\r\n      * @dev disables converting from the given reserve token in case the reserve token got compromised\r\n      * can only be called by the owner\r\n      * note that converting to the token is still enabled regardless of this flag and it cannot be disabled by the owner\r\n      * note that prior to version 17, you should use 'disableConnectorSale' instead\r\n      * \r\n      * @param _reserveToken    reserve token contract address\r\n      * @param _disable         true to disable the token, false to re-enable it\r\n    */\r\n    function disableReserveSale(IERC20Token _reserveToken, bool _disable)\r\n        public\r\n        ownerOnly\r\n        validReserve(_reserveToken)\r\n    {\r\n        reserves[_reserveToken].isSaleEnabled = !_disable;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the reserve's ratio\r\n      * added in version 22\r\n      * \r\n      * @param _reserveToken    reserve token contract address\r\n      * \r\n      * @return reserve ratio\r\n    */\r\n    function getReserveRatio(IERC20Token _reserveToken)\r\n        public\r\n        view\r\n        validReserve(_reserveToken)\r\n        returns (uint256)\r\n    {\r\n        return reserves[_reserveToken].ratio;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the reserve's virtual balance if one is defined, otherwise returns the actual balance\r\n      * note that prior to version 17, you should use 'getConnectorBalance' instead\r\n      * \r\n      * @param _reserveToken    reserve token contract address\r\n      * \r\n      * @return reserve balance\r\n    */\r\n    function getReserveBalance(IERC20Token _reserveToken)\r\n        public\r\n        view\r\n        validReserve(_reserveToken)\r\n        returns (uint256)\r\n    {\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        return reserve.isVirtualBalanceEnabled ? reserve.virtualBalance : _reserveToken.balanceOf(this);\r\n    }\r\n\r\n    /**\r\n      * @dev calculates the expected return of converting a given amount of tokens\r\n      * \r\n      * @param _fromToken  contract address of the token to convert from\r\n      * @param _toToken    contract address of the token to convert to\r\n      * @param _amount     amount of tokens received from the user\r\n      * \r\n      * @return amount of tokens that the user will receive\r\n      * @return amount of tokens that the user will pay as fee\r\n    */\r\n    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public view returns (uint256, uint256) {\r\n        require(_fromToken != _toToken); // validate input\r\n\r\n        // conversion between the token and one of its reserves\r\n        if (_toToken == token)\r\n            return getPurchaseReturn(_fromToken, _amount);\r\n        else if (_fromToken == token)\r\n            return getSaleReturn(_toToken, _amount);\r\n\r\n        // conversion between 2 reserves\r\n        return getCrossReserveReturn(_fromToken, _toToken, _amount);\r\n    }\r\n\r\n    /**\r\n      * @dev calculates the expected return of buying with a given amount of tokens\r\n      * \r\n      * @param _reserveToken    contract address of the reserve token\r\n      * @param _depositAmount   amount of reserve-tokens received from the user\r\n      * \r\n      * @return amount of supply-tokens that the user will receive\r\n      * @return amount of supply-tokens that the user will pay as fee\r\n    */\r\n    function getPurchaseReturn(IERC20Token _reserveToken, uint256 _depositAmount)\r\n        public\r\n        view\r\n        active\r\n        validReserve(_reserveToken)\r\n        returns (uint256, uint256)\r\n    {\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        require(reserve.isSaleEnabled); // validate input\r\n\r\n        uint256 tokenSupply = token.totalSupply();\r\n        uint256 reserveBalance = _reserveToken.balanceOf(this);\r\n        IBancorFormula formula = IBancorFormula(addressOf(BANCOR_FORMULA));\r\n        uint256 amount = formula.calculatePurchaseReturn(tokenSupply, reserveBalance, reserve.ratio, _depositAmount);\r\n        uint256 finalAmount = getFinalAmount(amount, 1);\r\n\r\n        // return the amount minus the conversion fee and the conversion fee\r\n        return (finalAmount, amount - finalAmount);\r\n    }\r\n\r\n    /**\r\n      * @dev calculates the expected return of selling a given amount of tokens\r\n      * \r\n      * @param _reserveToken    contract address of the reserve token\r\n      * @param _sellAmount      amount of supply-tokens received from the user\r\n      * \r\n      * @return amount of reserve-tokens that the user will receive\r\n      * @return amount of reserve-tokens that the user will pay as fee\r\n    */\r\n    function getSaleReturn(IERC20Token _reserveToken, uint256 _sellAmount)\r\n        public\r\n        view\r\n        active\r\n        validReserve(_reserveToken)\r\n        returns (uint256, uint256)\r\n    {\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        uint256 tokenSupply = token.totalSupply();\r\n        uint256 reserveBalance = _reserveToken.balanceOf(this);\r\n        IBancorFormula formula = IBancorFormula(addressOf(BANCOR_FORMULA));\r\n        uint256 amount = formula.calculateSaleReturn(tokenSupply, reserveBalance, reserve.ratio, _sellAmount);\r\n        uint256 finalAmount = getFinalAmount(amount, 1);\r\n\r\n        // return the amount minus the conversion fee and the conversion fee\r\n        return (finalAmount, amount - finalAmount);\r\n    }\r\n\r\n    /**\r\n      * @dev calculates the expected return of converting a given amount from one reserve to another\r\n      * note that prior to version 17, you should use 'getCrossConnectorReturn' instead\r\n      * \r\n      * @param _fromReserveToken    contract address of the reserve token to convert from\r\n      * @param _toReserveToken      contract address of the reserve token to convert to\r\n      * @param _amount              amount of tokens received from the user\r\n      * \r\n      * @return amount of tokens that the user will receive\r\n      * @return amount of tokens that the user will pay as fee\r\n    */\r\n    function getCrossReserveReturn(IERC20Token _fromReserveToken, IERC20Token _toReserveToken, uint256 _amount)\r\n        public\r\n        view\r\n        active\r\n        validReserve(_fromReserveToken)\r\n        validReserve(_toReserveToken)\r\n        returns (uint256, uint256)\r\n    {\r\n        Reserve storage fromReserve = reserves[_fromReserveToken];\r\n        Reserve storage toReserve = reserves[_toReserveToken];\r\n        require(fromReserve.isSaleEnabled); // validate input\r\n\r\n        IBancorFormula formula = IBancorFormula(addressOf(BANCOR_FORMULA));\r\n        uint256 amount = formula.calculateCrossReserveReturn(\r\n            getReserveBalance(_fromReserveToken), \r\n            fromReserve.ratio, \r\n            getReserveBalance(_toReserveToken), \r\n            toReserve.ratio, \r\n            _amount);\r\n        uint256 finalAmount = getFinalAmount(amount, 2);\r\n\r\n        // return the amount minus the conversion fee and the conversion fee\r\n        // the fee is higher (magnitude = 2) since cross reserve conversion equals 2 conversions (from / to the smart token)\r\n        return (finalAmount, amount - finalAmount);\r\n    }\r\n\r\n    /**\r\n      * @dev converts a specific amount of _fromToken to _toToken\r\n      * can only be called by the bancor network contract\r\n      * \r\n      * @param _fromToken  ERC20 token to convert from\r\n      * @param _toToken    ERC20 token to convert to\r\n      * @param _amount     amount to convert, in fromToken\r\n      * @param _minReturn  if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n      * \r\n      * @return conversion return amount\r\n    */\r\n    function convertInternal(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn)\r\n        public\r\n        only(BANCOR_NETWORK)\r\n        conversionsAllowed\r\n        greaterThanZero(_minReturn)\r\n        returns (uint256)\r\n    {\r\n        require(_fromToken != _toToken); // validate input\r\n\r\n        // conversion between the token and one of its reserves\r\n        if (_toToken == token)\r\n            return buy(_fromToken, _amount, _minReturn);\r\n        else if (_fromToken == token)\r\n            return sell(_toToken, _amount, _minReturn);\r\n\r\n        uint256 amount;\r\n        uint256 feeAmount;\r\n\r\n        // conversion between 2 reserves\r\n        (amount, feeAmount) = getCrossReserveReturn(_fromToken, _toToken, _amount);\r\n        // ensure the trade gives something in return and meets the minimum requested amount\r\n        require(amount != 0 && amount >= _minReturn);\r\n\r\n        // update the source token virtual balance if relevant\r\n        Reserve storage fromReserve = reserves[_fromToken];\r\n        if (fromReserve.isVirtualBalanceEnabled)\r\n            fromReserve.virtualBalance = fromReserve.virtualBalance.add(_amount);\r\n\r\n        // update the target token virtual balance if relevant\r\n        Reserve storage toReserve = reserves[_toToken];\r\n        if (toReserve.isVirtualBalanceEnabled)\r\n            toReserve.virtualBalance = toReserve.virtualBalance.sub(amount);\r\n\r\n        // ensure that the trade won't deplete the reserve balance\r\n        uint256 toReserveBalance = getReserveBalance(_toToken);\r\n        assert(amount < toReserveBalance);\r\n\r\n        // transfer funds from the caller in the from reserve token\r\n        ensureTransferFrom(_fromToken, msg.sender, this, _amount);\r\n        // transfer funds to the caller in the to reserve token\r\n        // the transfer might fail if virtual balance is enabled\r\n        ensureTransferFrom(_toToken, this, msg.sender, amount);\r\n\r\n        // dispatch the conversion event\r\n        // the fee is higher (magnitude = 2) since cross reserve conversion equals 2 conversions (from / to the smart token)\r\n        dispatchConversionEvent(_fromToken, _toToken, _amount, amount, feeAmount);\r\n\r\n        // dispatch price data updates for the smart token / both reserves\r\n        emit PriceDataUpdate(_fromToken, token.totalSupply(), _fromToken.balanceOf(this), fromReserve.ratio);\r\n        emit PriceDataUpdate(_toToken, token.totalSupply(), _toToken.balanceOf(this), toReserve.ratio);\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n      * @dev buys the token by depositing one of its reserve tokens\r\n      * \r\n      * @param _reserveToken    reserve token contract address\r\n      * @param _depositAmount   amount to deposit (in the reserve token)\r\n      * @param _minReturn       if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n      * \r\n      * @return buy return amount\r\n    */\r\n    function buy(IERC20Token _reserveToken, uint256 _depositAmount, uint256 _minReturn) internal returns (uint256) {\r\n        uint256 amount;\r\n        uint256 feeAmount;\r\n        (amount, feeAmount) = getPurchaseReturn(_reserveToken, _depositAmount);\r\n        // ensure the trade gives something in return and meets the minimum requested amount\r\n        require(amount != 0 && amount >= _minReturn);\r\n\r\n        // update virtual balance if relevant\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        if (reserve.isVirtualBalanceEnabled)\r\n            reserve.virtualBalance = reserve.virtualBalance.add(_depositAmount);\r\n\r\n        // transfer funds from the caller in the reserve token\r\n        ensureTransferFrom(_reserveToken, msg.sender, this, _depositAmount);\r\n        // issue new funds to the caller in the smart token\r\n        token.issue(msg.sender, amount);\r\n\r\n        // dispatch the conversion event\r\n        dispatchConversionEvent(_reserveToken, token, _depositAmount, amount, feeAmount);\r\n\r\n        // dispatch price data update for the smart token/reserve\r\n        emit PriceDataUpdate(_reserveToken, token.totalSupply(), _reserveToken.balanceOf(this), reserve.ratio);\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n      * @dev sells the token by withdrawing from one of its reserve tokens\r\n      * \r\n      * @param _reserveToken    reserve token contract address\r\n      * @param _sellAmount      amount to sell (in the smart token)\r\n      * @param _minReturn       if the conversion results in an amount smaller the minimum return - it is cancelled, must be nonzero\r\n      * \r\n      * @return sell return amount\r\n    */\r\n    function sell(IERC20Token _reserveToken, uint256 _sellAmount, uint256 _minReturn) internal returns (uint256) {\r\n        require(_sellAmount <= token.balanceOf(msg.sender)); // validate input\r\n        uint256 amount;\r\n        uint256 feeAmount;\r\n        (amount, feeAmount) = getSaleReturn(_reserveToken, _sellAmount);\r\n        // ensure the trade gives something in return and meets the minimum requested amount\r\n        require(amount != 0 && amount >= _minReturn);\r\n\r\n        // ensure that the trade will only deplete the reserve balance if the total supply is depleted as well\r\n        uint256 tokenSupply = token.totalSupply();\r\n        uint256 reserveBalance = _reserveToken.balanceOf(this);\r\n        assert(amount < reserveBalance || (amount == reserveBalance && _sellAmount == tokenSupply));\r\n\r\n        // update virtual balance if relevant\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        if (reserve.isVirtualBalanceEnabled)\r\n            reserve.virtualBalance = reserve.virtualBalance.sub(amount);\r\n\r\n        // destroy _sellAmount from the caller's balance in the smart token\r\n        token.destroy(msg.sender, _sellAmount);\r\n        // transfer funds to the caller in the reserve token\r\n        ensureTransferFrom(_reserveToken, this, msg.sender, amount);\r\n\r\n        // dispatch the conversion event\r\n        dispatchConversionEvent(token, _reserveToken, _sellAmount, amount, feeAmount);\r\n\r\n        // dispatch price data update for the smart token/reserve\r\n        emit PriceDataUpdate(_reserveToken, token.totalSupply(), _reserveToken.balanceOf(this), reserve.ratio);\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n      * @dev converts a specific amount of _fromToken to _toToken\r\n      * note that prior to version 16, you should use 'convert' instead\r\n      * \r\n      * @param _fromToken           ERC20 token to convert from\r\n      * @param _toToken             ERC20 token to convert to\r\n      * @param _amount              amount to convert, in fromToken\r\n      * @param _minReturn           if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n      * @param _affiliateAccount    affiliate account\r\n      * @param _affiliateFee        affiliate fee in PPM\r\n      * \r\n      * @return conversion return amount\r\n    */\r\n    function convert2(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn, address _affiliateAccount, uint256 _affiliateFee) public returns (uint256) {\r\n        IERC20Token[] memory path = new IERC20Token[](3);\r\n        (path[0], path[1], path[2]) = (_fromToken, token, _toToken);\r\n        return quickConvert2(path, _amount, _minReturn, _affiliateAccount, _affiliateFee);\r\n    }\r\n\r\n    /**\r\n      * @dev converts the token to any other token in the bancor network by following a predefined conversion path\r\n      * note that when converting from an ERC20 token (as opposed to a smart token), allowance must be set beforehand\r\n      * note that prior to version 16, you should use 'quickConvert' instead\r\n      * \r\n      * @param _path                conversion path, see conversion path format in the BancorNetwork contract\r\n      * @param _amount              amount to convert from (in the initial source token)\r\n      * @param _minReturn           if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n      * @param _affiliateAccount    affiliate account\r\n      * @param _affiliateFee        affiliate fee in PPM\r\n      * \r\n      * @return tokens issued in return\r\n    */\r\n    function quickConvert2(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _affiliateAccount, uint256 _affiliateFee)\r\n        public\r\n        payable\r\n        returns (uint256)\r\n    {\r\n        return quickConvertPrioritized2(_path, _amount, _minReturn, getSignature(0x0, 0x0, 0x0, 0x0, 0x0), _affiliateAccount, _affiliateFee);\r\n    }\r\n\r\n    /**\r\n      * @dev converts the token to any other token in the bancor network by following a predefined conversion path\r\n      * note that when converting from an ERC20 token (as opposed to a smart token), allowance must be set beforehand\r\n      * note that prior to version 16, you should use 'quickConvertPrioritized' instead\r\n      * \r\n      * @param _path                conversion path, see conversion path format in the BancorNetwork contract\r\n      * @param _amount              amount to convert from (in the initial source token)\r\n      * @param _minReturn           if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n      * @param _signature           an array of the following elements:\r\n      *     [0] uint256             custom value that was signed for prioritized conversion; must be equal to _amount\r\n      *     [1] uint256             if the current block exceeded the given parameter - it is cancelled\r\n      *     [2] uint8               (signature[128:130]) associated with the signer address and helps to validate if the signature is legit\r\n      *     [3] bytes32             (signature[0:64]) associated with the signer address and helps to validate if the signature is legit\r\n      *     [4] bytes32             (signature[64:128]) associated with the signer address and helps to validate if the signature is legit\r\n      * if the array is empty (length == 0), then the gas-price limit is verified instead of the signature\r\n      * @param _affiliateAccount    affiliate account\r\n      * @param _affiliateFee        affiliate fee in PPM\r\n      * \r\n      * @return tokens issued in return\r\n    */\r\n    function quickConvertPrioritized2(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, uint256[] memory _signature, address _affiliateAccount, uint256 _affiliateFee)\r\n        public\r\n        payable\r\n        returns (uint256)\r\n    {\r\n        require(_signature.length == 0 || _signature[0] == _amount);\r\n\r\n        IBancorNetwork bancorNetwork = IBancorNetwork(addressOf(BANCOR_NETWORK));\r\n\r\n        // we need to transfer the source tokens from the caller to the BancorNetwork contract,\r\n        // so it can execute the conversion on behalf of the caller\r\n        if (msg.value == 0) {\r\n            // not ETH, send the source tokens to the BancorNetwork contract\r\n            // if the token is the smart token, no allowance is required - destroy the tokens\r\n            // from the caller and issue them to the BancorNetwork contract\r\n            if (_path[0] == token) {\r\n                token.destroy(msg.sender, _amount); // destroy _amount tokens from the caller's balance in the smart token\r\n                token.issue(bancorNetwork, _amount); // issue _amount new tokens to the BancorNetwork contract\r\n            } else {\r\n                // otherwise, we assume we already have allowance, transfer the tokens directly to the BancorNetwork contract\r\n                ensureTransferFrom(_path[0], msg.sender, bancorNetwork, _amount);\r\n            }\r\n        }\r\n\r\n        // execute the conversion and pass on the ETH with the call\r\n        return bancorNetwork.convertForPrioritized4.value(msg.value)(_path, _amount, _minReturn, msg.sender, _signature, _affiliateAccount, _affiliateFee);\r\n    }\r\n\r\n    /**\r\n      * @dev allows a user to convert BNT that was sent from another blockchain into any other\r\n      * token on the BancorNetwork without specifying the amount of BNT to be converted, but\r\n      * rather by providing the xTransferId which allows us to get the amount from BancorX.\r\n      * note that prior to version 16, you should use 'completeXConversion' instead\r\n      * \r\n      * @param _path            conversion path, see conversion path format in the BancorNetwork contract\r\n      * @param _minReturn       if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n      * @param _conversionId    pre-determined unique (if non zero) id which refers to this transaction \r\n      * @param _signature       an array of the following elements:\r\n      *     [0] uint256         custom value that was signed for prioritized conversion; must be equal to _conversionId\r\n      *     [1] uint256         if the current block exceeded the given parameter - it is cancelled\r\n      *     [2] uint8           (signature[128:130]) associated with the signer address and helps to validate if the signature is legit\r\n      *     [3] bytes32         (signature[0:64]) associated with the signer address and helps to validate if the signature is legit\r\n      *     [4] bytes32         (signature[64:128]) associated with the signer address and helps to validate if the signature is legit\r\n      * if the array is empty (length == 0), then the gas-price limit is verified instead of the signature\r\n      * \r\n      * @return tokens issued in return\r\n    */\r\n    function completeXConversion2(\r\n        IERC20Token[] _path,\r\n        uint256 _minReturn,\r\n        uint256 _conversionId,\r\n        uint256[] memory _signature\r\n    )\r\n        public\r\n        returns (uint256)\r\n    {\r\n        // verify that the custom value (if valid) is equal to _conversionId\r\n        require(_signature.length == 0 || _signature[0] == _conversionId);\r\n\r\n        IBancorX bancorX = IBancorX(addressOf(BANCOR_X));\r\n        IBancorNetwork bancorNetwork = IBancorNetwork(addressOf(BANCOR_NETWORK));\r\n\r\n        // verify that the first token in the path is BNT\r\n        require(_path[0] == addressOf(BNT_TOKEN));\r\n\r\n        // get conversion amount from BancorX contract\r\n        uint256 amount = bancorX.getXTransferAmount(_conversionId, msg.sender);\r\n\r\n        // send BNT from msg.sender to the BancorNetwork contract\r\n        token.destroy(msg.sender, amount);\r\n        token.issue(bancorNetwork, amount);\r\n\r\n        return bancorNetwork.convertForPrioritized4(_path, amount, _minReturn, msg.sender, _signature, address(0), 0);\r\n    }\r\n\r\n    /**\r\n      * @dev returns whether or not the caller is an administrator\r\n     */\r\n    function isAdmin() internal view returns (bool) {\r\n        return msg.sender == owner || msg.sender == manager;\r\n    }\r\n\r\n    /**\r\n      * @dev ensures transfer of tokens, taking into account that some ERC-20 implementations don't return\r\n      * true on success but revert on failure instead\r\n      * \r\n      * @param _token     the token to transfer\r\n      * @param _from      the address to transfer the tokens from\r\n      * @param _to        the address to transfer the tokens to\r\n      * @param _amount    the amount to transfer\r\n    */\r\n    function ensureTransferFrom(IERC20Token _token, address _from, address _to, uint256 _amount) private {\r\n        IAddressList addressList = IAddressList(addressOf(NON_STANDARD_TOKEN_REGISTRY));\r\n        bool transferFromThis = _from == address(this);\r\n        if (addressList.listedAddresses(_token)) {\r\n            uint256 prevBalance = _token.balanceOf(_to);\r\n            // we have to cast the token contract in an interface which has no return value\r\n            if (transferFromThis)\r\n                INonStandardERC20(_token).transfer(_to, _amount);\r\n            else\r\n                INonStandardERC20(_token).transferFrom(_from, _to, _amount);\r\n            uint256 postBalance = _token.balanceOf(_to);\r\n            assert(postBalance > prevBalance);\r\n        } else {\r\n            // if the token is standard, we assert on transfer\r\n            if (transferFromThis)\r\n                assert(_token.transfer(_to, _amount));\r\n            else\r\n                assert(_token.transferFrom(_from, _to, _amount));\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @dev buys the token with all reserve tokens using the same percentage\r\n      * for example, if the caller increases the supply by 10%,\r\n      * then it will cost an amount equal to 10% of each reserve token balance\r\n      * note that the function can be called only when conversions are enabled\r\n      * \r\n      * @param _amount  amount to increase the supply by (in the smart token)\r\n    */\r\n    function fund(uint256 _amount)\r\n        public\r\n        conversionsAllowed\r\n        multipleReservesOnly\r\n    {\r\n        uint256 supply = token.totalSupply();\r\n        IBancorFormula formula = IBancorFormula(addressOf(BANCOR_FORMULA));\r\n\r\n        // iterate through the reserve tokens and transfer a percentage equal to the ratio between _amount\r\n        // and the total supply in each reserve from the caller to the converter\r\n        IERC20Token reserveToken;\r\n        uint256 reserveBalance;\r\n        uint256 reserveAmount;\r\n        for (uint16 i = 0; i < reserveTokens.length; i++) {\r\n            reserveToken = reserveTokens[i];\r\n            reserveBalance = reserveToken.balanceOf(this);\r\n            reserveAmount = formula.calculateFundCost(supply, reserveBalance, totalReserveRatio, _amount);\r\n\r\n            // update virtual balance if relevant\r\n            Reserve storage reserve = reserves[reserveToken];\r\n            if (reserve.isVirtualBalanceEnabled)\r\n                reserve.virtualBalance = reserve.virtualBalance.add(reserveAmount);\r\n\r\n            // transfer funds from the caller in the reserve token\r\n            ensureTransferFrom(reserveToken, msg.sender, this, reserveAmount);\r\n\r\n            // dispatch price data update for the smart token/reserve\r\n            emit PriceDataUpdate(reserveToken, supply + _amount, reserveBalance + reserveAmount, reserve.ratio);\r\n        }\r\n\r\n        // issue new funds to the caller in the smart token\r\n        token.issue(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n      * @dev sells the token for all reserve tokens using the same percentage\r\n      * for example, if the holder sells 10% of the supply,\r\n      * then they will receive 10% of each reserve token balance in return\r\n      * note that the function can be called also when conversions are disabled\r\n      * \r\n      * @param _amount  amount to liquidate (in the smart token)\r\n    */\r\n    function liquidate(uint256 _amount)\r\n        public\r\n        multipleReservesOnly\r\n    {\r\n        uint256 supply = token.totalSupply();\r\n        IBancorFormula formula = IBancorFormula(addressOf(BANCOR_FORMULA));\r\n\r\n        // destroy _amount from the caller's balance in the smart token\r\n        token.destroy(msg.sender, _amount);\r\n\r\n        // iterate through the reserve tokens and send a percentage equal to the ratio between _amount\r\n        // and the total supply from each reserve balance to the caller\r\n        IERC20Token reserveToken;\r\n        uint256 reserveBalance;\r\n        uint256 reserveAmount;\r\n        for (uint16 i = 0; i < reserveTokens.length; i++) {\r\n            reserveToken = reserveTokens[i];\r\n            reserveBalance = reserveToken.balanceOf(this);\r\n            reserveAmount = formula.calculateLiquidateReturn(supply, reserveBalance, totalReserveRatio, _amount);\r\n\r\n            // update virtual balance if relevant\r\n            Reserve storage reserve = reserves[reserveToken];\r\n            if (reserve.isVirtualBalanceEnabled)\r\n                reserve.virtualBalance = reserve.virtualBalance.sub(reserveAmount);\r\n\r\n            // transfer funds to the caller in the reserve token\r\n            ensureTransferFrom(reserveToken, this, msg.sender, reserveAmount);\r\n\r\n            // dispatch price data update for the smart token/reserve\r\n            emit PriceDataUpdate(reserveToken, supply - _amount, reserveBalance - reserveAmount, reserve.ratio);\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @dev helper, dispatches the Conversion event\r\n      * \r\n      * @param _fromToken       ERC20 token to convert from\r\n      * @param _toToken         ERC20 token to convert to\r\n      * @param _amount          amount purchased/sold (in the source token)\r\n      * @param _returnAmount    amount returned (in the target token)\r\n    */\r\n    function dispatchConversionEvent(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _returnAmount, uint256 _feeAmount) private {\r\n        // fee amount is converted to 255 bits -\r\n        // negative amount means the fee is taken from the source token, positive amount means its taken from the target token\r\n        // currently the fee is always taken from the target token\r\n        // since we convert it to a signed number, we first ensure that it's capped at 255 bits to prevent overflow\r\n        assert(_feeAmount < 2 ** 255);\r\n        emit Conversion(_fromToken, _toToken, msg.sender, _amount, _returnAmount, int256(_feeAmount));\r\n    }\r\n\r\n    function getSignature(\r\n        uint256 _customVal,\r\n        uint256 _block,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) private pure returns (uint256[] memory) {\r\n        if (_v == 0x0 && _r == 0x0 && _s == 0x0)\r\n            return new uint256[](0);\r\n        uint256[] memory signature = new uint256[](5);\r\n        signature[0] = _customVal;\r\n        signature[1] = _block;\r\n        signature[2] = uint256(_v);\r\n        signature[3] = uint256(_r);\r\n        signature[4] = uint256(_s);\r\n        return signature;\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256) {\r\n        return convertInternal(_fromToken, _toToken, _amount, _minReturn);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function convert(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256) {\r\n        return convert2(_fromToken, _toToken, _amount, _minReturn, address(0), 0);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function quickConvert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256) {\r\n        return quickConvert2(_path, _amount, _minReturn, address(0), 0);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function quickConvertPrioritized(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, uint256 _block, uint8 _v, bytes32 _r, bytes32 _s) public payable returns (uint256) {\r\n        return quickConvertPrioritized2(_path, _amount, _minReturn, getSignature(_amount, _block, _v, _r, _s), address(0), 0);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function completeXConversion(IERC20Token[] _path, uint256 _minReturn, uint256 _conversionId, uint256 _block, uint8 _v, bytes32 _r, bytes32 _s) public returns (uint256) {\r\n        return completeXConversion2(_path, _minReturn, _conversionId, getSignature(_conversionId, _block, _v, _r, _s));\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function connectors(address _address) public view returns (uint256, uint32, bool, bool, bool) {\r\n        Reserve storage reserve = reserves[_address];\r\n        return(reserve.virtualBalance, reserve.ratio, reserve.isVirtualBalanceEnabled, reserve.isSaleEnabled, reserve.isSet);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function connectorTokens(uint256 _index) public view returns (IERC20Token) {\r\n        return BancorConverter.reserveTokens[_index];\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function connectorTokenCount() public view returns (uint16) {\r\n        return reserveTokenCount();\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function addConnector(IERC20Token _token, uint32 _weight, bool /*_enableVirtualBalance*/) public {\r\n        addReserve(_token, _weight);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function updateConnector(IERC20Token _connectorToken, uint32 /*_weight*/, bool /*_enableVirtualBalance*/, uint256 _virtualBalance) public {\r\n        updateReserveVirtualBalance(_connectorToken, _virtualBalance);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function disableConnectorSale(IERC20Token _connectorToken, bool _disable) public {\r\n        disableReserveSale(_connectorToken, _disable);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function getConnectorBalance(IERC20Token _connectorToken) public view returns (uint256) {\r\n        return getReserveBalance(_connectorToken);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function getCrossConnectorReturn(IERC20Token _fromConnectorToken, IERC20Token _toConnectorToken, uint256 _amount) public view returns (uint256, uint256) {\r\n        return getCrossReserveReturn(_fromConnectorToken, _toConnectorToken, _amount);\r\n    }\r\n}\r\n\r\n// File: contracts/converter/interfaces/IBancorConverterFactory.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n\r\n/*\r\n    Bancor Converter Factory interface\r\n*/\r\ncontract IBancorConverterFactory {\r\n    function createConverter(\r\n        ISmartToken _token,\r\n        IContractRegistry _registry,\r\n        uint32 _maxConversionFee,\r\n        IERC20Token _reserveToken,\r\n        uint32 _reserveRatio\r\n    )\r\n    public returns (address);\r\n}\r\n\r\n// File: contracts/converter/BancorConverterFactory.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n\r\n/*\r\n    Bancor Converter Factory\r\n*/\r\ncontract BancorConverterFactory is IBancorConverterFactory {\r\n    /**\r\n      * @dev triggered when a new converter is created\r\n      * \r\n      * @param _converter   new converter address\r\n      * @param _owner       converter owner address\r\n    */\r\n    event NewConverter(address indexed _converter, address indexed _owner);\r\n\r\n    /**\r\n      * @dev initializes a new BancorConverterFactory instance\r\n    */\r\n    constructor() public {\r\n    }\r\n\r\n    /**\r\n      * @dev creates a new converter with the given arguments and transfers\r\n      * the ownership and management to the sender.\r\n      * \r\n      * @param  _token              smart token governed by the converter\r\n      * @param  _registry           address of a contract registry contract\r\n      * @param  _maxConversionFee   maximum conversion fee, represented in ppm\r\n      * @param  _reserveToken       optional, initial reserve, allows defining the first reserve at deployment time\r\n      * @param  _reserveRatio       optional, ratio for the initial reserve\r\n      * \r\n      * @return a new converter\r\n    */\r\n    function createConverter(\r\n        ISmartToken _token,\r\n        IContractRegistry _registry,\r\n        uint32 _maxConversionFee,\r\n        IERC20Token _reserveToken,\r\n        uint32 _reserveRatio\r\n    ) public returns(address converterAddress) {\r\n        BancorConverter converter = new BancorConverter(\r\n            _token,\r\n            _registry,\r\n            _maxConversionFee,\r\n            _reserveToken,\r\n            _reserveRatio\r\n        );\r\n\r\n        converter.transferOwnership(msg.sender);\r\n        converter.transferManagement(msg.sender);\r\n\r\n        address _converterAddress = address(converter);\r\n        emit NewConverter(_converterAddress, msg.sender);\r\n        return _converterAddress;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_registry\",\"type\":\"address\"},{\"name\":\"_maxConversionFee\",\"type\":\"uint32\"},{\"name\":\"_reserveToken\",\"type\":\"address\"},{\"name\":\"_reserveRatio\",\"type\":\"uint32\"}],\"name\":\"createConverter\",\"outputs\":[{\"name\":\"converterAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_converter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"NewConverter\",\"type\":\"event\"}]","ContractName":"BancorConverterFactory","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://0145b61a898ae62e09871e71b24be651e4058c16a697e29aea7cd9f251ee63ac"}]}