{"status":"1","message":"OK","result":[{"SourceCode":"{\"ConditionKyberRate.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\nimport \\\"./IGelatoCondition.sol\\\";\\nimport \\\"./IKyber.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\ncontract ConditionKyberRate is IGelatoCondition {\\n\\n    using SafeMath for uint256;\\n\\n    enum Reason {\\n        // StandardReason Fields\\n        Ok,  // 0: Standard Field for Fulfilled Conditions and No Errors\\n        NotOk,  // 1: Standard Field for Unfulfilled Conditions or Caught/Handled Errors\\n        UnhandledError,  // 2: Standard Field for Uncaught/Unhandled Errors\\n        // Ok: Fulfilled Conditions\\n        OkKyberExpectedRateIsGreaterThanRefRate,\\n        OkKyberExpectedRateIsSmallerThanRefRate,\\n        // NotOk: Unfulfilled Conditions\\n        NotOkKyberExpectedRateIsNotGreaterThanRefRate,\\n        NotOkKyberExpectedRateIsNotSmallerThanRefRate,\\n        KyberGetExpectedRateError\\n    }\\n\\n    // conditionSelector public state variable np due to this.actionSelector constant issue\\n    function conditionSelector() external pure override returns(bytes4) {\\n        return this.reached.selector;\\n    }\\n    uint256 public constant override conditionGas = 500000;\\n\\n    function reached(\\n        address _src,\\n        uint256 _srcAmt,\\n        address _dest,\\n        uint256 _refRate,\\n        bool _greaterElseSmaller\\n    )\\n        external\\n        view\\n        returns(bool, uint8)  // executable?, reason\\n    {\\n        // !!!!!!!!! MAINNET !!!!!!\\n        address kyberAddress = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;\\n\\n        try IKyber(kyberAddress).getExpectedRate(\\n            _src,\\n            _dest,\\n            _srcAmt\\n        )\\n            returns(uint256 expectedRate, uint256)\\n        {\\n            if (_greaterElseSmaller) {  // greaterThan\\n                if (expectedRate \\u003e= _refRate)\\n                    return (true, uint8(Reason.OkKyberExpectedRateIsGreaterThanRefRate));\\n                else\\n                    return (false, uint8(Reason.NotOkKyberExpectedRateIsNotGreaterThanRefRate));\\n            } else {  // smallerThan\\n                if (expectedRate \\u003c= _refRate)\\n                    return (true, uint8(Reason.OkKyberExpectedRateIsSmallerThanRefRate));\\n                else\\n                    return(false, uint8(Reason.NotOkKyberExpectedRateIsNotSmallerThanRefRate));\\n            }\\n        } catch {\\n            return(false, uint8(Reason.KyberGetExpectedRateError));\\n        }\\n    }\\n\\n    function getConditionValue(address _src, uint256 _srcAmt, address _dest, uint256, bool)\\n        external\\n        view\\n        returns(uint256)\\n    {\\n        // !!!!!!!!! MAINNET !!!!!!\\n        address kyberAddress = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;\\n\\n        (uint256 expectedRate,) = IKyber(kyberAddress).getExpectedRate(_src, _dest, _srcAmt);\\n        return expectedRate;\\n    }\\n}\"},\"ConditionKyberRateError.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\nimport \\\"./ConditionKyberRate.sol\\\";\\n\\ncontract ConditionKyberRateError {\\n\\n    enum Reason {\\n        // StandardReason Fields\\n        Ok,  // 0: Standard Field for Fulfilled Conditions and No Errors\\n        NotOk,  // 1: Standard Field for Unfulfilled Conditions or Caught/Handled Errors\\n        UnhandledError,  // 2: Standard Field for Uncaught/Unhandled Errors\\n        // Ok: Fulfilled Conditions\\n        OkKyberExpectedRateIsGreaterThanRefRate,\\n        OkKyberExpectedRateIsSmallerThanRefRate,\\n        // NotOk: Unfulfilled Conditions\\n        NotOkKyberExpectedRateIsNotGreaterThanRefRate,\\n        NotOkKyberExpectedRateIsNotSmallerThanRefRate,\\n        KyberGetExpectedRateError\\n    }\\n\\n    uint256 public conditionGas = 500000;\\n\\n    function setConditionGas(uint256 _gas) external {\\n        conditionGas = _gas;\\n    }\\n\\n    function canExecute(\\n        ConditionKyberRate _conditionKyberRate,\\n        // The parameters we need to encode\\n        address _src,\\n        uint256 _srcAmt,\\n        address _dest,\\n        uint256 _refRate,\\n        bool _greaterElseSmaller\\n    )\\n        external\\n        view\\n        returns(string memory)\\n    {\\n        bytes4 reachedSelector = _conditionKyberRate.reached.selector;\\n\\n        bytes memory reachedPayload = abi.encodeWithSelector(\\n            reachedSelector,\\n            _src,\\n            _srcAmt,\\n            _dest,\\n            _refRate,\\n            _greaterElseSmaller\\n        );\\n\\n        (bool success,\\n         bytes memory returndata)\\n            = address(_conditionKyberRate).staticcall.gas(conditionGas)(reachedPayload);\\n\\n        if (!success) return \\\"Unhandled Condition Error\\\";\\n        else {\\n            (, uint8 reason) = abi.decode(returndata, (bool, uint8));\\n\\n            if (reason == uint8(Reason.Ok)) return \\\"ConditionKyberRate: Ok\\\";\\n\\n            else if (reason == uint8(Reason.NotOk)) return \\\"ConditionKyberRate: NotOk\\\";\\n\\n            else if (reason == uint8(Reason.UnhandledError))\\n                return \\\"ConditionKyberRate: UnhandledError\\\";\\n\\n            else if (reason == uint8(Reason.OkKyberExpectedRateIsGreaterThanRefRate))\\n                return \\\"ConditionKyberRate: OkKyberExpectedRateIsGreaterThanRefRate\\\";\\n\\n            else if (reason == uint8(Reason.OkKyberExpectedRateIsSmallerThanRefRate))\\n                return \\\"ConditionKyberRate: OkKyberExpectedRateIsSmallerThanRefRate\\\";\\n\\n            else if (reason == uint8(Reason.NotOkKyberExpectedRateIsNotGreaterThanRefRate))\\n                return \\\"ConditionKyberRate: NotOkKyberExpectedRateIsNotGreaterThanRefRate\\\";\\n\\n            else if (reason == uint8(Reason.NotOkKyberExpectedRateIsNotSmallerThanRefRate))\\n                return \\\"ConditionKyberRate: NotOkKyberExpectedRateIsNotSmallerThanRefRate\\\";\\n\\n            else if (reason == uint8(Reason.KyberGetExpectedRateError))\\n                return \\\"ConditionKyberRate: KyberGetExpectedRateError\\\";\\n\\n            else return \\\"Unidentified ConditionKyberRate reason\\\";\\n        }\\n    }\\n}\"},\"IGelatoCondition.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/// @title IGelatoCondition - solidity interface of GelatoConditionsStandard\\n/// @notice all the APIs of GelatoConditionsStandard\\n/// @dev all the APIs are implemented inside GelatoConditionsStandard\\ninterface IGelatoCondition {\\n    /* CAUTION All Conditions must reserve the first 3 fields of their `enum Reason` as such:\\n        0: Ok,  // 0: standard field for Fulfilled Conditions and No Errors\\n        1: NotOk,  // 1: standard field for Unfulfilled Conditions or Handled Errors\\n        2: UnhandledError  // 2: standard field for Unhandled or Uncaught Errors\\n    */\\n\\n    /* CAUTION: the following functions are part of the standard IGelatoCondition interface but cannot be overriden\\n        - \\\"function reached(args) external view\\\": non-standardisable due to different arguments passed across different conditions\\n        - \\\"function getConditionValue(same args as reached function) external view/pure\\\": always takes same args as reached()\\n    */\\n\\n    function conditionSelector() external pure returns(bytes4);\\n    function conditionGas() external pure returns(uint256);\\n}\"},\"IKyber.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\ninterface IKyber {\\n    /**\\n     * @dev Makes a trade between src and dest token and send dest tokens to destAddress\\n     * @param src source ERC20 token contract address\\n     * @param srcAmount source ERC20 token amount in its token decimals\\n     * @param dest destination ERC20 token contract address\\n     * @param destAddress recipient address for destination ERC20 token\\n     * @param maxDestAmount limit on the amount of destination tokens\\n     * @param minConversionRate minimum conversion rate; trade is canceled if actual rate is lower\\n     * @param walletId wallet address to send part of the fees to\\n     * @return Amount of actual destination tokens\\n     * @notice srcAmount | maxDestAmount These amounts should be in the source and\\n         destination token decimals respectively. For example, if the user wants to swap\\n         from / to 10 POWR,which has 6 decimals, it would be 10 * (10 ** 6) = 10000000\\n     * @notice maxDestAmount should not be 0. Set it to an arbitarily large amount\\n         if you want all source tokens to be converted.\\n     * @notice minConversionRate: This rate is independent of the source and\\n         destination token decimals. To calculate this rate, take yourRate * 10**18.\\n         For example, even though ZIL has 12 token decimals, if we want the minimum\\n         conversion rate to be 1 ZIL = 0.00017 ETH, then\\n         minConversionRate = 0.00017 * (10 ** 18).\\n     * @notice walletId: If you are part of our fee sharing program, this will be\\n         your registered wallet address. Set it as 0 if you are not a participant.\\n     * @notice Since ETH is not an ERC20 token, we use\\n        0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee as a proxy address to represent it.\\n     * @notice If src is ETH, then you also need to send ether along with your call.\\n     * @notice There is a minimum trading value of 1000 wei tokens.\\n        Anything fewer is considered as 0.\\n     */\\n    function trade(\\n        address src,\\n        uint256 srcAmount,\\n        address dest,\\n        address destAddress,\\n        uint256 maxDestAmount,\\n        uint256 minConversionRate,\\n        address walletId\\n    )\\n        external\\n        payable\\n        returns (uint256);\\n\\n    /**\\n     * @dev Get the expected exchange rate.\\n     * @param src source ERC20 token contract address\\n     * @param dest destination ERC20 token contract address\\n     * @param srcQty wei amount of source ERC20 token\\n     * @return The expected exchange rate and slippage rate.\\n     * @notice Returned values are in precision values (10**18)\\n        To understand what this rate means, divide the obtained value by 10**18\\n        (tA, tB,)\\n     */\\n    function getExpectedRate(address src, address dest, uint256 srcQty)\\n        external\\n        view\\n        returns (uint256, uint256);\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ConditionKyberRate\",\"name\":\"_conditionKyberRate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_src\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_srcAmt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_refRate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_greaterElseSmaller\",\"type\":\"bool\"}],\"name\":\"canExecute\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"conditionGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gas\",\"type\":\"uint256\"}],\"name\":\"setConditionGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ConditionKyberRateError","CompilerVersion":"v0.6.1+commit.e6f7d5a4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"ipfs://66ab36f0f32e8c5a68c1ad096a8ad7c05e201eae5b301e75142c7726fed72851"}]}