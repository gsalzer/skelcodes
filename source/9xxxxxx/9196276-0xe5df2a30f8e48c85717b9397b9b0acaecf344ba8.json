{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.12;\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title   Lition Pool Contract\r\n * @author  Patricio Mosse\r\n * @notice  This contract is used for staking LIT (ERC20) tokens to support a validator running in the Lition blockchain network and distribute rewards.\r\n **/\r\ncontract LitionPool {\r\n    using SafeMath for uint256;\r\n\r\n    /**************************************************** Events **************************************************************/\r\n    \r\n    event NewStake(address indexed staker, uint256 totalStaked, uint8 lockupPeriod, bool compound);\r\n    event StakeFinishedByUser(address indexed staker, uint256 totalRecovered, uint256 index);\r\n    event StakeRemoved(address indexed staker, uint256 totalRecovered, uint256 index);\r\n    event RewardsToBeAccreditedDistributed(uint256 total);\r\n    event RewardsToBeAccreditedUpdated(address indexed staker, uint256 total, uint256 delta);\r\n    event RewardsAccredited(uint256 total);\r\n    event RewardsAccreditedToStaker(address indexed staker, uint256 total);\r\n    event CompoundChanged(address indexed staker, uint256 index);\r\n    event RewardsWithdrawn(address indexed staker, uint256 total);\r\n    event StakeDeclaredAsFinished(address indexed staker, uint256 index);\r\n    event StakeIncreased(address indexed staker, uint256 index, uint256 total, uint256 delta);\r\n    event TransferredToVestingAccount(uint256 total);\r\n\r\n    /**************************************************** Vars and structs **************************************************************/\r\n    \r\n    address public owner;\r\n    IERC20 litionToken;\r\n    uint256 public lastMiningRewardBlock = 0;\r\n    uint256 public lastNewStakeBlock = 0;\r\n    bool public paused = false;\r\n\r\n    struct StakeList {\r\n        Stake[] stakes;\r\n        uint256 rewards;\r\n        uint256 rewardsToBeAccredited;\r\n    }\r\n    \r\n    struct Stake {\r\n        uint256 createdOn;\r\n        uint256 totalStaked;\r\n        uint8 lockupPeriod;\r\n        bool compound;\r\n        bool isFinished;\r\n    }\r\n    \r\n    address[] public stakers;\r\n    mapping (address => StakeList) public stakeListBySender;\r\n\r\n    /**************************************************** Admin **************************************************************/\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    constructor(IERC20 _litionToken) public {\r\n        owner = msg.sender;\r\n        litionToken = _litionToken;\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"New owner can't be the zero address\");\r\n        owner = newOwner;\r\n    }\r\n    \r\n    function _switchPaused() public onlyOwner {\r\n        paused = !paused;\r\n    }\r\n\r\n    function() external payable {\r\n        revert();\r\n    }\r\n\r\n    /**************************************************** Public Interface for Stakers **************************************************************/\r\n\r\n    function createNewStake(uint256 _amount, uint8 _lockupPeriod, bool _compound) public {\r\n        require(!paused, \"New stakes are paused\");\r\n        require(_isValidLockupPeriod(_lockupPeriod), \"The lockup period is invalid\");\r\n        require(_amount >= 5000000000000000000000, \"You must stake at least 5000 LIT\");\r\n        require(_canStakeToday(), \"You can't start a stake until the first day of next month\");\r\n        require(IERC20(litionToken).transferFrom(msg.sender, address(this), _amount), \"Couldn't take the LIT from the sender\");\r\n        \r\n        Stake memory stake = Stake({createdOn: now, \r\n                                    totalStaked:_amount, \r\n                                    lockupPeriod:_lockupPeriod, \r\n                                    compound:_compound, \r\n                                    isFinished:false});\r\n                                    \r\n        Stake[] storage stakes = stakeListBySender[msg.sender].stakes;\r\n        stakes.push(stake);\r\n        _addStakerIfNotExist(msg.sender);\r\n        \r\n        emit NewStake(msg.sender, _amount, _lockupPeriod, _compound);\r\n    }\r\n    \r\n    function switchCompound(uint256 _index) public {\r\n        require(stakeListBySender[msg.sender].stakes.length > _index, \"The stake doesn't exist\");\r\n        stakeListBySender[msg.sender].stakes[_index].compound = !stakeListBySender[msg.sender].stakes[_index].compound;\r\n        \r\n        emit CompoundChanged(msg.sender, _index);\r\n    }\r\n    \r\n    function finishStake(uint256 _index) public {\r\n        require(stakeListBySender[msg.sender].stakes.length > _index, \"The stake doesn't exist\");\r\n        Stake memory stake = stakeListBySender[msg.sender].stakes[_index];\r\n        require (stake.isFinished, \"The stake is not finished yet\");\r\n        uint256 total = _closeStake(msg.sender, _index);\r\n        \r\n        emit StakeFinishedByUser(msg.sender, total, _index);\r\n    }\r\n    \r\n     function withdrawRewards() public {\r\n        require(stakeListBySender[msg.sender].rewards > 0, \"You don't have rewards to withdraw\");\r\n        \r\n        uint256 total = stakeListBySender[msg.sender].rewards;\r\n        stakeListBySender[msg.sender].rewards = 0;\r\n\r\n        require(litionToken.transfer(msg.sender, total));\r\n\r\n        emit RewardsWithdrawn(msg.sender, total);\r\n    }\r\n\r\n    /**************************************************** Public Interface for Admin **************************************************************/\r\n\r\n    // Will be called monthly, at the end of each month\r\n    function _accreditRewards() public onlyOwner {\r\n        uint256 totalToAccredit = getTotalRewardsToBeAccredited();\r\n        require(IERC20(litionToken).transferFrom(msg.sender, address(this), totalToAccredit), \"Couldn't take the LIT from the sender\");\r\n\r\n        for (uint256 i = 0; i < stakers.length; i++) {\r\n            StakeList storage stakeList = stakeListBySender[stakers[i]];\r\n            uint256 rewardsToBeAccredited = stakeList.rewardsToBeAccredited;\r\n            if (rewardsToBeAccredited > 0) {\r\n                stakeList.rewardsToBeAccredited = 0;\r\n                stakeList.rewards += rewardsToBeAccredited;\r\n                \r\n                emit RewardsAccreditedToStaker(stakers[i], rewardsToBeAccredited);\r\n            }\r\n        }\r\n        \r\n        emit RewardsAccredited(totalToAccredit);\r\n    }\r\n\r\n    // Will be called monthly, at the end of each month\r\n    function _declareFinishers() public onlyOwner {\r\n        uint256 totalForClosers = getTotalAmountsForClosers();\r\n        require(totalForClosers > 0, \"There are no finishers\");\r\n        require(IERC20(litionToken).transferFrom(msg.sender, address(this), totalForClosers), \"Couldn't take the LIT from the sender\");\r\n\r\n        for (uint256 i = 0; i < stakers.length; i++) {\r\n            Stake[] storage stakes = stakeListBySender[stakers[i]].stakes;\r\n            for (uint256 j = 0; j < stakes.length; j++) {\r\n                if (!stakes[j].isFinished && _isLockupPeriodFinished(stakes[j].createdOn, stakes[j].lockupPeriod)) {\r\n                    stakes[j].isFinished = true;\r\n                    \r\n                    emit StakeDeclaredAsFinished(stakers[i], j);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Will be called every day to distribute the accumulated new MiningReward events coming from LitionRegistry\r\n    function _updateRewardsToBeAccredited(uint256 _fromMiningRewardBlock, uint256 _toMiningRewardBlock, uint256 _amount) public onlyOwner {\r\n        require(_fromMiningRewardBlock < _toMiningRewardBlock, \"Invalid params\");\r\n        require(_fromMiningRewardBlock > lastMiningRewardBlock, \"Rewards already distributed\");\r\n        \r\n        lastMiningRewardBlock = _toMiningRewardBlock;\r\n        \r\n        //Won't consider any stake marked as isFinished\r\n        \r\n        uint256 fees = _amount.mul(5) / 100; // Amount the validator will keep for himself\r\n        uint256 totalParts = _calculateParts();\r\n\r\n        _distributeBetweenStakers(totalParts, _amount.sub(fees));\r\n\r\n        emit RewardsToBeAccreditedDistributed(_amount);\r\n    }\r\n\r\n    function _transferLITToVestingAccount(uint256 _fromNewStakeBlock, uint256 _toNewStakeBlock, uint256 _total) public onlyOwner {\r\n        require(_fromNewStakeBlock < _toNewStakeBlock, \"Invalid params\");\r\n        require(_fromNewStakeBlock > lastNewStakeBlock, \"Stakes already transferred\");\r\n        \r\n        lastNewStakeBlock = _toNewStakeBlock;\r\n        \r\n        require(litionToken.transfer(msg.sender, _total));\r\n        emit TransferredToVestingAccount(_total);\r\n    }\r\n\r\n    function _extractRemainingLitSentByMistake(address _sendTo) public onlyOwner {\r\n        require(stakers.length == 0, \"There are still stakers in the contract\");\r\n        uint256 totalBalance = litionToken.balanceOf(address(this));\r\n        require(litionToken.transfer(_sendTo, totalBalance));\r\n    }\r\n    \r\n    function _extractCertainLitSentByMistake(uint256 amount, address _sendTo) public onlyOwner {\r\n        require(litionToken.transfer(_sendTo, amount));\r\n    }\r\n\r\n    function _removeStaker(address _staker, uint256 _index) public onlyOwner {\r\n        require(stakeListBySender[_staker].stakes.length > _index, \"The stake doesn't exist\");\r\n        uint256 total = _closeStake(_staker, _index);\r\n\r\n        emit StakeRemoved(_staker, total, _index);\r\n    }\r\n\r\n    /**************************************************** Pool Information **************************************************************/\r\n\r\n\tfunction getTotalRewardsToBeAccredited() public view returns (uint256) {\r\n        uint256 total = 0;\r\n        for (uint256 i = 0; i < stakers.length; i++) {\r\n            total += stakeListBySender[stakers[i]].rewardsToBeAccredited;\r\n        }\r\n        return total;\r\n    }\r\n    \r\n    function getTotalAmountsForClosers() public view returns (uint256) {\r\n        uint256 total = 0;\r\n        for (uint256 i = 0; i < stakers.length; i++) {\r\n            Stake[] memory stakes = stakeListBySender[stakers[i]].stakes;\r\n            for (uint256 j = 0; j < stakes.length; j++) {\r\n                if (!stakes[j].isFinished && _isLockupPeriodFinished(stakes[j].createdOn, stakes[j].lockupPeriod)) {\r\n                    total = total.add(stakes[j].totalStaked);\r\n                }\r\n            }\r\n        }\r\n        return total;\r\n    }\r\n\r\n\tfunction areThereFinishers() public view returns(bool) {\r\n        for (uint256 i = 0; i < stakers.length; i++) {\r\n            Stake[] storage stakes = stakeListBySender[stakers[i]].stakes;\r\n            for (uint256 j = 0; j < stakes.length; j++) {\r\n                if (!stakes[j].isFinished && _isLockupPeriodFinished(stakes[j].createdOn, stakes[j].lockupPeriod)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function getTotalInStakeIncludingFinished() public view returns (uint256) {\r\n        uint256 total = 0;\r\n        for (uint256 i = 0; i < stakers.length; i++) {\r\n            Stake[] memory stakes = stakeListBySender[stakers[i]].stakes;\r\n            for (uint256 j = 0; j < stakes.length; j++) {\r\n                total = total.add(stakes[j].totalStaked);\r\n            }\r\n        }\r\n        return total;\r\n    }\r\n    \r\n    function getTotalInStake() public view returns (uint256) {\r\n        uint256 total = 0;\r\n        for (uint256 i = 0; i < stakers.length; i++) {\r\n            Stake[] memory stakes = stakeListBySender[stakers[i]].stakes;\r\n            for (uint256 j = 0; j < stakes.length; j++) {\r\n                if (!stakes[j].isFinished) {\r\n                    total = total.add(stakes[j].totalStaked);\r\n                }\r\n            }\r\n        }\r\n        return total;\r\n    }\r\n    \r\n    function getTotalStakes() public view returns (uint256) {\r\n        uint256 total = 0;\r\n        for (uint256 i = 0; i < stakers.length; i++) {\r\n            Stake[] memory stakes = stakeListBySender[stakers[i]].stakes;\r\n            for (uint256 j = 0; j < stakes.length; j++) {\r\n                if (!stakes[j].isFinished) {\r\n                    total += 1;\r\n                }\r\n            }\r\n        }\r\n        return total;\r\n    }\r\n    \r\n    function getTotalStakers() public view returns (uint256) {\r\n        return stakers.length;\r\n    }\r\n\r\n    function getStaker(address _staker) external view returns (uint256 rewards, uint256 rewardsToBeAccredited, uint256 totalStakes) {\r\n        StakeList memory stakeList = stakeListBySender[_staker];\r\n        rewards = stakeList.rewards;\r\n        rewardsToBeAccredited = stakeList.rewardsToBeAccredited;\r\n        totalStakes = stakeList.stakes.length;\r\n    }\r\n    \r\n    function getStake(address _staker, uint256 _index) external view returns (uint256 createdOn, uint256 totalStaked, uint8 lockupPeriod, bool compound, bool isFinished, uint256 lockupFinishes) {\r\n        require(stakeListBySender[_staker].stakes.length > _index, \"The stake doesn't exist\");\r\n        Stake memory stake = stakeListBySender[_staker].stakes[_index];\r\n        createdOn = stake.createdOn;\r\n        totalStaked = stake.totalStaked;\r\n        lockupPeriod = stake.lockupPeriod;\r\n        compound = stake.compound;\r\n        isFinished = stake.isFinished;\r\n        lockupFinishes = getLockupFinishTimestamp(_staker, _index);\r\n    }\r\n\r\n    function getLockupFinishTimestamp(address _staker, uint256 _index) public view returns (uint256) {\r\n        require(stakeListBySender[_staker].stakes.length > _index, \"The stake doesn't exist\");\r\n        Stake memory stake = stakeListBySender[_staker].stakes[_index];\r\n        return calculateFinishTimestamp(stake.createdOn, stake.lockupPeriod);\r\n    }\r\n\r\n    /**************************************************** Internal Admin - Lockups **************************************************************/\r\n    \r\n    function calculateFinishTimestamp(uint256 _timestamp, uint8 _lockupPeriod) public pure returns (uint256) {\r\n        uint16 year = Date.getYear(_timestamp);\r\n        uint8 month = Date.getMonth(_timestamp);\r\n        month += _lockupPeriod;\r\n        if (month > 12) {\r\n            year += 1;\r\n            month = month % 12;\r\n        }\r\n        uint8 newDay = Date.getDaysInMonth(month, year);\r\n        return Date.toTimestamp(year, month, newDay);\r\n    }\r\n\r\n    /**************************************************** Internal Admin - Stakes and Rewards **************************************************************/\r\n\r\n    function _closeStake(address _staker, uint256 _index) internal returns (uint256) {\r\n        uint256 total = stakeListBySender[_staker].stakes[_index].totalStaked;\r\n\r\n        _removeStakeByIndex(_staker, _index);\r\n        if (stakeListBySender[msg.sender].stakes.length == 0) {\r\n            _removeStakerByValue(_staker);\r\n        }\r\n        \r\n        require(litionToken.transfer(_staker, total));\r\n\r\n        return total;\r\n    }\r\n\r\n    function _distributeBetweenStakers(uint256 _totalParts, uint256 _amountMinusFees) internal {\r\n        uint256 totalTransferred = 0;\r\n\r\n        for (uint256 i = 0; i < stakers.length; i++) {\r\n            StakeList storage stakeList = stakeListBySender[stakers[i]];\r\n            \r\n            for (uint256 j = 0; j < stakeList.stakes.length; j++) {\r\n            \r\n                if (!_isValidAndNotFinished(stakers[i], j)) {\r\n                    continue;\r\n                }\r\n                \r\n                Stake storage stake = stakeList.stakes[j];\r\n                \r\n                uint256 amountToTransfer = _getAmountToTransfer(_totalParts, _amountMinusFees, stake.lockupPeriod, stake.totalStaked);\r\n                totalTransferred = totalTransferred.add(amountToTransfer);\r\n                \r\n                if (stake.compound) {\r\n                    stake.totalStaked = stake.totalStaked.add(amountToTransfer);\r\n\r\n                    emit StakeIncreased(stakers[i], j, stake.totalStaked, amountToTransfer);\r\n                }\r\n                else {\r\n                    stakeList.rewardsToBeAccredited = stakeList.rewardsToBeAccredited.add(amountToTransfer);\r\n                    \r\n                    emit RewardsToBeAccreditedUpdated(stakers[i], stakeList.rewardsToBeAccredited, amountToTransfer);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _calculateParts() internal view returns (uint256) {\r\n        uint256 divideInParts = 0;\r\n        \r\n        for (uint256 i = 0; i < stakers.length; i++) {\r\n            StakeList memory stakeList = stakeListBySender[stakers[i]];\r\n            \r\n            for (uint256 j = 0; j < stakeList.stakes.length; j++) {\r\n                if (!_isValidAndNotFinished(stakers[i], j)) {\r\n                    continue;\r\n                }\r\n                \r\n                Stake memory stake = stakeList.stakes[j];\r\n                if (stake.lockupPeriod == 1) {\r\n                    divideInParts = divideInParts.add(stake.totalStaked.mul(12));\r\n                }\r\n                else if (stake.lockupPeriod == 3) {\r\n                    divideInParts = divideInParts.add(stake.totalStaked.mul(14));\r\n                }\r\n                else if (stake.lockupPeriod == 6) {\r\n                    divideInParts = divideInParts.add(stake.totalStaked.mul(16));\r\n                }\r\n                else if (stake.lockupPeriod == 12) {\r\n                    divideInParts = divideInParts.add(stake.totalStaked.mul(18));\r\n                }\r\n            }\r\n        }\r\n        \r\n        return divideInParts;\r\n    }\r\n\r\n    function _getAmountToTransfer(uint256 _totalParts,  uint256 _amount, uint8 _lockupPeriod, uint256 _rewards) internal pure returns (uint256) {\r\n        uint256 factor;\r\n        \r\n        if (_lockupPeriod == 1) {\r\n            factor = 12;\r\n        }\r\n        else if (_lockupPeriod == 3) {\r\n            factor = 14;\r\n        }\r\n        else if (_lockupPeriod == 6) {\r\n            factor = 16;\r\n        }\r\n        else if (_lockupPeriod == 12) {\r\n            factor = 18;\r\n        }\r\n\r\n        return _amount.mul(factor).mul(_rewards).div(_totalParts);\r\n    }\r\n    \r\n    /**************************************************** Internal Admin - Validations **************************************************************/\r\n    \r\n    function _isValidLockupPeriod(uint8 n) internal pure returns (bool) {\r\n        if (n == 1) {\r\n            return true;\r\n        }\r\n        else if (n == 3) {\r\n            return true;\r\n        }\r\n        else if (n == 6) {\r\n            return true;\r\n        }\r\n        else if (n == 12) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _isLockupPeriodFinished(uint256 _timestamp, uint8 _lockupPeriod) internal view returns (bool) {\r\n        return now > calculateFinishTimestamp(_timestamp, _lockupPeriod);\r\n    }\r\n    \r\n    function _isValidAndNotFinished(address _staker, uint256 _index) internal view returns (bool) {\r\n        if (stakeListBySender[_staker].stakes.length <= _index) {\r\n            return false;\r\n        }\r\n        return !stakeListBySender[_staker].stakes[_index].isFinished;\r\n    }\r\n\r\n    function _canStakeToday() internal view returns (bool) {\r\n        uint8 currentDay = Date.getDay(now);\r\n        uint16 year = Date.getYear(now);\r\n        uint8 month = Date.getMonth(now);\r\n        uint8 totalDays = Date.getDaysInMonth(month, year);\r\n        return totalDays - 8 > currentDay;\r\n    }\r\n\r\n    /**************************************************** Internal Admin - Arrays **************************************************************/\r\n\r\n    function _addStakerIfNotExist(address _staker) internal {\r\n        for (uint256 i = 0; i < stakers.length; i++) {\r\n            if (stakers[i] == _staker) {\r\n                return;\r\n            }\r\n        }\r\n        stakers.push(_staker);\r\n    }\r\n\r\n    function _findStaker(address _value) internal view returns(uint) {\r\n        uint i = 0;\r\n        while (stakers[i] != _value) {\r\n            i++;\r\n        }\r\n        return i;\r\n    }\r\n\r\n    function _removeStakerByValue(address _value) internal {\r\n        uint i = _findStaker(_value);\r\n        _removeStakerByIndex(i);\r\n    }\r\n\r\n    function _removeStakerByIndex(uint _i) internal {\r\n        while (_i<stakers.length-1) {\r\n            stakers[_i] = stakers[_i+1];\r\n            _i++;\r\n        }\r\n        stakers.length--;\r\n    }\r\n    \r\n    function _removeStakeByIndex(address _staker, uint _i) internal {\r\n        Stake[] storage stakes = stakeListBySender[_staker].stakes;\r\n        while (_i<stakes.length-1) {\r\n            stakes[_i] = stakes[_i+1];\r\n            _i++;\r\n        }\r\n        stakes.length--;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary Date {\r\n    struct _Date {\r\n        uint16 year;\r\n        uint8 month;\r\n        uint8 day;\r\n    }\r\n\r\n    uint constant DAY_IN_SECONDS = 86400;\r\n    uint constant YEAR_IN_SECONDS = 31536000;\r\n    uint constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n    uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n    function isLeapYear(uint16 year) public pure returns (bool) {\r\n        if (year % 4 != 0) {\r\n                return false;\r\n        }\r\n        if (year % 100 != 0) {\r\n                return true;\r\n        }\r\n        if (year % 400 != 0) {\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function leapYearsBefore(uint year) public pure returns (uint) {\r\n        year -= 1;\r\n        return year / 4 - year / 100 + year / 400;\r\n    }\r\n\r\n    function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\r\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n                return 31;\r\n        }\r\n        else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n                return 30;\r\n        }\r\n        else if (isLeapYear(year)) {\r\n                return 29;\r\n        }\r\n        else {\r\n                return 28;\r\n        }\r\n    }\r\n\r\n    function parseTimestamp(uint timestamp) internal pure returns (_Date memory dt) {\r\n        uint secondsAccountedFor = 0;\r\n        uint buf;\r\n        uint8 i;\r\n\r\n        // Year\r\n        dt.year = getYear(timestamp);\r\n        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n        // Month\r\n        uint secondsInMonth;\r\n        for (i = 1; i <= 12; i++) {\r\n                secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n                if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                        dt.month = i;\r\n                        break;\r\n                }\r\n                secondsAccountedFor += secondsInMonth;\r\n        }\r\n\r\n        // Day\r\n        for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\r\n                if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                        dt.day = i;\r\n                        break;\r\n                }\r\n                secondsAccountedFor += DAY_IN_SECONDS;\r\n        }\r\n    }\r\n\r\n    function getYear(uint timestamp) public pure returns (uint16) {\r\n        uint secondsAccountedFor = 0;\r\n        uint16 year;\r\n        uint numLeapYears;\r\n\r\n        // Year\r\n        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n        while (secondsAccountedFor > timestamp) {\r\n                if (isLeapYear(uint16(year - 1))) {\r\n                        secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                }\r\n                else {\r\n                        secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                }\r\n                year -= 1;\r\n        }\r\n        return year;\r\n    }\r\n\r\n    function getMonth(uint timestamp) public pure returns (uint8) {\r\n        return parseTimestamp(timestamp).month;\r\n    }\r\n\r\n    function getDay(uint timestamp) public pure returns (uint8) {\r\n        return parseTimestamp(timestamp).day;\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\r\n        uint16 i;\r\n\r\n        // Year\r\n        for (i = ORIGIN_YEAR; i < year; i++) {\r\n                if (isLeapYear(i)) {\r\n                        timestamp += LEAP_YEAR_IN_SECONDS;\r\n                }\r\n                else {\r\n                        timestamp += YEAR_IN_SECONDS;\r\n                }\r\n        }\r\n\r\n        // Month\r\n        uint8[12] memory monthDayCounts;\r\n        monthDayCounts[0] = 31;\r\n        if (isLeapYear(year)) {\r\n                monthDayCounts[1] = 29;\r\n        }\r\n        else {\r\n                monthDayCounts[1] = 28;\r\n        }\r\n        monthDayCounts[2] = 31;\r\n        monthDayCounts[3] = 30;\r\n        monthDayCounts[4] = 31;\r\n        monthDayCounts[5] = 30;\r\n        monthDayCounts[6] = 31;\r\n        monthDayCounts[7] = 31;\r\n        monthDayCounts[8] = 30;\r\n        monthDayCounts[9] = 31;\r\n        monthDayCounts[10] = 30;\r\n        monthDayCounts[11] = 31;\r\n\r\n        for (i = 1; i < month; i++) {\r\n                timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\r\n        }\r\n\r\n        // Day\r\n        timestamp += DAY_IN_SECONDS * (day - 1);\r\n\r\n        return timestamp;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_litionToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"CompoundChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"lockupPeriod\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"compound\",\"type\":\"bool\"}],\"name\":\"NewStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"RewardsAccredited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"RewardsAccreditedToStaker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"RewardsToBeAccreditedDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delta\",\"type\":\"uint256\"}],\"name\":\"RewardsToBeAccreditedUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"RewardsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"StakeDeclaredAsFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalRecovered\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"StakeFinishedByUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delta\",\"type\":\"uint256\"}],\"name\":\"StakeIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalRecovered\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"StakeRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"TransferredToVestingAccount\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[],\"name\":\"_accreditRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_declareFinishers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_sendTo\",\"type\":\"address\"}],\"name\":\"_extractCertainLitSentByMistake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sendTo\",\"type\":\"address\"}],\"name\":\"_extractRemainingLitSentByMistake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"_removeStaker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_switchPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fromNewStakeBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toNewStakeBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_total\",\"type\":\"uint256\"}],\"name\":\"_transferLITToVestingAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"_transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fromMiningRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toMiningRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"_updateRewardsToBeAccredited\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"areThereFinishers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_lockupPeriod\",\"type\":\"uint8\"}],\"name\":\"calculateFinishTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_lockupPeriod\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"_compound\",\"type\":\"bool\"}],\"name\":\"createNewStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"finishStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getLockupFinishTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"createdOn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"lockupPeriod\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"compound\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isFinished\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lockupFinishes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getStaker\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsToBeAccredited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStakes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalAmountsForClosers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalInStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalInStakeIncludingFinished\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalRewardsToBeAccredited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalStakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastMiningRewardBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastNewStakeBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeListBySender\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsToBeAccredited\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"switchCompound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LitionPool","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000763fa6806e1acf68130d2d0f0df754c93cc546b2","Library":"Date:459772562be6b220cb4fdeccc8b5ff8727b958ca","LicenseType":"MIT","SwarmSource":"bzzr://0bd3669484e28913551f5c5511fbd203bf9de1582f21a5e438e065099d1ccd6b"}]}