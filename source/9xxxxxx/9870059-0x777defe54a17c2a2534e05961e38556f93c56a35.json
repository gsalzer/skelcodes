{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.16;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev banq audit is a decentralized audit platform for opensource (smart contract) audit projects\r\n *      anyone can submit audit request and anyone can submit a audit report. A successful agree results in\r\n *      increased loyalty points. A disagree results in loss of loyalty points.\r\n */\r\ncontract BanqAudit {\r\n    using SafeMath for uint256;\r\n    \r\n    //audit data\r\n    struct Audit {\r\n        address owner;\r\n        string link;\r\n        uint256 balance;\r\n        uint256[4] rewards;\r\n        uint256 reportIndex;\r\n        uint256[] reports;\r\n        address[] validated;\r\n        bool closed;\r\n    }\r\n    \r\n    //audit report data\r\n    struct Report {\r\n        address owner;\r\n        bytes32 auditid;\r\n        bytes32 reportid;\r\n        string link;\r\n        uint256 totalrisk;\r\n        uint256[10] bugs;\r\n        uint256[10] bugrisk;\r\n        uint256[10] bugreview;\r\n        bool[10] bugclosed;\r\n        //reportstatus 1 = opened, 2 = responded auditee & 3 = closed auditor\r\n        uint256 reportstatus;           \r\n        uint256 payout;\r\n    }\r\n    \r\n    //Total variables\r\n    uint256 public totalRewardAvailable;\r\n    uint256 public totalPendingPayout;\r\n\r\n    //reliability points auditor and auditee\r\n    uint256 public totalReliability_auditee;\r\n    uint256 public totalReliability_auditor;\r\n    mapping (address => uint256) public reliability_auditee; \r\n    mapping (address => uint256) public reliability_auditor; \r\n    \r\n    //audit requests index and mapping of audits\r\n    uint256 public indexTotal;\r\n    uint256 public indexPending;\r\n    mapping (bytes32 => Audit) public audits;\r\n    mapping (uint256 => bytes32) public index_audit;\r\n    mapping (bytes32 => uint256) public audit_index;\r\n    mapping (uint256 => uint256) public total_pending;\r\n    mapping (uint256 => uint256) public pending_total;\r\n    \r\n    //audit report index and mapping of audits\r\n    uint256 public indexReports;\r\n    mapping (uint256 => Report) public reports;\r\n    \r\n    //address developer used for fee payment\r\n    address payable public dev;\r\n\r\n    //Events to submit during stages of audit\r\n    event AuditRequest(bytes32 _contracthash, uint256 _rewardtotal, address owner);\r\n    event ReportSubmit(bytes32 _contracthash, bytes32 _reporthash, uint256 _reportid, uint256 _risktotal, address owner);\r\n    event VerifiedReport(bytes32 _contracthash, uint256 _reportid, uint256 _amountreview, uint256 _points, bool received);\r\n    event ClosedReport(bytes32 _contracthash, uint256 _reportid, uint256 _payout);\r\n    event ClosedAudit(bytes32 _contracthash, uint256 _amountleft);\r\n\r\n    constructor() public {\r\n        dev = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev fallback function. Makes the contract payable.\r\n     */\r\n    function() external payable {}\r\n\r\n    /**\r\n     * @dev function for the developer to change the address. \r\n     */\r\n    function changeDev(address payable _dev) external returns (bool) {\r\n        require(msg.sender == dev, \"change developer: not the current developer\");\r\n        dev = _dev;\r\n    }\r\n\r\n    /**\r\n     * @dev functions to get the arrays of the audit and report structs.\r\n     */\r\n     function getAuditData(bytes32 _contracthash) public view returns (uint256[4] memory) {\r\n            return audits[_contracthash].rewards;\r\n     }\r\n     function getAuditReports(bytes32 _contracthash) public view returns (uint256[] memory) {\r\n            return audits[_contracthash].reports;\r\n     }\r\n     function getAuditValidators(bytes32 _contracthash) public view returns (address[] memory) {\r\n            return audits[_contracthash].validated;\r\n     }\r\n     function getReportData(uint256 _indexReports, uint256 id) public view returns (uint256[10] memory) {\r\n            if (id == 0) {\r\n                return reports[_indexReports].bugs;\r\n            }\r\n            if (id == 1) {\r\n                return reports[_indexReports].bugrisk;\r\n            }\r\n            if (id == 2) {\r\n                return reports[_indexReports].bugreview;\r\n            }\r\n     } \r\n     \r\n    /**\r\n     * @dev auditee can request an audit using this function and sets reward per bug and bug risk.\r\n     *      contract needs a deposit of multiples of the total reward.\r\n     * \r\n     */\r\n    function RequestAudit(bytes32 _contracthash, string memory _link, uint256[4] memory _rewards) public payable returns (bool success) {\r\n            uint256[] memory emptyarray;\r\n            address[] memory emptyaddress;\r\n            uint256 totalRewards = _rewards[0].add(_rewards[1]).add(_rewards[2]).add(_rewards[3]);\r\n            //calculate fee 0.3% and deduct form deposit\r\n            uint256 deposit_multiplier = msg.value.div(totalRewards);\r\n            uint256 total = totalRewards.mul(deposit_multiplier);\r\n            uint256 fee = total.div(1000).mul(3);\r\n            uint256 amount = msg.value.sub(fee);\r\n            //Check if rewards are multiple of each other and msg.value\r\n            require(audits[_contracthash].owner == address(0), \"request audit: audit is non empty\");\r\n            require(msg.value != 0, \"request audit: no reward added\");\r\n            require(amount.mod(totalRewards) == 0, \"request audit: msg.value not equal to rewards\");\r\n            require(_rewards[0].mod(_rewards[1]) == 0, \"request audit: critical reward is not multiple of high reward\");\r\n            require(_rewards[1].mod(_rewards[2]) == 0, \"request audit: high reward is not multiple of medium reward\");\r\n            require(_rewards[2].mod(_rewards[3]) == 0, \"request audit: critical medium is not multiple of low reward\");\r\n            totalRewardAvailable = totalRewardAvailable.add(amount);\r\n            audits[_contracthash] = Audit({owner: msg.sender,\r\n                                            link: _link,\r\n                                            balance: amount,\r\n                                            rewards: _rewards,\r\n                                            reportIndex: 0,\r\n                                            reports: emptyarray,\r\n                                            validated: emptyaddress,\r\n                                            closed: false\r\n                                    });\r\n            index_audit[indexTotal] = _contracthash;\r\n            audit_index[_contracthash] = indexTotal;\r\n            //Set audit as pending\r\n            total_pending[indexTotal] = indexPending;\r\n            pending_total[indexPending] = indexTotal;\r\n            indexTotal = indexTotal.add(1);\r\n            indexPending = indexPending.add(1);\r\n            dev.transfer(fee);\r\n            emit AuditRequest(_contracthash, totalRewards, msg.sender);\r\n            return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev auditee can deposit additional funds to a pending audit.\r\n     */\r\n    function depositAudit(bytes32 _contracthash) public payable returns (bool success) {\r\n            uint256 minimum = audits[_contracthash].rewards[3];\r\n            //calculate fee 0.3% and deduct form deposit\r\n            uint256 deposit_multiplier = msg.value.div(minimum);\r\n            uint256 total = minimum.mul(deposit_multiplier);\r\n            uint256 fee = total.div(1000).mul(3);\r\n            uint256 amount = msg.value.sub(fee);\r\n            require(!audits[_contracthash].closed, \"deposit audit: audit is closed\");\r\n            require(msg.value != 0, \"request audit: no reward added\");\r\n            require(amount.mod(minimum) == 0, \"deposit audit: msg.value not multiple of minimum reward\");\r\n            totalRewardAvailable = totalRewardAvailable.add(amount);\r\n            audits[_contracthash].balance = audits[_contracthash].balance.add(amount);\r\n            dev.transfer(fee);\r\n            return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev auditor can submit a report (bug) for a pending audit.\r\n     */\r\n    function SubmitReport(bytes32 _contracthash, bytes32 _reporthash, string memory _link, uint256[10] memory _bugID, uint256[10] memory _bugClaim) public returns (bool success) {\r\n            require(!audits[_contracthash].closed, \"submit report: audit is closed\");\r\n            require(audits[_contracthash].owner != msg.sender, \"submit report: auditor and auditee are the same\");\r\n            uint256[10] memory emptyarray; \r\n            bool[10] memory emptyarray1; \r\n            uint256 totalrisk;\r\n            for (uint256 i = 0; i < 10; i++) {\r\n                require(_bugClaim[i] < 5);\r\n                totalrisk = totalrisk.add(_bugClaim[i]);\r\n            }\r\n            audits[_contracthash].reportIndex = audits[_contracthash].reportIndex.add(1);\r\n            reports[indexReports] = Report({owner: msg.sender,\r\n                                            link: _link,\r\n                                            auditid: _contracthash,\r\n                                            reportid: _reporthash,\r\n                                            totalrisk: totalrisk,\r\n                                            bugs: _bugID,\r\n                                            bugrisk: _bugClaim,\r\n                                            bugreview: emptyarray,\r\n                                            bugclosed: emptyarray1,\r\n                                            reportstatus: 1,\r\n                                            payout: 0\r\n                                    });\r\n            audits[_contracthash].reports.push(indexReports);\r\n            indexReports = indexReports.add(1);\r\n            emit ReportSubmit(_contracthash, _reporthash, indexReports, totalrisk, msg.sender);\r\n            return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Auditee can check an audit report and agree/adjust the bug risk in the report \r\n     *      or claim that the report is not received. If not receiven it will deduct \r\n     *      reliability points of the auditor.\r\n     */\r\n    function VerifyReport(uint256 _reportID, uint256[10] memory _bugClaim, uint256 addition, bool received) public returns (bool success) {\r\n            address auditor = reports[_reportID].owner;\r\n            bytes32 _contracthash = reports[_reportID].auditid;\r\n            require(audits[_contracthash].owner == msg.sender, \"verify report: not the owner of the audit\");\r\n            require(reports[_reportID].reportstatus == 1, \"verify report: report is not status 1\");\r\n            reports[_reportID].bugreview = _bugClaim;\r\n            //for loop to calculate amount \r\n            uint256 amountAudit;\r\n            uint256 amountReport;\r\n            for (uint256 i = 0; i < 10; i++) {\r\n                require(_bugClaim[i] < 5);\r\n                if (reports[_reportID].bugrisk[i] != 0 && reports[_reportID].bugclosed[i] != true) {\r\n                        reports[_reportID].bugclosed[i] == true;\r\n                        if (reports[_reportID].bugreview[i] != 0) {\r\n                            uint256 riskReview = reports[_reportID].bugreview[i].sub(1);\r\n                            amountAudit = amountAudit.add(audits[_contracthash].rewards[riskReview]);\r\n                        }\r\n                        uint256 riskReport = reports[_reportID].bugrisk[i].sub(1);\r\n                        amountReport = amountReport.add(audits[_contracthash].rewards[riskReport]);\r\n                } \r\n            }\r\n            if (addition > 0) {\r\n                    require(addition < 5);\r\n                    uint256 index = addition.sub(1);\r\n                    amountAudit = amountAudit.add(audits[_contracthash].rewards[index]);\r\n            }\r\n            uint256 points;\r\n            if (received == false) {\r\n                reports[_reportID].reportstatus = 3;\r\n                points = amountReport.div(10**16);\r\n                if (reliability_auditor[reports[_reportID].owner] > points) {\r\n                    totalReliability_auditor = totalReliability_auditor.sub(points);\r\n                    reliability_auditor[reports[_reportID].owner] = reliability_auditor[reports[_reportID].owner].sub(points);\r\n                } else {\r\n                    totalReliability_auditor = totalReliability_auditor.sub(reliability_auditor[reports[_reportID].owner]);\r\n                    reliability_auditor[reports[_reportID].owner] = 0;\r\n                }\r\n            } else {\r\n                points = amountAudit.div(10**16);\r\n                reports[_reportID].reportstatus = 2;\r\n                totalReliability_auditor = totalReliability_auditor.add(points);\r\n                reliability_auditor[auditor] = reliability_auditor[auditor].add(points);\r\n                totalReliability_auditee = totalReliability_auditee.add(points);\r\n                reliability_auditee[msg.sender] = reliability_auditee[msg.sender].add(points);\r\n                totalRewardAvailable = totalRewardAvailable.sub(amountAudit);\r\n                totalPendingPayout = totalPendingPayout.add(amountAudit);\r\n                audits[_contracthash].balance = audits[_contracthash].balance.sub(amountAudit);\r\n                reports[_reportID].payout = reports[_reportID].payout.add(amountAudit);\r\n            }\r\n            emit VerifiedReport(_contracthash, _reportID, amountAudit, points, received);\r\n            return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Auditor can check response from aditee and agree with changes to receive rewards\r\n     *      or disagree. Disagree will deduct reliability point from the auditee.\r\n     */\r\n    function ClaimResponse(uint256 _reportID, bool agreed) public returns (bool success) {\r\n            bytes32 _contracthash = reports[_reportID].auditid;\r\n            require(reports[_reportID].reportstatus == 2, \"claim report: report is not status 2\");\r\n            require(reports[_reportID].owner == msg.sender, \"claim report: msg.sender is not owner of report\");\r\n            reports[_reportID].reportstatus = 3;\r\n            audits[_contracthash].validated.push(msg.sender);\r\n            uint256 amount_nofee = reports[_reportID].payout;\r\n            //calculate fee and deduct\r\n            uint256 fee = amount_nofee.div(1000).mul(3);\r\n            uint256 amount = amount_nofee.sub(fee);\r\n            if (agreed == true) {\r\n                totalPendingPayout = totalPendingPayout.sub(amount_nofee);\r\n                dev.transfer(fee);\r\n                msg.sender.transfer(amount); \r\n            } else {\r\n                uint256 amountAudit;\r\n                for (uint256 i = 0; i < 10; i++) {\r\n                    if (reports[_reportID].bugreview[i] != 0) {\r\n                        uint256 riskReview = reports[_reportID].bugreview[i].sub(1);\r\n                        amountAudit = amountAudit.add(audits[_contracthash].rewards[riskReview]);\r\n                    } \r\n                }\r\n                uint256 points = amountAudit.div(10**16);\r\n                if (reliability_auditee[audits[_contracthash].owner] > points) {\r\n                    totalReliability_auditee = totalReliability_auditee.sub(points);\r\n                    reliability_auditee[audits[_contracthash].owner] = reliability_auditee[audits[_contracthash].owner].sub(points);\r\n                } else {\r\n                    totalReliability_auditee = totalReliability_auditee.sub(reliability_auditee[audits[_contracthash].owner]);\r\n                    reliability_auditee[audits[_contracthash].owner] = 0;\r\n                }\r\n                totalPendingPayout = totalPendingPayout.sub(amount_nofee);\r\n                dev.transfer(fee);\r\n                msg.sender.transfer(amount); \r\n            }\r\n            emit ClosedReport(_contracthash, _reportID, amount);\r\n            return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Close open audit requests\r\n     */\r\n    function CloseAuditRequest(bytes32 _contracthash) public returns (bool success) {\r\n            require(audits[_contracthash].owner == msg.sender, \"close audit: msg.sender is not owner of audit\");\r\n            require(audits[_contracthash].closed == false, \"close audit: audit is closed\");\r\n            //Check pending reports\r\n            uint256 pending;\r\n            for (uint256 i = 0; i < audits[_contracthash].reportIndex; i++) {\r\n                uint256 reportID = audits[_contracthash].reports[i];\r\n                uint256 reportstatus = reports[reportID].reportstatus;\r\n                if (reportstatus == 1) {\r\n                    pending = pending.add(1);\r\n                }\r\n            }\r\n            require(pending == 0, \"close audit: there is an open report\");\r\n            uint256 amount = audits[_contracthash].balance;\r\n            uint256 index_total = audit_index[_contracthash];\r\n            uint256 pendingIndex = total_pending[index_total];\r\n            uint256 replace = pending_total[indexPending.sub(1)];\r\n            audits[_contracthash].closed = true;\r\n            totalRewardAvailable = totalRewardAvailable.sub(audits[_contracthash].balance);\r\n            audits[_contracthash].balance = 0;\r\n            //Replace with the last and remove last\r\n            pending_total[pendingIndex] = replace;\r\n            total_pending[replace] = pendingIndex;\r\n            pending_total[indexPending.sub(1)] = 0;\r\n            total_pending[index_total] = 0;\r\n            indexPending = indexPending.sub(1);\r\n            //Transfer remaining balance to owner\r\n            msg.sender.transfer(amount);\r\n            emit ClosedAudit(_contracthash, amount);\r\n            return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Auditor can close a report before reaction of the auditor.\r\n     *      \r\n     */\r\n    function CloseReport(uint256 _reportID) public returns (bool success) {\r\n            require(reports[_reportID].reportstatus == 1, \"close report: report is closed\");\r\n            require(reports[_reportID].owner == msg.sender, \"close report: not the owner\");\r\n            reports[_reportID].reportstatus = 3;\r\n            emit ClosedReport(reports[_reportID].auditid, _reportID, 0);\r\n            return true;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_contracthash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_rewardtotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"AuditRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_contracthash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountleft\",\"type\":\"uint256\"}],\"name\":\"ClosedAudit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_contracthash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_reportid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_payout\",\"type\":\"uint256\"}],\"name\":\"ClosedReport\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_contracthash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_reporthash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_reportid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_risktotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ReportSubmit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_contracthash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_reportid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountreview\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_points\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"received\",\"type\":\"bool\"}],\"name\":\"VerifiedReport\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"agreed\",\"type\":\"bool\"}],\"name\":\"ClaimResponse\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_contracthash\",\"type\":\"bytes32\"}],\"name\":\"CloseAuditRequest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportID\",\"type\":\"uint256\"}],\"name\":\"CloseReport\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_contracthash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"_link\",\"type\":\"string\"},{\"internalType\":\"uint256[4]\",\"name\":\"_rewards\",\"type\":\"uint256[4]\"}],\"name\":\"RequestAudit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_contracthash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_reporthash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"_link\",\"type\":\"string\"},{\"internalType\":\"uint256[10]\",\"name\":\"_bugID\",\"type\":\"uint256[10]\"},{\"internalType\":\"uint256[10]\",\"name\":\"_bugClaim\",\"type\":\"uint256[10]\"}],\"name\":\"SubmitReport\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportID\",\"type\":\"uint256\"},{\"internalType\":\"uint256[10]\",\"name\":\"_bugClaim\",\"type\":\"uint256[10]\"},{\"internalType\":\"uint256\",\"name\":\"addition\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"received\",\"type\":\"bool\"}],\"name\":\"VerifyReport\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"audit_index\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"audits\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"link\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reportIndex\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"closed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_dev\",\"type\":\"address\"}],\"name\":\"changeDev\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_contracthash\",\"type\":\"bytes32\"}],\"name\":\"depositAudit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_contracthash\",\"type\":\"bytes32\"}],\"name\":\"getAuditData\",\"outputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"\",\"type\":\"uint256[4]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_contracthash\",\"type\":\"bytes32\"}],\"name\":\"getAuditReports\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_contracthash\",\"type\":\"bytes32\"}],\"name\":\"getAuditValidators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_indexReports\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getReportData\",\"outputs\":[{\"internalType\":\"uint256[10]\",\"name\":\"\",\"type\":\"uint256[10]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"indexPending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"indexReports\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"indexTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"index_audit\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pending_total\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"reliability_auditee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"reliability_auditor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reports\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"auditid\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"reportid\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"link\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalrisk\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reportstatus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPendingPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalReliability_auditee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalReliability_auditor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRewardAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"total_pending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BanqAudit","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://9818f36af36b512dbfd4d422eca2e5c4a6fafc50338938d35ca4697a250dc943"}]}