{"status":"1","message":"OK","result":[{"SourceCode":"// File: akap/contracts/IAKAP.sol\r\n\r\n// Copyright (C) 2019  Christian Felde\r\n// Copyright (C) 2019  Mohamed Elshami\r\n\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n\r\n// http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title  Interface for AKA Protocol Registry (akap.me)\r\n *\r\n * @author Christian Felde\r\n * @author Mohamed Elshami\r\n *\r\n * @notice This interface defines basic meta data operations in addition to hashOf and claim functions on AKAP nodes.\r\n * @dev    Functionality related to the ERC-721 nature of nodes also available on AKAP, like transferFrom(..), etc.\r\n */\r\ncontract IAKAP {\r\n    enum ClaimCase {RECLAIM, NEW, TRANSFER}\r\n    enum NodeAttribute {EXPIRY, SEE_ALSO, SEE_ADDRESS, NODE_BODY, TOKEN_URI}\r\n\r\n    event Claim(address indexed sender, uint indexed nodeId, uint indexed parentId, bytes label, ClaimCase claimCase);\r\n    event AttributeChanged(address indexed sender, uint indexed nodeId, NodeAttribute attribute);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Calculate the hash of a parentId and node label.\r\n     *\r\n     * @param parentId Hash value of parent ID\r\n     * @param label Label of node\r\n     * @return Hash ID of node\r\n     */\r\n    function hashOf(uint parentId, bytes memory label) public pure returns (uint id);\r\n\r\n    /**\r\n     * @dev Claim or reclaim a node identified by the given parent ID hash and node label.\r\n     *\r\n     * There are 4 potential return value outcomes:\r\n     *\r\n     * 0: No action taken. This is the default if msg.sender does not have permission to act on the specified node.\r\n     * 1: An existing node already owned by msg.sender was reclaimed.\r\n     * 2: Node did not previously exist and is now minted and allocated to msg.sender.\r\n     * 3: An existing node already exist but was expired. Node ownership transferred to msg.sender.\r\n     *\r\n     * If msg.sender is not the owner but is instead approved \"spender\" of node, the same logic applies. Only on\r\n     * case 2 and 3 does msg.sender become owner of the node. On case 1 only the expiry is updated.\r\n     *\r\n     * Whenever the return value is non-zero, the expiry of the node has been set to 52 weeks into the future.\r\n     *\r\n     * @param parentId Hash value of parent ID\r\n     * @param label Label of node\r\n     * @return Returns one of the above 4 outcomes\r\n     */\r\n    function claim(uint parentId, bytes calldata label) external returns (uint status);\r\n\r\n    /**\r\n     * @dev Returns true if nodeId exists.\r\n     *\r\n     * @param nodeId Node hash ID\r\n     * @return True if node exists\r\n     */\r\n    function exists(uint nodeId) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Returns whether msg.sender can transfer, claim or operate on a given node ID.\r\n     *\r\n     * @param nodeId Node hash ID\r\n     * @return bool True if approved or owner\r\n     */\r\n    function isApprovedOrOwner(uint nodeId) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Gets the owner of the specified node ID.\r\n     *\r\n     * @param tokenId Node hash ID\r\n     * @return address Node owner address\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address);\r\n\r\n    /**\r\n     * @dev Return parent hash ID for given node ID.\r\n     *\r\n     * @param nodeId Node hash ID\r\n     * @return Parent hash ID\r\n     */\r\n    function parentOf(uint nodeId) external view returns (uint);\r\n\r\n    /**\r\n     * @dev Return expiry timestamp for given node ID.\r\n     *\r\n     * @param nodeId Node hash ID\r\n     * @return Expiry timestamp as seconds since unix epoch\r\n     */\r\n    function expiryOf(uint nodeId) external view returns (uint);\r\n\r\n    /**\r\n     * @dev Return \"see also\" value for given node ID.\r\n     *\r\n     * @param nodeId Node hash ID\r\n     * @return \"See also\" value\r\n     */\r\n    function seeAlso(uint nodeId) external view returns (uint);\r\n\r\n    /**\r\n     * @dev Return \"see address\" value for given node ID.\r\n     *\r\n     * @param nodeId Node hash ID\r\n     * @return \"See address\" value\r\n     */\r\n    function seeAddress(uint nodeId) external view returns (address);\r\n\r\n    /**\r\n     * @dev Return \"node body\" value for given node ID.\r\n     *\r\n     * @param nodeId Node hash ID\r\n     * @return \"Node body\" value\r\n     */\r\n    function nodeBody(uint nodeId) external view returns (bytes memory);\r\n\r\n    /**\r\n     * @dev Return \"token URI\" value for given node ID.\r\n     *\r\n     * @param tokenId Node hash ID\r\n     * @return \"Token URI\" value\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Will immediately expire node on given node ID.\r\n     *\r\n     * An expired node will continue to function as any other node,\r\n     * but is now available to be claimed by a new owner.\r\n     *\r\n     * @param nodeId Node hash ID\r\n     */\r\n    function expireNode(uint nodeId) external;\r\n\r\n    /**\r\n     * @dev Set \"see also\" value on given node ID.\r\n     *\r\n     * @param nodeId Node hash ID\r\n     * @param value New \"see also\" value\r\n     */\r\n    function setSeeAlso(uint nodeId, uint value) external;\r\n\r\n    /**\r\n     * @dev Set \"see address\" value on given node ID.\r\n     *\r\n     * @param nodeId Node hash ID\r\n     * @param value New \"see address\" value\r\n     */\r\n    function setSeeAddress(uint nodeId, address value) external;\r\n\r\n    /**\r\n     * @dev Set \"node body\" value on given node ID.\r\n     *\r\n     * @param nodeId Node hash ID\r\n     * @param value New \"node body\" value\r\n     */\r\n    function setNodeBody(uint nodeId, bytes calldata value) external;\r\n\r\n    /**\r\n     * @dev Set \"token URI\" value on given node ID.\r\n     *\r\n     * @param nodeId Node hash ID\r\n     * @param uri New \"token URI\" value\r\n     */\r\n    function setTokenURI(uint nodeId, string calldata uri) external;\r\n\r\n    /**\r\n     * @dev Approves another address to transfer the given token ID\r\n     *\r\n     * The zero address indicates there is no approved address.\r\n     * There can only be one approved address per token at a given time.\r\n     * Can only be called by the token owner or an approved operator.\r\n     *\r\n     * @param to address to be approved for the given token ID\r\n     * @param tokenId uint256 ID of the token to be approved\r\n     */\r\n    function approve(address to, uint256 tokenId) public;\r\n\r\n    /**\r\n     * @dev Gets the approved address for a token ID, or zero if no address set\r\n     *\r\n     * Reverts if the token ID does not exist.\r\n     *\r\n     * @param tokenId uint256 ID of the token to query the approval of\r\n     * @return address currently approved for the given token ID\r\n     */\r\n    function getApproved(uint256 tokenId) public view returns (address);\r\n\r\n    /**\r\n     * @dev Sets or unsets the approval of a given operator\r\n     *\r\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\r\n     *\r\n     * @param to operator address to set the approval\r\n     * @param approved representing the status of the approval to be set\r\n     */\r\n    function setApprovalForAll(address to, bool approved) public;\r\n\r\n    /**\r\n     * @dev Tells whether an operator is approved by a given owner.\r\n     *\r\n     * @param owner owner address which you want to query the approval of\r\n     * @param operator operator address which you want to query the approval of\r\n     * @return bool whether the given operator is approved by the given owner\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers the ownership of a given token ID to another address.\r\n     *\r\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible.\r\n     * Requires the msg.sender to be the owner, approved, or operator.\r\n     *\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     *\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     *\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     *\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     *\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public;\r\n}\r\n\r\n// File: @openzeppelin/contracts/introspection/IERC165.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of NFTs in `owner`'s account.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the NFT specified by `tokenId`.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     *\r\n     *\r\n     * Requirements:\r\n     * - `from`, `to` cannot be zero.\r\n     * - `tokenId` must be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this\r\n     * NFT by either {approve} or {setApprovalForAll}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Requirements:\r\n     * - If the caller is not `from`, it must be approved to move this NFT by\r\n     * either {approve} or {setApprovalForAll}.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n// File: akap-utils/contracts/domain/IDomainManager.sol\r\n\r\n// Copyright (C) 2020  Christian Felde\r\n\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n\r\n// http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\ncontract IDomainManager {\r\n    function akap() public view returns (IAKAP);\r\n\r\n    function erc721() public view returns (IERC721);\r\n\r\n    function domainParent() public view returns (uint);\r\n\r\n    function domainLabel() public view returns (bytes memory);\r\n\r\n    function domain() public view returns (uint);\r\n\r\n    function setApprovalForAll(address to, bool approved) public;\r\n\r\n    function claim(bytes memory label) public returns (uint status);\r\n\r\n    function claim(uint parentId, bytes memory label) public returns (uint);\r\n\r\n    function reclaim() public returns (uint);\r\n}\r\n\r\n// File: akap-utils/contracts/upgradable/AkaProxy.sol\r\n\r\n// Copyright (C) 2020  Christian Felde\r\n\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n\r\n// http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\ncontract AkaProxy {\r\n    IDomainManager public dm;\r\n    IAKAP public akap;\r\n    uint public rootPtr;\r\n\r\n    constructor(address _dmAddress, uint _rootPtr) public {\r\n        dm = IDomainManager(_dmAddress);\r\n        akap = dm.akap();\r\n        rootPtr = _rootPtr;\r\n\r\n        require(akap.exists(rootPtr), \"AkaProxy: No root node\");\r\n    }\r\n\r\n    function () payable external {\r\n        address implementationAddress = akap.seeAddress(rootPtr);\r\n        require(implementationAddress != address(0), \"AkaProxy: No root node address\");\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize)\r\n            let result := delegatecall(gas, implementationAddress, ptr, calldatasize, 0, 0)\r\n            let size := returndatasize\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dmAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rootPtr\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"akap\",\"outputs\":[{\"internalType\":\"contract IAKAP\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dm\",\"outputs\":[{\"internalType\":\"contract IDomainManager\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rootPtr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AkaProxy","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a465781563d38e4d34421aff7aaaab6ff716c7521b2950c867bf6c4b13dd6b546a73cc83fdcfd34d03cf630f594e7a0f35606065","Library":"","LicenseType":"Apache-2.0","SwarmSource":"bzzr://e6a4ba0e205dc9c7946ecf196ff9912c3b37b64165a5742d04181a8e20c49e8d"}]}