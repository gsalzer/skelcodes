{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-04-20\r\n*/\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC1155 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/1155\r\n */\r\n\r\ninterface IERC1155 /* is ERC165 */ {\r\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\r\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n    event URI(string _value, uint256 indexed _id);\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;\r\n\r\n    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\r\n\r\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\r\n\r\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\ninterface ERC1155TokenReceiver {\r\n\r\n    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external returns(bytes4);\r\n\r\n    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);\r\n}\r\n\r\ncontract CommonConstants {\r\n    bytes4 constant internal ERC1155_ACCEPTED = 0xf23a6e61; \r\n    bytes4 constant internal ERC1155_BATCH_ACCEPTED = 0xbc197c81; \r\n    bytes4 constant internal FAILURE = 0x00000000; \r\n}\r\n\r\ncontract ElevateSwap is ERC1155TokenReceiver, CommonConstants {\r\n  enum PaymentState {\r\n    Uninitialized,\r\n    PaymentSent,\r\n    ReceivedSpent,\r\n    SenderRefunded\r\n  }\r\n\r\n  struct Payment {\r\n    bytes20 paymentHash;\r\n    uint64 lockTime;\r\n    PaymentState state;\r\n  }\r\n\r\n  mapping (bytes32 => Payment) public payments;\r\n \r\n  event PaymentSent(bytes32 id);\r\n  event ReceiverSpent(bytes32 id, bytes32 secret);\r\n  event SenderRefunded(bytes32 id);\r\n\r\n  constructor() public { }\r\n\r\n  function ethPayment(\r\n    bytes32 _id,\r\n    address _receiver,\r\n    bytes20 _secretHash,\r\n    uint64 _lockTime\r\n  ) external payable {\r\n    require(_receiver != address(0) && msg.value > 0 && payments[_id].state == PaymentState.Uninitialized);\r\n\r\n    bytes20 paymentHash = ripemd160(abi.encodePacked(\r\n      _receiver,\r\n      msg.sender,\r\n      _secretHash,\r\n      address(0),\r\n      msg.value,\r\n      uint256(0)\r\n    ));\r\n\r\n    payments[_id] = Payment(\r\n      paymentHash,\r\n      _lockTime,\r\n      PaymentState.PaymentSent\r\n    );\r\n\r\n    emit PaymentSent(_id);\r\n  }\r\n\r\n  function erc20Payment(\r\n    bytes32 _id,\r\n    uint256 _amount,\r\n    address _tokenAddress,\r\n    address _receiver,\r\n    bytes20 _secretHash,\r\n    uint64 _lockTime\r\n  ) external payable {\r\n    require(_receiver != address(0) && _amount > 0 && payments[_id].state == PaymentState.Uninitialized);\r\n\r\n    bytes20 paymentHash = ripemd160(abi.encodePacked(\r\n      _receiver,\r\n      msg.sender,\r\n      _secretHash,\r\n      _tokenAddress,\r\n      _amount,\r\n      uint256(0)\r\n    ));\r\n\r\n    payments[_id] = Payment(\r\n      paymentHash,\r\n      _lockTime,\r\n      PaymentState.PaymentSent\r\n    );\r\n\r\n    IERC20 token = IERC20(_tokenAddress);\r\n    require(token.transferFrom(msg.sender, address(this), _amount));\r\n    emit PaymentSent(_id);\r\n  }\r\n\r\n  function erc1155Payment(\r\n    bytes32 _id,\r\n    uint256 _tokenId,\r\n    uint256 _amount,\r\n    address _tokenAddress,\r\n    address _receiver,\r\n    bytes20 _secretHash,\r\n    uint64 _lockTime\r\n  ) external payable {\r\n    require(_receiver != address(0) && _amount > 0 && _tokenId > 0 && payments[_id].state == PaymentState.Uninitialized);\r\n\r\n    bytes20 paymentHash = ripemd160(abi.encodePacked(\r\n      _receiver,\r\n      msg.sender,\r\n      _secretHash,\r\n      _tokenAddress,\r\n      _amount,\r\n      _tokenId\r\n    ));\r\n\r\n    payments[_id] = Payment(\r\n      paymentHash,\r\n      _lockTime,\r\n      PaymentState.PaymentSent\r\n    );\r\n\r\n    IERC1155 token = IERC1155(_tokenAddress);\r\n    token.safeTransferFrom(msg.sender, address(this), _tokenId, _amount, bytes(msg.data));\r\n    emit PaymentSent(_id);\r\n  }\r\n\r\n  function receiverSpend(\r\n    bytes32 _id,\r\n    uint256 _amount,\r\n    bytes32 _secret,\r\n    address _tokenAddress,\r\n    address _sender,\r\n    uint256 _tokenId\r\n  ) external {\r\n    require(payments[_id].state == PaymentState.PaymentSent);\r\n\r\n    bytes20 paymentHash = ripemd160(abi.encodePacked(\r\n      msg.sender,\r\n      _sender,\r\n      ripemd160(abi.encodePacked(sha256(abi.encodePacked(_secret)))),\r\n      _tokenAddress,\r\n      _amount,\r\n      _tokenId\r\n    ));\r\n\r\n    require(paymentHash == payments[_id].paymentHash && now < payments[_id].lockTime);\r\n    payments[_id].state = PaymentState.ReceivedSpent;\r\n    if (_tokenAddress == address(0)) {\r\n      msg.sender.transfer(_amount);\r\n    } else if(_tokenId > uint256(0)) {\r\n      IERC1155 token = IERC1155(_tokenAddress);\r\n      token.safeTransferFrom(address(this), msg.sender, _tokenId, _amount, bytes(msg.data));\r\n    } else {\r\n      IERC20 token = IERC20(_tokenAddress);\r\n      require(token.transfer(msg.sender, _amount));\r\n    }\r\n\r\n    emit ReceiverSpent(_id, _secret);\r\n  }\r\n\r\n  function senderRefund(\r\n      bytes32 _id,\r\n      uint256 _amount,\r\n      bytes20 _paymentHash,\r\n      address _tokenAddress,\r\n      address _receiver,\r\n      uint256 _tokenId\r\n  ) external {\r\n    require(payments[_id].state == PaymentState.PaymentSent);\r\n\r\n    bytes20 paymentHash = ripemd160(abi.encodePacked(\r\n      _receiver,\r\n      msg.sender,\r\n      _paymentHash,\r\n      _tokenAddress,\r\n      _amount,\r\n      _tokenId\r\n    ));\r\n\r\n    require(paymentHash == payments[_id].paymentHash && now >= payments[_id].lockTime);\r\n\r\n    payments[_id].state = PaymentState.SenderRefunded;\r\n\r\n    if (_tokenAddress == address(0)) {\r\n      msg.sender.transfer(_amount);\r\n    } else if(_tokenId > uint256(0)) {\r\n      IERC1155 token = IERC1155(_tokenAddress);\r\n      token.safeTransferFrom(address(this), msg.sender, _tokenId, _amount, bytes(msg.data));\r\n    } else {\r\n      IERC20 token = IERC20(_tokenAddress);\r\n      require(token.transfer(msg.sender, _amount));\r\n    }\r\n\r\n    emit SenderRefunded(_id);\r\n  }\r\n\r\n  function onERC1155Received(\r\n     address _operator, \r\n     address _from, \r\n     uint256 _id, \r\n     uint256 _value, \r\n     bytes calldata _data\r\n  ) external returns(bytes4){\r\n    if(_operator == msg.sender && _value > 0){\r\n        return 0xf23a6e61;\r\n      //return ERC1155_ACCEPTED;\r\n      \r\n    }\r\n    return 0xf23a6e61;\r\n    //return FAILURE;\r\n    //return ERC1155_ACCEPTED;\r\n  }\r\n\r\n  function onERC1155BatchReceived(\r\n    address _operator, \r\n    address _from, \r\n    uint256[] calldata _ids, \r\n    uint256[] calldata _values, \r\n    bytes calldata _data\r\n  ) external returns(bytes4) {\r\n    if(_operator == msg.sender ){\r\n      return ERC1155_BATCH_ACCEPTED;\r\n    }\r\n    //return FAILURE;\r\n    return ERC1155_BATCH_ACCEPTED;\r\n  }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"PaymentSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"ReceiverSpent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"SenderRefunded\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"bytes20\",\"name\":\"_secretHash\",\"type\":\"bytes20\"},{\"internalType\":\"uint64\",\"name\":\"_lockTime\",\"type\":\"uint64\"}],\"name\":\"erc1155Payment\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"bytes20\",\"name\":\"_secretHash\",\"type\":\"bytes20\"},{\"internalType\":\"uint64\",\"name\":\"_lockTime\",\"type\":\"uint64\"}],\"name\":\"erc20Payment\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"bytes20\",\"name\":\"_secretHash\",\"type\":\"bytes20\"},{\"internalType\":\"uint64\",\"name\":\"_lockTime\",\"type\":\"uint64\"}],\"name\":\"ethPayment\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"payments\",\"outputs\":[{\"internalType\":\"bytes20\",\"name\":\"paymentHash\",\"type\":\"bytes20\"},{\"internalType\":\"uint64\",\"name\":\"lockTime\",\"type\":\"uint64\"},{\"internalType\":\"enum ElevateSwap.PaymentState\",\"name\":\"state\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_secret\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"receiverSpend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes20\",\"name\":\"_paymentHash\",\"type\":\"bytes20\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"senderRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ElevateSwap","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://86eaf229bc0d6ce8ea55170e54de9780b32c35a8a3384ed328f883ca9f0ff63d"}]}