{"status":"1","message":"OK","result":[{"SourceCode":"contract ERC20():\r\n    def transfer(_to: address, _value: uint256) -> bool: modifying\r\n    def transferFrom(_from: address, _to: address, _value: uint256) -> bool: modifying\r\n    def balanceOf(_owner: address) -> uint256: constant\r\n    def allowance(_owner: address, _spender: address) -> uint256: constant\r\n    def decimals() -> uint256: constant\r\n\r\ncontract PriceOracle():\r\n    def poolSize(contract_address: address) -> uint256: constant\r\n    def normalized_token_prices(token_address: address) -> uint256: constant\r\n\r\nTOKEN_PRICE_MULTIPLIER: constant(uint256) = 100000000\r\nFEE_MULTIPLIER: constant(uint256) = 100000\r\nEXCHANGE_RATE_MULTIPLIER: constant(uint256) = 10000000000000000000000 #10**22\r\n\r\n# ERC20 events\r\nTransfer: event({_from: indexed(address), _to: indexed(address), _value: uint256})\r\nApproval: event({_owner: indexed(address), _spender: indexed(address), _value: uint256})\r\n\r\nOwnershipTransferred: event({previous_owner: indexed(address), new_owner: indexed(address)})\r\nLiquidityAdded: event({provider: indexed(address), amount: indexed(uint256)})\r\nLiquidityRemoved: event({provider: indexed(address), amount: indexed(uint256)})\r\nTrade: event({input_token: indexed(address), output_token: indexed(address), input_amount: indexed(uint256)})\r\nPermissionUpdated: event({name: indexed(string[32]), value: indexed(bool)})\r\nFeeUpdated: event({name: indexed(string[32]), value: indexed(decimal)})\r\nPriceOracleAddressUpdated: event({new_address: indexed(address)})\r\n\r\nname: public(string[32])                                 # Stablecoinswap\r\nsymbol: public(string[6])                                # STL\r\nowner: public(address)                                   # contract owner\r\ndecimals: public(uint256)                                # 18\r\ntotalSupply: public(uint256)                             # total number of contract tokens in existence\r\nbalanceOf: public(map(address, uint256))                 # balance of an address\r\nallowance: public(map(address, map(address, uint256)))   # allowance of one address on another\r\ninputTokens: public(map(address, bool))                  # addresses of the ERC20 tokens allowed to transfer into this contract\r\noutputTokens: public(map(address, bool))                 # addresses of the ERC20 tokens allowed to transfer out of this contract\r\npermissions: public(map(string[32], bool))               # pause / resume contract functions\r\nfeesInt: map(string[32], uint256)                        # trade / pool fees multiplied by FEE_MULTIPLIER\r\npriceOracleAddress: public(address)                      # address of price oracle\r\n\r\n@public\r\ndef __init__(token_addresses: address[3], price_oracle_addr: address):\r\n    assert price_oracle_addr != ZERO_ADDRESS\r\n\r\n    self.owner = msg.sender\r\n    self.name = \"Stablecoinswap\"\r\n    self.symbol = \"STL\"\r\n    self.decimals = 18\r\n    self.permissions[\"tradingAllowed\"] = True\r\n    self.permissions[\"liquidityAddingAllowed\"] = True\r\n\r\n    for i in range(3):\r\n        assert token_addresses[i] != ZERO_ADDRESS\r\n        self.inputTokens[token_addresses[i]] = True\r\n        self.outputTokens[token_addresses[i]] = True\r\n\r\n    self.feesInt['tradeFee'] = 200\r\n    self.feesInt['ownerFee'] = 100\r\n\r\n    self.priceOracleAddress = price_oracle_addr\r\n\r\n@private\r\n@constant\r\ndef tokenPrice(token_address: address) -> uint256:\r\n    token_price: uint256 = PriceOracle(self.priceOracleAddress).normalized_token_prices(token_address)\r\n    assert token_price > 0\r\n\r\n    return token_price\r\n\r\n# Required to support tokens (such s USDT) which don't provide a return value for transfer functions\r\n@private\r\ndef transferAndCheck(token: address, recipient: address, amount: uint256) -> bool:\r\n    self_balance: uint256 = ERC20(token).balanceOf(self)\r\n    recipient_balance: uint256 = ERC20(token).balanceOf(recipient)\r\n    ERC20(token).transfer(recipient, amount)\r\n    new_self_balance: uint256 = ERC20(token).balanceOf(self)\r\n    new_recipient_balance: uint256 = ERC20(token).balanceOf(recipient)\r\n\r\n    assert new_recipient_balance == (recipient_balance + amount)\r\n    assert new_self_balance == (self_balance - amount)\r\n\r\n    return True\r\n\r\n# Required to support tokens (such s USDT) which don't provide a return value for transfer functions\r\n@private\r\ndef transferFromAndCheck(token: address, sender: address, recipient: address, amount: uint256) -> bool:\r\n    recipient_balance: uint256 = ERC20(token).balanceOf(recipient)\r\n    sender_balance: uint256 = ERC20(token).balanceOf(sender)\r\n    ERC20(token).transferFrom(sender, recipient, amount)\r\n    new_recipient_balance: uint256 = ERC20(token).balanceOf(recipient)\r\n    new_sender_balance: uint256 = ERC20(token).balanceOf(sender)\r\n\r\n    assert new_sender_balance == (sender_balance - amount)\r\n    assert new_recipient_balance == (recipient_balance + amount)\r\n\r\n    return True\r\n\r\n# Deposit erc20 token\r\n@public\r\n@nonreentrant('lock')\r\ndef addLiquidity(token_address: address, erc20_token_amount: uint256, deadline: timestamp) -> uint256:\r\n    assert self.inputTokens[token_address]\r\n    assert deadline > block.timestamp and erc20_token_amount > 0\r\n    assert self.permissions[\"liquidityAddingAllowed\"]\r\n\r\n    token_price: uint256 = self.tokenPrice(token_address)\r\n    # It's better to divide at the very end for a higher precision\r\n    new_liquidity: uint256 = token_price * erc20_token_amount / TOKEN_PRICE_MULTIPLIER\r\n    if self.totalSupply > 0:\r\n        new_liquidity = new_liquidity * self.totalSupply / PriceOracle(self.priceOracleAddress).poolSize(self)\r\n    else:\r\n        assert new_liquidity >= 1000000000\r\n\r\n    self.balanceOf[msg.sender] += new_liquidity\r\n    self.totalSupply += new_liquidity\r\n\r\n    # Can't assert the result directly: https://github.com/ethereum/vyper/issues/1468\r\n    transfer_from_result: bool = self.transferFromAndCheck(token_address, msg.sender, self, erc20_token_amount)\r\n    assert transfer_from_result\r\n\r\n    log.LiquidityAdded(msg.sender, new_liquidity)\r\n\r\n    return new_liquidity\r\n\r\n# Withdraw erc20 token\r\n@public\r\n@nonreentrant('lock')\r\ndef removeLiquidity(token_address: address, stableswap_token_amount: uint256, erc20_min_output_amount: uint256, deadline: timestamp) -> uint256:\r\n    assert self.outputTokens[token_address]\r\n    assert stableswap_token_amount > 0 and deadline > block.timestamp\r\n    assert self.balanceOf[msg.sender] >= stableswap_token_amount\r\n    assert self.totalSupply > 0\r\n\r\n    token_price: uint256 = self.tokenPrice(token_address)\r\n    pool_size: uint256 = PriceOracle(self.priceOracleAddress).poolSize(self)\r\n    # erc20_token_amount = stableswap_token_amount * pool_size / totalSupply / token_price * TOKEN_PRICE_MULTIPLIER\r\n    # It's better to divide at the very end for a higher precision\r\n    erc20_token_amount: uint256 = stableswap_token_amount * pool_size / self.totalSupply\r\n\r\n    ownerFee: uint256 = 0\r\n\r\n    if msg.sender != self.owner:\r\n        ownerFee = stableswap_token_amount * self.feesInt['ownerFee'] / FEE_MULTIPLIER\r\n        multiplier_after_fees: uint256 = FEE_MULTIPLIER - self.feesInt['ownerFee'] - self.feesInt['tradeFee']\r\n        erc20_token_amount = erc20_token_amount * multiplier_after_fees / FEE_MULTIPLIER\r\n\r\n    erc20_token_amount = erc20_token_amount * TOKEN_PRICE_MULTIPLIER / token_price\r\n\r\n    self.balanceOf[msg.sender] -= stableswap_token_amount\r\n    self.balanceOf[self.owner] += ownerFee\r\n    self.totalSupply -= stableswap_token_amount - ownerFee\r\n\r\n    assert erc20_token_amount >= erc20_min_output_amount\r\n\r\n    # Can't assert the result directly: https://github.com/ethereum/vyper/issues/1468\r\n    transfer_result: bool = self.transferAndCheck(token_address, msg.sender, erc20_token_amount)\r\n    assert transfer_result\r\n\r\n    log.LiquidityRemoved(msg.sender, stableswap_token_amount)\r\n\r\n    return erc20_token_amount\r\n\r\n# Note that due to rounding, the fees could be slightly higher for the tokens with smaller decimal precision.\r\n@public\r\n@constant\r\ndef tokenExchangeRateAfterFees(input_token_address: address, output_token_address: address) -> uint256:\r\n    input_token_price: uint256 = self.tokenPrice(input_token_address)\r\n    output_token_price: uint256 = self.tokenPrice(output_token_address)\r\n\r\n    multiplier_after_fees: uint256 = FEE_MULTIPLIER - self.feesInt['ownerFee'] - self.feesInt['tradeFee']\r\n    exchange_rate: uint256 = EXCHANGE_RATE_MULTIPLIER * input_token_price * multiplier_after_fees / FEE_MULTIPLIER / output_token_price\r\n\r\n    return exchange_rate\r\n\r\n@public\r\n@constant\r\ndef tokenOutputAmountAfterFees(input_token_amount: uint256, input_token_address: address, output_token_address: address) -> uint256:\r\n    output_token_amount: uint256 = input_token_amount * self.tokenExchangeRateAfterFees(input_token_address, output_token_address) / EXCHANGE_RATE_MULTIPLIER\r\n    return output_token_amount\r\n\r\n# Trade one erc20 token for another\r\n@public\r\n@nonreentrant('lock')\r\ndef swapTokens(input_token: address, output_token: address, erc20_input_amount: uint256, erc20_min_output_amount: uint256, deadline: timestamp) -> uint256:\r\n    assert self.inputTokens[input_token] and self.outputTokens[output_token]\r\n    assert erc20_input_amount > 0 and erc20_min_output_amount > 0\r\n    assert deadline > block.timestamp\r\n    assert self.permissions[\"tradingAllowed\"]\r\n\r\n    input_token_price: uint256 = self.tokenPrice(input_token)\r\n    # input_usd_value is a value of input multiplied by TOKEN_PRICE_MULTIPLIER\r\n    input_usd_value: uint256 = erc20_input_amount * input_token_price\r\n    tradeFee: uint256 = input_usd_value * self.feesInt['tradeFee'] / FEE_MULTIPLIER / TOKEN_PRICE_MULTIPLIER\r\n    ownerFee: uint256 = input_usd_value * self.feesInt['ownerFee'] / FEE_MULTIPLIER / TOKEN_PRICE_MULTIPLIER\r\n\r\n    pool_size_after_swap: uint256 = PriceOracle(self.priceOracleAddress).poolSize(self) + tradeFee\r\n    new_owner_shares: uint256 = self.totalSupply * ownerFee / pool_size_after_swap\r\n\r\n    erc20_output_amount: uint256 = self.tokenOutputAmountAfterFees(erc20_input_amount, input_token, output_token)\r\n    assert erc20_output_amount >= erc20_min_output_amount\r\n\r\n    self.balanceOf[self.owner] += new_owner_shares\r\n    self.totalSupply += new_owner_shares\r\n\r\n    # Can't assert the result directly: https://github.com/ethereum/vyper/issues/1468\r\n    transfer_from_result: bool = self.transferFromAndCheck(input_token, msg.sender, self, erc20_input_amount)\r\n    assert transfer_from_result\r\n\r\n    transfer_result: bool = self.transferAndCheck(output_token, msg.sender, erc20_output_amount)\r\n    assert transfer_result\r\n\r\n    log.Trade(input_token, output_token, erc20_input_amount)\r\n\r\n    return erc20_output_amount\r\n\r\n@public\r\ndef updateInputToken(token_address: address, allowed: bool) -> bool:\r\n    assert msg.sender == self.owner\r\n    assert not self.inputTokens[token_address] == allowed\r\n    assert ERC20(token_address).decimals() >= 2\r\n    self.inputTokens[token_address] = allowed\r\n    return True\r\n\r\n@public\r\ndef updateOutputToken(token_address: address, allowed: bool) -> bool:\r\n    assert msg.sender == self.owner\r\n    assert not self.outputTokens[token_address] == allowed\r\n    assert ERC20(token_address).decimals() >= 2\r\n    self.outputTokens[token_address] = allowed\r\n    return True\r\n\r\n@public\r\ndef updatePermission(permission_name: string[32], value: bool) -> bool:\r\n    assert msg.sender == self.owner\r\n    self.permissions[permission_name] = value\r\n    log.PermissionUpdated(permission_name, value)\r\n    return True\r\n\r\n# Return share of total liquidity belonging to the user\r\n@public\r\n@constant\r\ndef poolOwnership(user_address: address) -> decimal:\r\n    user_balance: decimal = convert(self.balanceOf[user_address], decimal)\r\n    total_liquidity: decimal = convert(self.totalSupply, decimal)\r\n    share: decimal = user_balance / total_liquidity\r\n    return share\r\n\r\n@public\r\ndef transferOwnership(new_owner: address) -> bool:\r\n    assert new_owner != ZERO_ADDRESS\r\n    assert msg.sender == self.owner\r\n    self.owner = new_owner\r\n    log.OwnershipTransferred(self.owner, new_owner)\r\n    return True\r\n\r\n@public\r\ndef updateFee(fee_name: string[32], value: decimal) -> bool:\r\n    assert msg.sender == self.owner\r\n    self.feesInt[fee_name] = convert(floor(value * convert(FEE_MULTIPLIER, decimal)), uint256)\r\n    log.FeeUpdated(fee_name, value)\r\n    return True\r\n\r\n@public\r\n@constant\r\ndef fees(fee_name: string[32]) -> decimal:\r\n    return convert(self.feesInt[fee_name], decimal) / convert(FEE_MULTIPLIER, decimal)\r\n\r\n@public\r\ndef updatePriceOracleAddress(new_address: address) -> bool:\r\n    assert msg.sender == self.owner\r\n    self.priceOracleAddress = new_address\r\n    log.PriceOracleAddressUpdated(new_address)\r\n    return True\r\n\r\n# ERC-20 functions\r\n\r\n@public\r\ndef transfer(_to: address, _value: uint256) -> bool:\r\n    self.balanceOf[msg.sender] -= _value\r\n    self.balanceOf[_to] += _value\r\n    log.Transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n@public\r\ndef transferFrom(_from: address, _to: address, _value: uint256) -> bool:\r\n    self.balanceOf[_from] -= _value\r\n    self.balanceOf[_to] += _value\r\n    self.allowance[_from][msg.sender] -= _value\r\n    log.Transfer(_from, _to, _value)\r\n    return True\r\n\r\n@public\r\ndef approve(_spender: address, _value: uint256) -> bool:\r\n    self.allowance[msg.sender][_spender] = _value\r\n    log.Approval(msg.sender, msg.sender, _value)\r\n    return True","ABI":"[{\"name\":\"Transfer\",\"inputs\":[{\"type\":\"address\",\"name\":\"_from\",\"indexed\":true},{\"type\":\"address\",\"name\":\"_to\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"_value\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"type\":\"address\",\"name\":\"_owner\",\"indexed\":true},{\"type\":\"address\",\"name\":\"_spender\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"_value\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"OwnershipTransferred\",\"inputs\":[{\"type\":\"address\",\"name\":\"previous_owner\",\"indexed\":true},{\"type\":\"address\",\"name\":\"new_owner\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"LiquidityAdded\",\"inputs\":[{\"type\":\"address\",\"name\":\"provider\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"amount\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"LiquidityRemoved\",\"inputs\":[{\"type\":\"address\",\"name\":\"provider\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"amount\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Trade\",\"inputs\":[{\"type\":\"address\",\"name\":\"input_token\",\"indexed\":true},{\"type\":\"address\",\"name\":\"output_token\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"input_amount\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PermissionUpdated\",\"inputs\":[{\"type\":\"string32\",\"name\":\"name\",\"indexed\":true},{\"type\":\"bool\",\"name\":\"value\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"FeeUpdated\",\"inputs\":[{\"type\":\"string32\",\"name\":\"name\",\"indexed\":true},{\"type\":\"fixed168x10\",\"name\":\"value\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PriceOracleAddressUpdated\",\"inputs\":[{\"type\":\"address\",\"name\":\"new_address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"address[3]\",\"name\":\"token_addresses\"},{\"type\":\"address\",\"name\":\"price_oracle_addr\"}],\"constant\":false,\"payable\":false,\"type\":\"constructor\"},{\"name\":\"addLiquidity\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"token_address\"},{\"type\":\"uint256\",\"name\":\"erc20_token_amount\"},{\"type\":\"uint256\",\"unit\":\"sec\",\"name\":\"deadline\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":163453},{\"name\":\"removeLiquidity\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"token_address\"},{\"type\":\"uint256\",\"name\":\"stableswap_token_amount\"},{\"type\":\"uint256\",\"name\":\"erc20_min_output_amount\"},{\"type\":\"uint256\",\"unit\":\"sec\",\"name\":\"deadline\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":204477},{\"name\":\"tokenExchangeRateAfterFees\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"input_token_address\"},{\"type\":\"address\",\"name\":\"output_token_address\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":9561},{\"name\":\"tokenOutputAmountAfterFees\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"input_token_amount\"},{\"type\":\"address\",\"name\":\"input_token_address\"},{\"type\":\"address\",\"name\":\"output_token_address\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":16010},{\"name\":\"swapTokens\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"input_token\"},{\"type\":\"address\",\"name\":\"output_token\"},{\"type\":\"uint256\",\"name\":\"erc20_input_amount\"},{\"type\":\"uint256\",\"name\":\"erc20_min_output_amount\"},{\"type\":\"uint256\",\"unit\":\"sec\",\"name\":\"deadline\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":207255},{\"name\":\"updateInputToken\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"token_address\"},{\"type\":\"bool\",\"name\":\"allowed\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":37682},{\"name\":\"updateOutputToken\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"token_address\"},{\"type\":\"bool\",\"name\":\"allowed\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":37712},{\"name\":\"updatePermission\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"string\",\"name\":\"permission_name\"},{\"type\":\"bool\",\"name\":\"value\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":37929},{\"name\":\"poolOwnership\",\"outputs\":[{\"type\":\"fixed168x10\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"user_address\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1507},{\"name\":\"transferOwnership\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"new_owner\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":37829},{\"name\":\"updateFee\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"string\",\"name\":\"fee_name\"},{\"type\":\"fixed168x10\",\"name\":\"value\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":37983},{\"name\":\"fees\",\"outputs\":[{\"type\":\"fixed168x10\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"string\",\"name\":\"fee_name\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1481},{\"name\":\"updatePriceOracleAddress\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"new_address\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":37244},{\"name\":\"transfer\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":74500},{\"name\":\"transferFrom\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":110367},{\"name\":\"approve\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_spender\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":38231},{\"name\":\"name\",\"outputs\":[{\"type\":\"string\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":6882},{\"name\":\"symbol\",\"outputs\":[{\"type\":\"string\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":3038},{\"name\":\"owner\",\"outputs\":[{\"type\":\"address\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1143},{\"name\":\"decimals\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1173},{\"name\":\"totalSupply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1203},{\"name\":\"balanceOf\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1387},{\"name\":\"allowance\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"},{\"type\":\"address\",\"name\":\"arg1\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1571},{\"name\":\"inputTokens\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1447},{\"name\":\"outputTokens\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1477},{\"name\":\"permissions\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"string\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1650},{\"name\":\"priceOracleAddress\",\"outputs\":[{\"type\":\"address\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1383}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.1.0b11","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000c12d1c73ee7dc3615ba4e37e4abfdbddfa38907e000000000000000000000000efe076de83ccf27bc893002439dec13f93564e84","Library":"","LicenseType":"None","SwarmSource":""}]}