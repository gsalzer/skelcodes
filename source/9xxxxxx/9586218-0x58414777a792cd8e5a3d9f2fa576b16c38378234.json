{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.16;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n\n\n/// @title Registry\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\n/// @notice This module provides a standard instance registry functionality.\ncontract Registry is Ownable {\n\n    enum FactoryStatus { Unregistered, Registered, Retired }\n\n    event FactoryAdded(address owner, address factory, uint256 factoryID, bytes extraData);\n    event FactoryRetired(address owner, address factory, uint256 factoryID);\n    event InstanceRegistered(address indexed instance, address indexed factory, address indexed creator, uint256 instanceIndex, uint256 factoryID);\n\n    address[] private _factoryList;\n    mapping(address => Factory) private _factoryData;\n\n    struct Factory {\n        FactoryStatus status;\n        uint16 factoryID;\n        bytes extraData;\n    }\n\n    bytes4 private _instanceType;\n    Instance[] private _instances;\n\n    struct Instance {\n        address instance;\n        uint16 factoryID;\n        uint80 extraData;\n    }\n\n    constructor(string memory instanceType) public {\n        _instanceType = bytes4(keccak256(bytes(instanceType)));\n    }\n\n    // factory state functions\n\n    /// @notice Add an instance factory to the registry. A factory must be added to the registry before it can create instances.\n    /// @param factory address of the factory to be added.\n    /// @param extraData bytes extra factory specific data that can be accessed publicly.\n    function addFactory(\n        address factory,\n        bytes calldata extraData\n    ) external onlyOwner() {\n        // get the factory object from storage.\n        Factory storage factoryData = _factoryData[factory];\n\n        // ensure that the provided factory is new.\n        require(\n            factoryData.status == FactoryStatus.Unregistered,\n            \"factory already exists at the provided factory address\"\n        );\n\n        // get the factoryID of the new factory.\n        uint16 factoryID = uint16(_factoryList.length);\n\n        // set all of the information for the new factory.\n        factoryData.status = FactoryStatus.Registered;\n        factoryData.factoryID = factoryID;\n        factoryData.extraData = extraData;\n\n        _factoryList.push(factory);\n\n        // emit an event.\n        emit FactoryAdded(msg.sender, factory, factoryID, extraData);\n    }\n\n    /// @notice Remove an instance factory from the registry. Once retired, a factory can no longer produce instances.\n    /// @param factory address of the factory to be removed.\n    function retireFactory(address factory) external onlyOwner() {\n        // get the factory object from storage.\n        Factory storage factoryData = _factoryData[factory];\n\n        // ensure that the provided factory is new and not already retired.\n        require(\n            factoryData.status == FactoryStatus.Registered,\n            \"factory is not currently registered\"\n        );\n\n        // retire the factory.\n        factoryData.status = FactoryStatus.Retired;\n\n        emit FactoryRetired(msg.sender, factory, factoryData.factoryID);\n    }\n\n    // factory view functions\n\n    function getFactoryCount() external view returns (uint256 count) {\n        return _factoryList.length;\n    }\n\n    function getFactoryStatus(address factory) external view returns (FactoryStatus status) {\n        return _factoryData[factory].status;\n    }\n\n    function getFactoryID(address factory) external view returns (uint16 factoryID) {\n        return _factoryData[factory].factoryID;\n    }\n\n    function getFactoryData(address factory) external view returns (bytes memory extraData) {\n        return _factoryData[factory].extraData;\n    }\n\n    function getFactoryAddress(uint16 factoryID) external view returns (address factory) {\n        return _factoryList[factoryID];\n    }\n\n    function getFactory(address factory) public view returns (\n        FactoryStatus status,\n        uint16 factoryID,\n        bytes memory extraData\n    ) {\n        Factory memory factoryData = _factoryData[factory];\n        return (factoryData.status, factoryData.factoryID, factoryData.extraData);\n    }\n\n    function getFactories() external view returns (address[] memory factories) {\n        return _factoryList;\n    }\n\n    // Note: startIndex is inclusive, endIndex exclusive\n    function getPaginatedFactories(uint256 startIndex, uint256 endIndex) external view returns (address[] memory factories) {\n        require(startIndex < endIndex, \"startIndex must be less than endIndex\");\n        require(endIndex <= _factoryList.length, \"end index out of range\");\n\n        // initialize fixed size memory array\n        address[] memory range = new address[](endIndex - startIndex);\n\n        // Populate array with addresses in range\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            range[i - startIndex] = _factoryList[i];\n        }\n\n        // return array of addresses\n        return range;\n    }\n\n    // instance state functions\n\n    function register(address instance, address creator, uint80 extraData) external {\n        (\n            FactoryStatus status,\n            uint16 factoryID,\n            // bytes memory extraData\n        ) = getFactory(msg.sender);\n\n        // ensure that the caller is a registered factory\n        require(\n            status == FactoryStatus.Registered,\n            \"factory in wrong status\"\n        );\n\n        uint256 instanceIndex = _instances.length;\n        _instances.push(\n            Instance({\n                instance: instance,\n                factoryID: factoryID,\n                extraData: extraData\n            })\n        );\n\n        emit InstanceRegistered(instance, msg.sender, creator, instanceIndex, factoryID);\n    }\n\n    // instance view functions\n\n    function getInstanceType() external view returns (bytes4 instanceType) {\n        return _instanceType;\n    }\n\n    function getInstanceCount() external view returns (uint256 count) {\n        return _instances.length;\n    }\n\n    function getInstance(uint256 index) external view returns (address instance) {\n        require(index < _instances.length, \"index out of range\");\n        return _instances[index].instance;\n    }\n\n    function getInstanceData(uint256 index) external view returns (\n        address instanceAddress,\n        uint16 factoryID,\n        uint80 extraData\n    ) {\n\n        require(index < _instances.length, \"index out of range\");\n\n        Instance memory instance = _instances[index];\n        return (instance.instance, instance.factoryID, instance.extraData);\n    }\n\n    function getInstances() external view returns (address[] memory instances) {\n        uint256 length = _instances.length;\n        address[] memory addresses = new address[](length);\n\n        // Populate array with addresses in range\n        for (uint256 i = 0; i < length; i++) {\n            addresses[i] = _instances[i].instance;\n        }\n        return addresses;\n    }\n\n    // Note: startIndex is inclusive, endIndex exclusive\n    function getPaginatedInstances(uint256 startIndex, uint256 endIndex) external view returns (address[] memory instances) {\n        require(startIndex < endIndex, \"startIndex must be less than endIndex\");\n        require(endIndex <= _instances.length, \"end index out of range\");\n\n        // initialize fixed size memory array\n        address[] memory range = new address[](endIndex - startIndex);\n\n        // Populate array with addresses in range\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            range[i - startIndex] = _instances[i].instance;\n        }\n\n        // return array of addresses\n        return range;\n    }\n}\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an owner and a manager that can be granted exclusive access to\n * specific functions.\n */\ncontract Manageable is Ownable {\n    address private _manager;\n\n    event ManagementTransferred(address indexed previousManager, address indexed newManager);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial manager.\n     */\n    constructor () internal Ownable() {\n        _manager = _msgSender();\n        emit ManagementTransferred(address(0), _manager);\n    }\n\n    /**\n     * @return the address of the manager.\n     */\n    function manager() public view returns (address) {\n        return _manager;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner or manager.\n     */\n    modifier onlyManagerOrOwner() {\n        require(isManagerOrOwner(), \"Manageable: caller is not the manager or owner\");\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner or manager of the contract.\n     */\n    function isManagerOrOwner() public view returns (bool) {\n        return (_msgSender() == _manager || isOwner());\n    }\n\n    /**\n     * @dev Leaves the contract without manager. Owner will need to set a new manager.\n     * Can only be called by the current owner or manager.\n     */\n    function renounceManagement() public onlyManagerOrOwner {\n        emit ManagementTransferred(_manager, address(0));\n        _manager = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newManager.\n     * Can only be called by the current owner.\n     * @param newManager The address to transfer management to.\n     */\n    function transferManagement(address newManager) public onlyOwner {\n        require(newManager != address(0), \"Manageable: new manager is the zero address\");\n        emit ManagementTransferred(_manager, newManager);\n        _manager = newManager;\n    }\n}\n\n\n/// @title RegistryManager\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\n/// @notice This module allows for managing instance registries.\ncontract RegistryManager is Manageable {\n    \n    /// @notice Add an instance factory to the registry.\n    /// @param registry address of the target registry.\n    /// @param factory address of the factory to be added.\n    /// @param extraData bytes extra factory specific data that can be accessed publicly.\n    function addFactory(\n        address registry,\n        address factory,\n        bytes calldata extraData\n    ) external onlyManagerOrOwner() {\n        Registry(registry).addFactory(factory, extraData);\n    }\n    \n    /// @notice Remove an instance factory from the registry.\n    /// @param registry address of the target registry.\n    /// @param factory address of the factory to be removed.\n    function retireFactory(\n        address registry,\n        address factory\n    ) external onlyManagerOrOwner() {\n        Registry(registry).retireFactory(factory);\n    }\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagementTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"addFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isManagerOrOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceManagement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"retireFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"transferManagement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RegistryManager","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":""}]}