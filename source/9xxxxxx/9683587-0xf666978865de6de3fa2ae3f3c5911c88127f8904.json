{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.14;\r\n\r\ncontract SwapProxyInterface {\r\n    function name() public view returns(string memory);\r\n    function getSwapQuantity(address src, address dst, uint256 srcQty) public view returns(uint256);\r\n    function getSwapRate(address src, address dst, uint256 srcQty) public view returns(uint256);\r\n    function executeSwap(address srcToken, uint256 srcQty, address dstToken, address dstAddress) public returns(bool);\r\n}\r\n\r\ncontract ERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function decimals() public view returns(uint);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n}\r\n\r\ncontract Auction {\r\n    function bidAndWithdraw(address _rebalancingSetToken, uint256 _quantity, bool _allowPartialFill) external;\r\n}\r\n\r\n\r\ncontract AdminRole {\r\n\r\n    mapping (address => bool) adminGroup;\r\n    address payable owner;\r\n\r\n    constructor () public {\r\n        adminGroup[msg.sender] = true;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(\r\n            isAdmin(msg.sender),\r\n            \"The caller is not Admin\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(\r\n            owner == msg.sender,\r\n            \"The caller is not Owner\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function addAdmin(address addr) external onlyAdmin {\r\n        adminGroup[addr] = true;\r\n    }\r\n    function delAdmin(address addr) external onlyAdmin {\r\n        adminGroup[addr] = false;\r\n    }\r\n\r\n    function isAdmin(address addr) public view returns(bool) {\r\n        return adminGroup[addr];\r\n    }\r\n\r\n    function kill() external onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n}\r\n\r\ncontract Withdrawable is AdminRole {\r\n    /*\r\n     * External Function to withdraw funds -> Gas or Tokens\r\n     */\r\n    function withdrawTo (address payable dst, uint funds, address token) external onlyAdmin {\r\n        if (token == address(0))\r\n            require (address(this).balance >= funds);\r\n        else {\r\n            ERC20 erc20 = ERC20(token);\r\n            require (erc20.balanceOf(address(this)) >= funds);\r\n        }\r\n        sendFunds(dst,funds, token);\r\n    }\r\n\r\n    /*\r\n     * Function to send funds -> Gas or Tokens\r\n     */\r\n    function sendFunds(address payable dst, uint amount, address token) internal returns(bool) {\r\n        ERC20 erc20;\r\n        if (token == address(0))\r\n            require(address(dst).send(amount), \"Impossible send funds\");\r\n        else {\r\n            erc20 = ERC20(token);\r\n            require(erc20.transfer(dst, amount), \"Impossible send funds\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract GasReserve {\r\n    uint256[] g;\r\n\r\n    event GasReport(\r\n        uint256 total_gas_consumed,\r\n        uint256 words_used\r\n    );\r\n\r\n    function reserveGas(uint256 quantity) public {\r\n        if (quantity != 0)\r\n            reserve(quantity);\r\n    }\r\n\r\n    function gasWordsQuantity() external view returns(uint256) {\r\n        return g.length;\r\n    }\r\n\r\n    function useGas(uint256 start_gas) internal {\r\n        uint256 consumed_gas = start_gas - gasleft();\r\n        uint256 words = consumed_gas/25000;\r\n        releaseGas(words);\r\n        emit GasReport(consumed_gas,words);\r\n    }\r\n\r\n    function releaseGas(uint256 quantity) internal {\r\n        if (g.length!=0) {\r\n            if (quantity <= g.length)\r\n                release(quantity);\r\n            else\r\n                release(g.length);\r\n        }\r\n    }\r\n\r\n    function getReserveAddr () private pure returns(uint256 reserve) {\r\n        uint256 gaddr;\r\n        assembly {\r\n            gaddr := g_slot\r\n        }\r\n        return uint256(keccak256(abi.encode(gaddr)));\r\n    }\r\n\r\n    function reserve(uint256 quantity) private {\r\n        uint256 len = g.length;\r\n        uint256 start = getReserveAddr() + len;\r\n        uint256 end = start + quantity;\r\n\r\n        len = len + quantity;\r\n\r\n        for (uint256 i = start; i < end; i ++) {\r\n            assembly {\r\n                sstore(i,1)\r\n            }\r\n        }\r\n        assembly {\r\n            sstore(g_slot, len)\r\n        }\r\n    }\r\n\r\n    function release(uint256 quantity) private {\r\n        uint256 len = g.length;\r\n        uint256 start = getReserveAddr() + (len - quantity);\r\n        uint256 end = getReserveAddr() + len;\r\n\r\n        len = len - quantity;\r\n \r\n        for (uint256 i = start; i < end; i++) {\r\n            assembly {\r\n                sstore(i,0)\r\n            }\r\n        }\r\n        assembly {\r\n            sstore(g_slot, len)\r\n        }\r\n    }\r\n}\r\n\r\ncontract Swapper is Withdrawable, GasReserve {\r\n\r\n    event TokenSwapped(address indexed srcToken, address indexed dstToken, string swapProxy);\r\n\r\n    address[10] swapProxy;\r\n    uint256 swapProxySize = 0;\r\n\r\n    function addSwapProxy (address addr) external onlyAdmin {\r\n        require(swapProxySize < 10, \"Max SwapProxy has reatched\");\r\n\r\n        for (uint256 i; i < 10; i++ ) {\r\n            if (swapProxy[i] == address(0)) {\r\n                swapProxy[i] = addr;\r\n                swapProxySize = swapProxySize + 1;\r\n                return;\r\n            }\r\n        }\r\n        revert(\"Unable to found free slot\");\r\n    }\r\n\r\n    function delSwapProxy(address addr) external onlyAdmin {\r\n        for (uint256 i; i < 10; i++ ) {\r\n            if (swapProxy[i] == addr) {\r\n                swapProxy[i] = address(0);\r\n                swapProxySize = swapProxySize - 1;\r\n                return;\r\n            }\r\n        }\r\n        revert(\"Unable to found a proxy\");\r\n    }\r\n\r\n    function getBestSwapRate(address src, address dst, uint256 srcQty) external view\r\n        returns (string memory name, uint256 rate, uint256 index)\r\n    {\r\n        SwapProxyInterface spi;\r\n\r\n        /**\r\n         * Si no existe nigun swap proxy\r\n         */\r\n        if (swapProxySize == 0)\r\n            return (name,rate,index);\r\n\r\n        (index, rate) = getBestRate(src,dst,srcQty);\r\n\r\n        if (rate != 0) {\r\n            spi = SwapProxyInterface(swapProxy[index]);\r\n            name = spi.name();\r\n        }\r\n    }\r\n\r\n    function TokenSwapOnBest(address srcToken, uint256 srcQty, address dstToken, address dstAddress, bool useReserveOfGas) external {\r\n        uint256 start_gas = gasleft();\r\n\r\n        ERC20 token = ERC20(srcToken);\r\n        require(token.transferFrom(msg.sender, address(this), srcQty), \"Unable to transferFrom()\");\r\n\r\n        swapOnBest(srcToken, srcQty, dstToken, dstAddress);\r\n\r\n        if (useReserveOfGas) {\r\n            if (isAdmin(msg.sender)) {\r\n                useGas(start_gas);\r\n            }\r\n        }\r\n    }\r\n\r\n    function TokenSwapOn(uint256 dex, address srcToken, uint256 srcQty, address dstToken, address dstAddress, bool useReserveOfGas) external {\r\n        uint256 start_gas = gasleft();\r\n\r\n        ERC20 token = ERC20(srcToken);\r\n        require(token.transferFrom(msg.sender, address(this), srcQty), \"Unable to transferFrom()\");\r\n\r\n        swapOn(dex,srcToken, srcQty, dstToken, dstAddress);\r\n\r\n        if (useReserveOfGas) {\r\n            if (isAdmin(msg.sender)) {\r\n                useGas(start_gas);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getBestRate(address src, address dst, uint256 srcQty)\r\n        internal view returns(uint256 index, uint256 rate )\r\n    {\r\n        SwapProxyInterface spi;\r\n        uint256 tmp;\r\n        uint256 i;\r\n\r\n\r\n        for (i = 0; i < 10; i++) {\r\n            if (swapProxy[i] != address(0)) {\r\n                spi = SwapProxyInterface(swapProxy[i]);\r\n                tmp = spi.getSwapRate(src,dst,srcQty);\r\n                if (tmp > rate) {\r\n                    rate = tmp;\r\n                    index = i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function swapOnBest(address srcToken, uint256 srcQty, address dstToken, address dstAddress)\r\n        internal returns(bool)\r\n    {\r\n        SwapProxyInterface spi;\r\n        ERC20 token = ERC20(srcToken);\r\n        uint256 index;\r\n        uint256 rate;\r\n\r\n        require(swapProxySize != 0, \"Unable to found a configured swap\");\r\n\r\n        (index,rate) = getBestRate(srcToken,dstToken,srcQty);\r\n\r\n        require(rate != 0, \"Unable to found a valid rate\");\r\n\r\n        // Set the spender's token allowance to tokenQty\r\n        require(token.approve(swapProxy[index], srcQty), \"Unable to appove()\");\r\n\r\n        spi = SwapProxyInterface(swapProxy[index]);\r\n\r\n        require(spi.executeSwap(srcToken,srcQty,dstToken,dstAddress), \"Unable to executeSwap\");\r\n\r\n        emit TokenSwapped(srcToken,dstToken,spi.name());\r\n\r\n        return true;\r\n    }\r\n\r\n    function swapOn(uint256 dex, address srcToken, uint256 srcQty, address dstToken, address dstAddress)\r\n        internal returns(bool)\r\n    {\r\n        SwapProxyInterface spi;\r\n        ERC20 token = ERC20(srcToken);\r\n\r\n        require(swapProxySize != 0 && swapProxy[dex] != address(0), \"Unable to found a swap identified by dex\");\r\n\r\n        // Set the spender's token allowance to tokenQty\r\n        require(token.approve(swapProxy[dex], srcQty), \"Unable to appove()\");\r\n\r\n        spi = SwapProxyInterface(swapProxy[dex]);\r\n\r\n        require(spi.executeSwap(srcToken,srcQty,dstToken,dstAddress), \"Unable to executeSwap\");\r\n\r\n        emit TokenSwapped(srcToken,dstToken,spi.name());\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\ncontract Bidder is Swapper {\r\n    address public transferProxy = 0x882d80D3a191859d64477eb78Cca46599307ec1C;\r\n    Auction auction = Auction(0xe23FB31dD2edacEbF7d92720358bB92445F47fDB);\r\n\r\n    function bidAndSwapOnBest(address tokenset, uint256 inflow, uint256 minimumBid, uint256 srcQty, address src, address dst, bool useReserveOfGas)\r\n        external\r\n    {\r\n        uint256 start_gas = gasleft();\r\n        uint256 quantity;\r\n        ERC20 srcToken = ERC20(src);\r\n        ERC20 dstToken = ERC20(dst);\r\n        uint256 dst_startBalance = dstToken.balanceOf(address(this));\r\n        uint256 src_startBalance = srcToken.balanceOf(address(this));\r\n        uint256 src_finalBalance;\r\n\r\n        /**\r\n         * 1- Traemos los fondos para poder participar de la subasta\r\n         */\r\n        require(srcToken.transferFrom(msg.sender,address(this),srcQty), \"Unable to transferFrom()\");\r\n\r\n        /**\r\n         * 2- Habilitamos el approve al transfer proxy si no esta habilitado\r\n         */\r\n        require(srcToken.approve(transferProxy,srcQty), \"Unable to approve\");\r\n\r\n        /**\r\n         * 3- Calculamos la cantidad para participar\r\n         */\r\n\r\n        quantity = (srcQty / inflow) * minimumBid;\r\n        /**\r\n         * 4- Participamos en la subasta\r\n         */\r\n        auction.bidAndWithdraw(tokenset,quantity,true);\r\n\r\n        /**\r\n         * 5- En este punto debemos tener mas balance del dstToken y esa diferencia es la que tenemos que\r\n         *    intercambiar\r\n         */\r\n        swapOnBest(dst,dstToken.balanceOf(address(this))-dst_startBalance,src,address(this));\r\n\r\n        /**\r\n         * 6- Se captura el balance final del inflow token\r\n         */\r\n        src_finalBalance = srcToken.balanceOf(address(this));\r\n\r\n        /**\r\n         * 7- En este punto es facil saber si huvo ganancias y en caso de que el profit sea\r\n         *    nagativo hace un revert\r\n         */\r\n        require(src_startBalance + srcQty < src_finalBalance, \"Negative Profit\");\r\n\r\n        /**\r\n         * 8- Envia los fondos menos el balance inincial\r\n         */\r\n        sendFunds(msg.sender, src_finalBalance - src_startBalance, src);\r\n\r\n        /**\r\n         * 9- Libera Gas\r\n         */\r\n        if (useReserveOfGas) {\r\n            if (isAdmin(msg.sender)) {\r\n                useGas(start_gas);\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total_gas_consumed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"words_used\",\"type\":\"uint256\"}],\"name\":\"GasReport\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"swapProxy\",\"type\":\"string\"}],\"name\":\"TokenSwapped\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcQty\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"useReserveOfGas\",\"type\":\"bool\"}],\"name\":\"TokenSwapOn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcQty\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"useReserveOfGas\",\"type\":\"bool\"}],\"name\":\"TokenSwapOnBest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addSwapProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inflow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"srcQty\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"useReserveOfGas\",\"type\":\"bool\"}],\"name\":\"bidAndSwapOnBest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"delAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"delSwapProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasWordsQuantity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcQty\",\"type\":\"uint256\"}],\"name\":\"getBestSwapRate\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"reserveGas\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"funds\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Bidder","CompilerVersion":"v0.5.14+commit.1f1aaa4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://e6e7cbdab24dda494047444d08d85de210301397dc072712245f4fc17fdc770e"}]}