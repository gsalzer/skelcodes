{"status":"1","message":"OK","result":[{"SourceCode":"/**\n\nDeployed by Ren Project, https://renproject.io\n\nCommit hash: 9068f80\nRepository: https://github.com/renproject/darknode-sol\nIssues: https://github.com/renproject/darknode-sol/issues\n\nLicenses\n@openzeppelin/contracts: (MIT) https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/LICENSE\ndarknode-sol: (GNU GPL V3) https://github.com/renproject/darknode-sol/blob/master/LICENSE\n\n*/\n\npragma solidity 0.5.16;\n\n\ncontract Initializable {\n\n  \n  bool private initialized;\n\n  \n  bool private initializing;\n\n  \n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  \n  function isConstructor() private view returns (bool) {\n    \n    \n    \n    \n    \n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  \n  uint256[50] private ______gap;\n}\n\ncontract IRelayRecipient {\n    \n    function getHubAddr() public view returns (address);\n\n    \n    function acceptRelayedCall(\n        address relay,\n        address from,\n        bytes calldata encodedFunction,\n        uint256 transactionFee,\n        uint256 gasPrice,\n        uint256 gasLimit,\n        uint256 nonce,\n        bytes calldata approvalData,\n        uint256 maxPossibleCharge\n    )\n        external\n        view\n        returns (uint256, bytes memory);\n\n    \n    function preRelayedCall(bytes calldata context) external returns (bytes32);\n\n    \n    function postRelayedCall(bytes calldata context, bool success, uint256 actualCharge, bytes32 preRetVal) external;\n}\n\ncontract IRelayHub {\n    \n\n    \n    function stake(address relayaddr, uint256 unstakeDelay) external payable;\n\n    \n    event Staked(address indexed relay, uint256 stake, uint256 unstakeDelay);\n\n    \n    function registerRelay(uint256 transactionFee, string memory url) public;\n\n    \n    event RelayAdded(address indexed relay, address indexed owner, uint256 transactionFee, uint256 stake, uint256 unstakeDelay, string url);\n\n    \n    function removeRelayByOwner(address relay) public;\n\n    \n    event RelayRemoved(address indexed relay, uint256 unstakeTime);\n\n    \n    function unstake(address relay) public;\n\n    \n    event Unstaked(address indexed relay, uint256 stake);\n\n    \n    enum RelayState {\n        Unknown, \n        Staked, \n        Registered, \n        Removed    \n    }\n\n    \n    function getRelay(address relay) external view returns (uint256 totalStake, uint256 unstakeDelay, uint256 unstakeTime, address payable owner, RelayState state);\n\n    \n\n    \n    function depositFor(address target) public payable;\n\n    \n    event Deposited(address indexed recipient, address indexed from, uint256 amount);\n\n    \n    function balanceOf(address target) external view returns (uint256);\n\n    \n    function withdraw(uint256 amount, address payable dest) public;\n\n    \n    event Withdrawn(address indexed account, address indexed dest, uint256 amount);\n\n    \n\n    \n    function canRelay(\n        address relay,\n        address from,\n        address to,\n        bytes memory encodedFunction,\n        uint256 transactionFee,\n        uint256 gasPrice,\n        uint256 gasLimit,\n        uint256 nonce,\n        bytes memory signature,\n        bytes memory approvalData\n    ) public view returns (uint256 status, bytes memory recipientContext);\n\n    \n    enum PreconditionCheck {\n        OK,                         \n        WrongSignature,             \n        WrongNonce,                 \n        AcceptRelayedCallReverted,  \n        InvalidRecipientStatusCode  \n    }\n\n    \n    function relayCall(\n        address from,\n        address to,\n        bytes memory encodedFunction,\n        uint256 transactionFee,\n        uint256 gasPrice,\n        uint256 gasLimit,\n        uint256 nonce,\n        bytes memory signature,\n        bytes memory approvalData\n    ) public;\n\n    \n    event CanRelayFailed(address indexed relay, address indexed from, address indexed to, bytes4 selector, uint256 reason);\n\n    \n    event TransactionRelayed(address indexed relay, address indexed from, address indexed to, bytes4 selector, RelayCallStatus status, uint256 charge);\n\n    \n    enum RelayCallStatus {\n        OK,                      \n        RelayedCallFailed,       \n        PreRelayedFailed,        \n        PostRelayedFailed,       \n        RecipientBalanceChanged  \n    }\n\n    \n    function requiredGas(uint256 relayedCallStipend) public view returns (uint256);\n\n    \n    function maxPossibleCharge(uint256 relayedCallStipend, uint256 gasPrice, uint256 transactionFee) public view returns (uint256);\n\n     \n     \n    \n    \n\n    \n    function penalizeRepeatedNonce(bytes memory unsignedTx1, bytes memory signature1, bytes memory unsignedTx2, bytes memory signature2) public;\n\n    \n    function penalizeIllegalTransaction(bytes memory unsignedTx, bytes memory signature) public;\n\n    \n    event Penalized(address indexed relay, address sender, uint256 amount);\n\n    \n    function getNonce(address from) external view returns (uint256);\n}\n\ncontract Context is Initializable {\n    \n    \n    constructor () internal { }\n    \n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; \n        return msg.data;\n    }\n}\n\ncontract GSNRecipient is Initializable, IRelayRecipient, Context {\n    function initialize() public initializer {\n        if (_relayHub == address(0)) {\n            setDefaultRelayHub();\n        }\n    }\n\n    function setDefaultRelayHub() public {\n        _upgradeRelayHub(0xD216153c06E857cD7f72665E0aF1d7D82172F494);\n    }\n\n    \n    address private _relayHub;\n\n    uint256 constant private RELAYED_CALL_ACCEPTED = 0;\n    uint256 constant private RELAYED_CALL_REJECTED = 11;\n\n    \n    uint256 constant internal POST_RELAYED_CALL_MAX_GAS = 100000;\n\n    \n    event RelayHubChanged(address indexed oldRelayHub, address indexed newRelayHub);\n\n    \n    function getHubAddr() public view returns (address) {\n        return _relayHub;\n    }\n\n    \n    function _upgradeRelayHub(address newRelayHub) internal {\n        address currentRelayHub = _relayHub;\n        require(newRelayHub != address(0), \"GSNRecipient: new RelayHub is the zero address\");\n        require(newRelayHub != currentRelayHub, \"GSNRecipient: new RelayHub is the current one\");\n\n        emit RelayHubChanged(currentRelayHub, newRelayHub);\n\n        _relayHub = newRelayHub;\n    }\n\n    \n    \n    \n    function relayHubVersion() public view returns (string memory) {\n        this; \n        return \"1.0.0\";\n    }\n\n    \n    function _withdrawDeposits(uint256 amount, address payable payee) internal {\n        IRelayHub(_relayHub).withdraw(amount, payee);\n    }\n\n    \n    \n    \n    \n\n    \n    function _msgSender() internal view returns (address payable) {\n        if (msg.sender != _relayHub) {\n            return msg.sender;\n        } else {\n            return _getRelayedCallSender();\n        }\n    }\n\n    \n    function _msgData() internal view returns (bytes memory) {\n        if (msg.sender != _relayHub) {\n            return msg.data;\n        } else {\n            return _getRelayedCallData();\n        }\n    }\n\n    \n    \n\n    \n    function preRelayedCall(bytes calldata context) external returns (bytes32) {\n        require(msg.sender == getHubAddr(), \"GSNRecipient: caller is not RelayHub\");\n        return _preRelayedCall(context);\n    }\n\n    \n    function _preRelayedCall(bytes memory context) internal returns (bytes32);\n\n    \n    function postRelayedCall(bytes calldata context, bool success, uint256 actualCharge, bytes32 preRetVal) external {\n        require(msg.sender == getHubAddr(), \"GSNRecipient: caller is not RelayHub\");\n        _postRelayedCall(context, success, actualCharge, preRetVal);\n    }\n\n    \n    function _postRelayedCall(bytes memory context, bool success, uint256 actualCharge, bytes32 preRetVal) internal;\n\n    \n    function _approveRelayedCall() internal pure returns (uint256, bytes memory) {\n        return _approveRelayedCall(\"\");\n    }\n\n    \n    function _approveRelayedCall(bytes memory context) internal pure returns (uint256, bytes memory) {\n        return (RELAYED_CALL_ACCEPTED, context);\n    }\n\n    \n    function _rejectRelayedCall(uint256 errorCode) internal pure returns (uint256, bytes memory) {\n        return (RELAYED_CALL_REJECTED + errorCode, \"\");\n    }\n\n    \n    function _computeCharge(uint256 gas, uint256 gasPrice, uint256 serviceFee) internal pure returns (uint256) {\n        \n        \n        return (gas * gasPrice * (100 + serviceFee)) / 100;\n    }\n\n    function _getRelayedCallSender() private pure returns (address payable result) {\n        \n        \n        \n        \n        \n\n        \n        \n\n        \n        bytes memory array = msg.data;\n        uint256 index = msg.data.length;\n\n        \n        assembly {\n            \n            result := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n        return result;\n    }\n\n    function _getRelayedCallData() private pure returns (bytes memory) {\n        \n        \n\n        uint256 actualDataLength = msg.data.length - 20;\n        bytes memory actualData = new bytes(actualDataLength);\n\n        for (uint256 i = 0; i < actualDataLength; ++i) {\n            actualData[i] = msg.data[i];\n        }\n\n        return actualData;\n    }\n}\n\ninterface IMintGateway {\n    function mint(\n        bytes32 _pHash,\n        uint256 _amount,\n        bytes32 _nHash,\n        bytes calldata _sig\n    ) external returns (uint256);\n    function mintFee() external view returns (uint256);\n}\n\ninterface IBurnGateway {\n    function burn(bytes calldata _to, uint256 _amountScaled)\n        external\n        returns (uint256);\n    function burnFee() external view returns (uint256);\n}\n\ninterface IGateway {\n    \n    function mint(\n        bytes32 _pHash,\n        uint256 _amount,\n        bytes32 _nHash,\n        bytes calldata _sig\n    ) external returns (uint256);\n    function mintFee() external view returns (uint256);\n    \n    function burn(bytes calldata _to, uint256 _amountScaled)\n        external\n        returns (uint256);\n    function burnFee() external view returns (uint256);\n}\n\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n\n    \n    function balanceOf(address account) external view returns (uint256);\n\n    \n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IGatewayRegistry {\n    \n    \n    event LogGatewayRegistered(\n        string _symbol,\n        string indexed _indexedSymbol,\n        address indexed _tokenAddress,\n        address indexed _gatewayAddress\n    );\n    event LogGatewayDeregistered(\n        string _symbol,\n        string indexed _indexedSymbol,\n        address indexed _tokenAddress,\n        address indexed _gatewayAddress\n    );\n    event LogGatewayUpdated(\n        address indexed _tokenAddress,\n        address indexed _currentGatewayAddress,\n        address indexed _newGatewayAddress\n    );\n\n    \n    function getGateways(address _start, uint256 _count)\n        external\n        view\n        returns (address[] memory);\n\n    \n    function getRenTokens(address _start, uint256 _count)\n        external\n        view\n        returns (address[] memory);\n\n    \n    \n    \n    \n    function getGatewayByToken(address _tokenAddress)\n        external\n        view\n        returns (IGateway);\n\n    \n    \n    \n    \n    function getGatewayBySymbol(string calldata _tokenSymbol)\n        external\n        view\n        returns (IGateway);\n\n    \n    \n    \n    \n    function getTokenBySymbol(string calldata _tokenSymbol)\n        external\n        view\n        returns (IERC20);\n}\n\ncontract BasicAdapter is GSNRecipient {\n    IGatewayRegistry registry;\n\n    constructor(IGatewayRegistry _registry) public {\n        GSNRecipient.initialize();\n        registry = _registry;\n    }\n\n    function mint(\n        \n        string calldata _symbol,\n        address _recipient,\n        \n        uint256 _amount,\n        bytes32 _nHash,\n        bytes calldata _sig\n    ) external {\n        bytes32 payloadHash = keccak256(abi.encode(_symbol, _recipient));\n        uint256 amount = registry.getGatewayBySymbol(_symbol).mint(\n            payloadHash,\n            _amount,\n            _nHash,\n            _sig\n        );\n        registry.getTokenBySymbol(_symbol).transfer(_recipient, amount);\n    }\n\n    function burn(string calldata _symbol, bytes calldata _to, uint256 _amount)\n        external\n    {\n        require(\n            registry.getTokenBySymbol(_symbol).transferFrom(\n                _msgSender(),\n                address(this),\n                _amount\n            ),\n            \"token transfer failed\"\n        );\n        registry.getGatewayBySymbol(_symbol).burn(_to, _amount);\n    }\n\n    \n\n    function acceptRelayedCall(\n        address relay,\n        address from,\n        bytes calldata encodedFunction,\n        uint256 transactionFee,\n        uint256 gasPrice,\n        uint256 gasLimit,\n        uint256 nonce,\n        bytes calldata approvalData,\n        uint256 maxPossibleCharge\n    ) external view returns (uint256, bytes memory) {\n        return _approveRelayedCall();\n    }\n\n    \n    function _preRelayedCall(bytes memory context) internal returns (bytes32) {}\n\n    function _postRelayedCall(\n        bytes memory context,\n        bool,\n        uint256 actualCharge,\n        bytes32\n    ) internal {}\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IGatewayRegistry\",\"name\":\"_registry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldRelayHub\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRelayHub\",\"type\":\"address\"}],\"name\":\"RelayHubChanged\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"relay\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"encodedFunction\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"transactionFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"approvalData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"maxPossibleCharge\",\"type\":\"uint256\"}],\"name\":\"acceptRelayedCall\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_to\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHubAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_nHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"actualCharge\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"preRetVal\",\"type\":\"bytes32\"}],\"name\":\"postRelayedCall\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"}],\"name\":\"preRelayedCall\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"relayHubVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setDefaultRelayHub\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BasicAdapter","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e80d347df1209a76dd9d2319d62912ba98c54ddd","Library":"","LicenseType":"","SwarmSource":""}]}