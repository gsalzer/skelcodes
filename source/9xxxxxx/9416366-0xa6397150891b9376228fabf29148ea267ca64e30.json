{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >0.4.99 <0.6.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0);\r\n        // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address payable private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor(address payable newOwner) public {\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address payable) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address payable newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address payable newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract TicketsStorage is Ownable {\r\n    using SafeMath for uint;\r\n\r\n    struct Ticket {\r\n        address payable wallet;\r\n        uint investment;\r\n        uint stakeAmount;\r\n        uint stake;\r\n        uint happyNumber;\r\n        uint8[] percentArray;\r\n        address payable ownerWallet;\r\n    }\r\n\r\n    mapping(address => mapping(uint => Ticket)) private tickets;\r\n    // adrress of contract -> round -> Ticket\r\n\r\n    mapping(address => mapping(bytes32 => uint)) numberTicket;\r\n    // adrress of contract -> hash -> Ticket\r\n\r\n    mapping(address => bool) private parentContract;\r\n    //address of contract -> bool\r\n    mapping(address => bool) private whitelist;\r\n    //address of contract -> bool\r\n\r\n    event FindedNumber(address indexed requestor, uint reqValue, uint findValue);\r\n\r\n\r\n    modifier onlyParentContract {\r\n        require(parentContract[msg.sender] || isOwner(), \"onlyParentContract methods called by non - parent of contract.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhitelist {\r\n        require(whitelist[msg.sender] || isOwner(), \"only whitelist contract methods called by non - parent of contract.\");\r\n        _;\r\n    }\r\n\r\n    constructor() public\r\n    Ownable(msg.sender)\r\n    { }\r\n\r\n    function save(address _contract, uint _round, address payable _wallet, uint _investment, uint _stake) public onlyWhitelist {\r\n        Ticket storage ticket = tickets[_contract][_round];\r\n        ticket.wallet = _wallet;\r\n        ticket.investment = _investment;\r\n        ticket.stake = _stake;\r\n    }\r\n\r\n    function saveHash(address _contract, bytes32 _hash, uint _round) public onlyWhitelist {\r\n        numberTicket[_contract][_hash] = _round;\r\n    }\r\n\r\n    function update(address _contract, uint _round, uint _stakeAmount, uint _happyNumber) public onlyWhitelist {\r\n        Ticket storage ticket = tickets[_contract][_round];\r\n        ticket.stakeAmount = _stakeAmount;\r\n        ticket.happyNumber = _happyNumber;\r\n    }\r\n\r\n    function ticketInfo(address _contract, uint round) public view returns (\r\n        address payable _wallet,\r\n        uint _investment,\r\n        uint _stakeAmount,\r\n        uint _stake,\r\n        uint _happyNumber\r\n    ) {\r\n        Ticket memory ticket = tickets[_contract][round];\r\n        _wallet = ticket.wallet;\r\n        _investment = ticket.investment;\r\n        _stakeAmount = ticket.stakeAmount;\r\n        _stake = ticket.stake;\r\n        _happyNumber = ticket.happyNumber;\r\n    }\r\n\r\n    function numberTicketFromHash(address _contract, bytes32 _hash) public view returns (uint) {\r\n        return numberTicket[_contract][_hash];\r\n    }\r\n\r\n    function findHappyNumber(uint step) public onlyWhitelist returns (uint) {\r\n        uint happyNumber = getRandomNumber(step);\r\n        emit FindedNumber(msg.sender, step, happyNumber);\r\n        return happyNumber;\r\n    }\r\n\r\n    function getRandomNumber(uint step) internal view returns (uint randomNumber) {\r\n        if (step > 0) {\r\n            uint numberOne = uint8(getByteByIndex(30, blockhash(block.number-1)));\r\n            uint numberTwo = uint8(getByteByIndex(29, blockhash(block.number-2)));\r\n            uint numberThree = uint8(getByteByIndex(28, blockhash(block.number-3)));\r\n            uint numberFor = uint8(getByteByIndex(10, blockhash(block.number-4)));\r\n            uint random = 0;\r\n            if (step < 5) {\r\n                random = numberTwo.add(numberFor).add(numberThree);\r\n            }\r\n            if (step >= 5 && step < 970000) {\r\n                random = numberOne.mul(numberTwo);\r\n                random = random.add(numberFor);\r\n                random = random.mul(numberThree).sub(numberFor);\r\n            }\r\n            if (step >= 970000 && step < 96000000) {\r\n                random = numberOne.mul(numberTwo).mul(numberFor);\r\n                random = random.add(numberFor);\r\n                random = random.mul(numberThree).sub(numberFor);\r\n            }\r\n            if (step >= 96000000) {\r\n                random = numberOne.mul(numberTwo).mul(numberFor);\r\n                random = random.mul(numberOne).add(numberFor);\r\n                random = random.mul(numberThree).mul(numberTwo).sub(numberFor);\r\n            }\r\n            randomNumber = random % step;\r\n            return randomNumber + 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function randomBytes(uint blockn, address entropyAddress) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(bytes32(blockn),entropyAddress));\r\n    }\r\n\r\n    function getByteByIndex(uint number, bytes32 strBytes) private pure returns (byte lastByte) {\r\n        require(number < 32 && number >= 0);\r\n        lastByte = strBytes[number];\r\n    }\r\n\r\n    function setWhitelist(address _contract, bool _status) onlyParentContract public {\r\n        whitelist[_contract] = _status;\r\n    }\r\n\r\n    function finish() external onlyOwner {\r\n        address payable __owner = owner();\r\n        selfdestruct(__owner);\r\n    }\r\n\r\n    function setParentContract(address _contract, bool _status) onlyOwner public {\r\n        parentContract[_contract] = _status;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requestor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reqValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"findValue\",\"type\":\"uint256\"}],\"name\":\"FindedNumber\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"step\",\"type\":\"uint256\"}],\"name\":\"findHappyNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finish\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"numberTicketFromHash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"entropyAddress\",\"type\":\"address\"}],\"name\":\"randomBytes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stake\",\"type\":\"uint256\"}],\"name\":\"save\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"saveHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setParentContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"ticketInfo\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_happyNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_happyNumber\",\"type\":\"uint256\"}],\"name\":\"update\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TicketsStorage","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"Unlicense","SwarmSource":"bzzr://4c3fa01ed2c499a039a6bc0f8809f0367cbd29dab4c81ac3e085ecf298c40289"}]}