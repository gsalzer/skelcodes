{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.10;\r\n\r\n/**\r\n * Copyright Â© 2017-2019 Ramp Network sp. z o.o. All rights reserved (MIT License).\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\r\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\r\n * including without limitation the rights to use, copy, modify, merge, publish, distribute,\r\n * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software\r\n * is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all copies\r\n * or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\r\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE\r\n * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n\r\ncontract AssetAdapter {\r\n\r\n    uint16 public ASSET_TYPE;\r\n\r\n    constructor(\r\n        uint16 assetType\r\n    ) internal {\r\n        ASSET_TYPE = assetType;\r\n    }\r\n\r\n    /**\r\n     * Ensure the described asset is sent to the given address.\r\n     * Should revert if the transfer failed, but callers must also handle `false` being returned,\r\n     * much like ERC-20's `transfer`.\r\n     */\r\n    function rawSendAsset(\r\n        bytes memory assetData,\r\n        uint256 _amount,\r\n        address payable _to\r\n    ) internal returns (bool success);  // solium-disable-line indentation\r\n    // indentation rule bug ^ https://github.com/duaraghav8/Ethlint/issues/268\r\n\r\n    /**\r\n     * Ensure the described asset is sent to this contract.\r\n     * Should revert if the transfer failed, but callers must also handle `false` being returned,\r\n     * much like ERC-20's `transfer`.\r\n     */\r\n    function rawLockAsset(\r\n        uint256 amount,\r\n        address payable _from\r\n    ) internal returns (bool success) {\r\n        return RampInstantPoolInterface(_from).sendFundsToSwap(amount);\r\n    }\r\n\r\n    function getAmount(bytes memory assetData) internal pure returns (uint256);\r\n\r\n    /**\r\n     * Verify that the passed asset data can be handled by this adapter and given pool.\r\n     *\r\n     * @dev it's sufficient to use this only when creating a new swap -- all the other swap\r\n     * functions first check if the swap hash is valid, while a swap hash with invalid\r\n     * asset type wouldn't be created at all.\r\n     *\r\n     * @dev asset type is 2 bytes long, and it's at offset 32 in `assetData`'s memory (the first 32\r\n     * bytes are the data length). We load the word at offset 2 (it ends with the asset type bytes),\r\n     * and retrieve its last 2 bytes into a `uint16` variable.\r\n     */\r\n    modifier checkAssetTypeAndData(bytes memory assetData, address _pool) {\r\n        uint16 assetType;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            assetType := and(\r\n                mload(add(assetData, 2)),\r\n                0xffff\r\n            )\r\n        }\r\n        require(assetType == ASSET_TYPE, \"invalid asset type\");\r\n        checkAssetData(assetData, _pool);\r\n        _;\r\n    }\r\n\r\n    function checkAssetData(bytes memory assetData, address _pool) internal view;\r\n\r\n    function () external payable {\r\n        revert(\"this contract cannot receive ether\");\r\n    }\r\n\r\n}\r\n\r\ncontract RampInstantPoolInterface {\r\n\r\n    uint16 public ASSET_TYPE;\r\n\r\n    function sendFundsToSwap(uint256 _amount)\r\n        public /*onlyActive onlySwapsContract isWithinLimits*/ returns(bool success);\r\n\r\n}\r\n\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n\r\n    constructor() internal {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only the owner can call this\");\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address _newOwner) external onlyOwner {\r\n        owner = _newOwner;\r\n        emit OwnerChanged(msg.sender, _newOwner);\r\n    }\r\n\r\n}\r\n\r\ncontract WithStatus is Ownable {\r\n\r\n    enum Status {\r\n        STOPPED,\r\n        RETURN_ONLY,\r\n        FINALIZE_ONLY,\r\n        ACTIVE\r\n    }\r\n\r\n    event StatusChanged(Status oldStatus, Status newStatus);\r\n\r\n    Status public status = Status.ACTIVE;\r\n\r\n    function setStatus(Status _status) external onlyOwner {\r\n        emit StatusChanged(status, _status);\r\n        status = _status;\r\n    }\r\n\r\n    modifier statusAtLeast(Status _status) {\r\n        require(status >= _status, \"invalid contract status\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\ncontract WithOracles is Ownable {\r\n\r\n    mapping (address => bool) oracles;\r\n\r\n    constructor() internal {\r\n        oracles[msg.sender] = true;\r\n    }\r\n\r\n    function approveOracle(address _oracle) external onlyOwner {\r\n        oracles[_oracle] = true;\r\n    }\r\n\r\n    function revokeOracle(address _oracle) external onlyOwner {\r\n        oracles[_oracle] = false;\r\n    }\r\n\r\n    modifier isOracle(address _oracle) {\r\n        require(oracles[_oracle], \"invalid oracle address\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOracleOrPool(address _pool, address _oracle) {\r\n        require(\r\n            msg.sender == _pool || (msg.sender == _oracle && oracles[msg.sender]),\r\n            \"only the oracle or the pool can call this\"\r\n        );\r\n        _;\r\n    }\r\n\r\n}\r\n\r\ncontract WithSwapsCreator is Ownable {\r\n\r\n    address internal swapCreator;\r\n\r\n    event SwapCreatorChanged(address _oldCreator, address _newCreator);\r\n\r\n    constructor() internal {\r\n        swapCreator = msg.sender;\r\n    }\r\n\r\n    function changeSwapCreator(address _newCreator) public onlyOwner {\r\n        swapCreator = _newCreator;\r\n        emit SwapCreatorChanged(msg.sender, _newCreator);\r\n    }\r\n\r\n    modifier onlySwapCreator() {\r\n        require(msg.sender == swapCreator, \"only the swap creator can call this\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\ncontract AssetAdapterWithFees is Ownable, AssetAdapter {\r\n\r\n    uint16 public feeThousandthsPercent;\r\n    uint256 public minFeeAmount;\r\n\r\n    constructor(uint16 _feeThousandthsPercent, uint256 _minFeeAmount) public {\r\n        require(_feeThousandthsPercent < (1 << 16), \"fee % too high\");\r\n        require(_minFeeAmount <= (1 << 255), \"minFeeAmount too high\");\r\n        feeThousandthsPercent = _feeThousandthsPercent;\r\n        minFeeAmount = _minFeeAmount;\r\n    }\r\n\r\n    function rawAccumulateFee(bytes memory assetData, uint256 _amount) internal;\r\n\r\n    function accumulateFee(bytes memory assetData) internal {\r\n        rawAccumulateFee(assetData, getFee(getAmount(assetData)));\r\n    }\r\n\r\n    function withdrawFees(\r\n        bytes calldata assetData,\r\n        address payable _to\r\n    ) external /*onlyOwner*/ returns (bool success);  // solium-disable-line indentation\r\n\r\n    function getFee(uint256 _amount) internal view returns (uint256) {\r\n        uint256 fee = _amount * feeThousandthsPercent / 100000;\r\n        return fee < minFeeAmount\r\n            ? minFeeAmount\r\n            : fee;\r\n    }\r\n\r\n    function getAmountWithFee(bytes memory assetData) internal view returns (uint256) {\r\n        uint256 baseAmount = getAmount(assetData);\r\n        return baseAmount + getFee(baseAmount);\r\n    }\r\n\r\n    function lockAssetWithFee(\r\n        bytes memory assetData,\r\n        address payable _from\r\n    ) internal returns (bool success) {\r\n        return rawLockAsset(getAmountWithFee(assetData), _from);\r\n    }\r\n\r\n    function sendAssetWithFee(\r\n        bytes memory assetData,\r\n        address payable _to\r\n    ) internal returns (bool success) {\r\n        return rawSendAsset(assetData, getAmountWithFee(assetData), _to);\r\n    }\r\n\r\n    function sendAssetKeepingFee(\r\n        bytes memory assetData,\r\n        address payable _to\r\n    ) internal returns (bool success) {\r\n        bool result = rawSendAsset(assetData, getAmount(assetData), _to);\r\n        if (result) accumulateFee(assetData);\r\n        return result;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * The main contract managing Ramp Swaps escrows lifecycle: create, release or return.\r\n * Uses an abstract AssetAdapter to carry out the transfers and handle the particular asset data.\r\n * With a corresponding off-chain oracle protocol allows for atomic-swap-like transfer between\r\n * fiat currencies and crypto assets.\r\n *\r\n * @dev an active swap is represented by a hash of its details, mapped to its escrow expiration\r\n * timestamp. When the swap is created, its end time is set a given amount of time in the future\r\n * (but within {MIN,MAX}_SWAP_LOCK_TIME_S).\r\n * The hashed swap details are:\r\n *  * address pool: the `RampInstantPool` contract that sells the crypto asset;\r\n *  * address receiver: the user that buys the crypto asset;\r\n *  * address oracle: address of the oracle that handles this particular swap;\r\n *  * bytes assetData: description of the crypto asset, handled by an AssetAdapter;\r\n *  * bytes32 paymentDetailsHash: hash of the fiat payment details: account numbers, fiat value\r\n *    and currency, and the transfer reference (title), that can be verified off-chain.\r\n *\r\n * @author Ramp Network sp. z o.o.\r\n */\r\ncontract RampInstantEscrows\r\nis Ownable, WithStatus, WithOracles, WithSwapsCreator, AssetAdapterWithFees {\r\n\r\n    /// @dev contract version, defined in semver\r\n    string public constant VERSION = \"0.5.1\";\r\n\r\n    uint32 internal constant MIN_ACTUAL_TIMESTAMP = 1000000000;\r\n\r\n    /// @notice lock time limits for pool's assets, after which unreleased escrows can be returned\r\n    uint32 internal constant MIN_SWAP_LOCK_TIME_S = 24 hours;\r\n    uint32 internal constant MAX_SWAP_LOCK_TIME_S = 30 days;\r\n\r\n    event Created(bytes32 indexed swapHash);\r\n    event Released(bytes32 indexed swapHash);\r\n    event PoolReleased(bytes32 indexed swapHash);\r\n    event Returned(bytes32 indexed swapHash);\r\n    event PoolReturned(bytes32 indexed swapHash);\r\n\r\n    /**\r\n     * @notice Mapping from swap details hash to its end time (as a unix timestamp).\r\n     * After the end time the swap can be cancelled, and the funds will be returned to the pool.\r\n     */\r\n    mapping (bytes32 => uint32) internal swaps;\r\n\r\n    /**\r\n     * Swap creation, called by the Ramp Network. Checks swap parameters and ensures the crypto\r\n     * asset is locked on this contract.\r\n     *\r\n     * Emits a `Created` event with the swap hash.\r\n     */\r\n    function create(\r\n        address payable _pool,\r\n        address _receiver,\r\n        address _oracle,\r\n        bytes calldata _assetData,\r\n        bytes32 _paymentDetailsHash,\r\n        uint32 lockTimeS\r\n    )\r\n        external\r\n        statusAtLeast(Status.ACTIVE)\r\n        onlySwapCreator()\r\n        isOracle(_oracle)\r\n        checkAssetTypeAndData(_assetData, _pool)\r\n        returns\r\n        (bool success)\r\n    {\r\n        require(\r\n            lockTimeS >= MIN_SWAP_LOCK_TIME_S && lockTimeS <= MAX_SWAP_LOCK_TIME_S,\r\n            \"lock time outside limits\"\r\n        );\r\n        bytes32 swapHash = getSwapHash(\r\n            _pool, _receiver, _oracle, keccak256(_assetData), _paymentDetailsHash\r\n        );\r\n        requireSwapNotExists(swapHash);\r\n        // Set up swap status before transfer, to avoid reentrancy attacks.\r\n        // Even if a malicious token is somehow passed to this function (despite the oracle\r\n        // signature of its details), the state of this contract is already fully updated,\r\n        // so it will behave correctly (as it would be a separate call).\r\n        // solium-disable-next-line security/no-block-members\r\n        swaps[swapHash] = uint32(block.timestamp) + lockTimeS;\r\n        require(\r\n            lockAssetWithFee(_assetData, _pool),\r\n            \"escrow lock failed\"\r\n        );\r\n        emit Created(swapHash);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Swap release, which transfers the crypto asset to the receiver and removes the swap from\r\n     * the active swap mapping. Normally called by the swap's oracle after it confirms a matching\r\n     * wire transfer on pool's bank account. Can be also called by the pool, for example in case\r\n     * of a dispute, when the parties reach an agreement off-chain.\r\n     *\r\n     * Emits a `Released` or `PoolReleased` event with the swap's hash.\r\n     */\r\n    function release(\r\n        address _pool,\r\n        address payable _receiver,\r\n        address _oracle,\r\n        bytes calldata _assetData,\r\n        bytes32 _paymentDetailsHash\r\n    ) external statusAtLeast(Status.FINALIZE_ONLY) onlyOracleOrPool(_pool, _oracle) {\r\n        bytes32 swapHash = getSwapHash(\r\n            _pool, _receiver, _oracle, keccak256(_assetData), _paymentDetailsHash\r\n        );\r\n        requireSwapCreated(swapHash);\r\n        // Delete the swap status before transfer, to avoid reentrancy attacks.\r\n        swaps[swapHash] = 0;\r\n        require(\r\n            sendAssetKeepingFee(_assetData, _receiver),\r\n            \"asset release failed\"\r\n        );\r\n        if (msg.sender == _pool) {\r\n            emit PoolReleased(swapHash);\r\n        } else {\r\n            emit Released(swapHash);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Swap return, which transfers the crypto asset back to the pool and removes the swap from\r\n     * the active swap mapping. Can be called by the pool or the swap's oracle, but only if the\r\n     * escrow lock time expired.\r\n     *\r\n     * Emits a `Returned` or `PoolReturned` event with the swap's hash.\r\n     */\r\n    function returnFunds(\r\n        address payable _pool,\r\n        address _receiver,\r\n        address _oracle,\r\n        bytes calldata _assetData,\r\n        bytes32 _paymentDetailsHash\r\n    ) external statusAtLeast(Status.RETURN_ONLY) onlyOracleOrPool(_pool, _oracle) {\r\n        bytes32 swapHash = getSwapHash(\r\n            _pool, _receiver, _oracle, keccak256(_assetData), _paymentDetailsHash\r\n        );\r\n        requireSwapExpired(swapHash);\r\n        // Delete the swap status before transfer, to avoid reentrancy attacks.\r\n        swaps[swapHash] = 0;\r\n        require(\r\n            sendAssetWithFee(_assetData, _pool),\r\n            \"asset return failed\"\r\n        );\r\n        if (msg.sender == _pool) {\r\n            emit PoolReturned(swapHash);\r\n        } else {\r\n            emit Returned(swapHash);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given all valid swap details, returns its status. The return can be:\r\n     * 0: the swap details are invalid, swap doesn't exist, or was already released/returned.\r\n     * >1: the swap was created, and the value is a timestamp indicating end of its lock time.\r\n     */\r\n    function getSwapStatus(\r\n        address _pool,\r\n        address _receiver,\r\n        address _oracle,\r\n        bytes calldata _assetData,\r\n        bytes32 _paymentDetailsHash\r\n    ) external view returns (uint32 status) {\r\n        bytes32 swapHash = getSwapHash(\r\n            _pool, _receiver, _oracle, keccak256(_assetData), _paymentDetailsHash\r\n        );\r\n        return swaps[swapHash];\r\n    }\r\n\r\n    /**\r\n     * Calculates the swap hash used to reference the swap in this contract's storage.\r\n     */\r\n    function getSwapHash(\r\n        address _pool,\r\n        address _receiver,\r\n        address _oracle,\r\n        bytes32 assetHash,\r\n        bytes32 _paymentDetailsHash\r\n    ) internal pure returns (bytes32) {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                _pool, _receiver, _oracle, assetHash, _paymentDetailsHash\r\n            )\r\n        );\r\n    }\r\n\r\n    function requireSwapNotExists(bytes32 swapHash) internal view {\r\n        require(\r\n            swaps[swapHash] == 0,\r\n            \"swap already exists\"\r\n        );\r\n    }\r\n\r\n    function requireSwapCreated(bytes32 swapHash) internal view {\r\n        require(\r\n            swaps[swapHash] > MIN_ACTUAL_TIMESTAMP,\r\n            \"swap invalid\"\r\n        );\r\n    }\r\n\r\n    function requireSwapExpired(bytes32 swapHash) internal view {\r\n        require(\r\n            // solium-disable-next-line security/no-block-members\r\n            swaps[swapHash] > MIN_ACTUAL_TIMESTAMP && block.timestamp > swaps[swapHash],\r\n            \"swap not expired or invalid\"\r\n        );\r\n    }\r\n\r\n}\r\n\r\ncontract EthAdapter is AssetAdapterWithFees {\r\n\r\n    uint16 internal constant ETH_TYPE_ID = 1;\r\n    uint16 internal constant ETH_ASSET_DATA_LENGTH = 34;\r\n    uint256 internal accumulatedFees = 0;\r\n\r\n    constructor() internal AssetAdapter(ETH_TYPE_ID) {}\r\n\r\n    /**\r\n    * @dev eth assetData bytes contents:\r\n    * offset length type     contents\r\n    * +00    32     uint256  data length (== 0x22 == 34 bytes)\r\n    * +32     2     uint16   asset type  (== ETH_TYPE_ID == 1)\r\n    * +34    32     uint256  ether amount in wei\r\n    */\r\n    function getAmount(bytes memory assetData) internal pure returns (uint256 amount) {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            amount := mload(add(assetData, 34))\r\n        }\r\n    }\r\n\r\n    function rawSendAsset(\r\n        bytes memory /*assetData*/,\r\n        uint256 _amount,\r\n        address payable _to\r\n    ) internal returns (bool success) {\r\n        // To enable more complex purchase receiver contracts, we're using `call.value(...)` instead\r\n        // of plain `transfer(...)`, which allows only 2300 gas to be used by the fallback function.\r\n        // This works for transfers to plain accounts too, no need to check if it's a contract.\r\n        // solium-disable-next-line security/no-call-value\r\n        (bool transferSuccessful,) = _to.call.value(_amount)(\"\");\r\n        require(transferSuccessful, \"eth transfer failed\");\r\n        return true;\r\n    }\r\n\r\n    function rawAccumulateFee(bytes memory /*assetData*/, uint256 _amount) internal {\r\n        accumulatedFees += _amount;\r\n    }\r\n\r\n    function withdrawFees(\r\n        bytes calldata /*assetData*/,\r\n        address payable _to\r\n    ) external onlyOwner returns (bool success) {\r\n        uint256 fees = accumulatedFees;\r\n        accumulatedFees = 0;\r\n        _to.transfer(fees);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * This adapter can receive eth payments, but no other use of the fallback function is allowed.\r\n     */\r\n    function () external payable {\r\n        require(msg.data.length == 0, \"invalid method called\");\r\n    }\r\n\r\n    function checkAssetData(bytes memory assetData, address /*_pool*/) internal view {\r\n        require(assetData.length == ETH_ASSET_DATA_LENGTH, \"invalid asset data length\");\r\n    }\r\n\r\n}\r\n\r\ncontract RampInstantEthEscrows is RampInstantEscrows, EthAdapter {\r\n\r\n    constructor(\r\n        uint16 _feeThousandthsPercent,\r\n        uint256 _minFeeAmount\r\n    ) public AssetAdapterWithFees(_feeThousandthsPercent, _minFeeAmount) {}\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_oracle\",\"type\":\"address\"},{\"name\":\"_assetData\",\"type\":\"bytes\"},{\"name\":\"_paymentDetailsHash\",\"type\":\"bytes32\"},{\"name\":\"lockTimeS\",\"type\":\"uint32\"}],\"name\":\"create\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeThousandthsPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCreator\",\"type\":\"address\"}],\"name\":\"changeSwapCreator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_status\",\"type\":\"uint8\"}],\"name\":\"setStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"revokeOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ASSET_TYPE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_oracle\",\"type\":\"address\"},{\"name\":\"_assetData\",\"type\":\"bytes\"},{\"name\":\"_paymentDetailsHash\",\"type\":\"bytes32\"}],\"name\":\"getSwapStatus\",\"outputs\":[{\"name\":\"status\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_oracle\",\"type\":\"address\"},{\"name\":\"_assetData\",\"type\":\"bytes\"},{\"name\":\"_paymentDetailsHash\",\"type\":\"bytes32\"}],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_oracle\",\"type\":\"address\"},{\"name\":\"_assetData\",\"type\":\"bytes\"},{\"name\":\"_paymentDetailsHash\",\"type\":\"bytes32\"}],\"name\":\"returnFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"bytes\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawFees\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"approveOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minFeeAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_feeThousandthsPercent\",\"type\":\"uint16\"},{\"name\":\"_minFeeAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"name\":\"Released\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"name\":\"PoolReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"name\":\"Returned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"name\":\"PoolReturned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldCreator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newCreator\",\"type\":\"address\"}],\"name\":\"SwapCreatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldStatus\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"newStatus\",\"type\":\"uint8\"}],\"name\":\"StatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"}]","ContractName":"RampInstantEthEscrows","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"420","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000003e80000000000000000000000000000000000000000000000000000000000000064","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://f0b9e282cb525222a60a3d79edaf8056b462d7ac7dba4030b983db61f70fc68b"}]}